/*
 * Teleport
 * Copyright (C) 2024  Gravitational, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package cli

import (
	"log/slog"
	"testing"

	"github.com/alecthomas/kingpin/v2"
	"github.com/stretchr/testify/require"

	"github.com/gravitational/teleport/api/types"
	"github.com/gravitational/teleport/lib/tbot/config"
	"github.com/gravitational/teleport/lib/utils"
)

func buildMinimalKingpinApp(subcommandName string) (app *kingpin.Application, subcommand *kingpin.CmdClause) {
	app = utils.InitCLIParser("tbot", "test").Interspersed(false)
	subcommand = app.Command(subcommandName, "subcommand")

	return
}

func TestConfigCLIOnlySample(t *testing.T) {
	// Test the sample config generated by `tctl bots add ...`
	legacy := &LegacyCommand{
		LegacyDestinationDirArgs: &LegacyDestinationDirArgs{
			DestinationDir: "/tmp/foo",
		},
		AuthProxyArgs: NewStaticAuthServer("auth.example.com"),
		Token:         "foo",
		CAPins:        []string{"abc123"},
		DiagAddr:      "127.0.0.1:1337",
		JoinMethod:    string(types.JoinMethodToken),
	}

	cfg, err := LoadConfigWithMutators(&GlobalArgs{
		Debug: true,
	}, legacy)
	require.NoError(t, err)

	require.Equal(t, legacy.AuthServer, cfg.AuthServer)

	require.NotNil(t, cfg.Onboarding)

	token, err := cfg.Onboarding.Token()
	require.NoError(t, err)
	require.Equal(t, legacy.Token, token)
	require.Equal(t, legacy.CAPins, cfg.Onboarding.CAPins)

	// Storage is still default
	storageImpl, ok := cfg.Storage.Destination.(*config.DestinationDirectory)
	require.True(t, ok)
	require.Equal(t, config.GetDefaultStoragePath(), storageImpl.Path)

	// A single default Destination should exist
	require.Len(t, cfg.Services, 1)
	output := cfg.Services[0]
	identOutput, ok := output.(*config.IdentityOutput)
	require.True(t, ok)

	destImpl := identOutput.GetDestination()
	require.NoError(t, err)
	destImplReal, ok := destImpl.(*config.DestinationDirectory)
	require.True(t, ok)

	require.Equal(t, legacy.DestinationDir, destImplReal.Path)
	require.True(t, cfg.Debug)
	require.Equal(t, legacy.DiagAddr, cfg.DiagAddr)
}

type basicCommand interface {
	TryRun(cmd string) (match bool, err error)
}

type testCommandCase[O any] struct {
	name   string
	args   []string
	assert func(t *testing.T, output O)
}

func testCommand[T basicCommand](
	t *testing.T,
	newCommand func(parentCommand KingpinClause, action func(T) error) T,
	testCases []testCommandCase[T],
) {
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			app, _ := buildMinimalKingpinApp("sub")
			actionCalled := false
			var actionCalledOutput T
			cmd := newCommand(app, func(output T) error {
				actionCalled = true
				actionCalledOutput = output
				return nil
			})

			command, err := app.Parse(tt.args)
			require.NoError(t, err)

			match, err := cmd.TryRun(command)
			require.NoError(t, err)
			require.True(t, match)

			require.True(t, actionCalled)

			tt.assert(t, actionCalledOutput)
		})
	}
}

type startConfigureCommand interface {
	ApplyConfig(cfg *config.BotConfig, l *slog.Logger) error
	basicCommand
}

type startConfigureTestCase struct {
	name         string
	args         []string
	assertConfig func(t *testing.T, cfg *config.BotConfig)
}

func testStartConfigureCommand[T startConfigureCommand](
	t *testing.T,
	newCommand func(parentCmd *kingpin.CmdClause, action MutatorAction, mode CommandMode) T,
	testCases []startConfigureTestCase,
) {
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			app, subcommand := buildMinimalKingpinApp("start")
			actionCalled := false
			cmd := newCommand(subcommand, func(mut ConfigMutator) error {
				actionCalled = true
				return nil
			}, CommandModeStart)

			command, err := app.Parse(tt.args)
			require.NoError(t, err)

			match, err := cmd.TryRun(command)
			require.NoError(t, err)
			require.True(t, match)

			require.True(t, actionCalled)

			// Convert these args to a BotConfig and check it.
			cfg, err := LoadConfigWithMutators(&GlobalArgs{}, cmd)
			require.NoError(t, err)

			tt.assertConfig(t, cfg)
		})
	}
}
