/*
Copyright 2023 Gravitational, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package upgradewindow

import (
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/gravitational/teleport/api/types"
	"github.com/gravitational/teleport/lib/utils"
)

type kubeScheduleRepr struct {
	Windows []windowRepr `json:"windows"`
}

type windowRepr struct {
	Start time.Time `json:"start"`
	Stop  time.Time `json:"stop"`
}

// windowRef is a known-good reference value used in checking consistent agent window encoding.
const windowRef = `{"windows":[{"start":"2023-03-28T02:00:00Z","stop":"2023-03-28T03:00:00Z"},{"start":"2023-03-29T02:00:00Z","stop":"2023-03-29T03:00:00Z"},{"start":"2023-03-30T02:00:00Z","stop":"2023-03-30T03:00:00Z"}]}`

// TestKubeControllerScheduleBasics performs a basic check comparing the agent upgrade schedule and our locally
// defined expected format in terms of a known good schedule value.
func TestKubeControllerScheduleBasics(t *testing.T) {
	t.Parallel()

	var sched types.AgentUpgradeSchedule
	err := utils.FastUnmarshal([]byte(windowRef), &sched)
	require.NoError(t, err)
	require.Len(t, sched.Windows, 3)

	var repr kubeScheduleRepr
	err = utils.FastUnmarshal([]byte(windowRef), &repr)
	require.NoError(t, err)
	require.Len(t, repr.Windows, 3)

	// ensure that times are equivalent
	for i := 0; i < 3; i++ {
		require.False(t, repr.Windows[i].Start.IsZero())
		require.False(t, repr.Windows[i].Stop.IsZero())

		require.Equal(t, repr.Windows[i].Start, sched.Windows[i].Start)
		require.Equal(t, repr.Windows[i].Stop, sched.Windows[i].Stop)
	}

	// encode the schedule value
	s, err := EncodeKubeControllerSchedule(sched)
	require.NoError(t, err)

	// decode as expected repr
	var repr2 kubeScheduleRepr
	err = utils.FastUnmarshal([]byte(s), &repr2)
	require.NoError(t, err)

	// ensure equality holds
	require.Equal(t, repr, repr2)
}

// FuzzKubeControllerSchedule does some fuzzy verification of schedule encoding/decoding
// to ensure that EncodeKubeControllerSchedule maintains compatibility with expected json repr.
func FuzzKubeControllerSchedule(f *testing.F) {
	f.Fuzz(func(t *testing.T, start, stop uint32) {
		startTime := time.Unix(int64(start), 0)
		stopTime := time.Unix(int64(stop), 0)

		sched := types.AgentUpgradeSchedule{
			Windows: []types.ScheduledAgentUpgradeWindow{
				{
					Start: startTime,
					Stop:  stopTime,
				},
			},
		}

		expect := kubeScheduleRepr{
			Windows: []windowRepr{
				{
					Start: startTime,
					Stop:  stopTime,
				},
			},
		}

		s, err := EncodeKubeControllerSchedule(sched)
		require.NoError(t, err)

		var repr kubeScheduleRepr
		err = utils.FastUnmarshal([]byte(s), &repr)
		require.NoError(t, err)

		require.Equal(t, expect, repr)
	})
}

// TestSystemdUnitSchedule verifies basic behavior of systemd unit schedule encoding.
func TestSystemdUnitSchedule(t *testing.T) {
	t.Parallel()

	tts := []struct {
		desc     string
		schedule types.AgentUpgradeSchedule
		expect   string
		err      bool
	}{
		{
			desc: "empty window case",
			err:  true,
		},
		{
			desc: "basic single-window case",
			schedule: types.AgentUpgradeSchedule{
				Windows: []types.ScheduledAgentUpgradeWindow{
					{
						Start: time.Unix(100, 0),
						Stop:  time.Unix(200, 0),
					},
				},
			},

			expect: "# generated by teleport\n100 200\n",
		},
		{
			desc: "normal multi-window case",
			schedule: types.AgentUpgradeSchedule{
				Windows: []types.ScheduledAgentUpgradeWindow{
					{
						Start: time.Unix(500000, 0),
						Stop:  time.Unix(600000, 0),
					},
					{
						Start: time.Unix(700000, 0),
						Stop:  time.Unix(800000, 0),
					},
					{
						Start: time.Unix(900000, 0),
						Stop:  time.Unix(1000000, 0),
					},
				},
			},

			expect: "# generated by teleport\n500000 600000\n700000 800000\n900000 1000000\n",
		},
	}

	for _, tt := range tts {
		s, err := EncodeSystemdUnitSchedule(tt.schedule)
		if tt.err {
			require.Error(t, err, "desc=%q", tt.desc)
			continue
		}
		require.NoError(t, err, "desc=%q", tt.desc)
		require.Equal(t, tt.expect, s, "desc=%q", tt.desc)
	}
}
