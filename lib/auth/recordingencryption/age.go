package recordingencryption

import (
	"filippo.io/age"
	"github.com/gravitational/trace"

	"github.com/gravitational/teleport/api/types"
)

// X25519Stanza is the default stanza type used by age.
const X25519Stanza = "X25519"

// RecordingStanza is the type used for the identifying stanza added by RecordingRecipient.
const RecordingStanza = "Recording-X25519"

// DecryptionKeyFinder returns the first EncryptionKeyPair related to one of the given public keys.
type DecryptionKeyFinder interface {
	FindDecryptionKey(publicKeys ...[]byte) (*types.EncryptionKeyPair, error)
}

// RecordingIdentity removes public keys from stanzas and passes the unwrap call to the default
// age.X25519Identity.
type RecordingIdentity struct {
	keyFinder DecryptionKeyFinder
}

// NewRecordingIdentity returns a RecordingIdentity that will use the given DecryptionKeyFinder in order to facilitate
// file key unwrapping.
func NewRecordingIdentity(keyFinder DecryptionKeyFinder) *RecordingIdentity {
	return &RecordingIdentity{
		keyFinder: keyFinder,
	}
}

// Unwrap uses the additional stanzas added by RecordingRecipient.Wrap in order to find a matching X25519 identity.
func (i *RecordingIdentity) Unwrap(stanzas []*age.Stanza) ([]byte, error) {
	var publicKeys [][]byte
	for _, stanza := range stanzas {
		if stanza.Type != RecordingStanza {
			continue
		}

		if len(stanza.Args) != 1 {
			continue
		}

		publicKeys = append(publicKeys, []byte(stanza.Args[0]))
	}

	pair, err := i.keyFinder.FindDecryptionKey(publicKeys...)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	identity, err := age.ParseX25519Identity(string(pair.PrivateKey))
	if err != nil {
		return nil, trace.Wrap(err)
	}

	return identity.Unwrap(stanzas)
}

// RecordingRecipient adds the public key to the stanzas generated by the default age.X25519Recipient
type RecordingRecipient struct {
	*age.X25519Recipient
}

// ParseRecordingRecipient parses an Bech32 encoded age X25519 public key into a RecordingRecipient.
func ParseRecordingRecipient(s string) (*RecordingRecipient, error) {
	recipient, err := age.ParseX25519Recipient(s)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	return &RecordingRecipient{X25519Recipient: recipient}, nil
}

// Wrap a fileKey using the wrapped X2519Recipient. An additional stanza containing the bech32 encoded X25519
// public key will be created to enable lookups during Unwrap.
func (r *RecordingRecipient) Wrap(fileKey []byte) ([]*age.Stanza, error) {
	stanzas, err := r.X25519Recipient.Wrap(fileKey)
	if err != nil {
		return nil, trace.Wrap(err)
	}

	// a new stanza has to be added because modifying the original stanza and returning it to "normal" during
	// Unwrap fails due to MAC errors
	for _, stanza := range stanzas {
		if stanza.Type == X25519Stanza {
			stanzas = append(stanzas, &age.Stanza{
				Type: RecordingStanza,
				Args: []string{r.String()},
			})
		}
	}

	return stanzas, nil
}
