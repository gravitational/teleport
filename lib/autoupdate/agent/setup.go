/*
 * Teleport
 * Copyright (C) 2024  Gravitational, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package agent

import (
	"bytes"
	"context"
	"errors"
	"io/fs"
	"log/slog"
	"os"
	"path/filepath"
	"regexp"
	"text/template"

	"github.com/google/renameio/v2"
	"github.com/gravitational/trace"

	"github.com/gravitational/teleport/lib/defaults"
)

// Base paths for constructing namespaced directories.
const (
	teleportOptDir   = "/opt/teleport"
	versionsDirName  = "versions"
	systemdAdminDir  = "/etc/systemd/system"
	systemdPIDFile   = "/run/teleport.pid"
	defaultNamespace = "default"
	systemNamespace  = "system"
	lockFileName     = "update.lock"
)

const (
	updateServiceTemplate = `# teleport-update
# DO NOT EDIT THIS FILE
[Unit]
Description=Teleport auto-update service

[Service]
Type=oneshot
ExecStart={{.UpdaterCommand}}
`
	updateTimerTemplate = `# teleport-update
# DO NOT EDIT THIS FILE
[Unit]
Description=Teleport auto-update timer unit

[Timer]
OnActiveSec=1m
OnUnitActiveSec=5m
RandomizedDelaySec=1m

[Install]
WantedBy={{.TeleportService}}
`
)

// Namespace represents a namespace within various system paths for a isolated installation of Teleport.
type Namespace struct {
	log *slog.Logger
	// name of namespace
	name string
	// dataDir for Teleport
	dataDir string
	// linkDir for Teleport binaries (ns: /opt/teleport/myns/bin)
	linkDir string
	// versionsDir for Teleport versions (ns: /opt/teleport/myns/versions)
	versionsDir string
	// serviceFile for the Teleport systemd service (ns: /etc/systemd/system/teleport_myns.service)
	serviceFile string
	// configFile for Teleport config (ns: /opt/teleport/myns/etc/teleport.yaml)
	configFile string
	// pidFile for Teleport (ns: /run/teleport_myns.pid)
	pidFile string
	// updaterLockFile for locking the updater (ns: /opt/teleport/myns/update.lock)
	updaterLockFile string
	// updaterConfigFile for configuring updates (ns: /opt/teleport/myns/update.yaml)
	updaterConfigFile string
	// updaterBinFile for the updater when linked (linkDir + name)
	updaterBinFile string
	// updaterServiceFile is the systemd service path for the updater
	updaterServiceFile string
	// updaterTimerFile is the systemd timer path for the updater
	updaterTimerFile string
}

var alphanum = regexp.MustCompile("^[a-zA-Z0-9-]*$")

// NewNamespace validates and returns a Namespace.
// Namespaces must be alphanumeric + `-`.
func NewNamespace(log *slog.Logger, name, dataDir, linkDir string) (*Namespace, error) {
	if name == defaultNamespace ||
		name == systemNamespace {
		return nil, trace.Errorf("namespace %q is reserved", name)
	}
	if !alphanum.MatchString(name) {
		return nil, trace.Errorf("invalid namespace name %q, must be alphanumeric", name)
	}
	if name == "" {
		if dataDir == "" {
			dataDir = defaults.DataDir
		}
		if linkDir == "" {
			linkDir = DefaultLinkDir
		}
		return &Namespace{
			log:                log,
			name:               name,
			dataDir:            dataDir,
			linkDir:            linkDir,
			versionsDir:        filepath.Join(namespaceDir(name), versionsDirName),
			serviceFile:        filepath.Join("/", serviceDir, serviceName),
			configFile:         defaults.ConfigFilePath,
			pidFile:            systemdPIDFile,
			updaterLockFile:    filepath.Join(namespaceDir(name), lockFileName),
			updaterConfigFile:  filepath.Join(namespaceDir(name), updateConfigName),
			updaterBinFile:     filepath.Join(linkDir, BinaryName),
			updaterServiceFile: filepath.Join(systemdAdminDir, BinaryName+".service"),
			updaterTimerFile:   filepath.Join(systemdAdminDir, BinaryName+".timer"),
		}, nil
	}

	prefix := "teleport_" + name
	if dataDir == "" {
		dataDir = filepath.Join(filepath.Dir(defaults.DataDir), prefix)
	}
	if linkDir == "" {
		linkDir = filepath.Join(namespaceDir(name), "bin")
	}
	return &Namespace{
		log:                log,
		name:               name,
		dataDir:            dataDir,
		linkDir:            linkDir,
		versionsDir:        filepath.Join(namespaceDir(name), versionsDirName),
		serviceFile:        filepath.Join(systemdAdminDir, prefix+".service"),
		configFile:         filepath.Join(filepath.Dir(defaults.ConfigFilePath), prefix+".yaml"),
		pidFile:            filepath.Join(filepath.Dir(systemdPIDFile), prefix+".pid"),
		updaterLockFile:    filepath.Join(namespaceDir(name), lockFileName),
		updaterConfigFile:  filepath.Join(namespaceDir(name), updateConfigName),
		updaterBinFile:     filepath.Join(linkDir, BinaryName),
		updaterServiceFile: filepath.Join(systemdAdminDir, BinaryName+"_"+name+".service"),
		updaterTimerFile:   filepath.Join(systemdAdminDir, BinaryName+"_"+name+".timer"),
	}, nil
}

func namespaceDir(name string) string {
	if name == "" {
		name = defaultNamespace
	}
	return filepath.Join(teleportOptDir, name)
}

// Init create the initial directory structure and returns the lockfile for a Namespace.
func (ns *Namespace) Init() (lockFile string, err error) {
	if err := os.MkdirAll(ns.versionsDir, systemDirMode); err != nil {
		return "", trace.Wrap(err)
	}
	return ns.updaterLockFile, nil
}

// Setup installs service and timer files for the teleport-update binary.
// Afterwords, Setup reloads systemd and enables the timer with --now.
func (ns *Namespace) Setup(ctx context.Context) error {
	err := ns.writeConfigFiles()
	if err != nil {
		return trace.Errorf("failed to write teleport-update systemd config files: %w", err)
	}
	svc := &SystemdService{
		ServiceName: filepath.Base(ns.updaterTimerFile),
		Log:         ns.log,
	}
	if err := svc.Sync(ctx); err != nil {
		return trace.Errorf("failed to sync systemd config: %w", err)
	}
	if err := svc.Enable(ctx, true); err != nil {
		return trace.Errorf("failed to enable teleport-update systemd timer: %w", err)
	}
	return nil
}

// Teardown removes all traces of the auto-updater, including its configuration.
func (ns *Namespace) Teardown(ctx context.Context) error {
	svc := &SystemdService{
		ServiceName: filepath.Base(ns.updaterTimerFile),
		Log:         ns.log,
	}
	if err := svc.Disable(ctx); err != nil {
		return trace.Errorf("failed to disable teleport-update systemd timer: %w", err)
	}
	if err := os.Remove(ns.updaterServiceFile); err != nil && !errors.Is(err, fs.ErrNotExist) {
		return trace.Errorf("failed to remove teleport-update systemd service: %w", err)
	}
	if err := os.Remove(ns.updaterTimerFile); err != nil && !errors.Is(err, fs.ErrNotExist) {
		return trace.Errorf("failed to remove teleport-update systemd timer: %w", err)
	}
	if err := svc.Sync(ctx); err != nil {
		return trace.Errorf("failed to sync systemd config: %w", err)
	}
	if err := os.RemoveAll(ns.versionsDir); err != nil {
		return trace.Errorf("failed to remove versions directory: %w", err)
	}
	return nil
}

func (ns *Namespace) writeConfigFiles() error {
	var args string
	if ns.name != "" {
		args = " --install-suffix=" + ns.name
	}
	err := writeTemplate(
		ns.updaterServiceFile, updateServiceTemplate,
		struct{ UpdaterCommand string }{
			ns.updaterBinFile + args + " update",
		},
	)
	if err != nil {
		return trace.Wrap(err)
	}
	err = writeTemplate(
		ns.updaterTimerFile, updateTimerTemplate,
		struct{ TeleportService string }{filepath.Base(ns.serviceFile)},
	)
	if err != nil {
		return trace.Wrap(err)
	}
	return nil
}

func writeTemplate(path, t string, values any) error {
	dir, file := filepath.Split(path)
	if err := os.MkdirAll(dir, systemDirMode); err != nil {
		return trace.Wrap(err)
	}
	opts := []renameio.Option{
		renameio.WithPermissions(configFileMode),
		renameio.WithExistingPermissions(),
	}
	f, err := renameio.NewPendingFile(path, opts...)
	if err != nil {
		return trace.Wrap(err)
	}
	defer f.Cleanup()

	tmpl, err := template.New(file).Parse(t)
	if err != nil {
		return trace.Wrap(err)
	}
	err = tmpl.Execute(f, values)
	if err != nil {
		return trace.Wrap(err)
	}
	return trace.Wrap(f.CloseAtomicallyReplace())
}

// replaceTeleportService replaces the default paths in the Teleport service config with namespaced paths.
func (ns *Namespace) replaceTeleportService(cfg []byte) []byte {
	for _, rep := range []struct {
		old, new string
	}{
		{
			old: "/usr/local/bin/",
			new: ns.linkDir + "/",
		},
		{
			old: "/etc/teleport.yaml",
			new: ns.configFile,
		},
		{
			old: "/run/teleport.pid",
			new: ns.pidFile,
		},
	} {
		cfg = bytes.ReplaceAll(cfg, []byte(rep.old), []byte(rep.new))
	}
	return cfg
}

func (ns *Namespace) LogWarning(ctx context.Context) {
	ns.log.WarnContext(ctx, "Custom install suffix specified. Teleport data_dir must be configured in the config file.",
		"data_dir", ns.dataDir,
		"path", ns.linkDir,
		"config", ns.configFile,
		"service", filepath.Base(ns.serviceFile),
		"pid", ns.pidFile,
	)
}
