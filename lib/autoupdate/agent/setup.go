/*
 * Teleport
 * Copyright (C) 2024  Gravitational, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package agent

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/gravitational/trace"
	"gopkg.in/yaml.v3"

	"github.com/gravitational/teleport"
	"github.com/gravitational/teleport/lib/autoupdate"
	"github.com/gravitational/teleport/lib/config/systemd"
	"github.com/gravitational/teleport/lib/defaults"
	"github.com/gravitational/teleport/lib/selinux"
	tbotsystemd "github.com/gravitational/teleport/lib/tbot/config/systemd"
	libutils "github.com/gravitational/teleport/lib/utils"
	"github.com/gravitational/teleport/lib/versioncontrol"
)

// Base paths for constructing namespaced directories.
const (
	defaultInstallDir  = "/opt/teleport"
	defaultPathDir     = "/usr/local/bin"
	systemdAdminDir    = "/etc/systemd/system"
	systemdPIDDir      = "/run"
	needrestartConfDir = "/etc/needrestart/conf.d"
	versionsDirName    = "versions"
	lockFileName       = "update.lock"
	defaultNamespace   = "default"
	systemNamespace    = "system"
)

const (
	// deprecatedTimerName is the timer for the deprecated upgrader should be disabled on setup.
	deprecatedTimerName = "teleport-upgrade.timer"
	// deprecatedServiceName is the service for the deprecated upgrader should be disabled on setup.
	deprecatedServiceName = "teleport-upgrade.service"
)

const markerPrefix = "# teleport-update "

// genMarker generates a systemd config file marker that is the
// first part of the header for systemd service files.
// Each revision of Teleport has a unique marker.
func genMarker(rev Revision) string {
	return markerPrefix + rev.Dir() + "\n"
}

// genHeader generates a systemd config file header that starts
// with the serviceMarker.
func genHeader(rev Revision) string {
	return genMarker(rev) +
		"# DO NOT EDIT THIS FILE\n"
}

const (
	updateServiceTemplate = `
[Unit]
Description=Teleport auto-update service

[Service]
Type=oneshot
ExecStart={{.UpdaterBinary}} --install-suffix={{.InstallSuffix}} "--install-dir={{escape .InstallDir}}" update
`
	updateTimerTemplate = `
[Unit]
Description=Teleport auto-update timer unit

[Timer]
OnActiveSec=1m
OnUnitActiveSec=5m
RandomizedDelaySec=1m

[Install]
WantedBy={{.TeleportService}}
`
	teleportDropInTemplate = `
[Service]
Environment="TELEPORT_UPDATE_CONFIG_FILE={{escape .UpdaterConfigFile}}"
Environment="TELEPORT_UPDATE_INSTALL_DIR={{escape .InstallDir}}"
`

	deprecatedDropInTemplate = `
[Service]
ExecStart=
ExecStart=-/bin/echo "The teleport-upgrade script has been disabled by teleport-update. Please remove the teleport-ent-updater package."
`

	// This configuration sets the default value for needrestart-trigger automatic restarts for teleport.service to disabled.
	// Users may still choose to enable needrestart for teleport.service when installing packaging interactively (or via dpkg config),
	// but doing so will result in a hard restart that disconnects the agent whenever any dependent libraries are updated.
	// Other network services, like openvpn, follow this pattern.
	// It is possible to configure needrestart to trigger a soft restart (via restart.d script), but given that Teleport subprocesses
	// can use a wide variety of installed binaries (when executed by the user), this could trigger many unexpected reloads.
	needrestartConfTemplate = `{{range .Services}}$nrconf{override_rc}{qr(^{{replace . "." "\\."}})} = 0;
{{end}}`
)

// systemdParams parameterizes the above updater systemd configuration templates.
type systemdParams struct {
	TeleportService   string
	Services          []string
	UpdaterBinary     string
	InstallSuffix     string
	InstallDir        string
	Path              string
	UpdaterConfigFile string
}

// standard Makefile included in 'selinux-policy-devel' RPM package
// used to build SELinux modules
const selinuxMakefile = "/usr/share/selinux/devel/Makefile"

// Namespace represents a namespace within various system paths for a isolated installation of Teleport.
type Namespace struct {
	log *slog.Logger
	// name of namespace
	name string
	// installDir for Teleport namespaces (/opt/teleport)
	installDir string
	// defaultPathDir for Teleport binaries (ns: /opt/teleport/myns/bin)
	defaultPathDir string
	// defaultProxyAddr parsed from teleport.yaml, if present
	defaultProxyAddr string
	// dataDir parsed from teleport.yaml, if present
	dataDir string
	// teleportServiceFile for the Teleport systemd service (ns: /etc/systemd/system/teleport_myns.service)
	teleportServiceFile string
	// teleportConfigFile for Teleport config (ns: /etc/teleport_myns.yaml)
	teleportConfigFile string
	// teleportPIDFile for Teleport (ns: /run/teleport_myns.pid)
	teleportPIDFile string
	// teleportDropInFile is the Teleport systemd drop-in path extending Teleport
	teleportDropInFile string
	// tbotServiceFile is the systemd service path for tbot (ns: /etc/systemd/system/tbot_myns.service)
	tbotServiceFile string
	// tbotConfigFile for tbot config (ns: /etc/tbot_myns.yaml)
	tbotConfigFile string
	// tbotPIDFile for tbot (ns: /run/tbot_myns.pid)
	tbotPIDFile string
	// updaterIDFile contains the updater's temporary ID file
	updaterIDFile string
	// updaterServiceFile is the systemd service path for the updater
	updaterServiceFile string
	// updaterTimerFile is the systemd timer path for the updater
	updaterTimerFile string
	// needrestartConfigFile is the path to needrestart configuration for all services
	needrestartConfigFile string
	// deprecatedDropInFile is the deprecated upgrader's systemd drop-in path
	deprecatedDropInFile string
}

var alphanum = regexp.MustCompile("^[a-zA-Z0-9-]*$")

// NewNamespace validates and returns a Namespace.
// Namespaces must be alphanumeric + `-`.
// defaultPathDir overrides the destination directory for namespace setup (i.e., /usr/local)
func NewNamespace(ctx context.Context, log *slog.Logger, name, installDir string) (ns *Namespace, err error) {
	defer func() { ns.overrideFromConfig(ctx) }()

	if name == defaultNamespace ||
		name == systemNamespace {
		return nil, trace.Errorf("namespace %s is reserved", name)
	}
	if !alphanum.MatchString(name) {
		return nil, trace.Errorf("invalid namespace name %s, must be alphanumeric", name)
	}
	if installDir == "" {
		installDir = defaultInstallDir
	}
	if name == "" {
		linkDir := defaultPathDir
		return &Namespace{
			log:                   log,
			name:                  name,
			installDir:            installDir,
			defaultPathDir:        linkDir,
			dataDir:               defaults.DataDir,
			teleportServiceFile:   filepath.Join("/", serviceDir, teleportServiceName), // /lib for backwards-compat
			teleportConfigFile:    defaults.ConfigFilePath,
			teleportPIDFile:       filepath.Join(systemdPIDDir, "teleport.pid"),
			needrestartConfigFile: filepath.Join(needrestartConfDir, BinaryName+".conf"),
			teleportDropInFile:    filepath.Join(systemdAdminDir, "teleport.service.d", BinaryName+".conf"),
			updaterIDFile:         filepath.Join(os.TempDir(), BinaryName+".id"),
			updaterServiceFile:    filepath.Join(systemdAdminDir, BinaryName+".service"),
			updaterTimerFile:      filepath.Join(systemdAdminDir, BinaryName+".timer"),
			deprecatedDropInFile:  filepath.Join(systemdAdminDir, deprecatedServiceName+".d", BinaryName+".conf"),
			tbotServiceFile:       filepath.Join(systemdAdminDir, "tbot.service"),
			tbotConfigFile:        filepath.Join("/etc", "tbot.yaml"),
			tbotPIDFile:           filepath.Join(systemdPIDDir, "tbot.pid"),
		}, nil
	}

	prefix := "teleport_" + name
	linkDir := filepath.Join(installDir, name, "bin")
	return &Namespace{
		log:                   log,
		name:                  name,
		installDir:            installDir,
		defaultPathDir:        linkDir,
		dataDir:               filepath.Join(filepath.Dir(defaults.DataDir), prefix),
		teleportServiceFile:   filepath.Join(systemdAdminDir, prefix+".service"),
		teleportConfigFile:    filepath.Join(filepath.Dir(defaults.ConfigFilePath), prefix+".yaml"),
		teleportPIDFile:       filepath.Join(systemdPIDDir, prefix+".pid"),
		needrestartConfigFile: filepath.Join(needrestartConfDir, BinaryName+"_"+name+".conf"),
		teleportDropInFile:    filepath.Join(systemdAdminDir, prefix+".service.d", BinaryName+"_"+name+".conf"),
		updaterIDFile:         filepath.Join(os.TempDir(), BinaryName+"_"+name+".id"),
		updaterServiceFile:    filepath.Join(systemdAdminDir, BinaryName+"_"+name+".service"),
		updaterTimerFile:      filepath.Join(systemdAdminDir, BinaryName+"_"+name+".timer"),
		tbotServiceFile:       filepath.Join(systemdAdminDir, "tbot_"+name+".service"),
		tbotConfigFile:        filepath.Join("/etc", "tbot_"+name+".yaml"),
		tbotPIDFile:           filepath.Join(systemdPIDDir, "tbot_"+name+".pid"),
		// no deprecatedDropInFile, as teleport-upgrade does not conflict with namespaced installs
	}, nil
}

func (ns *Namespace) Dir() string {
	name := ns.name
	if name == "" {
		name = defaultNamespace
	}
	return filepath.Join(ns.installDir, name)
}

// Init creates the initial directory structure and returns the lockfile for a Namespace.
// Init should be called before the namespace is locked.
func (ns *Namespace) Init() (lockFile string, err error) {
	if err := os.MkdirAll(filepath.Join(ns.Dir(), versionsDirName), systemDirMode); err != nil {
		return "", trace.Wrap(err)
	}
	return filepath.Join(ns.Dir(), lockFileName), nil
}

// Setup installs service and timer files for the teleport-update binary.
// Afterwords, Setup reloads systemd and enables the timer with --now.
func (ns *Namespace) Setup(ctx context.Context, path string, rev Revision, installSELinux bool) error {
	if installSELinux {
		if err := ns.installSELinux(ctx, rev); err != nil {
			ns.log.WarnContext(ctx, "Failed to install SELinux module.", errorKey, err)
		}
	} else {
		if err := ns.removeSELinux(ctx); err != nil {
			ns.log.WarnContext(ctx, "Failed to remove SELinux module.", errorKey, err)
		}
	}

	if ok, err := hasSystemD(); err == nil && !ok {
		ns.log.WarnContext(ctx, "Systemd is not running, skipping updater installation.")
		return nil
	}

	err := ns.writeConfigFiles(ctx, path, rev)
	if err != nil {
		return trace.Wrap(err, "failed to write teleport-update systemd config files")
	}
	timer := &SystemdService{
		ServiceName: filepath.Base(ns.updaterTimerFile),
		Log:         ns.log,
	}
	if err := timer.Sync(ctx); err != nil {
		return trace.Wrap(err, "failed to sync systemd config")
	}
	if err := timer.Enable(ctx, true); err != nil {
		return trace.Wrap(err, "failed to enable teleport-update systemd timer")
	}
	if ns.name == "" {
		oldTimer := &SystemdService{
			ServiceName: deprecatedTimerName,
			Log:         ns.log,
		}
		// If the old teleport-upgrade script is detected, disable it to ensure they do not interfere.
		// Note that the schedule is also set to nop by the Teleport agent -- this just prevents restarts.
		present, err := oldTimer.IsPresent(ctx)
		if errors.Is(err, ErrNotAvailable) { // systemd too old
			if err := oldTimer.Disable(ctx, true); err != nil {
				ns.log.DebugContext(ctx, "The deprecated teleport-ent-updater package is either missing, or could not be disabled.", errorKey, err)
			}
			return nil
		}
		if err != nil {
			return trace.Wrap(err, "failed to determine if deprecated teleport-upgrade systemd timer is present")
		}
		if present {
			if err := oldTimer.Disable(ctx, true); err != nil {
				ns.log.ErrorContext(ctx, "The deprecated teleport-ent-updater package is installed on this server and cannot be disabled due to an error.", errorKey, err)
				ns.log.ErrorContext(ctx, "You must remove the teleport-ent-updater package after verifying that teleport-update is working.", errorKey, err)
			} else {
				ns.log.WarnContext(ctx, "The deprecated teleport-ent-updater package is installed on this server.")
				ns.log.WarnContext(ctx, "The systemd timer included in this package has been disabled to prevent conflicts.", "timer", deprecatedTimerName)
				ns.log.WarnContext(ctx, "The systemd service included in this package will no longer perform updates.", "service", deprecatedServiceName)
				ns.log.WarnContext(ctx, "Please remove the teleport-ent-updater package after verifying that teleport-update is working.")
			}
		}
	}

	return nil
}

func (ns *Namespace) installSELinux(ctx context.Context, rev Revision) error {
	ns.log.InfoContext(ctx, "Installing SELinux module.")

	if err := ns.checkSELinux(ctx, true); err != nil {
		return trace.Wrap(err)
	}

	binaryPath := filepath.Join(ns.Dir(), versionsDirName, rev.Dir(), "bin", "teleport")
	fileCtxs, err := selinux.FileContexts(ns.dataDir, ns.teleportConfigFile, binaryPath)
	if err != nil {
		return trace.Wrap(err)
	}

	tempDir, err := os.MkdirTemp("", "selinux-*")
	if err != nil {
		return trace.Wrap(err, "failed to create temporary directory")
	}
	defer os.RemoveAll(tempDir)

	err = os.WriteFile(filepath.Join(tempDir, "teleport_ssh.fc"), []byte(fileCtxs), 0440)
	if err != nil {
		return trace.Wrap(err, "failed to write module source file")
	}

	err = os.WriteFile(filepath.Join(tempDir, "teleport_ssh.te"), []byte(selinux.ModuleSource()), 0440)
	if err != nil {
		return trace.Wrap(err, "failed to write module source file")
	}

	cmd := localExec{
		Dir:      tempDir,
		Log:      ns.log,
		ErrLevel: slog.LevelDebug,
		OutLevel: slog.LevelDebug,
	}

	// Build and install the module, then ensure files are properly labeled.
	_, err = cmd.Run(ctx, "make", "-f", selinuxMakefile, "teleport_ssh.pp")
	if err != nil {
		return trace.Wrap(err, "failed to build module")
	}

	_, err = cmd.Run(ctx, "semodule", "-i", "teleport_ssh.pp")
	if err != nil {
		return trace.Wrap(err, "failed to install module")
	}

	if err := ns.createAndLabelDirs(ctx, cmd); err != nil {
		return trace.Wrap(err)
	}

	return nil
}

func (ns *Namespace) createAndLabelDirs(ctx context.Context, cmd localExec) error {
	// Create the teleport-upgrade and data dirs ahead of time so we
	// can ensure they exist when we label them.
	if err := os.MkdirAll(versioncontrol.UnitConfigDir, defaults.DirectoryPermissions); err != nil {
		ns.log.WarnContext(ctx, "Failed to create teleport-upgrade directory.", errorKey, err)
	}
	if err := os.MkdirAll(ns.dataDir, teleport.PrivateDirMode); err != nil {
		ns.log.WarnContext(ctx, "Failed to create teleport data directory.", errorKey, err)
	}

	dirsToLabel := []string{
		filepath.Clean(ns.installDir),
		ns.dataDir,
		versioncontrol.UnitConfigDir,
	}
	// Create an empty teleport.yaml config file if it doesn't exist, and
	// only attempt to label it if it exists.
	if libutils.FileExists(ns.teleportConfigFile) {
		dirsToLabel = append(dirsToLabel, filepath.Dir(ns.teleportConfigFile))
	} else {
		confFile, err := os.OpenFile(ns.teleportConfigFile, os.O_RDONLY|os.O_CREATE|os.O_EXCL, 0o640)
		if err != nil {
			ns.log.WarnContext(ctx, "Failed to create teleport.yaml.", errorKey, err, "path", ns.teleportConfigFile)
			ns.log.WarnContext(ctx, "You will likely need to create teleport.yaml and re-run 'sudo teleport-update enable' for Teleport SSH to work correctly with SELinux.")
		} else {
			confFile.Close()
			dirsToLabel = append(dirsToLabel, filepath.Dir(ns.teleportConfigFile))
			ns.log.WarnContext(ctx, "Created an empty teleport.yaml.", "path", ns.teleportConfigFile)
			ns.log.WarnContext(ctx, "If you move or copy another file onto this file you will likely need to re-run 'sudo teleport-update enable' for Teleport SSH to work correctly with SELinux.")
		}
	}

	labelArgs := append([]string{"-rv"}, dirsToLabel...)
	_, err := cmd.Run(ctx, "restorecon", labelArgs...)
	if err != nil {
		return trace.Wrap(err, "failed to restore file contexts")
	}

	return nil
}

func (ns *Namespace) removeSELinux(ctx context.Context) error {
	installed, err := selinux.ModuleInstalled()
	if err != nil {
		return trace.Wrap(err, "failed to check if SELinux module is installed")
	}
	if !installed {
		ns.log.DebugContext(ctx, "SELinux module is not installed.")
		return nil
	}

	ns.log.InfoContext(ctx, "Removing SELinux module.")

	if err := ns.checkSELinux(ctx, false); err != nil {
		return trace.Wrap(err)
	}

	cmd := localExec{
		Log:      ns.log,
		ErrLevel: slog.LevelDebug,
		OutLevel: slog.LevelDebug,
	}

	removeOutput, err := cmd.Output(ctx, "semodule", "-r", "teleport_ssh")
	if err != nil {
		// If the module is not installed, return without an error.
		if bytes.Contains(removeOutput, []byte("(No such file or directory).")) {
			return nil
		}
		return trace.Wrap(err, "failed to remove module")
	}

	_, err = cmd.Run(ctx, "restorecon", "-rv", filepath.Clean(ns.installDir), ns.dataDir, filepath.Dir(ns.teleportConfigFile))
	if err != nil {
		return trace.Wrap(err, "failed to restore file contexts")
	}

	return nil
}

func (ns *Namespace) checkSELinux(ctx context.Context, installing bool) error {
	// Ensure necessary files and binaries exist for building a module and
	// inform the user what packages need to be installed if they can't be
	// found.
	if installing {
		_, err := exec.LookPath("make")
		if err != nil {
			ns.log.ErrorContext(ctx, "Failed to find 'make', you may need to install the 'make' package.")
			return trace.Wrap(err)
		}
		if !libutils.FileExists(selinuxMakefile) {
			ns.log.ErrorContext(ctx, "Failed to find the SELinux Makefile, you may need to install the 'selinux-policy-devel' package.")
			return trace.NotFound("failed to find %s", selinuxMakefile)
		}
	}
	_, err := exec.LookPath("semodule")
	if err != nil {
		ns.log.ErrorContext(ctx, "Failed to find 'semodule', you may need to install the 'policycoreutils' package.")
		return trace.Wrap(err)
	}
	_, err = exec.LookPath("restorecon")
	if err != nil {
		ns.log.ErrorContext(ctx, "Failed to find 'restorecon', you may need to install the 'policycoreutils' package.")
		return trace.Wrap(err)
	}

	return nil
}

// Teardown removes all traces of the auto-updater, including its configuration.
// Teardown does not verify that the removed files were created by teleport-update.
func (ns *Namespace) Teardown(ctx context.Context) error {
	modInstalled, err := selinux.ModuleInstalled()
	if err != nil {
		return trace.Wrap(err, "failed to check if SELinux module is installed")
	}
	if modInstalled {
		if err := ns.removeSELinux(ctx); err != nil {
			ns.log.WarnContext(ctx, "Failed to remove SELinux module.", errorKey, err)
		}
	}

	if ok, err := hasSystemD(); err == nil && !ok {
		ns.log.WarnContext(ctx, "Systemd is not running, skipping updater removal.")
		if err := os.RemoveAll(ns.Dir()); err != nil {
			return trace.Wrap(err, "failed to remove versions directory")
		}
		return nil
	}

	svc := &SystemdService{
		ServiceName: filepath.Base(ns.updaterTimerFile),
		Log:         ns.log,
	}
	if err := svc.Disable(ctx, true); err != nil {
		ns.log.WarnContext(ctx, "Unable to disable teleport-update systemd timer before removing.")
		ns.log.DebugContext(ctx, "Error disabling teleport-update systemd timer.", errorKey, err)
	}
	for _, p := range []string{
		ns.updaterServiceFile,
		ns.updaterTimerFile,
		ns.teleportDropInFile,
		ns.deprecatedDropInFile,
		ns.needrestartConfigFile,
	} {
		if p == "" {
			continue
		}
		if err := os.Remove(p); err != nil && !errors.Is(err, fs.ErrNotExist) {
			return trace.Wrap(err, "failed to remove %s", filepath.Base(p))
		}
	}
	if err := svc.Sync(ctx); err != nil {
		return trace.Wrap(err, "failed to sync systemd config")
	}
	if err := os.RemoveAll(ns.Dir()); err != nil {
		return trace.Wrap(err, "failed to remove versions directory")
	}
	if ns.name == "" {
		oldTimer := &SystemdService{
			ServiceName: deprecatedTimerName,
			Log:         ns.log,
		}
		// If the old upgrader exists, attempt to re-enable it automatically
		present, err := oldTimer.IsPresent(ctx)
		if errors.Is(err, ErrNotAvailable) { // systemd too old
			if err := oldTimer.Enable(ctx, true); err != nil {
				ns.log.DebugContext(ctx, "The deprecated teleport-ent-updater package is either missing, or could not be enabled.", errorKey, err)
			}
			return nil
		}
		if err != nil {
			return trace.Wrap(err, "failed to determine if deprecated teleport-upgrade systemd timer is present")
		}
		if present {
			if err := oldTimer.Enable(ctx, true); err != nil {
				ns.log.ErrorContext(ctx, "The deprecated teleport-ent-updater package is installed on this server, and it cannot be re-enabled due to an error.", errorKey, err)
				ns.log.ErrorContext(ctx, "Please fix the systemd timer included in the teleport-ent-updater package if you intend to use the deprecated updater.")
			} else {
				ns.log.WarnContext(ctx, "The deprecated teleport-ent-updater package is installed on this server.")
				ns.log.WarnContext(ctx, "The systemd timer included in this package has been re-enabled to ensure continued updates.", "timer", deprecatedTimerName)
				ns.log.WarnContext(ctx, "To disable updates entirely, please remove the teleport-ent-updater package.")
			}
		}
	}
	return nil
}

func (ns *Namespace) writeConfigFiles(ctx context.Context, path string, rev Revision) error {
	teleportService := filepath.Base(ns.teleportServiceFile)
	tbotService := filepath.Base(ns.tbotServiceFile)
	params := systemdParams{
		TeleportService:   teleportService,
		UpdaterBinary:     filepath.Join(path, BinaryName),
		InstallSuffix:     ns.name,
		InstallDir:        ns.installDir,
		Path:              path,
		UpdaterConfigFile: filepath.Join(ns.Dir(), updateConfigName),
	}

	for _, v := range []struct {
		path, tmpl string
	}{
		{ns.updaterServiceFile, updateServiceTemplate},
		{ns.updaterTimerFile, updateTimerTemplate},
		{ns.teleportDropInFile, teleportDropInTemplate},
		{ns.deprecatedDropInFile, deprecatedDropInTemplate},
	} {
		if v.path == "" {
			continue
		}
		err := writeSystemTemplate(v.path, genHeader(rev), v.tmpl, params)
		if err != nil {
			return trace.Wrap(err)
		}
	}

	// Needrestart config is non-critical for updater functionality.

	nrServices := []string{teleportService}
	if ok, err := ns.HasCustomTbot(ctx); err != nil {
		ns.log.ErrorContext(ctx, "Unable to determine if tbot is managed by the updater, skipping needrestart configuration.", errorKey, err)
	} else if !ok {
		nrServices = append(nrServices, tbotService)
	}

	_, err := os.Stat(filepath.Dir(ns.needrestartConfigFile))
	if os.IsNotExist(err) {
		return nil // needrestart is not present
	}
	if err != nil {
		ns.log.ErrorContext(ctx, "Unable to disable needrestart.", errorKey, err)
		return nil
	}
	ns.log.InfoContext(ctx, "Disabling needrestart.")
	err = writeSystemTemplate(ns.needrestartConfigFile, "", needrestartConfTemplate, systemdParams{
		Services: nrServices,
	})
	if err != nil {
		ns.log.ErrorContext(ctx, "Unable to disable needrestart.", errorKey, err)
		return nil
	}
	return nil
}

// writeSystemTemplate atomically writes a template to a system file, creating any needed directories.
// Temporarily files are stored in the target path to ensure the file has needed SELinux contexts.
func writeSystemTemplate(path, header, t string, values any) error {
	dir, file := filepath.Split(path)
	if err := os.MkdirAll(dir, systemDirMode); err != nil {
		return trace.Wrap(err)
	}

	return trace.Wrap(writeAtomicWithinDir(path, configFileMode, func(w io.Writer) error {
		if header != "" {
			_, err := fmt.Fprint(w, header)
			if err != nil {
				return trace.Wrap(err)
			}
		}
		tmpl, err := template.New(file).Funcs(template.FuncMap{
			"replace": func(s, old, new string) string {
				return strings.ReplaceAll(s, old, new)
			},
			// escape is a best-effort function for escaping quotes in systemd service templates.
			// Paths that are escaped with this method should not be advertised to the user as
			// configurable until a more robust escaping mechanism is shipped.
			// See: https://www.freedesktop.org/software/systemd/man/latest/systemd.syntax.html
			"escape": func(s string) string {
				replacer := strings.NewReplacer(
					`"`, `\"`,
					`\`, `\\`,
				)
				return replacer.Replace(s)
			},
		}).Parse(t)
		if err != nil {
			return trace.Wrap(err)
		}
		return trace.Wrap(tmpl.Execute(w, values))
	}))
}

// WriteTeleportService writes the Teleport systemd service for the version of Teleport
// that matches the version of Teleport compiled into the executing code.
func (ns *Namespace) WriteTeleportService(_ context.Context, pathDir string, rev Revision) error {
	if pathDir == "" {
		pathDir = ns.defaultPathDir
	}
	return trace.Wrap(writeAtomicWithinDir(ns.teleportServiceFile, configFileMode, func(w io.Writer) error {
		_, err := fmt.Fprint(w, genHeader(rev)+"\n")
		if err != nil {
			return trace.Wrap(err)
		}
		return trace.Wrap(systemd.WriteUnitFile(systemd.Flags{
			EnvironmentFile:          systemd.DefaultEnvironmentFile,
			PIDFile:                  ns.teleportPIDFile,
			FileDescriptorLimit:      systemd.DefaultFileDescriptorLimit,
			TeleportInstallationFile: filepath.Join(pathDir, "teleport"),
			TeleportConfigPath:       ns.teleportConfigFile,
			FIPS:                     rev.Flags&autoupdate.FlagFIPS != 0,
		}, w))
	}))
}

func (ns *Namespace) HasCustomTbot(ctx context.Context) (bool, error) {
	diskMarkerPrefix, err := readFileLimit(ns.tbotServiceFile, int64(len(markerPrefix)))
	if errors.Is(err, os.ErrNotExist) {
		ns.log.DebugContext(ctx, "Service not present.", "path", ns.tbotServiceFile)
		return false, nil
	}
	if err != nil {
		return false, trace.Wrap(err)
	}
	return string(diskMarkerPrefix) != markerPrefix, nil
}

// WriteTbotService writes the tbot systemd service for the version of tbot
// that matches the version of tbot compiled into the executing code.
func (ns *Namespace) WriteTbotService(ctx context.Context, pathDir string, rev Revision) error {
	if pathDir == "" {
		pathDir = ns.defaultPathDir
	}
	// This configuration preserves the original tbot systemd.tmpl params.
	// In the future, the template could be updated to accept PIDFile directly.
	unitName := "tbot"
	if ns.name != "" {
		unitName = "tbot_" + ns.name
	}
	if ns.tbotPIDFile != filepath.Join("/run", unitName+".pid") {
		return trace.Errorf("invalid PID file: %q", ns.tbotPIDFile)
	}
	diagDir := filepath.Join(ns.dataDir, "bot")

	if err := os.MkdirAll(diagDir, teleport.PrivateDirMode); err != nil {
		ns.log.WarnContext(ctx, "Failed to create tbot data directory.", errorKey, err)
	}

	return trace.Wrap(writeAtomicWithinDir(ns.tbotServiceFile, configFileMode, func(w io.Writer) error {
		_, err := fmt.Fprint(w, genHeader(rev)+"\n")
		if err != nil {
			return trace.Wrap(err)
		}
		return trace.Wrap(tbotsystemd.Template.Execute(w, tbotsystemd.TemplateParams{
			UnitName:             unitName,
			User:                 "root",
			Group:                "root",
			AnonymousTelemetry:   true,
			ConfigPath:           ns.tbotConfigFile,
			TBotPath:             filepath.Join(pathDir, "tbot"),
			DiagSocketForUpdater: filepath.Join(diagDir, teleport.DebugServiceSocketName),
		}))
	}))
}

// ReplaceTeleportService replaces the default paths in the Teleport service config with namespaced paths.
// This function is still used for backwards-compatibility, but string-replaced systemd services
// are always overridden in more recent versions of Teleport.
func (ns *Namespace) ReplaceTeleportService(cfg []byte, path string, flags autoupdate.InstallFlags) []byte {
	if path == "" {
		path = ns.defaultPathDir
	}
	var startFlags []string
	if flags&autoupdate.FlagFIPS != 0 {
		startFlags = append(startFlags, "--fips")
	}
	for _, rep := range []struct {
		old, new string
	}{
		{
			old: "/usr/local/bin/",
			new: path + "/",
		},
		{
			old: "/etc/teleport.yaml",
			new: ns.teleportConfigFile,
		},
		{
			old: "/run/teleport.pid",
			new: ns.teleportPIDFile,
		},
		{
			old: "/teleport start ",
			new: "/teleport start " + joinTerminal(startFlags, " "),
		},
	} {
		cfg = bytes.ReplaceAll(cfg, []byte(rep.old), []byte(rep.new))
	}
	return cfg
}

func joinTerminal(s []string, sep string) string {
	v := strings.Join(s, sep)
	if len(v) > 0 {
		return v + sep
	}
	return v
}

func (ns *Namespace) LogWarnings(ctx context.Context, pathDir string) {
	if ns.name == "" {
		return
	}
	if pathDir == "" {
		pathDir = ns.defaultPathDir
	}
	ns.log.WarnContext(ctx, "Custom install suffix specified.", "suffix", ns.name, "path_dir", pathDir)
	ns.log.WarnContext(ctx, "Teleport data_dir must be set in the config file, and paths will be different.",
		"data_dir", ns.dataDir,
		"config_file", ns.teleportConfigFile,
		"service", filepath.Base(ns.teleportServiceFile),
		"pid_file", ns.teleportPIDFile,
	)
	ns.log.WarnContext(ctx, "Tbot data storage must be set in the config file, and paths will be different.",
		"data_dir", filepath.Join(ns.dataDir, "bot"),
		"config_file", ns.tbotConfigFile,
		"service", filepath.Base(ns.tbotServiceFile),
		"pid_file", ns.tbotPIDFile,
	)
}

// unversionedConfig is used to read all versions of teleport.yaml, including
// versions that may now be unsupported.
type unversionedConfig struct {
	Teleport unversionedTeleport `yaml:"teleport"`
}

type unversionedTeleport struct {
	AuthServers []string `yaml:"auth_servers"`
	AuthServer  string   `yaml:"auth_server"`
	ProxyServer string   `yaml:"proxy_server"`
	DataDir     string   `yaml:"data_dir"`
}

// overrideFromConfig loads fields from teleport.yaml into the namespace, overriding any defaults.
func (ns *Namespace) overrideFromConfig(ctx context.Context) {
	if ns == nil {
		return
	}
	var (
		configFile string
		cfg        unversionedConfig
	)

	switch {
	case ns.teleportConfigFile != "":
		configFile = ns.teleportConfigFile
		f, err := libutils.OpenFileAllowingUnsafeLinks(configFile)
		if err != nil {
			ns.log.DebugContext(ctx, "Unable to open Teleport config to read proxy or data dir", "config_file", configFile, errorKey, err)
			return
		}
		defer f.Close()
		if err := yaml.NewDecoder(f).Decode(&cfg); err != nil {
			ns.log.DebugContext(ctx, "Unable to parse Teleport config to read proxy or data dir", "config_file", configFile, errorKey, err)
			return
		}
		if cfg.Teleport.DataDir != "" {
			ns.dataDir = cfg.Teleport.DataDir
		}
	case ns.tbotConfigFile != "":
		configFile = ns.tbotConfigFile
		customTbot, err := ns.HasCustomTbot(ctx)
		if err != nil {
			ns.log.DebugContext(ctx, "Unable to determine if tbot is managed by the updater", "config_file", configFile, errorKey, err)
			return
		}
		if customTbot {
			return
		}
		f, err := libutils.OpenFileAllowingUnsafeLinks(configFile)
		if err != nil {
			ns.log.DebugContext(ctx, "Unable to open tbot config to read proxy or data dir", "config_file", configFile, errorKey, err)
			return
		}
		defer f.Close()
		if err := yaml.NewDecoder(f).Decode(&cfg.Teleport); err != nil {
			ns.log.DebugContext(ctx, "Unable to parse tbot config to read proxy or data dir", "config_file", configFile, errorKey, err)
			return
		}
	default:
		return
	}

	// Any implicitly defaulted port in configuration is explicitly defaulted (to 3080).

	var addr string
	var port int
	switch t := cfg.Teleport; {
	case t.ProxyServer != "":
		addr = t.ProxyServer
		port = defaults.HTTPListenPort
	case t.AuthServer != "":
		addr = t.AuthServer
		port = defaults.AuthListenPort
	case len(t.AuthServers) > 0:
		addr = t.AuthServers[0]
		port = defaults.AuthListenPort
	default:
		ns.log.DebugContext(ctx, "Unable to find proxy in config", "config_file", configFile)
		return
	}
	netaddr, err := libutils.ParseHostPortAddr(addr, port)
	if err != nil {
		ns.log.DebugContext(ctx, "Unable to parse proxy in config", "config_file", configFile, "proxy_addr", addr, "proxy_port", port, errorKey, err)
		return
	}
	ns.defaultProxyAddr = netaddr.String()
}
