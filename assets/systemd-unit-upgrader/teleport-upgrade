#!/bin/bash

set -euo pipefail


conf_dir="${TELEPORT_UPGRADE_CONFIG:-/etc/teleport-upgrade.d}"

# get_conf is a helper for loading values from the configuration dir. supports very
# rudimentary comment stripping in order to let us include basic comments in generated
# configs.
get_conf() {
    conf_name=$1
    default_value=$2
    
    # if file does not exist, use default
    if ! test -f $conf_dir/$conf_name; then
        echo "$default_value"
        return 0
    fi

    # strip trivially obvious comments, empty lines, and leading/trailing whitespace.
    normalized_value="$(grep -v -e '^# ' -e '^[[:space:]]*$' <"$conf_dir/$conf_name" | awk '{$1=$1};1')"

    # if variable is empty post-normalization, use default
    if [[ -z "$normalized_value" ]]; then
        echo "$default_value"
        return 0
    fi

    echo "$normalized_value"
}


# upgrade_endpoint is the base host+path used to load the /version and /critical endpoints
upgrade_endpoint="$(get_conf endpoint update.gravitational.io/v1/stable/cloud)"

# package_name specializes the teleport package name (e.g. teleport|teleport-ent|etc)
package_name="$(get_conf package teleport)"

# insecure_mode switches from https to http for upgrade_endpoint. only honored if upgrade_endpoint
# points to localhost.
insecure_mode="$(get_conf insecure no)"

# debug mode increases log verbosity when set to 'yes'.
debug_mode="$(get_conf debug no)"

# upgrade schedule is a line-separated list of pairs of unix timestamps, used to define
# the upcoming upgrade windows. a missing or stale schedule file indicates that the teleport
# agent may be unhealthy.
upgrade_schedule="$(get_conf schedule none)"

# installer kind is an enum representing the kind of installer to use (apt|yum|nop).
installer_kind="$(get_conf installer nop)"


# log_info prints standard-verbosity messages to stderr.
log_info() {
    echo "[i] ${@} [ $(caller | awk '{print $1}') ]" >&2
}

# log_warn prints critical messages to stderr.
log_warn() {
    echo "[!] ${@} [ $(caller | awk '{print $1}') ]" >&2
}

# log_debug prints high verbosity messages to stderr.
log_debug() {
    if [[ $debug_mode != "yes" ]]; then
        return 0
    fi
    echo "[d] ${@} [ $(caller | awk '{print $1}') ]" >&2
}

# pop_unhealthy_marker reads and then deletes the mark-unhealthy file. we can't distinguish between an
# unhealthy agent and an agent that was just restarted, so we use the unhealthy marker to ensure that
# the agent has had at least one 'tick' to try to get itself healthy before we attempt an upgrade.
pop_unhealthy_marker() {
    marker_value="$(get_conf mark-unhealthy no)"
    rm -f "$conf_dir/mark-unhealthy"
    echo "$marker_value"
}

# set_unhealthy_marker sets the unhealthy marker to 'yes'. includes a comment string to help
# clarify the nature of the file.
set_unhealthy_marker() {
    mkdir -p "$conf_dir"

    cat > "$conf_dir/mark-unhealthy" <<EOF
# this file is automatically generated by teleport-upgrade.
# modifications are not persisted.
yes
EOF
}


# is_insecure_mode returns 0 if the 'insecure' config param was set to 'yes' *and* the
# upgrade endpoint looks like it points to localhost.
is_insecure_mode() {
    if [[ $insecure_mode != "yes" ]]; then
        return 1
    fi

    ue_hostport="$(echo $upgrade_endpoint | awk -F/ '{print $1}')"
    ue_host="$(echo $ue_hostport | awk -F: '{print $1}')"

    if [[ $ue_host != "localhost" ]]; then
        log_warn "refusing to run in insecure mode for non-local endpoint $upgrade_endpoint."
        return 1
    fi

    return 0
}

# in_maintenance_window checks if we are in one of the maintenance windows as specified in
# <config-dir>/schedule. the schedule file contains pairs of unix timestamps representing
# the start and end times of maintenance windows.
in_maintenance_window() {
    if [[ $upgrade_schedule == "none" ]]; then
        log_debug "cannot check maintenance window (no schedule)."
        return 1
    fi

    time_now="$(date +%s)"
    
    while read line; do
        prefix="$(echo $line | awk '{print $1}')"
        if [[ "$prefix" != "win" ]]; then
            continue
        fi

        start_time="$(echo $line | awk '{print $2}')"
        end_time="$(echo $line | awk '{print $3}')" 

        if (( time_now > start_time && time_now < end_time )); then
            log_debug "within maintenance window ${start_time} - ${end_time}."
            return 0
        fi
    done <<< "$upgrade_schedule"

    log_debug "not within maintenance window."
    return 1
}

# schedule_appears_healthy checks if schedule was defined and contains at least
# one upgrade window that ends in the future.
schedule_appears_healthy() {
    if [[ $upgrade_schedule == "none" ]]; then
        log_debug "schedule appears unhealthy (does not exist)."
        return 1
    fi

    time_now="$(date +%s)"
    
    while read line; do
        end_time="$(echo $line | awk '{print $2}')" 

        if (( time_now < end_time )); then
            log_debug "schedule appears healthy (contains future window)"
            return 0
        fi
    done <<< "$upgrade_schedule"

    log_debug "schedule appears unhealthy (contains no future windows)."
    return 1
}


# get_current_version gets the current version of the teleport binary. if this
# operation fails, we assume that teleport is eligible for upgrade.
get_current_version() {
    echo "1.2.3"
    return 0
    if cv_output="$(teleport version --raw)"; then
        echo "${cv_output}"
        return 0
    fi

    return 1
}

# upgrade_endpoint_fetch loads the specified value from the upgrade endpoint. the only
# currently supported values are 'version' and 'critical'.
upgrade_endpoint_fetch() {
    host_path="${upgrade_endpoint}/${1}" 
    if is_insecure_mode; then
        log_warn "fetching $host_path in insecure mode (not safe for production use)."
        if if_output="$(curl -sSf "http://${host_path}")"; then
            echo "$if_output"
            return 0
        else
            log_debug "failed to GET $host_path (insecure mode)."
            return 1
        fi
    fi

    log_debug "fetching $host_path..."

    if sf_output="$(curl --proto '=https' --tlsv1.2 -sSf "https://${host_path}")"; then
        echo "$sf_output"
        return 0
    else
        log_debug "failed to GET $host_path"
        return 1
    fi
}

# get_target_version loads the current value of the /version endpoint.
get_target_version() {
    if tv_output="$(upgrade_endpoint_fetch version)"; then
        echo "${tv_output#v}"
        return 0
    fi
    return 1
}

# is_critical checks if the /critical endpoint is available and set to 'yes'.
is_critical() {
    if ef_output="$(upgrade_endpoint_fetch critical)"; then
        if [[ $ef_output == "yes" ]]; then
            return 0
        fi
    fi

    return 1
}

# do_upgrade invokes the appropriate installer_kind with package_name=target_version.
do_upgrade() {
    case "$installer_kind" in
        nop)
            log_info "attempting nop install $package_name=$target_version..."
            echo "nop install $package_name=$target_version"
            return 0
            ;;
        apt)
            log_info "attempting apt install $package_name=$target_version..."
            apt update \
                -o Dir::Etc::sourcelist="sources.list.d/teleport.list" \
                -o Dir::Etc::sourceparts="-" \
                -o APT::Get::List-Cleanup="0"
            apt install -y "$package_name=$target_version"
            systemctl try-restart teleport.service
            return 0
            ;;
        yum)
            log_info "attempting yum install $package_name=$target_version..."
            # TODO
            log_warn "not implemented!"
            return 1
            ;;
        *)
            log_warn "unsupported installer kind: $installer_kind (expected one apt, yum, or nop)"
            return 1
            ;;
    esac
}

log_debug "init: endpoint=$upgrade_endpoint, insecure=$insecure_mode, package=$package_name"

marked_unhealthy="$(pop_unhealthy_marker)"

if ! target_version="$(get_target_version)"; then
    log_warn "failed to get target version, cannot proceed with update check."
    exit 1
fi

# we compare current version to target version here, but the only effect this comparison has
# is to halt an upgrade that would otherwise proceed if the strings are identical.
if current_version="$(get_current_version)"; then
    if [[ "$current_version" == "$target_version" ]]; then
        log_info "no upgrades available ($current_version == $target_version)"
        exit 0
    else
        log_info "an upgrade is available ($current_version -> $target_version)"
    fi
else
    log_info "failed to detect current version, assuming $target_version to be valid target."
fi


if is_critical; then
    log_info "upgrade is marked as critical, will be attempted without checking maintenenance window."
elif in_maintenance_window; then
    log_info "within maintenance window, upgrade will be attempted."
elif ! schedule_appears_healthy; then
    # lack of healthy upgrade schedule means the agent was either just restarted, or is unhealthy. if
    # we also observed unhealthy state on the previous tick, we take that to mean the problem is
    # persistent, rather than having been caused by a restart.
    if [[ "$marked_unhealthy" != "yes" ]]; then 
        log_info "agent may be unhealthy. marking for potential future upgrade."
        set_unhealthy_marker
        exit 0
    fi
    log_warn "agent was previously marked unhealthy and does not appear recovered, upgrade will be attempted."
else
    log_info "upgrade is non-critical and we are outside of maintanence window, not attempting."
    exit 0
fi

if ! do_upgrade; then
    log_warn "upgrade attempt failed for $package_name=$target_version."
    exit 1
fi
