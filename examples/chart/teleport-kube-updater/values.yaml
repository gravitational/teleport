# Default values for teleport-kube-updater.
#
# This is a YAML-formatted file.
# The default values are documented in the Chart.yaml.

# enabled(bool) -- Enables the Kube Updater and deploys it alongside the Teleport Agent or Tbot.
# You can enable this when:
#
# - using Teleport Cloud and your tenant is enrolled into automatic updates by default.
# - using self-hosted Teleport and you maintain your own version server.
#
# You must not enable this when:
#
# - you are a self-hosted Teleport user and have not set up your Teleport cluster to
#   support automatic updates.
enabled: false

# proxyAddr(string) -- provides the public-facing Teleport Proxy Service endpoint
# which should be used to join the cluster. This is the same URL used to access
# the web UI of your Teleport cluster. The port used is usually either 3080 or 443.
#
# Here are a few examples:
#
# | Deployment method             | Example `proxy_service.public_addr` |
# |-------------------------------|-------------------------------------|
# | On-prem Teleport cluster      | `teleport.example.com:3080`         |
# | Teleport Cloud cluster        | `example.teleport.sh:443`           |
# | `teleport-cluster` Helm chart | `teleport.example.com:443`          |
proxyAddr: ""

# versionServer(string) -- is the URL of the version server the updater
# fetches the target version from. The complete version endpoint is built by
# concatenating [`versionServer`](#versionserver) and [`releaseChannel`
# ](#releasechannel).
# This field supports gotemplate.
#
# Setting this field makes the updater fetch the version using the version server protocol.
# Setting this field to a custom value disables the webapi update protocol to ensure backward compatibility.
versionServer: "https://{{ .Values.proxyAddr }}/v1/webapi/automaticupgrades/channel"

# releaseChannel(string) -- is the release channel the updater
# subscribes to.
#
# The complete version endpoint is built by concatenating
# [`versionServer`](#versionserver) and [`releaseChannel`](#releasechannel).
# You must not change the default value if you are a Teleport Cloud user unless
# instructed by Teleport support.
#
# This value is used when the updater is fetching the version using the version server protocol.
# It is also used as a failover when fetching the version using the webapi protocol if `group` is unset.
releaseChannel: "stable/cloud"

# group(string) -- is the update group used when fetching the version using the webapi protocol.
# When unset, the group defaults to `default`.
group: ""

# image(string) -- sets the container image used for Teleport updater
# pods run when `enabled` is true.
#
# You can override this to use your own Teleport Kube Updater image rather
# than a Teleport-published image.
image: public.ecr.aws/gravitational/teleport-kube-agent-updater

# appImage(string) -- sets the container image used for updating pods monitored by this
# chart. If it is not defined Kube Updater will receive it from the target pod for updating.
appImage: ""

# containerName(string) -- sets the name of the main container in the Teleport Kube Updater pod.
# This value is typically left empty and is required to be set during installation.
containerName: ""

# syncPeriod(string) -- sets the period at which the updater checks for new versions.
# The value is a duration string (e.g., "10h" for 10 hours, "30m" for 30 minutes).
# This value is used to configure how often the updater polls for version updates.
# The default value is "10h".
syncPeriod: "10h"

# serviceAccount --
serviceAccount:
  # serviceAccount.name(string) -- is the updater Kubernetes Service
  # Account name. When unset, it defaults to `<kube updater sa name>`
  name: ""
  create: true

# pullCredentials(string) -- configures how the updater attempts to
# get the image pull credentials used to validate the image signature.
#
# This is not required when pulling images from official public Teleport
# registries (chart's default).
#
# Supported values are `amazon`, `google`, `docker` and `none`.
pullCredentials: ""

# extraArgs(list) -- contains additional arguments to pass to the updater
# binary.
extraArgs: []

# extraVolumes(list) -- contains extra volumes to mount into the Updater pods.
# See [the Kubernetes volume documentation](https://kubernetes.io/docs/concepts/storage/volumes/)
# for more details.
#
# For example:
# ```yaml
# extraVolumes:
# - name: myvolume
#   secret:
#     secretName: testSecret
# ```
extraVolumes: []

# extraVolumeMounts(list) -- contains extra volumes mounts for the updater.
# See [the Kubernetes volume documentation](https://kubernetes.io/docs/concepts/storage/volumes/)
# for more details.
#
# For example:
# ```yaml
# extraVolumesMounts:
# - name: myvolume
#   mountPath: /path/on/host
# ```
extraVolumeMounts: []

# resources(object) -- sets the resource requests/limits for any pods created by the chart.
# See [the Kubernetes documentation](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)
# for more details.
resources: { }

# tls -- contains settings for mounting your own TLS material in the updater pod.
# The updater does not expose a TLS server, so this is only used to trust CAs.
tls:
  # tls.existingCASecretName(string) -- sets the `SSL_CERT_FILE` environment
  # variable to load a trusted CA or bundle in PEM format into Teleport pods.
  # The injected CA will be used to validate TLS communications, with the Proxy
  # Service, with upstream applications or databases.
  #
  # <Admonition type="note">
  #   The recommended way to trust a database CA is to do it per-database instead
  #   of adding the CA to the global Teleport trust store. It allows to trust
  #   multiple CAs while limiting the trust scope to their specific databases.
  #   See [the `databases` section](#databases).
  # </Admonition>
  #
  # You must create a secret containing the CA certs in the same namespace as Teleport using a command like:
  #
  # ```code
  # $ kubectl create secret generic my-root-ca --from-file=ca.pem=/path/to/root-ca.pem
  # ```
  #
  # <Admonition type="warning" title="Root CA filename">
  #   The key containing the root CA in the secret must be `ca.pem`.
  # </Admonition>
  existingCASecretName: ""

# Set to true (default) to create Kubernetes ClusterRole and ClusterRoleBinding.
rbac:
  # Specifies whether a ClusterRole and ClusterRoleBinding should be created.
  # Set to false if your cluster level resources are managed separately.
  create: true

extraLabels:
  # extraLabels.roleBinding(object) -- are labels to set on the RoleBinding.
  roleBinding: { }
  # extraLabels.role(object) -- are labels to set on the Role.
  role: { }
  # extraLabels.pod(object) -- are labels to set on the Pods created by the
  # Deployment, StatefulSet, or Job.
  pod: { }
  # extraLabels.deployment(object) -- are labels to set on the Deployment or StatefulSet.
  deployment: { }
  # extraLabels.serviceAccount(object) -- are labels to set on the ServiceAccount.
  serviceAccount: { }

# extraEnv(list) -- contains extra environment variables to set in the main
# updater pod.
#
# For example:
# ```yaml
# extraEnv:
#   - name: HTTPS_PROXY
#     value: "http://username:password@my.proxy.host:3128"
# ```
extraEnv: [ ]

# annotations -- contains annotations to apply to the different Kubernetes
# objects created by the chart. See [the Kubernetes annotation
# documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/)
# for more details.
annotations:
  # annotations.config(object) -- contains the Kubernetes annotations
  # put on the `ConfigMap` resource created by the chart.
  config: {}
  # annotations.deployment(object) -- contains the Kubernetes annotations
  # put on the `Deployment` or `StatefulSet` resource created by the chart.
  deployment: {}
  # annotations.pod(object) -- contains the Kubernetes annotations
  # put on the `Pod` resources created by the chart.
  pod: {}
  # annotations.secret(object) -- contains the Kubernetes annotations
  # put on the `Secret` resource created by the chart.
  # This has no effect when `joinTokenSecret.create` is `false`.
  secret: {}
  # annotations.serviceAccount(object) -- contains the Kubernetes annotations
  # put on the `ServiceAccount` resource created by the chart.
  serviceAccount: {}

# priorityClassName(string) -- sets the priority class used by any pods created by the chart.
# The user is responsible for creating the `PriorityClass` resource before deploying the chart.
# See [the Kubernetes documentation](https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/)
# for more details.
priorityClassName: ""
