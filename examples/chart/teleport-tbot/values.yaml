image:
  name: teleport-distroless
registry:
  domain: public.ecr.aws/gravitational

serviceAccount:
  # serviceAccount.create(bool) -- controls whether Helm Chart creates the
  # Kubernetes `ServiceAccount` resources for the agent and optionally for the
  # updater.
  # When off, you are responsible for creating the appropriate ServiceAccount
  # resources.
  create: true
  # serviceAccount.name(string) -- sets the name of the `ServiceAccount` resource
  # used by the chart. By default, the `ServiceAccount` has the name of the
  # Helm release.
  name: ""

podSecurityPolicy:
  # podSecurityPolicy.enabled(bool) -- controls if the chart should deploy a Kubernetes
  # PodSecurityPolicy.
  #
  # By default, Teleport charts used to install a [`podSecurityPolicy`](https://github.com/gravitational/teleport/blob/branch/(=teleport.major_version=)/examples/chart/teleport-cluster/templates/psp.yaml).
  #
  # PodSecurityPolicy resources (PSP) have been removed in Kubernetes 1.25
  # and replaced since 1.23 by PodSecurityAdmission (PSA). If you are running on
  # Kubernetes 1.23 or later, it is recommended to disable PSPs and use PSAs.
  # The steps are documented in the
  # [PSP removal guide](../../../deploy-a-cluster/helm-deployments/migration-kubernetes-1-25-psp.mdx).
  #
  # This value will be removed in a future chart version.
  enabled: true

teleport:
  tokenName: ""
  proxyAddr: teleport.example.com:443
  teleportClusterName: teleport.example.com
  teleportVersion: 15.0.1

pod:
  user:
    id: 1000
  group:
    id: 1000

resources:
  limits:
    cpu: 250m
    memory: 500Mi
  requests:
    cpu: 100m
    memory: 250Mi

# Add seccomp to pod security context
podSecurityContext:
  seccompProfile:
    type: RuntimeDefault
  runAsNonRoot: true

# Add seccomp to container security context
containerSecurityContext:
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL

annotations:
  # annotations.config(object) -- contains the Kubernetes annotations
  # put on the `ConfigMap` resource created by the chart.
  config: {}
  # annotations.deployment(object) -- contains the Kubernetes annotations
  # put on the `Deployment` or `StatefulSet` resource created by the chart.
  deployment: {}
  # annotations.pod(object) -- contains the Kubernetes annotations
  # put on the `Pod` resources created by the chart.
  pod: {}
  # annotations.secret(object) -- contains the Kubernetes annotations
  # put on the `Secret` resource created by the chart.
  # This has no effect when `joinTokenSecret.create` is `false`.
  secret: {}
  # annotations.serviceAccount(object) -- contains the Kubernetes annotations
  # put on the `ServiceAccount` resource created by the chart.
  serviceAccount: {}

extraLabels:
  # extraLabels.clusterRole(object) -- are labels to set on the ClusterRole.
  clusterRole: {}
  # extraLabels.clusterRoleBinding(object) -- are labels to set on the ClusterRoleBinding.
  clusterRoleBinding: {}
  # extraLabels.role(object) -- are labels to set on the Role.
  role: {}
  # extraLabels.roleBinding(object) -- are labels to set on the RoleBinding.
  roleBinding: {}
  # extraLabels.config(object) -- are labels to set on the ConfigMap.
  config: {}
  # extraLabels.deployment(object) -- are labels to set on the Deployment or StatefulSet.
  deployment: {}
  # extraLabels.pod(object) -- are labels to set on the Pods created by the
  # Deployment or StatefulSet.
  pod: {}
  # extraLabels.podDisruptionBudget(object) -- are labels to set on the podDisruptionBudget.
  podDisruptionBudget: {}
  # extraLabels.podSecurityPolicy(object) -- are labels to set on the podSecurityPolicy.
  podSecurityPolicy: {}
  # extraLabels.secret(object) -- are labels to set on the Secret.
  secret: {}
  # extraLabels.serviceAccount(object) -- are labels to set on the ServiceAccount.
  serviceAccount: {}