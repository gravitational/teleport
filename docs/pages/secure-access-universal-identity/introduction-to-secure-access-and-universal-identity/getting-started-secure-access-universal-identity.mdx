---
title: Secure Access & Universal Identity Getting Started Guide
description: Getting started with Secure Access & Universal Identity
---

In this getting started guide, you will learn how to use Secure Access & Universal Identity together.

## Secure Access Configuration 

Secure Access uses Machine ID. Configure Machine ID to issue certificates that enable a bot user to connect to a remote host.

Here's an overview of what you will do:

- Download and install `tbot` on the host that will run Machine ID.
- Create a bot user.
- Start Machine ID.
- Use certificates issued by Machine ID to connect to a remote machine with SSH.

This guide covers configuring Machine ID for development and learning purposes.
For a production-ready configuration of Machine ID, visit the [Deploying Machine
ID](deployment/deployment.mdx) guides.

## Prerequisites

- A host that you wish to assign an identity to using Machine ID.

(!docs/pages/includes/edition-prereqs-tabs.mdx!)

(!/docs/pages/includes/tctl.mdx!)

## Step 1/4. Download and install Teleport

In this step, you will be downloading and installing Teleport binaries onto the
machine you wish to assign an identity to.

Each Teleport package hosted on our downloads page ships with several useful
binaries, including `teleport`, `tctl`, `tsh`,`tbot`, and `fdpass-teleport`:

- `teleport` is the daemon used to initialize a Teleport cluster; this binary is not used in this guide
- `tctl` is the administrative tool you will use to create the bot user (step 1/4)
- `tsh` is the client tool you will use to log in to the Teleport Cluster (steps 2/4 and 4/4)
- `tbot` is the Machine ID tool you will use to associate a bot user with a machine (step 3/4)
- `fdpass-teleport` is used to integrate Machine ID with OpenSSH to enable higher performance and reduced resource consumption when establishing SSH connections; this binary is not used in this guide

Download the appropriate Teleport package for your platform: 

(!docs/pages/includes/install-linux.mdx!)

## Step 2/4. Create a Bot

In Teleport, a **Bot** represents an identity for a machine. This is similar to
how a user represents the identity of a human. Like users, bots are assigned
roles to manage their access to resources. However, unlike users, bots do not
authenticate using a username and password or SSO. Instead, they initially
authenticate in a process called joining.

Teleport supports a number of secure join methods specific to the platform the
bot is running on, but for the purposes of this guide, we will use the simpler
`token` join method. You can follow a deployment guide later to learn about the
secure join methods available for your platform.

Before you create a bot user, you need to determine which role(s) you want to
assign to it. You can use the `tctl` command below to examine what roles exist
on your system.

On your client machine, log in to Teleport using `tsh`, then use `tctl` to examine
what roles exist on your system.

```code
$ tctl get roles --format=text
```

You will see something like the output below on a fresh install of Teleport with the
default roles—your cluster may have different roles. In this example, let's
assume you want to give the bot the `access` role to allow it to connect to
machines within your cluster.

```
Role    Allowed to login as                           Node Labels Access to resources
------- --------------------------------------------- ----------- ----------------------------------------
access  {{internal.logins}}                           <all nodes> event:list,read,session:read,list
auditor no-login-6566121f-b602-47f1-a118-c9c618ee5aec             session:list,read,event:list,read
editor                                                            user:list,create,read,update,delete,...
```

The `internal.logins` trait is replaced with values from the Teleport local user
database. For full details on how traits work in Teleport roles, see the
[Access Controls
Reference](../../reference/access-controls/roles.mdx).

Assuming that you are using the default `access` role, ensure that you use the 
`--logins` flag when adding your bot to specify the SSH logins that you wish to 
allow the bot to access on hosts. For our example, we will be using `root`.

Use `tctl bots add` to create our bot:

```code
$ tctl bots add robot --roles=access --logins=root
```

## Step 3/4. Start Machine ID

Now start Machine ID using the `tbot` binary. The `tbot start` command will
start running Machine ID in a loop, writing renewable certificates to
`/var/lib/teleport/bot` and the short-lived certificates your application will
use to `/opt/machine-id`.

In a production environment you will want to run Machine ID in the background
using a service manager like systemd. However, in this guide you will run it in
the foreground to better understand how it works.

```code
$ export TELEPORT_ANONYMOUS_TELEMETRY=1
$ sudo tbot start \
 --data-dir=/var/lib/teleport/bot \
 --destination-dir=/opt/machine-id \
 --token=(=presets.tokens.first=) \
 --join-method=token \
 --proxy-server=example.teleport.sh:443
```

`TELEPORT_ANONYMOUS_TELEMETRY` enables the submission of anonymous usage
telemetry. This helps us shape the future development of `tbot`. You can disable
this by omitting this.

Replace the following fields with values from your own cluster.

- `token` is the token output by the `tctl bots add` command or the name of your IAM method token.
- `destination-dir` is where Machine ID writes user certificates that can be used by applications and tools.
- `data-dir` is where Machine ID writes its private data, including its own short-lived renewable certificates. These should not be used by applications and tools.
- `proxy-server` is the address of your Teleport Proxy service, for example `example.teleport.sh:443`.

Now that Machine ID has successfully started, let's investigate the
`/opt/machine-id` directory to see what was written to disk.

```code
$ tree /opt/machine-id
machine-id
├── identity
├── key
├── key-cert.pub
├── key.pub
├── known_hosts
├── ssh_config
├── teleport-database-ca.crt
├── teleport-host-ca.crt
├── teleport-user-ca.crt
└── tlscert

0 directories, 10 files
```

This directory contains private key material in the `key.*` files, SSH
certificates in the `identity` file, X.509 certificates in the `tls*` and
`*.crt` files, OpenSSH configuration in the `ssh_config` and
`known_hosts` files to make it easy to integrate Machine ID with external
 applications and tools.

## Step 4/4. Use certificates issued by Machine ID

To use Machine ID, find a host that you want to connect to within your cluster
using `tsh ls`. You might see output like the following on your system.

```code
$ tsh ls
Node Name Address        Labels
--------- -------------- -----------------------------
node-name  127.0.0.1:3022 arch=x86_64,group=api-servers
```

<details>
<summary>Not seeing Nodes?</summary>

(!docs/pages/includes/node-logins.mdx!)

</details>

To use Machine ID with the OpenSSH integration, run the following command to
connect to `node-name` within cluster `example.com`.

```code
$ ssh -F /opt/machine-id/ssh_config root@node-name.example.com
```

In addition to the `ssh` client you can use `tsh`. Replace the `--proxy` parameter
with your proxy address. 

```code
$ tsh ssh --proxy=mytenant.teleport.sh -i /opt/machine-id/identity root@node-name
```

<Admonition type="note" title="Roles must have logins defined">
  The below error can occur when the bot does not have permission to log in to
  a node as the requested user:

  ```code
  $ ssh -F /opt/machine-id/ssh_config root@node-name.example.com
  root@node-name: Permission denied (publickey).
  kex_exchange_identification: Connection closed by remote host
  ```
  This can happen in two circumstances:
  - The user you are trying to log in as is not specified under `logins` in the
   role you are using
  - If you have used `--logins` when creating the bot user, the role the bot is 
  impersonating does not have the `{{ internal.logins }}` variable specified.

  If you have been following along with the `access` role, do the following.

  - Export the role by running `tctl get roles/access > access.yaml`
  - Edit the `logins` field in `access.yaml`
  - Update the role by running `tctl create -f access.yaml`
</Admonition>

Now you can replace any invocations of `ssh` with the above command to provide
your applications and tools a machine identity that can be rotated, audited,
and controlled with access controls.

## Universal Identity

Teleport's Universal Identity uses Workload Identity, which issues flexible short-lived identities intended
for workloads. It is compatible with the industry-standard SPIFFE specification
meaning that it can be used in place of other SPIFFE compatible identity
providers.

## How it works

Configure the RBAC necessary to allow a Bot to issue
workload identity credentials and then configure `tbot` to expose a SPIFFE
Workload API endpoint. You can then connect your workloads to this endpoint to
receive SPIFFE SVID-compatible workload identity credentials.

## Prerequisites

(!docs/pages/includes/edition-prereqs-tabs.mdx!)

- (!docs/pages/includes/tctl.mdx!)
- `tbot` must already be installed and configured on the host where the
  workloads which need to access Teleport Workload Identity will run. For more
  information, see the [deployment guides](../machine-id/deployment/deployment.mdx).

## Step 1/4. Configure Workload Identity

First, you will need to create a Workload Identity resource.

This resource is the primary way that Teleport Workload Identity is configured.
Each Workload Identity resource represents the configuration of an identity for a
specific workload or a template to be used when representing the identity of a
group of workloads. The Workload Identity resource specifies a number of key
things, including:

- The name of the Workload Identity, which will be needed when issuing it.
- The SPIFFE ID that will be included in credentials issued for this
  WorkloadIdentity.
- Any rules around when this Workload Identity can be used to issue credentials.

Before proceeding, you'll want to determine the SPIFFE ID path that your
workload will use. In our example, we'll use `/svc/foo`. We provide more
guidance on choosing a SPIFFE ID structure in the
[Best Practices](./best-practices.mdx) guide.

Create a new file called `workload-identity.yaml`:

```yaml
kind: workload_identity
version: v1
metadata:
  name: example-workload-identity
  labels:
    example: getting-started
spec:
  spiffe:
    id: /svc/foo
```

Replace:

- `example-workload-identity` with a name that describes your use-case.
- `/svc/foo` with the SPIFFE ID path you have decided on issuing.

Use `tctl create -f ./workload-identity.yaml` to create the Workload Identity.

Now, you'll need to create a role that will grant access to the Workload Identity
that you have just created. As with other Teleport resources, access is granted
by specifying label matchers on the role that will match the labels on the
resource itself.

In addition to granting access to the resource, we will also need to grant the
ability to read and list the Workload Identity resource type.

Create `workload-identity-issuer-role.yaml`:

```yaml
kind: role
version: v6
metadata:
  name: example-workload-identity-issuer
spec:
  allow:
    workload_identity_labels:
      example: ["getting-started"]
    rules:
    - resources:
      - workload_identity
      verbs:
      - list
      - read
```

Use `tctl create -f ./workload-identity-issuer-role.yaml` to create the role.

Now, use `tctl bots update` to add the role to the Bot. Replace `example-bot`
with the name of the Bot you created in the deployment guide and
`example-workload-identity-issuer` with the name of the role you just created:

```code
$ tctl bots update example-bot --add-roles example-workload-identity-issuer
```

### Configuring DNS SANs

In some cases, you may wish to configure DNS SANs which should be included in
the X509 certificates issued by the Workload API. This is useful in cases
where the client may not be SPIFFE aware and will check the DNS SAN rather than
the SPIFFE URI during the TLS handshake.

Modify your `workload-identity.yaml` resource definition to include the
`spec.spiffe.x509.dns_sans` field, replacing `example.com` with the DNS name you
require:

```yaml
kind: workload_identity
version: v1
metadata:
  name: example-workload-identity
  labels:
    example: getting-started
spec:
  spiffe:
    id: /svc/foo
    x509:
      dns_sans:
      - example.com
```

Use `tctl create -f ./workload-identity.yaml` to update the WorkloadIdentity
resource with your changes.

## Step 2/4. Configure `workload-identity-api` service in `tbot`

To set up a SPIFFE Workload API endpoint with `tbot`, we configure an instance
of the `workload-identity-api` service.

First, determine where you wish this socket to be created. In our example,
we'll use `/opt/machine-id/workload.sock`. You may wish to choose a directory
that is only accessible by the processes that will need to connect to the
Workload API.

Modify your `tbot` configuration file to include the `workload-identity-api`
service:

```yaml
services:
- type: workload-identity-api
  listen: unix:///opt/machine-id/workload.sock
  selector:
    name: example-workload-identity
```

Replace:

- `/opt/machine-id/workload.sock` with the path to the socket you wish to create.
- `example-workload-identity` with the name of the Workload Identity resource you
  created earlier.

Start or restart your `tbot` instance to apply the new configuration

### Configuring Unix Workload Attestation

By default, an SVID listed under the Workload API service will be issued to any
workload that connects to the Workload API. You may wish to restrict which SVIDs
are issued based on certain characteristics of the workload. This is known as
Workload Attestation.

When using the Unix listener, `tbot` supports workload attestation based on
three characteristics of the workload process:

- `uid`: The UID of the user that the workload process is running as.
- `gid`: The primary GID of the user that the workload process is running as.
- `pid`: The PID of the workload process.

Within a Workload Identity, you can configure rules based on the attributes
determined via workload attestation. Each rule contains a number of tests and
all tests must pass for the rule to pass. At least one rule must pass for the
Workload Identity to be allowed to issue a credential.

For example, to configure a Workload Identity to be issued only to workloads that
are running as the user with ID 1000 or running as a user with a primary group
ID of 50:

```yaml
kind: workload_identity
version: v1
metadata:
  name: example-workload-identity
  labels:
    example: getting-started
spec:
  rules:
    allow:
    - conditions:
      - attribute: workload.unix.uid
        eq:
          value: 1000
    - conditions:
      - attribute: workload.unix.gid
        eq:
          value: 50
  spiffe:
    id: /svc/foo
```

## Step 3/4. Testing the Workload API with `tbot spiffe-inspect`

The `tbot` binary includes a `spiffe-inspect` command that can be used to
test the configuration of the Workload API. This command will connect to the
Workload API and request SVIDs, whilst providing debug information.

Before configuring your workload to use the Workload API, we recommend using
this command to ensure that the Workload API is behaving as expected.

Use the `spiffe-inspect` command with `--path` to specify the path to the
Workload API socket, replacing `/opt/machine-id/workload.sock` with the path you
configured in the previous step:

```code
$ tbot spiffe-inspect --path unix:///opt/machine-id/workload.sock
INFO [TBOT]      Inspecting SPIFFE Workload API Endpoint unix:///opt/machine-id/workload.sock tbot/spiffe.go:31
INFO [TBOT]      Received X.509 SVID context from Workload API bundles_count:1 svids_count:1 tbot/spiffe.go:46
SVIDS
- spiffe://example.teleport.sh/svc/foo
  - Expiry: 2024-03-20 10:55:52 +0000 UTC
Trust Bundles
- example.teleport.sh
```

## Step 4/4. Configuring your workload to use the Workload API

Now that you know that the Workload API is behaving as expected, you can
configure your workload to use it. The exact steps will depend on the workload.

In cases where you have used the SPIFFE SDKs, you can configure the
`SPIFFE_ENDPOINT_SOCKET` environment variable to point to the socket created by
`tbot`.

See the [Best Practices](./best-practices.mdx) guide for more information on
integrating SPIFFE with your workloads.


## Next Steps

- Read the [architecture overview](../../reference/architecture/machine-id-architecture.mdx) to learn about how
  Machine ID works in more detail.
- Check out the [deployment guides](deployment/deployment.mdx) to learn about
  configuring `tbot` in a production-ready way for your platform.
- Check out the [access guides](access-guides/access-guides.mdx) to learn about configuring
  `tbot` for different use cases than SSH.
- Read the [configuration reference](../../reference/machine-id/configuration.mdx) to explore
  all the available configuration options.
- [More information about `TELEPORT_ANONYMOUS_TELEMETRY`.](../../reference/machine-id/telemetry.mdx)

