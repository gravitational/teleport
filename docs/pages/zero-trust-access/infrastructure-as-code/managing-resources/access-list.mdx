---
title: Creating Access Lists with IaC
description: Use Infrastructure-as-Code tooling to create Access Lists.
tags:
 - infrastructure-as-code
 - how-to
 - zero-trust
---

Access Lists allow Teleport users to be granted long-term access to resources
managed within Teleport. With Access Lists, administrators can regularly audit and control membership to specific roles and
traits, which then tie easily back into Teleport's existing RBAC system.

In this guide, we'll follow up
on [the IaC users and roles guide](./user-and-role.mdx) by allowing users with
the `manager` role to grant the `support-engineer` role to users meeting
specific criteria.

## How it works

Access Lists are registered with the Teleport Auth Service as resources stored
on the Auth Service backend. The Teleport Auth Service exposes a gRPC API that
enables clients to create, delete, or modify backend resources, including Access
Lists. The Teleport Kubernetes Operator and Terraform provider, along with the
`tctl` command-line tool, can manage agentless SSH services by authenticating to
the Teleport Auth Service and interacting with its gRPC API.

By default, Access Lists can be managed via IaC but Access List memberships
cannot. The goal of Access Lists is to decentralize granting and reviewing
access. By allowing managers to grant access within specific guidelines and
automatically enforcing review, users can request common access rights without
having to go through the centralized team managing the Teleport IaC. This
reduces the load on the centralized IaC/security team, ensures the access
reviewer is aware of the context, reduces the request resolution time, and
ensures access grants are periodically reviewed.

## Prerequisites

To follow this guide, you must follow
first [the basic users and roles IaC guide](./user-and-role.mdx). We will reuse
its users and roles for our Access List.

## Step 1/3 - Write manifests

### Write the privileged role manifest

We will create a new role `support-engineer` that grants access to production
servers. The `engineer` role from the previous guide was only granting access to
`dev` and `staging` servers.


<Tabs>
<TabItem label="tctl">

Create the following `privileged-role.yaml` file:

```yaml
kind: role
version: v7
metadata:
  name: support-engineer
spec:
  allow:
    logins: ['root', 'ubuntu', '{{internal.logins}}']
    node_labels:
      'env': ['production']
```

</TabItem>
<TabItem label="Kubernetes Operator">

Create the following `privileged-role.yaml` file:

```yaml
apiVersion: resources.teleport.dev/v1
kind: TeleportRoleV7
metadata:
  name: support-engineer
spec:
  allow:
    logins: [ 'root', 'ubuntu', '{{internal.logins}}' ]
    node_labels:
      'env': [ 'production' ]
```

</TabItem>
<TabItem label="Terraform">

Create the following `privileged-role.tf` file:

```hcl
resource "teleport_role" "support-engineer" {
  version = "v7"
  metadata = {
    name = "support-engineer"
  }

  spec = {
    allow = {
      logins = ["root", "ubuntu", "{{internal.logins}}"]
      node_labels = {
        env = ["production"]
      }
    }
  }
}
```

</TabItem>
</Tabs>

### Write the Access List manifest

In this step we'll create an Access List that allows users with the `manager`
role such as  `alice` to grant access to production to users with the `engineer`
role.

<Tabs>
<TabItem label="tctl">

Create the following `accesslist.yaml` file:

```yaml
version: v1
kind: access_list
metadata:
  name: support-engineers
spec:
  title: "Production access for support engineers"
  audit:
    recurrence:
      frequency: 6months
  description: "Use this Access List to grant access to production to your engineers enrolled in the support rotation."
  owners:
    - description: "manager of NA support team"
      name: alice
  ownership_requires:
    roles:
      - manager
  grants:
    roles:
      - support-engineer
  membership_requires:
    roles:
      - engineer
```

</TabItem>
<TabItem label="Kubernetes Operator">

Create the following `accesslist.yaml` file:

```yaml
apiVersion: resources.teleport.dev/v1
kind: TeleportAccessList
metadata:
  name: support-engineers
spec:
  title: "Production access for support engineers"
  description: "Use this Access List to grant access to production to your engineers enrolled in the support rotation."
  audit:
    recurrence:
      frequency: 6months
  owners:
    - description: "manager of NA support team"
      name: alice
  ownership_requires:
    roles:
      - manager
  grants:
    roles:
      - support-engineer
  membership_requires:
    roles:
      - engineer
```

</TabItem>
<TabItem label="Terraform">

Create the following `accesslist.tf` file:

```hcl
resource "teleport_access_list" "support-engineers" {
  header =  {
    version = "v1"
    metadata = {
      name = "support-engineers"
    }
  }

  spec = {
    title = "Production access for support engineers"
    description = "Use this Access List to grant access to production to your engineers enrolled in the support rotation."
    audit = {
      recurrence = {
        frequency = 6
      }
    }
    owners = [
      {
        description = "manager of NA support team"
        name = "alice"
      }
    ]
    ownership_requires = {
      roles = ["manager"]
    }
    grants = {
      roles = ["support-engineer"]
    }
    membership_requires = {
      roles = ["engineer"]
    }
  }
}
```

</TabItem>
</Tabs>

## Step 2/3 - Apply the manifests

<Tabs>
<TabItem label="tctl">

```code
$ tctl create -f privileged-role.yaml
role 'support-engineer' has been created

$ tctl create -f accesslist.yaml
Access list "support-engineers" has been created
```

<Admonition type="note">
The user resource depends on roles. You must create roles before users as a user
with a non-existing role is invalid and will be rejected by Teleport.
</Admonition>

</TabItem>
<TabItem label="Kubernetes Operator">

Create the Kubernetes CRs with the following commands:

```code
$ kubectl apply -n "$OPERATOR_NAMESPACE" -f privileged-role.yaml
teleportrolev7.resources.teleport.dev/support-engineer created

$ kubectl apply -n "$OPERATOR_NAMESPACE" -f accesslist.yaml
teleportaccesslist.resources.teleport.dev/support-engineers
```

</TabItem>
<TabItem label="Terraform">

```code
$ terraform plan
[...]
Plan: 2 to add, 0 to change, 0 to destroy.

$ terraform apply
teleport_access_list.support-engineers: Creating...
teleport_role.support-engineer: Creating...
teleport_role.support-engineer: Creation complete after 0s [id=support-engineer]
teleport_access_list.support-engineers: Creation complete after 0s [id=support-engineers]
```

</TabItem>
</Tabs>

## Step 3/3 - Log in as `alice` and grant access to `bob`

Now, you created an Access List allowing `alice` to grant the `support-engineer`
role to its engineers.

You can log in as alice and add `bob` to the `support-engineers` Access List.

<Tabs>
<TabItem label="Web UI">

Log in as `alice` in the Web UI, Zero Trust Access, select Access Lists, and click on your Access List. 
Click "Add new Members or Access Lists or Access Lists" and add `bob`.

![Screenshot of the Web UI showing the Access List and the "Enroll Member" button](../../../../img/management/access-list-web-ui.png)

</TabItem>
<TabItem label="CLI">

Log in as `alice` with `tsh`, then add bob to the Access List:

```code
# log in as alice
$ tsh login --proxy <your-cluster-domain>:<port> --user alice

# tctl acl users add <access-list-name> <user> [<expires>] [<reason>]
$ tctl acl users add support-engineers bob "" "Bob is now part of the on-call support rotation"
```

Finally, list the Access List members:
```code
$ tctl acl users ls support-engineers
Members of support-engineers:
- bob
```

</TabItem>
</Tabs>

## Managing Access List members with Terraform

When using the Teleport Terraform provider (but not the Kubernetes Operator),
**Static Access Lists** differ from the default Access Lists in that they
support managing members via Infrastructure as Code. For static Access Lists,
the source of truth for the membership is external--an Infrastructure as Code
configuration-- so audit is not supported. The members should be reviewed at
source, which are the Terraform data sources or manifests and this process has
to be external to Teleport.

Edit the Access List you created earlier to set the type to `"static"`, which
marks it as a static Access List. While Teleport ignores the `spec.audit` field
for static Access Lists, you can remove it for clarity as below:

```diff
  resource "teleport_access_list" "support-engineers" {
    header =  {
      version = "v1"
      metadata = {
        name = "support-engineers"
      }
    }
  
    spec = {
+     type = "static"
      title = "Production access for support engineers"
      description = "Use this Access List to grant access to production to your engineers enrolled in the support rotation."
-     audit = {
-     recurrence = {
-       frequency = 6
-     }
-   }
    }
  # remaining fields truncated
  }
```

### Assigning users to an Access List

To assign a user as a member of an Access List, declare a
`teleport_access_list_member` resource and set its `spec.membership_kind` to
`1`, which indicates that the member is a user:

```hcl
resource "teleport_access_list_member" "developers_alice" {
  header = {
    version = "v1"
    metadata = {
      name = "alice" # Teleport user name
    }
  }
  spec = {
    access_list     = teleport_access_list.support-engineers.id
    membership_kind = 1 # 1 for "MEMBERSHIP_KIND_USER", 2 for "MEMBERSHIP_KIND_LIST"
  }
}

resource "teleport_access_list_member" "developers_bob" {
  header = {
    version = "v1"
    metadata = {
      name = "bob"
    }
  }
  spec = {
    access_list     = teleport_access_list.support-engineers.id
    membership_kind = 1 # 1 for "MEMBERSHIP_KIND_USER", 2 for "MEMBERSHIP_KIND_LIST"
  }
}
```

Notice that both members' `spec.access_list` refers to the ID of the
`support-engineers` Access List you created earlier.

### Assigning nested Access Lists

Static Access Lists also allow you to assign nested Access Lists. For example,
consider the following `teleport_access_list_member` resource:

```hcl
resource "teleport_access_list_member" "db_access_staging_developers" {
  header = {
    version = "v1"
    metadata = {
      name = teleport_access_list.technical-account-managers.id
    }
  }
  spec = {
    access_list     = teleport_access_list.support-engineers.id
    membership_kind = 2 # 1 for "MEMBERSHIP_KIND_USER", 2 for "MEMBERSHIP_KIND_LIST"
  }
}
```

This resource has a `spec.membership_kind` of `2`, indicating that it is a
nested Access List. The name of the member is the ID of another Access List
(not shown in this guide) called `technical-account-managers`. This instructs
the Terraform provider to assign the `technical-account-managers` Access List as
a nested Access List within `support-engineers`.

### Give access to an Okta or Microsoft Entra ID group

The Okta integration allows [synchronizing Okta groups and
apps](../../../identity-governance/integrations/okta/app-and-group-sync.mdx) as Teleport Access Lists, while the
Microsoft Entra ID integration allows [synchronizing
groups](../../../identity-governance/integrations/entra-id/entra-id.mdx) as Teleport Access Lists. 

To give permissions to an Access List based on these integrations in Terraform,
navigate to the Access List in the Web UI, and from its URL (e.g.
`https://example.teleport.sh/web/accesslists/00gt3c8z9ukePm5uF697`) copy the
last path segment. In this case `00gt3c8z9ukePm5uF697` - this is the name of the
Access List resource in Teleport.

For example, the following `teleport_access_list_member` configures an Access
List managed via the Okta integration to be a child of the `support-engineers`
Access List:

```hcl
resource "teleport_access_list_member" "db_access_staging_okta_group" {
  header = {
    version = "v1"
    metadata = {
      name = "00gt3c8z9ukePm5uF697"
    }
  }
  spec = {
    access_list     = teleport_access_list.support-engineers.id
    membership_kind = 2 # 1 for "MEMBERSHIP_KIND_USER", 2 for "MEMBERSHIP_KIND_LIST"
  }
}
```

For an Access List managed via the Microsoft Entra ID integration, the name of
the Access List will be similar to `b1a6a594-a4ac-51d1-a6f6-1746a413a79a`.

### Importing Access Lists created using the Web UI into Terraform

It is usually not possible to import Access Lists created using the Web UI into
a Terraform module. Any Access List can be imported, but Access Lists created in
the UI are not of the static type, so their members can't be managed with Terraform.
The same applies to Access Lists created by an integration (e.g.
[Okta](../../../identity-governance/integrations/okta/app-and-group-sync.mdx) or
[Microsoft Entra ID](../../../identity-governance/integrations/entra-id/entra-id.mdx)).  An
existing static list created by another Terraform setup (with a different state)
could be imported, and its members can be managed by Terraform, but this
situation is unusual.

The recommended solution is to create a static Access List managed with
Terraform and make this list a member of an existing Access List. That way the
members of the static Access List managed with Terraform will inherit the grants
of the existing Access List.

## Next steps

You can see all supported Access List fields
[in the Access List reference](../../../reference/access-controls/access-lists.mdx).
