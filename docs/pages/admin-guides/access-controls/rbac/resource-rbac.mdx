---
title: Getting Started With Per-Resource Role-Based Access Control
description: Implementing fine-grained access control with RBAC.
---

Per-resource RBAC enables administrators to control user access on a per-resource basis. Using a granular approach allows you to grant more precise management of user permissions in your environment.

## What is per-resource RBAC?

This capability is particularly useful in complex, multi-tenant environments where user groups have varying levels of access requirements. It allows for precise control over permissions, enabling restricted access to sensitive resources for certain users while granting broader access to others based on their operational needs.

## Use cases

### Multi-tenant environments

In a multi-tenant setup, per-resource RBAC can ensure that each client or team has access only to their specific resources, preventing any accidental or intentional cross-tenant access.

### Compliance requirements
For industries with strict regulatory requirements (e.g., finance, healthcare), per-resource RBAC helps in implementing and demonstrating compliance with access control policies.

### Team management
For new team members or roles, per-resource RBAC facilitates a gradual increase in access privileges as users become more familiar with the systems and demonstrate need and competence.
When working with external contractors, per-resource RBAC allows granting temporary, limited access to specific resources without exposing the entire infrastructure.

### DevOps workflows
In CI/CD pipelines, different stages may require different levels of access; per-resource RBAC can be used to grant just-in-time access for specific tasks in the pipeline.

Let's look at some examples of how per-resource RBAC can be implemented:

**SSH access control**

```code
kind: role
version: v3
metadata:
 name: dev-team
spec:
 allow:
    logins: ['ubuntu']
    node_labels:
      environment: ['dev', 'staging']
    rules:
      - resources: ['session']
        verbs: ['read', 'list']
```

This role allows members of the dev team to SSH into nodes labeled as 'dev' or 'staging' environments, using the 'ubuntu' user account. 
They can also read and list session information.

**Kubernetes access control**

```code
kind: role
version: v3
metadata:
  name: k8s-dev
spec:
  allow:
    kubernetes_groups: ['system:developers']
    kubernetes_resources:
      - kind: pod
        namespace: 'dev-*'
        verbs: ['get', 'list', 'create', 'update', 'delete']
      - kind: service
        namespace: 'dev-*'
        verbs: ['get', 'list']
```

This role grants developers access to manage pods in any namespace starting with 'dev-', while only allowing them to view services in those namespaces.

**Database access control**

```code
kind: role
version: v3
metadata:
  name: db-readonly
spec:
  allow:
    db_labels:
      environment: ['production']
      type: ['postgres']
    db_names: ['analytics', 'reporting']
    db_users: ['readonly']
```

This role provides read-only access to production PostgreSQL databases named 'analytics' and 'reporting' using the 'readonly' database user.


