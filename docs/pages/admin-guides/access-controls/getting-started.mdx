---
title: Getting Started With Role-Based Access Control
description: Teleport Role-Based Access Control.
---

This guide helps you understand and implement Role-Based Access Control (RBAC) in Teleport. If you're new to managing access in Teleport, you'll learn how to create basic roles, assign them to users, and control access to your resources.

By the end of this guide, you'll be able to:

- Understand how roles control access to resources.
- Implement common access patterns.
- Create and configure basic roles in Teleport.
- Assign roles to users.
- Follow best practices to scale and maintain roles.

## What is RBAC?

RBAC (Role-Based Access Control) is Teleport's system for managing who can access what within your infrastructure. Instead of assigning permissions directly to users, you create roles that define sets of permissions, then assign those roles to users.

Think of roles as job descriptions - they define what actions someone can perform and what resources they can access.

### Key components

**Roles**: 

Define what actions are allowed.

- Which resources are accessible.
- What actions can be performed (read, write, etc.).
- When access is allowed.

**Users**: 

The entities that need access.

- Can be assigned one or more roles.
- Can be local users or SSO users.
- Inherit permissions from their assigned roles.

**Resources**: 

What users need access to.

- SSH servers
- Kubernetes clusters
- Databases
- Web applications

### Understanding role components

Teleport’s roles are defined using YAML. For example:

- `kind: role`: Tells Teleport this is a role definition
- `name: staging-access`: What you'll reference when assigning the role
- `allow`: Defines what the role permits
- `logins`: Specifies the system user names allowed for SSH
- `node_labels`: Controls which servers can be accessed based on their labels

### Resource labels

Resource labeling is a crucial component of effective RBAC implementation in Teleport. Labels help you define which specific 
resources users can access and why they need that access. Some common labels to consider using:

- Environment (`dev`, `staging`, `production`)
- Team ownership (`backend`, `frontend`, `data`)
- Project or application (`auth-service`, `billing-api`)
- Cost center or business unit (`marketing`, `engineering`)

Example label structure:

```yaml
kind: role
version: v7
metadata:
  name: senior-developer
spec:
  allow:
    node_labels:
      environment: ['dev', 'staging']  # Environment context
      team: 'backend'                  # Team context
      project: 'auth-service'          # Project context
```

Teleport roles can match labels in several ways:

**Exact matching**

```yaml
node_labels:
  environment: 'production'  # Matches only 'production'
```

**Multiple values**

```yaml
node_labels:
  environment: ['dev', 'staging']  # Matches either 'dev' or 'staging'
```

**Wildcard matching**

```yaml
node_labels:
  project: 'api-*'  # Matches any project starting with 'api-'
```

#### Maintaining your labeling strategy

**Regular Review**

Regular audits of your labeling scheme are essential for maintaining an effective RBAC system. Your organization's structure 
and needs evolve over time, so your labels should be reviewed to ensure they accurately reflect these changes. 

**Documentation**

Maintaining consistency across your organization. Include clear guidelines for label naming conventions to ensure 
standardization and prevent confusion as your team grows and your infrastructure expands.

**Automation**

Implementing automation in your labeling strategy will maintain consistency and reduce human error as your system scales and evolves. 

## Creating your first role
  
### Step 1/3

Let's set up an example role for team members who need access to staging environments. 
Create a role definition file called staging-access.yaml with the following content:

```yaml
kind: role
version: v7
metadata:
  name: staging-access
spec:
  allow:
    logins: ['dev']
    node_labels:
      'env': 'staging'
  deny:
    node_labels:
      'env': 'production'
```

### Step 2/3

Apply this role using the following command:

```code
$ tctl create -f staging-access.yaml
```
This role allows the user to log in as the `dev` user to servers labeled with `env: staging` and explicitly denies access to any server labeled `env: production`.

### Step 3/3

Now that you’ve created a role, assign it to a local user named Alice:

```code
$ tctl users add alice --roles=staging-access
```

Alice can now log in to staging servers, but she will be blocked from production environments.

### Assigning roles to users

Once you've created a role, you can assign it to users. For example:

```bash
# Assign to a new user
tctl users add alice --roles=staging-access

# Update existing user's roles
tctl users update bob --set-roles=staging-access
```

### Common use cases examples

**Basic Developer Access**

```yaml
kind: role
version: v8
metadata:
  name: developer
spec:
  allow:
    logins: ['dev']
    node_labels:
      'env': ['staging', 'dev']
    kubernetes_labels:
      'env': 'dev'
```

**Read-only Auditor**

```yaml
kind: role
version: v7
metadata:
  name: auditor
spec:
  allow:
    logins: ['readonly']
    rules:
      - resources: ['session']
        verbs: ['list', 'read']
```

### Per-resource RBAC

Per-resource RBAC extends basic RBAC by allowing you to define permissions at the individual resource level. This means you can create more specific access rules based on resource attributes.

For example, instead of giving database admins access to all databases, you can specify:

```yaml
kind: role
version: v7
metadata:
  name: db-admin
spec:
  allow:
    db_labels:
      environment: ['production']
      type: ['postgres']
    db_names: ['analytics-*']
    db_users: ['readonly']
```

This role only allows access to:
- Production environment databases
- PostgreSQL databases
- Databases with names starting with 'analytics-'
- Using the 'readonly' database user

You can combine multiple attributes to create precise access controls:

```yaml
kind: role
version: v7
metadata:
  name: k8s-dev
spec:
  allow:
    kubernetes_groups: ['system:developers']
    kubernetes_resources:
      - kind: pod
        namespace: 'dev-*'
        verbs: ['get', 'list', 'create']
```

## Best practices

Keep these key principles in mind to maintain a secure environment:

- **Regular audits**: 
Periodically review and update RBAC policies to ensure they align with current organizational needs and security best practices.
- **Principle of least privilege**: 
Always start with minimal access and gradually increase permissions as needed. Use descriptive role names that reflect their purpose.
- **Integration with identity providers (IdPs) like Okta and AWS OIDC**:
Leverage existing identity management systems to streamline user management and access control.
- **Monitoring and alerting**:
Set up comprehensive logging and alerting for access events, especially for sensitive resources.
- **User education**:
Ensure that all users understand their access levels and the importance of adhering to security policies.
Document your role configurations.


## Next steps

- [Mapping SSO and local users traits with role templates](../access-controls/guides/role-templates.mdx)
- [Access Control for Servers](../../enroll-resources/server-access/rbac.mdx)
- [Access Control for Kubernetes](../../enroll-resources/kubernetes-access/controls.mdx)
- [Enforce Device Trust with RBAC](./device-trust/device-trust.mdx).
