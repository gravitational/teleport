---
title: Getting Started With Role-Based Access Control
description: Teleport Role-Based Access Control.
---

In Teleport, RBAC (Role-Based Access Control) is a system that helps you manage who can access various resources such as databases, SSH servers, Kubernetes clusters, Windows desktops, and web apps. 


A Teleport user can be assigned one or several roles. Roles govern access to your resources and infrastructure.

Each role defines specific permissions to ensure that users only have access to what they need. 


Roles determine what resources a user can access and what actions they can perform within the system. 

By creating and assigning roles, administrators can enforce security policies, manage access, and ensure users have the appropriate level of privileges based on their responsibilities.

## Teleport users

Users are entities that can authenticate and interact with the resources within a Teleport cluster. These users can have different levels of access depending on the roles assigned to them. 

Teleport supports both local (internal) users and SSO (external) users, which differ mainly in how they authenticate and how they are managed.

### Local users

Local users are created and managed directly within the Teleport cluster itself. Local users can be created via the CLI (tctl users add), by applying a user resource manifest (tctl create -f user.yaml) or 
via the web UI. Their roles and traits can be modified directly in Teleport.

Local users can authenticate using credentials managed within Teleport, such as:
- Username and password
- Multi-factor authentication (MFA), such as TOTP (time-based one-time passwords)

Local users are assigned roles that define what resources they can access and what actions they can perform within the cluster. They are typically used for small to mid-size deployments where user management 
is handled directly in Teleport without relying on SSO identity providers.

### SSO users

SSO users authenticate using SSO Identity Providers (IdP), such as Okta, Google, GitHub, Microsoft Entra ID, or other SAML/OIDC providers. These users do not manage their passwords or credentials within Teleport itself. Instead, they authenticate using their SSO credentials. For example, a user in the "admin" group in Okta can be mapped to the admin role in Teleport. 

SSO users are useful for larger organizations or those that want to centralize identity management via an existing SSO provider. This is often preferred for enterprise environments where identity management is handled outside Teleport.

### Bot users

Machine ID provides machines with an identity that can authenticate to the Teleport cluster. This identity is known as a robot. Robots are represented in Teleport by a user and a role resource and can be created via the tctl bots add command. Unlike human users, who use a password, MFA, or SSO, robot users join the cluster as Teleport services using a join method. They can still join even if local auth is disabled.

See the [Machine ID introduction](../../enroll-resources/machine-id/introduction.mdx) for more information.

## Teleport roles

Some examples of roles include:

- **access**: Grants basic access to resources.
- **editor**: Allows users to modify configuration settings.
- **auditor**: Allows users to view logs and auditing activities.

Roles enforce Role-Based Access Control (RBAC), ensuring that users only have the permissions needed for their specific tasks. 
See [Teleport Access Controls Reference](../../reference/access-controls/roles.mdx) for in-depth information about types of roles, options, and usage.

## Understanding Teleport’s resource tagging and matching

Before configuring RBAC, it’s essential to understand how Teleport tags and matches resources to users’ roles.

- Resource tagging: Teleport uses labels (key-value pairs) to tag resources like SSH nodes, databases, or Kubernetes clusters. For example, a server might have the label env: production.
- Role matching: A role in Teleport allows or denies access to resources based on matching these labels. For instance, if a user has a role that allows access to resources labeled env: staging, they will only access resources with that label.

You can use this labeling and matching logic to grant users specific access, ensuring they only interact with the resources they need.

## Understanding Teleport’s YAML configuration

Teleport’s roles are defined using YAML. Here’s a breakdown of a basic role configuration:

- **kind**: The type of resource being created. For roles, this will always be role.
- **metadata**: Includes information like the role’s name, which is used to identify the role.
- **spec**: This section defines what the role can and cannot do.
- **allow**: Lists the permissions the role grants, such as allowed logins or access to resources based on labels.
- **deny**: Specifies any permissions that should be explicitly denied, even if they would otherwise be allowed.

##  Creating a Basic Role for SSH Access

- (!docs/pages/includes/edition-prereqs-tabs.mdx!)

### Step 1/3

Let’s set up a sample role that gives users access to staging servers for SSH access. Create a role definition file called staging-access.yaml with the following content:

```yaml
kind: role
version: v7
metadata:
  name: staging-access
spec:
  allow:
    logins: ['dev']
    node_labels:
      'env': 'staging'
  deny:
    node_labels:
      'env': 'production'

```

### Step 2/3

Apply this role using the following command:

```code
$ tctl create -f staging-access.yaml
```
This role allows the user to log in as the `dev` user to servers labeled with `env: staging` and explicitly denies access to any server labeled `env: production`.

### Step 3/3

Assigning the Role to a User

Now that you’ve created a role, assign it to a local user named Alice:

```code
$ tctl users add alice --roles=staging-access
```

Alice can now log in to staging servers, but she will be blocked from production environments.

## Add users with preset roles

Teleport provides several preset roles, which can be used with SSO or local users:

(!docs/pages/includes/preset-roles-table.mdx!)

Invite Alice as cluster `editor`:

```code
$ tctl users add alice --roles=editor
```

Invite Alice as cluster `editor` and `reviewer`:

```code
$ tctl users add alice --roles=editor,reviewer
```

Once Alice signs up, she will be able to edit cluster configuration. You can list
users and their roles using `tctl users ls`.


```code
$ tctl users ls

# User                 Roles
# -------------------- --------------
# alice                editor, reviewer
```

You can update the user's roles using the `tctl users update` command:

```code
$ tctl users update alice --set-roles=editor,auditor
```

Once Alice logs back in, she will be able to view audit logs.

```code
$ tctl users update alice --set-roles=editor,reviewer,auditor
```

Because Alice has two or more roles, permissions from those roles create a union. She will be able to act as a system administrator and auditor at the same time.

## Create a custom role

Let's create a custom role for interns. Interns will have access
to test or staging SSH servers as `readonly` users. We will let them
view some monitoring web applications and dev kubernetes cluster.

Save this role as `interns.yaml`:

```yaml
kind: role
version: v8
metadata:
  name: interns
spec:
  allow:
    # Logins configures SSH login principals
    logins: ['readonly']
    # Assigns users with this role to the built-in Kubernetes group "view"
    kubernetes_groups: ["view"]
    # Allow access to SSH nodes, Kubernetes clusters, apps or databases
    # labeled with "staging" or "test"
    node_labels:
      'env': ['staging', 'test']
    kubernetes_labels:
      'env': 'dev'
    kubernetes_resources:
      - kind: "*"
        api_group: "*"
        namespace: "*"
        name: "*"
        verbs: ["*"]
    app_labels:
      'type': ['monitoring']
  # The deny rules always override allow rules.
  deny:
    # deny access to any Node, database, app or Kubernetes cluster labeled
    # as prod as any user.
    node_labels:
      'env': 'prod'
    kubernetes_labels:
      'env': 'prod'
    kubernetes_resources:
      - kind: "namespaces"
        name: "prod"
    db_labels:
      'env': 'prod'
    app_labels:
      'env': 'prod'
```

Create a role using the `tctl create -f` command:

```code
$ tctl create -f /tmp/interns.yaml
# Get a list of all roles in the system
$ tctl get roles --format text
```

(!docs/pages/includes/create-role-using-web.mdx!)

Next, follow the instructions to set up an authentication connector that maps users within your SSO solution to Teleport roles. Follow the instructions 
to set up an authentication connector that maps users within your [SSO solution](../../admin-guides/access-controls/sso/sso/) to Teleport roles.

## Per-resource RBAC

Per-resource RBAC is an access control system that enables you to define and enforce permissions at the individual resource level, 
rather than just at the role level. A resource could be a specific database, server, Kubernetes pod, or application. 
Instead of granting blanket permissions through roles alone (like "can access all databases"), per-resource RBAC lets you create 
rules that combine both roles and resource-specific attributes (like "can access only production databases with the label `analytics`").

Here's a concrete example to illustrate:

Traditional RBAC might say: "Database Admins can access all databases". Per-resource RBAC can say: "Database Admins can access databases where:

- Environment label = 'production'
- Database type = 'postgres'
- Database name matches 'analytics-*'
- Access time is between 9 AM and 5 PM"

This makes per-resource RBAC fundamentally different from traditional RBAC because permissions are evaluated using both the role and the resource's characteristics. 
Access decisions can consider multiple attributes of individual resources; the same role can result in tiered permissions for different resources based on their properties. 
This fine-grained access control capability is particularly useful in complex, multi-tenant environments where user groups have varying levels of access requirements.

## Use cases

- **Multi-tenant environments**

In a multi-tenant setup, per-resource RBAC can ensure that each client or team has access only to their specific resources, preventing any accidental or intentional cross-tenant access.

- **Compliance requirements**

For industries with strict regulatory requirements (e.g., finance, healthcare), per-resource RBAC helps in implementing and demonstrating compliance with access control policies.

- **Team management**

For new team members or roles, per-resource RBAC facilitates a gradual increase in access privileges as users become more familiar with the systems and demonstrate need and competence.
When working with SSO contractors, per-resource RBAC allows granting temporary, limited access to specific resources without exposing the entire infrastructure.

- **DevOps workflows**

In CI/CD pipelines, different stages may require different levels of access; per-resource RBAC can be used to grant just-in-time access for specific tasks in the pipeline.

Let's look at some examples of how per-resource RBAC can be implemented:

**SSH access control**

```code
kind: role
version: v3
metadata:
 name: dev-team
spec:
 allow:
    logins: ['ubuntu']
    node_labels:
      environment: ['dev', 'staging']
    rules:
      - resources: ['session']
        verbs: ['read', 'list']
```

This role allows members of the dev team to SSH into nodes labeled as 'dev' or 'staging' environments, using the 'ubuntu' user account. 
They can also read and list session information.

**Kubernetes access control**

```code
kind: role
version: v3
metadata:
  name: k8s-dev
spec:
  allow:
    kubernetes_groups: ['system:developers']
    kubernetes_resources:
      - kind: pod
        namespace: 'dev-*'
        verbs: ['get', 'list', 'create', 'update', 'delete']
      - kind: service
        namespace: 'dev-*'
        verbs: ['get', 'list']
```

This role grants developers access to manage pods in any namespace starting with 'dev-', while only allowing them to view services in those namespaces.

**Database access control**

```code
kind: role
version: v3
metadata:
  name: db-readonly
spec:
  allow:
    db_labels:
      environment: ['production']
      type: ['postgres']
    db_names: ['analytics', 'reporting']
    db_users: ['readonly']
```

This role provides read-only access to production PostgreSQL databases named 'analytics' and 'reporting' using the 'readonly' database user.

## Best practices

Keep these key principles in mind to maintain a secure environment:

- **Regular audits**: 
Periodically review and update RBAC policies to ensure they align with current organizational needs and security best practices.
- **Principle of least privilege**: 
Always start with minimal access and gradually increase permissions as needed.
- **Integration with identity providers (IdPs) like Okta and AWS OIDC**:
Leverage existing identity management systems to streamline user management and access control.
- **Monitoring and alerting**:
Set up comprehensive logging and alerting for access events, especially for sensitive resources.
- **User education**:
Ensure that all users understand their access levels and the importance of adhering to security policies.

## Next steps

- [Mapping SSO and local users traits with role templates](../access-controls/guides/role-templates.mdx)
- [Access Control for Servers](../../enroll-resources/server-access/rbac.mdx)
- [Access Control for Kubernetes](../../enroll-resources/kubernetes-access/controls.mdx)
- [Enroll a Kubernetes Cluster](../../enroll-resources/kubernetes-access/getting-started.mdx) 
- [Create certs for CI/CD using impersonation](../../admin-guides/access-controls/guides/impersonation.mdx) 
