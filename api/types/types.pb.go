// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/legacy/types/types.proto

package types

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	github_com_gravitational_teleport_api_constants "github.com/gravitational/teleport/api/constants"
	v1 "github.com/gravitational/teleport/api/gen/proto/go/attestation/v1"
	_ "github.com/gravitational/teleport/api/types/wrappers"
	github_com_gravitational_teleport_api_types_wrappers "github.com/gravitational/teleport/api/types/wrappers"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// IAMPolicyStatus represents states that describe if an AWS database
// has its IAM policy properly configured or not.
// This enum is set in a Sync.Map during an IAM task that checks for the
// validity of IAM policy, and the database gets updated with the value
// from this map during a heartbeat.
type IAMPolicyStatus int32

const (
	// IAM_POLICY_STATUS_UNSPECIFIED represents a zero value where
	// nothing has been attempted yet.
	IAMPolicyStatus_IAM_POLICY_STATUS_UNSPECIFIED IAMPolicyStatus = 0
	// IAM_POLICY_STATUS_PENDING represents a state where iam policy status
	// is pending to be checked. This enum value is set at the start of
	// registering a database -> IAM setup (before the db heartbeat starts).
	//
	// This state was required for two reasons:
	//   1) To be able to tell apart from an older service that do not update
	//      the IAMPolicyStatus (in which case the enum value will remain the
	//      zero value).
	//   2) When starting a database, the heartbeat and its IAM task starts,
	//      and the heartbeat may run first before the IAM task finishes.
	IAMPolicyStatus_IAM_POLICY_STATUS_PENDING IAMPolicyStatus = 1
	// IAM_POLICY_STATUS_FAILED represents a state where an error occured
	// while checking for IAM policy status eg: no AWS credentials provider found
	// or the policy was misconfigured.
	IAMPolicyStatus_IAM_POLICY_STATUS_FAILED IAMPolicyStatus = 2
	// IAM_POLICY_STATUS_SUCCESS represents a state where IAM policy was configured
	// correctly.
	IAMPolicyStatus_IAM_POLICY_STATUS_SUCCESS IAMPolicyStatus = 3
)

var IAMPolicyStatus_name = map[int32]string{
	0: "IAM_POLICY_STATUS_UNSPECIFIED",
	1: "IAM_POLICY_STATUS_PENDING",
	2: "IAM_POLICY_STATUS_FAILED",
	3: "IAM_POLICY_STATUS_SUCCESS",
}

var IAMPolicyStatus_value = map[string]int32{
	"IAM_POLICY_STATUS_UNSPECIFIED": 0,
	"IAM_POLICY_STATUS_PENDING":     1,
	"IAM_POLICY_STATUS_FAILED":      2,
	"IAM_POLICY_STATUS_SUCCESS":     3,
}

func (x IAMPolicyStatus) String() string {
	return proto.EnumName(IAMPolicyStatus_name, int32(x))
}

func (IAMPolicyStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{0}
}

// DatabaseTLSMode represents the level of TLS verification performed by
// DB agent when connecting to a database.
type DatabaseTLSMode int32

const (
	// VERIFY_FULL performs full certificate validation.
	DatabaseTLSMode_VERIFY_FULL DatabaseTLSMode = 0
	// VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.
	DatabaseTLSMode_VERIFY_CA DatabaseTLSMode = 1
	// INSECURE accepts any certificate provided by server. This is the least secure option.
	DatabaseTLSMode_INSECURE DatabaseTLSMode = 2
)

var DatabaseTLSMode_name = map[int32]string{
	0: "VERIFY_FULL",
	1: "VERIFY_CA",
	2: "INSECURE",
}

var DatabaseTLSMode_value = map[string]int32{
	"VERIFY_FULL": 0,
	"VERIFY_CA":   1,
	"INSECURE":    2,
}

func (x DatabaseTLSMode) String() string {
	return proto.EnumName(DatabaseTLSMode_name, int32(x))
}

func (DatabaseTLSMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{1}
}

// PrivateKeyType is the storage type of a private key.
type PrivateKeyType int32

const (
	// RAW is a plaintext private key.
	PrivateKeyType_RAW PrivateKeyType = 0
	// PKCS11 is a private key backed by a PKCS11 device such as HSM.
	PrivateKeyType_PKCS11 PrivateKeyType = 1
	// GCP_KMS is a private key backed by GCP KMS.
	PrivateKeyType_GCP_KMS PrivateKeyType = 2
	// AWS_KMS is a private key backed by AWS KMS.
	PrivateKeyType_AWS_KMS PrivateKeyType = 3
)

var PrivateKeyType_name = map[int32]string{
	0: "RAW",
	1: "PKCS11",
	2: "GCP_KMS",
	3: "AWS_KMS",
}

var PrivateKeyType_value = map[string]int32{
	"RAW":     0,
	"PKCS11":  1,
	"GCP_KMS": 2,
	"AWS_KMS": 3,
}

func (x PrivateKeyType) String() string {
	return proto.EnumName(PrivateKeyType_name, int32(x))
}

func (PrivateKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{2}
}

// ProxyListenerMode represents the cluster proxy listener mode.
type ProxyListenerMode int32

const (
	// Separate is the proxy listener mode indicating that proxies are running
	// in separate listener mode where Teleport Proxy services use different listeners.
	ProxyListenerMode_Separate ProxyListenerMode = 0
	// Multiplex is the proxy listener mode indicating the proxy should use multiplex mode
	// where all proxy services are multiplexed on a single proxy port.
	ProxyListenerMode_Multiplex ProxyListenerMode = 1
)

var ProxyListenerMode_name = map[int32]string{
	0: "Separate",
	1: "Multiplex",
}

var ProxyListenerMode_value = map[string]int32{
	"Separate":  0,
	"Multiplex": 1,
}

func (x ProxyListenerMode) String() string {
	return proto.EnumName(ProxyListenerMode_name, int32(x))
}

func (ProxyListenerMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{3}
}

// RoutingStrategy determines the strategy used to route to nodes.
type RoutingStrategy int32

const (
	// UnambiguousMatch only routes to distinct nodes.
	RoutingStrategy_UNAMBIGUOUS_MATCH RoutingStrategy = 0
	// MostRecent routes to the most recently heartbeated node if duplicates are present.
	RoutingStrategy_MOST_RECENT RoutingStrategy = 1
)

var RoutingStrategy_name = map[int32]string{
	0: "UNAMBIGUOUS_MATCH",
	1: "MOST_RECENT",
}

var RoutingStrategy_value = map[string]int32{
	"UNAMBIGUOUS_MATCH": 0,
	"MOST_RECENT":       1,
}

func (x RoutingStrategy) String() string {
	return proto.EnumName(RoutingStrategy_name, int32(x))
}

func (RoutingStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{4}
}

// UserTokenUsage contains additional information about the intended usage of a user token.
type UserTokenUsage int32

const (
	// Default value that implies token usage was not set.
	UserTokenUsage_USER_TOKEN_USAGE_UNSPECIFIED UserTokenUsage = 0
	// USER_TOKEN_RECOVER_PASSWORD is a request to recover password.
	UserTokenUsage_USER_TOKEN_RECOVER_PASSWORD UserTokenUsage = 1
	// USER_TOKEN_RECOVER_MFA is a request to recover a MFA.
	UserTokenUsage_USER_TOKEN_RECOVER_MFA UserTokenUsage = 2
	// USER_TOKEN_RENEWAL_BOT is a request to generate certificates
	// for a bot user.
	UserTokenUsage_USER_TOKEN_RENEWAL_BOT UserTokenUsage = 3
)

var UserTokenUsage_name = map[int32]string{
	0: "USER_TOKEN_USAGE_UNSPECIFIED",
	1: "USER_TOKEN_RECOVER_PASSWORD",
	2: "USER_TOKEN_RECOVER_MFA",
	3: "USER_TOKEN_RENEWAL_BOT",
}

var UserTokenUsage_value = map[string]int32{
	"USER_TOKEN_USAGE_UNSPECIFIED": 0,
	"USER_TOKEN_RECOVER_PASSWORD":  1,
	"USER_TOKEN_RECOVER_MFA":       2,
	"USER_TOKEN_RENEWAL_BOT":       3,
}

func (x UserTokenUsage) String() string {
	return proto.EnumName(UserTokenUsage_name, int32(x))
}

func (UserTokenUsage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{5}
}

// RequestState represents the state of a request for escalated privilege.
type RequestState int32

const (
	// NONE variant exists to allow RequestState to be explicitly omitted
	// in certain circumstances (e.g. in an AccessRequestFilter).
	RequestState_NONE RequestState = 0
	// PENDING variant is the default for newly created requests.
	RequestState_PENDING RequestState = 1
	// APPROVED variant indicates that a request has been accepted by
	// an administrating party.
	RequestState_APPROVED RequestState = 2
	// DENIED variant indicates that a request has been rejected by
	// an administrating party.
	RequestState_DENIED RequestState = 3
	// PROMOTED variant indicates that a request has been promoted to
	// an access list.
	RequestState_PROMOTED RequestState = 4
)

var RequestState_name = map[int32]string{
	0: "NONE",
	1: "PENDING",
	2: "APPROVED",
	3: "DENIED",
	4: "PROMOTED",
}

var RequestState_value = map[string]int32{
	"NONE":     0,
	"PENDING":  1,
	"APPROVED": 2,
	"DENIED":   3,
	"PROMOTED": 4,
}

func (x RequestState) String() string {
	return proto.EnumName(RequestState_name, int32(x))
}

func (RequestState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{6}
}

type AccessRequestScope int32

const (
	// DEFAULT allows all requests to be viewed
	AccessRequestScope_DEFAULT AccessRequestScope = 0
	// MY_REQUESTS will return only requests created by the requester
	AccessRequestScope_MY_REQUESTS AccessRequestScope = 1
	// NEEDS_REVIEW will return only requests that were not created by
	// the requester and do not include a review made by the requester
	AccessRequestScope_NEEDS_REVIEW AccessRequestScope = 2
	// REVIEWED will return only requests that were not created by
	// the requester and have a review submitted by the requester. This
	// can include requests that have no yet been completely approved/denied.
	AccessRequestScope_REVIEWED AccessRequestScope = 3
)

var AccessRequestScope_name = map[int32]string{
	0: "DEFAULT",
	1: "MY_REQUESTS",
	2: "NEEDS_REVIEW",
	3: "REVIEWED",
}

var AccessRequestScope_value = map[string]int32{
	"DEFAULT":      0,
	"MY_REQUESTS":  1,
	"NEEDS_REVIEW": 2,
	"REVIEWED":     3,
}

func (x AccessRequestScope) String() string {
	return proto.EnumName(AccessRequestScope_name, int32(x))
}

func (AccessRequestScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{7}
}

// CreateHostUserMode determines whether host user creation should be
// disabled or if host users should be cleaned up or kept after
// sessions end.
type CreateHostUserMode int32

const (
	CreateHostUserMode_HOST_USER_MODE_UNSPECIFIED CreateHostUserMode = 0
	// HOST_USER_MODE_OFF disables host user creation.
	CreateHostUserMode_HOST_USER_MODE_OFF CreateHostUserMode = 1
	// HOST_USER_MODE_DROP enables host user creation and deletes users at session end.
	// Deprecated: replaced by HOST_USER_MODE_INSECURE_DROP.
	CreateHostUserMode_HOST_USER_MODE_DROP CreateHostUserMode = 2 // Deprecated: Do not use.
	// HOST_USER_MODE_KEEP enables host user creation and leaves users behind at session end.
	CreateHostUserMode_HOST_USER_MODE_KEEP CreateHostUserMode = 3
	// HOST_USER_MODE_INSECURE_DROP enables host user creation without a home directory and deletes
	// users at session end.
	CreateHostUserMode_HOST_USER_MODE_INSECURE_DROP CreateHostUserMode = 4
)

var CreateHostUserMode_name = map[int32]string{
	0: "HOST_USER_MODE_UNSPECIFIED",
	1: "HOST_USER_MODE_OFF",
	2: "HOST_USER_MODE_DROP",
	3: "HOST_USER_MODE_KEEP",
	4: "HOST_USER_MODE_INSECURE_DROP",
}

var CreateHostUserMode_value = map[string]int32{
	"HOST_USER_MODE_UNSPECIFIED":   0,
	"HOST_USER_MODE_OFF":           1,
	"HOST_USER_MODE_DROP":          2,
	"HOST_USER_MODE_KEEP":          3,
	"HOST_USER_MODE_INSECURE_DROP": 4,
}

func (x CreateHostUserMode) String() string {
	return proto.EnumName(CreateHostUserMode_name, int32(x))
}

func (CreateHostUserMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{8}
}

// CreateDatabaseUserMode determines whether database user creation should be
// disabled or if users should be cleaned up or kept after sessions end.
type CreateDatabaseUserMode int32

const (
	CreateDatabaseUserMode_DB_USER_MODE_UNSPECIFIED CreateDatabaseUserMode = 0
	// DB_USER_MODE_OFF disables user creation.
	CreateDatabaseUserMode_DB_USER_MODE_OFF CreateDatabaseUserMode = 1
	// DB_USER_MODE_KEEP allows user creation and disable users at session end.
	CreateDatabaseUserMode_DB_USER_MODE_KEEP CreateDatabaseUserMode = 2
	// DB_USER_MODE_BEST_EFFORT_DROP allows user creation and tries to drop user
	// at session end. If the drop fails, fallback to disabling them.
	CreateDatabaseUserMode_DB_USER_MODE_BEST_EFFORT_DROP CreateDatabaseUserMode = 3
)

var CreateDatabaseUserMode_name = map[int32]string{
	0: "DB_USER_MODE_UNSPECIFIED",
	1: "DB_USER_MODE_OFF",
	2: "DB_USER_MODE_KEEP",
	3: "DB_USER_MODE_BEST_EFFORT_DROP",
}

var CreateDatabaseUserMode_value = map[string]int32{
	"DB_USER_MODE_UNSPECIFIED":      0,
	"DB_USER_MODE_OFF":              1,
	"DB_USER_MODE_KEEP":             2,
	"DB_USER_MODE_BEST_EFFORT_DROP": 3,
}

func (x CreateDatabaseUserMode) String() string {
	return proto.EnumName(CreateDatabaseUserMode_name, int32(x))
}

func (CreateDatabaseUserMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{9}
}

// CertExtensionMode specifies the type of extension to use in the cert.
type CertExtensionMode int32

const (
	// EXTENSION represents a cert extension that may or may not be
	// honored by the server.
	CertExtensionMode_EXTENSION CertExtensionMode = 0
)

var CertExtensionMode_name = map[int32]string{
	0: "EXTENSION",
}

var CertExtensionMode_value = map[string]int32{
	"EXTENSION": 0,
}

func (x CertExtensionMode) String() string {
	return proto.EnumName(CertExtensionMode_name, int32(x))
}

func (CertExtensionMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{10}
}

// CertExtensionType represents the certificate type the extension is for.
// Currently only ssh is supported.
type CertExtensionType int32

const (
	// SSH is used when extending an ssh certificate
	CertExtensionType_SSH CertExtensionType = 0
)

var CertExtensionType_name = map[int32]string{
	0: "SSH",
}

var CertExtensionType_value = map[string]int32{
	"SSH": 0,
}

func (x CertExtensionType) String() string {
	return proto.EnumName(CertExtensionType_name, int32(x))
}

func (CertExtensionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{11}
}

// PasswordState indicates what is known about existence of user's password.
type PasswordState int32

const (
	// Unable to tell whether the password has been configured.
	PasswordState_PASSWORD_STATE_UNSPECIFIED PasswordState = 0
	// Password is known to be not configured.
	PasswordState_PASSWORD_STATE_UNSET PasswordState = 1
	// Password is known to be configured.
	PasswordState_PASSWORD_STATE_SET PasswordState = 2
)

var PasswordState_name = map[int32]string{
	0: "PASSWORD_STATE_UNSPECIFIED",
	1: "PASSWORD_STATE_UNSET",
	2: "PASSWORD_STATE_SET",
}

var PasswordState_value = map[string]int32{
	"PASSWORD_STATE_UNSPECIFIED": 0,
	"PASSWORD_STATE_UNSET":       1,
	"PASSWORD_STATE_SET":         2,
}

func (x PasswordState) String() string {
	return proto.EnumName(PasswordState_name, int32(x))
}

func (PasswordState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{12}
}

// TrustedDeviceRequirement indicates whether access may be hindered by the lack
// of a trusted device.
type TrustedDeviceRequirement int32

const (
	// Device requirement not determined.
	// Does not mean that a device is not required, only that the necessary data
	// was not considered.
	TrustedDeviceRequirement_TRUSTED_DEVICE_REQUIREMENT_UNSPECIFIED TrustedDeviceRequirement = 0
	// Trusted device not required.
	TrustedDeviceRequirement_TRUSTED_DEVICE_REQUIREMENT_NOT_REQUIRED TrustedDeviceRequirement = 1
	// Trusted device required by either cluster mode or user roles.
	TrustedDeviceRequirement_TRUSTED_DEVICE_REQUIREMENT_REQUIRED TrustedDeviceRequirement = 2
)

var TrustedDeviceRequirement_name = map[int32]string{
	0: "TRUSTED_DEVICE_REQUIREMENT_UNSPECIFIED",
	1: "TRUSTED_DEVICE_REQUIREMENT_NOT_REQUIRED",
	2: "TRUSTED_DEVICE_REQUIREMENT_REQUIRED",
}

var TrustedDeviceRequirement_value = map[string]int32{
	"TRUSTED_DEVICE_REQUIREMENT_UNSPECIFIED":  0,
	"TRUSTED_DEVICE_REQUIREMENT_NOT_REQUIRED": 1,
	"TRUSTED_DEVICE_REQUIREMENT_REQUIRED":     2,
}

func (x TrustedDeviceRequirement) String() string {
	return proto.EnumName(TrustedDeviceRequirement_name, int32(x))
}

func (TrustedDeviceRequirement) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{13}
}

// SessionState represents the state of a session.
type SessionState int32

const (
	// Pending variant represents a session that is waiting on participants to fulfill the criteria
	// to start the session.
	SessionState_SessionStatePending SessionState = 0
	// Running variant represents a session that has had it's criteria for starting
	// fulfilled at least once and has transitioned to a RUNNING state.
	SessionState_SessionStateRunning SessionState = 1
	// Terminated variant represents a session that is no longer running and due for removal.
	SessionState_SessionStateTerminated SessionState = 2
)

var SessionState_name = map[int32]string{
	0: "SessionStatePending",
	1: "SessionStateRunning",
	2: "SessionStateTerminated",
}

var SessionState_value = map[string]int32{
	"SessionStatePending":    0,
	"SessionStateRunning":    1,
	"SessionStateTerminated": 2,
}

func (x SessionState) String() string {
	return proto.EnumName(SessionState_name, int32(x))
}

func (SessionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{14}
}

// AlertSeverity represents how problematic/urgent an alert is, and is used to assist
// in sorting alerts for display.
type AlertSeverity int32

const (
	AlertSeverity_LOW    AlertSeverity = 0
	AlertSeverity_MEDIUM AlertSeverity = 5
	AlertSeverity_HIGH   AlertSeverity = 10
)

var AlertSeverity_name = map[int32]string{
	0:  "LOW",
	5:  "MEDIUM",
	10: "HIGH",
}

var AlertSeverity_value = map[string]int32{
	"LOW":    0,
	"MEDIUM": 5,
	"HIGH":   10,
}

func (x AlertSeverity) String() string {
	return proto.EnumName(AlertSeverity_name, int32(x))
}

func (AlertSeverity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{15}
}

// RequireMFAType is a type of MFA requirement enforced outside of login,
// such as per-session MFA or per-request PIV touch.
type RequireMFAType int32

const (
	// OFF means additional MFA enforcement is not enabled.
	RequireMFAType_OFF RequireMFAType = 0
	// SESSION means MFA is required to begin server sessions.
	RequireMFAType_SESSION RequireMFAType = 1
	// SESSION_AND_HARDWARE_KEY means MFA is required to begin server sessions,
	// and login sessions must use a private key backed by a hardware key.
	RequireMFAType_SESSION_AND_HARDWARE_KEY RequireMFAType = 2
	// HARDWARE_KEY_TOUCH means login sessions must use a hardware private key that
	// requires touch to be used.
	RequireMFAType_HARDWARE_KEY_TOUCH RequireMFAType = 3
	// HARDWARE_KEY_PIN means login sessions must use a hardware private key that
	// requires pin to be used.
	RequireMFAType_HARDWARE_KEY_PIN RequireMFAType = 4
	// HARDWARE_KEY_TOUCH_AND_PIN means login sessions must use a hardware private key that
	// requires touch and pin to be used.
	RequireMFAType_HARDWARE_KEY_TOUCH_AND_PIN RequireMFAType = 5
)

var RequireMFAType_name = map[int32]string{
	0: "OFF",
	1: "SESSION",
	2: "SESSION_AND_HARDWARE_KEY",
	3: "HARDWARE_KEY_TOUCH",
	4: "HARDWARE_KEY_PIN",
	5: "HARDWARE_KEY_TOUCH_AND_PIN",
}

var RequireMFAType_value = map[string]int32{
	"OFF":                        0,
	"SESSION":                    1,
	"SESSION_AND_HARDWARE_KEY":   2,
	"HARDWARE_KEY_TOUCH":         3,
	"HARDWARE_KEY_PIN":           4,
	"HARDWARE_KEY_TOUCH_AND_PIN": 5,
}

func (x RequireMFAType) String() string {
	return proto.EnumName(RequireMFAType_name, int32(x))
}

func (RequireMFAType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{16}
}

// SignatureAlgorithmSuite represents the suite of cryptographic signature algorithms used in the cluster.
type SignatureAlgorithmSuite int32

const (
	// SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED represents an unspecified signature algorithm suite.
	SignatureAlgorithmSuite_SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED SignatureAlgorithmSuite = 0
	// SIGNATURE_ALGORITHM_SUITE_LEGACY is the original algorithm suite used in
	// Teleport, it almost exclusively uses 2048-bit RSA.
	SignatureAlgorithmSuite_SIGNATURE_ALGORITHM_SUITE_LEGACY SignatureAlgorithmSuite = 1
	// SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 aims to strikes a balance between
	// security, compatibility, and performance. It uses Ed25519 for most SSH
	// keys, ECDSA on the NIST P256 curve for most TLS keys, and 2048-bit RSA
	// where necessary for compatibility with third-party software.
	SignatureAlgorithmSuite_SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 SignatureAlgorithmSuite = 2
	// SIGNATURE_ALGORITHM_SUITE_FIPS_V1 is tailored for FIPS compliance. It is
	// based on the BALANCED_V1 suite but replaces all instances of Ed25519 with
	// ECDSA on the NIST P256 curve.
	SignatureAlgorithmSuite_SIGNATURE_ALGORITHM_SUITE_FIPS_V1 SignatureAlgorithmSuite = 3
	// SIGNATURE_ALGORITHM_SUITE_HSM_V1 is tailored for clusters using an HSM or
	// KMS service to back CA private material. It is based on the BALANCED suite
	// but replaces Ed25519 with ECDSA on the NIST P256 curve for CA keys only,
	// not for server or client keys. It is also valid to use the LEGACY for FIPS
	// suites if your cluster uses an HSM or KMS.
	SignatureAlgorithmSuite_SIGNATURE_ALGORITHM_SUITE_HSM_V1 SignatureAlgorithmSuite = 4
)

var SignatureAlgorithmSuite_name = map[int32]string{
	0: "SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED",
	1: "SIGNATURE_ALGORITHM_SUITE_LEGACY",
	2: "SIGNATURE_ALGORITHM_SUITE_BALANCED_V1",
	3: "SIGNATURE_ALGORITHM_SUITE_FIPS_V1",
	4: "SIGNATURE_ALGORITHM_SUITE_HSM_V1",
}

var SignatureAlgorithmSuite_value = map[string]int32{
	"SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED": 0,
	"SIGNATURE_ALGORITHM_SUITE_LEGACY":      1,
	"SIGNATURE_ALGORITHM_SUITE_BALANCED_V1": 2,
	"SIGNATURE_ALGORITHM_SUITE_FIPS_V1":     3,
	"SIGNATURE_ALGORITHM_SUITE_HSM_V1":      4,
}

func (x SignatureAlgorithmSuite) String() string {
	return proto.EnumName(SignatureAlgorithmSuite_name, int32(x))
}

func (SignatureAlgorithmSuite) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{17}
}

type PluginStatusCode int32

const (
	// UNKNOWN is the default value when the plugin has not reported its status yet.
	PluginStatusCode_UNKNOWN PluginStatusCode = 0
	// RUNNING means the plugin reports running successfully.
	PluginStatusCode_RUNNING PluginStatusCode = 1
	// OTHER_ERROR indicates that an otherwise-unspecified error has been encountered.
	PluginStatusCode_OTHER_ERROR PluginStatusCode = 2
	// UNAUTHORIZED indicates that plugin is not able to authenticate to the 3rd party API.
	// This could be a result of e.g. the user revoking the authorization on the API provider's side.
	PluginStatusCode_UNAUTHORIZED PluginStatusCode = 3
	// SLACK_NOT_IN_CHANNEL is a Slack-specific status code that indicates
	// that the bot has not been invited to a channel that it is configured to post in.
	PluginStatusCode_SLACK_NOT_IN_CHANNEL PluginStatusCode = 10
)

var PluginStatusCode_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "RUNNING",
	2:  "OTHER_ERROR",
	3:  "UNAUTHORIZED",
	10: "SLACK_NOT_IN_CHANNEL",
}

var PluginStatusCode_value = map[string]int32{
	"UNKNOWN":              0,
	"RUNNING":              1,
	"OTHER_ERROR":          2,
	"UNAUTHORIZED":         3,
	"SLACK_NOT_IN_CHANNEL": 10,
}

func (x PluginStatusCode) String() string {
	return proto.EnumName(PluginStatusCode_name, int32(x))
}

func (PluginStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{18}
}

// OktaPluginSyncStatusCode indicates the possible states of an Okta
// synchronization service.
type OktaPluginSyncStatusCode int32

const (
	// OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED is the status code zero value,
	// indicating that the service has not yet reported a status code.
	OktaPluginSyncStatusCode_OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED OktaPluginSyncStatusCode = 0
	// OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS indicates that the service is running
	// without error
	OktaPluginSyncStatusCode_OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS OktaPluginSyncStatusCode = 1
	// OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR indicates that the service is currently
	// in an error state.
	OktaPluginSyncStatusCode_OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR OktaPluginSyncStatusCode = 2
)

var OktaPluginSyncStatusCode_name = map[int32]string{
	0: "OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED",
	1: "OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS",
	2: "OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR",
}

var OktaPluginSyncStatusCode_value = map[string]int32{
	"OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED": 0,
	"OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS":     1,
	"OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR":       2,
}

func (x OktaPluginSyncStatusCode) String() string {
	return proto.EnumName(OktaPluginSyncStatusCode_name, int32(x))
}

func (OktaPluginSyncStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{19}
}

// HeadlessAuthenticationState is a headless authentication state.
type HeadlessAuthenticationState int32

const (
	HeadlessAuthenticationState_HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED HeadlessAuthenticationState = 0
	// authentication pending.
	HeadlessAuthenticationState_HEADLESS_AUTHENTICATION_STATE_PENDING HeadlessAuthenticationState = 1
	// authentication denied.
	HeadlessAuthenticationState_HEADLESS_AUTHENTICATION_STATE_DENIED HeadlessAuthenticationState = 2
	// authentication approved.
	HeadlessAuthenticationState_HEADLESS_AUTHENTICATION_STATE_APPROVED HeadlessAuthenticationState = 3
)

var HeadlessAuthenticationState_name = map[int32]string{
	0: "HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED",
	1: "HEADLESS_AUTHENTICATION_STATE_PENDING",
	2: "HEADLESS_AUTHENTICATION_STATE_DENIED",
	3: "HEADLESS_AUTHENTICATION_STATE_APPROVED",
}

var HeadlessAuthenticationState_value = map[string]int32{
	"HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED": 0,
	"HEADLESS_AUTHENTICATION_STATE_PENDING":     1,
	"HEADLESS_AUTHENTICATION_STATE_DENIED":      2,
	"HEADLESS_AUTHENTICATION_STATE_APPROVED":    3,
}

func (x HeadlessAuthenticationState) String() string {
	return proto.EnumName(HeadlessAuthenticationState_name, int32(x))
}

func (HeadlessAuthenticationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{20}
}

// InstallParamEnrollMode is the mode used to enroll the node into the cluster.
type InstallParamEnrollMode int32

const (
	// INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED uses the EICE mode for EC2 Matchers with an Integration and SCRIPT mode otherwise.
	InstallParamEnrollMode_INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED InstallParamEnrollMode = 0
	// INSTALL_PARAM_ENROLL_MODE_SCRIPT runs a script on the target host.
	InstallParamEnrollMode_INSTALL_PARAM_ENROLL_MODE_SCRIPT InstallParamEnrollMode = 1
	// INSTALL_PARAM_ENROLL_MODE_EICE uses EC2 Instance Connect Endpoint to access the node and DiscoveryService handles the heartbeat.
	// Only available for AWS EC2 instances.
	InstallParamEnrollMode_INSTALL_PARAM_ENROLL_MODE_EICE InstallParamEnrollMode = 2
)

var InstallParamEnrollMode_name = map[int32]string{
	0: "INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED",
	1: "INSTALL_PARAM_ENROLL_MODE_SCRIPT",
	2: "INSTALL_PARAM_ENROLL_MODE_EICE",
}

var InstallParamEnrollMode_value = map[string]int32{
	"INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED": 0,
	"INSTALL_PARAM_ENROLL_MODE_SCRIPT":      1,
	"INSTALL_PARAM_ENROLL_MODE_EICE":        2,
}

func (x InstallParamEnrollMode) String() string {
	return proto.EnumName(InstallParamEnrollMode_name, int32(x))
}

func (InstallParamEnrollMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{21}
}

// The type of a KeepAlive. When adding a new type, please double-check
// lib/usagereporter/teleport to see if we need any change in the resource
// heartbeat event.
type KeepAlive_KeepAliveType int32

const (
	KeepAlive_UNKNOWN KeepAlive_KeepAliveType = 0
	// "node", KindNode. For the sake of correct usage reporting, it shouldn't
	// be used for OpenSSH nodes.
	KeepAlive_NODE KeepAlive_KeepAliveType = 1
	// "app_server", KindAppServer
	KeepAlive_APP KeepAlive_KeepAliveType = 2
	// "db_server", KindDatabaseServer
	KeepAlive_DATABASE KeepAlive_KeepAliveType = 3
	// "windows_desktop_service", KindWindowsDesktopService
	KeepAlive_WINDOWS_DESKTOP KeepAlive_KeepAliveType = 4
	// "kube_server", KindKubeServer
	KeepAlive_KUBERNETES KeepAlive_KeepAliveType = 5
	// "db_service", KindDatabaseService
	KeepAlive_DATABASE_SERVICE KeepAlive_KeepAliveType = 6
)

var KeepAlive_KeepAliveType_name = map[int32]string{
	0: "UNKNOWN",
	1: "NODE",
	2: "APP",
	3: "DATABASE",
	4: "WINDOWS_DESKTOP",
	5: "KUBERNETES",
	6: "DATABASE_SERVICE",
}

var KeepAlive_KeepAliveType_value = map[string]int32{
	"UNKNOWN":          0,
	"NODE":             1,
	"APP":              2,
	"DATABASE":         3,
	"WINDOWS_DESKTOP":  4,
	"KUBERNETES":       5,
	"DATABASE_SERVICE": 6,
}

func (x KeepAlive_KeepAliveType) String() string {
	return proto.EnumName(KeepAlive_KeepAliveType_name, int32(x))
}

func (KeepAlive_KeepAliveType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{0, 0}
}

// SigningAlgType is unused.
//
// Deprecated: SigningAlgType is unused.
type CertAuthoritySpecV2_SigningAlgType int32 // Deprecated: Do not use.
const (
	CertAuthoritySpecV2_UNKNOWN      CertAuthoritySpecV2_SigningAlgType = 0
	CertAuthoritySpecV2_RSA_SHA1     CertAuthoritySpecV2_SigningAlgType = 1
	CertAuthoritySpecV2_RSA_SHA2_256 CertAuthoritySpecV2_SigningAlgType = 2
	CertAuthoritySpecV2_RSA_SHA2_512 CertAuthoritySpecV2_SigningAlgType = 3
)

var CertAuthoritySpecV2_SigningAlgType_name = map[int32]string{
	0: "UNKNOWN",
	1: "RSA_SHA1",
	2: "RSA_SHA2_256",
	3: "RSA_SHA2_512",
}

var CertAuthoritySpecV2_SigningAlgType_value = map[string]int32{
	"UNKNOWN":      0,
	"RSA_SHA1":     1,
	"RSA_SHA2_256": 2,
	"RSA_SHA2_512": 3,
}

func (x CertAuthoritySpecV2_SigningAlgType) String() string {
	return proto.EnumName(CertAuthoritySpecV2_SigningAlgType_name, int32(x))
}

func (CertAuthoritySpecV2_SigningAlgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{52, 0}
}

// FIPSEndpointState represents an AWS FIPS endpoint state.
type ClusterAuditConfigSpecV2_FIPSEndpointState int32

const (
	// FIPS_UNSET allows setting FIPS state for AWS S3/Dynamo using configuration files or
	// environment variables
	ClusterAuditConfigSpecV2_FIPS_UNSET ClusterAuditConfigSpecV2_FIPSEndpointState = 0
	// FIPS_ENABLED explicitly enables FIPS support for AWS S3/Dynamo
	ClusterAuditConfigSpecV2_FIPS_ENABLED ClusterAuditConfigSpecV2_FIPSEndpointState = 1
	// FIPS_DISABLED explicitly disables FIPS support for AWS S3/Dynamo
	ClusterAuditConfigSpecV2_FIPS_DISABLED ClusterAuditConfigSpecV2_FIPSEndpointState = 2
)

var ClusterAuditConfigSpecV2_FIPSEndpointState_name = map[int32]string{
	0: "FIPS_UNSET",
	1: "FIPS_ENABLED",
	2: "FIPS_DISABLED",
}

var ClusterAuditConfigSpecV2_FIPSEndpointState_value = map[string]int32{
	"FIPS_UNSET":    0,
	"FIPS_ENABLED":  1,
	"FIPS_DISABLED": 2,
}

func (x ClusterAuditConfigSpecV2_FIPSEndpointState) String() string {
	return proto.EnumName(ClusterAuditConfigSpecV2_FIPSEndpointState_name, int32(x))
}

func (ClusterAuditConfigSpecV2_FIPSEndpointState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{74, 0}
}

// TraceType is an identification of the checkpoint.
type ConnectionDiagnosticTrace_TraceType int32

const (
	ConnectionDiagnosticTrace_TRACE_TYPE_UNSPECIFIED ConnectionDiagnosticTrace_TraceType = 0
	// UNKNOWN_ERROR is used when we don't know the error.
	// It's not always possible to offer guidance based on the received error.
	// This trace type should be used when the error is too generic given the context we
	// have.
	ConnectionDiagnosticTrace_UNKNOWN_ERROR ConnectionDiagnosticTrace_TraceType = 1
	// RBAC_NODE is for RBAC checks for the node.
	ConnectionDiagnosticTrace_RBAC_NODE ConnectionDiagnosticTrace_TraceType = 2
	// CONNECTIVITY is for network connectivity checks.
	ConnectionDiagnosticTrace_CONNECTIVITY ConnectionDiagnosticTrace_TraceType = 3
	// RBAC_PRINCIPAL is used when checking if the principal is allowed per RBAC rules.
	ConnectionDiagnosticTrace_RBAC_PRINCIPAL ConnectionDiagnosticTrace_TraceType = 4
	// NODE_PRINCIPAL is used when checking if the Node has the requested principal.
	ConnectionDiagnosticTrace_NODE_PRINCIPAL ConnectionDiagnosticTrace_TraceType = 5
	// RBAC_KUBE is for RBAC checks to kubernetes the cluster.
	ConnectionDiagnosticTrace_RBAC_KUBE ConnectionDiagnosticTrace_TraceType = 6
	// KUBE_PRINCIPAL is used when checking if the Kube Cluster has at least one user principals.
	ConnectionDiagnosticTrace_KUBE_PRINCIPAL ConnectionDiagnosticTrace_TraceType = 7
	// RBAC_DATABASE is for RBAC checks to database access (db_labels).
	ConnectionDiagnosticTrace_RBAC_DATABASE ConnectionDiagnosticTrace_TraceType = 8
	// RBAC_DATABASE_LOGIN is for RBAC checks to database login (db_name and db_user).
	ConnectionDiagnosticTrace_RBAC_DATABASE_LOGIN ConnectionDiagnosticTrace_TraceType = 9
	// DATABASE_DB_USER is used when checking whether the Database has the requested Database User.
	ConnectionDiagnosticTrace_DATABASE_DB_USER ConnectionDiagnosticTrace_TraceType = 10
	// DATABASE_DB_NAME is used when checking whether the Database has the requested Database Name.
	ConnectionDiagnosticTrace_DATABASE_DB_NAME ConnectionDiagnosticTrace_TraceType = 11
)

var ConnectionDiagnosticTrace_TraceType_name = map[int32]string{
	0:  "TRACE_TYPE_UNSPECIFIED",
	1:  "UNKNOWN_ERROR",
	2:  "RBAC_NODE",
	3:  "CONNECTIVITY",
	4:  "RBAC_PRINCIPAL",
	5:  "NODE_PRINCIPAL",
	6:  "RBAC_KUBE",
	7:  "KUBE_PRINCIPAL",
	8:  "RBAC_DATABASE",
	9:  "RBAC_DATABASE_LOGIN",
	10: "DATABASE_DB_USER",
	11: "DATABASE_DB_NAME",
}

var ConnectionDiagnosticTrace_TraceType_value = map[string]int32{
	"TRACE_TYPE_UNSPECIFIED": 0,
	"UNKNOWN_ERROR":          1,
	"RBAC_NODE":              2,
	"CONNECTIVITY":           3,
	"RBAC_PRINCIPAL":         4,
	"NODE_PRINCIPAL":         5,
	"RBAC_KUBE":              6,
	"KUBE_PRINCIPAL":         7,
	"RBAC_DATABASE":          8,
	"RBAC_DATABASE_LOGIN":    9,
	"DATABASE_DB_USER":       10,
	"DATABASE_DB_NAME":       11,
}

func (x ConnectionDiagnosticTrace_TraceType) String() string {
	return proto.EnumName(ConnectionDiagnosticTrace_TraceType_name, int32(x))
}

func (ConnectionDiagnosticTrace_TraceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{244, 0}
}

// StatusType describes whether this was a success or a failure.
type ConnectionDiagnosticTrace_StatusType int32

const (
	ConnectionDiagnosticTrace_STATUS_UNSPECIFIED ConnectionDiagnosticTrace_StatusType = 0
	ConnectionDiagnosticTrace_SUCCESS            ConnectionDiagnosticTrace_StatusType = 1
	ConnectionDiagnosticTrace_FAILED             ConnectionDiagnosticTrace_StatusType = 2
)

var ConnectionDiagnosticTrace_StatusType_name = map[int32]string{
	0: "STATUS_UNSPECIFIED",
	1: "SUCCESS",
	2: "FAILED",
}

var ConnectionDiagnosticTrace_StatusType_value = map[string]int32{
	"STATUS_UNSPECIFIED": 0,
	"SUCCESS":            1,
	"FAILED":             2,
}

func (x ConnectionDiagnosticTrace_StatusType) String() string {
	return proto.EnumName(ConnectionDiagnosticTrace_StatusType_name, int32(x))
}

func (ConnectionDiagnosticTrace_StatusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{244, 1}
}

// OktaAssignmentStatus represents the status of an Okta assignment.
type OktaAssignmentSpecV1_OktaAssignmentStatus int32

const (
	// UNKNOWN indicates the status is not set.
	OktaAssignmentSpecV1_UNKNOWN OktaAssignmentSpecV1_OktaAssignmentStatus = 0
	// PENDING indicates the action has not yet been applied.
	OktaAssignmentSpecV1_PENDING OktaAssignmentSpecV1_OktaAssignmentStatus = 1
	// PROCESSSING indicates that the assignment is being applied.
	OktaAssignmentSpecV1_PROCESSING OktaAssignmentSpecV1_OktaAssignmentStatus = 2
	// SUCCESSFUL indicates the action was applied successfully.
	OktaAssignmentSpecV1_SUCCESSFUL OktaAssignmentSpecV1_OktaAssignmentStatus = 3
	// FAILED indicates the action was not applied successfully. It will be retried.
	OktaAssignmentSpecV1_FAILED OktaAssignmentSpecV1_OktaAssignmentStatus = 4
)

var OktaAssignmentSpecV1_OktaAssignmentStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "PROCESSING",
	3: "SUCCESSFUL",
	4: "FAILED",
}

var OktaAssignmentSpecV1_OktaAssignmentStatus_value = map[string]int32{
	"UNKNOWN":    0,
	"PENDING":    1,
	"PROCESSING": 2,
	"SUCCESSFUL": 3,
	"FAILED":     4,
}

func (x OktaAssignmentSpecV1_OktaAssignmentStatus) String() string {
	return proto.EnumName(OktaAssignmentSpecV1_OktaAssignmentStatus_name, int32(x))
}

func (OktaAssignmentSpecV1_OktaAssignmentStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{315, 0}
}

// OktaAssignmentTargetType is the type of Okta object that an assignment is targeting.
type OktaAssignmentTargetV1_OktaAssignmentTargetType int32

const (
	// UNKNOWN indicates the target is unknown.
	OktaAssignmentTargetV1_UNKNOWN OktaAssignmentTargetV1_OktaAssignmentTargetType = 0
	// APPLICATION indicates the target is an application.
	OktaAssignmentTargetV1_APPLICATION OktaAssignmentTargetV1_OktaAssignmentTargetType = 1
	// GROUP indicates the target is a group.
	OktaAssignmentTargetV1_GROUP OktaAssignmentTargetV1_OktaAssignmentTargetType = 2
)

var OktaAssignmentTargetV1_OktaAssignmentTargetType_name = map[int32]string{
	0: "UNKNOWN",
	1: "APPLICATION",
	2: "GROUP",
}

var OktaAssignmentTargetV1_OktaAssignmentTargetType_value = map[string]int32{
	"UNKNOWN":     0,
	"APPLICATION": 1,
	"GROUP":       2,
}

func (x OktaAssignmentTargetV1_OktaAssignmentTargetType) String() string {
	return proto.EnumName(OktaAssignmentTargetV1_OktaAssignmentTargetType_name, int32(x))
}

func (OktaAssignmentTargetV1_OktaAssignmentTargetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{316, 0}
}

type KeepAlive struct {
	// Name of the resource to keep alive.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"server_name"`
	// Namespace is the namespace of the resource.
	Namespace string `protobuf:"bytes,2,opt,name=Namespace,proto3" json:"namespace"`
	// Expires is set to update expiry time of the resource.
	Expires time.Time `protobuf:"bytes,4,opt,name=Expires,proto3,stdtime" json:"expires"`
	// Type is the type (or kind) of the resource that's being kept alive.
	Type KeepAlive_KeepAliveType `protobuf:"varint,9,opt,name=Type,proto3,enum=types.KeepAlive_KeepAliveType" json:"type"`
	// HostID is an optional UUID of the host the resource belongs to.
	HostID               string   `protobuf:"bytes,10,opt,name=HostID,proto3" json:"host_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeepAlive) Reset()         { *m = KeepAlive{} }
func (m *KeepAlive) String() string { return proto.CompactTextString(m) }
func (*KeepAlive) ProtoMessage()    {}
func (*KeepAlive) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{0}
}
func (m *KeepAlive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeepAlive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeepAlive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeepAlive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeepAlive.Merge(m, src)
}
func (m *KeepAlive) XXX_Size() int {
	return m.Size()
}
func (m *KeepAlive) XXX_DiscardUnknown() {
	xxx_messageInfo_KeepAlive.DiscardUnknown(m)
}

var xxx_messageInfo_KeepAlive proto.InternalMessageInfo

// Metadata is resource metadata
type Metadata struct {
	// Name is an object name
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Namespace is object namespace. The field should be called "namespace"
	// when it returns in Teleport 2.4.
	Namespace string `protobuf:"bytes,2,opt,name=Namespace,proto3" json:"-"`
	// Description is object description
	Description string `protobuf:"bytes,3,opt,name=Description,proto3" json:"description,omitempty"`
	// Labels is a set of labels
	Labels map[string]string `protobuf:"bytes,5,rep,name=Labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Expires is a global expiry time header can be set on any resource in the
	// system.
	Expires *time.Time `protobuf:"bytes,6,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// Revision is an opaque identifier which tracks the versions of a resource
	// over time. Clients should ignore and not alter its value but must return
	// the revision in any updates of a resource.
	Revision             string   `protobuf:"bytes,8,opt,name=Revision,proto3" json:"revision,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{1}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

// Rotation is a status of the rotation of the certificate authority
type Rotation struct {
	// State could be one of "init" or "in_progress".
	State string `protobuf:"bytes,1,opt,name=State,proto3" json:"state,omitempty"`
	// Phase is the current rotation phase.
	Phase string `protobuf:"bytes,2,opt,name=Phase,proto3" json:"phase,omitempty"`
	// Mode sets manual or automatic rotation mode.
	Mode string `protobuf:"bytes,3,opt,name=Mode,proto3" json:"mode,omitempty"`
	// CurrentID is the ID of the rotation operation
	// to differentiate between rotation attempts.
	CurrentID string `protobuf:"bytes,4,opt,name=CurrentID,proto3" json:"current_id"`
	// Started is set to the time when rotation has been started
	// in case if the state of the rotation is "in_progress".
	Started time.Time `protobuf:"bytes,5,opt,name=Started,proto3,stdtime" json:"started,omitempty"`
	// GracePeriod is a period during which old and new CA
	// are valid for checking purposes, but only new CA is issuing certificates.
	GracePeriod Duration `protobuf:"varint,6,opt,name=GracePeriod,proto3,casttype=Duration" json:"grace_period,omitempty"`
	// LastRotated specifies the last time of the completed rotation.
	LastRotated time.Time `protobuf:"bytes,7,opt,name=LastRotated,proto3,stdtime" json:"last_rotated,omitempty"`
	// Schedule is a rotation schedule - used in
	// automatic mode to switch between phases.
	Schedule             RotationSchedule `protobuf:"bytes,8,opt,name=Schedule,proto3" json:"schedule,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Rotation) Reset()      { *m = Rotation{} }
func (*Rotation) ProtoMessage() {}
func (*Rotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{2}
}
func (m *Rotation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rotation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rotation.Merge(m, src)
}
func (m *Rotation) XXX_Size() int {
	return m.Size()
}
func (m *Rotation) XXX_DiscardUnknown() {
	xxx_messageInfo_Rotation.DiscardUnknown(m)
}

var xxx_messageInfo_Rotation proto.InternalMessageInfo

// RotationSchedule is a rotation schedule setting time switches
// for different phases.
type RotationSchedule struct {
	// UpdateClients specifies time to switch to the "Update clients" phase
	UpdateClients time.Time `protobuf:"bytes,1,opt,name=UpdateClients,proto3,stdtime" json:"update_clients,omitempty"`
	// UpdateServers specifies time to switch to the "Update servers" phase.
	UpdateServers time.Time `protobuf:"bytes,2,opt,name=UpdateServers,proto3,stdtime" json:"update_servers,omitempty"`
	// Standby specifies time to switch to the "Standby" phase.
	Standby              time.Time `protobuf:"bytes,3,opt,name=Standby,proto3,stdtime" json:"standby,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RotationSchedule) Reset()         { *m = RotationSchedule{} }
func (m *RotationSchedule) String() string { return proto.CompactTextString(m) }
func (*RotationSchedule) ProtoMessage()    {}
func (*RotationSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{3}
}
func (m *RotationSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RotationSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RotationSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RotationSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotationSchedule.Merge(m, src)
}
func (m *RotationSchedule) XXX_Size() int {
	return m.Size()
}
func (m *RotationSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_RotationSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_RotationSchedule proto.InternalMessageInfo

// ResourceHeader is a shared resource header
// used in cases when only type and name is known
type ResourceHeader struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind,omitempty"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the API version used to create the resource. It must be
	// specified. Based on this version, Teleport will apply different defaults on
	// resource creation or deletion. It must be an integer prefixed by "v".
	// For example: `v1`
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version,omitempty"`
	// Metadata is resource metadata
	Metadata             Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceHeader) Reset()         { *m = ResourceHeader{} }
func (m *ResourceHeader) String() string { return proto.CompactTextString(m) }
func (*ResourceHeader) ProtoMessage()    {}
func (*ResourceHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{4}
}
func (m *ResourceHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeader.Merge(m, src)
}
func (m *ResourceHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeader proto.InternalMessageInfo

// DatabaseServerV3 represents a database access server.
type DatabaseServerV3 struct {
	// Kind is the database server resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the database server metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the database server spec.
	Spec                 DatabaseServerSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DatabaseServerV3) Reset()      { *m = DatabaseServerV3{} }
func (*DatabaseServerV3) ProtoMessage() {}
func (*DatabaseServerV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{5}
}
func (m *DatabaseServerV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseServerV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseServerV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseServerV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseServerV3.Merge(m, src)
}
func (m *DatabaseServerV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseServerV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseServerV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseServerV3 proto.InternalMessageInfo

// DatabaseServerSpecV3 is the database server spec.
type DatabaseServerSpecV3 struct {
	// Version is the Teleport version that the server is running.
	Version string `protobuf:"bytes,6,opt,name=Version,proto3" json:"version"`
	// Hostname is the database server hostname.
	Hostname string `protobuf:"bytes,7,opt,name=Hostname,proto3" json:"hostname"`
	// HostID is the ID of the host the database server is running on.
	HostID string `protobuf:"bytes,8,opt,name=HostID,proto3" json:"host_id"`
	// Rotation contains the server CA rotation information.
	Rotation Rotation `protobuf:"bytes,10,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// Database is the database proxied by this database server.
	Database *DatabaseV3 `protobuf:"bytes,12,opt,name=Database,proto3" json:"database,omitempty"`
	// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
	ProxyIDs             []string `protobuf:"bytes,13,rep,name=ProxyIDs,proto3" json:"proxy_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseServerSpecV3) Reset()         { *m = DatabaseServerSpecV3{} }
func (m *DatabaseServerSpecV3) String() string { return proto.CompactTextString(m) }
func (*DatabaseServerSpecV3) ProtoMessage()    {}
func (*DatabaseServerSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{6}
}
func (m *DatabaseServerSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseServerSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseServerSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseServerSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseServerSpecV3.Merge(m, src)
}
func (m *DatabaseServerSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseServerSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseServerSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseServerSpecV3 proto.InternalMessageInfo

// DatabaseV3List represents a list of databases.
type DatabaseV3List struct {
	// Databases is a list of database resources.
	Databases            []*DatabaseV3 `protobuf:"bytes,1,rep,name=Databases,proto3" json:"Databases,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DatabaseV3List) Reset()         { *m = DatabaseV3List{} }
func (m *DatabaseV3List) String() string { return proto.CompactTextString(m) }
func (*DatabaseV3List) ProtoMessage()    {}
func (*DatabaseV3List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{7}
}
func (m *DatabaseV3List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseV3List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseV3List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseV3List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseV3List.Merge(m, src)
}
func (m *DatabaseV3List) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseV3List) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseV3List.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseV3List proto.InternalMessageInfo

// DatabaseV3 represents a single proxied database.
type DatabaseV3 struct {
	// Kind is the database resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v3`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the database metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the database spec.
	Spec DatabaseSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	// Status is the database runtime information.
	Status               DatabaseStatusV3 `protobuf:"bytes,6,opt,name=Status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DatabaseV3) Reset()      { *m = DatabaseV3{} }
func (*DatabaseV3) ProtoMessage() {}
func (*DatabaseV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{8}
}
func (m *DatabaseV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseV3.Merge(m, src)
}
func (m *DatabaseV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseV3 proto.InternalMessageInfo

// DatabaseSpecV3 is the database spec.
type DatabaseSpecV3 struct {
	// Protocol is the database protocol: postgres, mysql, mongodb, etc.
	Protocol string `protobuf:"bytes,1,opt,name=Protocol,proto3" json:"protocol"`
	// URI is the database connection endpoint.
	URI string `protobuf:"bytes,2,opt,name=URI,proto3" json:"uri"`
	// CACert is the PEM-encoded database CA certificate.
	//
	// DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
	CACert string `protobuf:"bytes,3,opt,name=CACert,proto3" json:"ca_cert,omitempty"` // Deprecated: Do not use.
	// DynamicLabels is the database dynamic labels.
	DynamicLabels map[string]CommandLabelV2 `protobuf:"bytes,4,rep,name=DynamicLabels,proto3" json:"dynamic_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
	AWS AWS `protobuf:"bytes,5,opt,name=AWS,proto3" json:"aws,omitempty"`
	// GCP contains parameters specific to GCP Cloud SQL databases.
	GCP GCPCloudSQL `protobuf:"bytes,6,opt,name=GCP,proto3" json:"gcp,omitempty"`
	// Azure contains Azure specific database metadata.
	Azure Azure `protobuf:"bytes,7,opt,name=Azure,proto3" json:"azure,omitempty"`
	// TLS is the TLS configuration used when establishing connection to target database.
	// Allows to provide custom CA cert or override server name.
	TLS DatabaseTLS `protobuf:"bytes,8,opt,name=TLS,proto3" json:"tls,omitempty"`
	// AD is the Active Directory configuration for the database.
	AD AD `protobuf:"bytes,9,opt,name=AD,proto3" json:"ad,omitempty"`
	// MySQL is an additional section with MySQL database options.
	MySQL MySQLOptions `protobuf:"bytes,10,opt,name=MySQL,proto3" json:"mysql,omitempty"`
	// AdminUser is the database admin user for automatic user provisioning.
	AdminUser *DatabaseAdminUser `protobuf:"bytes,11,opt,name=AdminUser,proto3" json:"admin_user,omitempty"`
	// MongoAtlas contains Atlas metadata about the database.
	MongoAtlas MongoAtlas `protobuf:"bytes,12,opt,name=MongoAtlas,proto3" json:"mongo_atlas,omitempty"`
	// Oracle is an additional Oracle configuration options.
	Oracle               OracleOptions `protobuf:"bytes,13,opt,name=Oracle,proto3" json:"oracle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DatabaseSpecV3) Reset()         { *m = DatabaseSpecV3{} }
func (m *DatabaseSpecV3) String() string { return proto.CompactTextString(m) }
func (*DatabaseSpecV3) ProtoMessage()    {}
func (*DatabaseSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{9}
}
func (m *DatabaseSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseSpecV3.Merge(m, src)
}
func (m *DatabaseSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseSpecV3 proto.InternalMessageInfo

// DatabaseAdminUser contains information about privileged database user used
// for automatic user provisioning.
type DatabaseAdminUser struct {
	// Name is the username of the privileged database user.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// DefaultDatabase is the database that the privileged database user logs
	// into by default.
	//
	// Depending on the database type, this database may be used to store
	// procedures or data for managing database users.
	DefaultDatabase      string   `protobuf:"bytes,2,opt,name=DefaultDatabase,proto3" json:"default_database"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseAdminUser) Reset()         { *m = DatabaseAdminUser{} }
func (m *DatabaseAdminUser) String() string { return proto.CompactTextString(m) }
func (*DatabaseAdminUser) ProtoMessage()    {}
func (*DatabaseAdminUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{10}
}
func (m *DatabaseAdminUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseAdminUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseAdminUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseAdminUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseAdminUser.Merge(m, src)
}
func (m *DatabaseAdminUser) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseAdminUser) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseAdminUser.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseAdminUser proto.InternalMessageInfo

// OracleOptions contains information about privileged database user used
// for database audit.
type OracleOptions struct {
	// AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
	AuditUser            string   `protobuf:"bytes,1,opt,name=AuditUser,proto3" json:"audit_user"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleOptions) Reset()         { *m = OracleOptions{} }
func (m *OracleOptions) String() string { return proto.CompactTextString(m) }
func (*OracleOptions) ProtoMessage()    {}
func (*OracleOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{11}
}
func (m *OracleOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleOptions.Merge(m, src)
}
func (m *OracleOptions) XXX_Size() int {
	return m.Size()
}
func (m *OracleOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleOptions.DiscardUnknown(m)
}

var xxx_messageInfo_OracleOptions proto.InternalMessageInfo

// DatabaseStatusV3 contains runtime information about the database.
type DatabaseStatusV3 struct {
	// CACert is the auto-downloaded cloud database CA certificate.
	CACert string `protobuf:"bytes,1,opt,name=CACert,proto3" json:"ca_cert,omitempty"`
	// AWS is the auto-discovered AWS cloud database metadata.
	AWS AWS `protobuf:"bytes,2,opt,name=AWS,proto3" json:"aws"`
	// MySQL is an additional section with MySQL runtime database information.
	MySQL MySQLOptions `protobuf:"bytes,3,opt,name=MySQL,proto3" json:"mysql,omitempty"`
	// ManagedUsers is a list of database users that are managed by Teleport.
	ManagedUsers []string `protobuf:"bytes,4,rep,name=ManagedUsers,proto3" json:"managed_users,omitempty"`
	// Azure is the auto-discovered Azure cloud database metadata.
	Azure                Azure    `protobuf:"bytes,5,opt,name=Azure,proto3" json:"azure"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseStatusV3) Reset()         { *m = DatabaseStatusV3{} }
func (m *DatabaseStatusV3) String() string { return proto.CompactTextString(m) }
func (*DatabaseStatusV3) ProtoMessage()    {}
func (*DatabaseStatusV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{12}
}
func (m *DatabaseStatusV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseStatusV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseStatusV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseStatusV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseStatusV3.Merge(m, src)
}
func (m *DatabaseStatusV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseStatusV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseStatusV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseStatusV3 proto.InternalMessageInfo

// AWS contains AWS metadata about the database.
type AWS struct {
	// Region is a AWS cloud region.
	Region string `protobuf:"bytes,1,opt,name=Region,proto3" json:"region,omitempty"`
	// Redshift contains Redshift specific metadata.
	Redshift Redshift `protobuf:"bytes,2,opt,name=Redshift,proto3" json:"redshift,omitempty"`
	// RDS contains RDS specific metadata.
	RDS RDS `protobuf:"bytes,3,opt,name=RDS,proto3" json:"rds,omitempty"`
	// AccountID is the AWS account ID this database belongs to.
	AccountID string `protobuf:"bytes,4,opt,name=AccountID,proto3" json:"account_id,omitempty"`
	// ElastiCache contains AWS ElastiCache Redis specific metadata.
	ElastiCache ElastiCache `protobuf:"bytes,5,opt,name=ElastiCache,proto3" json:"elasticache,omitempty"`
	// SecretStore contains secret store configurations.
	SecretStore SecretStore `protobuf:"bytes,6,opt,name=SecretStore,proto3" json:"secret_store,omitempty"`
	// MemoryDB contains AWS MemoryDB specific metadata.
	MemoryDB MemoryDB `protobuf:"bytes,7,opt,name=MemoryDB,proto3" json:"memorydb,omitempty"`
	// RDSProxy contains AWS Proxy specific metadata.
	RDSProxy RDSProxy `protobuf:"bytes,8,opt,name=RDSProxy,proto3" json:"rdsproxy,omitempty"`
	// RedshiftServerless contains AWS Redshift Serverless specific metadata.
	RedshiftServerless RedshiftServerless `protobuf:"bytes,9,opt,name=RedshiftServerless,proto3" json:"redshift_serverless,omitempty"`
	// ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
	ExternalID string `protobuf:"bytes,10,opt,name=ExternalID,proto3" json:"external_id,omitempty"`
	// AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
	// Set this field and ExternalID to enable access across AWS accounts.
	AssumeRoleARN string `protobuf:"bytes,11,opt,name=AssumeRoleARN,proto3" json:"assume_role_arn,omitempty"`
	// OpenSearch contains AWS OpenSearch specific metadata.
	OpenSearch OpenSearch `protobuf:"bytes,12,opt,name=OpenSearch,proto3" json:"opensearch,omitempty"`
	// IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access.
	// If not, the user must update the AWS profile identity to allow access to the Database.
	// Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
	IAMPolicyStatus IAMPolicyStatus `protobuf:"varint,14,opt,name=IAMPolicyStatus,proto3,enum=types.IAMPolicyStatus" json:"iam_policy_status"`
	// SessionTags is a list of AWS STS session tags.
	SessionTags map[string]string `protobuf:"bytes,15,rep,name=SessionTags,proto3" json:"session_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// DocumentDB contains AWS DocumentDB specific metadata.
	DocumentDB           DocumentDB `protobuf:"bytes,16,opt,name=DocumentDB,proto3" json:"docdb,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AWS) Reset()         { *m = AWS{} }
func (m *AWS) String() string { return proto.CompactTextString(m) }
func (*AWS) ProtoMessage()    {}
func (*AWS) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{13}
}
func (m *AWS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWS.Merge(m, src)
}
func (m *AWS) XXX_Size() int {
	return m.Size()
}
func (m *AWS) XXX_DiscardUnknown() {
	xxx_messageInfo_AWS.DiscardUnknown(m)
}

var xxx_messageInfo_AWS proto.InternalMessageInfo

// SecretStore contains secret store configurations.
type SecretStore struct {
	// KeyPrefix specifies the secret key prefix.
	KeyPrefix string `protobuf:"bytes,1,opt,name=KeyPrefix,proto3" json:"key_prefix,omitempty"`
	// KMSKeyID specifies the AWS KMS key for encryption.
	KMSKeyID             string   `protobuf:"bytes,2,opt,name=KMSKeyID,proto3" json:"kms_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecretStore) Reset()         { *m = SecretStore{} }
func (m *SecretStore) String() string { return proto.CompactTextString(m) }
func (*SecretStore) ProtoMessage()    {}
func (*SecretStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{14}
}
func (m *SecretStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecretStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretStore.Merge(m, src)
}
func (m *SecretStore) XXX_Size() int {
	return m.Size()
}
func (m *SecretStore) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretStore.DiscardUnknown(m)
}

var xxx_messageInfo_SecretStore proto.InternalMessageInfo

// Redshift contains AWS Redshift specific database metadata.
type Redshift struct {
	// ClusterID is the Redshift cluster identifier.
	ClusterID            string   `protobuf:"bytes,1,opt,name=ClusterID,proto3" json:"cluster_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Redshift) Reset()         { *m = Redshift{} }
func (m *Redshift) String() string { return proto.CompactTextString(m) }
func (*Redshift) ProtoMessage()    {}
func (*Redshift) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{15}
}
func (m *Redshift) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Redshift) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Redshift.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Redshift) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redshift.Merge(m, src)
}
func (m *Redshift) XXX_Size() int {
	return m.Size()
}
func (m *Redshift) XXX_DiscardUnknown() {
	xxx_messageInfo_Redshift.DiscardUnknown(m)
}

var xxx_messageInfo_Redshift proto.InternalMessageInfo

// RDS contains AWS RDS specific database metadata.
type RDS struct {
	// InstanceID is the RDS instance identifier.
	InstanceID string `protobuf:"bytes,1,opt,name=InstanceID,proto3" json:"instance_id,omitempty"`
	// ClusterID is the RDS cluster (Aurora) identifier.
	ClusterID string `protobuf:"bytes,2,opt,name=ClusterID,proto3" json:"cluster_id,omitempty"`
	// ResourceID is the RDS instance resource identifier (db-xxx).
	ResourceID string `protobuf:"bytes,3,opt,name=ResourceID,proto3" json:"resource_id,omitempty"`
	// IAMAuth indicates whether database IAM authentication is enabled.
	IAMAuth bool `protobuf:"varint,4,opt,name=IAMAuth,proto3" json:"iam_auth"`
	// Subnets is a list of subnets for the RDS instance.
	Subnets []string `protobuf:"bytes,5,rep,name=Subnets,proto3" json:"subnets,omitempty"`
	// VPCID is the VPC where the RDS is running.
	VPCID                string   `protobuf:"bytes,6,opt,name=VPCID,proto3" json:"vpc_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RDS) Reset()         { *m = RDS{} }
func (m *RDS) String() string { return proto.CompactTextString(m) }
func (*RDS) ProtoMessage()    {}
func (*RDS) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{16}
}
func (m *RDS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RDS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RDS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RDS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RDS.Merge(m, src)
}
func (m *RDS) XXX_Size() int {
	return m.Size()
}
func (m *RDS) XXX_DiscardUnknown() {
	xxx_messageInfo_RDS.DiscardUnknown(m)
}

var xxx_messageInfo_RDS proto.InternalMessageInfo

// RDSProxy contains AWS RDS Proxy specific database metadata.
type RDSProxy struct {
	// Name is the identifier of an RDS Proxy.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	// CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
	CustomEndpointName string `protobuf:"bytes,2,opt,name=CustomEndpointName,proto3" json:"custom_endpoint_name,omitempty"`
	// ResourceID is the RDS instance resource identifier (prx-xxx).
	ResourceID           string   `protobuf:"bytes,3,opt,name=ResourceID,proto3" json:"resource_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RDSProxy) Reset()         { *m = RDSProxy{} }
func (m *RDSProxy) String() string { return proto.CompactTextString(m) }
func (*RDSProxy) ProtoMessage()    {}
func (*RDSProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{17}
}
func (m *RDSProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RDSProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RDSProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RDSProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RDSProxy.Merge(m, src)
}
func (m *RDSProxy) XXX_Size() int {
	return m.Size()
}
func (m *RDSProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_RDSProxy.DiscardUnknown(m)
}

var xxx_messageInfo_RDSProxy proto.InternalMessageInfo

// ElastiCache contains AWS ElastiCache Redis specific metadata.
type ElastiCache struct {
	// ReplicationGroupID is the Redis replication group ID.
	ReplicationGroupID string `protobuf:"bytes,1,opt,name=ReplicationGroupID,proto3" json:"replication_group_id,omitempty"`
	// UserGroupIDs is a list of user group IDs.
	UserGroupIDs []string `protobuf:"bytes,2,rep,name=UserGroupIDs,proto3" json:"user_group_ids,omitempty"`
	// TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
	TransitEncryptionEnabled bool `protobuf:"varint,3,opt,name=TransitEncryptionEnabled,proto3" json:"transit_encryption_enabled,omitempty"`
	// EndpointType is the type of the endpoint.
	EndpointType         string   `protobuf:"bytes,4,opt,name=EndpointType,proto3" json:"endpoint_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ElastiCache) Reset()         { *m = ElastiCache{} }
func (m *ElastiCache) String() string { return proto.CompactTextString(m) }
func (*ElastiCache) ProtoMessage()    {}
func (*ElastiCache) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{18}
}
func (m *ElastiCache) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElastiCache) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ElastiCache.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ElastiCache) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElastiCache.Merge(m, src)
}
func (m *ElastiCache) XXX_Size() int {
	return m.Size()
}
func (m *ElastiCache) XXX_DiscardUnknown() {
	xxx_messageInfo_ElastiCache.DiscardUnknown(m)
}

var xxx_messageInfo_ElastiCache proto.InternalMessageInfo

// MemoryDB contains AWS MemoryDB specific metadata.
type MemoryDB struct {
	// ClusterName is the name of the MemoryDB cluster.
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"cluster_name,omitempty"`
	// ACLName is the name of the ACL associated with the cluster.
	ACLName string `protobuf:"bytes,2,opt,name=ACLName,proto3" json:"acl_name,omitempty"`
	// TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
	TLSEnabled bool `protobuf:"varint,3,opt,name=TLSEnabled,proto3" json:"tls_enabled,omitempty"`
	// EndpointType is the type of the endpoint.
	EndpointType         string   `protobuf:"bytes,4,opt,name=EndpointType,proto3" json:"endpoint_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryDB) Reset()         { *m = MemoryDB{} }
func (m *MemoryDB) String() string { return proto.CompactTextString(m) }
func (*MemoryDB) ProtoMessage()    {}
func (*MemoryDB) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{19}
}
func (m *MemoryDB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryDB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryDB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryDB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryDB.Merge(m, src)
}
func (m *MemoryDB) XXX_Size() int {
	return m.Size()
}
func (m *MemoryDB) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryDB.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryDB proto.InternalMessageInfo

// RedshiftServerless contains AWS Redshift Serverless specific metadata.
type RedshiftServerless struct {
	// WorkgroupName is the workgroup name.
	WorkgroupName string `protobuf:"bytes,1,opt,name=WorkgroupName,proto3" json:"workgroup_name,omitempty"`
	// EndpointName is the VPC endpoint name.
	EndpointName string `protobuf:"bytes,2,opt,name=EndpointName,proto3" json:"endpoint_name,omitempty"`
	// WorkgroupID is the workgroup ID.
	WorkgroupID          string   `protobuf:"bytes,3,opt,name=WorkgroupID,proto3" json:"workgroup_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RedshiftServerless) Reset()         { *m = RedshiftServerless{} }
func (m *RedshiftServerless) String() string { return proto.CompactTextString(m) }
func (*RedshiftServerless) ProtoMessage()    {}
func (*RedshiftServerless) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{20}
}
func (m *RedshiftServerless) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedshiftServerless) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedshiftServerless.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedshiftServerless) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedshiftServerless.Merge(m, src)
}
func (m *RedshiftServerless) XXX_Size() int {
	return m.Size()
}
func (m *RedshiftServerless) XXX_DiscardUnknown() {
	xxx_messageInfo_RedshiftServerless.DiscardUnknown(m)
}

var xxx_messageInfo_RedshiftServerless proto.InternalMessageInfo

// OpenSearch contains AWS OpenSearch specific metadata.
type OpenSearch struct {
	// DomainName is the name of the domain.
	DomainName string `protobuf:"bytes,1,opt,name=DomainName,proto3" json:"domain_name,omitempty"`
	// DomainID is the ID of the domain.
	DomainID string `protobuf:"bytes,2,opt,name=DomainID,proto3" json:"domain_id,omitempty"`
	// EndpointType is the type of the endpoint.
	EndpointType         string   `protobuf:"bytes,3,opt,name=EndpointType,proto3" json:"endpoint_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenSearch) Reset()         { *m = OpenSearch{} }
func (m *OpenSearch) String() string { return proto.CompactTextString(m) }
func (*OpenSearch) ProtoMessage()    {}
func (*OpenSearch) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{21}
}
func (m *OpenSearch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSearch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSearch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSearch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSearch.Merge(m, src)
}
func (m *OpenSearch) XXX_Size() int {
	return m.Size()
}
func (m *OpenSearch) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSearch.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSearch proto.InternalMessageInfo

// DocumentDB contains AWS DocumentDB specific metadata.
type DocumentDB struct {
	// ClusterID is the cluster identifier.
	ClusterID string `protobuf:"bytes,1,opt,name=ClusterID,proto3" json:"cluster_id,omitempty"`
	// InstanceID is the instance identifier.
	InstanceID string `protobuf:"bytes,2,opt,name=InstanceID,proto3" json:"instance_id,omitempty"`
	// EndpointType is the type of the endpoint.
	EndpointType         string   `protobuf:"bytes,3,opt,name=EndpointType,proto3" json:"endpoint_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DocumentDB) Reset()         { *m = DocumentDB{} }
func (m *DocumentDB) String() string { return proto.CompactTextString(m) }
func (*DocumentDB) ProtoMessage()    {}
func (*DocumentDB) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{22}
}
func (m *DocumentDB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentDB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentDB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentDB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentDB.Merge(m, src)
}
func (m *DocumentDB) XXX_Size() int {
	return m.Size()
}
func (m *DocumentDB) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentDB.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentDB proto.InternalMessageInfo

// GCPCloudSQL contains parameters specific to GCP Cloud SQL databases.
type GCPCloudSQL struct {
	// ProjectID is the GCP project ID the Cloud SQL instance resides in.
	ProjectID string `protobuf:"bytes,1,opt,name=ProjectID,proto3" json:"project_id,omitempty"`
	// InstanceID is the Cloud SQL instance ID.
	InstanceID           string   `protobuf:"bytes,2,opt,name=InstanceID,proto3" json:"instance_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GCPCloudSQL) Reset()         { *m = GCPCloudSQL{} }
func (m *GCPCloudSQL) String() string { return proto.CompactTextString(m) }
func (*GCPCloudSQL) ProtoMessage()    {}
func (*GCPCloudSQL) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{23}
}
func (m *GCPCloudSQL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPCloudSQL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCPCloudSQL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCPCloudSQL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPCloudSQL.Merge(m, src)
}
func (m *GCPCloudSQL) XXX_Size() int {
	return m.Size()
}
func (m *GCPCloudSQL) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPCloudSQL.DiscardUnknown(m)
}

var xxx_messageInfo_GCPCloudSQL proto.InternalMessageInfo

// Azure contains Azure specific database metadata.
type Azure struct {
	// Name is the Azure database server name.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	// ResourceID is the Azure fully qualified ID for the resource.
	ResourceID string `protobuf:"bytes,2,opt,name=ResourceID,proto3" json:"resource_id,omitempty"`
	// Redis contains Azure Cache for Redis specific database metadata.
	Redis AzureRedis `protobuf:"bytes,3,opt,name=Redis,proto3" json:"redis,omitempty"`
	// IsFlexiServer is true if the database is an Azure Flexible server.
	IsFlexiServer        bool     `protobuf:"varint,4,opt,name=IsFlexiServer,proto3" json:"is_flexi_server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Azure) Reset()         { *m = Azure{} }
func (m *Azure) String() string { return proto.CompactTextString(m) }
func (*Azure) ProtoMessage()    {}
func (*Azure) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{24}
}
func (m *Azure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Azure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Azure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Azure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Azure.Merge(m, src)
}
func (m *Azure) XXX_Size() int {
	return m.Size()
}
func (m *Azure) XXX_DiscardUnknown() {
	xxx_messageInfo_Azure.DiscardUnknown(m)
}

var xxx_messageInfo_Azure proto.InternalMessageInfo

// AzureRedis contains Azure Cache for Redis specific database metadata.
type AzureRedis struct {
	// ClusteringPolicy is the clustering policy for Redis Enterprise.
	ClusteringPolicy     string   `protobuf:"bytes,1,opt,name=ClusteringPolicy,proto3" json:"clustering_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureRedis) Reset()         { *m = AzureRedis{} }
func (m *AzureRedis) String() string { return proto.CompactTextString(m) }
func (*AzureRedis) ProtoMessage()    {}
func (*AzureRedis) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{25}
}
func (m *AzureRedis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureRedis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureRedis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureRedis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureRedis.Merge(m, src)
}
func (m *AzureRedis) XXX_Size() int {
	return m.Size()
}
func (m *AzureRedis) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureRedis.DiscardUnknown(m)
}

var xxx_messageInfo_AzureRedis proto.InternalMessageInfo

// AD contains Active Directory specific database configuration.
type AD struct {
	// KeytabFile is the path to the Kerberos keytab file.
	KeytabFile string `protobuf:"bytes,1,opt,name=KeytabFile,proto3" json:"keytab_file,omitempty"`
	// Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
	Krb5File string `protobuf:"bytes,2,opt,name=Krb5File,proto3" json:"krb5_file,omitempty"`
	// Domain is the Active Directory domain the database resides in.
	Domain string `protobuf:"bytes,3,opt,name=Domain,proto3" json:"domain"`
	// SPN is the service principal name for the database.
	SPN string `protobuf:"bytes,4,opt,name=SPN,proto3" json:"spn"`
	// LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
	LDAPCert string `protobuf:"bytes,5,opt,name=LDAPCert,proto3" json:"ldap_cert,omitempty"`
	// KDCHostName is the host name for a KDC for x509 Authentication.
	KDCHostName          string   `protobuf:"bytes,6,opt,name=KDCHostName,proto3" json:"kdc_host_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AD) Reset()         { *m = AD{} }
func (m *AD) String() string { return proto.CompactTextString(m) }
func (*AD) ProtoMessage()    {}
func (*AD) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{26}
}
func (m *AD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AD.Merge(m, src)
}
func (m *AD) XXX_Size() int {
	return m.Size()
}
func (m *AD) XXX_DiscardUnknown() {
	xxx_messageInfo_AD.DiscardUnknown(m)
}

var xxx_messageInfo_AD proto.InternalMessageInfo

// DatabaseTLS contains TLS configuration options.
type DatabaseTLS struct {
	// Mode is a TLS connection mode.
	// 0 is "verify-full"; 1 is "verify-ca", 2 is "insecure".
	Mode DatabaseTLSMode `protobuf:"varint,1,opt,name=Mode,proto3,enum=types.DatabaseTLSMode" json:"mode"`
	// CACert is an optional user provided CA certificate used for verifying
	// database TLS connection.
	CACert string `protobuf:"bytes,2,opt,name=CACert,proto3" json:"ca_cert,omitempty"`
	// ServerName allows to provide custom hostname. This value will override the
	// servername/hostname on a certificate during validation.
	ServerName string `protobuf:"bytes,3,opt,name=ServerName,proto3" json:"server_name,omitempty"`
	// TrustSystemCertPool allows Teleport to trust certificate authorities
	// available on the host system. If not set (by default), Teleport only
	// trusts self-signed databases with TLS certificates signed by Teleport's
	// Database Server CA or the ca_cert specified in this TLS setting. For
	// cloud-hosted databases, Teleport downloads the corresponding required CAs
	// for validation.
	TrustSystemCertPool  bool     `protobuf:"varint,4,opt,name=TrustSystemCertPool,proto3" json:"trust_system_cert_pool,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseTLS) Reset()         { *m = DatabaseTLS{} }
func (m *DatabaseTLS) String() string { return proto.CompactTextString(m) }
func (*DatabaseTLS) ProtoMessage()    {}
func (*DatabaseTLS) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{27}
}
func (m *DatabaseTLS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseTLS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseTLS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseTLS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseTLS.Merge(m, src)
}
func (m *DatabaseTLS) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseTLS) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseTLS.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseTLS proto.InternalMessageInfo

// MySQLOptions are additional MySQL database options.
type MySQLOptions struct {
	// ServerVersion is the server version reported by DB proxy if the runtime information is
	// not available.
	ServerVersion        string   `protobuf:"bytes,1,opt,name=ServerVersion,proto3" json:"server_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MySQLOptions) Reset()         { *m = MySQLOptions{} }
func (m *MySQLOptions) String() string { return proto.CompactTextString(m) }
func (*MySQLOptions) ProtoMessage()    {}
func (*MySQLOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{28}
}
func (m *MySQLOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MySQLOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MySQLOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MySQLOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MySQLOptions.Merge(m, src)
}
func (m *MySQLOptions) XXX_Size() int {
	return m.Size()
}
func (m *MySQLOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MySQLOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MySQLOptions proto.InternalMessageInfo

// MongoAtlas contains Atlas metadata about the database.
type MongoAtlas struct {
	// Name is the Atlas database instance name.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MongoAtlas) Reset()         { *m = MongoAtlas{} }
func (m *MongoAtlas) String() string { return proto.CompactTextString(m) }
func (*MongoAtlas) ProtoMessage()    {}
func (*MongoAtlas) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{29}
}
func (m *MongoAtlas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MongoAtlas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MongoAtlas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MongoAtlas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MongoAtlas.Merge(m, src)
}
func (m *MongoAtlas) XXX_Size() int {
	return m.Size()
}
func (m *MongoAtlas) XXX_DiscardUnknown() {
	xxx_messageInfo_MongoAtlas.DiscardUnknown(m)
}

var xxx_messageInfo_MongoAtlas proto.InternalMessageInfo

// InstanceV1 represents the state of a running teleport instance independent
// of the specific services that instance exposes.
type InstanceV1 struct {
	ResourceHeader       `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	Spec                 InstanceSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstanceV1) Reset()         { *m = InstanceV1{} }
func (m *InstanceV1) String() string { return proto.CompactTextString(m) }
func (*InstanceV1) ProtoMessage()    {}
func (*InstanceV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{30}
}
func (m *InstanceV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceV1.Merge(m, src)
}
func (m *InstanceV1) XXX_Size() int {
	return m.Size()
}
func (m *InstanceV1) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceV1.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceV1 proto.InternalMessageInfo

type InstanceSpecV1 struct {
	// Version is the version of teleport this instance most recently advertised.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"version,omitempty"`
	// Services is the list of active services this instance most recently advertised.
	Services []SystemRole `protobuf:"bytes,2,rep,name=Services,proto3,casttype=SystemRole" json:"services,omitempty"`
	// Hostname is the hostname this instance most recently advertised.
	Hostname string `protobuf:"bytes,3,opt,name=Hostname,proto3" json:"hostname,omitempty"`
	// AuthID is the ID of the auth server that most recently observed this instance.
	AuthID string `protobuf:"bytes,4,opt,name=AuthID,proto3" json:"auth_id,omitempty"`
	// LastSeen is the last time an auth server reported observing this instance.
	LastSeen time.Time `protobuf:"bytes,5,opt,name=LastSeen,proto3,stdtime" json:"last_seen,omitempty"`
	// ControlLog is the log of recent important instance control events related to this instance. See comments
	// on the InstanceControlLogEntry type for details.
	ControlLog []InstanceControlLogEntry `protobuf:"bytes,6,rep,name=ControlLog,proto3" json:"control_log,omitempty"`
	// ExternalUpgrader identifies the external upgrader that the instance is configured to
	// export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
	ExternalUpgrader string `protobuf:"bytes,7,opt,name=ExternalUpgrader,proto3" json:"ext_upgrader,omitempty"`
	// ExternalUpgraderVersion identifies the external upgrader version. Empty if no upgrader is defined.
	ExternalUpgraderVersion string   `protobuf:"bytes,8,opt,name=ExternalUpgraderVersion,proto3" json:"ext_upgrader_version,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *InstanceSpecV1) Reset()         { *m = InstanceSpecV1{} }
func (m *InstanceSpecV1) String() string { return proto.CompactTextString(m) }
func (*InstanceSpecV1) ProtoMessage()    {}
func (*InstanceSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{31}
}
func (m *InstanceSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceSpecV1.Merge(m, src)
}
func (m *InstanceSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *InstanceSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceSpecV1 proto.InternalMessageInfo

// InstanceControlLogEntry represents an entry in a given instance's control log. The control log of
// an instance is protected by CompareAndSwap semantics, allowing entries to function as a means of
// synchronization as well as recordkeeping. For example, an auth server intending to trigger an upgrade
// for a given instance can check its control log for 'upgrade-attempt' entries. If no such entry exists,
// it can attempt to write an 'upgrade-attempt' entry of its own. If that entry successfully writes without
// hitting a CompareFailed, the auth server knows that no other auth servers will make concurrent upgrade
// attempts while that entry persists.
//
// NOTE: Due to resource size and backend throughput limitations, care should be taken to minimize the
// use and size of instance control log entries.
type InstanceControlLogEntry struct {
	// Type represents the type of control log entry this is (e.g. 'upgrade-attempt').
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// ID is a random identifier used to assist in uniquely identifying entries. This value may
	// be unique, or it may be used to associate a collection of related entries (e.g. an upgrade
	// attempt entry may use the same ID as an associated upgrade failure entry if appropriate).
	ID uint64 `protobuf:"varint,2,opt,name=ID,proto3" json:"id,omitempty"`
	// Time is the time at which the event represented by this entry occurred (used in determining
	// ordering and expiry).
	Time time.Time `protobuf:"bytes,3,opt,name=Time,proto3,stdtime" json:"time,omitempty"`
	// TTL is an optional custom time to live for this control log entry. Some control log entries
	// (e.g. an upgrade failure) may require longer than normal TTLs in order to ensure visibility.
	// If a log entry's TTL results in it having an intended expiry further in the future than the
	// expiry of the enclosing Instance resource, the instance resource's expiry will be bumped
	// to accommodate preservation of the log. Because of this fact, custom entry TTLs should be
	// used sparingly, as excess usage could result in unexpected backend growth for high churn
	// clusters.
	TTL time.Duration `protobuf:"varint,4,opt,name=TTL,proto3,casttype=time.Duration" json:"ttl,omitempty"`
	// Labels is an arbitrary collection of key-value pairs. The expected labels are determined by the
	// type of the entry. Use of labels is preferable to adding new fields in some cases in order to
	// preserve fields across auth downgrades (this is mostly relevant for the version-control system).
	Labels               map[string]string `protobuf:"bytes,5,rep,name=Labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *InstanceControlLogEntry) Reset()         { *m = InstanceControlLogEntry{} }
func (m *InstanceControlLogEntry) String() string { return proto.CompactTextString(m) }
func (*InstanceControlLogEntry) ProtoMessage()    {}
func (*InstanceControlLogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{32}
}
func (m *InstanceControlLogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceControlLogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceControlLogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceControlLogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceControlLogEntry.Merge(m, src)
}
func (m *InstanceControlLogEntry) XXX_Size() int {
	return m.Size()
}
func (m *InstanceControlLogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceControlLogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceControlLogEntry proto.InternalMessageInfo

// InstanceFilter matches instance resources.
type InstanceFilter struct {
	// ServerID matches exactly one instance by server ID if specified.
	ServerID string `protobuf:"bytes,1,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	// Version matches instance version if specified.
	Version string `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	// Services matches the instance services if specified. Note that this field matches all instances which
	// expose *at least* one of the listed services. This is in contrast to service matching in version
	// directives which match instances that expose a *at most* the listed services.
	Services []SystemRole `protobuf:"bytes,3,rep,name=Services,proto3,casttype=SystemRole" json:"Services,omitempty"`
	// ExternalUpgrader matches instance upgrader if specified.
	ExternalUpgrader string `protobuf:"bytes,4,opt,name=ExternalUpgrader,proto3" json:"ExternalUpgrader,omitempty"`
	// NoExtUpgrader explicitly matches instances for which no upgrader is defined.
	NoExtUpgrader bool `protobuf:"varint,5,opt,name=NoExtUpgrader,proto3" json:"NoExtUpgrader,omitempty"`
	// OlderThanVersion is an optional exclusive upper version bound.
	OlderThanVersion string `protobuf:"bytes,6,opt,name=OlderThanVersion,proto3" json:"OlderThanVersion,omitempty"`
	// NewerThanVersion is an optional exclusive lower version bound.
	NewerThanVersion     string   `protobuf:"bytes,7,opt,name=NewerThanVersion,proto3" json:"NewerThanVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstanceFilter) Reset()         { *m = InstanceFilter{} }
func (m *InstanceFilter) String() string { return proto.CompactTextString(m) }
func (*InstanceFilter) ProtoMessage()    {}
func (*InstanceFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{33}
}
func (m *InstanceFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceFilter.Merge(m, src)
}
func (m *InstanceFilter) XXX_Size() int {
	return m.Size()
}
func (m *InstanceFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceFilter.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceFilter proto.InternalMessageInfo

// ServerV2 represents a Node, App, Database, Proxy or Auth server in a Teleport cluster.
type ServerV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a server spec
	Spec                 ServerSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ServerV2) Reset()      { *m = ServerV2{} }
func (*ServerV2) ProtoMessage() {}
func (*ServerV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{34}
}
func (m *ServerV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerV2.Merge(m, src)
}
func (m *ServerV2) XXX_Size() int {
	return m.Size()
}
func (m *ServerV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerV2.DiscardUnknown(m)
}

var xxx_messageInfo_ServerV2 proto.InternalMessageInfo

// ServerSpecV2 is a specification for V2 Server
type ServerSpecV2 struct {
	// Addr is a host:port address where this server can be reached.
	Addr string `protobuf:"bytes,1,opt,name=Addr,proto3" json:"addr"`
	// Hostname is server hostname
	Hostname string `protobuf:"bytes,3,opt,name=Hostname,proto3" json:"hostname"`
	// CmdLabels is server dynamic labels
	CmdLabels map[string]CommandLabelV2 `protobuf:"bytes,4,rep,name=CmdLabels,proto3" json:"cmd_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Rotation specifies server rotation
	Rotation Rotation `protobuf:"bytes,5,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// UseTunnel indicates that connections to this server should occur over a
	// reverse tunnel.
	UseTunnel bool `protobuf:"varint,6,opt,name=UseTunnel,proto3" json:"use_tunnel,omitempty"`
	// TeleportVersion is the teleport version that the server is running on
	Version string `protobuf:"bytes,7,opt,name=Version,proto3" json:"version"`
	// PeerAddr is the address a proxy server is reachable at by its peer proxies.
	PeerAddr string `protobuf:"bytes,11,opt,name=PeerAddr,proto3" json:"peer_addr,omitempty"`
	// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
	ProxyIDs []string `protobuf:"bytes,12,rep,name=ProxyIDs,proto3" json:"proxy_ids,omitempty"`
	// PublicAddrs is a list of public addresses where this server can be reached.
	PublicAddrs []string `protobuf:"bytes,13,rep,name=public_addrs,json=publicAddrs,proto3" json:"public_addrs,omitempty"`
	// CloudMetadata contains info about the cloud instance the server is running
	// on, if any.
	CloudMetadata        *CloudMetadata `protobuf:"bytes,14,opt,name=CloudMetadata,proto3" json:"cloud_metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ServerSpecV2) Reset()         { *m = ServerSpecV2{} }
func (m *ServerSpecV2) String() string { return proto.CompactTextString(m) }
func (*ServerSpecV2) ProtoMessage()    {}
func (*ServerSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{35}
}
func (m *ServerSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerSpecV2.Merge(m, src)
}
func (m *ServerSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *ServerSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_ServerSpecV2 proto.InternalMessageInfo

// AWSInfo contains attributes to match to an EC2 instance.
type AWSInfo struct {
	// AccountID is an AWS account ID.
	AccountID string `protobuf:"bytes,1,opt,name=AccountID,proto3" json:"account_id"`
	// InstanceID is an EC2 instance ID.
	InstanceID string `protobuf:"bytes,2,opt,name=InstanceID,proto3" json:"instance_id"`
	// Region is the AWS EC2 Instance Region.
	Region string `protobuf:"bytes,3,opt,name=Region,proto3" json:"region,omitempty"`
	// VPCID is the AWS VPC ID where the Instance is running.
	VPCID string `protobuf:"bytes,4,opt,name=VPCID,proto3" json:"vpc_id,omitempty"`
	// Integration is the integration name that added this Node.
	// When connecting to it, it will use this integration to issue AWS API calls in order to set up the connection.
	// This includes sending an SSH Key and then opening a tunnel (EC2 Instance Connect Endpoint) so Teleport can connect to it.
	Integration string `protobuf:"bytes,5,opt,name=Integration,proto3" json:"integration,omitempty"`
	// SubnetID is the Subnet ID in use by the instance.
	SubnetID             string   `protobuf:"bytes,6,opt,name=SubnetID,proto3" json:"subnet_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AWSInfo) Reset()         { *m = AWSInfo{} }
func (m *AWSInfo) String() string { return proto.CompactTextString(m) }
func (*AWSInfo) ProtoMessage()    {}
func (*AWSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{36}
}
func (m *AWSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSInfo.Merge(m, src)
}
func (m *AWSInfo) XXX_Size() int {
	return m.Size()
}
func (m *AWSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AWSInfo proto.InternalMessageInfo

// CloudMetadata contains info about the cloud instance a server is running
// on, if any.
type CloudMetadata struct {
	// AWSInfo contains attributes to match to an EC2 instance.
	AWS                  *AWSInfo `protobuf:"bytes,1,opt,name=AWS,proto3" json:"aws,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloudMetadata) Reset()         { *m = CloudMetadata{} }
func (m *CloudMetadata) String() string { return proto.CompactTextString(m) }
func (*CloudMetadata) ProtoMessage()    {}
func (*CloudMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{37}
}
func (m *CloudMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloudMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloudMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudMetadata.Merge(m, src)
}
func (m *CloudMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CloudMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CloudMetadata proto.InternalMessageInfo

// AppServerV3 represents a single proxied web app.
type AppServerV3 struct {
	// Kind is the app server resource kind. Always "app_server".
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the app server metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the app server spec.
	Spec                 AppServerSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AppServerV3) Reset()      { *m = AppServerV3{} }
func (*AppServerV3) ProtoMessage() {}
func (*AppServerV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{38}
}
func (m *AppServerV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppServerV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppServerV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppServerV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppServerV3.Merge(m, src)
}
func (m *AppServerV3) XXX_Size() int {
	return m.Size()
}
func (m *AppServerV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppServerV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppServerV3 proto.InternalMessageInfo

// AppServerSpecV3 is the app access server spec.
type AppServerSpecV3 struct {
	// Version is the Teleport version that the server is running.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"version"`
	// Hostname is the app server hostname.
	Hostname string `protobuf:"bytes,2,opt,name=Hostname,proto3" json:"hostname"`
	// HostID is the app server host uuid.
	HostID string `protobuf:"bytes,3,opt,name=HostID,proto3" json:"host_id"`
	// Rotation contains the app server CA rotation information.
	Rotation Rotation `protobuf:"bytes,4,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// App is the app proxied by this app server.
	App *AppV3 `protobuf:"bytes,5,opt,name=App,proto3" json:"app"`
	// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
	ProxyIDs             []string `protobuf:"bytes,6,rep,name=ProxyIDs,proto3" json:"proxy_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppServerSpecV3) Reset()         { *m = AppServerSpecV3{} }
func (m *AppServerSpecV3) String() string { return proto.CompactTextString(m) }
func (*AppServerSpecV3) ProtoMessage()    {}
func (*AppServerSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{39}
}
func (m *AppServerSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppServerSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppServerSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppServerSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppServerSpecV3.Merge(m, src)
}
func (m *AppServerSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *AppServerSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppServerSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppServerSpecV3 proto.InternalMessageInfo

// AppV3List represents a list of app resources.
type AppV3List struct {
	// Apps is a list of app resources.
	Apps                 []*AppV3 `protobuf:"bytes,1,rep,name=Apps,proto3" json:"Apps,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppV3List) Reset()         { *m = AppV3List{} }
func (m *AppV3List) String() string { return proto.CompactTextString(m) }
func (*AppV3List) ProtoMessage()    {}
func (*AppV3List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{40}
}
func (m *AppV3List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppV3List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppV3List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppV3List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppV3List.Merge(m, src)
}
func (m *AppV3List) XXX_Size() int {
	return m.Size()
}
func (m *AppV3List) XXX_DiscardUnknown() {
	xxx_messageInfo_AppV3List.DiscardUnknown(m)
}

var xxx_messageInfo_AppV3List proto.InternalMessageInfo

// AppV3 represents an app resource.
type AppV3 struct {
	// Kind is the app resource kind. Always "app".
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are:`v3`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the app resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the app resource spec.
	Spec                 AppSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AppV3) Reset()      { *m = AppV3{} }
func (*AppV3) ProtoMessage() {}
func (*AppV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{41}
}
func (m *AppV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppV3.Merge(m, src)
}
func (m *AppV3) XXX_Size() int {
	return m.Size()
}
func (m *AppV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppV3 proto.InternalMessageInfo

// AppSpecV3 is the AppV3 resource spec.
type AppSpecV3 struct {
	// URI is the web app endpoint.
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"uri"`
	// PublicAddr is the public address the application is accessible at.
	PublicAddr string `protobuf:"bytes,2,opt,name=PublicAddr,proto3" json:"public_addr,omitempty"`
	// DynamicLabels are the app's command labels.
	DynamicLabels map[string]CommandLabelV2 `protobuf:"bytes,3,rep,name=DynamicLabels,proto3" json:"dynamic_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// InsecureSkipVerify disables app's TLS certificate verification.
	InsecureSkipVerify bool `protobuf:"varint,4,opt,name=InsecureSkipVerify,proto3" json:"insecure_skip_verify"`
	// Rewrite is a list of rewriting rules to apply to requests and responses.
	Rewrite *Rewrite `protobuf:"bytes,5,opt,name=Rewrite,proto3" json:"rewrite,omitempty"`
	// AWS contains additional options for AWS applications.
	AWS *AppAWS `protobuf:"bytes,6,opt,name=AWS,proto3" json:"aws,omitempty"`
	// Cloud identifies the cloud instance the app represents.
	Cloud string `protobuf:"bytes,7,opt,name=Cloud,proto3" json:"cloud,omitempty"`
	// UserGroups are a list of user group IDs that this app is associated with.
	UserGroups []string `protobuf:"bytes,8,rep,name=UserGroups,proto3" json:"UserGroups,omitempty"`
	// Integration is the integration name that must be used to access this Application.
	// Only applicable to AWS App Access.
	// If present, the Application must use the Integration's credentials instead of ambient credentials to access Cloud APIs.
	Integration          string   `protobuf:"bytes,9,opt,name=Integration,proto3" json:"integration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppSpecV3) Reset()         { *m = AppSpecV3{} }
func (m *AppSpecV3) String() string { return proto.CompactTextString(m) }
func (*AppSpecV3) ProtoMessage()    {}
func (*AppSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{42}
}
func (m *AppSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppSpecV3.Merge(m, src)
}
func (m *AppSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *AppSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppSpecV3 proto.InternalMessageInfo

// AppServerOrSAMLIdPServiceProviderV1 holds either an AppServerV3 or a SAMLIdPServiceProviderV1 resource (never both).
// Used in application listings that request both app servers and saml apps.
//
// DEPRECATED: Use AppServer and SAMLIdPServiceProvider type individually.
//
// Deprecated: Do not use.
type AppServerOrSAMLIdPServiceProviderV1 struct {
	// Kind is the resource kind. Always "app_server_saml_idp_sp".
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// The AppServer or SAMLIdPServiceProvider resource.
	//
	// Types that are valid to be assigned to Resource:
	//	*AppServerOrSAMLIdPServiceProviderV1_AppServer
	//	*AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider
	Resource             isAppServerOrSAMLIdPServiceProviderV1_Resource `protobuf_oneof:"Resource"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *AppServerOrSAMLIdPServiceProviderV1) Reset()      { *m = AppServerOrSAMLIdPServiceProviderV1{} }
func (*AppServerOrSAMLIdPServiceProviderV1) ProtoMessage() {}
func (*AppServerOrSAMLIdPServiceProviderV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{43}
}
func (m *AppServerOrSAMLIdPServiceProviderV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppServerOrSAMLIdPServiceProviderV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppServerOrSAMLIdPServiceProviderV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppServerOrSAMLIdPServiceProviderV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppServerOrSAMLIdPServiceProviderV1.Merge(m, src)
}
func (m *AppServerOrSAMLIdPServiceProviderV1) XXX_Size() int {
	return m.Size()
}
func (m *AppServerOrSAMLIdPServiceProviderV1) XXX_DiscardUnknown() {
	xxx_messageInfo_AppServerOrSAMLIdPServiceProviderV1.DiscardUnknown(m)
}

var xxx_messageInfo_AppServerOrSAMLIdPServiceProviderV1 proto.InternalMessageInfo

type isAppServerOrSAMLIdPServiceProviderV1_Resource interface {
	isAppServerOrSAMLIdPServiceProviderV1_Resource()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AppServerOrSAMLIdPServiceProviderV1_AppServer struct {
	AppServer *AppServerV3 `protobuf:"bytes,2,opt,name=AppServer,proto3,oneof" json:"app_server,omitempty"`
}
type AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider struct {
	SAMLIdPServiceProvider *SAMLIdPServiceProviderV1 `protobuf:"bytes,3,opt,name=SAMLIdPServiceProvider,proto3,oneof" json:"saml_idp_service_provider,omitempty"`
}

func (*AppServerOrSAMLIdPServiceProviderV1_AppServer) isAppServerOrSAMLIdPServiceProviderV1_Resource() {
}
func (*AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider) isAppServerOrSAMLIdPServiceProviderV1_Resource() {
}

func (m *AppServerOrSAMLIdPServiceProviderV1) GetResource() isAppServerOrSAMLIdPServiceProviderV1_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *AppServerOrSAMLIdPServiceProviderV1) GetAppServer() *AppServerV3 {
	if x, ok := m.GetResource().(*AppServerOrSAMLIdPServiceProviderV1_AppServer); ok {
		return x.AppServer
	}
	return nil
}

func (m *AppServerOrSAMLIdPServiceProviderV1) GetSAMLIdPServiceProvider() *SAMLIdPServiceProviderV1 {
	if x, ok := m.GetResource().(*AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider); ok {
		return x.SAMLIdPServiceProvider
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AppServerOrSAMLIdPServiceProviderV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AppServerOrSAMLIdPServiceProviderV1_AppServer)(nil),
		(*AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider)(nil),
	}
}

// Rewrite is a list of rewriting rules to apply to requests and responses.
type Rewrite struct {
	// Redirect defines a list of hosts which will be rewritten to the public
	// address of the application if they occur in the "Location" header.
	Redirect []string `protobuf:"bytes,1,rep,name=Redirect,proto3" json:"redirect,omitempty"`
	// Headers is a list of headers to inject when passing the request over
	// to the application.
	Headers []*Header `protobuf:"bytes,2,rep,name=Headers,proto3" json:"headers,omitempty"`
	// JWTClaims configures whether roles/traits are included in the JWT token.
	JWTClaims            string   `protobuf:"bytes,3,opt,name=JWTClaims,proto3" json:"jwt_claims,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rewrite) Reset()         { *m = Rewrite{} }
func (m *Rewrite) String() string { return proto.CompactTextString(m) }
func (*Rewrite) ProtoMessage()    {}
func (*Rewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{44}
}
func (m *Rewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rewrite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rewrite.Merge(m, src)
}
func (m *Rewrite) XXX_Size() int {
	return m.Size()
}
func (m *Rewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_Rewrite.DiscardUnknown(m)
}

var xxx_messageInfo_Rewrite proto.InternalMessageInfo

// Header represents a single http header passed over to the proxied application.
type Header struct {
	// Name is the http header name.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Value is the http header value.
	Value                string   `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{45}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

// CommandLabelV2 is a label that has a value as a result of the
// output generated by running command, e.g. hostname
type CommandLabelV2 struct {
	// Period is a time between command runs
	Period Duration `protobuf:"varint,1,opt,name=Period,proto3,casttype=Duration" json:"period"`
	// Command is a command to run
	Command []string `protobuf:"bytes,2,rep,name=Command,proto3" json:"command"`
	// Result captures standard output
	Result               string   `protobuf:"bytes,3,opt,name=Result,proto3" json:"result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandLabelV2) Reset()         { *m = CommandLabelV2{} }
func (m *CommandLabelV2) String() string { return proto.CompactTextString(m) }
func (*CommandLabelV2) ProtoMessage()    {}
func (*CommandLabelV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{46}
}
func (m *CommandLabelV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLabelV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandLabelV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandLabelV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLabelV2.Merge(m, src)
}
func (m *CommandLabelV2) XXX_Size() int {
	return m.Size()
}
func (m *CommandLabelV2) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLabelV2.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLabelV2 proto.InternalMessageInfo

// AppAWS contains additional options for AWS applications.
type AppAWS struct {
	// ExternalID is the AWS External ID used when assuming roles in this app.
	ExternalID           string   `protobuf:"bytes,1,opt,name=ExternalID,proto3" json:"external_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppAWS) Reset()         { *m = AppAWS{} }
func (m *AppAWS) String() string { return proto.CompactTextString(m) }
func (*AppAWS) ProtoMessage()    {}
func (*AppAWS) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{47}
}
func (m *AppAWS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppAWS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppAWS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppAWS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppAWS.Merge(m, src)
}
func (m *AppAWS) XXX_Size() int {
	return m.Size()
}
func (m *AppAWS) XXX_DiscardUnknown() {
	xxx_messageInfo_AppAWS.DiscardUnknown(m)
}

var xxx_messageInfo_AppAWS proto.InternalMessageInfo

// SSHKeyPair is an SSH CA key pair.
type SSHKeyPair struct {
	// PublicKey is the SSH public key.
	PublicKey []byte `protobuf:"bytes,1,opt,name=PublicKey,proto3" json:"public_key,omitempty"`
	// PrivateKey is the SSH private key.
	PrivateKey []byte `protobuf:"bytes,2,opt,name=PrivateKey,proto3" json:"private_key,omitempty"`
	// PrivateKeyType is the type of the PrivateKey.
	PrivateKeyType       PrivateKeyType `protobuf:"varint,3,opt,name=PrivateKeyType,proto3,enum=types.PrivateKeyType" json:"private_key_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SSHKeyPair) Reset()         { *m = SSHKeyPair{} }
func (m *SSHKeyPair) String() string { return proto.CompactTextString(m) }
func (*SSHKeyPair) ProtoMessage()    {}
func (*SSHKeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{48}
}
func (m *SSHKeyPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSHKeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSHKeyPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSHKeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSHKeyPair.Merge(m, src)
}
func (m *SSHKeyPair) XXX_Size() int {
	return m.Size()
}
func (m *SSHKeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_SSHKeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_SSHKeyPair proto.InternalMessageInfo

// TLSKeyPair is a TLS key pair
type TLSKeyPair struct {
	// Cert is a PEM encoded TLS cert
	Cert []byte `protobuf:"bytes,1,opt,name=Cert,proto3" json:"cert,omitempty"`
	// Key is a PEM encoded TLS key
	Key []byte `protobuf:"bytes,2,opt,name=Key,proto3" json:"key,omitempty"`
	// KeyType is the type of the Key.
	KeyType              PrivateKeyType `protobuf:"varint,3,opt,name=KeyType,proto3,enum=types.PrivateKeyType" json:"key_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLSKeyPair) Reset()         { *m = TLSKeyPair{} }
func (m *TLSKeyPair) String() string { return proto.CompactTextString(m) }
func (*TLSKeyPair) ProtoMessage()    {}
func (*TLSKeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{49}
}
func (m *TLSKeyPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSKeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSKeyPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLSKeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSKeyPair.Merge(m, src)
}
func (m *TLSKeyPair) XXX_Size() int {
	return m.Size()
}
func (m *TLSKeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSKeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_TLSKeyPair proto.InternalMessageInfo

// JWTKeyPair is a PEM encoded keypair used for signing JWT tokens.
type JWTKeyPair struct {
	// PublicKey is a PEM encoded public key.
	PublicKey []byte `protobuf:"bytes,1,opt,name=PublicKey,proto3" json:"public_key,omitempty"`
	// PrivateKey is a PEM encoded private key.
	PrivateKey []byte `protobuf:"bytes,2,opt,name=PrivateKey,proto3" json:"private_key,omitempty"`
	// PrivateKeyType is the type of the PrivateKey.
	PrivateKeyType       PrivateKeyType `protobuf:"varint,3,opt,name=PrivateKeyType,proto3,enum=types.PrivateKeyType" json:"private_key_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *JWTKeyPair) Reset()         { *m = JWTKeyPair{} }
func (m *JWTKeyPair) String() string { return proto.CompactTextString(m) }
func (*JWTKeyPair) ProtoMessage()    {}
func (*JWTKeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{50}
}
func (m *JWTKeyPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JWTKeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JWTKeyPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JWTKeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JWTKeyPair.Merge(m, src)
}
func (m *JWTKeyPair) XXX_Size() int {
	return m.Size()
}
func (m *JWTKeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_JWTKeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_JWTKeyPair proto.InternalMessageInfo

// CertAuthorityV2 is version 2 resource spec for Cert Authority
type CertAuthorityV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is connector metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec contains cert authority specification
	Spec                 CertAuthoritySpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CertAuthorityV2) Reset()      { *m = CertAuthorityV2{} }
func (*CertAuthorityV2) ProtoMessage() {}
func (*CertAuthorityV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{51}
}
func (m *CertAuthorityV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertAuthorityV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertAuthorityV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertAuthorityV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertAuthorityV2.Merge(m, src)
}
func (m *CertAuthorityV2) XXX_Size() int {
	return m.Size()
}
func (m *CertAuthorityV2) XXX_DiscardUnknown() {
	xxx_messageInfo_CertAuthorityV2.DiscardUnknown(m)
}

var xxx_messageInfo_CertAuthorityV2 proto.InternalMessageInfo

// CertAuthoritySpecV2 is a host or user certificate authority that
// can check and if it has private key stored as well, sign it too
type CertAuthoritySpecV2 struct {
	// Type is either user or host certificate authority
	Type CertAuthType `protobuf:"bytes,1,opt,name=Type,proto3,casttype=CertAuthType" json:"type"`
	// ClusterName identifies the cluster name this authority serves.
	ClusterName string `protobuf:"bytes,2,opt,name=ClusterName,proto3" json:"cluster_name"`
	// Roles is a list of roles assumed by users signed by this CA
	Roles []string `protobuf:"bytes,5,rep,name=Roles,proto3" json:"roles,omitempty"`
	// RoleMap specifies role mappings to remote roles
	RoleMap []RoleMapping `protobuf:"bytes,6,rep,name=RoleMap,proto3" json:"role_map,omitempty"`
	// Rotation is a status of the certificate authority rotation
	Rotation *Rotation `protobuf:"bytes,8,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// SigningAlg is unused.
	//
	// Deprecated: SigningAlg is unused.
	SigningAlg CertAuthoritySpecV2_SigningAlgType `protobuf:"varint,9,opt,name=SigningAlg,proto3,enum=types.CertAuthoritySpecV2_SigningAlgType" json:"signing_alg,omitempty"` // Deprecated: Do not use.
	// ActiveKeys are the CA key sets used to sign any new certificates.
	ActiveKeys CAKeySet `protobuf:"bytes,11,opt,name=ActiveKeys,proto3" json:"active_keys,omitempty"`
	// AdditionalTrustedKeys are additional CA key sets that can be used to
	// verify certificates. Certificates should be verified with
	// AdditionalTrustedKeys and ActiveKeys combined.
	AdditionalTrustedKeys CAKeySet `protobuf:"bytes,12,opt,name=AdditionalTrustedKeys,proto3" json:"additional_trusted_keys,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *CertAuthoritySpecV2) Reset()         { *m = CertAuthoritySpecV2{} }
func (m *CertAuthoritySpecV2) String() string { return proto.CompactTextString(m) }
func (*CertAuthoritySpecV2) ProtoMessage()    {}
func (*CertAuthoritySpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{52}
}
func (m *CertAuthoritySpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertAuthoritySpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertAuthoritySpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertAuthoritySpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertAuthoritySpecV2.Merge(m, src)
}
func (m *CertAuthoritySpecV2) XXX_Size() int {
	return m.Size()
}
func (m *CertAuthoritySpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_CertAuthoritySpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_CertAuthoritySpecV2 proto.InternalMessageInfo

// CAKeySet is the set of CA keys.
type CAKeySet struct {
	// SSH contains SSH CA key pairs.
	SSH []*SSHKeyPair `protobuf:"bytes,1,rep,name=SSH,proto3" json:"ssh,omitempty"`
	// TLS contains TLS CA key/cert pairs.
	TLS []*TLSKeyPair `protobuf:"bytes,2,rep,name=TLS,proto3" json:"tls,omitempty"`
	// JWT contains JWT signing key pairs.
	JWT                  []*JWTKeyPair `protobuf:"bytes,3,rep,name=JWT,proto3" json:"jwt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CAKeySet) Reset()         { *m = CAKeySet{} }
func (m *CAKeySet) String() string { return proto.CompactTextString(m) }
func (*CAKeySet) ProtoMessage()    {}
func (*CAKeySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{53}
}
func (m *CAKeySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CAKeySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CAKeySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CAKeySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CAKeySet.Merge(m, src)
}
func (m *CAKeySet) XXX_Size() int {
	return m.Size()
}
func (m *CAKeySet) XXX_DiscardUnknown() {
	xxx_messageInfo_CAKeySet.DiscardUnknown(m)
}

var xxx_messageInfo_CAKeySet proto.InternalMessageInfo

// RoleMapping provides mapping of remote roles to local roles
// for trusted clusters
type RoleMapping struct {
	// Remote specifies remote role name to map from
	Remote string `protobuf:"bytes,1,opt,name=Remote,proto3" json:"remote"`
	// Local specifies local roles to map to
	Local                []string `protobuf:"bytes,2,rep,name=Local,proto3" json:"local"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoleMapping) Reset()         { *m = RoleMapping{} }
func (m *RoleMapping) String() string { return proto.CompactTextString(m) }
func (*RoleMapping) ProtoMessage()    {}
func (*RoleMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{54}
}
func (m *RoleMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleMapping.Merge(m, src)
}
func (m *RoleMapping) XXX_Size() int {
	return m.Size()
}
func (m *RoleMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleMapping.DiscardUnknown(m)
}

var xxx_messageInfo_RoleMapping proto.InternalMessageInfo

// ProvisionTokenV1 is a provisioning token V1
type ProvisionTokenV1 struct {
	// Roles is a list of roles associated with the token,
	// that will be converted to metadata in the SSH and X509
	// certificates issued to the user of the token
	Roles []SystemRole `protobuf:"bytes,1,rep,name=Roles,proto3,casttype=SystemRole" json:"roles"`
	// Expires is a global expiry time header can be set on any resource in the
	// system.
	Expires time.Time `protobuf:"bytes,2,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// Token is a token name
	Token                string   `protobuf:"bytes,3,opt,name=Token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenV1) Reset()      { *m = ProvisionTokenV1{} }
func (*ProvisionTokenV1) ProtoMessage() {}
func (*ProvisionTokenV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{55}
}
func (m *ProvisionTokenV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenV1.Merge(m, src)
}
func (m *ProvisionTokenV1) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenV1.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenV1 proto.InternalMessageInfo

// ProvisionTokenV2 specifies provisioning token
type ProvisionTokenV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are:`v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a provisioning token V2 spec
	Spec                 ProvisionTokenSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ProvisionTokenV2) Reset()      { *m = ProvisionTokenV2{} }
func (*ProvisionTokenV2) ProtoMessage() {}
func (*ProvisionTokenV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{56}
}
func (m *ProvisionTokenV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenV2.Merge(m, src)
}
func (m *ProvisionTokenV2) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenV2.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenV2 proto.InternalMessageInfo

// ProvisionTokenV2List is a list of provisioning tokens.
type ProvisionTokenV2List struct {
	// ProvisionTokens is a list of provisioning tokens.
	ProvisionTokens      []*ProvisionTokenV2 `protobuf:"bytes,1,rep,name=ProvisionTokens,proto3" json:"ProvisionTokens,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ProvisionTokenV2List) Reset()         { *m = ProvisionTokenV2List{} }
func (m *ProvisionTokenV2List) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenV2List) ProtoMessage()    {}
func (*ProvisionTokenV2List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{57}
}
func (m *ProvisionTokenV2List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenV2List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenV2List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenV2List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenV2List.Merge(m, src)
}
func (m *ProvisionTokenV2List) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenV2List) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenV2List.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenV2List proto.InternalMessageInfo

// TokenRule is a rule that a joining node must match in order to use the
// associated token.
type TokenRule struct {
	// AWSAccount is the AWS account ID.
	AWSAccount string `protobuf:"bytes,1,opt,name=AWSAccount,proto3" json:"aws_account,omitempty"`
	// AWSRegions is used for the EC2 join method and is a list of AWS regions a
	// node is allowed to join from.
	AWSRegions []string `protobuf:"bytes,2,rep,name=AWSRegions,proto3" json:"aws_regions,omitempty"`
	// AWSRole is used for the EC2 join method and is the ARN of the AWS
	// role that the auth server will assume in order to call the ec2 API.
	AWSRole string `protobuf:"bytes,3,opt,name=AWSRole,proto3" json:"aws_role,omitempty"`
	// AWSARN is used for the IAM join method, the AWS identity of joining nodes
	// must match this ARN. Supports wildcards "*" and "?".
	AWSARN               string   `protobuf:"bytes,4,opt,name=AWSARN,proto3" json:"aws_arn,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokenRule) Reset()         { *m = TokenRule{} }
func (m *TokenRule) String() string { return proto.CompactTextString(m) }
func (*TokenRule) ProtoMessage()    {}
func (*TokenRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{58}
}
func (m *TokenRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenRule.Merge(m, src)
}
func (m *TokenRule) XXX_Size() int {
	return m.Size()
}
func (m *TokenRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenRule.DiscardUnknown(m)
}

var xxx_messageInfo_TokenRule proto.InternalMessageInfo

// ProvisionTokenSpecV2 is a specification for V2 token
type ProvisionTokenSpecV2 struct {
	// Roles is a list of roles associated with the token,
	// that will be converted to metadata in the SSH and X509
	// certificates issued to the user of the token
	Roles []SystemRole `protobuf:"bytes,1,rep,name=Roles,proto3,casttype=SystemRole" json:"roles"`
	// Allow is a list of TokenRules, nodes using this token must match one
	// allow rule to use this token.
	Allow []*TokenRule `protobuf:"bytes,2,rep,name=Allow,proto3" json:"allow,omitempty"`
	// AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used
	// to join the cluster with this token.
	AWSIIDTTL Duration `protobuf:"varint,3,opt,name=AWSIIDTTL,proto3,casttype=Duration" json:"aws_iid_ttl,omitempty"`
	// JoinMethod is the joining method required in order to use this token.
	// Supported joining methods include: azure, circleci, ec2, gcp, github, gitlab, iam, kubernetes, spacelift, token, tpm
	JoinMethod JoinMethod `protobuf:"bytes,4,opt,name=JoinMethod,proto3,casttype=JoinMethod" json:"join_method"`
	// BotName is the name of the bot this token grants access to, if any
	BotName string `protobuf:"bytes,5,opt,name=BotName,proto3" json:"bot_name,omitempty"`
	// SuggestedLabels is a set of labels that resources should set when using this token to enroll
	// themselves in the cluster.
	// Currently, only node-join scripts create a configuration according to the suggestion.
	SuggestedLabels Labels `protobuf:"bytes,6,opt,name=SuggestedLabels,proto3,customtype=Labels" json:"suggested_labels,omitempty"`
	// GitHub allows the configuration of options specific to the "github" join method.
	GitHub *ProvisionTokenSpecV2GitHub `protobuf:"bytes,7,opt,name=GitHub,proto3" json:"github,omitempty"`
	// CircleCI allows the configuration of options specific to the "circleci" join method.
	CircleCI *ProvisionTokenSpecV2CircleCI `protobuf:"bytes,8,opt,name=CircleCI,proto3" json:"circleci,omitempty"`
	// SuggestedAgentMatcherLabels is a set of labels to be used by agents to match on resources.
	// When an agent uses this token, the agent should monitor resources that match those labels.
	// For databases, this means adding the labels to `db_service.resources.labels`.
	// Currently, only node-join scripts create a configuration according to the suggestion.
	SuggestedAgentMatcherLabels Labels `protobuf:"bytes,9,opt,name=SuggestedAgentMatcherLabels,proto3,customtype=Labels" json:"suggested_agent_matcher_labels,omitempty"`
	// Kubernetes allows the configuration of options specific to the "kubernetes" join method.
	Kubernetes *ProvisionTokenSpecV2Kubernetes `protobuf:"bytes,10,opt,name=Kubernetes,proto3" json:"kubernetes,omitempty"`
	// Azure allows the configuration of options specific to the "azure" join method.
	Azure *ProvisionTokenSpecV2Azure `protobuf:"bytes,11,opt,name=Azure,proto3" json:"azure,omitempty"`
	// GitLab allows the configuration of options specific to the "gitlab" join method.
	GitLab *ProvisionTokenSpecV2GitLab `protobuf:"bytes,12,opt,name=GitLab,proto3" json:"gitlab,omitempty"`
	// GCP allows the configuration of options specific to the "gcp" join method.
	GCP *ProvisionTokenSpecV2GCP `protobuf:"bytes,13,opt,name=GCP,proto3" json:"gcp,omitempty"`
	// Spacelift allows the configuration of options specific to the "spacelift" join method.
	Spacelift *ProvisionTokenSpecV2Spacelift `protobuf:"bytes,14,opt,name=Spacelift,proto3" json:"spacelift,omitempty"`
	// TPM allows the configuration of options specific to the "tpm" join method.
	TPM *ProvisionTokenSpecV2TPM `protobuf:"bytes,15,opt,name=TPM,proto3" json:"tpm,omitempty"`
	// TerraformCloud allows the configuration of options specific to the "terraform_cloud" join method.
	TerraformCloud       *ProvisionTokenSpecV2TerraformCloud `protobuf:"bytes,16,opt,name=TerraformCloud,proto3" json:"terraform_cloud,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *ProvisionTokenSpecV2) Reset()         { *m = ProvisionTokenSpecV2{} }
func (m *ProvisionTokenSpecV2) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2) ProtoMessage()    {}
func (*ProvisionTokenSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{59}
}
func (m *ProvisionTokenSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2.Merge(m, src)
}
func (m *ProvisionTokenSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2 proto.InternalMessageInfo

// ProvisionTokenSpecV2TPM contains the TPM-specific part of the
// ProvisionTokenSpecV2
type ProvisionTokenSpecV2TPM struct {
	// Allow is a list of Rules, the presented delegated identity must match one
	// allow rule to permit joining.
	Allow []*ProvisionTokenSpecV2TPM_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	// EKCertAllowedCAs is a list of CA certificates that will be used to validate
	// TPM EKCerts.
	// When specified, joining TPMs must present an EKCert signed by one of the
	// specified CAs. TPMs that do not present an EKCert will be not permitted to
	// join.
	// When unspecified, TPMs will be allowed to join with either an EKCert or an
	// EKPubHash.
	EKCertAllowedCAs     []string `protobuf:"bytes,2,rep,name=EKCertAllowedCAs,proto3" json:"ekcert_allowed_cas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2TPM) Reset()         { *m = ProvisionTokenSpecV2TPM{} }
func (m *ProvisionTokenSpecV2TPM) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2TPM) ProtoMessage()    {}
func (*ProvisionTokenSpecV2TPM) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{60}
}
func (m *ProvisionTokenSpecV2TPM) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2TPM) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2TPM.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2TPM) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2TPM.Merge(m, src)
}
func (m *ProvisionTokenSpecV2TPM) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2TPM) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2TPM.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2TPM proto.InternalMessageInfo

type ProvisionTokenSpecV2TPM_Rule struct {
	// Description is a human-readable description of the rule. It has no
	// bearing on whether or not a TPM is allowed to join, but can be used
	// to associate a rule with a specific host (e.g the asset tag of the server
	// in which the TPM resides).
	// Example: "build-server-100"
	Description string `protobuf:"bytes,1,opt,name=Description,proto3" json:"description,omitempty"`
	// EKPublicHash is the SHA256 hash of the EKPub marshaled in PKIX format
	// and encoded in hexadecimal. This value will also be checked when a TPM
	// has submitted an EKCert, and the public key in the EKCert will be used
	// for this check.
	// Example: d4b45864d9d6fabfc568d74f26c35ababde2105337d7af9a6605e1c56c891aa6
	EKPublicHash string `protobuf:"bytes,4,opt,name=EKPublicHash,proto3" json:"ek_public_hash,omitempty"`
	// EKCertificateSerial is the serial number of the EKCert in hexadecimal
	// with colon separated nibbles. This value will not be checked when a TPM
	// does not have an EKCert configured.
	// Example: 73:df:dc:bd:af:ef:8a:d8:15:2e:96:71:7a:3e:7f:a4
	EKCertificateSerial  string   `protobuf:"bytes,5,opt,name=EKCertificateSerial,proto3" json:"ek_certificate_serial,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2TPM_Rule) Reset()         { *m = ProvisionTokenSpecV2TPM_Rule{} }
func (m *ProvisionTokenSpecV2TPM_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2TPM_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2TPM_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{60, 0}
}
func (m *ProvisionTokenSpecV2TPM_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2TPM_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2TPM_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2TPM_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2TPM_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2TPM_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2TPM_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2TPM_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2TPM_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2Github contains the GitHub-specific part of the
// ProvisionTokenSpecV2
type ProvisionTokenSpecV2GitHub struct {
	// Allow is a list of TokenRules, nodes using this token must match one
	// allow rule to use this token.
	Allow []*ProvisionTokenSpecV2GitHub_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	// EnterpriseServerHost allows joining from runners associated with a
	// GitHub Enterprise Server instance. When unconfigured, tokens will be
	// validated against github.com, but when configured to the host of a GHES
	// instance, then the tokens will be validated against host.
	//
	// This value should be the hostname of the GHES instance, and should not
	// include the scheme or a path. The instance must be accessible over HTTPS
	// at this hostname and the certificate must be trusted by the Auth Server.
	EnterpriseServerHost string `protobuf:"bytes,2,opt,name=EnterpriseServerHost,proto3" json:"enterprise_server_host,omitempty"`
	// EnterpriseSlug allows the slug of a GitHub Enterprise organisation to be
	// included in the expected issuer of the OIDC tokens. This is for
	// compatibility with the `include_enterprise_slug` option in GHE.
	//
	// This field should be set to the slug of your enterprise if this is enabled. If
	// this is not enabled, then this field must be left empty. This field cannot
	// be specified if `enterprise_server_host` is specified.
	//
	// See https://docs.github.com/en/enterprise-cloud@latest/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-issuer-value-for-an-enterprise
	// for more information about customized issuer values.
	EnterpriseSlug       string   `protobuf:"bytes,3,opt,name=EnterpriseSlug,proto3" json:"enterprise_slug,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2GitHub) Reset()         { *m = ProvisionTokenSpecV2GitHub{} }
func (m *ProvisionTokenSpecV2GitHub) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2GitHub) ProtoMessage()    {}
func (*ProvisionTokenSpecV2GitHub) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{61}
}
func (m *ProvisionTokenSpecV2GitHub) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2GitHub) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2GitHub.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2GitHub) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2GitHub.Merge(m, src)
}
func (m *ProvisionTokenSpecV2GitHub) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2GitHub) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2GitHub.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2GitHub proto.InternalMessageInfo

// Rule includes fields mapped from `lib/githubactions.IDToken`
// Not all fields should be included, only ones that we expect to be useful
// when trying to create rules around which workflows should be allowed to
// authenticate against a cluster.
type ProvisionTokenSpecV2GitHub_Rule struct {
	// Sub also known as Subject is a string that roughly uniquely identifies
	// the workload. The format of this varies depending on the type of
	// github action run.
	Sub string `protobuf:"bytes,1,opt,name=Sub,proto3" json:"sub,omitempty"`
	// The repository from where the workflow is running.
	// This includes the name of the owner e.g `gravitational/teleport`
	Repository string `protobuf:"bytes,2,opt,name=Repository,proto3" json:"repository,omitempty"`
	// The name of the organization in which the repository is stored.
	RepositoryOwner string `protobuf:"bytes,3,opt,name=RepositoryOwner,proto3" json:"repository_owner,omitempty"`
	// The name of the workflow.
	Workflow string `protobuf:"bytes,4,opt,name=Workflow,proto3" json:"workflow,omitempty"`
	// The name of the environment used by the job.
	Environment string `protobuf:"bytes,5,opt,name=Environment,proto3" json:"environment,omitempty"`
	// The personal account that initiated the workflow run.
	Actor string `protobuf:"bytes,6,opt,name=Actor,proto3" json:"actor,omitempty"`
	// The git ref that triggered the workflow run.
	Ref string `protobuf:"bytes,7,opt,name=Ref,proto3" json:"ref,omitempty"`
	// The type of ref, for example: "branch".
	RefType              string   `protobuf:"bytes,8,opt,name=RefType,proto3" json:"ref_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2GitHub_Rule) Reset()         { *m = ProvisionTokenSpecV2GitHub_Rule{} }
func (m *ProvisionTokenSpecV2GitHub_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2GitHub_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2GitHub_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{61, 0}
}
func (m *ProvisionTokenSpecV2GitHub_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2GitHub_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2GitHub_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2GitHub_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2GitHub_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2GitHub_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2GitHub_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2GitHub_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2GitHub_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2GitLab contains the GitLab-specific part of the
// ProvisionTokenSpecV2
type ProvisionTokenSpecV2GitLab struct {
	// Allow is a list of TokenRules, nodes using this token must match one
	// allow rule to use this token.
	Allow []*ProvisionTokenSpecV2GitLab_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	// Domain is the domain of your GitLab instance. This will default to
	// `gitlab.com` - but can be set to the domain of your self-hosted GitLab
	// e.g `gitlab.example.com`.
	Domain               string   `protobuf:"bytes,2,opt,name=Domain,proto3" json:"domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2GitLab) Reset()         { *m = ProvisionTokenSpecV2GitLab{} }
func (m *ProvisionTokenSpecV2GitLab) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2GitLab) ProtoMessage()    {}
func (*ProvisionTokenSpecV2GitLab) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{62}
}
func (m *ProvisionTokenSpecV2GitLab) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2GitLab) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2GitLab.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2GitLab) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2GitLab.Merge(m, src)
}
func (m *ProvisionTokenSpecV2GitLab) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2GitLab) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2GitLab.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2GitLab proto.InternalMessageInfo

type ProvisionTokenSpecV2GitLab_Rule struct {
	// Sub roughly uniquely identifies the workload. Example:
	// `project_path:mygroup/my-project:ref_type:branch:ref:main`
	// project_path:GROUP/PROJECT:ref_type:TYPE:ref:BRANCH_NAME
	//
	// This field supports simple "glob-style" matching:
	// - Use '*' to match zero or more characters.
	// - Use '?' to match any single character.
	Sub string `protobuf:"bytes,1,opt,name=Sub,proto3" json:"sub,omitempty"`
	// Ref allows access to be limited to jobs triggered by a specific git ref.
	// Ensure this is used in combination with ref_type.
	//
	// This field supports simple "glob-style" matching:
	// - Use '*' to match zero or more characters.
	// - Use '?' to match any single character.
	Ref string `protobuf:"bytes,2,opt,name=Ref,proto3" json:"ref,omitempty"`
	// RefType allows access to be limited to jobs triggered by a specific git
	// ref type. Example:
	// `branch` or `tag`
	RefType string `protobuf:"bytes,3,opt,name=RefType,proto3" json:"ref_type,omitempty"`
	// NamespacePath is used to limit access to jobs in a group or user's
	// projects.
	// Example:
	// `mygroup`
	//
	// This field supports simple "glob-style" matching:
	// - Use '*' to match zero or more characters.
	// - Use '?' to match any single character.
	NamespacePath string `protobuf:"bytes,4,opt,name=NamespacePath,proto3" json:"namespace_path,omitempty"`
	// ProjectPath is used to limit access to jobs belonging to an individual
	// project. Example:
	// `mygroup/myproject`
	//
	// This field supports simple "glob-style" matching:
	// - Use '*' to match zero or more characters.
	// - Use '?' to match any single character.
	ProjectPath string `protobuf:"bytes,5,opt,name=ProjectPath,proto3" json:"project_path,omitempty"`
	// PipelineSource limits access by the job pipeline source type.
	// https://docs.gitlab.com/ee/ci/jobs/job_control.html#common-if-clauses-for-rules
	// Example: `web`
	PipelineSource string `protobuf:"bytes,6,opt,name=PipelineSource,proto3" json:"pipeline_source,omitempty"`
	// Environment limits access by the environment the job deploys to
	// (if one is associated)
	Environment string `protobuf:"bytes,7,opt,name=Environment,proto3" json:"environment,omitempty"`
	// UserLogin is the username of the user executing the job
	UserLogin string `protobuf:"bytes,8,opt,name=UserLogin,proto3" json:"user_login,omitempty"`
	// UserID is the ID of the user executing the job
	UserID string `protobuf:"bytes,9,opt,name=UserID,proto3" json:"user_id,omitempty"`
	// UserEmail is the email of the user executing the job
	UserEmail string `protobuf:"bytes,10,opt,name=UserEmail,proto3" json:"user_email,omitempty"`
	// RefProtected is true if the Git ref is protected, false otherwise.
	RefProtected *BoolOption `protobuf:"bytes,11,opt,name=RefProtected,proto3,customtype=BoolOption" json:"ref_protected,omitempty"`
	// EnvironmentProtected is true if the Git ref is protected, false otherwise.
	EnvironmentProtected *BoolOption `protobuf:"bytes,12,opt,name=EnvironmentProtected,proto3,customtype=BoolOption" json:"environment_protected,omitempty"`
	// CIConfigSHA is the git commit SHA for the ci_config_ref_uri.
	CIConfigSHA string `protobuf:"bytes,13,opt,name=CIConfigSHA,proto3" json:"ci_config_sha,omitempty"`
	// CIConfigRefURI is the ref path to the top-level pipeline definition, for example,
	// gitlab.example.com/my-group/my-project//.gitlab-ci.yml@refs/heads/main.
	CIConfigRefURI string `protobuf:"bytes,14,opt,name=CIConfigRefURI,proto3" json:"ci_config_ref_uri,omitempty"`
	// DeploymentTier is the deployment tier of the environment the job specifies
	DeploymentTier string `protobuf:"bytes,15,opt,name=DeploymentTier,proto3" json:"deployment_tier,omitempty"`
	// ProjectVisibility is the visibility of the project where the pipeline is running.
	// Can be internal, private, or public.
	ProjectVisibility    string   `protobuf:"bytes,16,opt,name=ProjectVisibility,proto3" json:"project_visibility,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2GitLab_Rule) Reset()         { *m = ProvisionTokenSpecV2GitLab_Rule{} }
func (m *ProvisionTokenSpecV2GitLab_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2GitLab_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2GitLab_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{62, 0}
}
func (m *ProvisionTokenSpecV2GitLab_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2GitLab_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2GitLab_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2GitLab_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2GitLab_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2GitLab_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2GitLab_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2GitLab_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2GitLab_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2CircleCI contains the CircleCI-specific part of the
// ProvisionTokenSpecV2
type ProvisionTokenSpecV2CircleCI struct {
	// Allow is a list of TokenRules, nodes using this token must match one
	// allow rule to use this token.
	Allow                []*ProvisionTokenSpecV2CircleCI_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	OrganizationID       string                               `protobuf:"bytes,2,opt,name=OrganizationID,proto3" json:"organization_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *ProvisionTokenSpecV2CircleCI) Reset()         { *m = ProvisionTokenSpecV2CircleCI{} }
func (m *ProvisionTokenSpecV2CircleCI) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2CircleCI) ProtoMessage()    {}
func (*ProvisionTokenSpecV2CircleCI) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{63}
}
func (m *ProvisionTokenSpecV2CircleCI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2CircleCI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2CircleCI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2CircleCI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2CircleCI.Merge(m, src)
}
func (m *ProvisionTokenSpecV2CircleCI) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2CircleCI) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2CircleCI.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2CircleCI proto.InternalMessageInfo

type ProvisionTokenSpecV2CircleCI_Rule struct {
	ProjectID            string   `protobuf:"bytes,1,opt,name=ProjectID,proto3" json:"project_id,omitempty"`
	ContextID            string   `protobuf:"bytes,2,opt,name=ContextID,proto3" json:"context_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2CircleCI_Rule) Reset()         { *m = ProvisionTokenSpecV2CircleCI_Rule{} }
func (m *ProvisionTokenSpecV2CircleCI_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2CircleCI_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2CircleCI_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{63, 0}
}
func (m *ProvisionTokenSpecV2CircleCI_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2CircleCI_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2CircleCI_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2CircleCI_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2CircleCI_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2CircleCI_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2CircleCI_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2CircleCI_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2CircleCI_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2Spacelift contains the Spacelift-specific part of the
// ProvisionTokenSpecV2
type ProvisionTokenSpecV2Spacelift struct {
	// Allow is a list of Rules, nodes using this token must match one
	// allow rule to use this token.
	Allow []*ProvisionTokenSpecV2Spacelift_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	// Hostname is the hostname of the Spacelift tenant that tokens
	// will originate from. E.g `example.app.spacelift.io`
	Hostname             string   `protobuf:"bytes,2,opt,name=Hostname,proto3" json:"hostname,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2Spacelift) Reset()         { *m = ProvisionTokenSpecV2Spacelift{} }
func (m *ProvisionTokenSpecV2Spacelift) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2Spacelift) ProtoMessage()    {}
func (*ProvisionTokenSpecV2Spacelift) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{64}
}
func (m *ProvisionTokenSpecV2Spacelift) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2Spacelift) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2Spacelift.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2Spacelift) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2Spacelift.Merge(m, src)
}
func (m *ProvisionTokenSpecV2Spacelift) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2Spacelift) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2Spacelift.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2Spacelift proto.InternalMessageInfo

type ProvisionTokenSpecV2Spacelift_Rule struct {
	// SpaceID is the ID of the space in which the run that owns the token was
	// executed.
	SpaceID string `protobuf:"bytes,1,opt,name=SpaceID,proto3" json:"space_id,omitempty"`
	// CallerID is the ID of the caller, ie. the stack or module that generated
	// the run.
	CallerID string `protobuf:"bytes,2,opt,name=CallerID,proto3" json:"caller_id,omitempty"`
	// CallerType is the type of the caller, ie. the entity that owns the run -
	// either `stack` or `module`.
	CallerType string `protobuf:"bytes,3,opt,name=CallerType,proto3" json:"caller_type,omitempty"`
	// Scope is the scope of the token - either `read` or `write`.
	// See https://docs.spacelift.io/integrations/cloud-providers/oidc/#about-scopes
	Scope                string   `protobuf:"bytes,4,opt,name=Scope,proto3" json:"scope,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2Spacelift_Rule) Reset()         { *m = ProvisionTokenSpecV2Spacelift_Rule{} }
func (m *ProvisionTokenSpecV2Spacelift_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2Spacelift_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2Spacelift_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{64, 0}
}
func (m *ProvisionTokenSpecV2Spacelift_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2Spacelift_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2Spacelift_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2Spacelift_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2Spacelift_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2Spacelift_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2Spacelift_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2Spacelift_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2Spacelift_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2Kubernetes contains the Kubernetes-specific part of the
// ProvisionTokenSpecV2
type ProvisionTokenSpecV2Kubernetes struct {
	// Allow is a list of Rules, nodes using this token must match one
	// allow rule to use this token.
	Allow []*ProvisionTokenSpecV2Kubernetes_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	// Type controls which behavior should be used for validating the Kubernetes
	// Service Account token. Support values:
	// - `in_cluster`
	// - `static_jwks`
	// If unset, this defaults to `in_cluster`.
	Type KubernetesJoinType `protobuf:"bytes,2,opt,name=Type,proto3,casttype=KubernetesJoinType" json:"type,omitempty"`
	// StaticJWKS is the configuration specific to the `static_jwks` type.
	StaticJWKS           *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig `protobuf:"bytes,3,opt,name=StaticJWKS,proto3" json:"static_jwks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *ProvisionTokenSpecV2Kubernetes) Reset()         { *m = ProvisionTokenSpecV2Kubernetes{} }
func (m *ProvisionTokenSpecV2Kubernetes) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2Kubernetes) ProtoMessage()    {}
func (*ProvisionTokenSpecV2Kubernetes) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{65}
}
func (m *ProvisionTokenSpecV2Kubernetes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2Kubernetes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2Kubernetes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2Kubernetes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2Kubernetes.Merge(m, src)
}
func (m *ProvisionTokenSpecV2Kubernetes) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2Kubernetes) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2Kubernetes.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2Kubernetes proto.InternalMessageInfo

type ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig struct {
	// JWKS should be the JSON Web Key Set formatted public keys of that the
	// Kubernetes Cluster uses to sign service account tokens.
	// This can be fetched from /openid/v1/jwks on the Kubernetes API Server.
	JWKS                 string   `protobuf:"bytes,1,opt,name=JWKS,proto3" json:"jwks,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) Reset() {
	*m = ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig{}
}
func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) String() string {
	return proto.CompactTextString(m)
}
func (*ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) ProtoMessage() {}
func (*ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{65, 0}
}
func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig.Merge(m, src)
}
func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig proto.InternalMessageInfo

// Rule is a set of properties the Kubernetes-issued token might have to be
// allowed to use this ProvisionToken
type ProvisionTokenSpecV2Kubernetes_Rule struct {
	// ServiceAccount is the namespaced name of the Kubernetes service account.
	// Its format is "namespace:service-account".
	ServiceAccount       string   `protobuf:"bytes,1,opt,name=ServiceAccount,proto3" json:"service_account,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2Kubernetes_Rule) Reset()         { *m = ProvisionTokenSpecV2Kubernetes_Rule{} }
func (m *ProvisionTokenSpecV2Kubernetes_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2Kubernetes_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2Kubernetes_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{65, 1}
}
func (m *ProvisionTokenSpecV2Kubernetes_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2Kubernetes_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2Kubernetes_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2Kubernetes_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2Kubernetes_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2Kubernetes_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2Azure contains the Azure-specific part of the
// ProvisionTokenSpecV2.
type ProvisionTokenSpecV2Azure struct {
	// Allow is a list of Rules, nodes using this token must match one
	// allow rule to use this token.
	Allow                []*ProvisionTokenSpecV2Azure_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *ProvisionTokenSpecV2Azure) Reset()         { *m = ProvisionTokenSpecV2Azure{} }
func (m *ProvisionTokenSpecV2Azure) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2Azure) ProtoMessage()    {}
func (*ProvisionTokenSpecV2Azure) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{66}
}
func (m *ProvisionTokenSpecV2Azure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2Azure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2Azure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2Azure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2Azure.Merge(m, src)
}
func (m *ProvisionTokenSpecV2Azure) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2Azure) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2Azure.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2Azure proto.InternalMessageInfo

// Rule is a set of properties the Azure-issued token might have to be
// allowed to use this ProvisionToken.
type ProvisionTokenSpecV2Azure_Rule struct {
	// Subscription is the Azure subscription.
	Subscription string `protobuf:"bytes,1,opt,name=Subscription,proto3" json:"subscription,omitempty"`
	// ResourceGroups is a list of Azure resource groups the node is allowed
	// to join from.
	ResourceGroups       []string `protobuf:"bytes,2,rep,name=ResourceGroups,proto3" json:"resource_groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2Azure_Rule) Reset()         { *m = ProvisionTokenSpecV2Azure_Rule{} }
func (m *ProvisionTokenSpecV2Azure_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2Azure_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2Azure_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{66, 0}
}
func (m *ProvisionTokenSpecV2Azure_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2Azure_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2Azure_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2Azure_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2Azure_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2Azure_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2Azure_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2Azure_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2Azure_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2GCP contains the GCP-specific part of the
// ProvisionTokenSpecV2.
type ProvisionTokenSpecV2GCP struct {
	// Allow is a list of Rules, nodes using this token must match one
	// allow rule to use this token.
	Allow                []*ProvisionTokenSpecV2GCP_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ProvisionTokenSpecV2GCP) Reset()         { *m = ProvisionTokenSpecV2GCP{} }
func (m *ProvisionTokenSpecV2GCP) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2GCP) ProtoMessage()    {}
func (*ProvisionTokenSpecV2GCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{67}
}
func (m *ProvisionTokenSpecV2GCP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2GCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2GCP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2GCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2GCP.Merge(m, src)
}
func (m *ProvisionTokenSpecV2GCP) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2GCP) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2GCP.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2GCP proto.InternalMessageInfo

// Rule is a set of properties the GCP-ussued token might have to be allowed
// to use this ProvisionToken.
type ProvisionTokenSpecV2GCP_Rule struct {
	// ProjectIDs is a list of project IDs (e.g. `<example-id-123456>`).
	ProjectIDs []string `protobuf:"bytes,1,rep,name=ProjectIDs,proto3" json:"project_ids,omitempty"`
	// Locations is a list of regions (e.g. "us-west1") and/or zones (e.g.
	// "us-west1-b").
	Locations []string `protobuf:"bytes,2,rep,name=Locations,proto3" json:"locations,omitempty"`
	// ServiceAccounts is a list of service account emails (e.g.
	// `<project-number>-compute@developer.gserviceaccount.com`).
	ServiceAccounts      []string `protobuf:"bytes,3,rep,name=ServiceAccounts,proto3" json:"service_accounts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2GCP_Rule) Reset()         { *m = ProvisionTokenSpecV2GCP_Rule{} }
func (m *ProvisionTokenSpecV2GCP_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2GCP_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2GCP_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{67, 0}
}
func (m *ProvisionTokenSpecV2GCP_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2GCP_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2GCP_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2GCP_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2GCP_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2GCP_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2GCP_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2GCP_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2GCP_Rule proto.InternalMessageInfo

// ProvisionTokenSpecV2Terraform contains Terraform-specific parts of the
// ProvisionTokenSpecV2.
type ProvisionTokenSpecV2TerraformCloud struct {
	// Allow is a list of Rules, nodes using this token must match one
	// allow rule to use this token.
	Allow []*ProvisionTokenSpecV2TerraformCloud_Rule `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow,omitempty"`
	// Audience is the JWT audience as configured in the
	// TFC_WORKLOAD_IDENTITY_AUDIENCE(_$TAG) variable in Terraform Cloud. If
	// unset, defaults to the Teleport cluster name.
	// For example, if `TFC_WORKLOAD_IDENTITY_AUDIENCE_TELEPORT=foo` is set in
	// Terraform Cloud, this value should be `foo`. If the variable is set to
	// match the cluster name, it does not need to be set here.
	Audience             string   `protobuf:"bytes,2,opt,name=Audience,proto3" json:"audience,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2TerraformCloud) Reset()         { *m = ProvisionTokenSpecV2TerraformCloud{} }
func (m *ProvisionTokenSpecV2TerraformCloud) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2TerraformCloud) ProtoMessage()    {}
func (*ProvisionTokenSpecV2TerraformCloud) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{68}
}
func (m *ProvisionTokenSpecV2TerraformCloud) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2TerraformCloud) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2TerraformCloud) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud.Merge(m, src)
}
func (m *ProvisionTokenSpecV2TerraformCloud) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2TerraformCloud) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud proto.InternalMessageInfo

// Rule is a set of properties the Terraform-issued token might have to be
// allowed to use this ProvisionToken.
type ProvisionTokenSpecV2TerraformCloud_Rule struct {
	// OrganizationID is the ID of the HCP Terraform organization. At least
	// one organization value is required, either ID or name.
	OrganizationID string `protobuf:"bytes,1,opt,name=OrganizationID,proto3" json:"organization_id,omitempty"`
	// OrganizationName is the human-readable name of the HCP Terraform
	// organization. At least one organization value is required, either ID or
	// name.
	OrganizationName string `protobuf:"bytes,2,opt,name=OrganizationName,proto3" json:"organization_name,omitempty"`
	// ProjectID is the ID of the HCP Terraform project. At least one project or
	// workspace value is required, either ID or name.
	ProjectID string `protobuf:"bytes,3,opt,name=ProjectID,proto3" json:"project_id,omitempty"`
	// ProjectName is the human-readable name for the HCP Terraform project. At
	// least one project or workspace value is required, either ID or name.
	ProjectName string `protobuf:"bytes,4,opt,name=ProjectName,proto3" json:"project_name,omitempty"`
	// WorkspaceID is the ID of the HCP Terraform workspace. At least one
	// project or workspace value is required, either ID or name.
	WorkspaceID string `protobuf:"bytes,5,opt,name=WorkspaceID,proto3" json:"workspace_id,omitempty"`
	// WorkspaceName is the human-readable name of the HCP Terraform workspace.
	// At least one project or workspace value is required, either ID or name.
	WorkspaceName string `protobuf:"bytes,6,opt,name=WorkspaceName,proto3" json:"workspace_name,omitempty"`
	// RunPhase is the phase of the run the token was issued for, e.g. `plan` or
	// `apply`
	RunPhase             string   `protobuf:"bytes,7,opt,name=RunPhase,proto3" json:"run_phase,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionTokenSpecV2TerraformCloud_Rule) Reset() {
	*m = ProvisionTokenSpecV2TerraformCloud_Rule{}
}
func (m *ProvisionTokenSpecV2TerraformCloud_Rule) String() string { return proto.CompactTextString(m) }
func (*ProvisionTokenSpecV2TerraformCloud_Rule) ProtoMessage()    {}
func (*ProvisionTokenSpecV2TerraformCloud_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{68, 0}
}
func (m *ProvisionTokenSpecV2TerraformCloud_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionTokenSpecV2TerraformCloud_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionTokenSpecV2TerraformCloud_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud_Rule.Merge(m, src)
}
func (m *ProvisionTokenSpecV2TerraformCloud_Rule) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionTokenSpecV2TerraformCloud_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionTokenSpecV2TerraformCloud_Rule proto.InternalMessageInfo

// StaticTokensV2 implements the StaticTokens interface.
type StaticTokensV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a provisioning token V2 spec
	Spec                 StaticTokensSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StaticTokensV2) Reset()      { *m = StaticTokensV2{} }
func (*StaticTokensV2) ProtoMessage() {}
func (*StaticTokensV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{69}
}
func (m *StaticTokensV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticTokensV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaticTokensV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaticTokensV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticTokensV2.Merge(m, src)
}
func (m *StaticTokensV2) XXX_Size() int {
	return m.Size()
}
func (m *StaticTokensV2) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticTokensV2.DiscardUnknown(m)
}

var xxx_messageInfo_StaticTokensV2 proto.InternalMessageInfo

// StaticTokensSpecV2 is the actual data we care about for StaticTokensSpecV2.
type StaticTokensSpecV2 struct {
	// StaticTokens is a list of tokens that can be used to add nodes to the
	// cluster.
	StaticTokens         []ProvisionTokenV1 `protobuf:"bytes,1,rep,name=StaticTokens,proto3" json:"static_tokens"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *StaticTokensSpecV2) Reset()         { *m = StaticTokensSpecV2{} }
func (m *StaticTokensSpecV2) String() string { return proto.CompactTextString(m) }
func (*StaticTokensSpecV2) ProtoMessage()    {}
func (*StaticTokensSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{70}
}
func (m *StaticTokensSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticTokensSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaticTokensSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaticTokensSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticTokensSpecV2.Merge(m, src)
}
func (m *StaticTokensSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *StaticTokensSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticTokensSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_StaticTokensSpecV2 proto.InternalMessageInfo

// ClusterNameV2 implements the ClusterName interface.
type ClusterNameV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a cluster name V2 spec
	Spec                 ClusterNameSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ClusterNameV2) Reset()      { *m = ClusterNameV2{} }
func (*ClusterNameV2) ProtoMessage() {}
func (*ClusterNameV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{71}
}
func (m *ClusterNameV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterNameV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterNameV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterNameV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterNameV2.Merge(m, src)
}
func (m *ClusterNameV2) XXX_Size() int {
	return m.Size()
}
func (m *ClusterNameV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterNameV2.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterNameV2 proto.InternalMessageInfo

// ClusterNameSpecV2 is the actual data we care about for ClusterName.
type ClusterNameSpecV2 struct {
	// ClusterName is the name of the cluster. Changing this value once the
	// cluster is setup can and will cause catastrophic problems.
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"cluster_name"`
	// ClusterID is the unique cluster ID that is set once during the first
	// auth server startup.
	ClusterID            string   `protobuf:"bytes,2,opt,name=ClusterID,proto3" json:"cluster_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterNameSpecV2) Reset()         { *m = ClusterNameSpecV2{} }
func (m *ClusterNameSpecV2) String() string { return proto.CompactTextString(m) }
func (*ClusterNameSpecV2) ProtoMessage()    {}
func (*ClusterNameSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{72}
}
func (m *ClusterNameSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterNameSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterNameSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterNameSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterNameSpecV2.Merge(m, src)
}
func (m *ClusterNameSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *ClusterNameSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterNameSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterNameSpecV2 proto.InternalMessageInfo

// ClusterAuditConfigV2 represents audit log settings in the cluster.
type ClusterAuditConfigV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is a resource version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a ClusterAuditConfig specification
	Spec                 ClusterAuditConfigSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ClusterAuditConfigV2) Reset()         { *m = ClusterAuditConfigV2{} }
func (m *ClusterAuditConfigV2) String() string { return proto.CompactTextString(m) }
func (*ClusterAuditConfigV2) ProtoMessage()    {}
func (*ClusterAuditConfigV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{73}
}
func (m *ClusterAuditConfigV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterAuditConfigV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterAuditConfigV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterAuditConfigV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterAuditConfigV2.Merge(m, src)
}
func (m *ClusterAuditConfigV2) XXX_Size() int {
	return m.Size()
}
func (m *ClusterAuditConfigV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterAuditConfigV2.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterAuditConfigV2 proto.InternalMessageInfo

// ClusterAuditConfigSpecV2 is the actual data we care about
// for ClusterAuditConfig.
type ClusterAuditConfigSpecV2 struct {
	// Type is audit backend type
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type,omitempty"`
	// Region is a region setting for audit sessions used by cloud providers
	Region string `protobuf:"bytes,2,opt,name=Region,proto3" json:"region,omitempty"`
	// AuditSessionsURI is a parameter where to upload sessions
	AuditSessionsURI string `protobuf:"bytes,3,opt,name=AuditSessionsURI,proto3" json:"audit_sessions_uri,omitempty"`
	// AuditEventsURI is a parameter with all supported outputs
	// for audit events
	AuditEventsURI github_com_gravitational_teleport_api_types_wrappers.Strings `protobuf:"bytes,4,opt,name=AuditEventsURI,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Strings" json:"audit_events_uri,omitempty"`
	// EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
	EnableContinuousBackups bool `protobuf:"varint,6,opt,name=EnableContinuousBackups,proto3" json:"continuous_backups,omitempty"`
	// EnableAutoScaling is used to enable (or disable) auto scaling policy.
	EnableAutoScaling bool `protobuf:"varint,7,opt,name=EnableAutoScaling,proto3" json:"auto_scaling,omitempty"`
	// ReadMaxCapacity is the maximum provisioned read capacity.
	ReadMaxCapacity int64 `protobuf:"varint,8,opt,name=ReadMaxCapacity,proto3" json:"read_max_capacity,omitempty"`
	// ReadMinCapacity is the minimum provisioned read capacity.
	ReadMinCapacity int64 `protobuf:"varint,9,opt,name=ReadMinCapacity,proto3" json:"read_min_capacity,omitempty"`
	// ReadTargetValue is the ratio of consumed read to provisioned capacity.
	ReadTargetValue float64 `protobuf:"fixed64,10,opt,name=ReadTargetValue,proto3" json:"read_target_value,omitempty"`
	// WriteMaxCapacity is the maximum provisioned write capacity.
	WriteMaxCapacity int64 `protobuf:"varint,11,opt,name=WriteMaxCapacity,proto3" json:"write_max_capacity,omitempty"`
	// WriteMinCapacity is the minimum provisioned write capacity.
	WriteMinCapacity int64 `protobuf:"varint,12,opt,name=WriteMinCapacity,proto3" json:"write_min_capacity,omitempty"`
	// WriteTargetValue is the ratio of consumed write to provisioned capacity.
	WriteTargetValue float64 `protobuf:"fixed64,13,opt,name=WriteTargetValue,proto3" json:"write_target_value,omitempty"`
	// RetentionPeriod is the retention period for audit events.
	RetentionPeriod Duration `protobuf:"varint,14,opt,name=RetentionPeriod,proto3,casttype=Duration" json:"retention_period"`
	// UseFIPSEndpoint configures AWS endpoints to use FIPS.
	UseFIPSEndpoint      ClusterAuditConfigSpecV2_FIPSEndpointState `protobuf:"varint,15,opt,name=UseFIPSEndpoint,proto3,enum=types.ClusterAuditConfigSpecV2_FIPSEndpointState" json:"use_fips_endpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *ClusterAuditConfigSpecV2) Reset()         { *m = ClusterAuditConfigSpecV2{} }
func (m *ClusterAuditConfigSpecV2) String() string { return proto.CompactTextString(m) }
func (*ClusterAuditConfigSpecV2) ProtoMessage()    {}
func (*ClusterAuditConfigSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{74}
}
func (m *ClusterAuditConfigSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterAuditConfigSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterAuditConfigSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterAuditConfigSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterAuditConfigSpecV2.Merge(m, src)
}
func (m *ClusterAuditConfigSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *ClusterAuditConfigSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterAuditConfigSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterAuditConfigSpecV2 proto.InternalMessageInfo

// ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
type ClusterNetworkingConfigV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are:`v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a ClusterNetworkingConfig specification
	Spec                 ClusterNetworkingConfigSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ClusterNetworkingConfigV2) Reset()         { *m = ClusterNetworkingConfigV2{} }
func (m *ClusterNetworkingConfigV2) String() string { return proto.CompactTextString(m) }
func (*ClusterNetworkingConfigV2) ProtoMessage()    {}
func (*ClusterNetworkingConfigV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{75}
}
func (m *ClusterNetworkingConfigV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterNetworkingConfigV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterNetworkingConfigV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterNetworkingConfigV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterNetworkingConfigV2.Merge(m, src)
}
func (m *ClusterNetworkingConfigV2) XXX_Size() int {
	return m.Size()
}
func (m *ClusterNetworkingConfigV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterNetworkingConfigV2.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterNetworkingConfigV2 proto.InternalMessageInfo

// ClusterNetworkingConfigSpecV2 is the actual data we care about
// for ClusterNetworkingConfig.
type ClusterNetworkingConfigSpecV2 struct {
	// ClientIdleTimeout sets global cluster default setting for client idle
	// timeouts.
	ClientIdleTimeout Duration `protobuf:"varint,1,opt,name=ClientIdleTimeout,proto3,casttype=Duration" json:"client_idle_timeout"`
	// KeepAliveInterval is the interval at which the server sends keep-alive messages
	// to the client.
	KeepAliveInterval Duration `protobuf:"varint,2,opt,name=KeepAliveInterval,proto3,casttype=Duration" json:"keep_alive_interval"`
	// KeepAliveCountMax is the number of keep-alive messages that can be
	// missed before the server disconnects the connection to the client.
	KeepAliveCountMax int64 `protobuf:"varint,3,opt,name=KeepAliveCountMax,proto3" json:"keep_alive_count_max"`
	// SessionControlTimeout is the session control lease expiry and defines
	// the upper limit of how long a node may be out of contact with the auth
	// server before it begins terminating controlled sessions.
	SessionControlTimeout Duration `protobuf:"varint,4,opt,name=SessionControlTimeout,proto3,casttype=Duration" json:"session_control_timeout"`
	// ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
	ClientIdleTimeoutMessage string `protobuf:"bytes,5,opt,name=ClientIdleTimeoutMessage,proto3" json:"idle_timeout_message"`
	// WebIdleTimeout sets global cluster default setting for the web UI idle
	// timeouts.
	WebIdleTimeout Duration `protobuf:"varint,6,opt,name=WebIdleTimeout,proto3,casttype=Duration" json:"web_idle_timeout"`
	// ProxyListenerMode is proxy listener mode used by Teleport Proxies.
	// 0 is "separate"; 1 is "multiplex".
	ProxyListenerMode ProxyListenerMode `protobuf:"varint,7,opt,name=ProxyListenerMode,proto3,enum=types.ProxyListenerMode" json:"proxy_listener_mode,omitempty"`
	// RoutingStrategy determines the strategy used to route to nodes.
	// 0 is "unambiguous_match"; 1 is "most_recent".
	RoutingStrategy RoutingStrategy `protobuf:"varint,8,opt,name=RoutingStrategy,proto3,enum=types.RoutingStrategy" json:"routing_strategy,omitempty"`
	// TunnelStrategyV1 determines the tunnel strategy used in the cluster.
	TunnelStrategy *TunnelStrategyV1 `protobuf:"bytes,9,opt,name=TunnelStrategy,proto3" json:"tunnel_strategy,omitempty"`
	// ProxyPingInterval defines in which interval the TLS routing ping message
	// should be sent. This is applicable only when using ping-wrapped
	// connections, regular TLS routing connections are not affected.
	ProxyPingInterval Duration `protobuf:"varint,10,opt,name=ProxyPingInterval,proto3,casttype=Duration" json:"proxy_ping_interval,omitempty"`
	// AssistCommandExecutionWorkers determines the number of workers that will
	// execute arbitrary Assist commands on servers in parallel
	AssistCommandExecutionWorkers int32 `protobuf:"varint,11,opt,name=AssistCommandExecutionWorkers,proto3" json:"assist_command_execution_workers,omitempty"`
	// CaseInsensitiveRouting causes proxies to use case-insensitive hostname matching.
	CaseInsensitiveRouting bool `protobuf:"varint,12,opt,name=CaseInsensitiveRouting,proto3" json:"case_insensitive_routing,omitempty"`
	// SSHDialTimeout is a custom dial timeout used when establishing
	// SSH connections. If not set, the default timeout of 30s will be used.
	SSHDialTimeout       Duration `protobuf:"varint,13,opt,name=SSHDialTimeout,proto3,casttype=Duration" json:"ssh_dial_timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterNetworkingConfigSpecV2) Reset()         { *m = ClusterNetworkingConfigSpecV2{} }
func (m *ClusterNetworkingConfigSpecV2) String() string { return proto.CompactTextString(m) }
func (*ClusterNetworkingConfigSpecV2) ProtoMessage()    {}
func (*ClusterNetworkingConfigSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{76}
}
func (m *ClusterNetworkingConfigSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterNetworkingConfigSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterNetworkingConfigSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterNetworkingConfigSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterNetworkingConfigSpecV2.Merge(m, src)
}
func (m *ClusterNetworkingConfigSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *ClusterNetworkingConfigSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterNetworkingConfigSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterNetworkingConfigSpecV2 proto.InternalMessageInfo

// TunnelStrategyV1 defines possible tunnel strategy types.
type TunnelStrategyV1 struct {
	// Types that are valid to be assigned to Strategy:
	//
	//	*TunnelStrategyV1_AgentMesh
	//	*TunnelStrategyV1_ProxyPeering
	Strategy             isTunnelStrategyV1_Strategy `protobuf_oneof:"Strategy"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TunnelStrategyV1) Reset()         { *m = TunnelStrategyV1{} }
func (m *TunnelStrategyV1) String() string { return proto.CompactTextString(m) }
func (*TunnelStrategyV1) ProtoMessage()    {}
func (*TunnelStrategyV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{77}
}
func (m *TunnelStrategyV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelStrategyV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelStrategyV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelStrategyV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelStrategyV1.Merge(m, src)
}
func (m *TunnelStrategyV1) XXX_Size() int {
	return m.Size()
}
func (m *TunnelStrategyV1) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelStrategyV1.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelStrategyV1 proto.InternalMessageInfo

type isTunnelStrategyV1_Strategy interface {
	isTunnelStrategyV1_Strategy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TunnelStrategyV1_AgentMesh struct {
	AgentMesh *AgentMeshTunnelStrategy `protobuf:"bytes,1,opt,name=AgentMesh,proto3,oneof" json:"agent_mesh,omitempty"`
}
type TunnelStrategyV1_ProxyPeering struct {
	ProxyPeering *ProxyPeeringTunnelStrategy `protobuf:"bytes,2,opt,name=ProxyPeering,proto3,oneof" json:"proxy_peering,omitempty"`
}

func (*TunnelStrategyV1_AgentMesh) isTunnelStrategyV1_Strategy()    {}
func (*TunnelStrategyV1_ProxyPeering) isTunnelStrategyV1_Strategy() {}

func (m *TunnelStrategyV1) GetStrategy() isTunnelStrategyV1_Strategy {
	if m != nil {
		return m.Strategy
	}
	return nil
}

func (m *TunnelStrategyV1) GetAgentMesh() *AgentMeshTunnelStrategy {
	if x, ok := m.GetStrategy().(*TunnelStrategyV1_AgentMesh); ok {
		return x.AgentMesh
	}
	return nil
}

func (m *TunnelStrategyV1) GetProxyPeering() *ProxyPeeringTunnelStrategy {
	if x, ok := m.GetStrategy().(*TunnelStrategyV1_ProxyPeering); ok {
		return x.ProxyPeering
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TunnelStrategyV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TunnelStrategyV1_AgentMesh)(nil),
		(*TunnelStrategyV1_ProxyPeering)(nil),
	}
}

// AgentMeshTunnelStrategy requires reverse tunnels to dial every proxy.
type AgentMeshTunnelStrategy struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AgentMeshTunnelStrategy) Reset()         { *m = AgentMeshTunnelStrategy{} }
func (m *AgentMeshTunnelStrategy) String() string { return proto.CompactTextString(m) }
func (*AgentMeshTunnelStrategy) ProtoMessage()    {}
func (*AgentMeshTunnelStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{78}
}
func (m *AgentMeshTunnelStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgentMeshTunnelStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgentMeshTunnelStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgentMeshTunnelStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgentMeshTunnelStrategy.Merge(m, src)
}
func (m *AgentMeshTunnelStrategy) XXX_Size() int {
	return m.Size()
}
func (m *AgentMeshTunnelStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_AgentMeshTunnelStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_AgentMeshTunnelStrategy proto.InternalMessageInfo

// ProxyPeeringTunnelStrategy requires reverse tunnels to dial a fixed number of proxies.
type ProxyPeeringTunnelStrategy struct {
	AgentConnectionCount int64    `protobuf:"varint,1,opt,name=AgentConnectionCount,proto3" json:"agent_connection_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProxyPeeringTunnelStrategy) Reset()         { *m = ProxyPeeringTunnelStrategy{} }
func (m *ProxyPeeringTunnelStrategy) String() string { return proto.CompactTextString(m) }
func (*ProxyPeeringTunnelStrategy) ProtoMessage()    {}
func (*ProxyPeeringTunnelStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{79}
}
func (m *ProxyPeeringTunnelStrategy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProxyPeeringTunnelStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProxyPeeringTunnelStrategy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProxyPeeringTunnelStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProxyPeeringTunnelStrategy.Merge(m, src)
}
func (m *ProxyPeeringTunnelStrategy) XXX_Size() int {
	return m.Size()
}
func (m *ProxyPeeringTunnelStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_ProxyPeeringTunnelStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_ProxyPeeringTunnelStrategy proto.InternalMessageInfo

// SessionRecordingConfigV2 contains session recording configuration.
type SessionRecordingConfigV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are:`v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a SessionRecordingConfig specification
	Spec                 SessionRecordingConfigSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *SessionRecordingConfigV2) Reset()         { *m = SessionRecordingConfigV2{} }
func (m *SessionRecordingConfigV2) String() string { return proto.CompactTextString(m) }
func (*SessionRecordingConfigV2) ProtoMessage()    {}
func (*SessionRecordingConfigV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{80}
}
func (m *SessionRecordingConfigV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionRecordingConfigV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionRecordingConfigV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionRecordingConfigV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionRecordingConfigV2.Merge(m, src)
}
func (m *SessionRecordingConfigV2) XXX_Size() int {
	return m.Size()
}
func (m *SessionRecordingConfigV2) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionRecordingConfigV2.DiscardUnknown(m)
}

var xxx_messageInfo_SessionRecordingConfigV2 proto.InternalMessageInfo

// SessionRecordingConfigSpecV2 is the actual data we care about
// for SessionRecordingConfig.
type SessionRecordingConfigSpecV2 struct {
	// Mode controls where (or if) the session is recorded.
	Mode string `protobuf:"bytes,1,opt,name=Mode,proto3" json:"mode"`
	// ProxyChecksHostKeys is used to control if the proxy will check host keys
	// when in recording mode.
	ProxyChecksHostKeys  *BoolOption `protobuf:"bytes,2,opt,name=ProxyChecksHostKeys,proto3,customtype=BoolOption" json:"proxy_checks_host_keys"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SessionRecordingConfigSpecV2) Reset()         { *m = SessionRecordingConfigSpecV2{} }
func (m *SessionRecordingConfigSpecV2) String() string { return proto.CompactTextString(m) }
func (*SessionRecordingConfigSpecV2) ProtoMessage()    {}
func (*SessionRecordingConfigSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{81}
}
func (m *SessionRecordingConfigSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionRecordingConfigSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionRecordingConfigSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionRecordingConfigSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionRecordingConfigSpecV2.Merge(m, src)
}
func (m *SessionRecordingConfigSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *SessionRecordingConfigSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionRecordingConfigSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_SessionRecordingConfigSpecV2 proto.InternalMessageInfo

// AuthPreferenceV2 implements the AuthPreference interface.
type AuthPreferenceV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is an AuthPreference specification
	Spec                 AuthPreferenceSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AuthPreferenceV2) Reset()      { *m = AuthPreferenceV2{} }
func (*AuthPreferenceV2) ProtoMessage() {}
func (*AuthPreferenceV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{82}
}
func (m *AuthPreferenceV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthPreferenceV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthPreferenceV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthPreferenceV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthPreferenceV2.Merge(m, src)
}
func (m *AuthPreferenceV2) XXX_Size() int {
	return m.Size()
}
func (m *AuthPreferenceV2) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthPreferenceV2.DiscardUnknown(m)
}

var xxx_messageInfo_AuthPreferenceV2 proto.InternalMessageInfo

// AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.
type AuthPreferenceSpecV2 struct {
	// Type is the type of authentication.
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type"`
	// SecondFactor is the type of second factor.
	SecondFactor github_com_gravitational_teleport_api_constants.SecondFactorType `protobuf:"bytes,2,opt,name=SecondFactor,proto3,casttype=github.com/gravitational/teleport/api/constants.SecondFactorType" json:"second_factor,omitempty"`
	// ConnectorName is the name of the OIDC or SAML connector. If this value is
	// not set the first connector in the backend will be used.
	ConnectorName string `protobuf:"bytes,3,opt,name=ConnectorName,proto3" json:"connector_name,omitempty"`
	// U2F are the settings for the U2F device.
	U2F *U2F `protobuf:"bytes,4,opt,name=U2F,proto3" json:"u2f,omitempty"`
	// DisconnectExpiredCert provides disconnect expired certificate setting -
	// if true, connections with expired client certificates will get disconnected
	DisconnectExpiredCert *BoolOption `protobuf:"bytes,6,opt,name=DisconnectExpiredCert,proto3,customtype=BoolOption" json:"disconnect_expired_cert,omitempty"`
	// AllowLocalAuth is true if local authentication is enabled.
	AllowLocalAuth  *BoolOption `protobuf:"bytes,7,opt,name=AllowLocalAuth,proto3,customtype=BoolOption" json:"allow_local_auth,omitempty"`
	MessageOfTheDay string      `protobuf:"bytes,8,opt,name=MessageOfTheDay,proto3" json:"message_of_the_day,omitempty"`
	// LockingMode is the cluster-wide locking mode default.
	LockingMode github_com_gravitational_teleport_api_constants.LockingMode `protobuf:"bytes,9,opt,name=LockingMode,proto3,casttype=github.com/gravitational/teleport/api/constants.LockingMode" json:"locking_mode,omitempty"`
	// Webauthn are the settings for server-side Web Authentication support.
	Webauthn *Webauthn `protobuf:"bytes,10,opt,name=Webauthn,proto3" json:"webauthn,omitempty"`
	// AllowPasswordless enables/disables passwordless support.
	// Passwordless requires Webauthn to work.
	// Defaults to true if the Webauthn is configured, defaults to false
	// otherwise.
	AllowPasswordless *BoolOption `protobuf:"bytes,11,opt,name=AllowPasswordless,proto3,customtype=BoolOption" json:"allow_passwordless,omitempty"`
	// RequireMFAType is the type of MFA requirement enforced for this cluster.
	// 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
	// 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
	RequireMFAType RequireMFAType `protobuf:"varint,12,opt,name=RequireMFAType,proto3,enum=types.RequireMFAType" json:"require_session_mfa,omitempty"`
	// DeviceTrust holds settings related to trusted device verification.
	// Requires Teleport Enterprise.
	DeviceTrust *DeviceTrust `protobuf:"bytes,13,opt,name=DeviceTrust,proto3" json:"device_trust,omitempty"`
	// IDP is a set of options related to accessing IdPs within Teleport.
	// Requires Teleport Enterprise.
	IDP *IdPOptions `protobuf:"bytes,14,opt,name=IDP,proto3" json:"idp,omitempty"`
	// AllowHeadless enables/disables headless support.
	// Headless authentication requires Webauthn to work.
	// Defaults to true if the Webauthn is configured, defaults to false
	// otherwise.
	AllowHeadless *BoolOption `protobuf:"bytes,15,opt,name=AllowHeadless,proto3,customtype=BoolOption" json:"allow_headless,omitempty"`
	// DefaultSessionTTL is the TTL to use for user certs when
	// an explicit TTL is not requested.
	DefaultSessionTTL Duration `protobuf:"varint,16,opt,name=DefaultSessionTTL,proto3,casttype=Duration" json:"default_session_ttl,omitempty"`
	// Okta is a set of options related to the Okta service in Teleport.
	// Requires Teleport Enterprise.
	Okta *OktaOptions `protobuf:"bytes,17,opt,name=Okta,proto3" json:"okta,omitempty"`
	// TODO(Joerger): DELETE IN 17.0.0
	// Deprecated, replaced by HardwareKey settings.
	PIVSlot string `protobuf:"bytes,18,opt,name=PIVSlot,proto3" json:"piv_slot,omitempty"` // Deprecated: Do not use.
	// HardwareKey are the settings for hardware key support.
	HardwareKey *HardwareKey `protobuf:"bytes,19,opt,name=HardwareKey,proto3" json:"hardware_key,omitempty"`
	// SignatureAlgorithmSuite is the configured signature algorithm suite for the cluster.
	// The current default value is "legacy". This field is not yet fully supported.
	SignatureAlgorithmSuite SignatureAlgorithmSuite `protobuf:"varint,20,opt,name=signature_algorithm_suite,json=signatureAlgorithmSuite,proto3,enum=types.SignatureAlgorithmSuite" json:"signature_algorithm_suite,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                `json:"-"`
	XXX_unrecognized        []byte                  `json:"-"`
	XXX_sizecache           int32                   `json:"-"`
}

func (m *AuthPreferenceSpecV2) Reset()         { *m = AuthPreferenceSpecV2{} }
func (m *AuthPreferenceSpecV2) String() string { return proto.CompactTextString(m) }
func (*AuthPreferenceSpecV2) ProtoMessage()    {}
func (*AuthPreferenceSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{83}
}
func (m *AuthPreferenceSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthPreferenceSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthPreferenceSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthPreferenceSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthPreferenceSpecV2.Merge(m, src)
}
func (m *AuthPreferenceSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *AuthPreferenceSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthPreferenceSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_AuthPreferenceSpecV2 proto.InternalMessageInfo

// U2F defines settings for U2F device.
// Deprecated: U2F is transparently converted to WebAuthn by Teleport. Prefer
// using WebAuthn instead.
type U2F struct {
	// AppID returns the application ID for universal second factor.
	AppID string `protobuf:"bytes,1,opt,name=AppID,proto3" json:"app_id,omitempty"`
	// Facets returns the facets for universal second factor.
	// Deprecated: Kept for backwards compatibility reasons, but Facets have no
	// effect since Teleport v10, when Webauthn replaced the U2F implementation.
	Facets []string `protobuf:"bytes,2,rep,name=Facets,proto3" json:"facets,omitempty"`
	// DeviceAttestationCAs contains the trusted attestation CAs for U2F
	// devices.
	DeviceAttestationCAs []string `protobuf:"bytes,3,rep,name=DeviceAttestationCAs,proto3" json:"device_attestation_cas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *U2F) Reset()         { *m = U2F{} }
func (m *U2F) String() string { return proto.CompactTextString(m) }
func (*U2F) ProtoMessage()    {}
func (*U2F) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{84}
}
func (m *U2F) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *U2F) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_U2F.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *U2F) XXX_Merge(src proto.Message) {
	xxx_messageInfo_U2F.Merge(m, src)
}
func (m *U2F) XXX_Size() int {
	return m.Size()
}
func (m *U2F) XXX_DiscardUnknown() {
	xxx_messageInfo_U2F.DiscardUnknown(m)
}

var xxx_messageInfo_U2F proto.InternalMessageInfo

// Webauthn defines user-visible settings for server-side Web Authentication
// support.
type Webauthn struct {
	// RPID is the ID of the Relying Party.
	// It should be set to the domain name of the Teleport installation.
	//
	// IMPORTANT: RPID must never change in the lifetime of the cluster, because
	// it's recorded in the registration data on the WebAuthn device. If the
	// RPID changes, all existing WebAuthn key registrations will become invalid
	// and all users who use WebAuthn as the second factor will need to
	// re-register.
	RPID string `protobuf:"bytes,1,opt,name=RPID,proto3" json:"rp_id,omitempty"`
	// Allow list of device attestation CAs in PEM format.
	// If present, only devices whose attestation certificates match the
	// certificates specified here may be registered (existing registrations are
	// unchanged).
	// If supplied in conjunction with AttestationDeniedCAs, then both
	// conditions need to be true for registration to be allowed (the device
	// MUST match an allowed CA and MUST NOT match a denied CA).
	// By default all devices are allowed.
	AttestationAllowedCAs []string `protobuf:"bytes,2,rep,name=AttestationAllowedCAs,proto3" json:"attestation_allowed_cas,omitempty"`
	// Deny list of device attestation CAs in PEM format.
	// If present, only devices whose attestation certificates don't match the
	// certificates specified here may be registered (existing registrations are
	// unchanged).
	// If supplied in conjunction with AttestationAllowedCAs, then both
	// conditions need to be true for registration to be allowed (the device
	// MUST match an allowed CA and MUST NOT match a denied CA).
	// By default no devices are denied.
	AttestationDeniedCAs []string `protobuf:"bytes,3,rep,name=AttestationDeniedCAs,proto3" json:"attestation_denied_cas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Webauthn) Reset()         { *m = Webauthn{} }
func (m *Webauthn) String() string { return proto.CompactTextString(m) }
func (*Webauthn) ProtoMessage()    {}
func (*Webauthn) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{85}
}
func (m *Webauthn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Webauthn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Webauthn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Webauthn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Webauthn.Merge(m, src)
}
func (m *Webauthn) XXX_Size() int {
	return m.Size()
}
func (m *Webauthn) XXX_DiscardUnknown() {
	xxx_messageInfo_Webauthn.DiscardUnknown(m)
}

var xxx_messageInfo_Webauthn proto.InternalMessageInfo

// DeviceTrust holds settings related to trusted device verification.
// Requires Teleport Enterprise.
type DeviceTrust struct {
	// Mode of verification for trusted devices.
	//
	// The following modes are supported:
	//
	//   - "off": disables both device authentication and authorization.
	//   - "optional": allows both device authentication and authorization, but
	//     doesn't enforce the presence of device extensions for sensitive
	//     endpoints.
	//   - "required": enforces the presence of device extensions for sensitive
	//     endpoints.
	//
	// Mode is always "off" for OSS.
	// Defaults to "optional" for Enterprise.
	Mode string `protobuf:"bytes,1,opt,name=Mode,proto3" json:"mode,omitempty"`
	// Enable device auto-enroll.
	// Auto-enroll lets any user issue a device enrollment token for a known
	// device that is not already enrolled.
	// `tsh` takes advantage of auto-enroll to automatically enroll devices on
	// user login, when appropriate.
	// The effective cluster Mode still applies: AutoEnroll=true is meaningless if
	// Mode="off".
	AutoEnroll bool `protobuf:"varint,2,opt,name=AutoEnroll,proto3" json:"auto_enroll,omitempty"`
	// Allow list of EKCert CAs in PEM format.
	// If present, only TPM devices that present an EKCert that is signed by a
	// CA specified here may be enrolled (existing enrollments are
	// unchanged).
	//
	// If not present, then the CA of TPM EKCerts will not be checked during
	// enrollment, this allows any device to enroll.
	EKCertAllowedCAs     []string `protobuf:"bytes,3,rep,name=EKCertAllowedCAs,proto3" json:"ekcert_allowed_cas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceTrust) Reset()         { *m = DeviceTrust{} }
func (m *DeviceTrust) String() string { return proto.CompactTextString(m) }
func (*DeviceTrust) ProtoMessage()    {}
func (*DeviceTrust) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{86}
}
func (m *DeviceTrust) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceTrust) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceTrust.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceTrust) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceTrust.Merge(m, src)
}
func (m *DeviceTrust) XXX_Size() int {
	return m.Size()
}
func (m *DeviceTrust) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceTrust.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceTrust proto.InternalMessageInfo

// HardwareKey holds settings related to hardware key support.
// Requires Teleport Enterprise.
type HardwareKey struct {
	// PIVSlot is a PIV slot that Teleport clients should use instead of the
	// default based on private key policy. For example, "9a" or "9e".
	PIVSlot string `protobuf:"bytes,1,opt,name=PIVSlot,proto3" json:"piv_slot,omitempty"`
	// SerialNumberValidation holds settings for hardware key serial number validation.
	// By default, serial number validation is disabled.
	SerialNumberValidation *HardwareKeySerialNumberValidation `protobuf:"bytes,2,opt,name=SerialNumberValidation,proto3" json:"serial_number_validation,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                           `json:"-"`
	XXX_unrecognized       []byte                             `json:"-"`
	XXX_sizecache          int32                              `json:"-"`
}

func (m *HardwareKey) Reset()         { *m = HardwareKey{} }
func (m *HardwareKey) String() string { return proto.CompactTextString(m) }
func (*HardwareKey) ProtoMessage()    {}
func (*HardwareKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{87}
}
func (m *HardwareKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardwareKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HardwareKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HardwareKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardwareKey.Merge(m, src)
}
func (m *HardwareKey) XXX_Size() int {
	return m.Size()
}
func (m *HardwareKey) XXX_DiscardUnknown() {
	xxx_messageInfo_HardwareKey.DiscardUnknown(m)
}

var xxx_messageInfo_HardwareKey proto.InternalMessageInfo

type HardwareKeySerialNumberValidation struct {
	// Enabled indicates whether hardware key serial number validation is enabled.
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled,omitempty"`
	// SerialNumberTraitName is an optional custom user trait name for hardware key
	// serial numbers to replace the default: "hardware_key_serial_numbers".
	//
	// Note: Values for this user trait should be a comma-separated list of serial numbers,
	// or a list of comm-separated lists. e.g ["123", "345,678"]
	SerialNumberTraitName string   `protobuf:"bytes,2,opt,name=SerialNumberTraitName,proto3" json:"serial_number_trait_name,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *HardwareKeySerialNumberValidation) Reset()         { *m = HardwareKeySerialNumberValidation{} }
func (m *HardwareKeySerialNumberValidation) String() string { return proto.CompactTextString(m) }
func (*HardwareKeySerialNumberValidation) ProtoMessage()    {}
func (*HardwareKeySerialNumberValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{88}
}
func (m *HardwareKeySerialNumberValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardwareKeySerialNumberValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HardwareKeySerialNumberValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HardwareKeySerialNumberValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardwareKeySerialNumberValidation.Merge(m, src)
}
func (m *HardwareKeySerialNumberValidation) XXX_Size() int {
	return m.Size()
}
func (m *HardwareKeySerialNumberValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_HardwareKeySerialNumberValidation.DiscardUnknown(m)
}

var xxx_messageInfo_HardwareKeySerialNumberValidation proto.InternalMessageInfo

// Namespace represents namespace resource specification
type Namespace struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a namespace spec
	Spec                 NamespaceSpec `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Namespace) Reset()         { *m = Namespace{} }
func (m *Namespace) String() string { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()    {}
func (*Namespace) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{89}
}
func (m *Namespace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Namespace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Namespace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Namespace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Namespace.Merge(m, src)
}
func (m *Namespace) XXX_Size() int {
	return m.Size()
}
func (m *Namespace) XXX_DiscardUnknown() {
	xxx_messageInfo_Namespace.DiscardUnknown(m)
}

var xxx_messageInfo_Namespace proto.InternalMessageInfo

// NamespaceSpec is a namespace specification
type NamespaceSpec struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NamespaceSpec) Reset()         { *m = NamespaceSpec{} }
func (m *NamespaceSpec) String() string { return proto.CompactTextString(m) }
func (*NamespaceSpec) ProtoMessage()    {}
func (*NamespaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{90}
}
func (m *NamespaceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceSpec.Merge(m, src)
}
func (m *NamespaceSpec) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceSpec proto.InternalMessageInfo

type UserTokenV3 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is a resource sub kind, used to define the type of user token.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is an resource specification
	Spec                 UserTokenSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserTokenV3) Reset()      { *m = UserTokenV3{} }
func (*UserTokenV3) ProtoMessage() {}
func (*UserTokenV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{91}
}
func (m *UserTokenV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTokenV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTokenV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTokenV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTokenV3.Merge(m, src)
}
func (m *UserTokenV3) XXX_Size() int {
	return m.Size()
}
func (m *UserTokenV3) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTokenV3.DiscardUnknown(m)
}

var xxx_messageInfo_UserTokenV3 proto.InternalMessageInfo

type UserTokenSpecV3 struct {
	// User is user name associated with this token
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// URL is this token URL
	URL string `protobuf:"bytes,2,opt,name=URL,proto3" json:"url"`
	// Usage is an optional field that provides more information about how this token will be used.
	Usage UserTokenUsage `protobuf:"varint,3,opt,name=Usage,proto3,enum=types.UserTokenUsage" json:"usage,omitempty"`
	// Created holds information about when the token was created
	Created              time.Time `protobuf:"bytes,4,opt,name=Created,proto3,stdtime" json:"created,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *UserTokenSpecV3) Reset()         { *m = UserTokenSpecV3{} }
func (m *UserTokenSpecV3) String() string { return proto.CompactTextString(m) }
func (*UserTokenSpecV3) ProtoMessage()    {}
func (*UserTokenSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{92}
}
func (m *UserTokenSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTokenSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTokenSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTokenSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTokenSpecV3.Merge(m, src)
}
func (m *UserTokenSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *UserTokenSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTokenSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_UserTokenSpecV3 proto.InternalMessageInfo

type UserTokenSecretsV3 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is an resource specification
	Spec                 UserTokenSecretsSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UserTokenSecretsV3) Reset()      { *m = UserTokenSecretsV3{} }
func (*UserTokenSecretsV3) ProtoMessage() {}
func (*UserTokenSecretsV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{93}
}
func (m *UserTokenSecretsV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTokenSecretsV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTokenSecretsV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTokenSecretsV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTokenSecretsV3.Merge(m, src)
}
func (m *UserTokenSecretsV3) XXX_Size() int {
	return m.Size()
}
func (m *UserTokenSecretsV3) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTokenSecretsV3.DiscardUnknown(m)
}

var xxx_messageInfo_UserTokenSecretsV3 proto.InternalMessageInfo

type UserTokenSecretsSpecV3 struct {
	// OTPKey is is a secret value of one time password secret generator
	OTPKey string `protobuf:"bytes,1,opt,name=OTPKey,proto3" json:"opt_key"`
	// OTPKey is is a secret value of one time password secret generator
	QRCode string `protobuf:"bytes,2,opt,name=QRCode,proto3" json:"qr_code,omitempty"`
	// Created holds information about when the token was created
	Created              time.Time `protobuf:"bytes,3,opt,name=Created,proto3,stdtime" json:"created,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *UserTokenSecretsSpecV3) Reset()         { *m = UserTokenSecretsSpecV3{} }
func (m *UserTokenSecretsSpecV3) String() string { return proto.CompactTextString(m) }
func (*UserTokenSecretsSpecV3) ProtoMessage()    {}
func (*UserTokenSecretsSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{94}
}
func (m *UserTokenSecretsSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserTokenSecretsSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserTokenSecretsSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserTokenSecretsSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserTokenSecretsSpecV3.Merge(m, src)
}
func (m *UserTokenSecretsSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *UserTokenSecretsSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_UserTokenSecretsSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_UserTokenSecretsSpecV3 proto.InternalMessageInfo

// AccessRequest represents an access request resource specification
type AccessRequestV3 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is AccessRequest metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is an AccessRequest specification
	Spec                 AccessRequestSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AccessRequestV3) Reset()      { *m = AccessRequestV3{} }
func (*AccessRequestV3) ProtoMessage() {}
func (*AccessRequestV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{95}
}
func (m *AccessRequestV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestV3.Merge(m, src)
}
func (m *AccessRequestV3) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestV3.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestV3 proto.InternalMessageInfo

// AccessReviewThreshold describes a filter used to match access reviews,
// as well as approval/denial counts which trigger state-transitions.  This type
// can be used to describe policies such as "can be approved by 2 admins"
// or "can be denied by any non-contractor".
type AccessReviewThreshold struct {
	// Name is the optional human-readable name of the threshold.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	// Filter is an optional predicate used to determine which reviews
	// count toward this threshold.
	Filter string `protobuf:"bytes,2,opt,name=Filter,proto3" json:"filter,omitempty"`
	// Approve is the number of matching approvals needed for state-transition.
	Approve uint32 `protobuf:"varint,3,opt,name=Approve,proto3" json:"approve,omitempty"`
	// Deny is the number of denials needed for state-transition.
	Deny                 uint32   `protobuf:"varint,4,opt,name=Deny,proto3" json:"deny,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessReviewThreshold) Reset()         { *m = AccessReviewThreshold{} }
func (m *AccessReviewThreshold) String() string { return proto.CompactTextString(m) }
func (*AccessReviewThreshold) ProtoMessage()    {}
func (*AccessReviewThreshold) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{96}
}
func (m *AccessReviewThreshold) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessReviewThreshold) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessReviewThreshold.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessReviewThreshold) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessReviewThreshold.Merge(m, src)
}
func (m *AccessReviewThreshold) XXX_Size() int {
	return m.Size()
}
func (m *AccessReviewThreshold) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessReviewThreshold.DiscardUnknown(m)
}

var xxx_messageInfo_AccessReviewThreshold proto.InternalMessageInfo

// PromotedAccessList is a minimal access list representation used for
// promoting access requests to access lists.
type PromotedAccessList struct {
	// Name is the name of the access list.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Title is the title of the access list.
	Title                string   `protobuf:"bytes,2,opt,name=Title,proto3" json:"title"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PromotedAccessList) Reset()         { *m = PromotedAccessList{} }
func (m *PromotedAccessList) String() string { return proto.CompactTextString(m) }
func (*PromotedAccessList) ProtoMessage()    {}
func (*PromotedAccessList) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{97}
}
func (m *PromotedAccessList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PromotedAccessList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PromotedAccessList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PromotedAccessList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PromotedAccessList.Merge(m, src)
}
func (m *PromotedAccessList) XXX_Size() int {
	return m.Size()
}
func (m *PromotedAccessList) XXX_DiscardUnknown() {
	xxx_messageInfo_PromotedAccessList.DiscardUnknown(m)
}

var xxx_messageInfo_PromotedAccessList proto.InternalMessageInfo

// AccessReview is a review to be applied to an access request.
type AccessReview struct {
	// Author is the teleport username of the review author.
	Author string `protobuf:"bytes,1,opt,name=Author,proto3" json:"author"`
	// Roles is a list used for role-subselection (not yet fully supported).
	Roles []string `protobuf:"bytes,2,rep,name=Roles,proto3" json:"roles,omitempty"`
	// ProposedState is the proposed state (must be APPROVED or DENIED).
	ProposedState RequestState `protobuf:"varint,3,opt,name=ProposedState,proto3,enum=types.RequestState" json:"proposed_state,omitempty"`
	// Reason is an optional human-readable reason for why the above state
	// is being proposed.
	Reason string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	// Created is the time at which the review was created.
	Created time.Time `protobuf:"bytes,5,opt,name=Created,proto3,stdtime" json:"created,omitempty"`
	// Annotations is the proposed value of the request's resolve_annotations field.
	Annotations github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,6,opt,name=Annotations,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"annotations,omitempty"`
	// ThresholdIndexes stores the indexes of thresholds which this review matches
	// (internal use only).
	ThresholdIndexes []uint32 `protobuf:"varint,7,rep,packed,name=ThresholdIndexes,proto3" json:"i,omitempty"`
	// AccessList is the access list that this request was promoted to.
	// This field is only populated when the request is in the PROMOTED state.
	AccessList *PromotedAccessList `protobuf:"bytes,9,opt,name=accessList,proto3" json:"access_list,omitempty"`
	// AssumeStartTime is the time the requested roles can be assumed.
	AssumeStartTime      *time.Time `protobuf:"bytes,10,opt,name=AssumeStartTime,proto3,stdtime" json:"assume_start_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AccessReview) Reset()         { *m = AccessReview{} }
func (m *AccessReview) String() string { return proto.CompactTextString(m) }
func (*AccessReview) ProtoMessage()    {}
func (*AccessReview) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{98}
}
func (m *AccessReview) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessReview) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessReview.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessReview) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessReview.Merge(m, src)
}
func (m *AccessReview) XXX_Size() int {
	return m.Size()
}
func (m *AccessReview) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessReview.DiscardUnknown(m)
}

var xxx_messageInfo_AccessReview proto.InternalMessageInfo

// AccessReviewSubmission encodes the necessary parameters for submitting
// a new access review.
type AccessReviewSubmission struct {
	// RequestID is the unique ID of the request to be reviewed.
	RequestID string `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"id,omitempty"`
	// Review is the review to be applied.
	Review               AccessReview `protobuf:"bytes,2,opt,name=Review,proto3" json:"review,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AccessReviewSubmission) Reset()         { *m = AccessReviewSubmission{} }
func (m *AccessReviewSubmission) String() string { return proto.CompactTextString(m) }
func (*AccessReviewSubmission) ProtoMessage()    {}
func (*AccessReviewSubmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{99}
}
func (m *AccessReviewSubmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessReviewSubmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessReviewSubmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessReviewSubmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessReviewSubmission.Merge(m, src)
}
func (m *AccessReviewSubmission) XXX_Size() int {
	return m.Size()
}
func (m *AccessReviewSubmission) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessReviewSubmission.DiscardUnknown(m)
}

var xxx_messageInfo_AccessReviewSubmission proto.InternalMessageInfo

// ThresholdIndexSet encodes a list of threshold indexes. One of the listed thresholds
// must pass for the set to be considered to have passed (i.e. this is an `or` operator).
type ThresholdIndexSet struct {
	// Indexes are the indexes of thresholds which relate to the role.
	Indexes              []uint32 `protobuf:"varint,1,rep,packed,name=Indexes,proto3" json:"i,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThresholdIndexSet) Reset()         { *m = ThresholdIndexSet{} }
func (m *ThresholdIndexSet) String() string { return proto.CompactTextString(m) }
func (*ThresholdIndexSet) ProtoMessage()    {}
func (*ThresholdIndexSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{100}
}
func (m *ThresholdIndexSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdIndexSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdIndexSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdIndexSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdIndexSet.Merge(m, src)
}
func (m *ThresholdIndexSet) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdIndexSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdIndexSet.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdIndexSet proto.InternalMessageInfo

// ThresholdIndexSets is a list of threshold index sets.  Each of the individual
// sets must pass (i.e. this is an `and` operator).
type ThresholdIndexSets struct {
	// Sets are the sets that make up this group.
	Sets                 []ThresholdIndexSet `protobuf:"bytes,1,rep,name=Sets,proto3" json:"s,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ThresholdIndexSets) Reset()         { *m = ThresholdIndexSets{} }
func (m *ThresholdIndexSets) String() string { return proto.CompactTextString(m) }
func (*ThresholdIndexSets) ProtoMessage()    {}
func (*ThresholdIndexSets) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{101}
}
func (m *ThresholdIndexSets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdIndexSets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdIndexSets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdIndexSets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdIndexSets.Merge(m, src)
}
func (m *ThresholdIndexSets) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdIndexSets) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdIndexSets.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdIndexSets proto.InternalMessageInfo

// AccessRequestSpec is the specification for AccessRequest
type AccessRequestSpecV3 struct {
	// User is the name of the user to whom the roles will be applied.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// Roles is the name of the roles being requested.
	Roles []string `protobuf:"bytes,2,rep,name=Roles,proto3" json:"roles"`
	// State is the current state of this access request.
	State RequestState `protobuf:"varint,3,opt,name=State,proto3,enum=types.RequestState" json:"state,omitempty"`
	// Created encodes the time at which the request was registered with the auth
	// server.
	Created time.Time `protobuf:"bytes,4,opt,name=Created,proto3,stdtime" json:"created,omitempty"`
	// Expires constrains the maximum lifetime of any login session for which this
	// request is active.
	Expires time.Time `protobuf:"bytes,5,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// RequestReason is an optional message explaining the reason for the request.
	RequestReason string `protobuf:"bytes,6,opt,name=RequestReason,proto3" json:"request_reason,omitempty"`
	// ResolveReason is an optional message explaining the reason for the resolution
	// of the request (approval, denial, etc...).
	ResolveReason string `protobuf:"bytes,7,opt,name=ResolveReason,proto3" json:"resolve_reason,omitempty"`
	// ResolveAnnotations is a set of arbitrary values received from plugins or other
	// resolving parties during approval/denial.  Importantly, these annotations are
	// included in the access_request.update event, allowing plugins to propagate
	// arbitrary structured data to the audit log.
	ResolveAnnotations github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,8,opt,name=ResolveAnnotations,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"resolve_annotations,omitempty"`
	// SystemAnnotations is a set of programmatically generated annotations attached
	// to pending access requests by teleport.  These annotations are generated by
	// applying variable interpolation to the RoleConditions.Request.Annotations block
	// of a user's role(s).  These annotations serve as a mechanism for administrators
	// to pass extra information to plugins when they process pending access requests.
	SystemAnnotations github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,9,opt,name=SystemAnnotations,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"system_annotations,omitempty"`
	// Thresholds is a list of review thresholds relevant to this request.  Order must be
	// preserved, as thresholds are referenced by index (internal use only).
	Thresholds []AccessReviewThreshold `protobuf:"bytes,10,rep,name=Thresholds,proto3" json:"thresholds,omitempty"`
	// RoleThresholdMapping encodes the relationship between the requested roles and
	// the review threshold requirements for the given role (internal use only).
	// By storing a representation of which thresholds must pass for each requested role, we
	// both eliminate the need to cache the requestor's roles directly, and allow future
	// versions of teleport to become smarter about calculating more granular requirements
	// in a backwards-compatible manner (i.e. calculation can become smarter in minor releases).
	// Storing this relationship on the request is necessary in order to avoid unexpected or
	// inconsistent behavior due to review submission timing.
	RoleThresholdMapping map[string]ThresholdIndexSets `protobuf:"bytes,11,rep,name=RoleThresholdMapping,proto3" json:"rtm,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Reviews is a list of reviews applied to this request (internal use only).
	Reviews []AccessReview `protobuf:"bytes,12,rep,name=Reviews,proto3" json:"reviews,omitempty"`
	// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
	// that is not a requirement.
	SuggestedReviewers []string `protobuf:"bytes,13,rep,name=SuggestedReviewers,proto3" json:"suggested_reviewers,omitempty"`
	// RequestedResourceIDs is a set of resources to which access is being requested.
	RequestedResourceIDs []ResourceID `protobuf:"bytes,14,rep,name=RequestedResourceIDs,proto3" json:"resource_ids,omitempty"`
	// LoginHint is used as a hint for search-based access requests to select
	// roles based on the login the user is attempting.
	LoginHint string `protobuf:"bytes,15,opt,name=LoginHint,proto3" json:"login_hint,omitempty"`
	// DryRun indicates that the request should not actually be created, the
	// auth server should only validate the access request.
	DryRun bool `protobuf:"varint,16,opt,name=DryRun,proto3" json:"dry_run,omitempty"`
	// MaxDuration indicates how long the access should be granted for.
	MaxDuration time.Time `protobuf:"bytes,17,opt,name=MaxDuration,proto3,stdtime" json:"max_duration,omitempty"`
	// SessionTLL indicated how long a certificate for a session should be valid for.
	SessionTTL time.Time `protobuf:"bytes,18,opt,name=SessionTTL,proto3,stdtime" json:"session_ttl,omitempty"`
	// PromotedAccessListTitle is the title of the access list that this request
	// was promoted to. Used by WebUI to display the title of the access list.
	// This field is only populated when the request is in the PROMOTED state.
	AccessList *PromotedAccessList `protobuf:"bytes,20,opt,name=accessList,proto3" json:"access_list,omitempty"`
	// AssumeStartTime is the time the requested roles can be assumed.
	AssumeStartTime      *time.Time `protobuf:"bytes,21,opt,name=AssumeStartTime,proto3,stdtime" json:"assume_start_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AccessRequestSpecV3) Reset()         { *m = AccessRequestSpecV3{} }
func (m *AccessRequestSpecV3) String() string { return proto.CompactTextString(m) }
func (*AccessRequestSpecV3) ProtoMessage()    {}
func (*AccessRequestSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{102}
}
func (m *AccessRequestSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestSpecV3.Merge(m, src)
}
func (m *AccessRequestSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestSpecV3 proto.InternalMessageInfo

// AccessRequestFilter encodes filter params for access requests.
type AccessRequestFilter struct {
	// ID specifies a request ID if set.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"id,omitempty"`
	// User specifies a username if set.
	User string `protobuf:"bytes,2,opt,name=User,proto3" json:"user,omitempty"`
	// RequestState filters for requests in a specific state.
	State RequestState `protobuf:"varint,3,opt,name=State,proto3,enum=types.RequestState" json:"state,omitempty"`
	// SearchKeywords is a list of search keywords to match against resource field values.
	// The matcher goes through select field values from a resource
	// and tries to match against the list of search values, ignoring case and order.
	// Returns true if all search vals were matched (or if nil search vals).
	// Returns false if no or partial match (or nil field values).
	SearchKeywords []string `protobuf:"bytes,4,rep,name=SearchKeywords,proto3" json:"search,omitempty"`
	// Scope is an aditional filter to view requests based on needs review, reviewed, my requests
	Scope AccessRequestScope `protobuf:"varint,5,opt,name=Scope,proto3,enum=types.AccessRequestScope" json:"scope,omitempty"`
	// Requester is the requester of the api call. This is set by the auth server
	// Use User for the requester of the request.
	Requester            string   `protobuf:"bytes,6,opt,name=Requester,proto3" json:"requester,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessRequestFilter) Reset()         { *m = AccessRequestFilter{} }
func (m *AccessRequestFilter) String() string { return proto.CompactTextString(m) }
func (*AccessRequestFilter) ProtoMessage()    {}
func (*AccessRequestFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{103}
}
func (m *AccessRequestFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestFilter.Merge(m, src)
}
func (m *AccessRequestFilter) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestFilter.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestFilter proto.InternalMessageInfo

// AccessCapabilities is a summary of capabilities that a user
// is granted via their dynamic access privileges which may not be
// calculable by directly examining the user's own static roles.
type AccessCapabilities struct {
	// RequestableRoles is a list of existent roles which the user is allowed to request.
	RequestableRoles []string `protobuf:"bytes,1,rep,name=RequestableRoles,proto3" json:"requestable_roles,omitempty"`
	// SuggestedReviewers is a list of all reviewers which are suggested by the user's roles.
	SuggestedReviewers []string `protobuf:"bytes,2,rep,name=SuggestedReviewers,proto3" json:"suggested_reviewers,omitempty"`
	// ApplicableRolesForResources is a list of the roles applicable for access to a given set of resources.
	ApplicableRolesForResources []string `protobuf:"bytes,3,rep,name=ApplicableRolesForResources,proto3" json:"applicable_roles,omitempty"`
	// RequestPrompt is an optional message which tells users what they aught to request.
	RequestPrompt string `protobuf:"bytes,4,opt,name=RequestPrompt,proto3" json:"request_prompt,omitempty"`
	// RequireReason indicates whether the request strategy is one that requires
	// users to always supply reasons with their requests.
	RequireReason bool `protobuf:"varint,5,opt,name=RequireReason,proto3" json:"require_reason,omitempty"`
	// AutoRequest indicates whether the request strategy indicates that a
	// request should be automatically generated on login.
	AutoRequest          bool     `protobuf:"varint,6,opt,name=AutoRequest,proto3" json:"auto_request,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessCapabilities) Reset()         { *m = AccessCapabilities{} }
func (m *AccessCapabilities) String() string { return proto.CompactTextString(m) }
func (*AccessCapabilities) ProtoMessage()    {}
func (*AccessCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{104}
}
func (m *AccessCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessCapabilities.Merge(m, src)
}
func (m *AccessCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *AccessCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_AccessCapabilities proto.InternalMessageInfo

// AccessCapabilitiesRequest encodes parameters for the GetAccessCapabilities method.
type AccessCapabilitiesRequest struct {
	// User is the name of the user whose capabilities we are interested in (defaults to
	// the caller's own username).
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user,omitempty"`
	// RequestableRoles is a flag indicating that we would like to view the list of roles
	// that the user is able to request.
	RequestableRoles bool `protobuf:"varint,2,opt,name=RequestableRoles,proto3" json:"requestable_roles,omitempty"`
	// SuggestedReviewers is a flag indicating that we would like to view the list of all
	// reviewers which are suggested by the user's roles.
	SuggestedReviewers bool `protobuf:"varint,3,opt,name=SuggestedReviewers,proto3" json:"suggested_reviewers,omitempty"`
	// ResourceIDs is the list of the ResourceIDs of the resources we would like to view
	// the necessary roles for.
	ResourceIDs []ResourceID `protobuf:"bytes,4,rep,name=ResourceIDs,proto3" json:"resource_ids,omitempty"`
	// Login is the host login the user is requesting access for.
	Login string `protobuf:"bytes,5,opt,name=Login,proto3" json:"login,omitempty"`
	// FilterRequestableRolesByResource is a flag indicating that the returned
	// list of roles that the user can request should be filtered to only include
	// roles that allow access to the provided ResourceIDs.
	FilterRequestableRolesByResource bool     `protobuf:"varint,6,opt,name=FilterRequestableRolesByResource,proto3" json:"filter_requestable_roles_by_resource,omitempty"`
	XXX_NoUnkeyedLiteral             struct{} `json:"-"`
	XXX_unrecognized                 []byte   `json:"-"`
	XXX_sizecache                    int32    `json:"-"`
}

func (m *AccessCapabilitiesRequest) Reset()         { *m = AccessCapabilitiesRequest{} }
func (m *AccessCapabilitiesRequest) String() string { return proto.CompactTextString(m) }
func (*AccessCapabilitiesRequest) ProtoMessage()    {}
func (*AccessCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{105}
}
func (m *AccessCapabilitiesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessCapabilitiesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessCapabilitiesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessCapabilitiesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessCapabilitiesRequest.Merge(m, src)
}
func (m *AccessCapabilitiesRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccessCapabilitiesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessCapabilitiesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccessCapabilitiesRequest proto.InternalMessageInfo

// ResourceID is a unique identifier for a teleport resource.
type ResourceID struct {
	// ClusterName is the name of the cluster the resource is in.
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"cluster"`
	// Kind is the resource kind.
	Kind string `protobuf:"bytes,2,opt,name=Kind,proto3" json:"kind"`
	// Name is the name of the specific resource.
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name"`
	// SubResourceName is the resource belonging to resource identified by "Name"
	// that the user is allowed to access to.
	// When granting access to a subresource, access to other resources is limited.
	// Currently it just supports resources of Kind=pod and the format is the following
	// "<kube_namespace>/<kube_pod>".
	SubResourceName      string   `protobuf:"bytes,4,opt,name=SubResourceName,proto3" json:"sub_resource,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceID) Reset()         { *m = ResourceID{} }
func (m *ResourceID) String() string { return proto.CompactTextString(m) }
func (*ResourceID) ProtoMessage()    {}
func (*ResourceID) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{106}
}
func (m *ResourceID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceID.Merge(m, src)
}
func (m *ResourceID) XXX_Size() int {
	return m.Size()
}
func (m *ResourceID) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceID.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceID proto.InternalMessageInfo

// PluginData stores a collection of values associated with a specific resource.
type PluginDataV3 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is PluginData metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a PluginData specification
	Spec                 PluginDataSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PluginDataV3) Reset()      { *m = PluginDataV3{} }
func (*PluginDataV3) ProtoMessage() {}
func (*PluginDataV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{107}
}
func (m *PluginDataV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginDataV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginDataV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginDataV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginDataV3.Merge(m, src)
}
func (m *PluginDataV3) XXX_Size() int {
	return m.Size()
}
func (m *PluginDataV3) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginDataV3.DiscardUnknown(m)
}

var xxx_messageInfo_PluginDataV3 proto.InternalMessageInfo

// PluginDataEntry wraps a mapping of arbitrary string values used by
// plugins to store per-resource information.
type PluginDataEntry struct {
	// Data is a mapping of arbitrary string values.
	Data                 map[string]string `protobuf:"bytes,1,rep,name=Data,proto3" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PluginDataEntry) Reset()         { *m = PluginDataEntry{} }
func (m *PluginDataEntry) String() string { return proto.CompactTextString(m) }
func (*PluginDataEntry) ProtoMessage()    {}
func (*PluginDataEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{108}
}
func (m *PluginDataEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginDataEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginDataEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginDataEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginDataEntry.Merge(m, src)
}
func (m *PluginDataEntry) XXX_Size() int {
	return m.Size()
}
func (m *PluginDataEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginDataEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PluginDataEntry proto.InternalMessageInfo

// PluginData stores a collection of values associated with a specific resource.
type PluginDataSpecV3 struct {
	// Entries is a collection of PluginData values organized by plugin name.
	Entries              map[string]*PluginDataEntry `protobuf:"bytes,1,rep,name=Entries,proto3" json:"entries" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PluginDataSpecV3) Reset()         { *m = PluginDataSpecV3{} }
func (m *PluginDataSpecV3) String() string { return proto.CompactTextString(m) }
func (*PluginDataSpecV3) ProtoMessage()    {}
func (*PluginDataSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{109}
}
func (m *PluginDataSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginDataSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginDataSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginDataSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginDataSpecV3.Merge(m, src)
}
func (m *PluginDataSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *PluginDataSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginDataSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_PluginDataSpecV3 proto.InternalMessageInfo

// PluginDataFilter encodes filter params for plugin data.
type PluginDataFilter struct {
	// Kind is the kind of resource that the target plugin data
	// is associated with.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind,omitempty"`
	// Resource matches a specific resource name if set.
	Resource string `protobuf:"bytes,2,opt,name=Resource,proto3" json:"resource,omitempty"`
	// Plugin matches a specific plugin name if set.
	Plugin               string   `protobuf:"bytes,3,opt,name=Plugin,proto3" json:"plugin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginDataFilter) Reset()         { *m = PluginDataFilter{} }
func (m *PluginDataFilter) String() string { return proto.CompactTextString(m) }
func (*PluginDataFilter) ProtoMessage()    {}
func (*PluginDataFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{110}
}
func (m *PluginDataFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginDataFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginDataFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginDataFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginDataFilter.Merge(m, src)
}
func (m *PluginDataFilter) XXX_Size() int {
	return m.Size()
}
func (m *PluginDataFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginDataFilter.DiscardUnknown(m)
}

var xxx_messageInfo_PluginDataFilter proto.InternalMessageInfo

// PluginDataUpdateParams encodes parameters for updating a PluginData field.
type PluginDataUpdateParams struct {
	// Kind is the kind of resource that the target plugin data
	// is associated with.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// Resource indicates the name of the target resource.
	Resource string `protobuf:"bytes,2,opt,name=Resource,proto3" json:"resource"`
	// Plugin is the name of the plugin that owns the data.
	Plugin string `protobuf:"bytes,3,opt,name=Plugin,proto3" json:"plugin"`
	// Set indicates the fields which should be set by this operation.
	Set map[string]string `protobuf:"bytes,4,rep,name=Set,proto3" json:"set,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Expect optionally indicates the expected state of fields prior to this update.
	Expect               map[string]string `protobuf:"bytes,5,rep,name=Expect,proto3" json:"expect,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PluginDataUpdateParams) Reset()         { *m = PluginDataUpdateParams{} }
func (m *PluginDataUpdateParams) String() string { return proto.CompactTextString(m) }
func (*PluginDataUpdateParams) ProtoMessage()    {}
func (*PluginDataUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{111}
}
func (m *PluginDataUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginDataUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginDataUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginDataUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginDataUpdateParams.Merge(m, src)
}
func (m *PluginDataUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *PluginDataUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginDataUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_PluginDataUpdateParams proto.InternalMessageInfo

// RoleFilter matches role resources.
type RoleFilter struct {
	// SearchKeywords is a list of search keywords to match against resource field values.
	SearchKeywords []string `protobuf:"bytes,1,rep,name=SearchKeywords,proto3" json:"search_keywords,omitempty"`
	// SkipSystemRoles filters out teleport system roles from the results.
	SkipSystemRoles      bool     `protobuf:"varint,2,opt,name=SkipSystemRoles,proto3" json:"skip_system_roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoleFilter) Reset()         { *m = RoleFilter{} }
func (m *RoleFilter) String() string { return proto.CompactTextString(m) }
func (*RoleFilter) ProtoMessage()    {}
func (*RoleFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{112}
}
func (m *RoleFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleFilter.Merge(m, src)
}
func (m *RoleFilter) XXX_Size() int {
	return m.Size()
}
func (m *RoleFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleFilter.DiscardUnknown(m)
}

var xxx_messageInfo_RoleFilter proto.InternalMessageInfo

// RoleV6 represents role resource specification
type RoleV6 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v3`, `v4`, `v5`, `v6`, `v7`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a role specification
	Spec                 RoleSpecV6 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RoleV6) Reset()      { *m = RoleV6{} }
func (*RoleV6) ProtoMessage() {}
func (*RoleV6) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{113}
}
func (m *RoleV6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleV6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleV6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleV6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleV6.Merge(m, src)
}
func (m *RoleV6) XXX_Size() int {
	return m.Size()
}
func (m *RoleV6) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleV6.DiscardUnknown(m)
}

var xxx_messageInfo_RoleV6 proto.InternalMessageInfo

// RoleSpecV6 is role specification for RoleV6.
type RoleSpecV6 struct {
	// Options is for OpenSSH options like agent forwarding.
	Options RoleOptions `protobuf:"bytes,1,opt,name=Options,proto3" json:"options,omitempty"`
	// Allow is the set of conditions evaluated to grant access.
	Allow RoleConditions `protobuf:"bytes,2,opt,name=Allow,proto3" json:"allow,omitempty"`
	// Deny is the set of conditions evaluated to deny access. Deny takes priority
	// over allow.
	Deny                 RoleConditions `protobuf:"bytes,3,opt,name=Deny,proto3" json:"deny,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RoleSpecV6) Reset()         { *m = RoleSpecV6{} }
func (m *RoleSpecV6) String() string { return proto.CompactTextString(m) }
func (*RoleSpecV6) ProtoMessage()    {}
func (*RoleSpecV6) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{114}
}
func (m *RoleSpecV6) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleSpecV6) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleSpecV6.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleSpecV6) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleSpecV6.Merge(m, src)
}
func (m *RoleSpecV6) XXX_Size() int {
	return m.Size()
}
func (m *RoleSpecV6) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleSpecV6.DiscardUnknown(m)
}

var xxx_messageInfo_RoleSpecV6 proto.InternalMessageInfo

// RoleOptions is a set of role options
type RoleOptions struct {
	// ForwardAgent is SSH agent forwarding.
	ForwardAgent Bool `protobuf:"varint,1,opt,name=ForwardAgent,proto3,casttype=Bool" json:"forward_agent"`
	// MaxSessionTTL defines how long a SSH session can last for.
	MaxSessionTTL Duration `protobuf:"varint,2,opt,name=MaxSessionTTL,proto3,casttype=Duration" json:"max_session_ttl,omitempty"`
	// PortForwarding defines if the certificate will have
	// "permit-port-forwarding"
	// in the certificate. PortForwarding is "yes" if not set,
	// that's why this is a pointer
	PortForwarding *BoolOption `protobuf:"bytes,3,opt,name=PortForwarding,proto3,customtype=BoolOption" json:"port_forwarding,omitempty"`
	// CertificateFormat defines the format of the user certificate to allow
	// compatibility with older versions of OpenSSH.
	CertificateFormat string `protobuf:"bytes,4,opt,name=CertificateFormat,proto3" json:"cert_format"`
	// ClientIdleTimeout sets disconnect clients on idle timeout behavior,
	// if set to 0 means do not disconnect, otherwise is set to the idle
	// duration.
	ClientIdleTimeout Duration `protobuf:"varint,5,opt,name=ClientIdleTimeout,proto3,casttype=Duration" json:"client_idle_timeout,omitempty"`
	// DisconnectExpiredCert sets disconnect clients on expired certificates.
	DisconnectExpiredCert Bool `protobuf:"varint,6,opt,name=DisconnectExpiredCert,proto3,casttype=Bool" json:"disconnect_expired_cert,omitempty"`
	// BPF defines what events to record for the BPF-based session recorder.
	BPF []string `protobuf:"bytes,7,rep,name=BPF,proto3" json:"enhanced_recording,omitempty"`
	// PermitX11Forwarding authorizes use of X11 forwarding.
	PermitX11Forwarding Bool `protobuf:"varint,8,opt,name=PermitX11Forwarding,proto3,casttype=Bool" json:"permit_x11_forwarding,omitempty"`
	// MaxConnections defines the maximum number of
	// concurrent connections a user may hold.
	MaxConnections int64 `protobuf:"varint,9,opt,name=MaxConnections,proto3" json:"max_connections,omitempty"`
	// MaxSessions defines the maximum number of
	// concurrent sessions per connection.
	MaxSessions int64 `protobuf:"varint,10,opt,name=MaxSessions,proto3" json:"max_sessions,omitempty"`
	// RequestAccess defines the request strategy (optional|note|always)
	// where optional is the default.
	RequestAccess RequestStrategy `protobuf:"bytes,11,opt,name=RequestAccess,proto3,casttype=RequestStrategy" json:"request_access,omitempty"`
	// RequestPrompt is an optional message which tells users what they aught to request.
	RequestPrompt string `protobuf:"bytes,12,opt,name=RequestPrompt,proto3" json:"request_prompt,omitempty"`
	// Lock specifies the locking mode (strict|best_effort) to be applied with
	// the role.
	Lock github_com_gravitational_teleport_api_constants.LockingMode `protobuf:"bytes,14,opt,name=Lock,proto3,casttype=github.com/gravitational/teleport/api/constants.LockingMode" json:"lock,omitempty"`
	// RecordDesktopSession indicates whether desktop access sessions should be recorded.
	// It defaults to true unless explicitly set to false.
	RecordSession *RecordSession `protobuf:"bytes,15,opt,name=RecordSession,proto3" json:"record_session"`
	// DesktopClipboard indicates whether clipboard sharing is allowed between the user's
	// workstation and the remote desktop. It defaults to true unless explicitly set to
	// false.
	DesktopClipboard *BoolOption `protobuf:"bytes,16,opt,name=DesktopClipboard,proto3,customtype=BoolOption" json:"desktop_clipboard"`
	// CertExtensions specifies the key/values
	CertExtensions []*CertExtension `protobuf:"bytes,17,rep,name=CertExtensions,proto3" json:"cert_extensions,omitempty"`
	// MaxKubernetesConnections defines the maximum number of concurrent
	// Kubernetes sessions a user may hold.
	MaxKubernetesConnections int64 `protobuf:"varint,18,opt,name=MaxKubernetesConnections,proto3" json:"max_kubernetes_connections,omitempty"`
	// DesktopDirectorySharing indicates whether directory sharing is allowed between the user's
	// workstation and the remote desktop. It defaults to false unless explicitly set to
	// true.
	DesktopDirectorySharing *BoolOption `protobuf:"bytes,19,opt,name=DesktopDirectorySharing,proto3,customtype=BoolOption" json:"desktop_directory_sharing"`
	// CreateHostUser allows users to be automatically created on a host
	CreateHostUser *BoolOption `protobuf:"bytes,20,opt,name=CreateHostUser,proto3,customtype=BoolOption" json:"create_host_user,omitempty"`
	// PinSourceIP forces the same client IP for certificate generation and usage
	PinSourceIP Bool `protobuf:"varint,21,opt,name=PinSourceIP,proto3,casttype=Bool" json:"pin_source_ip"`
	// SSHFileCopy indicates whether remote file operations via SCP or SFTP are allowed
	// over an SSH session. It defaults to true unless explicitly set to false.
	SSHFileCopy *BoolOption `protobuf:"bytes,22,opt,name=SSHFileCopy,proto3,customtype=BoolOption" json:"ssh_file_copy"`
	// RequireMFAType is the type of MFA requirement enforced for this user.
	// 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
	// 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
	RequireMFAType RequireMFAType `protobuf:"varint,23,opt,name=RequireMFAType,proto3,enum=types.RequireMFAType" json:"require_session_mfa,omitempty"`
	// DeviceTrustMode is the device authorization mode used for the resources
	// associated with the role.
	// See DeviceTrust.Mode.
	DeviceTrustMode string `protobuf:"bytes,24,opt,name=DeviceTrustMode,proto3" json:"device_trust_mode,omitempty"`
	// IDP is a set of options related to accessing IdPs within Teleport.
	// Requires Teleport Enterprise.
	IDP *IdPOptions `protobuf:"bytes,25,opt,name=IDP,proto3" json:"idp,omitempty"`
	// CreateDesktopUser allows users to be automatically created on a Windows desktop
	CreateDesktopUser *BoolOption `protobuf:"bytes,26,opt,name=CreateDesktopUser,proto3,customtype=BoolOption" json:"create_desktop_user"`
	// CreateDatabaseUser enabled automatic database user creation.
	CreateDatabaseUser *BoolOption `protobuf:"bytes,27,opt,name=CreateDatabaseUser,proto3,customtype=BoolOption" json:"create_db_user"`
	// CreateHostUserMode allows users to be automatically created on a
	// host when not set to off.
	// 0 is "unspecified"; 1 is "off"; 2 is "drop" (removed for v15 and above),
	// 3 is "keep"; 4 is "insecure-drop".
	CreateHostUserMode CreateHostUserMode `protobuf:"varint,28,opt,name=CreateHostUserMode,proto3,enum=types.CreateHostUserMode" json:"create_host_user_mode,omitempty"`
	// CreateDatabaseUserMode allows users to be automatically created on a
	// database when not set to off.
	// 0 is "unspecified", 1 is "off", 2 is "keep", 3 is "best_effort_drop".
	CreateDatabaseUserMode CreateDatabaseUserMode `protobuf:"varint,29,opt,name=CreateDatabaseUserMode,proto3,enum=types.CreateDatabaseUserMode" json:"create_db_user_mode,omitempty"`
	// MFAVerificationInterval optionally defines the maximum duration that can elapse
	// between successive MFA verifications. This variable is used to ensure
	// that users are periodically prompted to verify their identity, enhancing
	// security by preventing prolonged sessions without re-authentication when using
	// tsh proxy * derivatives.
	// It's only effective if the session requires MFA.
	// If not set, defaults to `max_session_ttl`.
	MFAVerificationInterval time.Duration `protobuf:"bytes,30,opt,name=MFAVerificationInterval,proto3,stdduration" json:"mfa_verification_interval,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}      `json:"-"`
	XXX_unrecognized        []byte        `json:"-"`
	XXX_sizecache           int32         `json:"-"`
}

func (m *RoleOptions) Reset()         { *m = RoleOptions{} }
func (m *RoleOptions) String() string { return proto.CompactTextString(m) }
func (*RoleOptions) ProtoMessage()    {}
func (*RoleOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{115}
}
func (m *RoleOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleOptions.Merge(m, src)
}
func (m *RoleOptions) XXX_Size() int {
	return m.Size()
}
func (m *RoleOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RoleOptions proto.InternalMessageInfo

type RecordSession struct {
	// Desktop indicates whether desktop sessions should be recorded.
	// It defaults to true unless explicitly set to false.
	Desktop *BoolOption `protobuf:"bytes,1,opt,name=Desktop,proto3,customtype=BoolOption" json:"desktop"`
	// Default indicates the default value for the services.
	Default github_com_gravitational_teleport_api_constants.SessionRecordingMode `protobuf:"bytes,2,opt,name=Default,proto3,casttype=github.com/gravitational/teleport/api/constants.SessionRecordingMode" json:"default,omitempty"`
	// SSH indicates the session mode used on SSH sessions.
	SSH                  github_com_gravitational_teleport_api_constants.SessionRecordingMode `protobuf:"bytes,3,opt,name=SSH,proto3,casttype=github.com/gravitational/teleport/api/constants.SessionRecordingMode" json:"ssh,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                             `json:"-"`
	XXX_unrecognized     []byte                                                               `json:"-"`
	XXX_sizecache        int32                                                                `json:"-"`
}

func (m *RecordSession) Reset()         { *m = RecordSession{} }
func (m *RecordSession) String() string { return proto.CompactTextString(m) }
func (*RecordSession) ProtoMessage()    {}
func (*RecordSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{116}
}
func (m *RecordSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordSession.Merge(m, src)
}
func (m *RecordSession) XXX_Size() int {
	return m.Size()
}
func (m *RecordSession) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordSession.DiscardUnknown(m)
}

var xxx_messageInfo_RecordSession proto.InternalMessageInfo

// CertExtension represents a key/value for a certificate extension
type CertExtension struct {
	// Type represents the certificate type being extended, only ssh
	// is supported at this time.
	// 0 is "ssh".
	Type CertExtensionType `protobuf:"varint,1,opt,name=Type,proto3,enum=types.CertExtensionType" json:"type"`
	// Mode is the type of extension to be used -- currently
	// critical-option is not supported.
	// 0 is "extension".
	Mode CertExtensionMode `protobuf:"varint,2,opt,name=Mode,proto3,enum=types.CertExtensionMode" json:"mode"`
	// Name specifies the key to be used in the cert extension.
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name"`
	// Value specifies the value to be used in the cert extension.
	Value                string   `protobuf:"bytes,4,opt,name=Value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CertExtension) Reset()         { *m = CertExtension{} }
func (m *CertExtension) String() string { return proto.CompactTextString(m) }
func (*CertExtension) ProtoMessage()    {}
func (*CertExtension) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{117}
}
func (m *CertExtension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertExtension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertExtension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertExtension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertExtension.Merge(m, src)
}
func (m *CertExtension) XXX_Size() int {
	return m.Size()
}
func (m *CertExtension) XXX_DiscardUnknown() {
	xxx_messageInfo_CertExtension.DiscardUnknown(m)
}

var xxx_messageInfo_CertExtension proto.InternalMessageInfo

// RoleConditions is a set of conditions that must all match to be allowed or
// denied access.
type RoleConditions struct {
	// Logins is a list of *nix system logins.
	Logins []string `protobuf:"bytes,1,rep,name=Logins,proto3" json:"logins,omitempty"`
	// Namespaces is a list of namespaces (used to partition a cluster). The
	// field should be called "namespaces" when it returns in Teleport 2.4.
	Namespaces []string `protobuf:"bytes,2,rep,name=Namespaces,proto3" json:"-"`
	// NodeLabels is a map of node labels (used to dynamically grant access to
	// nodes).
	NodeLabels Labels `protobuf:"bytes,3,opt,name=NodeLabels,proto3,customtype=Labels" json:"node_labels,omitempty"`
	// Rules is a list of rules and their access levels. Rules are a high level
	// construct used for access control.
	Rules []Rule `protobuf:"bytes,4,rep,name=Rules,proto3" json:"rules,omitempty"`
	// KubeGroups is a list of kubernetes groups
	KubeGroups []string                 `protobuf:"bytes,5,rep,name=KubeGroups,proto3" json:"kubernetes_groups,omitempty"`
	Request    *AccessRequestConditions `protobuf:"bytes,6,opt,name=Request,proto3" json:"request,omitempty"`
	// KubeUsers is an optional kubernetes users to impersonate
	KubeUsers []string `protobuf:"bytes,7,rep,name=KubeUsers,proto3" json:"kubernetes_users,omitempty"`
	// AppLabels is a map of labels used as part of the RBAC system.
	AppLabels Labels `protobuf:"bytes,8,opt,name=AppLabels,proto3,customtype=Labels" json:"app_labels,omitempty"`
	// ClusterLabels is a map of node labels (used to dynamically grant access to
	// clusters).
	ClusterLabels Labels `protobuf:"bytes,9,opt,name=ClusterLabels,proto3,customtype=Labels" json:"cluster_labels,omitempty"`
	// KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
	KubernetesLabels Labels `protobuf:"bytes,10,opt,name=KubernetesLabels,proto3,customtype=Labels" json:"kubernetes_labels,omitempty"`
	// DatabaseLabels are used in RBAC system to allow/deny access to databases.
	DatabaseLabels Labels `protobuf:"bytes,11,opt,name=DatabaseLabels,proto3,customtype=Labels" json:"db_labels,omitempty"`
	// DatabaseNames is a list of database names this role is allowed to connect to.
	DatabaseNames []string `protobuf:"bytes,12,rep,name=DatabaseNames,proto3" json:"db_names,omitempty"`
	// DatabaseUsers is a list of databases users this role is allowed to connect as.
	DatabaseUsers []string `protobuf:"bytes,13,rep,name=DatabaseUsers,proto3" json:"db_users,omitempty"`
	// Impersonate specifies what users and roles this role is allowed to impersonate
	// by issuing certificates or other possible means.
	Impersonate *ImpersonateConditions `protobuf:"bytes,14,opt,name=Impersonate,proto3" json:"impersonate,omitempty"`
	// ReviewRequests defines conditions for submitting access reviews.
	ReviewRequests *AccessReviewConditions `protobuf:"bytes,15,opt,name=ReviewRequests,proto3" json:"review_requests,omitempty"`
	// AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
	AWSRoleARNs []string `protobuf:"bytes,16,rep,name=AWSRoleARNs,proto3" json:"aws_role_arns,omitempty"`
	// WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
	WindowsDesktopLogins []string `protobuf:"bytes,17,rep,name=WindowsDesktopLogins,proto3" json:"windows_desktop_logins,omitempty"`
	// WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
	WindowsDesktopLabels Labels `protobuf:"bytes,18,opt,name=WindowsDesktopLabels,proto3,customtype=Labels" json:"windows_desktop_labels,omitempty"`
	// RequireSessionJoin specifies policies for required users to start a session.
	RequireSessionJoin []*SessionRequirePolicy `protobuf:"bytes,19,rep,name=RequireSessionJoin,proto3" json:"require_session_join,omitempty"`
	// JoinSessions specifies policies to allow users to join other sessions.
	JoinSessions []*SessionJoinPolicy `protobuf:"bytes,20,rep,name=JoinSessions,proto3" json:"join_sessions,omitempty"`
	// HostGroups is a list of groups for created users to be added to
	HostGroups []string `protobuf:"bytes,21,rep,name=HostGroups,proto3" json:"host_groups,omitempty"`
	// HostSudoers is a list of entries to include in a users sudoer file
	HostSudoers []string `protobuf:"bytes,22,rep,name=HostSudoers,proto3" json:"host_sudoers,omitempty"`
	// AzureIdentities is a list of Azure identities this role is allowed to assume.
	AzureIdentities []string `protobuf:"bytes,23,rep,name=AzureIdentities,proto3" json:"azure_identities,omitempty"`
	// KubernetesResources is the Kubernetes Resources this Role grants access to.
	KubernetesResources []KubernetesResource `protobuf:"bytes,24,rep,name=KubernetesResources,proto3" json:"kubernetes_resources,omitempty"`
	// GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
	GCPServiceAccounts []string `protobuf:"bytes,25,rep,name=GCPServiceAccounts,proto3" json:"gcp_service_accounts,omitempty"`
	// DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
	DatabaseServiceLabels Labels `protobuf:"bytes,26,opt,name=DatabaseServiceLabels,proto3,customtype=Labels" json:"db_service_labels,omitempty"`
	// GroupLabels is a map of labels used as part of the RBAC system.
	GroupLabels Labels `protobuf:"bytes,27,opt,name=GroupLabels,proto3,customtype=Labels" json:"group_labels,omitempty"`
	// DesktopGroups is a list of groups for created desktop users to be added to
	DesktopGroups []string `protobuf:"bytes,28,rep,name=DesktopGroups,proto3" json:"desktop_groups,omitempty"`
	// DatabaseRoles is a list of databases roles for automatic user creation.
	DatabaseRoles []string `protobuf:"bytes,29,rep,name=DatabaseRoles,proto3" json:"db_roles,omitempty"`
	// NodeLabelsExpression is a predicate expression used to allow/deny access to
	// SSH nodes.
	NodeLabelsExpression string `protobuf:"bytes,30,opt,name=NodeLabelsExpression,proto3" json:"node_labels_expression,omitempty"`
	// AppLabelsExpression is a predicate expression used to allow/deny access to
	// Apps.
	AppLabelsExpression string `protobuf:"bytes,31,opt,name=AppLabelsExpression,proto3" json:"app_labels_expression,omitempty"`
	// ClusterLabelsExpression is a predicate expression used to allow/deny access
	// to remote Teleport clusters.
	ClusterLabelsExpression string `protobuf:"bytes,32,opt,name=ClusterLabelsExpression,proto3" json:"cluster_labels_expression,omitempty"`
	// KubernetesLabelsExpression is a predicate expression used to allow/deny
	// access to kubernetes clusters.
	KubernetesLabelsExpression string `protobuf:"bytes,33,opt,name=KubernetesLabelsExpression,proto3" json:"kubernetes_labels_expression,omitempty"`
	// DatabaseLabelsExpression is a predicate expression used to allow/deny
	// access to Databases.
	DatabaseLabelsExpression string `protobuf:"bytes,34,opt,name=DatabaseLabelsExpression,proto3" json:"db_labels_expression,omitempty"`
	// DatabaseServiceLabelsExpression is a predicate expression used to
	// allow/deny access to Database Services.
	DatabaseServiceLabelsExpression string `protobuf:"bytes,35,opt,name=DatabaseServiceLabelsExpression,proto3" json:"db_service_labels_expression,omitempty"`
	// WindowsDesktopLabelsExpression is a predicate expression used to allow/deny
	// access to Windows desktops.
	WindowsDesktopLabelsExpression string `protobuf:"bytes,36,opt,name=WindowsDesktopLabelsExpression,proto3" json:"windows_desktop_labels_expression,omitempty"`
	// GroupLabelsExpression is a predicate expression used to allow/deny
	// access to user groups.
	GroupLabelsExpression string `protobuf:"bytes,37,opt,name=GroupLabelsExpression,proto3" json:"group_labels_expression,omitempty"`
	// DatabasePermissions specifies a set of permissions that will be granted
	// to the database user when using automatic database user provisioning.
	DatabasePermissions []DatabasePermission `protobuf:"bytes,38,rep,name=DatabasePermissions,proto3" json:"db_permissions,omitempty"`
	// SPIFFE is used to allow or deny access to a role holder to generating a
	// SPIFFE SVID.
	SPIFFE               []*SPIFFERoleCondition `protobuf:"bytes,39,rep,name=SPIFFE,proto3" json:"spiffe,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *RoleConditions) Reset()         { *m = RoleConditions{} }
func (m *RoleConditions) String() string { return proto.CompactTextString(m) }
func (*RoleConditions) ProtoMessage()    {}
func (*RoleConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{118}
}
func (m *RoleConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleConditions.Merge(m, src)
}
func (m *RoleConditions) XXX_Size() int {
	return m.Size()
}
func (m *RoleConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleConditions.DiscardUnknown(m)
}

var xxx_messageInfo_RoleConditions proto.InternalMessageInfo

// SPIFFERoleCondition sets out which SPIFFE identities this role is allowed or
// denied to generate. The Path matcher is required, and is evaluated first. If,
// the Path does not match then the other matcher fields are not evaluated.
type SPIFFERoleCondition struct {
	// Path specifies a matcher for the SPIFFE ID path. It should not include the
	// trust domain and should start with a leading slash.
	//
	// The matcher by default allows '*' to be used to indicate zero or more of
	// any character. Prepend '^' and append '$' to instead switch to matching
	// using the Go regex syntax.
	//
	// Example:
	// - /svc/foo/*/bar would match /svc/foo/baz/bar
	// - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"path,omitempty"`
	// DNSSANs specifies matchers for the SPIFFE ID DNS SANs.
	//
	// Each requested DNS SAN is compared against all matchers configured and if
	// any match, the condition is considered to be met.
	//
	// The matcher by default allows '*' to be used to indicate zero or more of
	// any character. Prepend '^' and append '$' to instead switch to matching
	// using the Go regex syntax.
	//
	// Example: *.example.com would match foo.example.com
	DNSSANs []string `protobuf:"bytes,2,rep,name=DNSSANs,proto3" json:"dns_sans,omitempty"`
	// IPSANs specifies matchers for the SPIFFE ID IP SANs.
	//
	// Each requested IP SAN is compared against all matchers configured and if
	// any match, the condition is considered to be met.
	//
	// The matchers should be specified using CIDR notation, it supports IPv4 and
	// IPv6.
	//
	// Examples:
	// - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255
	// - 10.0.0.42/32 would match only 10.0.0.42
	IPSANs               []string `protobuf:"bytes,3,rep,name=IPSANs,proto3" json:"ip_sans,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SPIFFERoleCondition) Reset()         { *m = SPIFFERoleCondition{} }
func (m *SPIFFERoleCondition) String() string { return proto.CompactTextString(m) }
func (*SPIFFERoleCondition) ProtoMessage()    {}
func (*SPIFFERoleCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{119}
}
func (m *SPIFFERoleCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SPIFFERoleCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SPIFFERoleCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SPIFFERoleCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SPIFFERoleCondition.Merge(m, src)
}
func (m *SPIFFERoleCondition) XXX_Size() int {
	return m.Size()
}
func (m *SPIFFERoleCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_SPIFFERoleCondition.DiscardUnknown(m)
}

var xxx_messageInfo_SPIFFERoleCondition proto.InternalMessageInfo

// DatabasePermission specifies the database object permission for the user.
type DatabasePermission struct {
	// Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
	Permissions []string `protobuf:"bytes,1,rep,name=Permissions,proto3" json:"permissions"`
	// Match is a list of object labels that must be matched for the permission to be granted.
	Match                Labels   `protobuf:"bytes,2,opt,name=Match,proto3,customtype=Labels" json:"match"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabasePermission) Reset()         { *m = DatabasePermission{} }
func (m *DatabasePermission) String() string { return proto.CompactTextString(m) }
func (*DatabasePermission) ProtoMessage()    {}
func (*DatabasePermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{120}
}
func (m *DatabasePermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabasePermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabasePermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabasePermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabasePermission.Merge(m, src)
}
func (m *DatabasePermission) XXX_Size() int {
	return m.Size()
}
func (m *DatabasePermission) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabasePermission.DiscardUnknown(m)
}

var xxx_messageInfo_DatabasePermission proto.InternalMessageInfo

// KubernetesResource is the Kubernetes resource identifier.
type KubernetesResource struct {
	// Kind specifies the Kubernetes Resource type.
	// At the moment only "pod" is supported.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind,omitempty"`
	// Namespace is the resource namespace.
	// It supports wildcards.
	Namespace string `protobuf:"bytes,2,opt,name=Namespace,proto3" json:"namespace,omitempty"`
	// Name is the resource name.
	// It supports wildcards.
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name,omitempty"`
	// Verbs are the allowed Kubernetes verbs for the following resource.
	Verbs                []string `protobuf:"bytes,4,rep,name=Verbs,proto3" json:"verbs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesResource) Reset()         { *m = KubernetesResource{} }
func (m *KubernetesResource) String() string { return proto.CompactTextString(m) }
func (*KubernetesResource) ProtoMessage()    {}
func (*KubernetesResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{121}
}
func (m *KubernetesResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResource.Merge(m, src)
}
func (m *KubernetesResource) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResource) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResource.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResource proto.InternalMessageInfo

// SessionRequirePolicy a requirement policy that needs to be fulfilled to grant access.
type SessionRequirePolicy struct {
	// Name is the name of the policy.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Filter is a predicate that determines what users count towards this policy.
	Filter string `protobuf:"bytes,2,opt,name=Filter,proto3" json:"filter"`
	// Kinds are the session kinds this policy applies to.
	Kinds []string `protobuf:"bytes,3,rep,name=Kinds,proto3" json:"kinds"`
	// Count is the amount of people that need to be matched for this policy to be fulfilled.
	Count int32 `protobuf:"varint,4,opt,name=Count,proto3" json:"count"`
	// Modes is the list of modes that may be used to fulfill this policy.
	Modes []string `protobuf:"bytes,5,rep,name=Modes,proto3" json:"modes"`
	// OnLeave is the behaviour that's used when the policy is no longer fulfilled
	// for a live session.
	OnLeave              string   `protobuf:"bytes,6,opt,name=OnLeave,proto3" json:"on_leave"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionRequirePolicy) Reset()         { *m = SessionRequirePolicy{} }
func (m *SessionRequirePolicy) String() string { return proto.CompactTextString(m) }
func (*SessionRequirePolicy) ProtoMessage()    {}
func (*SessionRequirePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{122}
}
func (m *SessionRequirePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionRequirePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionRequirePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionRequirePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionRequirePolicy.Merge(m, src)
}
func (m *SessionRequirePolicy) XXX_Size() int {
	return m.Size()
}
func (m *SessionRequirePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionRequirePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_SessionRequirePolicy proto.InternalMessageInfo

// SessionJoinPolicy defines a policy that allows a user to join sessions.
type SessionJoinPolicy struct {
	// Name is the name of the policy.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Roles is a list of roles that you can join the session of.
	Roles []string `protobuf:"bytes,2,rep,name=Roles,proto3" json:"roles"`
	// Kinds are the session kinds this policy applies to.
	Kinds []string `protobuf:"bytes,3,rep,name=Kinds,proto3" json:"kinds"`
	// Modes is a list of permitted participant modes for this policy.
	Modes                []string `protobuf:"bytes,4,rep,name=Modes,proto3" json:"modes"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionJoinPolicy) Reset()         { *m = SessionJoinPolicy{} }
func (m *SessionJoinPolicy) String() string { return proto.CompactTextString(m) }
func (*SessionJoinPolicy) ProtoMessage()    {}
func (*SessionJoinPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{123}
}
func (m *SessionJoinPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionJoinPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionJoinPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionJoinPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionJoinPolicy.Merge(m, src)
}
func (m *SessionJoinPolicy) XXX_Size() int {
	return m.Size()
}
func (m *SessionJoinPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionJoinPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_SessionJoinPolicy proto.InternalMessageInfo

// AccessRequestConditions is a matcher for allow/deny restrictions on
// access-requests.
// Please remember to update IsEmpty when updating this message.
type AccessRequestConditions struct {
	// Roles is the name of roles which will match the request rule.
	Roles []string `protobuf:"bytes,1,rep,name=Roles,proto3" json:"roles,omitempty"`
	// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
	ClaimsToRoles []ClaimMapping `protobuf:"bytes,2,rep,name=ClaimsToRoles,proto3" json:"claims_to_roles,omitempty"`
	// Annotations is a collection of annotations to be programmatically
	// appended to pending access requests at the time of their creation.
	// These annotations serve as a mechanism to propagate extra information
	// to plugins.  Since these annotations support variable interpolation
	// syntax, they also offer a mechanism for forwarding claims from an
	// external identity provider, to a plugin via `{{external.trait_name}}`
	// style substitutions.
	Annotations github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,3,opt,name=Annotations,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"annotations,omitempty"`
	// Thresholds is a list of thresholds, one of which must be met in order for reviews
	// to trigger a state-transition.  If no thresholds are provided, a default threshold
	// of 1 for approval and denial is used.
	Thresholds []AccessReviewThreshold `protobuf:"bytes,4,rep,name=Thresholds,proto3" json:"thresholds,omitempty"`
	// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
	// that is not a requirement.
	SuggestedReviewers []string `protobuf:"bytes,5,rep,name=SuggestedReviewers,proto3" json:"suggested_reviewers,omitempty"`
	// SearchAsRoles is a list of extra roles which should apply to a user while
	// they are searching for resources as part of a Resource Access Request, and
	// defines the underlying roles which will be requested as part of any
	// Resource Access Request.
	SearchAsRoles []string `protobuf:"bytes,6,rep,name=SearchAsRoles,proto3" json:"search_as_roles,omitempty"`
	// MaxDuration is the amount of time the access will be granted for.
	// If this is zero, the default duration is used.
	MaxDuration          Duration `protobuf:"varint,7,opt,name=MaxDuration,proto3,casttype=Duration" json:"max_duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessRequestConditions) Reset()         { *m = AccessRequestConditions{} }
func (m *AccessRequestConditions) String() string { return proto.CompactTextString(m) }
func (*AccessRequestConditions) ProtoMessage()    {}
func (*AccessRequestConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{124}
}
func (m *AccessRequestConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestConditions.Merge(m, src)
}
func (m *AccessRequestConditions) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestConditions.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestConditions proto.InternalMessageInfo

// AccessReviewConditions is a matcher for allow/deny restrictions on
// access reviews.
// Please remember to update IsEmpty when updating this message.
type AccessReviewConditions struct {
	// Roles is the name of roles which may be reviewed.
	Roles []string `protobuf:"bytes,1,rep,name=Roles,proto3" json:"roles,omitempty"`
	// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
	ClaimsToRoles []ClaimMapping `protobuf:"bytes,2,rep,name=ClaimsToRoles,proto3" json:"claims_to_roles,omitempty"`
	// Where is an optional predicate which further limits which requests are
	// reviewable.
	Where string `protobuf:"bytes,3,opt,name=Where,proto3" json:"where,omitempty"`
	// PreviewAsRoles is a list of extra roles which should apply to a reviewer
	// while they are viewing a Resource Access Request for the purposes of
	// viewing details such as the hostname and labels of requested resources.
	PreviewAsRoles       []string `protobuf:"bytes,4,rep,name=PreviewAsRoles,proto3" json:"preview_as_roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessReviewConditions) Reset()         { *m = AccessReviewConditions{} }
func (m *AccessReviewConditions) String() string { return proto.CompactTextString(m) }
func (*AccessReviewConditions) ProtoMessage()    {}
func (*AccessReviewConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{125}
}
func (m *AccessReviewConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessReviewConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessReviewConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessReviewConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessReviewConditions.Merge(m, src)
}
func (m *AccessReviewConditions) XXX_Size() int {
	return m.Size()
}
func (m *AccessReviewConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessReviewConditions.DiscardUnknown(m)
}

var xxx_messageInfo_AccessReviewConditions proto.InternalMessageInfo

// AccessRequestAllowedPromotion describes an allowed promotion to an access list.
type AccessRequestAllowedPromotion struct {
	// associated access list
	AccessListName       string   `protobuf:"bytes,1,opt,name=accessListName,proto3" json:"accessListName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessRequestAllowedPromotion) Reset()         { *m = AccessRequestAllowedPromotion{} }
func (m *AccessRequestAllowedPromotion) String() string { return proto.CompactTextString(m) }
func (*AccessRequestAllowedPromotion) ProtoMessage()    {}
func (*AccessRequestAllowedPromotion) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{126}
}
func (m *AccessRequestAllowedPromotion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestAllowedPromotion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestAllowedPromotion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestAllowedPromotion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestAllowedPromotion.Merge(m, src)
}
func (m *AccessRequestAllowedPromotion) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestAllowedPromotion) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestAllowedPromotion.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestAllowedPromotion proto.InternalMessageInfo

// AccessRequestAllowedPromotions describes an valid promotion from an access request
// to an access list.
type AccessRequestAllowedPromotions struct {
	// suggestions is a list of allowed access lists promotions.
	Promotions           []*AccessRequestAllowedPromotion `protobuf:"bytes,1,rep,name=promotions,proto3" json:"promotions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *AccessRequestAllowedPromotions) Reset()         { *m = AccessRequestAllowedPromotions{} }
func (m *AccessRequestAllowedPromotions) String() string { return proto.CompactTextString(m) }
func (*AccessRequestAllowedPromotions) ProtoMessage()    {}
func (*AccessRequestAllowedPromotions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{127}
}
func (m *AccessRequestAllowedPromotions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestAllowedPromotions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestAllowedPromotions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestAllowedPromotions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestAllowedPromotions.Merge(m, src)
}
func (m *AccessRequestAllowedPromotions) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestAllowedPromotions) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestAllowedPromotions.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestAllowedPromotions proto.InternalMessageInfo

// ClaimMapping maps a claim to teleport roles.
type ClaimMapping struct {
	// Claim is a claim name.
	Claim string `protobuf:"bytes,1,opt,name=Claim,proto3" json:"claim"`
	// Value is a claim value to match.
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
	// Roles is a list of static teleport roles to match.
	Roles                []string `protobuf:"bytes,3,rep,name=Roles,proto3" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClaimMapping) Reset()         { *m = ClaimMapping{} }
func (m *ClaimMapping) String() string { return proto.CompactTextString(m) }
func (*ClaimMapping) ProtoMessage()    {}
func (*ClaimMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{128}
}
func (m *ClaimMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimMapping.Merge(m, src)
}
func (m *ClaimMapping) XXX_Size() int {
	return m.Size()
}
func (m *ClaimMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimMapping.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimMapping proto.InternalMessageInfo

// TraitMapping maps a trait to teleport roles.
type TraitMapping struct {
	// Trait is a trait name.
	Trait string `protobuf:"bytes,1,opt,name=Trait,proto3" json:"trait"`
	// Value is a trait value to match.
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
	// Roles is a list of static teleport roles to match.
	Roles                []string `protobuf:"bytes,3,rep,name=Roles,proto3" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TraitMapping) Reset()         { *m = TraitMapping{} }
func (m *TraitMapping) String() string { return proto.CompactTextString(m) }
func (*TraitMapping) ProtoMessage()    {}
func (*TraitMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{129}
}
func (m *TraitMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraitMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TraitMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TraitMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraitMapping.Merge(m, src)
}
func (m *TraitMapping) XXX_Size() int {
	return m.Size()
}
func (m *TraitMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_TraitMapping.DiscardUnknown(m)
}

var xxx_messageInfo_TraitMapping proto.InternalMessageInfo

// Rule represents allow or deny rule that is executed to check
// if user or service have access to resource
type Rule struct {
	// Resources is a list of resources
	Resources []string `protobuf:"bytes,1,rep,name=Resources,proto3" json:"resources,omitempty"`
	// Verbs is a list of verbs
	Verbs []string `protobuf:"bytes,2,rep,name=Verbs,proto3" json:"verbs,omitempty"`
	// Where specifies optional advanced matcher
	Where string `protobuf:"bytes,3,opt,name=Where,proto3" json:"where,omitempty"`
	// Actions specifies optional actions taken when this rule matches
	Actions              []string `protobuf:"bytes,4,rep,name=Actions,proto3" json:"actions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rule) Reset()         { *m = Rule{} }
func (m *Rule) String() string { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()    {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{130}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

// ImpersonateConditions specifies whether users are allowed
// to issue certificates for other users or groups.
type ImpersonateConditions struct {
	// Users is a list of resources this role is allowed to impersonate,
	// could be an empty list or a Wildcard pattern
	Users []string `protobuf:"bytes,1,rep,name=Users,proto3" json:"users,omitempty"`
	// Roles is a list of resources this role is allowed to impersonate
	Roles []string `protobuf:"bytes,2,rep,name=Roles,proto3" json:"roles,omitempty"`
	// Where specifies optional advanced matcher
	Where                string   `protobuf:"bytes,3,opt,name=Where,proto3" json:"where,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImpersonateConditions) Reset()         { *m = ImpersonateConditions{} }
func (m *ImpersonateConditions) String() string { return proto.CompactTextString(m) }
func (*ImpersonateConditions) ProtoMessage()    {}
func (*ImpersonateConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{131}
}
func (m *ImpersonateConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImpersonateConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImpersonateConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImpersonateConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImpersonateConditions.Merge(m, src)
}
func (m *ImpersonateConditions) XXX_Size() int {
	return m.Size()
}
func (m *ImpersonateConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_ImpersonateConditions.DiscardUnknown(m)
}

var xxx_messageInfo_ImpersonateConditions proto.InternalMessageInfo

// BoolValue is a wrapper around bool, used in cases
// whenever bool value can have different default value when missing
type BoolValue struct {
	Value                bool     `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoolValue) Reset()         { *m = BoolValue{} }
func (m *BoolValue) String() string { return proto.CompactTextString(m) }
func (*BoolValue) ProtoMessage()    {}
func (*BoolValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{132}
}
func (m *BoolValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoolValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoolValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoolValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoolValue.Merge(m, src)
}
func (m *BoolValue) XXX_Size() int {
	return m.Size()
}
func (m *BoolValue) XXX_DiscardUnknown() {
	xxx_messageInfo_BoolValue.DiscardUnknown(m)
}

var xxx_messageInfo_BoolValue proto.InternalMessageInfo

// UserFilter matches user resources.
type UserFilter struct {
	// SearchKeywords is a list of search keywords to match against resource field values.
	SearchKeywords       []string `protobuf:"bytes,1,rep,name=SearchKeywords,proto3" json:"search_keywords,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserFilter) Reset()         { *m = UserFilter{} }
func (m *UserFilter) String() string { return proto.CompactTextString(m) }
func (*UserFilter) ProtoMessage()    {}
func (*UserFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{133}
}
func (m *UserFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserFilter.Merge(m, src)
}
func (m *UserFilter) XXX_Size() int {
	return m.Size()
}
func (m *UserFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_UserFilter.DiscardUnknown(m)
}

var xxx_messageInfo_UserFilter proto.InternalMessageInfo

// UserV2 is version 2 resource spec of the user
type UserV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a user specification
	Spec                 UserSpecV2   `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	Status               UserStatusV2 `protobuf:"bytes,6,opt,name=Status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UserV2) Reset()      { *m = UserV2{} }
func (*UserV2) ProtoMessage() {}
func (*UserV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{134}
}
func (m *UserV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserV2.Merge(m, src)
}
func (m *UserV2) XXX_Size() int {
	return m.Size()
}
func (m *UserV2) XXX_DiscardUnknown() {
	xxx_messageInfo_UserV2.DiscardUnknown(m)
}

var xxx_messageInfo_UserV2 proto.InternalMessageInfo

// UserStatusV2 is a dynamic state of UserV2.
type UserStatusV2 struct {
	// password_state reflects what the system knows about the user's password.
	// Note that this is a "best effort" property, in that it can be UNSPECIFIED
	// for users who were created before this property was introduced and didn't
	// perform any password-related activity since then. See RFD 0159 for
	// details. Do NOT use this value for authentication purposes!
	PasswordState        PasswordState `protobuf:"varint,1,opt,name=password_state,json=passwordState,proto3,enum=types.PasswordState" json:"password_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UserStatusV2) Reset()         { *m = UserStatusV2{} }
func (m *UserStatusV2) String() string { return proto.CompactTextString(m) }
func (*UserStatusV2) ProtoMessage()    {}
func (*UserStatusV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{135}
}
func (m *UserStatusV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserStatusV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserStatusV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserStatusV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserStatusV2.Merge(m, src)
}
func (m *UserStatusV2) XXX_Size() int {
	return m.Size()
}
func (m *UserStatusV2) XXX_DiscardUnknown() {
	xxx_messageInfo_UserStatusV2.DiscardUnknown(m)
}

var xxx_messageInfo_UserStatusV2 proto.InternalMessageInfo

// UserSpecV2 is a specification for V2 user
type UserSpecV2 struct {
	// OIDCIdentities lists associated OpenID Connect identities
	// that let user log in using externally verified identity
	OIDCIdentities []ExternalIdentity `protobuf:"bytes,1,rep,name=OIDCIdentities,proto3" json:"oidc_identities,omitempty"`
	// SAMLIdentities lists associated SAML identities
	// that let user log in using externally verified identity
	SAMLIdentities []ExternalIdentity `protobuf:"bytes,2,rep,name=SAMLIdentities,proto3" json:"saml_identities,omitempty"`
	// GithubIdentities list associated Github OAuth2 identities
	// that let user log in using externally verified identity
	GithubIdentities []ExternalIdentity `protobuf:"bytes,3,rep,name=GithubIdentities,proto3" json:"github_identities,omitempty"`
	// Roles is a list of roles assigned to user
	Roles []string `protobuf:"bytes,4,rep,name=Roles,proto3" json:"roles,omitempty"`
	// Traits are key/value pairs received from an identity provider (through
	// OIDC claims or SAML assertions) or from a system administrator for local
	// accounts. Traits are used to populate role variables.
	Traits github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,5,opt,name=Traits,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"traits,omitempty"`
	// Status is a login status of the user
	Status LoginStatus `protobuf:"bytes,6,opt,name=Status,proto3" json:"status,omitempty"`
	// Expires if set sets TTL on the user
	Expires time.Time `protobuf:"bytes,7,opt,name=Expires,proto3,stdtime" json:"expires"`
	// CreatedBy holds information about agent or person created this user
	CreatedBy CreatedBy `protobuf:"bytes,8,opt,name=CreatedBy,proto3" json:"created_by,omitempty"`
	// LocalAuth holds sensitive data necessary for performing local
	// authentication
	LocalAuth *LocalAuthSecrets `protobuf:"bytes,9,opt,name=LocalAuth,proto3" json:"local_auth,omitempty"`
	// TrustedDeviceIDs contains the IDs of trusted devices enrolled by the user.
	//
	// Note that SSO users are transient and thus may contain an empty
	// TrustedDeviceIDs field, even though the user->device association exists
	// under the Device Trust subsystem. Do not rely on this field to determine
	// device associations or ownership, it exists for legacy/informative purposes
	// only.
	//
	// Managed by the Device Trust subsystem, avoid manual edits.
	TrustedDeviceIDs     []string `protobuf:"bytes,10,rep,name=TrustedDeviceIDs,proto3" json:"trusted_device_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserSpecV2) Reset()         { *m = UserSpecV2{} }
func (m *UserSpecV2) String() string { return proto.CompactTextString(m) }
func (*UserSpecV2) ProtoMessage()    {}
func (*UserSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{136}
}
func (m *UserSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSpecV2.Merge(m, src)
}
func (m *UserSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *UserSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_UserSpecV2 proto.InternalMessageInfo

// ExternalIdentity is OpenID Connect/SAML or Github identity that is linked
// to particular user and connector and lets user to log in using external
// credentials, e.g. google
type ExternalIdentity struct {
	// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
	ConnectorID string `protobuf:"bytes,1,opt,name=ConnectorID,proto3" json:"connector_id,omitempty"`
	// Username is username supplied by external identity provider
	Username string `protobuf:"bytes,2,opt,name=Username,proto3" json:"username,omitempty"`
	// SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
	SAMLSingleLogoutURL  string   `protobuf:"bytes,3,opt,name=SAMLSingleLogoutURL,proto3" json:"samlSingleLogoutUrl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExternalIdentity) Reset()      { *m = ExternalIdentity{} }
func (*ExternalIdentity) ProtoMessage() {}
func (*ExternalIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{137}
}
func (m *ExternalIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalIdentity.Merge(m, src)
}
func (m *ExternalIdentity) XXX_Size() int {
	return m.Size()
}
func (m *ExternalIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalIdentity proto.InternalMessageInfo

// LoginStatus is a login status of the user
type LoginStatus struct {
	// IsLocked tells us if user is locked
	IsLocked bool `protobuf:"varint,1,opt,name=IsLocked,proto3" json:"is_locked"`
	// LockedMessage contains the message in case if user is locked
	LockedMessage string `protobuf:"bytes,2,opt,name=LockedMessage,proto3" json:"locked_message,omitempty"`
	// LockedTime contains time when user was locked
	LockedTime time.Time `protobuf:"bytes,3,opt,name=LockedTime,proto3,stdtime" json:"locked_time,omitempty"`
	// LockExpires contains time when this lock will expire
	LockExpires          time.Time `protobuf:"bytes,4,opt,name=LockExpires,proto3,stdtime" json:"lock_expires,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *LoginStatus) Reset()         { *m = LoginStatus{} }
func (m *LoginStatus) String() string { return proto.CompactTextString(m) }
func (*LoginStatus) ProtoMessage()    {}
func (*LoginStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{138}
}
func (m *LoginStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginStatus.Merge(m, src)
}
func (m *LoginStatus) XXX_Size() int {
	return m.Size()
}
func (m *LoginStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LoginStatus proto.InternalMessageInfo

// CreatedBy holds information about the person or agent who created the user
type CreatedBy struct {
	// Identity if present means that user was automatically created by identity
	Connector *ConnectorRef `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector,omitempty"`
	// Time specifies when user was created
	Time time.Time `protobuf:"bytes,2,opt,name=Time,proto3,stdtime" json:"time"`
	// User holds information about user
	User                 UserRef  `protobuf:"bytes,3,opt,name=User,proto3" json:"user"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreatedBy) Reset()      { *m = CreatedBy{} }
func (*CreatedBy) ProtoMessage() {}
func (*CreatedBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{139}
}
func (m *CreatedBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatedBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatedBy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatedBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatedBy.Merge(m, src)
}
func (m *CreatedBy) XXX_Size() int {
	return m.Size()
}
func (m *CreatedBy) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatedBy.DiscardUnknown(m)
}

var xxx_messageInfo_CreatedBy proto.InternalMessageInfo

// LocalAuthSecrets holds sensitive data used to authenticate a local user.
type LocalAuthSecrets struct {
	// PasswordHash encodes a combined salt & hash for password verification.
	PasswordHash []byte `protobuf:"bytes,1,opt,name=PasswordHash,proto3" json:"password_hash,omitempty"`
	// Deprecated 2nd factor fields, use MFA below instead.
	TOTPKey string       `protobuf:"bytes,2,opt,name=TOTPKey,proto3" json:"totp_key,omitempty"`
	MFA     []*MFADevice `protobuf:"bytes,5,rep,name=MFA,proto3" json:"mfa,omitempty"`
	// Webauthn holds settings necessary for webauthn local auth.
	// May be null for legacy users or users that haven't yet used webauthn as
	// their second factor.
	Webauthn             *WebauthnLocalAuth `protobuf:"bytes,6,opt,name=Webauthn,proto3" json:"webauthn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *LocalAuthSecrets) Reset()         { *m = LocalAuthSecrets{} }
func (m *LocalAuthSecrets) String() string { return proto.CompactTextString(m) }
func (*LocalAuthSecrets) ProtoMessage()    {}
func (*LocalAuthSecrets) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{140}
}
func (m *LocalAuthSecrets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalAuthSecrets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalAuthSecrets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalAuthSecrets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalAuthSecrets.Merge(m, src)
}
func (m *LocalAuthSecrets) XXX_Size() int {
	return m.Size()
}
func (m *LocalAuthSecrets) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalAuthSecrets.DiscardUnknown(m)
}

var xxx_messageInfo_LocalAuthSecrets proto.InternalMessageInfo

// MFADevice is a multi-factor authentication device, such as a security key or
// an OTP app.
type MFADevice struct {
	// Boilerplate for implementing the Resource interface.
	Kind     string   `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	SubKind  string   `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	Version  string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Metadata Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata"`
	// ID is a UUID of this device.
	Id       string    `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	AddedAt  time.Time `protobuf:"bytes,6,opt,name=added_at,json=addedAt,proto3,stdtime" json:"added_at"`
	LastUsed time.Time `protobuf:"bytes,7,opt,name=last_used,json=lastUsed,proto3,stdtime" json:"last_used"`
	// Types that are valid to be assigned to Device:
	//
	//	*MFADevice_Totp
	//	*MFADevice_U2F
	//	*MFADevice_Webauthn
	Device               isMFADevice_Device `protobuf_oneof:"device"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MFADevice) Reset()         { *m = MFADevice{} }
func (m *MFADevice) String() string { return proto.CompactTextString(m) }
func (*MFADevice) ProtoMessage()    {}
func (*MFADevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{141}
}
func (m *MFADevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFADevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFADevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFADevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFADevice.Merge(m, src)
}
func (m *MFADevice) XXX_Size() int {
	return m.Size()
}
func (m *MFADevice) XXX_DiscardUnknown() {
	xxx_messageInfo_MFADevice.DiscardUnknown(m)
}

var xxx_messageInfo_MFADevice proto.InternalMessageInfo

type isMFADevice_Device interface {
	isMFADevice_Device()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MFADevice_Totp struct {
	Totp *TOTPDevice `protobuf:"bytes,8,opt,name=totp,proto3,oneof" json:"totp,omitempty"`
}
type MFADevice_U2F struct {
	U2F *U2FDevice `protobuf:"bytes,9,opt,name=u2f,proto3,oneof" json:"u2f,omitempty"`
}
type MFADevice_Webauthn struct {
	Webauthn *WebauthnDevice `protobuf:"bytes,10,opt,name=webauthn,proto3,oneof" json:"webauthn,omitempty"`
}

func (*MFADevice_Totp) isMFADevice_Device()     {}
func (*MFADevice_U2F) isMFADevice_Device()      {}
func (*MFADevice_Webauthn) isMFADevice_Device() {}

func (m *MFADevice) GetDevice() isMFADevice_Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *MFADevice) GetTotp() *TOTPDevice {
	if x, ok := m.GetDevice().(*MFADevice_Totp); ok {
		return x.Totp
	}
	return nil
}

func (m *MFADevice) GetU2F() *U2FDevice {
	if x, ok := m.GetDevice().(*MFADevice_U2F); ok {
		return x.U2F
	}
	return nil
}

func (m *MFADevice) GetWebauthn() *WebauthnDevice {
	if x, ok := m.GetDevice().(*MFADevice_Webauthn); ok {
		return x.Webauthn
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MFADevice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MFADevice_Totp)(nil),
		(*MFADevice_U2F)(nil),
		(*MFADevice_Webauthn)(nil),
	}
}

// TOTPDevice holds the TOTP-specific fields of MFADevice.
type TOTPDevice struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TOTPDevice) Reset()         { *m = TOTPDevice{} }
func (m *TOTPDevice) String() string { return proto.CompactTextString(m) }
func (*TOTPDevice) ProtoMessage()    {}
func (*TOTPDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{142}
}
func (m *TOTPDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TOTPDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TOTPDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TOTPDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TOTPDevice.Merge(m, src)
}
func (m *TOTPDevice) XXX_Size() int {
	return m.Size()
}
func (m *TOTPDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_TOTPDevice.DiscardUnknown(m)
}

var xxx_messageInfo_TOTPDevice proto.InternalMessageInfo

// U2FDevice holds the U2F-specific fields of MFADevice.
type U2FDevice struct {
	// KeyHandle uniquely identifies a key on a device
	KeyHandle []byte `protobuf:"bytes,1,opt,name=key_handle,json=keyHandle,proto3" json:"key_handle,omitempty"`
	// PubKey is an DER encoded ecdsa public key
	PubKey []byte `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// Counter is the latest seen value of the U2F usage counter.
	Counter              uint32   `protobuf:"varint,3,opt,name=counter,proto3" json:"counter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *U2FDevice) Reset()         { *m = U2FDevice{} }
func (m *U2FDevice) String() string { return proto.CompactTextString(m) }
func (*U2FDevice) ProtoMessage()    {}
func (*U2FDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{143}
}
func (m *U2FDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *U2FDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_U2FDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *U2FDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_U2FDevice.Merge(m, src)
}
func (m *U2FDevice) XXX_Size() int {
	return m.Size()
}
func (m *U2FDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_U2FDevice.DiscardUnknown(m)
}

var xxx_messageInfo_U2FDevice proto.InternalMessageInfo

// WebauthnDevice holds Webauthn-specific fields of MFADevice.
type WebauthnDevice struct {
	// Credential ID for the authenticator.
	CredentialId []byte `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// Public key encoded in CBOR format.
	// Webauthn support various key algorithms; CBOR encoding is used to reflect
	// those choices.
	// See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
	// reference.
	PublicKeyCbor []byte `protobuf:"bytes,2,opt,name=public_key_cbor,json=publicKeyCbor,proto3" json:"public_key_cbor,omitempty"`
	// Attestation format used by the authenticator, if any.
	AttestationType string `protobuf:"bytes,3,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type,omitempty"`
	// AAGUID is the globally unique identifier of the authenticator model.
	// Zeroed for U2F devices.
	Aaguid []byte `protobuf:"bytes,4,opt,name=aaguid,proto3" json:"aaguid,omitempty"`
	// Signature counter for login operations.
	// Actual counter values received from the authenticator are expected to be
	// higher than the previously-stored value.
	SignatureCounter uint32 `protobuf:"varint,5,opt,name=signature_counter,json=signatureCounter,proto3" json:"signature_counter,omitempty"`
	// Raw attestation object, as returned by the authentication during
	// registration.
	// Absent for legacy entries (Teleport 8.x).
	AttestationObject []byte `protobuf:"bytes,6,opt,name=attestation_object,json=attestationObject,proto3" json:"attestation_object,omitempty"`
	// True if a resident key was requested during registration.
	// Marks passwordless-capable devices.
	// (Note that resident_key=true represents the server-side / Relying Party
	// view of the registration process; the authenticator alone can determine
	// if a key is truly resident.)
	ResidentKey bool `protobuf:"varint,7,opt,name=resident_key,json=residentKey,proto3" json:"resident_key,omitempty"`
	// Relying Party ID used by the credential.
	// Recorded on registration for new credentials, or on first successful
	// authentication for "old" credentials (created before the field existed).
	// Ideally, this is always the same as the configured RPID.
	// If an RPID change does happen, this helps Teleport detect it and react
	// accordingly.
	CredentialRpId string `protobuf:"bytes,8,opt,name=credential_rp_id,json=credentialRpId,proto3" json:"credential_rp_id,omitempty"`
	// Authenticator Backup Eligibility (BE) bit, recorded during registration or
	// backfill (for older authenticators).
	// https://w3c.github.io/webauthn/#authdata-flags-be
	CredentialBackupEligible *types.BoolValue `protobuf:"bytes,9,opt,name=credential_backup_eligible,json=credentialBackupEligible,proto3" json:"credential_backup_eligible,omitempty"`
	// Authenticator Backup State (BS) bit, recorded during registration or
	// backfill (for older authenticators).
	// https://w3c.github.io/webauthn/#authdata-flags-bs
	CredentialBackedUp   *types.BoolValue `protobuf:"bytes,10,opt,name=credential_backed_up,json=credentialBackedUp,proto3" json:"credential_backed_up,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *WebauthnDevice) Reset()         { *m = WebauthnDevice{} }
func (m *WebauthnDevice) String() string { return proto.CompactTextString(m) }
func (*WebauthnDevice) ProtoMessage()    {}
func (*WebauthnDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{144}
}
func (m *WebauthnDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebauthnDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebauthnDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebauthnDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebauthnDevice.Merge(m, src)
}
func (m *WebauthnDevice) XXX_Size() int {
	return m.Size()
}
func (m *WebauthnDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_WebauthnDevice.DiscardUnknown(m)
}

var xxx_messageInfo_WebauthnDevice proto.InternalMessageInfo

// WebauthnLocalAuth holds settings necessary for local webauthn use.
type WebauthnLocalAuth struct {
	// UserID is the random user handle generated for the user.
	// See https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy.
	UserID               []byte   `protobuf:"bytes,1,opt,name=UserID,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebauthnLocalAuth) Reset()         { *m = WebauthnLocalAuth{} }
func (m *WebauthnLocalAuth) String() string { return proto.CompactTextString(m) }
func (*WebauthnLocalAuth) ProtoMessage()    {}
func (*WebauthnLocalAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{145}
}
func (m *WebauthnLocalAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebauthnLocalAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebauthnLocalAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebauthnLocalAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebauthnLocalAuth.Merge(m, src)
}
func (m *WebauthnLocalAuth) XXX_Size() int {
	return m.Size()
}
func (m *WebauthnLocalAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_WebauthnLocalAuth.DiscardUnknown(m)
}

var xxx_messageInfo_WebauthnLocalAuth proto.InternalMessageInfo

// ConnectorRef holds information about OIDC connector
type ConnectorRef struct {
	// Type is connector type
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type"`
	// ID is connector ID
	ID string `protobuf:"bytes,2,opt,name=ID,proto3" json:"id"`
	// Identity is external identity of the user
	Identity             string   `protobuf:"bytes,3,opt,name=Identity,proto3" json:"identity"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectorRef) Reset()         { *m = ConnectorRef{} }
func (m *ConnectorRef) String() string { return proto.CompactTextString(m) }
func (*ConnectorRef) ProtoMessage()    {}
func (*ConnectorRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{146}
}
func (m *ConnectorRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectorRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectorRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectorRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectorRef.Merge(m, src)
}
func (m *ConnectorRef) XXX_Size() int {
	return m.Size()
}
func (m *ConnectorRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectorRef.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectorRef proto.InternalMessageInfo

// UserRef holds references to user
type UserRef struct {
	// Name is name of the user
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRef) Reset()         { *m = UserRef{} }
func (m *UserRef) String() string { return proto.CompactTextString(m) }
func (*UserRef) ProtoMessage()    {}
func (*UserRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{147}
}
func (m *UserRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRef.Merge(m, src)
}
func (m *UserRef) XXX_Size() int {
	return m.Size()
}
func (m *UserRef) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRef.DiscardUnknown(m)
}

var xxx_messageInfo_UserRef proto.InternalMessageInfo

// ReverseTunnelV2 is version 2 of the resource spec of the reverse tunnel
type ReverseTunnelV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is a resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a reverse tunnel specification
	Spec                 ReverseTunnelSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ReverseTunnelV2) Reset()         { *m = ReverseTunnelV2{} }
func (m *ReverseTunnelV2) String() string { return proto.CompactTextString(m) }
func (*ReverseTunnelV2) ProtoMessage()    {}
func (*ReverseTunnelV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{148}
}
func (m *ReverseTunnelV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReverseTunnelV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReverseTunnelV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReverseTunnelV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseTunnelV2.Merge(m, src)
}
func (m *ReverseTunnelV2) XXX_Size() int {
	return m.Size()
}
func (m *ReverseTunnelV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseTunnelV2.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseTunnelV2 proto.InternalMessageInfo

// ReverseTunnelSpecV2 is a specification for V2 reverse tunnel
type ReverseTunnelSpecV2 struct {
	// ClusterName is a domain name of remote cluster we are connecting to
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"cluster_name"`
	// DialAddrs is a list of remote address to establish a connection to
	// it's always SSH over TCP
	DialAddrs []string `protobuf:"bytes,2,rep,name=DialAddrs,proto3" json:"dial_addrs,omitempty"`
	// Type is the type of reverse tunnel, either proxy or node.
	Type                 TunnelType `protobuf:"bytes,3,opt,name=Type,proto3,casttype=TunnelType" json:"type"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ReverseTunnelSpecV2) Reset()         { *m = ReverseTunnelSpecV2{} }
func (m *ReverseTunnelSpecV2) String() string { return proto.CompactTextString(m) }
func (*ReverseTunnelSpecV2) ProtoMessage()    {}
func (*ReverseTunnelSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{149}
}
func (m *ReverseTunnelSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReverseTunnelSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReverseTunnelSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReverseTunnelSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseTunnelSpecV2.Merge(m, src)
}
func (m *ReverseTunnelSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *ReverseTunnelSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseTunnelSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseTunnelSpecV2 proto.InternalMessageInfo

// TunnelConnectionV2 is version 2 of the resource spec of the tunnel connection
type TunnelConnectionV2 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is a resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a tunnel specification
	Spec                 TunnelConnectionSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TunnelConnectionV2) Reset()      { *m = TunnelConnectionV2{} }
func (*TunnelConnectionV2) ProtoMessage() {}
func (*TunnelConnectionV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{150}
}
func (m *TunnelConnectionV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelConnectionV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelConnectionV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelConnectionV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelConnectionV2.Merge(m, src)
}
func (m *TunnelConnectionV2) XXX_Size() int {
	return m.Size()
}
func (m *TunnelConnectionV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelConnectionV2.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelConnectionV2 proto.InternalMessageInfo

// TunnelConnectionSpecV2 is a specification for V2 tunnel connection
type TunnelConnectionSpecV2 struct {
	// ClusterName is a name of the cluster
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"cluster_name"`
	// ProxyName is the name of the proxy server
	ProxyName string `protobuf:"bytes,2,opt,name=ProxyName,proto3" json:"proxy_name"`
	// LastHeartbeat is a time of the last heartbeat
	LastHeartbeat time.Time `protobuf:"bytes,3,opt,name=LastHeartbeat,proto3,stdtime" json:"last_heartbeat,omitempty"`
	// Type is the type of reverse tunnel, either proxy or node.
	Type                 TunnelType `protobuf:"bytes,4,opt,name=Type,proto3,casttype=TunnelType" json:"type"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TunnelConnectionSpecV2) Reset()         { *m = TunnelConnectionSpecV2{} }
func (m *TunnelConnectionSpecV2) String() string { return proto.CompactTextString(m) }
func (*TunnelConnectionSpecV2) ProtoMessage()    {}
func (*TunnelConnectionSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{151}
}
func (m *TunnelConnectionSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelConnectionSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelConnectionSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelConnectionSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelConnectionSpecV2.Merge(m, src)
}
func (m *TunnelConnectionSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *TunnelConnectionSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelConnectionSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelConnectionSpecV2 proto.InternalMessageInfo

// SemaphoreFilter encodes semaphore filtering params.
// A semaphore filter matches a semaphore if all nonzero fields
// match the corresponding semaphore fields (e.g. a filter which
// specifies only `kind=foo` would match all semaphores of
// kind `foo`).
type SemaphoreFilter struct {
	// SemaphoreKind is the kind of the semaphore.
	SemaphoreKind string `protobuf:"bytes,1,opt,name=SemaphoreKind,proto3" json:"kind"`
	// SemaphoreName is the name of the semaphore.
	SemaphoreName        string   `protobuf:"bytes,2,opt,name=SemaphoreName,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SemaphoreFilter) Reset()         { *m = SemaphoreFilter{} }
func (m *SemaphoreFilter) String() string { return proto.CompactTextString(m) }
func (*SemaphoreFilter) ProtoMessage()    {}
func (*SemaphoreFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{152}
}
func (m *SemaphoreFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreFilter.Merge(m, src)
}
func (m *SemaphoreFilter) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreFilter.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreFilter proto.InternalMessageInfo

// AcquireSemaphoreRequest holds semaphore lease acquisition parameters.
type AcquireSemaphoreRequest struct {
	// SemaphoreKind is the kind of the semaphore.
	SemaphoreKind string `protobuf:"bytes,1,opt,name=SemaphoreKind,proto3" json:"kind"`
	// SemaphoreName is the name of the semaphore.
	SemaphoreName string `protobuf:"bytes,2,opt,name=SemaphoreName,proto3" json:"name"`
	// MaxLeases is the maximum number of concurrent leases.  If acquisition
	// would cause more than MaxLeases to exist, acquisition must fail.
	MaxLeases int64 `protobuf:"varint,3,opt,name=MaxLeases,proto3" json:"max_resources"`
	// Expires is the time at which this lease expires.
	Expires time.Time `protobuf:"bytes,4,opt,name=Expires,proto3,stdtime" json:"expires"`
	// Holder identifies the entity holding the lease.
	Holder               string   `protobuf:"bytes,5,opt,name=Holder,proto3" json:"holder"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcquireSemaphoreRequest) Reset()         { *m = AcquireSemaphoreRequest{} }
func (m *AcquireSemaphoreRequest) String() string { return proto.CompactTextString(m) }
func (*AcquireSemaphoreRequest) ProtoMessage()    {}
func (*AcquireSemaphoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{153}
}
func (m *AcquireSemaphoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcquireSemaphoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcquireSemaphoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcquireSemaphoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcquireSemaphoreRequest.Merge(m, src)
}
func (m *AcquireSemaphoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcquireSemaphoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcquireSemaphoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcquireSemaphoreRequest proto.InternalMessageInfo

// SemaphoreLease represents lease acquired for semaphore
type SemaphoreLease struct {
	// SemaphoreKind is the kind of the semaphore.
	SemaphoreKind string `protobuf:"bytes,1,opt,name=SemaphoreKind,proto3" json:"kind"`
	// SemaphoreName is the name of the semaphore.
	SemaphoreName string `protobuf:"bytes,2,opt,name=SemaphoreName,proto3" json:"name"`
	// LeaseID uniquely identifies this lease.
	LeaseID string `protobuf:"bytes,3,opt,name=LeaseID,proto3" json:"lease_id"`
	// Expires is the time at which this lease expires.
	Expires              time.Time `protobuf:"bytes,5,opt,name=Expires,proto3,stdtime" json:"expires"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SemaphoreLease) Reset()         { *m = SemaphoreLease{} }
func (m *SemaphoreLease) String() string { return proto.CompactTextString(m) }
func (*SemaphoreLease) ProtoMessage()    {}
func (*SemaphoreLease) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{154}
}
func (m *SemaphoreLease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreLease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreLease.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreLease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreLease.Merge(m, src)
}
func (m *SemaphoreLease) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreLease) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreLease.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreLease proto.InternalMessageInfo

// SemaphoreLeaseRef identifies an existent lease.
type SemaphoreLeaseRef struct {
	// LeaseID is the unique ID of the lease.
	LeaseID string `protobuf:"bytes,1,opt,name=LeaseID,proto3" json:"lease_id"`
	// Expires is the time at which the lease expires.
	Expires time.Time `protobuf:"bytes,2,opt,name=Expires,proto3,stdtime" json:"expires"`
	// Holder identifies the lease holder.
	Holder               string   `protobuf:"bytes,3,opt,name=Holder,proto3" json:"holder"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SemaphoreLeaseRef) Reset()         { *m = SemaphoreLeaseRef{} }
func (m *SemaphoreLeaseRef) String() string { return proto.CompactTextString(m) }
func (*SemaphoreLeaseRef) ProtoMessage()    {}
func (*SemaphoreLeaseRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{155}
}
func (m *SemaphoreLeaseRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreLeaseRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreLeaseRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreLeaseRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreLeaseRef.Merge(m, src)
}
func (m *SemaphoreLeaseRef) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreLeaseRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreLeaseRef.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreLeaseRef proto.InternalMessageInfo

// SemaphoreV3 implements Semaphore interface
type SemaphoreV3 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is Semaphore metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a lease V3 spec
	Spec                 SemaphoreSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SemaphoreV3) Reset()      { *m = SemaphoreV3{} }
func (*SemaphoreV3) ProtoMessage() {}
func (*SemaphoreV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{156}
}
func (m *SemaphoreV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreV3.Merge(m, src)
}
func (m *SemaphoreV3) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreV3) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreV3.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreV3 proto.InternalMessageInfo

// SemaphoreSpecV3 contains the data about lease
type SemaphoreSpecV3 struct {
	// Leases is a list of all currently acquired leases.
	Leases               []SemaphoreLeaseRef `protobuf:"bytes,1,rep,name=Leases,proto3" json:"leases"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SemaphoreSpecV3) Reset()         { *m = SemaphoreSpecV3{} }
func (m *SemaphoreSpecV3) String() string { return proto.CompactTextString(m) }
func (*SemaphoreSpecV3) ProtoMessage()    {}
func (*SemaphoreSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{157}
}
func (m *SemaphoreSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SemaphoreSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SemaphoreSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SemaphoreSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SemaphoreSpecV3.Merge(m, src)
}
func (m *SemaphoreSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *SemaphoreSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_SemaphoreSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_SemaphoreSpecV3 proto.InternalMessageInfo

// WebSessionV2 represents an application or UI web session.
type WebSessionV2 struct {
	// Kind is a resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is a resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a tunnel specification.
	Spec                 WebSessionSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *WebSessionV2) Reset()      { *m = WebSessionV2{} }
func (*WebSessionV2) ProtoMessage() {}
func (*WebSessionV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{158}
}
func (m *WebSessionV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSessionV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSessionV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebSessionV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSessionV2.Merge(m, src)
}
func (m *WebSessionV2) XXX_Size() int {
	return m.Size()
}
func (m *WebSessionV2) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSessionV2.DiscardUnknown(m)
}

var xxx_messageInfo_WebSessionV2 proto.InternalMessageInfo

// WebSessionSpecV2 is a specification for web session.
type WebSessionSpecV2 struct {
	// User is the identity of the user to which the web session belongs.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// Pub is the SSH certificate for the user, marshaled in the authorized key
	// format.
	Pub []byte `protobuf:"bytes,2,opt,name=Pub,proto3" json:"pub"`
	// Priv is the SSH private key for the user, in PEM-encoded PKCS#1 or PKCS#8
	// format. If TLSPriv is unset, this is also the TLS private key.
	Priv []byte `protobuf:"bytes,3,opt,name=Priv,proto3" json:"priv,omitempty"`
	// TLSCert is the X.509 certificate for the user (PEM-encoded).
	TLSCert []byte `protobuf:"bytes,4,opt,name=TLSCert,proto3" json:"tls_cert,omitempty"`
	// BearerToken is a token that is paired with the session cookie for
	// authentication. It is periodically rotated so a stolen cookie itself
	// is not enough to steal a session. In addition it is used for CSRF
	// mitigation.
	BearerToken string `protobuf:"bytes,5,opt,name=BearerToken,proto3" json:"bearer_token"`
	// BearerTokenExpires is the absolute time when the token expires.
	BearerTokenExpires time.Time `protobuf:"bytes,6,opt,name=BearerTokenExpires,proto3,stdtime" json:"bearer_token_expires"`
	// Expires is the absolute time when the session expires.
	Expires time.Time `protobuf:"bytes,7,opt,name=Expires,proto3,stdtime" json:"expires"`
	// LoginTime is the time this user recently logged in.
	LoginTime time.Time `protobuf:"bytes,8,opt,name=LoginTime,proto3,stdtime" json:"login_time"`
	// IdleTimeout is the max time a user can be inactive in a session.
	IdleTimeout Duration `protobuf:"varint,9,opt,name=IdleTimeout,proto3,casttype=Duration" json:"idle_timeout"`
	// ConsumedAccessRequestID is the ID of the access request from which additional roles to assume
	// were obtained.
	ConsumedAccessRequestID string `protobuf:"bytes,10,opt,name=ConsumedAccessRequestID,proto3" json:"consumed_access_request_id,omitempty"`
	// SAMLSession is data associated with a SAML IdP session.
	SAMLSession *SAMLSessionData `protobuf:"bytes,11,opt,name=SAMLSession,proto3" json:"saml_session,omitempty"`
	// Device trust web authentication token.
	// May be exchanged for a single on-behalf-of device authentication attempt
	// (typically performed by Connect).
	// Only present if on-behalf-of device authentication is possible.
	DeviceWebToken *DeviceWebToken `protobuf:"bytes,12,opt,name=DeviceWebToken,proto3" json:"device_web_token,omitempty"`
	// HasDeviceExtensions is true if the session's TLS and SSH certificates are
	// augmented with device extensions.
	HasDeviceExtensions bool `protobuf:"varint,13,opt,name=HasDeviceExtensions,proto3" json:"has_device_extensions,omitempty"`
	// TrustedDeviceRequirement indicates whether access may be hindered by the
	// lack of a trusted device.
	//
	// If during login a device is required and DeviceWebToken is nil, then it's
	// likely the user needs to enroll their device to avoid impacting access.
	TrustedDeviceRequirement TrustedDeviceRequirement `protobuf:"varint,14,opt,name=TrustedDeviceRequirement,proto3,enum=types.TrustedDeviceRequirement" json:"trusted_device_requirement,omitempty"`
	// TLSPriv is the TLS private key for the user, in PEM-encoded PKCS#1 or PKCS#8
	// format. If unset, then Priv is used as both the SSH and TLS private key.
	TLSPriv              []byte   `protobuf:"bytes,15,opt,name=TLSPriv,proto3" json:"tls_priv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebSessionSpecV2) Reset()         { *m = WebSessionSpecV2{} }
func (m *WebSessionSpecV2) String() string { return proto.CompactTextString(m) }
func (*WebSessionSpecV2) ProtoMessage()    {}
func (*WebSessionSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{159}
}
func (m *WebSessionSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSessionSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSessionSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebSessionSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSessionSpecV2.Merge(m, src)
}
func (m *WebSessionSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *WebSessionSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSessionSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_WebSessionSpecV2 proto.InternalMessageInfo

// Web-focused view of teleport.devicetrust.v1.DeviceWebToken.
type DeviceWebToken struct {
	// Opaque token identifier.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Opaque device web token, in plaintext, encoded in base64.RawURLEncoding
	// (so it is inherently safe for URl use).
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceWebToken) Reset()         { *m = DeviceWebToken{} }
func (m *DeviceWebToken) String() string { return proto.CompactTextString(m) }
func (*DeviceWebToken) ProtoMessage()    {}
func (*DeviceWebToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{160}
}
func (m *DeviceWebToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceWebToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceWebToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceWebToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceWebToken.Merge(m, src)
}
func (m *DeviceWebToken) XXX_Size() int {
	return m.Size()
}
func (m *DeviceWebToken) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceWebToken.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceWebToken proto.InternalMessageInfo

// WebSessionFilter encodes cache watch parameters for filtering web sessions.
type WebSessionFilter struct {
	// User is the username to filter web sessions for.
	User                 string   `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebSessionFilter) Reset()         { *m = WebSessionFilter{} }
func (m *WebSessionFilter) String() string { return proto.CompactTextString(m) }
func (*WebSessionFilter) ProtoMessage()    {}
func (*WebSessionFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{161}
}
func (m *WebSessionFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSessionFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSessionFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebSessionFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSessionFilter.Merge(m, src)
}
func (m *WebSessionFilter) XXX_Size() int {
	return m.Size()
}
func (m *WebSessionFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSessionFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WebSessionFilter proto.InternalMessageInfo

// SAMLSessionData contains data for a SAML session.
// Based on crewjam/saml's session object: https://github.com/crewjam/saml/blob/main/identity_provider.go
type SAMLSessionData struct {
	// ID is the identifier for the SAML session.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"id"`
	// CreateTime is the time that the session was created.
	CreateTime time.Time `protobuf:"bytes,2,opt,name=CreateTime,proto3,stdtime" json:"create_time"`
	// ExpireTime is the time that the session will expire.
	ExpireTime time.Time `protobuf:"bytes,3,opt,name=ExpireTime,proto3,stdtime" json:"expire_time"`
	// Index is the session index that allows the IdP to uniquely identify a session.
	Index string `protobuf:"bytes,4,opt,name=Index,proto3" json:"index"`
	// NameID an identifier for the session.
	NameID string `protobuf:"bytes,5,opt,name=NameID,proto3" json:"name_id"`
	// NameIDFormat is the format of the Name ID.
	NameIDFormat string `protobuf:"bytes,6,opt,name=NameIDFormat,proto3" json:"name_id_format"`
	// SubjectID is the identifier for the subject of the session.
	SubjectID string `protobuf:"bytes,7,opt,name=SubjectID,proto3" json:"subject_id"`
	// Groups is a list of groups that the user has access to.
	Groups []string `protobuf:"bytes,8,rep,name=Groups,proto3" json:"groups"`
	// UserName is the user's name.
	UserName string `protobuf:"bytes,9,opt,name=UserName,proto3" json:"user_name"`
	// UserEmail is the user's e-mail.
	UserEmail string `protobuf:"bytes,10,opt,name=UserEmail,proto3" json:"user_email"`
	// UserCommonName is the user's common name.
	UserCommonName string `protobuf:"bytes,11,opt,name=UserCommonName,proto3" json:"user_common_name"`
	// UserSurname is the user's surname.
	UserSurname string `protobuf:"bytes,12,opt,name=UserSurname,proto3" json:"user_surname"`
	// UserGivenName is the user's given name.
	UserGivenName string `protobuf:"bytes,13,opt,name=UserGivenName,proto3" json:"user_given_name"`
	// UserScopedAffiliation is the user's scoped affiliation.
	UserScopedAffiliation string `protobuf:"bytes,14,opt,name=UserScopedAffiliation,proto3" json:"user_scoped_affiliation"`
	// CustomAttributes are any custom attributes associated with the request.
	CustomAttributes     []*SAMLAttribute `protobuf:"bytes,15,rep,name=CustomAttributes,proto3" json:"custom_attributes"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SAMLSessionData) Reset()         { *m = SAMLSessionData{} }
func (m *SAMLSessionData) String() string { return proto.CompactTextString(m) }
func (*SAMLSessionData) ProtoMessage()    {}
func (*SAMLSessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{162}
}
func (m *SAMLSessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLSessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLSessionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLSessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLSessionData.Merge(m, src)
}
func (m *SAMLSessionData) XXX_Size() int {
	return m.Size()
}
func (m *SAMLSessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLSessionData.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLSessionData proto.InternalMessageInfo

// SAMLAttribute contains an attribute name and associated values.
// Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
type SAMLAttribute struct {
	// FriendlyName is a user readable name for the attribute.
	FriendlyName string `protobuf:"bytes,1,opt,name=FriendlyName,proto3" json:"friendly_name"`
	// Name is a full name for the attribute, typically an OID value.
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	// NameFormat is the format of the name.
	NameFormat string `protobuf:"bytes,3,opt,name=NameFormat,proto3" json:"name_format"`
	// Values is a list of attribute values.
	Values               []*SAMLAttributeValue `protobuf:"bytes,4,rep,name=Values,proto3" json:"values"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SAMLAttribute) Reset()         { *m = SAMLAttribute{} }
func (m *SAMLAttribute) String() string { return proto.CompactTextString(m) }
func (*SAMLAttribute) ProtoMessage()    {}
func (*SAMLAttribute) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{163}
}
func (m *SAMLAttribute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLAttribute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLAttribute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLAttribute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLAttribute.Merge(m, src)
}
func (m *SAMLAttribute) XXX_Size() int {
	return m.Size()
}
func (m *SAMLAttribute) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLAttribute.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLAttribute proto.InternalMessageInfo

// SAMLAttributeValues contains a type, value, and an associated name ID block.
// Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
type SAMLAttributeValue struct {
	// Type is the type of value this attribute represents.
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"type"`
	// Value is the value of the attribute.
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
	// NameID is a more restrictive identifier for the attribute value.
	NameID               *SAMLNameID `protobuf:"bytes,3,opt,name=NameID,proto3" json:"name_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SAMLAttributeValue) Reset()         { *m = SAMLAttributeValue{} }
func (m *SAMLAttributeValue) String() string { return proto.CompactTextString(m) }
func (*SAMLAttributeValue) ProtoMessage()    {}
func (*SAMLAttributeValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{164}
}
func (m *SAMLAttributeValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLAttributeValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLAttributeValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLAttributeValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLAttributeValue.Merge(m, src)
}
func (m *SAMLAttributeValue) XXX_Size() int {
	return m.Size()
}
func (m *SAMLAttributeValue) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLAttributeValue.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLAttributeValue proto.InternalMessageInfo

// SAMLNameID is a more restrictive identifier for an object in SAML.
// Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
type SAMLNameID struct {
	// NameQualifier is the domain that qualifies the identifier.
	NameQualifier string `protobuf:"bytes,1,opt,name=NameQualifier,proto3" json:"name_qualifier"`
	// SPNameQualifier qualifies the identifier with the name of the service provider.
	SPNameQualifier string `protobuf:"bytes,2,opt,name=SPNameQualifier,proto3" json:"sp_name_qualifier"`
	// Format is the format of the identifier.
	Format string `protobuf:"bytes,3,opt,name=Format,proto3" json:"format"`
	// SPProvidedID is an identifier established by the service provider.
	SPProvidedID string `protobuf:"bytes,4,opt,name=SPProvidedID,proto3" json:"sp_provider_id"`
	// Value is the value of the name ID.
	Value                string   `protobuf:"bytes,5,opt,name=Value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SAMLNameID) Reset()         { *m = SAMLNameID{} }
func (m *SAMLNameID) String() string { return proto.CompactTextString(m) }
func (*SAMLNameID) ProtoMessage()    {}
func (*SAMLNameID) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{165}
}
func (m *SAMLNameID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLNameID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLNameID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLNameID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLNameID.Merge(m, src)
}
func (m *SAMLNameID) XXX_Size() int {
	return m.Size()
}
func (m *SAMLNameID) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLNameID.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLNameID proto.InternalMessageInfo

// RemoteClusterV3 represents remote cluster resource specification
type RemoteClusterV3 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is resource API version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Status is a remote cluster status
	Status               RemoteClusterStatusV3 `protobuf:"bytes,5,opt,name=Status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *RemoteClusterV3) Reset()      { *m = RemoteClusterV3{} }
func (*RemoteClusterV3) ProtoMessage() {}
func (*RemoteClusterV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{166}
}
func (m *RemoteClusterV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteClusterV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteClusterV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteClusterV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteClusterV3.Merge(m, src)
}
func (m *RemoteClusterV3) XXX_Size() int {
	return m.Size()
}
func (m *RemoteClusterV3) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteClusterV3.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteClusterV3 proto.InternalMessageInfo

// RemoteClusterStatusV3 represents status of the remote cluster
type RemoteClusterStatusV3 struct {
	// Connection represents connection status, online or offline
	Connection string `protobuf:"bytes,1,opt,name=Connection,proto3" json:"connection"`
	// LastHeartbeat records last heartbeat of the cluster
	LastHeartbeat        time.Time `protobuf:"bytes,2,opt,name=LastHeartbeat,proto3,stdtime" json:"last_heartbeat"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RemoteClusterStatusV3) Reset()         { *m = RemoteClusterStatusV3{} }
func (m *RemoteClusterStatusV3) String() string { return proto.CompactTextString(m) }
func (*RemoteClusterStatusV3) ProtoMessage()    {}
func (*RemoteClusterStatusV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{167}
}
func (m *RemoteClusterStatusV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteClusterStatusV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteClusterStatusV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteClusterStatusV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteClusterStatusV3.Merge(m, src)
}
func (m *RemoteClusterStatusV3) XXX_Size() int {
	return m.Size()
}
func (m *RemoteClusterStatusV3) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteClusterStatusV3.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteClusterStatusV3 proto.InternalMessageInfo

// KubernetesCluster is a named kubernetes API endpoint handled by a Server.
//
// TODO: deprecate and convert all usage to KubernetesClusterV3
type KubernetesCluster struct {
	// Name is the name of this kubernetes cluster.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// StaticLabels is map of static labels associated with this cluster.
	// Used for RBAC.
	StaticLabels map[string]string `protobuf:"bytes,2,rep,name=StaticLabels,proto3" json:"static_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// DynamicLabels is map of dynamic labels associated with this cluster.
	// Used for RBAC.
	DynamicLabels        map[string]CommandLabelV2 `protobuf:"bytes,3,rep,name=DynamicLabels,proto3" json:"dynamic_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *KubernetesCluster) Reset()         { *m = KubernetesCluster{} }
func (m *KubernetesCluster) String() string { return proto.CompactTextString(m) }
func (*KubernetesCluster) ProtoMessage()    {}
func (*KubernetesCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{168}
}
func (m *KubernetesCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesCluster.Merge(m, src)
}
func (m *KubernetesCluster) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesCluster.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesCluster proto.InternalMessageInfo

// KubernetesClusterV3 represents a named kubernetes API endpoint.
type KubernetesClusterV3 struct {
	// Kind is the cluster resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the resource spec.
	Spec                 KubernetesClusterSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *KubernetesClusterV3) Reset()      { *m = KubernetesClusterV3{} }
func (*KubernetesClusterV3) ProtoMessage() {}
func (*KubernetesClusterV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{169}
}
func (m *KubernetesClusterV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesClusterV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesClusterV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesClusterV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesClusterV3.Merge(m, src)
}
func (m *KubernetesClusterV3) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesClusterV3) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesClusterV3.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesClusterV3 proto.InternalMessageInfo

// KubernetesClusterSpecV3 is a specification for a Kubernetes cluster.
type KubernetesClusterSpecV3 struct {
	// DynamicLabels are the cluster's dynamic labels.
	DynamicLabels map[string]CommandLabelV2 `protobuf:"bytes,1,rep,name=DynamicLabels,proto3" json:"dynamic_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kubeconfig is the kubeconfig file payload that grants access to the cluster.
	// If multiple contexts are specified, the first will be selected.
	Kubeconfig []byte `protobuf:"bytes,2,opt,name=Kubeconfig,proto3" json:"kubeconfig,omitempty"`
	// Azure holds the required Azure information for Teleport to access the cluster.
	Azure KubeAzure `protobuf:"bytes,3,opt,name=Azure,proto3" json:"azure,omitempty"`
	// AWS holds the required AWS information for Teleport to access the cluster.
	AWS KubeAWS `protobuf:"bytes,4,opt,name=AWS,proto3" json:"aws,omitempty"`
	// GCP holds the required GCP information for Teleport to access the cluster.
	GCP                  KubeGCP  `protobuf:"bytes,5,opt,name=GCP,proto3" json:"gcp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesClusterSpecV3) Reset()         { *m = KubernetesClusterSpecV3{} }
func (m *KubernetesClusterSpecV3) String() string { return proto.CompactTextString(m) }
func (*KubernetesClusterSpecV3) ProtoMessage()    {}
func (*KubernetesClusterSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{170}
}
func (m *KubernetesClusterSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesClusterSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesClusterSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesClusterSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesClusterSpecV3.Merge(m, src)
}
func (m *KubernetesClusterSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesClusterSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesClusterSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesClusterSpecV3 proto.InternalMessageInfo

// KubeAzure contains the Azure information about the cluster.
type KubeAzure struct {
	// ResourceName is the AKS cluster name.
	ResourceName string `protobuf:"bytes,1,opt,name=ResourceName,proto3" json:"resource_name,omitempty"`
	// ResourceGroup is the Azure resource group name.
	ResourceGroup string `protobuf:"bytes,2,opt,name=ResourceGroup,proto3" json:"resource_group,omitempty"`
	// TenantID is the AKS cluster Tenant ID.
	TenantID string `protobuf:"bytes,3,opt,name=TenantID,proto3" json:"tenant_id,omitempty"`
	// SubscriptionID is the AKS cluster SubscriptionID.
	SubscriptionID       string   `protobuf:"bytes,4,opt,name=SubscriptionID,proto3" json:"subscription_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubeAzure) Reset()         { *m = KubeAzure{} }
func (m *KubeAzure) String() string { return proto.CompactTextString(m) }
func (*KubeAzure) ProtoMessage()    {}
func (*KubeAzure) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{171}
}
func (m *KubeAzure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubeAzure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubeAzure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubeAzure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubeAzure.Merge(m, src)
}
func (m *KubeAzure) XXX_Size() int {
	return m.Size()
}
func (m *KubeAzure) XXX_DiscardUnknown() {
	xxx_messageInfo_KubeAzure.DiscardUnknown(m)
}

var xxx_messageInfo_KubeAzure proto.InternalMessageInfo

// KubeAWS contains the AWS information about the cluster.
type KubeAWS struct {
	// Region is a AWS cloud region.
	Region string `protobuf:"bytes,1,opt,name=Region,proto3" json:"region,omitempty"`
	// AccountID is a AWS Account ID.
	AccountID string `protobuf:"bytes,2,opt,name=AccountID,proto3" json:"account_id,omitempty"`
	// Name is a AWS EKS cluster name.
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubeAWS) Reset()         { *m = KubeAWS{} }
func (m *KubeAWS) String() string { return proto.CompactTextString(m) }
func (*KubeAWS) ProtoMessage()    {}
func (*KubeAWS) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{172}
}
func (m *KubeAWS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubeAWS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubeAWS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubeAWS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubeAWS.Merge(m, src)
}
func (m *KubeAWS) XXX_Size() int {
	return m.Size()
}
func (m *KubeAWS) XXX_DiscardUnknown() {
	xxx_messageInfo_KubeAWS.DiscardUnknown(m)
}

var xxx_messageInfo_KubeAWS proto.InternalMessageInfo

// KubeGCP contains the GCP information about the cluster.
type KubeGCP struct {
	// Location is a GKE cluster location.
	Location string `protobuf:"bytes,1,opt,name=Location,proto3" json:"location,omitempty"`
	// ProjectID is the GKE Project ID.
	ProjectID string `protobuf:"bytes,2,opt,name=ProjectID,proto3" json:"project_id,omitempty"`
	// Name is a GCP GKE cluster name.
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubeGCP) Reset()         { *m = KubeGCP{} }
func (m *KubeGCP) String() string { return proto.CompactTextString(m) }
func (*KubeGCP) ProtoMessage()    {}
func (*KubeGCP) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{173}
}
func (m *KubeGCP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubeGCP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubeGCP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubeGCP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubeGCP.Merge(m, src)
}
func (m *KubeGCP) XXX_Size() int {
	return m.Size()
}
func (m *KubeGCP) XXX_DiscardUnknown() {
	xxx_messageInfo_KubeGCP.DiscardUnknown(m)
}

var xxx_messageInfo_KubeGCP proto.InternalMessageInfo

// KubernetesClusterV3List represents a list of kubernetes clusters.
type KubernetesClusterV3List struct {
	// KubernetesClusters is a list of kubernetes clusters resources.
	KubernetesClusters   []*KubernetesClusterV3 `protobuf:"bytes,1,rep,name=KubernetesClusters,proto3" json:"KubernetesClusters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *KubernetesClusterV3List) Reset()         { *m = KubernetesClusterV3List{} }
func (m *KubernetesClusterV3List) String() string { return proto.CompactTextString(m) }
func (*KubernetesClusterV3List) ProtoMessage()    {}
func (*KubernetesClusterV3List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{174}
}
func (m *KubernetesClusterV3List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesClusterV3List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesClusterV3List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesClusterV3List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesClusterV3List.Merge(m, src)
}
func (m *KubernetesClusterV3List) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesClusterV3List) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesClusterV3List.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesClusterV3List proto.InternalMessageInfo

// KubernetesServerV3 represents a Kubernetes server.
type KubernetesServerV3 struct {
	// Kind is the Kubernetes server resource kind. Always "kube_server".
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the Kubernetes server metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the Kubernetes server spec.
	Spec                 KubernetesServerSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *KubernetesServerV3) Reset()      { *m = KubernetesServerV3{} }
func (*KubernetesServerV3) ProtoMessage() {}
func (*KubernetesServerV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{175}
}
func (m *KubernetesServerV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesServerV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesServerV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesServerV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesServerV3.Merge(m, src)
}
func (m *KubernetesServerV3) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesServerV3) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesServerV3.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesServerV3 proto.InternalMessageInfo

// KubernetesServerSpecV3 is the Kubernetes server spec.
type KubernetesServerSpecV3 struct {
	// Version is the Teleport version that the server is running.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"version"`
	// Hostname is the Kubernetes server hostname.
	Hostname string `protobuf:"bytes,2,opt,name=Hostname,proto3" json:"hostname"`
	// HostID is the Kubernetes server host uuid.
	HostID string `protobuf:"bytes,3,opt,name=HostID,proto3" json:"host_id"`
	// Rotation contains the Kubernetes server CA rotation information.
	Rotation Rotation `protobuf:"bytes,4,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// Cluster is a Kubernetes Cluster proxied by this Kubernetes server.
	Cluster *KubernetesClusterV3 `protobuf:"bytes,5,opt,name=Cluster,proto3" json:"cluster"`
	// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
	ProxyIDs             []string `protobuf:"bytes,6,rep,name=ProxyIDs,proto3" json:"proxy_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesServerSpecV3) Reset()         { *m = KubernetesServerSpecV3{} }
func (m *KubernetesServerSpecV3) String() string { return proto.CompactTextString(m) }
func (*KubernetesServerSpecV3) ProtoMessage()    {}
func (*KubernetesServerSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{176}
}
func (m *KubernetesServerSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesServerSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesServerSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesServerSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesServerSpecV3.Merge(m, src)
}
func (m *KubernetesServerSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesServerSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesServerSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesServerSpecV3 proto.InternalMessageInfo

// WebTokenV3 describes a web token. Web tokens are used as a transport to relay bearer tokens
// to the client.
// Initially bound to a web session, these have been factored out into a separate resource to
// enable separate lifecycle management.
type WebTokenV3 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is resource metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec defines the web token
	Spec                 WebTokenSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *WebTokenV3) Reset()      { *m = WebTokenV3{} }
func (*WebTokenV3) ProtoMessage() {}
func (*WebTokenV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{177}
}
func (m *WebTokenV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebTokenV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebTokenV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebTokenV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebTokenV3.Merge(m, src)
}
func (m *WebTokenV3) XXX_Size() int {
	return m.Size()
}
func (m *WebTokenV3) XXX_DiscardUnknown() {
	xxx_messageInfo_WebTokenV3.DiscardUnknown(m)
}

var xxx_messageInfo_WebTokenV3 proto.InternalMessageInfo

// WebTokenSpecV3 is a unique time-limited token bound to a user's web session
type WebTokenSpecV3 struct {
	// User specifies the user the token is bound to.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// Token specifies the token's value.
	Token                string   `protobuf:"bytes,2,opt,name=Token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebTokenSpecV3) Reset()         { *m = WebTokenSpecV3{} }
func (m *WebTokenSpecV3) String() string { return proto.CompactTextString(m) }
func (*WebTokenSpecV3) ProtoMessage()    {}
func (*WebTokenSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{178}
}
func (m *WebTokenSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebTokenSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebTokenSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebTokenSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebTokenSpecV3.Merge(m, src)
}
func (m *WebTokenSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *WebTokenSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_WebTokenSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_WebTokenSpecV3 proto.InternalMessageInfo

// GetWebSessionRequest describes a request to query a web session
type GetWebSessionRequest struct {
	// User specifies the user the web session is for.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// SessionID specifies the web session ID.
	SessionID            string   `protobuf:"bytes,2,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWebSessionRequest) Reset()         { *m = GetWebSessionRequest{} }
func (m *GetWebSessionRequest) String() string { return proto.CompactTextString(m) }
func (*GetWebSessionRequest) ProtoMessage()    {}
func (*GetWebSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{179}
}
func (m *GetWebSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWebSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWebSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWebSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWebSessionRequest.Merge(m, src)
}
func (m *GetWebSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWebSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWebSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWebSessionRequest proto.InternalMessageInfo

// DeleteWebSessionRequest describes a request to delete a web session
type DeleteWebSessionRequest struct {
	// User specifies the user the session is bound to
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// SessionID specifies the web session ID to delete.
	SessionID            string   `protobuf:"bytes,2,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteWebSessionRequest) Reset()         { *m = DeleteWebSessionRequest{} }
func (m *DeleteWebSessionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteWebSessionRequest) ProtoMessage()    {}
func (*DeleteWebSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{180}
}
func (m *DeleteWebSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteWebSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteWebSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteWebSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteWebSessionRequest.Merge(m, src)
}
func (m *DeleteWebSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteWebSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteWebSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteWebSessionRequest proto.InternalMessageInfo

// GetWebTokenRequest describes a request to query a web token
type GetWebTokenRequest struct {
	// User specifies the user the token is for.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// Token specifies the token to get.
	Token                string   `protobuf:"bytes,2,opt,name=Token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWebTokenRequest) Reset()         { *m = GetWebTokenRequest{} }
func (m *GetWebTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GetWebTokenRequest) ProtoMessage()    {}
func (*GetWebTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{181}
}
func (m *GetWebTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWebTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWebTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWebTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWebTokenRequest.Merge(m, src)
}
func (m *GetWebTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWebTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWebTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWebTokenRequest proto.InternalMessageInfo

// DeleteWebTokenRequest describes a request to delete a web token
type DeleteWebTokenRequest struct {
	// User specifies the user the token is for.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// Token specifies the token to delete.
	Token                string   `protobuf:"bytes,2,opt,name=Token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteWebTokenRequest) Reset()         { *m = DeleteWebTokenRequest{} }
func (m *DeleteWebTokenRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteWebTokenRequest) ProtoMessage()    {}
func (*DeleteWebTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{182}
}
func (m *DeleteWebTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteWebTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteWebTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteWebTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteWebTokenRequest.Merge(m, src)
}
func (m *DeleteWebTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteWebTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteWebTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteWebTokenRequest proto.InternalMessageInfo

// ResourceRequest is a request relating to a named resource.
type ResourceRequest struct {
	// Name is the name of the resource.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceRequest) Reset()         { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()    {}
func (*ResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{183}
}
func (m *ResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceRequest.Merge(m, src)
}
func (m *ResourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceRequest proto.InternalMessageInfo

// ResourceWithSecretsRequest is a request relating to a named resource with secrets.
type ResourceWithSecretsRequest struct {
	// Name is the name of the resource.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// WithSecrets specifies whether to load associated secrets.
	WithSecrets          bool     `protobuf:"varint,2,opt,name=WithSecrets,proto3" json:"with_secrets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceWithSecretsRequest) Reset()         { *m = ResourceWithSecretsRequest{} }
func (m *ResourceWithSecretsRequest) String() string { return proto.CompactTextString(m) }
func (*ResourceWithSecretsRequest) ProtoMessage()    {}
func (*ResourceWithSecretsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{184}
}
func (m *ResourceWithSecretsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceWithSecretsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceWithSecretsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceWithSecretsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceWithSecretsRequest.Merge(m, src)
}
func (m *ResourceWithSecretsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResourceWithSecretsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceWithSecretsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceWithSecretsRequest proto.InternalMessageInfo

// ResourcesWithSecretsRequest is a request relating to resources with secrets.
type ResourcesWithSecretsRequest struct {
	// WithSecrets specifies whether to load associated secrets.
	WithSecrets          bool     `protobuf:"varint,1,opt,name=WithSecrets,proto3" json:"with_secrets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourcesWithSecretsRequest) Reset()         { *m = ResourcesWithSecretsRequest{} }
func (m *ResourcesWithSecretsRequest) String() string { return proto.CompactTextString(m) }
func (*ResourcesWithSecretsRequest) ProtoMessage()    {}
func (*ResourcesWithSecretsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{185}
}
func (m *ResourcesWithSecretsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcesWithSecretsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcesWithSecretsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcesWithSecretsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcesWithSecretsRequest.Merge(m, src)
}
func (m *ResourcesWithSecretsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResourcesWithSecretsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcesWithSecretsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcesWithSecretsRequest proto.InternalMessageInfo

// ResourcesInNamespaceRequest is a request relating to a named resource in the given namespace.
type ResourceInNamespaceRequest struct {
	// Name is the name of the resource.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Namespace is the namespace of resources.
	Namespace            string   `protobuf:"bytes,2,opt,name=Namespace,proto3" json:"Namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceInNamespaceRequest) Reset()         { *m = ResourceInNamespaceRequest{} }
func (m *ResourceInNamespaceRequest) String() string { return proto.CompactTextString(m) }
func (*ResourceInNamespaceRequest) ProtoMessage()    {}
func (*ResourceInNamespaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{186}
}
func (m *ResourceInNamespaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceInNamespaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceInNamespaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceInNamespaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceInNamespaceRequest.Merge(m, src)
}
func (m *ResourceInNamespaceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResourceInNamespaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceInNamespaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceInNamespaceRequest proto.InternalMessageInfo

// ResourcesInNamespaceRequest is a request relating to resources in the given namespace.
type ResourcesInNamespaceRequest struct {
	// Namespace is the namespace of resources.
	Namespace            string   `protobuf:"bytes,1,opt,name=Namespace,proto3" json:"Namespace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourcesInNamespaceRequest) Reset()         { *m = ResourcesInNamespaceRequest{} }
func (m *ResourcesInNamespaceRequest) String() string { return proto.CompactTextString(m) }
func (*ResourcesInNamespaceRequest) ProtoMessage()    {}
func (*ResourcesInNamespaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{187}
}
func (m *ResourcesInNamespaceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcesInNamespaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcesInNamespaceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcesInNamespaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcesInNamespaceRequest.Merge(m, src)
}
func (m *ResourcesInNamespaceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResourcesInNamespaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcesInNamespaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcesInNamespaceRequest proto.InternalMessageInfo

// OIDCConnectorV3 represents an OIDC connector.
type OIDCConnectorV3 struct {
	// Kind is a resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v3`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata holds resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is an OIDC connector specification.
	Spec                 OIDCConnectorSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *OIDCConnectorV3) Reset()         { *m = OIDCConnectorV3{} }
func (m *OIDCConnectorV3) String() string { return proto.CompactTextString(m) }
func (*OIDCConnectorV3) ProtoMessage()    {}
func (*OIDCConnectorV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{188}
}
func (m *OIDCConnectorV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCConnectorV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCConnectorV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCConnectorV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCConnectorV3.Merge(m, src)
}
func (m *OIDCConnectorV3) XXX_Size() int {
	return m.Size()
}
func (m *OIDCConnectorV3) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCConnectorV3.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCConnectorV3 proto.InternalMessageInfo

// OIDCConnectorV3List is a list of OIDC connectors.
type OIDCConnectorV3List struct {
	// OIDCConnectors is a list of OIDC connectors.
	OIDCConnectors       []*OIDCConnectorV3 `protobuf:"bytes,1,rep,name=OIDCConnectors,proto3" json:"OIDCConnectors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *OIDCConnectorV3List) Reset()         { *m = OIDCConnectorV3List{} }
func (m *OIDCConnectorV3List) String() string { return proto.CompactTextString(m) }
func (*OIDCConnectorV3List) ProtoMessage()    {}
func (*OIDCConnectorV3List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{189}
}
func (m *OIDCConnectorV3List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCConnectorV3List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCConnectorV3List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCConnectorV3List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCConnectorV3List.Merge(m, src)
}
func (m *OIDCConnectorV3List) XXX_Size() int {
	return m.Size()
}
func (m *OIDCConnectorV3List) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCConnectorV3List.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCConnectorV3List proto.InternalMessageInfo

// OIDCConnectorSpecV3 is an OIDC connector specification.
//
// It specifies configuration for Open ID Connect compatible external
// identity provider: https://openid.net/specs/openid-connect-core-1_0.html
type OIDCConnectorSpecV3 struct {
	// IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
	IssuerURL string `protobuf:"bytes,1,opt,name=IssuerURL,proto3" json:"issuer_url"`
	// ClientID is the id of the authentication client (Teleport Auth server).
	ClientID string `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"client_id"`
	// ClientSecret is used to authenticate the client.
	ClientSecret string `protobuf:"bytes,3,opt,name=ClientSecret,proto3" json:"client_secret"`
	// ACR is an Authentication Context Class Reference value. The meaning of the ACR
	// value is context-specific and varies for identity providers.
	ACR string `protobuf:"bytes,5,opt,name=ACR,proto3" json:"acr_values,omitempty"`
	// Provider is the external identity provider.
	Provider string `protobuf:"bytes,6,opt,name=Provider,proto3" json:"provider,omitempty"`
	// Display is the friendly name for this provider.
	Display string `protobuf:"bytes,7,opt,name=Display,proto3" json:"display,omitempty"`
	// Scope specifies additional scopes set by provider.
	Scope []string `protobuf:"bytes,8,rep,name=Scope,proto3" json:"scope,omitempty"`
	// Prompt is an optional OIDC prompt. An empty string omits prompt.
	// If not specified, it defaults to select_account for backwards compatibility.
	Prompt string `protobuf:"bytes,9,opt,name=Prompt,proto3" json:"prompt,omitempty"`
	// ClaimsToRoles specifies a dynamic mapping from claims to roles.
	ClaimsToRoles []ClaimMapping `protobuf:"bytes,10,rep,name=ClaimsToRoles,proto3" json:"claims_to_roles,omitempty"`
	// GoogleServiceAccountURI is a path to a google service account uri.
	GoogleServiceAccountURI string `protobuf:"bytes,11,opt,name=GoogleServiceAccountURI,proto3" json:"google_service_account_uri,omitempty"`
	// GoogleServiceAccount is a string containing google service account credentials.
	GoogleServiceAccount string `protobuf:"bytes,12,opt,name=GoogleServiceAccount,proto3" json:"google_service_account,omitempty"`
	// GoogleAdminEmail is the email of a google admin to impersonate.
	GoogleAdminEmail string `protobuf:"bytes,13,opt,name=GoogleAdminEmail,proto3" json:"google_admin_email,omitempty"`
	// RedirectURLs is a list of callback URLs which the identity provider can use
	// to redirect the client back to the Teleport Proxy to complete authentication.
	// This list should match the URLs on the provider's side. The URL used for a
	// given auth request will be chosen to match the requesting Proxy's public
	// address. If there is no match, the first url in the list will be used.
	RedirectURLs github_com_gravitational_teleport_api_types_wrappers.Strings `protobuf:"bytes,14,opt,name=RedirectURLs,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Strings" json:"redirect_url"`
	// AllowUnverifiedEmail tells the connector to accept OIDC users with unverified emails.
	AllowUnverifiedEmail bool `protobuf:"varint,15,opt,name=AllowUnverifiedEmail,proto3" json:"allow_unverified_email,omitempty"`
	// UsernameClaim specifies the name of the claim from the OIDC connector to be used as the user's username.
	UsernameClaim string `protobuf:"bytes,16,opt,name=UsernameClaim,proto3" json:"username_claim,omitempty"`
	// MaxAge is the amount of time that user logins are
	// valid for. If a user logs in, but then does not login again
	// within this time period, they will be forced to re-authenticate.
	*MaxAge `protobuf:"bytes,17,opt,name=MaxAge,proto3,embedded=MaxAge" json:""`
	// ClientRedirectSettings defines which client redirect URLs are allowed for
	// non-browser SSO logins other than the standard localhost ones.
	ClientRedirectSettings *SSOClientRedirectSettings `protobuf:"bytes,18,opt,name=ClientRedirectSettings,proto3" json:"client_redirect_settings,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                   `json:"-"`
	XXX_unrecognized       []byte                     `json:"-"`
	XXX_sizecache          int32                      `json:"-"`
}

func (m *OIDCConnectorSpecV3) Reset()         { *m = OIDCConnectorSpecV3{} }
func (m *OIDCConnectorSpecV3) String() string { return proto.CompactTextString(m) }
func (*OIDCConnectorSpecV3) ProtoMessage()    {}
func (*OIDCConnectorSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{190}
}
func (m *OIDCConnectorSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCConnectorSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCConnectorSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCConnectorSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCConnectorSpecV3.Merge(m, src)
}
func (m *OIDCConnectorSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *OIDCConnectorSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCConnectorSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCConnectorSpecV3 proto.InternalMessageInfo

// MaxAge allows the max_age parameter to be nullable to preserve backwards
// compatibility. The duration is stored as nanoseconds.
type MaxAge struct {
	Value                Duration `protobuf:"varint,1,opt,name=Value,proto3,casttype=Duration" json:"max_age"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaxAge) Reset()         { *m = MaxAge{} }
func (m *MaxAge) String() string { return proto.CompactTextString(m) }
func (*MaxAge) ProtoMessage()    {}
func (*MaxAge) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{191}
}
func (m *MaxAge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxAge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxAge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxAge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxAge.Merge(m, src)
}
func (m *MaxAge) XXX_Size() int {
	return m.Size()
}
func (m *MaxAge) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxAge.DiscardUnknown(m)
}

var xxx_messageInfo_MaxAge proto.InternalMessageInfo

// SSOClientRedirectSettings contains settings to define which additional client
// redirect URLs should be allowed for non-browser SSO logins.
type SSOClientRedirectSettings struct {
	// a list of hostnames allowed for https client redirect URLs
	AllowedHttpsHostnames []string `protobuf:"bytes,1,rep,name=allowed_https_hostnames,json=allowedHttpsHostnames,proto3" json:"allowed_https_hostnames,omitempty"`
	// a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
	InsecureAllowedCidrRanges []string `protobuf:"bytes,2,rep,name=insecure_allowed_cidr_ranges,json=insecureAllowedCidrRanges,proto3" json:"insecure_allowed_cidr_ranges,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *SSOClientRedirectSettings) Reset()         { *m = SSOClientRedirectSettings{} }
func (m *SSOClientRedirectSettings) String() string { return proto.CompactTextString(m) }
func (*SSOClientRedirectSettings) ProtoMessage()    {}
func (*SSOClientRedirectSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{192}
}
func (m *SSOClientRedirectSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSOClientRedirectSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSOClientRedirectSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSOClientRedirectSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSOClientRedirectSettings.Merge(m, src)
}
func (m *SSOClientRedirectSettings) XXX_Size() int {
	return m.Size()
}
func (m *SSOClientRedirectSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_SSOClientRedirectSettings.DiscardUnknown(m)
}

var xxx_messageInfo_SSOClientRedirectSettings proto.InternalMessageInfo

// OIDCAuthRequest is a request to authenticate with OIDC
// provider, the state about request is managed by auth server
type OIDCAuthRequest struct {
	// ConnectorID is ID of OIDC connector this request uses
	ConnectorID string `protobuf:"bytes,1,opt,name=ConnectorID,proto3" json:"connector_id"`
	// Type is opaque string that helps callbacks identify the request type
	Type string `protobuf:"bytes,2,opt,name=Type,proto3" json:"type"`
	// CheckUser tells validator if it should expect and check user
	CheckUser bool `protobuf:"varint,3,opt,name=CheckUser,proto3" json:"check_user"`
	// StateToken is generated by service and is used to validate
	// request coming from
	StateToken string `protobuf:"bytes,4,opt,name=StateToken,proto3" json:"state_token"`
	// CSRFToken is associated with user web session token
	CSRFToken string `protobuf:"bytes,5,opt,name=CSRFToken,proto3" json:"csrf_token"`
	// RedirectURL will be used to route the user back to a
	// Teleport Proxy after the oidc login attempt in the browser.
	RedirectURL string `protobuf:"bytes,6,opt,name=RedirectURL,proto3" json:"redirect_url"`
	// PublicKey is an optional public key, users want these keys to be signed by
	// auth servers user CA in case of successful auth.
	//
	// Deprecated: prefer SshPublicKey and/or TlsPublicKey.
	PublicKey []byte `protobuf:"bytes,7,opt,name=PublicKey,proto3" json:"public_key"` // Deprecated: Do not use.
	// CertTTL is the TTL of the certificate user wants to get
	CertTTL time.Duration `protobuf:"varint,8,opt,name=CertTTL,proto3,casttype=time.Duration" json:"cert_ttl"`
	// CreateWebSession indicates if user wants to generate a web
	// session after successful authentication
	CreateWebSession bool `protobuf:"varint,9,opt,name=CreateWebSession,proto3" json:"create_web_session"`
	// ClientRedirectURL is a URL client wants to be redirected
	// after successful authentication
	ClientRedirectURL string `protobuf:"bytes,10,opt,name=ClientRedirectURL,proto3" json:"client_redirect_url"`
	// Compatibility specifies OpenSSH compatibility flags.
	Compatibility string `protobuf:"bytes,11,opt,name=Compatibility,proto3" json:"compatibility,omitempty"`
	// RouteToCluster is the name of Teleport cluster to issue credentials for.
	RouteToCluster string `protobuf:"bytes,12,opt,name=RouteToCluster,proto3" json:"route_to_cluster,omitempty"`
	// KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
	KubernetesCluster string `protobuf:"bytes,13,opt,name=KubernetesCluster,proto3" json:"kubernetes_cluster,omitempty"`
	// SSOTestFlow indicates if the request is part of the test flow.
	SSOTestFlow bool `protobuf:"varint,14,opt,name=SSOTestFlow,proto3" json:"sso_test_flow"`
	// ConnectorSpec is embedded connector spec for use in test flow.
	ConnectorSpec *OIDCConnectorSpecV3 `protobuf:"bytes,15,opt,name=ConnectorSpec,proto3" json:"connector_spec,omitempty"`
	// ProxyAddress is an optional address which can be used to
	// find a redirect url from the OIDC connector which matches
	// the address. If there is no match, the default redirect
	// url will be used.
	ProxyAddress string `protobuf:"bytes,16,opt,name=ProxyAddress,proto3" json:"proxy_address,omitempty"`
	// attestation_statement is an attestation statement for the given public key.
	//
	// Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
	AttestationStatement *v1.AttestationStatement `protobuf:"bytes,17,opt,name=attestation_statement,json=attestationStatement,proto3" json:"attestation_statement,omitempty"` // Deprecated: Do not use.
	// ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
	ClientLoginIP string `protobuf:"bytes,18,opt,name=ClientLoginIP,proto3" json:"client_login_ip,omitempty"`
	// ClientUserAgent is the user agent of the Web browser, used for issuing a
	// DeviceWebToken.
	ClientUserAgent string `protobuf:"bytes,19,opt,name=ClientUserAgent,proto3" json:"client_user_agent,omitempty"`
	// SshPublicKey is an optional public key to use as the subject of an issued
	// SSH cert in case of successful auth.
	SshPublicKey []byte `protobuf:"bytes,20,opt,name=ssh_public_key,json=sshPublicKey,proto3" json:"ssh_pub_key,omitempty"`
	// TlsPublicKey is an optional public key to use as the subject of an issued
	// TLS cert in case of successful auth.
	TlsPublicKey []byte `protobuf:"bytes,21,opt,name=tls_public_key,json=tlsPublicKey,proto3" json:"tls_pub_key,omitempty"`
	// SshAttestationStatement is an attestation statement for the given SSH public key.
	SshAttestationStatement *v1.AttestationStatement `protobuf:"bytes,22,opt,name=ssh_attestation_statement,json=sshAttestationStatement,proto3" json:"ssh_attestation_statement,omitempty"`
	// TlsAttestationStatement is an attestation statement for the given TLS public key.
	TlsAttestationStatement *v1.AttestationStatement `protobuf:"bytes,23,opt,name=tls_attestation_statement,json=tlsAttestationStatement,proto3" json:"tls_attestation_statement,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *OIDCAuthRequest) Reset()         { *m = OIDCAuthRequest{} }
func (m *OIDCAuthRequest) String() string { return proto.CompactTextString(m) }
func (*OIDCAuthRequest) ProtoMessage()    {}
func (*OIDCAuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{193}
}
func (m *OIDCAuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDCAuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDCAuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDCAuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDCAuthRequest.Merge(m, src)
}
func (m *OIDCAuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *OIDCAuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDCAuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OIDCAuthRequest proto.InternalMessageInfo

// SAMLConnectorV2 represents a SAML connector.
type SAMLConnectorV2 struct {
	// Kind is a resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata holds resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is an SAML connector specification.
	Spec                 SAMLConnectorSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SAMLConnectorV2) Reset()         { *m = SAMLConnectorV2{} }
func (m *SAMLConnectorV2) String() string { return proto.CompactTextString(m) }
func (*SAMLConnectorV2) ProtoMessage()    {}
func (*SAMLConnectorV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{194}
}
func (m *SAMLConnectorV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLConnectorV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLConnectorV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLConnectorV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLConnectorV2.Merge(m, src)
}
func (m *SAMLConnectorV2) XXX_Size() int {
	return m.Size()
}
func (m *SAMLConnectorV2) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLConnectorV2.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLConnectorV2 proto.InternalMessageInfo

// SAMLConnectorV2List is a list of SAML connectors.
type SAMLConnectorV2List struct {
	// SAMLConnectors is a list of SAML connectors.
	SAMLConnectors       []*SAMLConnectorV2 `protobuf:"bytes,1,rep,name=SAMLConnectors,proto3" json:"SAMLConnectors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SAMLConnectorV2List) Reset()         { *m = SAMLConnectorV2List{} }
func (m *SAMLConnectorV2List) String() string { return proto.CompactTextString(m) }
func (*SAMLConnectorV2List) ProtoMessage()    {}
func (*SAMLConnectorV2List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{195}
}
func (m *SAMLConnectorV2List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLConnectorV2List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLConnectorV2List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLConnectorV2List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLConnectorV2List.Merge(m, src)
}
func (m *SAMLConnectorV2List) XXX_Size() int {
	return m.Size()
}
func (m *SAMLConnectorV2List) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLConnectorV2List.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLConnectorV2List proto.InternalMessageInfo

// SAMLConnectorSpecV2 is a SAML connector specification.
type SAMLConnectorSpecV2 struct {
	// Issuer is the identity provider issuer.
	Issuer string `protobuf:"bytes,1,opt,name=Issuer,proto3" json:"issuer"`
	// SSO is the URL of the identity provider's SSO service.
	SSO string `protobuf:"bytes,2,opt,name=SSO,proto3" json:"sso"`
	// Cert is the identity provider certificate PEM.
	// IDP signs `<Response>` responses using this certificate.
	Cert string `protobuf:"bytes,3,opt,name=Cert,proto3" json:"cert"`
	// Display controls how this connector is displayed.
	Display string `protobuf:"bytes,4,opt,name=Display,proto3" json:"display"`
	// AssertionConsumerService is a URL for assertion consumer service
	// on the service provider (Teleport's side).
	AssertionConsumerService string `protobuf:"bytes,5,opt,name=AssertionConsumerService,proto3" json:"acs"`
	// Audience uniquely identifies our service provider.
	Audience string `protobuf:"bytes,6,opt,name=Audience,proto3" json:"audience"`
	// ServiceProviderIssuer is the issuer of the service provider (Teleport).
	ServiceProviderIssuer string `protobuf:"bytes,7,opt,name=ServiceProviderIssuer,proto3" json:"service_provider_issuer"`
	// EntityDescriptor is XML with descriptor. It can be used to supply configuration
	// parameters in one XML file rather than supplying them in the individual elements.
	EntityDescriptor string `protobuf:"bytes,8,opt,name=EntityDescriptor,proto3" json:"entity_descriptor"`
	// EntityDescriptorURL is a URL that supplies a configuration XML.
	EntityDescriptorURL string `protobuf:"bytes,9,opt,name=EntityDescriptorURL,proto3" json:"entity_descriptor_url"`
	// AttributesToRoles is a list of mappings of attribute statements to roles.
	AttributesToRoles []AttributeMapping `protobuf:"bytes,10,rep,name=AttributesToRoles,proto3" json:"attributes_to_roles"`
	// SigningKeyPair is an x509 key pair used to sign AuthnRequest.
	SigningKeyPair *AsymmetricKeyPair `protobuf:"bytes,11,opt,name=SigningKeyPair,proto3" json:"signing_key_pair,omitempty"`
	// Provider is the external identity provider.
	Provider string `protobuf:"bytes,12,opt,name=Provider,proto3" json:"provider,omitempty"`
	// EncryptionKeyPair is a key pair used for decrypting SAML assertions.
	EncryptionKeyPair *AsymmetricKeyPair `protobuf:"bytes,13,opt,name=EncryptionKeyPair,proto3" json:"assertion_key_pair,omitempty"`
	// AllowIDPInitiated is a flag that indicates if the connector can be used for IdP-initiated
	// logins.
	AllowIDPInitiated bool `protobuf:"varint,14,opt,name=AllowIDPInitiated,proto3" json:"allow_idp_initiated,omitempty"`
	// ClientRedirectSettings defines which client redirect URLs are allowed for
	// non-browser SSO logins other than the standard localhost ones.
	ClientRedirectSettings *SSOClientRedirectSettings `protobuf:"bytes,15,opt,name=ClientRedirectSettings,proto3" json:"client_redirect_settings,omitempty"`
	// SingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out). If this is not provided, SLO is disabled.
	SingleLogoutURL      string   `protobuf:"bytes,16,opt,name=SingleLogoutURL,proto3" json:"single_logout_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SAMLConnectorSpecV2) Reset()         { *m = SAMLConnectorSpecV2{} }
func (m *SAMLConnectorSpecV2) String() string { return proto.CompactTextString(m) }
func (*SAMLConnectorSpecV2) ProtoMessage()    {}
func (*SAMLConnectorSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{196}
}
func (m *SAMLConnectorSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLConnectorSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLConnectorSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLConnectorSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLConnectorSpecV2.Merge(m, src)
}
func (m *SAMLConnectorSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *SAMLConnectorSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLConnectorSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLConnectorSpecV2 proto.InternalMessageInfo

// SAMLAuthRequest is a request to authenticate with SAML
// provider, the state about request is managed by auth server.
type SAMLAuthRequest struct {
	// ID is a unique request ID.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"id"`
	// ConnectorID is ID of OIDC connector this request uses.
	ConnectorID string `protobuf:"bytes,2,opt,name=ConnectorID,proto3" json:"connector_id"`
	// Type is opaque string that helps callbacks identify the request type.
	Type string `protobuf:"bytes,3,opt,name=Type,proto3" json:"type"`
	// CheckUser tells validator if it should expect and check user.
	CheckUser bool `protobuf:"varint,4,opt,name=CheckUser,proto3" json:"check_user"`
	// RedirectURL will be used by browser.
	RedirectURL string `protobuf:"bytes,5,opt,name=RedirectURL,proto3" json:"redirect_url"`
	// PublicKey is an optional public key, users want these
	// keys to be signed by auth servers user CA in case
	// of successful auth.
	//
	// Deprecated: prefer SshPublicKey and/or TlsPublicKey.
	PublicKey []byte `protobuf:"bytes,6,opt,name=PublicKey,proto3" json:"public_key"` // Deprecated: Do not use.
	// CertTTL is the TTL of the certificate user wants to get.
	CertTTL time.Duration `protobuf:"varint,7,opt,name=CertTTL,proto3,casttype=time.Duration" json:"cert_ttl"`
	// CSRFToken is associated with user web session token.
	CSRFToken string `protobuf:"bytes,8,opt,name=CSRFToken,proto3" json:"csrf_token"`
	// CreateWebSession indicates if user wants to generate a web
	// session after successful authentication.
	CreateWebSession bool `protobuf:"varint,9,opt,name=CreateWebSession,proto3" json:"create_web_session"`
	// ClientRedirectURL is a URL client wants to be redirected
	// after successful authentication.
	ClientRedirectURL string `protobuf:"bytes,10,opt,name=ClientRedirectURL,proto3" json:"client_redirect_url"`
	// Compatibility specifies OpenSSH compatibility flags.
	Compatibility string `protobuf:"bytes,11,opt,name=Compatibility,proto3" json:"compatibility,omitempty"`
	// RouteToCluster is the name of Teleport cluster to issue credentials for.
	RouteToCluster string `protobuf:"bytes,12,opt,name=RouteToCluster,proto3" json:"route_to_cluster,omitempty"`
	// KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
	KubernetesCluster string `protobuf:"bytes,13,opt,name=KubernetesCluster,proto3" json:"kubernetes_cluster,omitempty"`
	// SSOTestFlow indicates if the request is part of the test flow.
	SSOTestFlow bool `protobuf:"varint,14,opt,name=SSOTestFlow,proto3" json:"sso_test_flow"`
	// ConnectorSpec is embedded connector spec for use in test flow.
	ConnectorSpec *SAMLConnectorSpecV2 `protobuf:"bytes,15,opt,name=ConnectorSpec,proto3" json:"connector_spec,omitempty"`
	// attestation_statement is an attestation statement for the given public key.
	//
	// Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
	AttestationStatement *v1.AttestationStatement `protobuf:"bytes,16,opt,name=attestation_statement,json=attestationStatement,proto3" json:"attestation_statement,omitempty"`
	// ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
	ClientLoginIP string `protobuf:"bytes,17,opt,name=ClientLoginIP,proto3" json:"client_login_ip,omitempty"`
	// ClientUserAgent is the user agent of the Web browser, used for issuing a
	// DeviceWebToken.
	ClientUserAgent string `protobuf:"bytes,18,opt,name=ClientUserAgent,proto3" json:"client_user_agent,omitempty"`
	// SshPublicKey is an optional public key to use as the subject of an issued
	// SSH cert in case of successful auth.
	SshPublicKey []byte `protobuf:"bytes,19,opt,name=ssh_public_key,json=sshPublicKey,proto3" json:"ssh_pub_key,omitempty"`
	// TlsPublicKey is an optional public key to use as the subject of an issued
	// TLS cert in case of successful auth.
	TlsPublicKey []byte `protobuf:"bytes,20,opt,name=tls_public_key,json=tlsPublicKey,proto3" json:"tls_pub_key,omitempty"`
	// SshAttestationStatement is an attestation statement for the given SSH public key.
	SshAttestationStatement *v1.AttestationStatement `protobuf:"bytes,21,opt,name=ssh_attestation_statement,json=sshAttestationStatement,proto3" json:"ssh_attestation_statement,omitempty"`
	// TlsAttestationStatement is an attestation statement for the given TLS public key.
	TlsAttestationStatement *v1.AttestationStatement `protobuf:"bytes,22,opt,name=tls_attestation_statement,json=tlsAttestationStatement,proto3" json:"tls_attestation_statement,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *SAMLAuthRequest) Reset()         { *m = SAMLAuthRequest{} }
func (m *SAMLAuthRequest) String() string { return proto.CompactTextString(m) }
func (*SAMLAuthRequest) ProtoMessage()    {}
func (*SAMLAuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{197}
}
func (m *SAMLAuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLAuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLAuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLAuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLAuthRequest.Merge(m, src)
}
func (m *SAMLAuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *SAMLAuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLAuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLAuthRequest proto.InternalMessageInfo

// AttributeMapping maps a SAML attribute statement to teleport roles.
type AttributeMapping struct {
	// Name is an attribute statement name.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Value is an attribute statement value to match.
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
	// Roles is a list of static teleport roles to map to.
	Roles                []string `protobuf:"bytes,3,rep,name=Roles,proto3" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttributeMapping) Reset()         { *m = AttributeMapping{} }
func (m *AttributeMapping) String() string { return proto.CompactTextString(m) }
func (*AttributeMapping) ProtoMessage()    {}
func (*AttributeMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{198}
}
func (m *AttributeMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttributeMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttributeMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttributeMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeMapping.Merge(m, src)
}
func (m *AttributeMapping) XXX_Size() int {
	return m.Size()
}
func (m *AttributeMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeMapping.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeMapping proto.InternalMessageInfo

// AsymmetricKeyPair is a combination of a public certificate and
// private key that can be used for encryption and signing.
type AsymmetricKeyPair struct {
	// PrivateKey is a PEM encoded x509 private key.
	PrivateKey string `protobuf:"bytes,1,opt,name=PrivateKey,proto3" json:"private_key"`
	// Cert is a PEM-encoded x509 certificate.
	Cert                 string   `protobuf:"bytes,2,opt,name=Cert,proto3" json:"cert"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AsymmetricKeyPair) Reset()         { *m = AsymmetricKeyPair{} }
func (m *AsymmetricKeyPair) String() string { return proto.CompactTextString(m) }
func (*AsymmetricKeyPair) ProtoMessage()    {}
func (*AsymmetricKeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{199}
}
func (m *AsymmetricKeyPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsymmetricKeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AsymmetricKeyPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AsymmetricKeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsymmetricKeyPair.Merge(m, src)
}
func (m *AsymmetricKeyPair) XXX_Size() int {
	return m.Size()
}
func (m *AsymmetricKeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_AsymmetricKeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_AsymmetricKeyPair proto.InternalMessageInfo

// GithubConnectorV3 represents a Github connector.
type GithubConnectorV3 struct {
	// Kind is a resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v3`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata holds resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is an Github connector specification.
	Spec                 GithubConnectorSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GithubConnectorV3) Reset()         { *m = GithubConnectorV3{} }
func (m *GithubConnectorV3) String() string { return proto.CompactTextString(m) }
func (*GithubConnectorV3) ProtoMessage()    {}
func (*GithubConnectorV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{200}
}
func (m *GithubConnectorV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubConnectorV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GithubConnectorV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GithubConnectorV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubConnectorV3.Merge(m, src)
}
func (m *GithubConnectorV3) XXX_Size() int {
	return m.Size()
}
func (m *GithubConnectorV3) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubConnectorV3.DiscardUnknown(m)
}

var xxx_messageInfo_GithubConnectorV3 proto.InternalMessageInfo

// GithubConnectorV3List is a list of Github connectors.
type GithubConnectorV3List struct {
	// GithubConnectors is a list of Github connectors.
	GithubConnectors     []*GithubConnectorV3 `protobuf:"bytes,1,rep,name=GithubConnectors,proto3" json:"GithubConnectors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GithubConnectorV3List) Reset()         { *m = GithubConnectorV3List{} }
func (m *GithubConnectorV3List) String() string { return proto.CompactTextString(m) }
func (*GithubConnectorV3List) ProtoMessage()    {}
func (*GithubConnectorV3List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{201}
}
func (m *GithubConnectorV3List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubConnectorV3List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GithubConnectorV3List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GithubConnectorV3List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubConnectorV3List.Merge(m, src)
}
func (m *GithubConnectorV3List) XXX_Size() int {
	return m.Size()
}
func (m *GithubConnectorV3List) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubConnectorV3List.DiscardUnknown(m)
}

var xxx_messageInfo_GithubConnectorV3List proto.InternalMessageInfo

// GithubConnectorSpecV3 is a Github connector specification.
type GithubConnectorSpecV3 struct {
	// ClientID is the Github OAuth app client ID.
	ClientID string `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"client_id"`
	// ClientSecret is the Github OAuth app client secret.
	ClientSecret string `protobuf:"bytes,2,opt,name=ClientSecret,proto3" json:"client_secret"`
	// RedirectURL is the authorization callback URL.
	RedirectURL string `protobuf:"bytes,3,opt,name=RedirectURL,proto3" json:"redirect_url"`
	// TeamsToLogins maps Github team memberships onto allowed logins/roles.
	//
	// DELETE IN 11.0.0
	// Deprecated: use GithubTeamsToRoles instead.
	TeamsToLogins []TeamMapping `protobuf:"bytes,4,rep,name=TeamsToLogins,proto3" json:"teams_to_logins"`
	// Display is the connector display name.
	Display string `protobuf:"bytes,5,opt,name=Display,proto3" json:"display"`
	// TeamsToRoles maps Github team memberships onto allowed roles.
	TeamsToRoles []TeamRolesMapping `protobuf:"bytes,6,rep,name=TeamsToRoles,proto3" json:"teams_to_roles"`
	// EndpointURL is the URL of the GitHub instance this connector is for.
	EndpointURL string `protobuf:"bytes,7,opt,name=EndpointURL,proto3" json:"endpoint_url"`
	// APIEndpointURL is the URL of the API endpoint of the Github instance
	// this connector is for.
	APIEndpointURL string `protobuf:"bytes,8,opt,name=APIEndpointURL,proto3" json:"api_endpoint_url"`
	// ClientRedirectSettings defines which client redirect URLs are allowed for
	// non-browser SSO logins other than the standard localhost ones.
	ClientRedirectSettings *SSOClientRedirectSettings `protobuf:"bytes,9,opt,name=ClientRedirectSettings,proto3" json:"client_redirect_settings,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                   `json:"-"`
	XXX_unrecognized       []byte                     `json:"-"`
	XXX_sizecache          int32                      `json:"-"`
}

func (m *GithubConnectorSpecV3) Reset()         { *m = GithubConnectorSpecV3{} }
func (m *GithubConnectorSpecV3) String() string { return proto.CompactTextString(m) }
func (*GithubConnectorSpecV3) ProtoMessage()    {}
func (*GithubConnectorSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{202}
}
func (m *GithubConnectorSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubConnectorSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GithubConnectorSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GithubConnectorSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubConnectorSpecV3.Merge(m, src)
}
func (m *GithubConnectorSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *GithubConnectorSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubConnectorSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_GithubConnectorSpecV3 proto.InternalMessageInfo

// GithubAuthRequest is the request to start Github OAuth2 flow.
type GithubAuthRequest struct {
	// ConnectorID is the name of the connector to use.
	ConnectorID string `protobuf:"bytes,1,opt,name=ConnectorID,proto3" json:"connector_id"`
	// Type is opaque string that helps callbacks identify the request type.
	Type string `protobuf:"bytes,2,opt,name=Type,proto3" json:"type"`
	// StateToken is used to validate the request.
	StateToken string `protobuf:"bytes,3,opt,name=StateToken,proto3" json:"state_token"`
	// CSRFToken is used to protect against CSRF attacks.
	CSRFToken string `protobuf:"bytes,4,opt,name=CSRFToken,proto3" json:"csrf_token"`
	// PublicKey is an optional public key to sign in case of successful auth.
	//
	// Deprecated: prefer SshPublicKey and/or TlsPublicKey.
	PublicKey []byte `protobuf:"bytes,5,opt,name=PublicKey,proto3" json:"public_key"` // Deprecated: Do not use.
	// CertTTL is TTL of the cert that's generated in case of successful auth.
	CertTTL time.Duration `protobuf:"varint,6,opt,name=CertTTL,proto3,casttype=time.Duration" json:"cert_ttl"`
	// CreateWebSession indicates that a user wants to generate a web session
	// after successful authentication.
	CreateWebSession bool `protobuf:"varint,7,opt,name=CreateWebSession,proto3" json:"create_web_session"`
	// RedirectURL will be used by browser.
	RedirectURL string `protobuf:"bytes,8,opt,name=RedirectURL,proto3" json:"redirect_url"`
	// ClientRedirectURL is the URL where client will be redirected after
	// successful auth.
	ClientRedirectURL string `protobuf:"bytes,9,opt,name=ClientRedirectURL,proto3" json:"client_redirect_url"`
	// Compatibility specifies OpenSSH compatibility flags.
	Compatibility string `protobuf:"bytes,10,opt,name=Compatibility,proto3" json:"compatibility,omitempty"`
	// Expires is a global expiry time header can be set on any resource in the system.
	Expires *time.Time `protobuf:"bytes,11,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// RouteToCluster is the name of Teleport cluster to issue credentials for.
	RouteToCluster string `protobuf:"bytes,12,opt,name=RouteToCluster,proto3" json:"route_to_cluster,omitempty"`
	// KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
	KubernetesCluster string `protobuf:"bytes,13,opt,name=KubernetesCluster,proto3" json:"kubernetes_cluster,omitempty"`
	// SSOTestFlow indicates if the request is part of the test flow.
	SSOTestFlow bool `protobuf:"varint,14,opt,name=SSOTestFlow,proto3" json:"sso_test_flow"`
	// ConnectorSpec is embedded connector spec for use in test flow.
	ConnectorSpec *GithubConnectorSpecV3 `protobuf:"bytes,15,opt,name=ConnectorSpec,proto3" json:"connector_spec,omitempty"`
	// AttestationStatement is an attestation statement for the given public key.
	//
	// Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
	AttestationStatement *v1.AttestationStatement `protobuf:"bytes,16,opt,name=attestation_statement,json=attestationStatement,proto3" json:"attestation_statement,omitempty"` // Deprecated: Do not use.
	// ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
	ClientLoginIP string `protobuf:"bytes,17,opt,name=ClientLoginIP,proto3" json:"client_login_ip,omitempty"`
	// ClientUserAgent is the user agent of the Web browser, used for issuing
	// a DeviceWebToken.
	ClientUserAgent string `protobuf:"bytes,18,opt,name=ClientUserAgent,proto3" json:"client_user_agent,omitempty"`
	// SshPublicKey is an optional public key to use as the subject of an issued
	// SSH cert in case of successful auth.
	SshPublicKey []byte `protobuf:"bytes,19,opt,name=ssh_public_key,json=sshPublicKey,proto3" json:"ssh_pub_key,omitempty"`
	// TlsPublicKey is an optional public key to use as the subject of an issued
	// TLS cert in case of successful auth.
	TlsPublicKey []byte `protobuf:"bytes,20,opt,name=tls_public_key,json=tlsPublicKey,proto3" json:"tls_pub_key,omitempty"`
	// SshAttestationStatement is an attestation statement for the given SSH public key.
	SshAttestationStatement *v1.AttestationStatement `protobuf:"bytes,21,opt,name=ssh_attestation_statement,json=sshAttestationStatement,proto3" json:"ssh_attestation_statement,omitempty"`
	// TlsAttestationStatement is an attestation statement for the given TLS public key.
	TlsAttestationStatement *v1.AttestationStatement `protobuf:"bytes,22,opt,name=tls_attestation_statement,json=tlsAttestationStatement,proto3" json:"tls_attestation_statement,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                 `json:"-"`
	XXX_unrecognized        []byte                   `json:"-"`
	XXX_sizecache           int32                    `json:"-"`
}

func (m *GithubAuthRequest) Reset()         { *m = GithubAuthRequest{} }
func (m *GithubAuthRequest) String() string { return proto.CompactTextString(m) }
func (*GithubAuthRequest) ProtoMessage()    {}
func (*GithubAuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{203}
}
func (m *GithubAuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubAuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GithubAuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GithubAuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubAuthRequest.Merge(m, src)
}
func (m *GithubAuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *GithubAuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubAuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GithubAuthRequest proto.InternalMessageInfo

// SSOWarnings conveys a user-facing main message along with auxiliary warnings.
type SSOWarnings struct {
	// Message is main user-facing message to be shown.
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"message,omitempty"`
	// Warnings is a set of distinct warnings to be reported.
	Warnings             []string `protobuf:"bytes,2,rep,name=Warnings,proto3" json:"warnings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSOWarnings) Reset()         { *m = SSOWarnings{} }
func (m *SSOWarnings) String() string { return proto.CompactTextString(m) }
func (*SSOWarnings) ProtoMessage()    {}
func (*SSOWarnings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{204}
}
func (m *SSOWarnings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSOWarnings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSOWarnings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSOWarnings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSOWarnings.Merge(m, src)
}
func (m *SSOWarnings) XXX_Size() int {
	return m.Size()
}
func (m *SSOWarnings) XXX_DiscardUnknown() {
	xxx_messageInfo_SSOWarnings.DiscardUnknown(m)
}

var xxx_messageInfo_SSOWarnings proto.InternalMessageInfo

// CreateUserParams represents the user creation parameters as called during SSO login flow.
type CreateUserParams struct {
	// ConnectorName is the name of the connector used for SSO login flow.
	ConnectorName string `protobuf:"bytes,1,opt,name=ConnectorName,proto3" json:"connector_name,omitempty"`
	// Username is the name of the user to be created.
	Username string `protobuf:"bytes,2,opt,name=Username,proto3" json:"username,omitempty"`
	// Logins is a list of available unix logins.
	Logins []string `protobuf:"bytes,3,rep,name=Logins,proto3" json:"logins,omitempty"`
	// KubeGroups is a list of assigned kube groups.
	KubeGroups []string `protobuf:"bytes,4,rep,name=KubeGroups,proto3" json:"kube_groups,omitempty"`
	// KubeUsers is a list of available kube users.
	KubeUsers []string `protobuf:"bytes,5,rep,name=KubeUsers,proto3" json:"kube_users,omitempty"`
	// Roles is a list of assigned roles.
	Roles []string `protobuf:"bytes,6,rep,name=Roles,proto3" json:"roles,omitempty"`
	// Traits is the set of traits the user is assigned.
	Traits github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,7,opt,name=Traits,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"traits,omitempty"`
	// SessionTTL determines the TTL.
	SessionTTL           Duration `protobuf:"varint,8,opt,name=SessionTTL,proto3,casttype=Duration" json:"session_ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateUserParams) Reset()         { *m = CreateUserParams{} }
func (m *CreateUserParams) String() string { return proto.CompactTextString(m) }
func (*CreateUserParams) ProtoMessage()    {}
func (*CreateUserParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{205}
}
func (m *CreateUserParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateUserParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateUserParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateUserParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateUserParams.Merge(m, src)
}
func (m *CreateUserParams) XXX_Size() int {
	return m.Size()
}
func (m *CreateUserParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateUserParams.DiscardUnknown(m)
}

var xxx_messageInfo_CreateUserParams proto.InternalMessageInfo

// SSODiagnosticInfo is a single SSO diagnostic info entry.
type SSODiagnosticInfo struct {
	// TestFlow indicates the SSO flow was a test one.
	TestFlow bool `protobuf:"varint,1,opt,name=TestFlow,proto3" json:"test_flow"`
	// Error stores user-friendly error message.
	Error string `protobuf:"bytes,2,opt,name=Error,proto3" json:"error"`
	// Success if present, marks the flow as finished with success.
	Success bool `protobuf:"varint,3,opt,name=Success,proto3" json:"success"`
	// CreateUserParams represents the user creation parameters as called during SSO login flow.
	CreateUserParams *CreateUserParams `protobuf:"bytes,4,opt,name=CreateUserParams,proto3" json:"create_user_params,omitempty"`
	// SAMLAttributesToRoles represents mapping from attributes to roles, as used during SAML SSO
	// login flow.
	SAMLAttributesToRoles []AttributeMapping `protobuf:"bytes,10,rep,name=SAMLAttributesToRoles,proto3" json:"saml_attributes_to_roles,omitempty"`
	// SAMLAttributesToRolesWarnings contains warnings produced during the process of mapping the
	// SAML attributes to roles.
	SAMLAttributesToRolesWarnings *SSOWarnings `protobuf:"bytes,11,opt,name=SAMLAttributesToRolesWarnings,proto3" json:"saml_attributes_to_roles_warnings,omitempty"`
	// SAMLAttributeStatements represents SAML attribute statements.
	SAMLAttributeStatements github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,12,opt,name=SAMLAttributeStatements,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"saml_attribute_statements,omitempty"`
	// SAMLAssertionInfo represents raw SAML assertion info as returned by IdP during SAML flow.
	SAMLAssertionInfo *AssertionInfo `protobuf:"bytes,13,opt,name=SAMLAssertionInfo,proto3,customtype=AssertionInfo" json:"saml_assertion_info,omitempty"`
	// SAMLTraitsFromAssertions represents traits translated from SAML assertions.
	SAMLTraitsFromAssertions github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,14,opt,name=SAMLTraitsFromAssertions,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"saml_traits_from_assertions,omitempty"`
	// SAMLConnectorTraitMapping represents connector-specific trait mapping.
	SAMLConnectorTraitMapping []TraitMapping `protobuf:"bytes,15,rep,name=SAMLConnectorTraitMapping,proto3" json:"saml_connector_trait_mapping,omitempty"`
	// OIDCClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
	OIDCClaimsToRoles []ClaimMapping `protobuf:"bytes,20,rep,name=OIDCClaimsToRoles,proto3" json:"oidc_claims_to_roles,omitempty"`
	// OIDCClaimsToRolesWarnings contains warnings produced during the process of mapping the
	// OIDC claims to roles.
	OIDCClaimsToRolesWarnings *SSOWarnings `protobuf:"bytes,21,opt,name=OIDCClaimsToRolesWarnings,proto3" json:"oidc_claims_to_roles_warnings,omitempty"`
	// OIDCClaims represents OIDC claims.
	OIDCClaims OIDCClaims `protobuf:"bytes,22,opt,name=OIDCClaims,proto3,customtype=OIDCClaims" json:"oidc_claims,omitempty"`
	// OIDCIdentity represents mapped OIDC Identity.
	OIDCIdentity *OIDCIdentity `protobuf:"bytes,23,opt,name=OIDCIdentity,proto3,customtype=OIDCIdentity" json:"oidc_identity,omitempty"`
	// OIDCTraitsFromClaims represents traits translated from OIDC claims.
	OIDCTraitsFromClaims github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,24,opt,name=OIDCTraitsFromClaims,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"oidc_traits_from_claims,omitempty"`
	// OIDCConnectorTraitMapping represents connector-specific trait mapping.
	OIDCConnectorTraitMapping []TraitMapping `protobuf:"bytes,25,rep,name=OIDCConnectorTraitMapping,proto3" json:"oidc_connector_trait_mapping,omitempty"`
	// GithubClaims represents Github user information obtained during OAuth2 flow.
	GithubClaims *GithubClaims `protobuf:"bytes,30,opt,name=GithubClaims,proto3" json:"github_claims,omitempty"`
	// GithubTeamsToLogins is TeamsToLogins mapping from Github connector used in the SSO flow.
	GithubTeamsToLogins []TeamMapping `protobuf:"bytes,31,rep,name=GithubTeamsToLogins,proto3" json:"github_teams_to_logins,omitempty"`
	// GithubTeamsToRoles is TeamRolesMapping mapping from Github connector used in the SSO flow.
	GithubTeamsToRoles []TeamRolesMapping `protobuf:"bytes,32,rep,name=GithubTeamsToRoles,proto3" json:"github_teams_to_roles,omitempty"`
	// GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
	GithubTokenInfo *GithubTokenInfo `protobuf:"bytes,33,opt,name=GithubTokenInfo,proto3" json:"github_token_info,omitempty"`
	// AppliedLoginRules stores the name of each login rule that was applied.
	AppliedLoginRules    []string `protobuf:"bytes,34,rep,name=AppliedLoginRules,proto3" json:"applied_login_rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSODiagnosticInfo) Reset()         { *m = SSODiagnosticInfo{} }
func (m *SSODiagnosticInfo) String() string { return proto.CompactTextString(m) }
func (*SSODiagnosticInfo) ProtoMessage()    {}
func (*SSODiagnosticInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{206}
}
func (m *SSODiagnosticInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSODiagnosticInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSODiagnosticInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSODiagnosticInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSODiagnosticInfo.Merge(m, src)
}
func (m *SSODiagnosticInfo) XXX_Size() int {
	return m.Size()
}
func (m *SSODiagnosticInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SSODiagnosticInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SSODiagnosticInfo proto.InternalMessageInfo

// GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
// The token itself is secret and therefore not included.
type GithubTokenInfo struct {
	TokenType            string   `protobuf:"bytes,1,opt,name=TokenType,proto3" json:"token_type"`
	Expires              int64    `protobuf:"varint,2,opt,name=Expires,proto3" json:"expires"`
	Scope                string   `protobuf:"bytes,3,opt,name=Scope,proto3" json:"scope"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GithubTokenInfo) Reset()         { *m = GithubTokenInfo{} }
func (m *GithubTokenInfo) String() string { return proto.CompactTextString(m) }
func (*GithubTokenInfo) ProtoMessage()    {}
func (*GithubTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{207}
}
func (m *GithubTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GithubTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GithubTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubTokenInfo.Merge(m, src)
}
func (m *GithubTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *GithubTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GithubTokenInfo proto.InternalMessageInfo

// GithubClaims represents Github user information obtained during OAuth2 flow
type GithubClaims struct {
	// Username is the user's username
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	// OrganizationToTeams is the user's organization and team membership
	OrganizationToTeams github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,2,opt,name=OrganizationToTeams,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"organization_to_teams"`
	// Teams is the users team membership
	Teams                []string `protobuf:"bytes,3,rep,name=Teams,proto3" json:"teams"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GithubClaims) Reset()         { *m = GithubClaims{} }
func (m *GithubClaims) String() string { return proto.CompactTextString(m) }
func (*GithubClaims) ProtoMessage()    {}
func (*GithubClaims) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{208}
}
func (m *GithubClaims) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GithubClaims) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GithubClaims.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GithubClaims) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GithubClaims.Merge(m, src)
}
func (m *GithubClaims) XXX_Size() int {
	return m.Size()
}
func (m *GithubClaims) XXX_DiscardUnknown() {
	xxx_messageInfo_GithubClaims.DiscardUnknown(m)
}

var xxx_messageInfo_GithubClaims proto.InternalMessageInfo

// TeamMapping represents a single team membership mapping.
//
// DELETE IN 11.0.0
type TeamMapping struct {
	// Organization is a Github organization a user belongs to.
	Organization string `protobuf:"bytes,1,opt,name=Organization,proto3" json:"organization"`
	// Team is a team within the organization a user belongs to.
	Team string `protobuf:"bytes,2,opt,name=Team,proto3" json:"team"`
	// Logins is a list of allowed logins for this org/team.
	Logins []string `protobuf:"bytes,3,rep,name=Logins,proto3" json:"logins,omitempty"`
	// KubeGroups is a list of allowed kubernetes groups for this org/team.
	KubeGroups []string `protobuf:"bytes,4,rep,name=KubeGroups,proto3" json:"kubernetes_groups,omitempty"`
	// KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
	KubeUsers            []string `protobuf:"bytes,5,rep,name=KubeUsers,proto3" json:"kubernetes_users,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TeamMapping) Reset()         { *m = TeamMapping{} }
func (m *TeamMapping) String() string { return proto.CompactTextString(m) }
func (*TeamMapping) ProtoMessage()    {}
func (*TeamMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{209}
}
func (m *TeamMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamMapping.Merge(m, src)
}
func (m *TeamMapping) XXX_Size() int {
	return m.Size()
}
func (m *TeamMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamMapping.DiscardUnknown(m)
}

var xxx_messageInfo_TeamMapping proto.InternalMessageInfo

// TeamRolesMapping represents a single team membership mapping.
type TeamRolesMapping struct {
	// Organization is a Github organization a user belongs to.
	Organization string `protobuf:"bytes,1,opt,name=Organization,proto3" json:"organization"`
	// Team is a team within the organization a user belongs to.
	Team string `protobuf:"bytes,2,opt,name=Team,proto3" json:"team"`
	// Roles is a list of allowed logins for this org/team.
	Roles                []string `protobuf:"bytes,3,rep,name=Roles,proto3" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TeamRolesMapping) Reset()         { *m = TeamRolesMapping{} }
func (m *TeamRolesMapping) String() string { return proto.CompactTextString(m) }
func (*TeamRolesMapping) ProtoMessage()    {}
func (*TeamRolesMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{210}
}
func (m *TeamRolesMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamRolesMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamRolesMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamRolesMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamRolesMapping.Merge(m, src)
}
func (m *TeamRolesMapping) XXX_Size() int {
	return m.Size()
}
func (m *TeamRolesMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamRolesMapping.DiscardUnknown(m)
}

var xxx_messageInfo_TeamRolesMapping proto.InternalMessageInfo

// TrustedClusterV2 represents a Trusted Cluster.
type TrustedClusterV2 struct {
	// Kind is a resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata holds resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a Trusted Cluster specification.
	Spec                 TrustedClusterSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TrustedClusterV2) Reset()      { *m = TrustedClusterV2{} }
func (*TrustedClusterV2) ProtoMessage() {}
func (*TrustedClusterV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{211}
}
func (m *TrustedClusterV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustedClusterV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustedClusterV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustedClusterV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustedClusterV2.Merge(m, src)
}
func (m *TrustedClusterV2) XXX_Size() int {
	return m.Size()
}
func (m *TrustedClusterV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustedClusterV2.DiscardUnknown(m)
}

var xxx_messageInfo_TrustedClusterV2 proto.InternalMessageInfo

// TrustedClusterV2List is a list of trusted cluster.
type TrustedClusterV2List struct {
	// TrustedClusters is a list of trusted cluster.
	TrustedClusters      []*TrustedClusterV2 `protobuf:"bytes,1,rep,name=TrustedClusters,proto3" json:"TrustedClusters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TrustedClusterV2List) Reset()         { *m = TrustedClusterV2List{} }
func (m *TrustedClusterV2List) String() string { return proto.CompactTextString(m) }
func (*TrustedClusterV2List) ProtoMessage()    {}
func (*TrustedClusterV2List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{212}
}
func (m *TrustedClusterV2List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustedClusterV2List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustedClusterV2List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustedClusterV2List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustedClusterV2List.Merge(m, src)
}
func (m *TrustedClusterV2List) XXX_Size() int {
	return m.Size()
}
func (m *TrustedClusterV2List) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustedClusterV2List.DiscardUnknown(m)
}

var xxx_messageInfo_TrustedClusterV2List proto.InternalMessageInfo

// TrustedClusterSpecV2 is a Trusted Cluster specification.
type TrustedClusterSpecV2 struct {
	// Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
	// Setting Enabled to false has a side effect of deleting the user and host certificate
	// authority (CA).
	Enabled bool `protobuf:"varint,1,opt,name=Enabled,proto3" json:"enabled"`
	// Roles is a list of roles that users will be assuming when connecting to this cluster.
	Roles []string `protobuf:"bytes,2,rep,name=Roles,proto3" json:"roles,omitempty"`
	// Token is the authorization token provided by another cluster needed by this cluster to join.
	Token string `protobuf:"bytes,3,opt,name=Token,proto3" json:"token"`
	// ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
	// it is derived from `<metadata.name>:<default web proxy server port>`.
	ProxyAddress string `protobuf:"bytes,4,opt,name=ProxyAddress,proto3" json:"web_proxy_addr"`
	// ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
	// not set, it is derived from `<metadata.name>:<default reverse tunnel port>`.
	ReverseTunnelAddress string `protobuf:"bytes,5,opt,name=ReverseTunnelAddress,proto3" json:"tunnel_addr"`
	// RoleMap specifies role mappings to remote roles.
	RoleMap              []RoleMapping `protobuf:"bytes,6,rep,name=RoleMap,proto3" json:"role_map,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TrustedClusterSpecV2) Reset()         { *m = TrustedClusterSpecV2{} }
func (m *TrustedClusterSpecV2) String() string { return proto.CompactTextString(m) }
func (*TrustedClusterSpecV2) ProtoMessage()    {}
func (*TrustedClusterSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{213}
}
func (m *TrustedClusterSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustedClusterSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustedClusterSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustedClusterSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustedClusterSpecV2.Merge(m, src)
}
func (m *TrustedClusterSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *TrustedClusterSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustedClusterSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_TrustedClusterSpecV2 proto.InternalMessageInfo

// LockV2 represents a lock.
// Locks are used to restrict access to a Teleport environment by disabling
// interactions involving a user, an RBAC role, a node, etc.
// See rfd/0009-locking.md for more details.
type LockV2 struct {
	// Kind is a resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version. It must be specified.
	// Supported values are: `v2`.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata holds resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is a Lock specification.
	Spec                 LockSpecV2 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LockV2) Reset()         { *m = LockV2{} }
func (m *LockV2) String() string { return proto.CompactTextString(m) }
func (*LockV2) ProtoMessage()    {}
func (*LockV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{214}
}
func (m *LockV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockV2.Merge(m, src)
}
func (m *LockV2) XXX_Size() int {
	return m.Size()
}
func (m *LockV2) XXX_DiscardUnknown() {
	xxx_messageInfo_LockV2.DiscardUnknown(m)
}

var xxx_messageInfo_LockV2 proto.InternalMessageInfo

// LockSpecV2 is a Lock specification.
type LockSpecV2 struct {
	// Target describes the set of interactions that the lock applies to.
	Target LockTarget `protobuf:"bytes,1,opt,name=Target,proto3" json:"target"`
	// Message is the message displayed to locked-out users.
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"message,omitempty"`
	// Expires if set specifies when the lock ceases to be in force.
	Expires *time.Time `protobuf:"bytes,3,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// CreatedAt is the date time that the lock was created.
	CreatedAt time.Time `protobuf:"bytes,4,opt,name=CreatedAt,proto3,stdtime" json:"created_at,omitempty"`
	// CreatedBy is the username of the author of the lock.
	CreatedBy            string   `protobuf:"bytes,5,opt,name=CreatedBy,proto3" json:"created_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockSpecV2) Reset()         { *m = LockSpecV2{} }
func (m *LockSpecV2) String() string { return proto.CompactTextString(m) }
func (*LockSpecV2) ProtoMessage()    {}
func (*LockSpecV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{215}
}
func (m *LockSpecV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockSpecV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockSpecV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockSpecV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockSpecV2.Merge(m, src)
}
func (m *LockSpecV2) XXX_Size() int {
	return m.Size()
}
func (m *LockSpecV2) XXX_DiscardUnknown() {
	xxx_messageInfo_LockSpecV2.DiscardUnknown(m)
}

var xxx_messageInfo_LockSpecV2 proto.InternalMessageInfo

// LockTarget lists the attributes of interactions to be disabled.
type LockTarget struct {
	// User specifies the name of a Teleport user.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user,omitempty"`
	// Role specifies the name of an RBAC role known to the root cluster.
	// In remote clusters, this constraint is evaluated before translating to local roles.
	Role string `protobuf:"bytes,2,opt,name=Role,proto3" json:"role,omitempty"`
	// Login specifies the name of a local UNIX user.
	Login string `protobuf:"bytes,3,opt,name=Login,proto3" json:"login,omitempty"`
	// Node specifies the UUID of a Teleport node.
	// A matching node is also prevented from heartbeating to the auth server.
	// DEPRECATED: use ServerID instead.
	Node string `protobuf:"bytes,4,opt,name=Node,proto3" json:"node,omitempty"` // Deprecated: Do not use.
	// MFADevice specifies the UUID of a user MFA device.
	MFADevice string `protobuf:"bytes,5,opt,name=MFADevice,proto3" json:"mfa_device,omitempty"`
	// WindowsDesktop specifies the name of a Windows desktop.
	WindowsDesktop string `protobuf:"bytes,6,opt,name=WindowsDesktop,proto3" json:"windows_desktop,omitempty"`
	// AccessRequest specifies the UUID of an access request.
	AccessRequest string `protobuf:"bytes,7,opt,name=AccessRequest,proto3" json:"access_request,omitempty"`
	// Device is the device ID of a trusted device.
	// Requires Teleport Enterprise.
	Device string `protobuf:"bytes,8,opt,name=Device,proto3" json:"device,omitempty"`
	// ServerID is the host id of the Teleport instance.
	ServerID             string   `protobuf:"bytes,9,opt,name=ServerID,proto3" json:"server_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LockTarget) Reset()      { *m = LockTarget{} }
func (*LockTarget) ProtoMessage() {}
func (*LockTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{216}
}
func (m *LockTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LockTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockTarget.Merge(m, src)
}
func (m *LockTarget) XXX_Size() int {
	return m.Size()
}
func (m *LockTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_LockTarget.DiscardUnknown(m)
}

var xxx_messageInfo_LockTarget proto.InternalMessageInfo

// AddressCondition represents a set of addresses. Presently the addresses are specified
// exclusively in terms of IPv4/IPv6 ranges.
type AddressCondition struct {
	// CIDR is IPv4 or IPv6 address. Valid value are either CIDR ranges (e.g. "10.0.1.0/24",
	// "fe::/8") or a single IP address (e.g "10.1.2.3")
	CIDR                 string   `protobuf:"bytes,1,opt,name=CIDR,proto3" json:"cidr"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressCondition) Reset()         { *m = AddressCondition{} }
func (m *AddressCondition) String() string { return proto.CompactTextString(m) }
func (*AddressCondition) ProtoMessage()    {}
func (*AddressCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{217}
}
func (m *AddressCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressCondition.Merge(m, src)
}
func (m *AddressCondition) XXX_Size() int {
	return m.Size()
}
func (m *AddressCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressCondition.DiscardUnknown(m)
}

var xxx_messageInfo_AddressCondition proto.InternalMessageInfo

type NetworkRestrictionsSpecV4 struct {
	// Allow lists the addresses that should be allowed.
	Allow []AddressCondition `protobuf:"bytes,1,rep,name=Allow,proto3" json:"allow"`
	// Deny lists the addresses that should be denied even if they're allowed by Allow condition.
	Deny                 []AddressCondition `protobuf:"bytes,2,rep,name=Deny,proto3" json:"deny"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *NetworkRestrictionsSpecV4) Reset()         { *m = NetworkRestrictionsSpecV4{} }
func (m *NetworkRestrictionsSpecV4) String() string { return proto.CompactTextString(m) }
func (*NetworkRestrictionsSpecV4) ProtoMessage()    {}
func (*NetworkRestrictionsSpecV4) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{218}
}
func (m *NetworkRestrictionsSpecV4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkRestrictionsSpecV4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkRestrictionsSpecV4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkRestrictionsSpecV4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkRestrictionsSpecV4.Merge(m, src)
}
func (m *NetworkRestrictionsSpecV4) XXX_Size() int {
	return m.Size()
}
func (m *NetworkRestrictionsSpecV4) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkRestrictionsSpecV4.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkRestrictionsSpecV4 proto.InternalMessageInfo

// NetworkRestrictions specifies a list of addresses to restrict (block). The deny
// list is checked first and the allow lists overrides it. Thus an empty allow
// list does not mean that no addresses will be allowed, that will only be the
// case if the deny list covers the whole address range.
type NetworkRestrictionsV4 struct {
	// Kind is the network restrictions resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the network restrictions metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec contains the network restrictions data
	Spec                 NetworkRestrictionsSpecV4 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *NetworkRestrictionsV4) Reset()         { *m = NetworkRestrictionsV4{} }
func (m *NetworkRestrictionsV4) String() string { return proto.CompactTextString(m) }
func (*NetworkRestrictionsV4) ProtoMessage()    {}
func (*NetworkRestrictionsV4) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{219}
}
func (m *NetworkRestrictionsV4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkRestrictionsV4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkRestrictionsV4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkRestrictionsV4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkRestrictionsV4.Merge(m, src)
}
func (m *NetworkRestrictionsV4) XXX_Size() int {
	return m.Size()
}
func (m *NetworkRestrictionsV4) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkRestrictionsV4.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkRestrictionsV4 proto.InternalMessageInfo

// WindowsDesktopServiceV3 represents a windows desktop access service.
type WindowsDesktopServiceV3 struct {
	// Header is the common resource header.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the windows desktop service spec.
	Spec                 WindowsDesktopServiceSpecV3 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *WindowsDesktopServiceV3) Reset()         { *m = WindowsDesktopServiceV3{} }
func (m *WindowsDesktopServiceV3) String() string { return proto.CompactTextString(m) }
func (*WindowsDesktopServiceV3) ProtoMessage()    {}
func (*WindowsDesktopServiceV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{220}
}
func (m *WindowsDesktopServiceV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsDesktopServiceV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsDesktopServiceV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsDesktopServiceV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsDesktopServiceV3.Merge(m, src)
}
func (m *WindowsDesktopServiceV3) XXX_Size() int {
	return m.Size()
}
func (m *WindowsDesktopServiceV3) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsDesktopServiceV3.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsDesktopServiceV3 proto.InternalMessageInfo

// WindowsDesktopServiceSpecV3 is the windows desktop service spec.
type WindowsDesktopServiceSpecV3 struct {
	// Addr is the address that this service can be reached at.
	Addr string `protobuf:"bytes,1,opt,name=Addr,proto3" json:"addr"`
	// TeleportVersion is teleport binary version running this service.
	TeleportVersion string `protobuf:"bytes,2,opt,name=TeleportVersion,proto3" json:"teleport_version"`
	// Hostname is the desktop service hostname.
	Hostname string `protobuf:"bytes,3,opt,name=Hostname,proto3" json:"hostname"`
	// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
	ProxyIDs             []string `protobuf:"bytes,4,rep,name=ProxyIDs,proto3" json:"proxy_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WindowsDesktopServiceSpecV3) Reset()         { *m = WindowsDesktopServiceSpecV3{} }
func (m *WindowsDesktopServiceSpecV3) String() string { return proto.CompactTextString(m) }
func (*WindowsDesktopServiceSpecV3) ProtoMessage()    {}
func (*WindowsDesktopServiceSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{221}
}
func (m *WindowsDesktopServiceSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsDesktopServiceSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsDesktopServiceSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsDesktopServiceSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsDesktopServiceSpecV3.Merge(m, src)
}
func (m *WindowsDesktopServiceSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *WindowsDesktopServiceSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsDesktopServiceSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsDesktopServiceSpecV3 proto.InternalMessageInfo

// WindowsDesktopFilter are filters to apply when searching for windows desktops.
type WindowsDesktopFilter struct {
	// HostID is the ID of the host the Windows Desktop Service proxying the desktop.
	HostID string `protobuf:"bytes,1,opt,name=HostID,proto3" json:"host_id"`
	// Name is the name of the desktop.
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WindowsDesktopFilter) Reset()         { *m = WindowsDesktopFilter{} }
func (m *WindowsDesktopFilter) String() string { return proto.CompactTextString(m) }
func (*WindowsDesktopFilter) ProtoMessage()    {}
func (*WindowsDesktopFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{222}
}
func (m *WindowsDesktopFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsDesktopFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsDesktopFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsDesktopFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsDesktopFilter.Merge(m, src)
}
func (m *WindowsDesktopFilter) XXX_Size() int {
	return m.Size()
}
func (m *WindowsDesktopFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsDesktopFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsDesktopFilter proto.InternalMessageInfo

// WindowsDesktopV3 represents a Windows host for desktop access.
type WindowsDesktopV3 struct {
	// Header is the common resource header.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the Windows host spec.
	Spec                 WindowsDesktopSpecV3 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *WindowsDesktopV3) Reset()         { *m = WindowsDesktopV3{} }
func (m *WindowsDesktopV3) String() string { return proto.CompactTextString(m) }
func (*WindowsDesktopV3) ProtoMessage()    {}
func (*WindowsDesktopV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{223}
}
func (m *WindowsDesktopV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsDesktopV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsDesktopV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsDesktopV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsDesktopV3.Merge(m, src)
}
func (m *WindowsDesktopV3) XXX_Size() int {
	return m.Size()
}
func (m *WindowsDesktopV3) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsDesktopV3.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsDesktopV3 proto.InternalMessageInfo

// WindowsDesktopSpecV3 is the Windows host spec.
type WindowsDesktopSpecV3 struct {
	// Addr is the address that this host can be reached at.
	Addr string `protobuf:"bytes,1,opt,name=Addr,proto3" json:"addr"`
	// Domain is the ActiveDirectory domain that this host belongs to.
	Domain string `protobuf:"bytes,2,opt,name=Domain,proto3" json:"domain"`
	// HostID is the ID of the host the Windows Desktop Service proxying the desktop.
	HostID string `protobuf:"bytes,3,opt,name=HostID,proto3" json:"host_id"`
	// NonAD marks this desktop as a standalone host that is
	// not joined to an Active Directory domain.
	NonAD bool `protobuf:"varint,4,opt,name=NonAD,proto3" json:"non_ad"`
	// ScreenSize specifies the size of the screen to use for sessions
	// on this host. In most cases this should be unspecified, in which
	// case Teleport will fill the browser window.
	ScreenSize           *Resolution `protobuf:"bytes,5,opt,name=ScreenSize,proto3" json:"screen_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WindowsDesktopSpecV3) Reset()         { *m = WindowsDesktopSpecV3{} }
func (m *WindowsDesktopSpecV3) String() string { return proto.CompactTextString(m) }
func (*WindowsDesktopSpecV3) ProtoMessage()    {}
func (*WindowsDesktopSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{224}
}
func (m *WindowsDesktopSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsDesktopSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsDesktopSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsDesktopSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsDesktopSpecV3.Merge(m, src)
}
func (m *WindowsDesktopSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *WindowsDesktopSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsDesktopSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsDesktopSpecV3 proto.InternalMessageInfo

type Resolution struct {
	Width                uint32   `protobuf:"varint,1,opt,name=Width,proto3" json:"width,omitempty"`
	Height               uint32   `protobuf:"varint,2,opt,name=Height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Resolution) Reset()         { *m = Resolution{} }
func (m *Resolution) String() string { return proto.CompactTextString(m) }
func (*Resolution) ProtoMessage()    {}
func (*Resolution) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{225}
}
func (m *Resolution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resolution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resolution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resolution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resolution.Merge(m, src)
}
func (m *Resolution) XXX_Size() int {
	return m.Size()
}
func (m *Resolution) XXX_DiscardUnknown() {
	xxx_messageInfo_Resolution.DiscardUnknown(m)
}

var xxx_messageInfo_Resolution proto.InternalMessageInfo

// RegisterUsingTokenRequest is a request to register with the auth server using
// an authentication token
type RegisterUsingTokenRequest struct {
	// HostID is a unique host ID, usually a UUID
	HostID string `protobuf:"bytes,1,opt,name=HostID,proto3" json:"hostID"`
	// NodeName is a node name
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"node_name"`
	// Role is a system role, e.g. Proxy
	Role SystemRole `protobuf:"bytes,3,opt,name=Role,proto3,casttype=SystemRole" json:"role"`
	// Token is the name of an authentication token
	Token string `protobuf:"bytes,4,opt,name=Token,proto3" json:"token"`
	// AdditionalPrincipals is a list of additional principals
	AdditionalPrincipals []string `protobuf:"bytes,5,rep,name=AdditionalPrincipals,proto3" json:"additional_principals"`
	// DNSNames is a list of DNS names to include in the x509 client certificate
	DNSNames []string `protobuf:"bytes,6,rep,name=DNSNames,proto3" json:"dns_names"`
	// PublicTLSKey is a PEM encoded public key
	// used for TLS setup
	PublicTLSKey []byte `protobuf:"bytes,7,opt,name=PublicTLSKey,proto3" json:"public_tls_key"`
	// PublicSSHKey is a SSH encoded public key,
	// if present will be signed as a return value
	// otherwise, new public/private key pair will be generated
	PublicSSHKey []byte `protobuf:"bytes,8,opt,name=PublicSSHKey,proto3" json:"public_ssh_key"`
	// RemoteAddr is the remote address of the host requesting a host certificate.
	// It is used to replace 0.0.0.0 in the list of additional principals.
	RemoteAddr string `protobuf:"bytes,9,opt,name=RemoteAddr,proto3" json:"remote_addr"`
	// EC2IdentityDocument is used for the EC2 join method to prove the identity
	// of a joining EC2 instance.
	EC2IdentityDocument []byte `protobuf:"bytes,10,opt,name=EC2IdentityDocument,proto3" json:"ec2_id"`
	// IDToken is a token provided by a workload identity provider as part of
	// OIDC join types such as GitHub.
	IDToken string `protobuf:"bytes,11,opt,name=IDToken,proto3" json:"id_token"`
	// Expires is a desired time of the expiry of user certificates returned by
	// registration. This only applies to bot joining, and will be ignored by
	// node joining.
	Expires *time.Time `protobuf:"bytes,12,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// BotInstanceID is a trusted instance identifier for a Machine ID bot,
	// provided when rejoining. This parameters may only be provided by the join
	// service and is ignored otherwise; bots should otherwise rejoin with their
	// existing client certificate to prove their instance identity.
	BotInstanceID string `protobuf:"bytes,13,opt,name=BotInstanceID,proto3" json:"bot_instance_id"`
	// BotGeneration is a trusted generation counter value for Machine ID bots,
	// provided to Auth by the Join Service when bots rejoin via a streamed/gRPC
	// join method. Rejoining bots supply this value via a client certificate
	// extension; it is ignored from other sources.
	BotGeneration        int32    `protobuf:"varint,14,opt,name=BotGeneration,proto3" json:"bot_generation"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterUsingTokenRequest) Reset()         { *m = RegisterUsingTokenRequest{} }
func (m *RegisterUsingTokenRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterUsingTokenRequest) ProtoMessage()    {}
func (*RegisterUsingTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{226}
}
func (m *RegisterUsingTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterUsingTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterUsingTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterUsingTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterUsingTokenRequest.Merge(m, src)
}
func (m *RegisterUsingTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterUsingTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterUsingTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterUsingTokenRequest proto.InternalMessageInfo

// RecoveryCodes holds a user's recovery code information. Recovery codes allows users to regain
// access to their account by restoring their lost password or second factor. Once a recovery code
// is successfully verified, the code is mark used (which invalidates it), and lets the user begin
// the recovery flow. When a user successfully finishes the recovery flow, users will get a new set
// of codes that will replace all the previous ones.
type RecoveryCodesV1 struct {
	// Kind is the resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind. Currently unused for this resource.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the resource spec.
	Spec                 RecoveryCodesSpecV1 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RecoveryCodesV1) Reset()         { *m = RecoveryCodesV1{} }
func (m *RecoveryCodesV1) String() string { return proto.CompactTextString(m) }
func (*RecoveryCodesV1) ProtoMessage()    {}
func (*RecoveryCodesV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{227}
}
func (m *RecoveryCodesV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCodesV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryCodesV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryCodesV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCodesV1.Merge(m, src)
}
func (m *RecoveryCodesV1) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCodesV1) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCodesV1.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCodesV1 proto.InternalMessageInfo

// RecoveryCodesSpecV1 is the recovery codes spec.
type RecoveryCodesSpecV1 struct {
	// Codes hold a list of numOfRecoveryCodes.
	Codes []RecoveryCode `protobuf:"bytes,1,rep,name=Codes,proto3" json:"codes"`
	// Created is when the set of recovery codes were generated. Updated when a new set of recovery
	// codes are inserted.
	Created              time.Time `protobuf:"bytes,2,opt,name=Created,proto3,stdtime" json:"created"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RecoveryCodesSpecV1) Reset()         { *m = RecoveryCodesSpecV1{} }
func (m *RecoveryCodesSpecV1) String() string { return proto.CompactTextString(m) }
func (*RecoveryCodesSpecV1) ProtoMessage()    {}
func (*RecoveryCodesSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{228}
}
func (m *RecoveryCodesSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCodesSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryCodesSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryCodesSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCodesSpecV1.Merge(m, src)
}
func (m *RecoveryCodesSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCodesSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCodesSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCodesSpecV1 proto.InternalMessageInfo

// RecoveryCode describes a recovery code.
type RecoveryCode struct {
	// HashedCode is a bcrypt hash of this recovery code.
	HashedCode []byte `protobuf:"bytes,1,opt,name=HashedCode,proto3" json:"hashed_code"`
	// IsUsed determines if this recovery code was used.
	IsUsed               bool     `protobuf:"varint,2,opt,name=IsUsed,proto3" json:"is_used"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecoveryCode) Reset()         { *m = RecoveryCode{} }
func (m *RecoveryCode) String() string { return proto.CompactTextString(m) }
func (*RecoveryCode) ProtoMessage()    {}
func (*RecoveryCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{229}
}
func (m *RecoveryCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCode.Merge(m, src)
}
func (m *RecoveryCode) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCode) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCode.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCode proto.InternalMessageInfo

type NullableSessionState struct {
	State                SessionState `protobuf:"varint,1,opt,name=State,proto3,enum=types.SessionState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *NullableSessionState) Reset()         { *m = NullableSessionState{} }
func (m *NullableSessionState) String() string { return proto.CompactTextString(m) }
func (*NullableSessionState) ProtoMessage()    {}
func (*NullableSessionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{230}
}
func (m *NullableSessionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullableSessionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullableSessionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NullableSessionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullableSessionState.Merge(m, src)
}
func (m *NullableSessionState) XXX_Size() int {
	return m.Size()
}
func (m *NullableSessionState) XXX_DiscardUnknown() {
	xxx_messageInfo_NullableSessionState.DiscardUnknown(m)
}

var xxx_messageInfo_NullableSessionState proto.InternalMessageInfo

// SessionTrackerFilter are filters to apply when searching for session trackers.
type SessionTrackerFilter struct {
	// Kind describes what kind of session this is.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind,omitempty"`
	// State is the current state of this session.
	State *NullableSessionState `protobuf:"bytes,2,opt,name=State,proto3" json:"state,omitempty"`
	// DesktopName is the windows desktop server this session belongs to.
	DesktopName          string   `protobuf:"bytes,3,opt,name=DesktopName,proto3" json:"desktop_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionTrackerFilter) Reset()         { *m = SessionTrackerFilter{} }
func (m *SessionTrackerFilter) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerFilter) ProtoMessage()    {}
func (*SessionTrackerFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{231}
}
func (m *SessionTrackerFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerFilter.Merge(m, src)
}
func (m *SessionTrackerFilter) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerFilter.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerFilter proto.InternalMessageInfo

// SessionTrackerV1 represents a live session resource.
type SessionTrackerV1 struct {
	// Header is the common resource header.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is a session specification.
	Spec                 SessionTrackerSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SessionTrackerV1) Reset()         { *m = SessionTrackerV1{} }
func (m *SessionTrackerV1) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerV1) ProtoMessage()    {}
func (*SessionTrackerV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{232}
}
func (m *SessionTrackerV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerV1.Merge(m, src)
}
func (m *SessionTrackerV1) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerV1) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerV1.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerV1 proto.InternalMessageInfo

// SessionTrackerSpecV1 is the specification for a live session.
type SessionTrackerSpecV1 struct {
	// SessionID is unique identifier of this session.
	SessionID string `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id,omitempty"`
	// Kind describes what kind of session this is.
	Kind string `protobuf:"bytes,2,opt,name=Kind,proto3" json:"kind,omitempty"`
	// State is the current state of this session.
	State SessionState `protobuf:"varint,3,opt,name=State,proto3,enum=types.SessionState" json:"state,omitempty"`
	// Created encodes the time at which the session was registered with the auth
	// server.
	//
	// This should match the timestamp in the corresponding `session.create` event.
	// It's thus up to the tracker creator to set the correct timestamp.
	Created time.Time `protobuf:"bytes,4,opt,name=Created,proto3,stdtime" json:"created,omitempty"`
	// Expires encodes the time at which this session expires and becomes invalid.
	Expires time.Time `protobuf:"bytes,5,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// AttachedData is arbitrary attached JSON serialized metadata.
	AttachedData string `protobuf:"bytes,6,opt,name=AttachedData,proto3" json:"attached,omitempty"`
	// Reason is an arbitrary string that may be used to describe the session and/or it's
	// purpose.
	Reason string `protobuf:"bytes,7,opt,name=Reason,proto3" json:"reason,omitempty"`
	// Invited is a list of invited users, this field can be used by
	// clients to deliver notifications to invited users.
	Invited []string `protobuf:"bytes,8,rep,name=Invited,proto3" json:"invited,omitempty"`
	// Hostname identifies the target this session is connected to.
	Hostname string `protobuf:"bytes,9,opt,name=Hostname,proto3" json:"target_hostname,omitempty"`
	// Address is the address of the target this session is connected to.
	Address string `protobuf:"bytes,10,opt,name=Address,proto3" json:"target_address,omitempty"`
	// ClusterName is the name of the Teleport cluster that this session belongs to.
	ClusterName string `protobuf:"bytes,11,opt,name=ClusterName,proto3" json:"cluster_name,omitempty"`
	// Login is the local login/user on the target used by the session.
	Login string `protobuf:"bytes,12,opt,name=Login,proto3" json:"login,omitempty"`
	// Participants is a list of session participants.
	Participants []Participant `protobuf:"bytes,13,rep,name=Participants,proto3" json:"participants,omitempty"`
	// The Kubernetes cluster this session belongs to.
	KubernetesCluster string `protobuf:"bytes,14,opt,name=KubernetesCluster,proto3" json:"kubernetes_cluster,omitempty"`
	// HostUser is the user regarded as the owner of this session, RBAC checks are performed
	// against the require policies of this user.
	//
	// This refers to the Teleport user but may not be the same as the sessions initiator.
	HostUser string `protobuf:"bytes,15,opt,name=HostUser,proto3" json:"host_user,omitempty"`
	// HostPolicies is a list of RBAC policy sets held by the host user at the time of session
	// creation.
	HostPolicies []*SessionTrackerPolicySet `protobuf:"bytes,16,rep,name=HostPolicies,proto3" json:"host_roles,omitempty"`
	// DatabaseName is the database server this session belongs to.
	DatabaseName string `protobuf:"bytes,17,opt,name=DatabaseName,proto3" json:"database_name,omitempty"`
	// AppName is the app server this session belongs to.
	AppName string `protobuf:"bytes,18,opt,name=AppName,proto3" json:"app_name,omitempty"`
	// AppSessionID is the unique ID of the app access certificate used to start this app session.
	AppSessionID string `protobuf:"bytes,19,opt,name=AppSessionID,proto3" json:"app_session_id,omitempty"`
	// DesktopName is the windows desktop server this session belongs to.
	DesktopName string `protobuf:"bytes,20,opt,name=DesktopName,proto3" json:"desktop_name,omitempty"`
	// HostID is the target host id that created the session tracker.
	// It's useful for Kubernetes moderated sessions when running in high availabilty
	// otherwise kube proxy is not able to know which agent runs the session.
	HostID string `protobuf:"bytes,21,opt,name=HostID,proto3" json:"host_id,omitempty"`
	// TargetSubKind is the sub kind of the target server.
	TargetSubKind string `protobuf:"bytes,22,opt,name=TargetSubKind,proto3" json:"target_sub_kind,omitempty"`
	// InitialCommand is the command that was executed to start this session.
	InitialCommand       []string `protobuf:"bytes,23,rep,name=InitialCommand,proto3" json:"initial_command,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionTrackerSpecV1) Reset()         { *m = SessionTrackerSpecV1{} }
func (m *SessionTrackerSpecV1) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerSpecV1) ProtoMessage()    {}
func (*SessionTrackerSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{233}
}
func (m *SessionTrackerSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerSpecV1.Merge(m, src)
}
func (m *SessionTrackerSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerSpecV1 proto.InternalMessageInfo

// SessionTrackerPolicySet is a set of RBAC policies held by the session tracker
// that contain additional metadata from the originating role.
type SessionTrackerPolicySet struct {
	// Name is name of the role this policy set originates from.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	// Version is version of the role this policy set originates from.
	Version string `protobuf:"bytes,2,opt,name=Version,proto3" json:"version,omitempty"`
	// RequireSessionJoin specifies policies for required users to start a session.
	RequireSessionJoin   []*SessionRequirePolicy `protobuf:"bytes,3,rep,name=RequireSessionJoin,proto3" json:"require_session_join,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SessionTrackerPolicySet) Reset()         { *m = SessionTrackerPolicySet{} }
func (m *SessionTrackerPolicySet) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerPolicySet) ProtoMessage()    {}
func (*SessionTrackerPolicySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{234}
}
func (m *SessionTrackerPolicySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerPolicySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerPolicySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerPolicySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerPolicySet.Merge(m, src)
}
func (m *SessionTrackerPolicySet) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerPolicySet) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerPolicySet.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerPolicySet proto.InternalMessageInfo

// Participant stores information about a participant in the session.
type Participant struct {
	// ID is a unique UUID of this participant for a given session.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"id,omitempty"`
	// User is the canonical name of the Teleport user controlling this participant.
	User string `protobuf:"bytes,2,opt,name=User,proto3" json:"user,omitempty"`
	// Mode is the participant mode.
	Mode string `protobuf:"bytes,3,opt,name=Mode,proto3" json:"mode,omitempty"`
	// LastActive is the last time this party was active in the session.
	LastActive           time.Time `protobuf:"bytes,4,opt,name=LastActive,proto3,stdtime" json:"last_active,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Participant) Reset()         { *m = Participant{} }
func (m *Participant) String() string { return proto.CompactTextString(m) }
func (*Participant) ProtoMessage()    {}
func (*Participant) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{235}
}
func (m *Participant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Participant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Participant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Participant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Participant.Merge(m, src)
}
func (m *Participant) XXX_Size() int {
	return m.Size()
}
func (m *Participant) XXX_DiscardUnknown() {
	xxx_messageInfo_Participant.DiscardUnknown(m)
}

var xxx_messageInfo_Participant proto.InternalMessageInfo

// UIConfigV1 represents the configuration for the web UI served by the proxy service
type UIConfigV1 struct {
	// Header is the resource header for the UI configuration.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the resource spec.
	Spec                 UIConfigSpecV1 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UIConfigV1) Reset()         { *m = UIConfigV1{} }
func (m *UIConfigV1) String() string { return proto.CompactTextString(m) }
func (*UIConfigV1) ProtoMessage()    {}
func (*UIConfigV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{236}
}
func (m *UIConfigV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UIConfigV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UIConfigV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UIConfigV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UIConfigV1.Merge(m, src)
}
func (m *UIConfigV1) XXX_Size() int {
	return m.Size()
}
func (m *UIConfigV1) XXX_DiscardUnknown() {
	xxx_messageInfo_UIConfigV1.DiscardUnknown(m)
}

var xxx_messageInfo_UIConfigV1 proto.InternalMessageInfo

// UIConfigSpecV1 is the specification for a UIConfig
type UIConfigSpecV1 struct {
	// ScrollbackLines is the max number of lines the UI terminal can display in its history.
	ScrollbackLines int32 `protobuf:"varint,1,opt,name=ScrollbackLines,proto3" json:"scrollback_lines"`
	// ShowResources determines which resources are shown in the web UI. Default if unset is "requestable"
	// which means resources the user has access to and resources they can request will be shown in the
	// resources UI. If set to `accessible_only`, only resources the user already has access to will be shown.
	ShowResources        github_com_gravitational_teleport_api_constants.ShowResources `protobuf:"bytes,2,opt,name=ShowResources,proto3,casttype=github.com/gravitational/teleport/api/constants.ShowResources" json:"show_resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                      `json:"-"`
	XXX_unrecognized     []byte                                                        `json:"-"`
	XXX_sizecache        int32                                                         `json:"-"`
}

func (m *UIConfigSpecV1) Reset()         { *m = UIConfigSpecV1{} }
func (m *UIConfigSpecV1) String() string { return proto.CompactTextString(m) }
func (*UIConfigSpecV1) ProtoMessage()    {}
func (*UIConfigSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{237}
}
func (m *UIConfigSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UIConfigSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UIConfigSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UIConfigSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UIConfigSpecV1.Merge(m, src)
}
func (m *UIConfigSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *UIConfigSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_UIConfigSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_UIConfigSpecV1 proto.InternalMessageInfo

// InstallerV1 represents an installer script resource. Used to
// provide a script to install teleport on discovered nodes.
type InstallerV1 struct {
	// Kind is the resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind. Currently unused for this resource.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the resource spec.
	Spec                 InstallerSpecV1 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *InstallerV1) Reset()         { *m = InstallerV1{} }
func (m *InstallerV1) String() string { return proto.CompactTextString(m) }
func (*InstallerV1) ProtoMessage()    {}
func (*InstallerV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{238}
}
func (m *InstallerV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerV1.Merge(m, src)
}
func (m *InstallerV1) XXX_Size() int {
	return m.Size()
}
func (m *InstallerV1) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerV1.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerV1 proto.InternalMessageInfo

// InstallerSpecV1 is the specification for an Installer
type InstallerSpecV1 struct {
	// Script represents the contents of a installer shell script
	Script               string   `protobuf:"bytes,1,opt,name=Script,proto3" json:"script"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallerSpecV1) Reset()         { *m = InstallerSpecV1{} }
func (m *InstallerSpecV1) String() string { return proto.CompactTextString(m) }
func (*InstallerSpecV1) ProtoMessage()    {}
func (*InstallerSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{239}
}
func (m *InstallerSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerSpecV1.Merge(m, src)
}
func (m *InstallerSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *InstallerSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerSpecV1 proto.InternalMessageInfo

// InstallerV1List represents a list of installer resources.
type InstallerV1List struct {
	// Installers is a list of installer resources.
	Installers           []*InstallerV1 `protobuf:"bytes,1,rep,name=installers,proto3" json:"installers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *InstallerV1List) Reset()         { *m = InstallerV1List{} }
func (m *InstallerV1List) String() string { return proto.CompactTextString(m) }
func (*InstallerV1List) ProtoMessage()    {}
func (*InstallerV1List) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{240}
}
func (m *InstallerV1List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerV1List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerV1List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerV1List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerV1List.Merge(m, src)
}
func (m *InstallerV1List) XXX_Size() int {
	return m.Size()
}
func (m *InstallerV1List) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerV1List.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerV1List proto.InternalMessageInfo

// SortBy defines a sort criteria.
type SortBy struct {
	// IsDesc is a sort direction flag where if true the direction is descending, else ascending.
	IsDesc bool `protobuf:"varint,1,opt,name=IsDesc,proto3" json:"is_desc"`
	// Field is the name of an objects field to sort by.
	Field                string   `protobuf:"bytes,2,opt,name=Field,proto3" json:"field"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SortBy) Reset()         { *m = SortBy{} }
func (m *SortBy) String() string { return proto.CompactTextString(m) }
func (*SortBy) ProtoMessage()    {}
func (*SortBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{241}
}
func (m *SortBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortBy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SortBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortBy.Merge(m, src)
}
func (m *SortBy) XXX_Size() int {
	return m.Size()
}
func (m *SortBy) XXX_DiscardUnknown() {
	xxx_messageInfo_SortBy.DiscardUnknown(m)
}

var xxx_messageInfo_SortBy proto.InternalMessageInfo

// ConnectionDiagnosticV1 is the result of testing a connection.
// When setting up a new resource in Teleport, it's useful to know if we can connect to it.
// This can be done using the test connection feature.
// The user can then receive the result as feedback using the UI
type ConnectionDiagnosticV1 struct {
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the resource spec.
	Spec                 ConnectionDiagnosticSpecV1 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ConnectionDiagnosticV1) Reset()         { *m = ConnectionDiagnosticV1{} }
func (m *ConnectionDiagnosticV1) String() string { return proto.CompactTextString(m) }
func (*ConnectionDiagnosticV1) ProtoMessage()    {}
func (*ConnectionDiagnosticV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{242}
}
func (m *ConnectionDiagnosticV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionDiagnosticV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionDiagnosticV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionDiagnosticV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionDiagnosticV1.Merge(m, src)
}
func (m *ConnectionDiagnosticV1) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionDiagnosticV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionDiagnosticV1.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionDiagnosticV1 proto.InternalMessageInfo

// ConnectionDiagnosticSpecV1 is the ConnectionDiagnostic Spec.
// It contains the result of testing a connection.
// It has the overall result of the connection and then a list of traces.
// Each trace contains checkpoints of the connection attempt and its result.
type ConnectionDiagnosticSpecV1 struct {
	// Success describes whether the connection was a success or a failure.
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"success"`
	// Message may contain some user friendly message to let the user know whether it was
	// successful or a failure.
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"message"`
	// Traces contain a list of checkpoints defined by
	Traces               []*ConnectionDiagnosticTrace `protobuf:"bytes,3,rep,name=Traces,proto3" json:"traces"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ConnectionDiagnosticSpecV1) Reset()         { *m = ConnectionDiagnosticSpecV1{} }
func (m *ConnectionDiagnosticSpecV1) String() string { return proto.CompactTextString(m) }
func (*ConnectionDiagnosticSpecV1) ProtoMessage()    {}
func (*ConnectionDiagnosticSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{243}
}
func (m *ConnectionDiagnosticSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionDiagnosticSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionDiagnosticSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionDiagnosticSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionDiagnosticSpecV1.Merge(m, src)
}
func (m *ConnectionDiagnosticSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionDiagnosticSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionDiagnosticSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionDiagnosticSpecV1 proto.InternalMessageInfo

// ConnectionDiagnosticTrace describes a trace of a connection diagnostic
type ConnectionDiagnosticTrace struct {
	Type   ConnectionDiagnosticTrace_TraceType  `protobuf:"varint,1,opt,name=Type,proto3,enum=types.ConnectionDiagnosticTrace_TraceType" json:"type"`
	Status ConnectionDiagnosticTrace_StatusType `protobuf:"varint,2,opt,name=Status,proto3,enum=types.ConnectionDiagnosticTrace_StatusType" json:"status"`
	// Details contains a User friendly message of the check's result.
	Details string `protobuf:"bytes,3,opt,name=Details,proto3" json:"details"`
	// Error contains the low level error message in case of a failure.
	Error                string   `protobuf:"bytes,4,opt,name=Error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionDiagnosticTrace) Reset()         { *m = ConnectionDiagnosticTrace{} }
func (m *ConnectionDiagnosticTrace) String() string { return proto.CompactTextString(m) }
func (*ConnectionDiagnosticTrace) ProtoMessage()    {}
func (*ConnectionDiagnosticTrace) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{244}
}
func (m *ConnectionDiagnosticTrace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionDiagnosticTrace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionDiagnosticTrace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionDiagnosticTrace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionDiagnosticTrace.Merge(m, src)
}
func (m *ConnectionDiagnosticTrace) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionDiagnosticTrace) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionDiagnosticTrace.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionDiagnosticTrace proto.InternalMessageInfo

// DatabaseServiceV1 is the representation of a DatabaseService (agent) process.
type DatabaseServiceV1 struct {
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the resource spec.
	Spec                 DatabaseServiceSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DatabaseServiceV1) Reset()         { *m = DatabaseServiceV1{} }
func (m *DatabaseServiceV1) String() string { return proto.CompactTextString(m) }
func (*DatabaseServiceV1) ProtoMessage()    {}
func (*DatabaseServiceV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{245}
}
func (m *DatabaseServiceV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseServiceV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseServiceV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseServiceV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseServiceV1.Merge(m, src)
}
func (m *DatabaseServiceV1) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseServiceV1) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseServiceV1.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseServiceV1 proto.InternalMessageInfo

// DatabaseServiceSpecV1 is the DatabaseService Spec.
type DatabaseServiceSpecV1 struct {
	// ResourceMatchers is the configured match for Database resources.
	ResourceMatchers []*DatabaseResourceMatcher `protobuf:"bytes,1,rep,name=ResourceMatchers,proto3" json:"resources"`
	// Hostname is the hostname where this service is running.
	Hostname             string   `protobuf:"bytes,2,opt,name=Hostname,proto3" json:"hostname"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseServiceSpecV1) Reset()         { *m = DatabaseServiceSpecV1{} }
func (m *DatabaseServiceSpecV1) String() string { return proto.CompactTextString(m) }
func (*DatabaseServiceSpecV1) ProtoMessage()    {}
func (*DatabaseServiceSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{246}
}
func (m *DatabaseServiceSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseServiceSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseServiceSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseServiceSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseServiceSpecV1.Merge(m, src)
}
func (m *DatabaseServiceSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseServiceSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseServiceSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseServiceSpecV1 proto.InternalMessageInfo

// DatabaseResourceMatcher is a set of properties that is used to match on resources.
type DatabaseResourceMatcher struct {
	Labels               *Labels            `protobuf:"bytes,1,opt,name=Labels,proto3,customtype=Labels" json:"labels"`
	AWS                  ResourceMatcherAWS `protobuf:"bytes,2,opt,name=AWS,proto3" json:"aws"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DatabaseResourceMatcher) Reset()         { *m = DatabaseResourceMatcher{} }
func (m *DatabaseResourceMatcher) String() string { return proto.CompactTextString(m) }
func (*DatabaseResourceMatcher) ProtoMessage()    {}
func (*DatabaseResourceMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{247}
}
func (m *DatabaseResourceMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseResourceMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseResourceMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseResourceMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseResourceMatcher.Merge(m, src)
}
func (m *DatabaseResourceMatcher) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseResourceMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseResourceMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseResourceMatcher proto.InternalMessageInfo

// ResourceMatcherAWS contains AWS specific settings for resource matcher.
type ResourceMatcherAWS struct {
	// AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
	AssumeRoleARN string `protobuf:"bytes,1,opt,name=AssumeRoleARN,proto3" json:"assume_role_arn,omitempty"`
	// ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
	ExternalID           string   `protobuf:"bytes,2,opt,name=ExternalID,proto3" json:"external_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceMatcherAWS) Reset()         { *m = ResourceMatcherAWS{} }
func (m *ResourceMatcherAWS) String() string { return proto.CompactTextString(m) }
func (*ResourceMatcherAWS) ProtoMessage()    {}
func (*ResourceMatcherAWS) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{248}
}
func (m *ResourceMatcherAWS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceMatcherAWS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceMatcherAWS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceMatcherAWS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceMatcherAWS.Merge(m, src)
}
func (m *ResourceMatcherAWS) XXX_Size() int {
	return m.Size()
}
func (m *ResourceMatcherAWS) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceMatcherAWS.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceMatcherAWS proto.InternalMessageInfo

// ClusterAlert is a cluster-level alert message.
type ClusterAlert struct {
	ResourceHeader       `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	Spec                 ClusterAlertSpec `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ClusterAlert) Reset()         { *m = ClusterAlert{} }
func (m *ClusterAlert) String() string { return proto.CompactTextString(m) }
func (*ClusterAlert) ProtoMessage()    {}
func (*ClusterAlert) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{249}
}
func (m *ClusterAlert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterAlert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterAlert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterAlert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterAlert.Merge(m, src)
}
func (m *ClusterAlert) XXX_Size() int {
	return m.Size()
}
func (m *ClusterAlert) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterAlert.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterAlert proto.InternalMessageInfo

// ClusterAlertSpec is a cluster alert specification.
type ClusterAlertSpec struct {
	// Severity represents how problematic/urgent the alert is.
	Severity AlertSeverity `protobuf:"varint,1,opt,name=Severity,proto3,enum=types.AlertSeverity" json:"severity"`
	// Message is the user-facing message associated with the alert.
	Message string `protobuf:"bytes,2,opt,name=Message,proto3" json:"message"`
	// Created is the time at which the alert was generated.
	Created              time.Time `protobuf:"bytes,3,opt,name=Created,proto3,stdtime" json:"created,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ClusterAlertSpec) Reset()         { *m = ClusterAlertSpec{} }
func (m *ClusterAlertSpec) String() string { return proto.CompactTextString(m) }
func (*ClusterAlertSpec) ProtoMessage()    {}
func (*ClusterAlertSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{250}
}
func (m *ClusterAlertSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterAlertSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterAlertSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterAlertSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterAlertSpec.Merge(m, src)
}
func (m *ClusterAlertSpec) XXX_Size() int {
	return m.Size()
}
func (m *ClusterAlertSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterAlertSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterAlertSpec proto.InternalMessageInfo

// GetClusterAlertsRequest matches cluster alerts.
type GetClusterAlertsRequest struct {
	// Severity is an optional minimum severity.
	Severity AlertSeverity `protobuf:"varint,1,opt,name=Severity,proto3,enum=types.AlertSeverity" json:"Severity,omitempty"`
	// AlertID optionally specifies the ID of the alert being requested.
	AlertID string `protobuf:"bytes,2,opt,name=AlertID,proto3" json:"AlertID,omitempty"`
	// Labels is an optional label selector.
	Labels map[string]string `protobuf:"bytes,3,rep,name=Labels,proto3" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// WithSuperseded includes superseded alerts in the output of the request.
	WithSuperseded bool `protobuf:"varint,4,opt,name=WithSuperseded,proto3" json:"WithSuperseded,omitempty"`
	// WithAcknowledged includes acknowledged alerts in the output of the request.
	WithAcknowledged bool `protobuf:"varint,5,opt,name=WithAcknowledged,proto3" json:"WithAcknowledged,omitempty"`
	// WithUntargeted requests that alerts be included even if they are not specifically
	// targeted toward the caller. This has no effect unless the caller has `cluster_alert:list`.
	WithUntargeted       bool     `protobuf:"varint,6,opt,name=WithUntargeted,proto3" json:"WithUntargeted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetClusterAlertsRequest) Reset()         { *m = GetClusterAlertsRequest{} }
func (m *GetClusterAlertsRequest) String() string { return proto.CompactTextString(m) }
func (*GetClusterAlertsRequest) ProtoMessage()    {}
func (*GetClusterAlertsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{251}
}
func (m *GetClusterAlertsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterAlertsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterAlertsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterAlertsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterAlertsRequest.Merge(m, src)
}
func (m *GetClusterAlertsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterAlertsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterAlertsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterAlertsRequest proto.InternalMessageInfo

// AlertAcknowledgement marks a cluster alert as having been "acknowledged".
// This causes the alert to no longer be displayed in 'tsh login', UI banners,
// etc. Acknowledgements must have an expiry and a message describing why the
// alert can be considered acknowledged.
type AlertAcknowledgement struct {
	// AlertID is the ID of the alert being acknowledged.
	AlertID string `protobuf:"bytes,1,opt,name=AlertID,proto3" json:"alert_id,omitempty"`
	// Reason describes the reason why the alert can be considered
	// acknowledged (e.g. 'alice will fix next week').
	Reason string `protobuf:"bytes,2,opt,name=Reason,proto3" json:"reason,omitempty"`
	// Expires is the time after which the acknowledgement expires.
	Expires              time.Time `protobuf:"bytes,4,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AlertAcknowledgement) Reset()         { *m = AlertAcknowledgement{} }
func (m *AlertAcknowledgement) String() string { return proto.CompactTextString(m) }
func (*AlertAcknowledgement) ProtoMessage()    {}
func (*AlertAcknowledgement) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{252}
}
func (m *AlertAcknowledgement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlertAcknowledgement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlertAcknowledgement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlertAcknowledgement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlertAcknowledgement.Merge(m, src)
}
func (m *AlertAcknowledgement) XXX_Size() int {
	return m.Size()
}
func (m *AlertAcknowledgement) XXX_DiscardUnknown() {
	xxx_messageInfo_AlertAcknowledgement.DiscardUnknown(m)
}

var xxx_messageInfo_AlertAcknowledgement proto.InternalMessageInfo

// Release correspond to a Teleport Enterprise releases
type Release struct {
	// NotesMD is the notes of the release in markdown
	NotesMD string `protobuf:"bytes,1,opt,name=NotesMD,proto3" json:"notes_md"`
	// Product is the release product, teleport or teleport-ent
	Product string `protobuf:"bytes,2,opt,name=Product,proto3" json:"product"`
	// ReleaseID is the ID of the product
	ReleaseID string `protobuf:"bytes,3,opt,name=ReleaseID,proto3" json:"release_id"`
	// Status is the status of the release
	Status string `protobuf:"bytes,4,opt,name=Status,proto3" json:"status"`
	// Version is the version of the release
	Version string `protobuf:"bytes,5,opt,name=Version,proto3" json:"version"`
	// Assets is a list of assets related to the release
	Assets               []*Asset `protobuf:"bytes,6,rep,name=Assets,proto3" json:"assets"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Release) Reset()         { *m = Release{} }
func (m *Release) String() string { return proto.CompactTextString(m) }
func (*Release) ProtoMessage()    {}
func (*Release) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{253}
}
func (m *Release) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Release) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Release.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Release) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Release.Merge(m, src)
}
func (m *Release) XXX_Size() int {
	return m.Size()
}
func (m *Release) XXX_DiscardUnknown() {
	xxx_messageInfo_Release.DiscardUnknown(m)
}

var xxx_messageInfo_Release proto.InternalMessageInfo

// Asset represents a release asset
type Asset struct {
	// Arch is the architecture of the asset
	Arch string `protobuf:"bytes,1,opt,name=Arch,proto3" json:"arch"`
	// Description is the description of the asset
	Description string `protobuf:"bytes,2,opt,name=Description,proto3" json:"description"`
	// Name is the name of the asset
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name"`
	// OS is which OS the asset is built for
	OS string `protobuf:"bytes,4,opt,name=OS,proto3" json:"os"`
	// SHA256 is the sha256 of the asset
	SHA256 string `protobuf:"bytes,5,opt,name=SHA256,proto3" json:"sha256"`
	// Size is the size of the release in bytes
	AssetSize int64 `protobuf:"varint,6,opt,name=AssetSize,proto3" json:"asset_size"`
	// DisplaySize is the human-readable size of the asset
	DisplaySize string `protobuf:"bytes,7,opt,name=DisplaySize,proto3" json:"display_size"`
	// ReleaseIDs is a list of releases that have the asset included
	ReleaseIDs []string `protobuf:"bytes,8,rep,name=ReleaseIDs,proto3" json:"release_ids"`
	// PublicURL is the public URL used to download the asset
	PublicURL            string   `protobuf:"bytes,9,opt,name=PublicURL,proto3" json:"public_url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Asset) Reset()         { *m = Asset{} }
func (m *Asset) String() string { return proto.CompactTextString(m) }
func (*Asset) ProtoMessage()    {}
func (*Asset) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{254}
}
func (m *Asset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Asset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Asset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Asset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Asset.Merge(m, src)
}
func (m *Asset) XXX_Size() int {
	return m.Size()
}
func (m *Asset) XXX_DiscardUnknown() {
	xxx_messageInfo_Asset.DiscardUnknown(m)
}

var xxx_messageInfo_Asset proto.InternalMessageInfo

// Plugin describes a single instance of a Teleport Plugin
type PluginV1 struct {
	// kind is the plugin resource kind.
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// sub_kind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	// version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// metadata is the resource metadata.
	Metadata Metadata       `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata"`
	Spec     PluginSpecV1   `protobuf:"bytes,5,opt,name=spec,proto3" json:"spec"`
	Status   PluginStatusV1 `protobuf:"bytes,6,opt,name=status,proto3" json:"status"`
	// credentials are "live" credentials to the 3rd party API.
	// These are considered secrets.
	Credentials          *PluginCredentialsV1 `protobuf:"bytes,7,opt,name=credentials,proto3" json:"credentials,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PluginV1) Reset()         { *m = PluginV1{} }
func (m *PluginV1) String() string { return proto.CompactTextString(m) }
func (*PluginV1) ProtoMessage()    {}
func (*PluginV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{255}
}
func (m *PluginV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginV1.Merge(m, src)
}
func (m *PluginV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginV1 proto.InternalMessageInfo

type PluginSpecV1 struct {
	// settings contain provider-specific plugin options.
	//
	// Types that are valid to be assigned to Settings:
	//
	//	*PluginSpecV1_SlackAccessPlugin
	//	*PluginSpecV1_Opsgenie
	//	*PluginSpecV1_Openai
	//	*PluginSpecV1_Okta
	//	*PluginSpecV1_Jamf
	//	*PluginSpecV1_PagerDuty
	//	*PluginSpecV1_Mattermost
	//	*PluginSpecV1_Jira
	//	*PluginSpecV1_Discord
	//	*PluginSpecV1_ServiceNow
	//	*PluginSpecV1_Gitlab
	//	*PluginSpecV1_EntraId
	//	*PluginSpecV1_Scim
	Settings isPluginSpecV1_Settings `protobuf_oneof:"settings"`
	// generation contains a unique ID that should:
	// - Be created by the backend on plugin creation.
	// - Be updated by the backend if the plugin is updated in any way.
	//
	// For older plugins, it's possible for this to be empty.
	Generation           string   `protobuf:"bytes,11,opt,name=generation,proto3" json:"generation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginSpecV1) Reset()         { *m = PluginSpecV1{} }
func (m *PluginSpecV1) String() string { return proto.CompactTextString(m) }
func (*PluginSpecV1) ProtoMessage()    {}
func (*PluginSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{256}
}
func (m *PluginSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginSpecV1.Merge(m, src)
}
func (m *PluginSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginSpecV1 proto.InternalMessageInfo

type isPluginSpecV1_Settings interface {
	isPluginSpecV1_Settings()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PluginSpecV1_SlackAccessPlugin struct {
	SlackAccessPlugin *PluginSlackAccessSettings `protobuf:"bytes,1,opt,name=slack_access_plugin,json=slackAccessPlugin,proto3,oneof" json:"slack_access_plugin,omitempty"`
}
type PluginSpecV1_Opsgenie struct {
	Opsgenie *PluginOpsgenieAccessSettings `protobuf:"bytes,2,opt,name=opsgenie,proto3,oneof" json:"opsgenie,omitempty"`
}
type PluginSpecV1_Openai struct {
	Openai *PluginOpenAISettings `protobuf:"bytes,3,opt,name=openai,proto3,oneof" json:"openai,omitempty"`
}
type PluginSpecV1_Okta struct {
	Okta *PluginOktaSettings `protobuf:"bytes,4,opt,name=okta,proto3,oneof" json:"okta,omitempty"`
}
type PluginSpecV1_Jamf struct {
	Jamf *PluginJamfSettings `protobuf:"bytes,5,opt,name=jamf,proto3,oneof" json:"jamf,omitempty"`
}
type PluginSpecV1_PagerDuty struct {
	PagerDuty *PluginPagerDutySettings `protobuf:"bytes,6,opt,name=pager_duty,json=pagerDuty,proto3,oneof" json:"pager_duty,omitempty"`
}
type PluginSpecV1_Mattermost struct {
	Mattermost *PluginMattermostSettings `protobuf:"bytes,7,opt,name=mattermost,proto3,oneof" json:"mattermost,omitempty"`
}
type PluginSpecV1_Jira struct {
	Jira *PluginJiraSettings `protobuf:"bytes,8,opt,name=jira,proto3,oneof" json:"jira,omitempty"`
}
type PluginSpecV1_Discord struct {
	Discord *PluginDiscordSettings `protobuf:"bytes,9,opt,name=discord,proto3,oneof" json:"discord,omitempty"`
}
type PluginSpecV1_ServiceNow struct {
	ServiceNow *PluginServiceNowSettings `protobuf:"bytes,10,opt,name=serviceNow,proto3,oneof" json:"serviceNow,omitempty"`
}
type PluginSpecV1_Gitlab struct {
	Gitlab *PluginGitlabSettings `protobuf:"bytes,12,opt,name=gitlab,proto3,oneof" json:"gitlab,omitempty"`
}
type PluginSpecV1_EntraId struct {
	EntraId *PluginEntraIDSettings `protobuf:"bytes,13,opt,name=entra_id,json=entraId,proto3,oneof" json:"entra_id,omitempty"`
}
type PluginSpecV1_Scim struct {
	Scim *PluginSCIMSettings `protobuf:"bytes,14,opt,name=scim,proto3,oneof" json:"scim,omitempty"`
}

func (*PluginSpecV1_SlackAccessPlugin) isPluginSpecV1_Settings() {}
func (*PluginSpecV1_Opsgenie) isPluginSpecV1_Settings()          {}
func (*PluginSpecV1_Openai) isPluginSpecV1_Settings()            {}
func (*PluginSpecV1_Okta) isPluginSpecV1_Settings()              {}
func (*PluginSpecV1_Jamf) isPluginSpecV1_Settings()              {}
func (*PluginSpecV1_PagerDuty) isPluginSpecV1_Settings()         {}
func (*PluginSpecV1_Mattermost) isPluginSpecV1_Settings()        {}
func (*PluginSpecV1_Jira) isPluginSpecV1_Settings()              {}
func (*PluginSpecV1_Discord) isPluginSpecV1_Settings()           {}
func (*PluginSpecV1_ServiceNow) isPluginSpecV1_Settings()        {}
func (*PluginSpecV1_Gitlab) isPluginSpecV1_Settings()            {}
func (*PluginSpecV1_EntraId) isPluginSpecV1_Settings()           {}
func (*PluginSpecV1_Scim) isPluginSpecV1_Settings()              {}

func (m *PluginSpecV1) GetSettings() isPluginSpecV1_Settings {
	if m != nil {
		return m.Settings
	}
	return nil
}

func (m *PluginSpecV1) GetSlackAccessPlugin() *PluginSlackAccessSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_SlackAccessPlugin); ok {
		return x.SlackAccessPlugin
	}
	return nil
}

func (m *PluginSpecV1) GetOpsgenie() *PluginOpsgenieAccessSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Opsgenie); ok {
		return x.Opsgenie
	}
	return nil
}

func (m *PluginSpecV1) GetOpenai() *PluginOpenAISettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Openai); ok {
		return x.Openai
	}
	return nil
}

func (m *PluginSpecV1) GetOkta() *PluginOktaSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Okta); ok {
		return x.Okta
	}
	return nil
}

func (m *PluginSpecV1) GetJamf() *PluginJamfSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Jamf); ok {
		return x.Jamf
	}
	return nil
}

func (m *PluginSpecV1) GetPagerDuty() *PluginPagerDutySettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_PagerDuty); ok {
		return x.PagerDuty
	}
	return nil
}

func (m *PluginSpecV1) GetMattermost() *PluginMattermostSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Mattermost); ok {
		return x.Mattermost
	}
	return nil
}

func (m *PluginSpecV1) GetJira() *PluginJiraSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Jira); ok {
		return x.Jira
	}
	return nil
}

func (m *PluginSpecV1) GetDiscord() *PluginDiscordSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Discord); ok {
		return x.Discord
	}
	return nil
}

func (m *PluginSpecV1) GetServiceNow() *PluginServiceNowSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_ServiceNow); ok {
		return x.ServiceNow
	}
	return nil
}

func (m *PluginSpecV1) GetGitlab() *PluginGitlabSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Gitlab); ok {
		return x.Gitlab
	}
	return nil
}

func (m *PluginSpecV1) GetEntraId() *PluginEntraIDSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_EntraId); ok {
		return x.EntraId
	}
	return nil
}

func (m *PluginSpecV1) GetScim() *PluginSCIMSettings {
	if x, ok := m.GetSettings().(*PluginSpecV1_Scim); ok {
		return x.Scim
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PluginSpecV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PluginSpecV1_SlackAccessPlugin)(nil),
		(*PluginSpecV1_Opsgenie)(nil),
		(*PluginSpecV1_Openai)(nil),
		(*PluginSpecV1_Okta)(nil),
		(*PluginSpecV1_Jamf)(nil),
		(*PluginSpecV1_PagerDuty)(nil),
		(*PluginSpecV1_Mattermost)(nil),
		(*PluginSpecV1_Jira)(nil),
		(*PluginSpecV1_Discord)(nil),
		(*PluginSpecV1_ServiceNow)(nil),
		(*PluginSpecV1_Gitlab)(nil),
		(*PluginSpecV1_EntraId)(nil),
		(*PluginSpecV1_Scim)(nil),
	}
}

type PluginSlackAccessSettings struct {
	FallbackChannel      string   `protobuf:"bytes,1,opt,name=fallback_channel,json=fallbackChannel,proto3" json:"fallback_channel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginSlackAccessSettings) Reset()         { *m = PluginSlackAccessSettings{} }
func (m *PluginSlackAccessSettings) String() string { return proto.CompactTextString(m) }
func (*PluginSlackAccessSettings) ProtoMessage()    {}
func (*PluginSlackAccessSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{257}
}
func (m *PluginSlackAccessSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginSlackAccessSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginSlackAccessSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginSlackAccessSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginSlackAccessSettings.Merge(m, src)
}
func (m *PluginSlackAccessSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginSlackAccessSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginSlackAccessSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginSlackAccessSettings proto.InternalMessageInfo

type PluginGitlabSettings struct {
	// APIEndpoint is the address of Gitlab API.
	ApiEndpoint          string   `protobuf:"bytes,1,opt,name=api_endpoint,json=apiEndpoint,proto3" json:"api_endpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginGitlabSettings) Reset()         { *m = PluginGitlabSettings{} }
func (m *PluginGitlabSettings) String() string { return proto.CompactTextString(m) }
func (*PluginGitlabSettings) ProtoMessage()    {}
func (*PluginGitlabSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{258}
}
func (m *PluginGitlabSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginGitlabSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginGitlabSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginGitlabSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginGitlabSettings.Merge(m, src)
}
func (m *PluginGitlabSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginGitlabSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginGitlabSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginGitlabSettings proto.InternalMessageInfo

type PluginOpsgenieAccessSettings struct {
	// Priority to create Opsgenie alerts with
	Priority string `protobuf:"bytes,2,opt,name=priority,proto3" json:"priority,omitempty"`
	// List of tags to be added to alerts created in Opsgenie
	AlertTags []string `protobuf:"bytes,3,rep,name=alert_tags,json=alertTags,proto3" json:"alert_tags,omitempty"`
	// Default on-call schedules to check if none are provided in the access request annotations
	DefaultSchedules []string `protobuf:"bytes,4,rep,name=default_schedules,json=defaultSchedules,proto3" json:"default_schedules,omitempty"`
	// APIEndpoint is the address of Opsgenie API.
	ApiEndpoint          string   `protobuf:"bytes,5,opt,name=api_endpoint,json=apiEndpoint,proto3" json:"api_endpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOpsgenieAccessSettings) Reset()         { *m = PluginOpsgenieAccessSettings{} }
func (m *PluginOpsgenieAccessSettings) String() string { return proto.CompactTextString(m) }
func (*PluginOpsgenieAccessSettings) ProtoMessage()    {}
func (*PluginOpsgenieAccessSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{259}
}
func (m *PluginOpsgenieAccessSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOpsgenieAccessSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOpsgenieAccessSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOpsgenieAccessSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOpsgenieAccessSettings.Merge(m, src)
}
func (m *PluginOpsgenieAccessSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginOpsgenieAccessSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOpsgenieAccessSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOpsgenieAccessSettings proto.InternalMessageInfo

// PluginServiceNowSettings are the settings for the serviceNow plugin
type PluginServiceNowSettings struct {
	// ApiEndpoint is the ServiceNow API endpoint.
	ApiEndpoint string `protobuf:"bytes,1,opt,name=api_endpoint,json=apiEndpoint,proto3" json:"api_endpoint,omitempty"`
	// Username is the ServiceNow API username.
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Password is the ServiceNow API password.
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// CloseCode is the close code that ServiceNow incidents will use.
	CloseCode            string   `protobuf:"bytes,4,opt,name=close_code,json=closeCode,proto3" json:"close_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginServiceNowSettings) Reset()         { *m = PluginServiceNowSettings{} }
func (m *PluginServiceNowSettings) String() string { return proto.CompactTextString(m) }
func (*PluginServiceNowSettings) ProtoMessage()    {}
func (*PluginServiceNowSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{260}
}
func (m *PluginServiceNowSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginServiceNowSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginServiceNowSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginServiceNowSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginServiceNowSettings.Merge(m, src)
}
func (m *PluginServiceNowSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginServiceNowSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginServiceNowSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginServiceNowSettings proto.InternalMessageInfo

type PluginPagerDutySettings struct {
	// UserEmail is the email address of the PagerDuty user that will be
	// listed as the reporter source of incidents, comments, etc
	// within PagerDuty. Should usually be the same user the API key
	// represents.
	UserEmail string `protobuf:"bytes,1,opt,name=user_email,json=userEmail,proto3" json:"user_email,omitempty"`
	// APIEndpoint is the address of PagerDuty API.
	ApiEndpoint          string   `protobuf:"bytes,2,opt,name=api_endpoint,json=apiEndpoint,proto3" json:"api_endpoint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginPagerDutySettings) Reset()         { *m = PluginPagerDutySettings{} }
func (m *PluginPagerDutySettings) String() string { return proto.CompactTextString(m) }
func (*PluginPagerDutySettings) ProtoMessage()    {}
func (*PluginPagerDutySettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{261}
}
func (m *PluginPagerDutySettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginPagerDutySettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginPagerDutySettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginPagerDutySettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginPagerDutySettings.Merge(m, src)
}
func (m *PluginPagerDutySettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginPagerDutySettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginPagerDutySettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginPagerDutySettings proto.InternalMessageInfo

type PluginJiraSettings struct {
	// ServerURL is the address of the target JIRA Server instance.
	ServerUrl string `protobuf:"bytes,1,opt,name=server_url,json=serverUrl,proto3" json:"server_url,omitempty"`
	// ProjectKey is the key of the Jira project that will receive
	// notifications and issues from the plugin.
	ProjectKey string `protobuf:"bytes,2,opt,name=project_key,json=projectKey,proto3" json:"project_key,omitempty"`
	// IssueType is the type of Jira Issue that the plugin will create
	IssueType            string   `protobuf:"bytes,3,opt,name=issue_type,json=issueType,proto3" json:"issue_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginJiraSettings) Reset()         { *m = PluginJiraSettings{} }
func (m *PluginJiraSettings) String() string { return proto.CompactTextString(m) }
func (*PluginJiraSettings) ProtoMessage()    {}
func (*PluginJiraSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{262}
}
func (m *PluginJiraSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginJiraSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginJiraSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginJiraSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginJiraSettings.Merge(m, src)
}
func (m *PluginJiraSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginJiraSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginJiraSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginJiraSettings proto.InternalMessageInfo

// Defines settings for the OpenAI plugin. Currently there are no settings.
type PluginOpenAISettings struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOpenAISettings) Reset()         { *m = PluginOpenAISettings{} }
func (m *PluginOpenAISettings) String() string { return proto.CompactTextString(m) }
func (*PluginOpenAISettings) ProtoMessage()    {}
func (*PluginOpenAISettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{263}
}
func (m *PluginOpenAISettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOpenAISettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOpenAISettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOpenAISettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOpenAISettings.Merge(m, src)
}
func (m *PluginOpenAISettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginOpenAISettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOpenAISettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOpenAISettings proto.InternalMessageInfo

// Defines settings for the Mattermost plugin.
type PluginMattermostSettings struct {
	// serverURL is the URL to access Mattermost.
	ServerUrl string `protobuf:"bytes,1,opt,name=server_url,json=serverUrl,proto3" json:"server_url,omitempty"`
	// team is the Mattermost workspace.
	Team string `protobuf:"bytes,2,opt,name=team,proto3" json:"team,omitempty"`
	// channel is the Mattermost channel in the workspace
	// (team) to send notifications to.
	Channel string `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel,omitempty"`
	// report_to_email is an optional email address of a Mattermost user
	// to notify via a direct message when the plugin receives an
	// Access Request event.
	ReportToEmail        string   `protobuf:"bytes,4,opt,name=report_to_email,json=reportToEmail,proto3" json:"report_to_email,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginMattermostSettings) Reset()         { *m = PluginMattermostSettings{} }
func (m *PluginMattermostSettings) String() string { return proto.CompactTextString(m) }
func (*PluginMattermostSettings) ProtoMessage()    {}
func (*PluginMattermostSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{264}
}
func (m *PluginMattermostSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginMattermostSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginMattermostSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginMattermostSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginMattermostSettings.Merge(m, src)
}
func (m *PluginMattermostSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginMattermostSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginMattermostSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginMattermostSettings proto.InternalMessageInfo

// Defines settings for Jamf plugin.
type PluginJamfSettings struct {
	// Jamf service spec
	JamfSpec             *JamfSpecV1 `protobuf:"bytes,1,opt,name=jamf_spec,json=jamfSpec,proto3" json:"jamf_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PluginJamfSettings) Reset()         { *m = PluginJamfSettings{} }
func (m *PluginJamfSettings) String() string { return proto.CompactTextString(m) }
func (*PluginJamfSettings) ProtoMessage()    {}
func (*PluginJamfSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{265}
}
func (m *PluginJamfSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginJamfSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginJamfSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginJamfSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginJamfSettings.Merge(m, src)
}
func (m *PluginJamfSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginJamfSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginJamfSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginJamfSettings proto.InternalMessageInfo

// Defines settings for the Okta plugin.
type PluginOktaSettings struct {
	// OrgUrl is the Okta organization URL to use for API communication.
	OrgUrl string `protobuf:"bytes,1,opt,name=org_url,json=orgUrl,proto3" json:"org_url,omitempty"`
	// EnableUserSync controls the user sync in the Okta integration service. Deprecated.
	// TODO(mdwn): Remove once e changes have been made.
	EnableUserSync bool `protobuf:"varint,2,opt,name=enable_user_sync,json=enableUserSync,proto3" json:"enable_user_sync,omitempty"`
	// SSOConnectorID (deprecated)
	// TODO(mdwn): Remove once e changes have been made.
	SsoConnectorId string `protobuf:"bytes,3,opt,name=sso_connector_id,json=ssoConnectorId,proto3" json:"sso_connector_id,omitempty"`
	// Sync settings controls the user and access list sync settings for Okta.
	SyncSettings         *PluginOktaSyncSettings `protobuf:"bytes,4,opt,name=sync_settings,json=syncSettings,proto3" json:"sync_settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *PluginOktaSettings) Reset()         { *m = PluginOktaSettings{} }
func (m *PluginOktaSettings) String() string { return proto.CompactTextString(m) }
func (*PluginOktaSettings) ProtoMessage()    {}
func (*PluginOktaSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{266}
}
func (m *PluginOktaSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaSettings.Merge(m, src)
}
func (m *PluginOktaSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaSettings proto.InternalMessageInfo

// Defines settings for syncing users and access lists from Okta.
type PluginOktaSyncSettings struct {
	// SyncUsers controls the user sync in the Okta integration service.
	SyncUsers bool `protobuf:"varint,1,opt,name=sync_users,json=syncUsers,proto3" json:"sync_users,omitempty"`
	// SSOConnectorID is the name of the Teleport SSO connector created and used by the Okta plugin
	SsoConnectorId string `protobuf:"bytes,2,opt,name=sso_connector_id,json=ssoConnectorId,proto3" json:"sso_connector_id,omitempty"`
	// SyncAccessLists controls the access list sync in the Okta integration service.
	SyncAccessLists bool `protobuf:"varint,3,opt,name=sync_access_lists,json=syncAccessLists,proto3" json:"sync_access_lists,omitempty"`
	// DefaultOwners are the default owners for all imported access lists.
	DefaultOwners []string `protobuf:"bytes,4,rep,name=default_owners,json=defaultOwners,proto3" json:"default_owners,omitempty"`
	// AppID is the Okta-assigned ID of the Okta App that Teleport uses as a
	// gateway to interact with Okta for SAML login, SCIM provisioning and user
	// sync. When set, user sync will pull users from the assignment list for this
	// app. When empty the plugin will fall back to the legacy behaviour of syncing
	// users from the entre organization.
	AppId string `protobuf:"bytes,5,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// GroupFilters are filters for which Okta groups to synchronize as access lists.
	// Filters can be globs, for example:
	//
	//	group*
	//	*service*
	//
	// Or regexes if they're prefixed and suffixed with ^ and $, for example:
	//
	//	^group.*$
	//	^.*service.*$
	GroupFilters []string `protobuf:"bytes,6,rep,name=group_filters,json=groupFilters,proto3" json:"group_filters,omitempty"`
	// AppFilters are filters for which Okta applications to synchronize as access lists.
	// Filters can be globs, for example:
	//
	//	app*
	//	*service*
	//
	// Or regexes if they're prefixed and suffixed with ^ and $, for example:
	//
	//	^app.*$
	//	^.*service.*$
	AppFilters           []string `protobuf:"bytes,7,rep,name=app_filters,json=appFilters,proto3" json:"app_filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOktaSyncSettings) Reset()         { *m = PluginOktaSyncSettings{} }
func (m *PluginOktaSyncSettings) String() string { return proto.CompactTextString(m) }
func (*PluginOktaSyncSettings) ProtoMessage()    {}
func (*PluginOktaSyncSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{267}
}
func (m *PluginOktaSyncSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaSyncSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaSyncSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaSyncSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaSyncSettings.Merge(m, src)
}
func (m *PluginOktaSyncSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaSyncSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaSyncSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaSyncSettings proto.InternalMessageInfo

// Defines a set of discord channel IDs
type DiscordChannels struct {
	ChannelIds           []string `protobuf:"bytes,1,rep,name=channel_ids,json=channelIds,proto3" json:"channel_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiscordChannels) Reset()         { *m = DiscordChannels{} }
func (m *DiscordChannels) String() string { return proto.CompactTextString(m) }
func (*DiscordChannels) ProtoMessage()    {}
func (*DiscordChannels) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{268}
}
func (m *DiscordChannels) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiscordChannels) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiscordChannels.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiscordChannels) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiscordChannels.Merge(m, src)
}
func (m *DiscordChannels) XXX_Size() int {
	return m.Size()
}
func (m *DiscordChannels) XXX_DiscardUnknown() {
	xxx_messageInfo_DiscordChannels.DiscardUnknown(m)
}

var xxx_messageInfo_DiscordChannels proto.InternalMessageInfo

// Defines settings for the discord plugin
type PluginDiscordSettings struct {
	// RoleToRecipients maps Teleport roles (by name) to the set of Discord
	// channel IDs that will receive notifications and requests regarding that
	// that Role.
	RoleToRecipients     map[string]*DiscordChannels `protobuf:"bytes,1,rep,name=role_to_recipients,json=roleToRecipients,proto3" json:"role_to_recipients,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *PluginDiscordSettings) Reset()         { *m = PluginDiscordSettings{} }
func (m *PluginDiscordSettings) String() string { return proto.CompactTextString(m) }
func (*PluginDiscordSettings) ProtoMessage()    {}
func (*PluginDiscordSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{269}
}
func (m *PluginDiscordSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginDiscordSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginDiscordSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginDiscordSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginDiscordSettings.Merge(m, src)
}
func (m *PluginDiscordSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginDiscordSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginDiscordSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginDiscordSettings proto.InternalMessageInfo

// PluginEntraIDSettings defines settings for the Entra ID sync plugin
type PluginEntraIDSettings struct {
	// SyncSettings controls the user and access list sync settings for EntraID.
	SyncSettings *PluginEntraIDSyncSettings `protobuf:"bytes,1,opt,name=sync_settings,json=syncSettings,proto3" json:"sync_settings,omitempty"`
	// AccessGraphSettings controls settings for syncing access graph specific data.
	// When this is null, Entra ID integration with Access Graph is disabled.
	AccessGraphSettings  *PluginEntraIDAccessGraphSettings `protobuf:"bytes,2,opt,name=access_graph_settings,json=accessGraphSettings,proto3" json:"access_graph_settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *PluginEntraIDSettings) Reset()         { *m = PluginEntraIDSettings{} }
func (m *PluginEntraIDSettings) String() string { return proto.CompactTextString(m) }
func (*PluginEntraIDSettings) ProtoMessage()    {}
func (*PluginEntraIDSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{270}
}
func (m *PluginEntraIDSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginEntraIDSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginEntraIDSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginEntraIDSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginEntraIDSettings.Merge(m, src)
}
func (m *PluginEntraIDSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginEntraIDSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginEntraIDSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginEntraIDSettings proto.InternalMessageInfo

// Defines settings for syncing users and access lists from Entra ID.
type PluginEntraIDSyncSettings struct {
	// DefaultOwners are the default owners for all imported access lists.
	DefaultOwners []string `protobuf:"bytes,1,rep,name=default_owners,json=defaultOwners,proto3" json:"default_owners,omitempty"`
	// SSOConnectorID is the name of the Teleport SSO connector created and used by the Entra ID plugin
	SsoConnectorId       string   `protobuf:"bytes,2,opt,name=sso_connector_id,json=ssoConnectorId,proto3" json:"sso_connector_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginEntraIDSyncSettings) Reset()         { *m = PluginEntraIDSyncSettings{} }
func (m *PluginEntraIDSyncSettings) String() string { return proto.CompactTextString(m) }
func (*PluginEntraIDSyncSettings) ProtoMessage()    {}
func (*PluginEntraIDSyncSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{271}
}
func (m *PluginEntraIDSyncSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginEntraIDSyncSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginEntraIDSyncSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginEntraIDSyncSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginEntraIDSyncSettings.Merge(m, src)
}
func (m *PluginEntraIDSyncSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginEntraIDSyncSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginEntraIDSyncSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginEntraIDSyncSettings proto.InternalMessageInfo

// AccessGraphSettings controls settings for syncing access graph specific data.
type PluginEntraIDAccessGraphSettings struct {
	// AppSsoSettingsCache is an array of single sign-on settings for Entra enterprise applications.
	//
	// This data is stored here because it is not available through traditional methods (MS Graph API).
	// Instead, it is fetched once during the plugin's set up using the user's credentials to connect to Azure's private API.
	AppSsoSettingsCache  []*PluginEntraIDAppSSOSettings `protobuf:"bytes,1,rep,name=app_sso_settings_cache,json=appSsoSettingsCache,proto3" json:"app_sso_settings_cache,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *PluginEntraIDAccessGraphSettings) Reset()         { *m = PluginEntraIDAccessGraphSettings{} }
func (m *PluginEntraIDAccessGraphSettings) String() string { return proto.CompactTextString(m) }
func (*PluginEntraIDAccessGraphSettings) ProtoMessage()    {}
func (*PluginEntraIDAccessGraphSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{272}
}
func (m *PluginEntraIDAccessGraphSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginEntraIDAccessGraphSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginEntraIDAccessGraphSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginEntraIDAccessGraphSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginEntraIDAccessGraphSettings.Merge(m, src)
}
func (m *PluginEntraIDAccessGraphSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginEntraIDAccessGraphSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginEntraIDAccessGraphSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginEntraIDAccessGraphSettings proto.InternalMessageInfo

// PluginEntraIDAppSSOSettings is a container for a single Entra ID enterprise application's
// cached SSO settings.
// As this data is only parsed by TAG, each value is stored as an opaque JSON blob.
type PluginEntraIDAppSSOSettings struct {
	// AppID is the `AppID` property of Entra application.
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// FederatedSSOV2 contains the cached, gzip-compressed payload from the /ApplicationSso/{servicePrincipalId}/FederatedSSOV2 endpoint.
	FederatedSsoV2       []byte   `protobuf:"bytes,2,opt,name=federated_sso_v2,json=federatedSsoV2,proto3" json:"federated_sso_v2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginEntraIDAppSSOSettings) Reset()         { *m = PluginEntraIDAppSSOSettings{} }
func (m *PluginEntraIDAppSSOSettings) String() string { return proto.CompactTextString(m) }
func (*PluginEntraIDAppSSOSettings) ProtoMessage()    {}
func (*PluginEntraIDAppSSOSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{273}
}
func (m *PluginEntraIDAppSSOSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginEntraIDAppSSOSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginEntraIDAppSSOSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginEntraIDAppSSOSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginEntraIDAppSSOSettings.Merge(m, src)
}
func (m *PluginEntraIDAppSSOSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginEntraIDAppSSOSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginEntraIDAppSSOSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginEntraIDAppSSOSettings proto.InternalMessageInfo

// PluginSCIMSettings defines the settings for a SCIM integration plugin
type PluginSCIMSettings struct {
	// SamlConnectorName is the name of the SAML Connector that users provisioned
	// by this SCIM plugin will use to log in to Teleport.
	SamlConnectorName string `protobuf:"bytes,1,opt,name=saml_connector_name,json=samlConnectorName,proto3" json:"saml_connector_name,omitempty"`
	// DefaultRole is the default role assigned to users provisioned by this
	// plugin.
	DefaultRole          string   `protobuf:"bytes,2,opt,name=default_role,json=defaultRole,proto3" json:"default_role,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginSCIMSettings) Reset()         { *m = PluginSCIMSettings{} }
func (m *PluginSCIMSettings) String() string { return proto.CompactTextString(m) }
func (*PluginSCIMSettings) ProtoMessage()    {}
func (*PluginSCIMSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{274}
}
func (m *PluginSCIMSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginSCIMSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginSCIMSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginSCIMSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginSCIMSettings.Merge(m, src)
}
func (m *PluginSCIMSettings) XXX_Size() int {
	return m.Size()
}
func (m *PluginSCIMSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginSCIMSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PluginSCIMSettings proto.InternalMessageInfo

type PluginBootstrapCredentialsV1 struct {
	// Types that are valid to be assigned to Credentials:
	//
	//	*PluginBootstrapCredentialsV1_Oauth2AuthorizationCode
	//	*PluginBootstrapCredentialsV1_BearerToken
	//	*PluginBootstrapCredentialsV1_IdSecret
	Credentials          isPluginBootstrapCredentialsV1_Credentials `protobuf_oneof:"credentials"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *PluginBootstrapCredentialsV1) Reset()         { *m = PluginBootstrapCredentialsV1{} }
func (m *PluginBootstrapCredentialsV1) String() string { return proto.CompactTextString(m) }
func (*PluginBootstrapCredentialsV1) ProtoMessage()    {}
func (*PluginBootstrapCredentialsV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{275}
}
func (m *PluginBootstrapCredentialsV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginBootstrapCredentialsV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginBootstrapCredentialsV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginBootstrapCredentialsV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginBootstrapCredentialsV1.Merge(m, src)
}
func (m *PluginBootstrapCredentialsV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginBootstrapCredentialsV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginBootstrapCredentialsV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginBootstrapCredentialsV1 proto.InternalMessageInfo

type isPluginBootstrapCredentialsV1_Credentials interface {
	isPluginBootstrapCredentialsV1_Credentials()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PluginBootstrapCredentialsV1_Oauth2AuthorizationCode struct {
	Oauth2AuthorizationCode *PluginOAuth2AuthorizationCodeCredentials `protobuf:"bytes,1,opt,name=oauth2_authorization_code,json=oauth2AuthorizationCode,proto3,oneof" json:"oauth2_authorization_code,omitempty"`
}
type PluginBootstrapCredentialsV1_BearerToken struct {
	BearerToken *PluginBearerTokenCredentials `protobuf:"bytes,2,opt,name=bearer_token,json=bearerToken,proto3,oneof" json:"bearer_token,omitempty"`
}
type PluginBootstrapCredentialsV1_IdSecret struct {
	IdSecret *PluginIdSecretCredential `protobuf:"bytes,3,opt,name=id_secret,json=idSecret,proto3,oneof" json:"id_secret,omitempty"`
}

func (*PluginBootstrapCredentialsV1_Oauth2AuthorizationCode) isPluginBootstrapCredentialsV1_Credentials() {
}
func (*PluginBootstrapCredentialsV1_BearerToken) isPluginBootstrapCredentialsV1_Credentials() {}
func (*PluginBootstrapCredentialsV1_IdSecret) isPluginBootstrapCredentialsV1_Credentials()    {}

func (m *PluginBootstrapCredentialsV1) GetCredentials() isPluginBootstrapCredentialsV1_Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *PluginBootstrapCredentialsV1) GetOauth2AuthorizationCode() *PluginOAuth2AuthorizationCodeCredentials {
	if x, ok := m.GetCredentials().(*PluginBootstrapCredentialsV1_Oauth2AuthorizationCode); ok {
		return x.Oauth2AuthorizationCode
	}
	return nil
}

func (m *PluginBootstrapCredentialsV1) GetBearerToken() *PluginBearerTokenCredentials {
	if x, ok := m.GetCredentials().(*PluginBootstrapCredentialsV1_BearerToken); ok {
		return x.BearerToken
	}
	return nil
}

func (m *PluginBootstrapCredentialsV1) GetIdSecret() *PluginIdSecretCredential {
	if x, ok := m.GetCredentials().(*PluginBootstrapCredentialsV1_IdSecret); ok {
		return x.IdSecret
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PluginBootstrapCredentialsV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PluginBootstrapCredentialsV1_Oauth2AuthorizationCode)(nil),
		(*PluginBootstrapCredentialsV1_BearerToken)(nil),
		(*PluginBootstrapCredentialsV1_IdSecret)(nil),
	}
}

// PluginIdSecretCredential can be OAuth2-like client_id and client_secret or username and password.
type PluginIdSecretCredential struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Secret               string   `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginIdSecretCredential) Reset()         { *m = PluginIdSecretCredential{} }
func (m *PluginIdSecretCredential) String() string { return proto.CompactTextString(m) }
func (*PluginIdSecretCredential) ProtoMessage()    {}
func (*PluginIdSecretCredential) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{276}
}
func (m *PluginIdSecretCredential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginIdSecretCredential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginIdSecretCredential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginIdSecretCredential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginIdSecretCredential.Merge(m, src)
}
func (m *PluginIdSecretCredential) XXX_Size() int {
	return m.Size()
}
func (m *PluginIdSecretCredential) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginIdSecretCredential.DiscardUnknown(m)
}

var xxx_messageInfo_PluginIdSecretCredential proto.InternalMessageInfo

type PluginOAuth2AuthorizationCodeCredentials struct {
	AuthorizationCode    string   `protobuf:"bytes,1,opt,name=authorization_code,json=authorizationCode,proto3" json:"authorization_code,omitempty"`
	RedirectUri          string   `protobuf:"bytes,2,opt,name=redirect_uri,json=redirectUri,proto3" json:"redirect_uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOAuth2AuthorizationCodeCredentials) Reset() {
	*m = PluginOAuth2AuthorizationCodeCredentials{}
}
func (m *PluginOAuth2AuthorizationCodeCredentials) String() string { return proto.CompactTextString(m) }
func (*PluginOAuth2AuthorizationCodeCredentials) ProtoMessage()    {}
func (*PluginOAuth2AuthorizationCodeCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{277}
}
func (m *PluginOAuth2AuthorizationCodeCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOAuth2AuthorizationCodeCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOAuth2AuthorizationCodeCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOAuth2AuthorizationCodeCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOAuth2AuthorizationCodeCredentials.Merge(m, src)
}
func (m *PluginOAuth2AuthorizationCodeCredentials) XXX_Size() int {
	return m.Size()
}
func (m *PluginOAuth2AuthorizationCodeCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOAuth2AuthorizationCodeCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOAuth2AuthorizationCodeCredentials proto.InternalMessageInfo

// PluginStatus is the user-facing status for the plugin instance.
type PluginStatusV1 struct {
	Code PluginStatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=types.PluginStatusCode" json:"code,omitempty"`
	// error_message is a human-readable error message that can be displayed to the user.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// last_sync_time is the last time the plugin was run.
	LastSyncTime time.Time `protobuf:"bytes,3,opt,name=last_sync_time,json=lastSyncTime,proto3,stdtime" json:"last_sync_time"`
	// details contains provider-specific plugin status details.
	//
	// Types that are valid to be assigned to Details:
	//
	//	*PluginStatusV1_Gitlab
	//	*PluginStatusV1_EntraId
	//	*PluginStatusV1_Okta
	Details isPluginStatusV1_Details `protobuf_oneof:"details"`
	// last_raw_error variable stores the most recent raw error message received from an API or service.
	// It is intended to capture the original error message without any modifications or formatting.
	// This can be useful for debugging purposes, providing detailed information about what went wrong
	// in the interaction with the external service.
	LastRawError         string   `protobuf:"bytes,6,opt,name=last_raw_error,json=lastRawError,proto3" json:"last_raw_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginStatusV1) Reset()         { *m = PluginStatusV1{} }
func (m *PluginStatusV1) String() string { return proto.CompactTextString(m) }
func (*PluginStatusV1) ProtoMessage()    {}
func (*PluginStatusV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{278}
}
func (m *PluginStatusV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginStatusV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginStatusV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginStatusV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginStatusV1.Merge(m, src)
}
func (m *PluginStatusV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginStatusV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginStatusV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginStatusV1 proto.InternalMessageInfo

type isPluginStatusV1_Details interface {
	isPluginStatusV1_Details()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PluginStatusV1_Gitlab struct {
	Gitlab *PluginGitlabStatusV1 `protobuf:"bytes,4,opt,name=gitlab,proto3,oneof" json:"gitlab,omitempty"`
}
type PluginStatusV1_EntraId struct {
	EntraId *PluginEntraIDStatusV1 `protobuf:"bytes,5,opt,name=entra_id,json=entraId,proto3,oneof" json:"entra_id,omitempty"`
}
type PluginStatusV1_Okta struct {
	Okta *PluginOktaStatusV1 `protobuf:"bytes,7,opt,name=okta,proto3,oneof" json:"okta,omitempty"`
}

func (*PluginStatusV1_Gitlab) isPluginStatusV1_Details()  {}
func (*PluginStatusV1_EntraId) isPluginStatusV1_Details() {}
func (*PluginStatusV1_Okta) isPluginStatusV1_Details()    {}

func (m *PluginStatusV1) GetDetails() isPluginStatusV1_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *PluginStatusV1) GetGitlab() *PluginGitlabStatusV1 {
	if x, ok := m.GetDetails().(*PluginStatusV1_Gitlab); ok {
		return x.Gitlab
	}
	return nil
}

func (m *PluginStatusV1) GetEntraId() *PluginEntraIDStatusV1 {
	if x, ok := m.GetDetails().(*PluginStatusV1_EntraId); ok {
		return x.EntraId
	}
	return nil
}

func (m *PluginStatusV1) GetOkta() *PluginOktaStatusV1 {
	if x, ok := m.GetDetails().(*PluginStatusV1_Okta); ok {
		return x.Okta
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PluginStatusV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PluginStatusV1_Gitlab)(nil),
		(*PluginStatusV1_EntraId)(nil),
		(*PluginStatusV1_Okta)(nil),
	}
}

// PluginGitlabStatusV1 is the status details for the Gitlab plugin.
type PluginGitlabStatusV1 struct {
	// imported_users is the number of users imported from Gitlab.
	ImportedUsers uint32 `protobuf:"varint,1,opt,name=imported_users,json=importedUsers,proto3" json:"imported_users,omitempty"`
	// imported_groups is the number of groups imported from Gitlab.
	ImportedGroups uint32 `protobuf:"varint,2,opt,name=imported_groups,json=importedGroups,proto3" json:"imported_groups,omitempty"`
	// imported_projects is the number of projects imported from Gitlab.
	ImportedProjects     uint32   `protobuf:"varint,3,opt,name=imported_projects,json=importedProjects,proto3" json:"imported_projects,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginGitlabStatusV1) Reset()         { *m = PluginGitlabStatusV1{} }
func (m *PluginGitlabStatusV1) String() string { return proto.CompactTextString(m) }
func (*PluginGitlabStatusV1) ProtoMessage()    {}
func (*PluginGitlabStatusV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{279}
}
func (m *PluginGitlabStatusV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginGitlabStatusV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginGitlabStatusV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginGitlabStatusV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginGitlabStatusV1.Merge(m, src)
}
func (m *PluginGitlabStatusV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginGitlabStatusV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginGitlabStatusV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginGitlabStatusV1 proto.InternalMessageInfo

// PluginEntraIDStatusV1 is the status details for the Entra ID plugin.
type PluginEntraIDStatusV1 struct {
	// imported_users is the number of users imported from Entra ID.
	ImportedUsers uint32 `protobuf:"varint,1,opt,name=imported_users,json=importedUsers,proto3" json:"imported_users,omitempty"`
	// imported_groups is the number of groups imported from Entra ID.
	ImportedGroups       uint32   `protobuf:"varint,2,opt,name=imported_groups,json=importedGroups,proto3" json:"imported_groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginEntraIDStatusV1) Reset()         { *m = PluginEntraIDStatusV1{} }
func (m *PluginEntraIDStatusV1) String() string { return proto.CompactTextString(m) }
func (*PluginEntraIDStatusV1) ProtoMessage()    {}
func (*PluginEntraIDStatusV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{280}
}
func (m *PluginEntraIDStatusV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginEntraIDStatusV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginEntraIDStatusV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginEntraIDStatusV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginEntraIDStatusV1.Merge(m, src)
}
func (m *PluginEntraIDStatusV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginEntraIDStatusV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginEntraIDStatusV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginEntraIDStatusV1 proto.InternalMessageInfo

// PluginOktaStatusV1 contains the details for the running Okta plugin.
type PluginOktaStatusV1 struct {
	// SSODetails are status details relating to SSO.
	SsoDetails *PluginOktaStatusDetailsSSO `protobuf:"bytes,1,opt,name=sso_details,json=ssoDetails,proto3" json:"sso_details,omitempty"`
	// AppGroupSyncDetails are status details relating to synchronizing apps and
	// groups from Okta.
	AppGroupSyncDetails *PluginOktaStatusDetailsAppGroupSync `protobuf:"bytes,2,opt,name=app_group_sync_details,json=appGroupSyncDetails,proto3" json:"app_group_sync_details,omitempty"`
	// UsersSyncDetails are status details relating to synchronizing users from
	// Okta.
	UsersSyncDetails *PluginOktaStatusDetailsUsersSync `protobuf:"bytes,3,opt,name=users_sync_details,json=usersSyncDetails,proto3" json:"users_sync_details,omitempty"`
	// ScimDetails are status details relating to SCIM integration with
	// Okta.
	ScimDetails *PluginOktaStatusDetailsSCIM `protobuf:"bytes,4,opt,name=scim_details,json=scimDetails,proto3" json:"scim_details,omitempty"`
	// AccessListSyncDetails are status details relating to synchronizing access
	// lists from Okta.
	AccessListsSyncDetails *PluginOktaStatusDetailsAccessListsSync `protobuf:"bytes,5,opt,name=access_lists_sync_details,json=accessListsSyncDetails,proto3" json:"access_lists_sync_details,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                                `json:"-"`
	XXX_unrecognized       []byte                                  `json:"-"`
	XXX_sizecache          int32                                   `json:"-"`
}

func (m *PluginOktaStatusV1) Reset()         { *m = PluginOktaStatusV1{} }
func (m *PluginOktaStatusV1) String() string { return proto.CompactTextString(m) }
func (*PluginOktaStatusV1) ProtoMessage()    {}
func (*PluginOktaStatusV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{281}
}
func (m *PluginOktaStatusV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaStatusV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaStatusV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaStatusV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaStatusV1.Merge(m, src)
}
func (m *PluginOktaStatusV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaStatusV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaStatusV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaStatusV1 proto.InternalMessageInfo

// PluginOktaStatusDetailsSSO are details related to the
// current status of the Okta integration w/r/t SSO.
type PluginOktaStatusDetailsSSO struct {
	// Enabled indicates whether SSO login is enabled.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// AppId is the unique Okta application ID of the Okta Applicaion used for
	// SSO login.
	AppId string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// AppName is the human-readable name of the Okta Applicaion used for SSO.
	AppName              string   `protobuf:"bytes,3,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOktaStatusDetailsSSO) Reset()         { *m = PluginOktaStatusDetailsSSO{} }
func (m *PluginOktaStatusDetailsSSO) String() string { return proto.CompactTextString(m) }
func (*PluginOktaStatusDetailsSSO) ProtoMessage()    {}
func (*PluginOktaStatusDetailsSSO) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{282}
}
func (m *PluginOktaStatusDetailsSSO) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaStatusDetailsSSO) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaStatusDetailsSSO.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaStatusDetailsSSO) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaStatusDetailsSSO.Merge(m, src)
}
func (m *PluginOktaStatusDetailsSSO) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaStatusDetailsSSO) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaStatusDetailsSSO.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaStatusDetailsSSO proto.InternalMessageInfo

// PluginOktaStatusDetailsAppGroupSync are details related to the
// current status of the Okta integration w/r/t application and group
// sync.
type PluginOktaStatusDetailsAppGroupSync struct {
	// Enabled is whether the users sync is enabled.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// StatusCode indicates the current state of the App & Group sync service
	StatusCode OktaPluginSyncStatusCode `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3,enum=types.OktaPluginSyncStatusCode" json:"status_code,omitempty"`
	// LastSuccessful is the date of the last successful run.
	LastSuccessful *time.Time `protobuf:"bytes,3,opt,name=last_successful,json=lastSuccessful,proto3,stdtime" json:"last_successful"`
	// LastFailed is the date of the last failed run.
	LastFailed *time.Time `protobuf:"bytes,4,opt,name=last_failed,json=lastFailed,proto3,stdtime" json:"last_failed"`
	// NumAppsSynced is the total number of apps synchronized.
	NumAppsSynced int32 `protobuf:"varint,5,opt,name=num_apps_synced,json=numAppsSynced,proto3" json:"num_apps_synced,omitempty"`
	// NumAppsSynced is the total number of groups synchronized.
	NumGroupsSynced int32 `protobuf:"varint,6,opt,name=num_groups_synced,json=numGroupsSynced,proto3" json:"num_groups_synced,omitempty"`
	// Error contains a textual description of the reason the last synchronization
	// failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
	Error                string   `protobuf:"bytes,7,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOktaStatusDetailsAppGroupSync) Reset()         { *m = PluginOktaStatusDetailsAppGroupSync{} }
func (m *PluginOktaStatusDetailsAppGroupSync) String() string { return proto.CompactTextString(m) }
func (*PluginOktaStatusDetailsAppGroupSync) ProtoMessage()    {}
func (*PluginOktaStatusDetailsAppGroupSync) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{283}
}
func (m *PluginOktaStatusDetailsAppGroupSync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaStatusDetailsAppGroupSync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaStatusDetailsAppGroupSync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaStatusDetailsAppGroupSync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaStatusDetailsAppGroupSync.Merge(m, src)
}
func (m *PluginOktaStatusDetailsAppGroupSync) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaStatusDetailsAppGroupSync) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaStatusDetailsAppGroupSync.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaStatusDetailsAppGroupSync proto.InternalMessageInfo

// PluginOktaStatusDetailsUsersSync are details related to the
// current status of the Okta integration w/r/t users sync.
type PluginOktaStatusDetailsUsersSync struct {
	// Enabled is whether the users sync is enabled.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// StatusCode indicates the current state of the User sync service
	StatusCode OktaPluginSyncStatusCode `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3,enum=types.OktaPluginSyncStatusCode" json:"status_code,omitempty"`
	// LastSuccessful is the date of the last successful run.
	LastSuccessful *time.Time `protobuf:"bytes,3,opt,name=last_successful,json=lastSuccessful,proto3,stdtime" json:"last_successful"`
	// LastFailed is the date of the last failed run.
	LastFailed *time.Time `protobuf:"bytes,4,opt,name=last_failed,json=lastFailed,proto3,stdtime" json:"last_failed"`
	// NumUsersSynced is the total number of users synchronized.
	NumUsersSynced int32 `protobuf:"varint,5,opt,name=num_users_synced,json=numUsersSynced,proto3" json:"num_users_synced,omitempty"`
	// Error contains a textual description of the reason the last synchronization
	// failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
	Error                string   `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOktaStatusDetailsUsersSync) Reset()         { *m = PluginOktaStatusDetailsUsersSync{} }
func (m *PluginOktaStatusDetailsUsersSync) String() string { return proto.CompactTextString(m) }
func (*PluginOktaStatusDetailsUsersSync) ProtoMessage()    {}
func (*PluginOktaStatusDetailsUsersSync) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{284}
}
func (m *PluginOktaStatusDetailsUsersSync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaStatusDetailsUsersSync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaStatusDetailsUsersSync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaStatusDetailsUsersSync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaStatusDetailsUsersSync.Merge(m, src)
}
func (m *PluginOktaStatusDetailsUsersSync) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaStatusDetailsUsersSync) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaStatusDetailsUsersSync.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaStatusDetailsUsersSync proto.InternalMessageInfo

// PluginOktaStatusDetailsSCIM are details related to the
// current status of the Okta integration w/r/t SCIM.
type PluginOktaStatusDetailsSCIM struct {
	// Enabled is whether SCIM is enabled.
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOktaStatusDetailsSCIM) Reset()         { *m = PluginOktaStatusDetailsSCIM{} }
func (m *PluginOktaStatusDetailsSCIM) String() string { return proto.CompactTextString(m) }
func (*PluginOktaStatusDetailsSCIM) ProtoMessage()    {}
func (*PluginOktaStatusDetailsSCIM) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{285}
}
func (m *PluginOktaStatusDetailsSCIM) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaStatusDetailsSCIM) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaStatusDetailsSCIM.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaStatusDetailsSCIM) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaStatusDetailsSCIM.Merge(m, src)
}
func (m *PluginOktaStatusDetailsSCIM) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaStatusDetailsSCIM) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaStatusDetailsSCIM.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaStatusDetailsSCIM proto.InternalMessageInfo

// PluginOktaStatusDetailsAccessListsSync are details related to the
// current status of the Okta integration w/r/t access list sync.
type PluginOktaStatusDetailsAccessListsSync struct {
	// Enabled is whether access lists sync is enabled.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// StatusCode indicates the current state of the AccessList sync service
	StatusCode OktaPluginSyncStatusCode `protobuf:"varint,2,opt,name=status_code,json=statusCode,proto3,enum=types.OktaPluginSyncStatusCode" json:"status_code,omitempty"`
	// LastSuccessful is the date of the last successful run.
	LastSuccessful *time.Time `protobuf:"bytes,3,opt,name=last_successful,json=lastSuccessful,proto3,stdtime" json:"last_successful"`
	// LastFailed is the date of the last failed run.
	LastFailed *time.Time `protobuf:"bytes,4,opt,name=last_failed,json=lastFailed,proto3,stdtime" json:"last_failed"`
	// AppFilters are the app filters used for the access list sync.
	AppFilters []string `protobuf:"bytes,5,rep,name=app_filters,json=appFilters,proto3" json:"app_filters,omitempty"`
	// NumAppsSynced are the number of applications synchronized as access lists.
	NumAppsSynced int32 `protobuf:"varint,6,opt,name=num_apps_synced,json=numAppsSynced,proto3" json:"num_apps_synced,omitempty"`
	// GroupFilters are the group filters used for the access list sync.
	GroupFilters []string `protobuf:"bytes,7,rep,name=group_filters,json=groupFilters,proto3" json:"group_filters,omitempty"`
	// NumGroupsSynced are the number of groups synchronized as access lists.
	NumGroupsSynced int32 `protobuf:"varint,8,opt,name=num_groups_synced,json=numGroupsSynced,proto3" json:"num_groups_synced,omitempty"`
	// Error contains a textual description of the reason the last synchronization
	// failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
	Error                string   `protobuf:"bytes,9,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginOktaStatusDetailsAccessListsSync) Reset() {
	*m = PluginOktaStatusDetailsAccessListsSync{}
}
func (m *PluginOktaStatusDetailsAccessListsSync) String() string { return proto.CompactTextString(m) }
func (*PluginOktaStatusDetailsAccessListsSync) ProtoMessage()    {}
func (*PluginOktaStatusDetailsAccessListsSync) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{286}
}
func (m *PluginOktaStatusDetailsAccessListsSync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOktaStatusDetailsAccessListsSync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOktaStatusDetailsAccessListsSync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOktaStatusDetailsAccessListsSync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOktaStatusDetailsAccessListsSync.Merge(m, src)
}
func (m *PluginOktaStatusDetailsAccessListsSync) XXX_Size() int {
	return m.Size()
}
func (m *PluginOktaStatusDetailsAccessListsSync) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOktaStatusDetailsAccessListsSync.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOktaStatusDetailsAccessListsSync proto.InternalMessageInfo

// PluginCredentialsV1 represents "live" credentials
// that are used by the plugin to authenticate to the 3rd party API.
type PluginCredentialsV1 struct {
	// Types that are valid to be assigned to Credentials:
	//
	//	*PluginCredentialsV1_Oauth2AccessToken
	//	*PluginCredentialsV1_BearerToken
	//	*PluginCredentialsV1_IdSecret
	//	*PluginCredentialsV1_StaticCredentialsRef
	Credentials          isPluginCredentialsV1_Credentials `protobuf_oneof:"credentials"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *PluginCredentialsV1) Reset()         { *m = PluginCredentialsV1{} }
func (m *PluginCredentialsV1) String() string { return proto.CompactTextString(m) }
func (*PluginCredentialsV1) ProtoMessage()    {}
func (*PluginCredentialsV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{287}
}
func (m *PluginCredentialsV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginCredentialsV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginCredentialsV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginCredentialsV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginCredentialsV1.Merge(m, src)
}
func (m *PluginCredentialsV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginCredentialsV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginCredentialsV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginCredentialsV1 proto.InternalMessageInfo

type isPluginCredentialsV1_Credentials interface {
	isPluginCredentialsV1_Credentials()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PluginCredentialsV1_Oauth2AccessToken struct {
	Oauth2AccessToken *PluginOAuth2AccessTokenCredentials `protobuf:"bytes,1,opt,name=oauth2_access_token,json=oauth2AccessToken,proto3,oneof" json:"oauth2_access_token,omitempty"`
}
type PluginCredentialsV1_BearerToken struct {
	BearerToken *PluginBearerTokenCredentials `protobuf:"bytes,2,opt,name=bearer_token,json=bearerToken,proto3,oneof" json:"bearer_token,omitempty"`
}
type PluginCredentialsV1_IdSecret struct {
	IdSecret *PluginIdSecretCredential `protobuf:"bytes,3,opt,name=id_secret,json=idSecret,proto3,oneof" json:"id_secret,omitempty"`
}
type PluginCredentialsV1_StaticCredentialsRef struct {
	StaticCredentialsRef *PluginStaticCredentialsRef `protobuf:"bytes,4,opt,name=static_credentials_ref,json=staticCredentialsRef,proto3,oneof" json:"static_credentials_ref,omitempty"`
}

func (*PluginCredentialsV1_Oauth2AccessToken) isPluginCredentialsV1_Credentials()    {}
func (*PluginCredentialsV1_BearerToken) isPluginCredentialsV1_Credentials()          {}
func (*PluginCredentialsV1_IdSecret) isPluginCredentialsV1_Credentials()             {}
func (*PluginCredentialsV1_StaticCredentialsRef) isPluginCredentialsV1_Credentials() {}

func (m *PluginCredentialsV1) GetCredentials() isPluginCredentialsV1_Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *PluginCredentialsV1) GetOauth2AccessToken() *PluginOAuth2AccessTokenCredentials {
	if x, ok := m.GetCredentials().(*PluginCredentialsV1_Oauth2AccessToken); ok {
		return x.Oauth2AccessToken
	}
	return nil
}

func (m *PluginCredentialsV1) GetBearerToken() *PluginBearerTokenCredentials {
	if x, ok := m.GetCredentials().(*PluginCredentialsV1_BearerToken); ok {
		return x.BearerToken
	}
	return nil
}

func (m *PluginCredentialsV1) GetIdSecret() *PluginIdSecretCredential {
	if x, ok := m.GetCredentials().(*PluginCredentialsV1_IdSecret); ok {
		return x.IdSecret
	}
	return nil
}

func (m *PluginCredentialsV1) GetStaticCredentialsRef() *PluginStaticCredentialsRef {
	if x, ok := m.GetCredentials().(*PluginCredentialsV1_StaticCredentialsRef); ok {
		return x.StaticCredentialsRef
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PluginCredentialsV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PluginCredentialsV1_Oauth2AccessToken)(nil),
		(*PluginCredentialsV1_BearerToken)(nil),
		(*PluginCredentialsV1_IdSecret)(nil),
		(*PluginCredentialsV1_StaticCredentialsRef)(nil),
	}
}

type PluginOAuth2AccessTokenCredentials struct {
	AccessToken          string    `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	RefreshToken         string    `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
	Expires              time.Time `protobuf:"bytes,3,opt,name=expires,proto3,stdtime" json:"expires"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PluginOAuth2AccessTokenCredentials) Reset()         { *m = PluginOAuth2AccessTokenCredentials{} }
func (m *PluginOAuth2AccessTokenCredentials) String() string { return proto.CompactTextString(m) }
func (*PluginOAuth2AccessTokenCredentials) ProtoMessage()    {}
func (*PluginOAuth2AccessTokenCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{288}
}
func (m *PluginOAuth2AccessTokenCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginOAuth2AccessTokenCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginOAuth2AccessTokenCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginOAuth2AccessTokenCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginOAuth2AccessTokenCredentials.Merge(m, src)
}
func (m *PluginOAuth2AccessTokenCredentials) XXX_Size() int {
	return m.Size()
}
func (m *PluginOAuth2AccessTokenCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginOAuth2AccessTokenCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_PluginOAuth2AccessTokenCredentials proto.InternalMessageInfo

type PluginBearerTokenCredentials struct {
	// Token is the literal bearer token to be submitted to the 3rd-party API provider.
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginBearerTokenCredentials) Reset()         { *m = PluginBearerTokenCredentials{} }
func (m *PluginBearerTokenCredentials) String() string { return proto.CompactTextString(m) }
func (*PluginBearerTokenCredentials) ProtoMessage()    {}
func (*PluginBearerTokenCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{289}
}
func (m *PluginBearerTokenCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginBearerTokenCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginBearerTokenCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginBearerTokenCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginBearerTokenCredentials.Merge(m, src)
}
func (m *PluginBearerTokenCredentials) XXX_Size() int {
	return m.Size()
}
func (m *PluginBearerTokenCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginBearerTokenCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_PluginBearerTokenCredentials proto.InternalMessageInfo

// PluginStaticCredentialsRef is a reference to plugin static credentials by labels.
type PluginStaticCredentialsRef struct {
	// Labels is the set of labels to use to match against a set of static credentials.
	Labels               map[string]string `protobuf:"bytes,1,rep,name=Labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PluginStaticCredentialsRef) Reset()         { *m = PluginStaticCredentialsRef{} }
func (m *PluginStaticCredentialsRef) String() string { return proto.CompactTextString(m) }
func (*PluginStaticCredentialsRef) ProtoMessage()    {}
func (*PluginStaticCredentialsRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{290}
}
func (m *PluginStaticCredentialsRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginStaticCredentialsRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginStaticCredentialsRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginStaticCredentialsRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginStaticCredentialsRef.Merge(m, src)
}
func (m *PluginStaticCredentialsRef) XXX_Size() int {
	return m.Size()
}
func (m *PluginStaticCredentialsRef) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginStaticCredentialsRef.DiscardUnknown(m)
}

var xxx_messageInfo_PluginStaticCredentialsRef proto.InternalMessageInfo

// PluginList represents a list of plugin resources
type PluginListV1 struct {
	// Plugins is a list of plugin resources.
	Plugins              []*PluginV1 `protobuf:"bytes,1,rep,name=plugins,proto3" json:"plugins,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *PluginListV1) Reset()         { *m = PluginListV1{} }
func (m *PluginListV1) String() string { return proto.CompactTextString(m) }
func (*PluginListV1) ProtoMessage()    {}
func (*PluginListV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{291}
}
func (m *PluginListV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginListV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginListV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginListV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginListV1.Merge(m, src)
}
func (m *PluginListV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginListV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginListV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginListV1 proto.InternalMessageInfo

// PluginStaticCredentialsV1 is a representation of static credentials for plugins.
type PluginStaticCredentialsV1 struct {
	// Header is the resource header for the plugin static credentials object.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:"Header"`
	// Spec contains the actual credentials for the object.
	Spec                 *PluginStaticCredentialsSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"Spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *PluginStaticCredentialsV1) Reset()      { *m = PluginStaticCredentialsV1{} }
func (*PluginStaticCredentialsV1) ProtoMessage() {}
func (*PluginStaticCredentialsV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{292}
}
func (m *PluginStaticCredentialsV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginStaticCredentialsV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginStaticCredentialsV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginStaticCredentialsV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginStaticCredentialsV1.Merge(m, src)
}
func (m *PluginStaticCredentialsV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginStaticCredentialsV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginStaticCredentialsV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginStaticCredentialsV1 proto.InternalMessageInfo

// PluginStaticCredentialsSpecV1 is the specification for the static credentials object.
type PluginStaticCredentialsSpecV1 struct {
	// Types that are valid to be assigned to Credentials:
	//
	//	*PluginStaticCredentialsSpecV1_APIToken
	//	*PluginStaticCredentialsSpecV1_BasicAuth
	//	*PluginStaticCredentialsSpecV1_OAuthClientSecret
	Credentials          isPluginStaticCredentialsSpecV1_Credentials `protobuf_oneof:"credentials"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *PluginStaticCredentialsSpecV1) Reset()         { *m = PluginStaticCredentialsSpecV1{} }
func (m *PluginStaticCredentialsSpecV1) String() string { return proto.CompactTextString(m) }
func (*PluginStaticCredentialsSpecV1) ProtoMessage()    {}
func (*PluginStaticCredentialsSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{293}
}
func (m *PluginStaticCredentialsSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginStaticCredentialsSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginStaticCredentialsSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginStaticCredentialsSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginStaticCredentialsSpecV1.Merge(m, src)
}
func (m *PluginStaticCredentialsSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *PluginStaticCredentialsSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginStaticCredentialsSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_PluginStaticCredentialsSpecV1 proto.InternalMessageInfo

type isPluginStaticCredentialsSpecV1_Credentials interface {
	isPluginStaticCredentialsSpecV1_Credentials()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PluginStaticCredentialsSpecV1_APIToken struct {
	APIToken string `protobuf:"bytes,1,opt,name=APIToken,proto3,oneof" json:"APIToken,omitempty"`
}
type PluginStaticCredentialsSpecV1_BasicAuth struct {
	BasicAuth *PluginStaticCredentialsBasicAuth `protobuf:"bytes,2,opt,name=BasicAuth,proto3,oneof" json:"BasicAuth,omitempty"`
}
type PluginStaticCredentialsSpecV1_OAuthClientSecret struct {
	OAuthClientSecret *PluginStaticCredentialsOAuthClientSecret `protobuf:"bytes,3,opt,name=OAuthClientSecret,proto3,oneof" json:"OAuthClientSecret,omitempty"`
}

func (*PluginStaticCredentialsSpecV1_APIToken) isPluginStaticCredentialsSpecV1_Credentials()  {}
func (*PluginStaticCredentialsSpecV1_BasicAuth) isPluginStaticCredentialsSpecV1_Credentials() {}
func (*PluginStaticCredentialsSpecV1_OAuthClientSecret) isPluginStaticCredentialsSpecV1_Credentials() {
}

func (m *PluginStaticCredentialsSpecV1) GetCredentials() isPluginStaticCredentialsSpecV1_Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *PluginStaticCredentialsSpecV1) GetAPIToken() string {
	if x, ok := m.GetCredentials().(*PluginStaticCredentialsSpecV1_APIToken); ok {
		return x.APIToken
	}
	return ""
}

func (m *PluginStaticCredentialsSpecV1) GetBasicAuth() *PluginStaticCredentialsBasicAuth {
	if x, ok := m.GetCredentials().(*PluginStaticCredentialsSpecV1_BasicAuth); ok {
		return x.BasicAuth
	}
	return nil
}

func (m *PluginStaticCredentialsSpecV1) GetOAuthClientSecret() *PluginStaticCredentialsOAuthClientSecret {
	if x, ok := m.GetCredentials().(*PluginStaticCredentialsSpecV1_OAuthClientSecret); ok {
		return x.OAuthClientSecret
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PluginStaticCredentialsSpecV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PluginStaticCredentialsSpecV1_APIToken)(nil),
		(*PluginStaticCredentialsSpecV1_BasicAuth)(nil),
		(*PluginStaticCredentialsSpecV1_OAuthClientSecret)(nil),
	}
}

// PluginStaticCredentialsBasicAuth represents username and password credentials for a plugin.
type PluginStaticCredentialsBasicAuth struct {
	// Username is the username to use for basic auth.
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	// Password is the password to use for basic auth.
	Password             string   `protobuf:"bytes,2,opt,name=Password,proto3" json:"password"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginStaticCredentialsBasicAuth) Reset()         { *m = PluginStaticCredentialsBasicAuth{} }
func (m *PluginStaticCredentialsBasicAuth) String() string { return proto.CompactTextString(m) }
func (*PluginStaticCredentialsBasicAuth) ProtoMessage()    {}
func (*PluginStaticCredentialsBasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{294}
}
func (m *PluginStaticCredentialsBasicAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginStaticCredentialsBasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginStaticCredentialsBasicAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginStaticCredentialsBasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginStaticCredentialsBasicAuth.Merge(m, src)
}
func (m *PluginStaticCredentialsBasicAuth) XXX_Size() int {
	return m.Size()
}
func (m *PluginStaticCredentialsBasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginStaticCredentialsBasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_PluginStaticCredentialsBasicAuth proto.InternalMessageInfo

// PluginStaticCredentialsOAuthClientSecret represents an oauth client id and secret.
type PluginStaticCredentialsOAuthClientSecret struct {
	// ClientId is the client ID to use for OAuth client secret.
	ClientId string `protobuf:"bytes,1,opt,name=ClientId,proto3" json:"client_id"`
	// ClientSecret is the client secret to use.
	ClientSecret         string   `protobuf:"bytes,2,opt,name=ClientSecret,proto3" json:"client_secret"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PluginStaticCredentialsOAuthClientSecret) Reset() {
	*m = PluginStaticCredentialsOAuthClientSecret{}
}
func (m *PluginStaticCredentialsOAuthClientSecret) String() string { return proto.CompactTextString(m) }
func (*PluginStaticCredentialsOAuthClientSecret) ProtoMessage()    {}
func (*PluginStaticCredentialsOAuthClientSecret) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{295}
}
func (m *PluginStaticCredentialsOAuthClientSecret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginStaticCredentialsOAuthClientSecret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginStaticCredentialsOAuthClientSecret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginStaticCredentialsOAuthClientSecret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginStaticCredentialsOAuthClientSecret.Merge(m, src)
}
func (m *PluginStaticCredentialsOAuthClientSecret) XXX_Size() int {
	return m.Size()
}
func (m *PluginStaticCredentialsOAuthClientSecret) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginStaticCredentialsOAuthClientSecret.DiscardUnknown(m)
}

var xxx_messageInfo_PluginStaticCredentialsOAuthClientSecret proto.InternalMessageInfo

// SAMLIdPServiceProviderV1 is the representation of a SAML IdP service provider.
type SAMLIdPServiceProviderV1 struct {
	// Header is the resource header for the SAML IdP service provider.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the SAML IdP service provider spec.
	Spec                 SAMLIdPServiceProviderSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *SAMLIdPServiceProviderV1) Reset()      { *m = SAMLIdPServiceProviderV1{} }
func (*SAMLIdPServiceProviderV1) ProtoMessage() {}
func (*SAMLIdPServiceProviderV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{296}
}
func (m *SAMLIdPServiceProviderV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLIdPServiceProviderV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLIdPServiceProviderV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLIdPServiceProviderV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLIdPServiceProviderV1.Merge(m, src)
}
func (m *SAMLIdPServiceProviderV1) XXX_Size() int {
	return m.Size()
}
func (m *SAMLIdPServiceProviderV1) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLIdPServiceProviderV1.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLIdPServiceProviderV1 proto.InternalMessageInfo

// SAMLIdPServiceProviderSpecV1 is the SAMLIdPServiceProviderV1 resource spec.
type SAMLIdPServiceProviderSpecV1 struct {
	// EntityDescriptor is the entity descriptor for the service provider
	EntityDescriptor string `protobuf:"bytes,1,opt,name=EntityDescriptor,proto3" json:"entity_descriptor"`
	// EntityID is the entity ID for the entity descriptor. If entity descriptor is provided,
	// this value is checked that it matches the entity ID in the entity descriptor
	// at upsert time to avoid having to parse the XML blob in the entity descriptor
	// every time we need to use this resource.
	EntityID string `protobuf:"bytes,2,opt,name=EntityID,proto3" json:"entity_id"`
	// ACSURL is the endpoint where SAML authentication response will be redirected.
	ACSURL string `protobuf:"bytes,3,opt,name=ACSURL,proto3" json:"acs_url"`
	// AttributeMapping is used to map service provider requested attributes to
	// username, role and traits in Teleport.
	AttributeMapping []*SAMLAttributeMapping `protobuf:"bytes,4,rep,name=AttributeMapping,proto3" json:"attribute_mapping"`
	// Preset is used to define service provider profile that will have a custom behavior
	// processed by Teleport.
	Preset string `protobuf:"bytes,5,opt,name=Preset,proto3" json:"preset"`
	// RelayState is used to add custom value in the SAML response as a relay_state HTTP parameter.
	// The value can contain service provider specific redirect URL, static state token etc.
	// The value is only applied in the IdP initiated SSO flow.
	RelayState           string   `protobuf:"bytes,6,opt,name=RelayState,proto3" json:"relay_state"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SAMLIdPServiceProviderSpecV1) Reset()         { *m = SAMLIdPServiceProviderSpecV1{} }
func (m *SAMLIdPServiceProviderSpecV1) String() string { return proto.CompactTextString(m) }
func (*SAMLIdPServiceProviderSpecV1) ProtoMessage()    {}
func (*SAMLIdPServiceProviderSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{297}
}
func (m *SAMLIdPServiceProviderSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLIdPServiceProviderSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLIdPServiceProviderSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLIdPServiceProviderSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLIdPServiceProviderSpecV1.Merge(m, src)
}
func (m *SAMLIdPServiceProviderSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *SAMLIdPServiceProviderSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLIdPServiceProviderSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLIdPServiceProviderSpecV1 proto.InternalMessageInfo

// SAMLAttributeMapping represents SAML service provider requested attribute
// name, format and its values.
type SAMLAttributeMapping struct {
	// name is an attribute name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	// name_format is an attribute name format.
	NameFormat string `protobuf:"bytes,2,opt,name=name_format,json=nameFormat,proto3" json:"name_format"`
	// value is an attribute value definable with predicate expression.
	Value                string   `protobuf:"bytes,3,opt,name=value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SAMLAttributeMapping) Reset()         { *m = SAMLAttributeMapping{} }
func (m *SAMLAttributeMapping) String() string { return proto.CompactTextString(m) }
func (*SAMLAttributeMapping) ProtoMessage()    {}
func (*SAMLAttributeMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{298}
}
func (m *SAMLAttributeMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SAMLAttributeMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SAMLAttributeMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SAMLAttributeMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SAMLAttributeMapping.Merge(m, src)
}
func (m *SAMLAttributeMapping) XXX_Size() int {
	return m.Size()
}
func (m *SAMLAttributeMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_SAMLAttributeMapping.DiscardUnknown(m)
}

var xxx_messageInfo_SAMLAttributeMapping proto.InternalMessageInfo

// IdPOptions specify options related to access Teleport IdPs.
type IdPOptions struct {
	// SAML are options related to the Teleport SAML IdP.
	SAML                 *IdPSAMLOptions `protobuf:"bytes,1,opt,name=SAML,proto3" json:"saml"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *IdPOptions) Reset()         { *m = IdPOptions{} }
func (m *IdPOptions) String() string { return proto.CompactTextString(m) }
func (*IdPOptions) ProtoMessage()    {}
func (*IdPOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{299}
}
func (m *IdPOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdPOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdPOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdPOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdPOptions.Merge(m, src)
}
func (m *IdPOptions) XXX_Size() int {
	return m.Size()
}
func (m *IdPOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_IdPOptions.DiscardUnknown(m)
}

var xxx_messageInfo_IdPOptions proto.InternalMessageInfo

// IdPSAMLOptions specifies options related to accessing the Teleport SAML IdP.
type IdPSAMLOptions struct {
	// Enabled is set to true if this option allows access to the Teleport SAML IdP.
	Enabled              *BoolOption `protobuf:"bytes,1,opt,name=Enabled,proto3,customtype=BoolOption" json:"enabled"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *IdPSAMLOptions) Reset()         { *m = IdPSAMLOptions{} }
func (m *IdPSAMLOptions) String() string { return proto.CompactTextString(m) }
func (*IdPSAMLOptions) ProtoMessage()    {}
func (*IdPSAMLOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{300}
}
func (m *IdPSAMLOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdPSAMLOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdPSAMLOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdPSAMLOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdPSAMLOptions.Merge(m, src)
}
func (m *IdPSAMLOptions) XXX_Size() int {
	return m.Size()
}
func (m *IdPSAMLOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_IdPSAMLOptions.DiscardUnknown(m)
}

var xxx_messageInfo_IdPSAMLOptions proto.InternalMessageInfo

// KubernetesResourceV1 represents a Kubernetes resource.
type KubernetesResourceV1 struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is KubernetesResourceV1 metadata
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec contains the Kubernetes resource data.
	Spec                 KubernetesResourceSpecV1 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *KubernetesResourceV1) Reset()         { *m = KubernetesResourceV1{} }
func (m *KubernetesResourceV1) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourceV1) ProtoMessage()    {}
func (*KubernetesResourceV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{301}
}
func (m *KubernetesResourceV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourceV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourceV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourceV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourceV1.Merge(m, src)
}
func (m *KubernetesResourceV1) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourceV1) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourceV1.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourceV1 proto.InternalMessageInfo

// KubernetesResourceSpecV1 is the Kubernetes resource spec.
type KubernetesResourceSpecV1 struct {
	// Namespace is the resource namespace.
	Namespace            string   `protobuf:"bytes,1,opt,name=Namespace,proto3" json:"namespace"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesResourceSpecV1) Reset()         { *m = KubernetesResourceSpecV1{} }
func (m *KubernetesResourceSpecV1) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourceSpecV1) ProtoMessage()    {}
func (*KubernetesResourceSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{302}
}
func (m *KubernetesResourceSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourceSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourceSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourceSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourceSpecV1.Merge(m, src)
}
func (m *KubernetesResourceSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourceSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourceSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourceSpecV1 proto.InternalMessageInfo

// ClusterMaintenanceConfigV1 is a config singleton used to configure infrequent
// cluster maintenance operations.
type ClusterMaintenanceConfigV1 struct {
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	Spec           ClusterMaintenanceConfigSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	// Nonce is used to protect against concurrent modification of the maintenance
	// window. Clients should treat nonces as opaque.
	Nonce                uint64   `protobuf:"varint,3,opt,name=Nonce,proto3" json:"nonce,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterMaintenanceConfigV1) Reset()         { *m = ClusterMaintenanceConfigV1{} }
func (m *ClusterMaintenanceConfigV1) String() string { return proto.CompactTextString(m) }
func (*ClusterMaintenanceConfigV1) ProtoMessage()    {}
func (*ClusterMaintenanceConfigV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{303}
}
func (m *ClusterMaintenanceConfigV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterMaintenanceConfigV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterMaintenanceConfigV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterMaintenanceConfigV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterMaintenanceConfigV1.Merge(m, src)
}
func (m *ClusterMaintenanceConfigV1) XXX_Size() int {
	return m.Size()
}
func (m *ClusterMaintenanceConfigV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterMaintenanceConfigV1.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterMaintenanceConfigV1 proto.InternalMessageInfo

// ClusterMaintenanceConfigSpecV1 encodes the parameters of the upgrade window config object.
type ClusterMaintenanceConfigSpecV1 struct {
	// AgentUpgrades encodes the agent upgrade window.
	AgentUpgrades        *AgentUpgradeWindow `protobuf:"bytes,1,opt,name=AgentUpgrades,proto3" json:"agent_upgrades,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ClusterMaintenanceConfigSpecV1) Reset()         { *m = ClusterMaintenanceConfigSpecV1{} }
func (m *ClusterMaintenanceConfigSpecV1) String() string { return proto.CompactTextString(m) }
func (*ClusterMaintenanceConfigSpecV1) ProtoMessage()    {}
func (*ClusterMaintenanceConfigSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{304}
}
func (m *ClusterMaintenanceConfigSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterMaintenanceConfigSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterMaintenanceConfigSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterMaintenanceConfigSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterMaintenanceConfigSpecV1.Merge(m, src)
}
func (m *ClusterMaintenanceConfigSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *ClusterMaintenanceConfigSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterMaintenanceConfigSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterMaintenanceConfigSpecV1 proto.InternalMessageInfo

// AgentUpgradeWindow is the config object used to determine upcoming agent
// upgrade windows.
type AgentUpgradeWindow struct {
	// UTCStartHour is the start hour of the maintenance window in UTC.
	UTCStartHour uint32 `protobuf:"varint,1,opt,name=UTCStartHour,proto3" json:"utc_start_hour"`
	// Weekdays is an optional list of weekdays. If not specified, an agent upgrade window
	// occurs every day.
	Weekdays             []string `protobuf:"bytes,2,rep,name=Weekdays,proto3" json:"weekdays,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AgentUpgradeWindow) Reset()         { *m = AgentUpgradeWindow{} }
func (m *AgentUpgradeWindow) String() string { return proto.CompactTextString(m) }
func (*AgentUpgradeWindow) ProtoMessage()    {}
func (*AgentUpgradeWindow) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{305}
}
func (m *AgentUpgradeWindow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgentUpgradeWindow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgentUpgradeWindow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgentUpgradeWindow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgentUpgradeWindow.Merge(m, src)
}
func (m *AgentUpgradeWindow) XXX_Size() int {
	return m.Size()
}
func (m *AgentUpgradeWindow) XXX_DiscardUnknown() {
	xxx_messageInfo_AgentUpgradeWindow.DiscardUnknown(m)
}

var xxx_messageInfo_AgentUpgradeWindow proto.InternalMessageInfo

// ScheduledAgentUpgradeWindow is a derived value representing a single
// upgrade window. Upgraders deal with discrete start/end times, so we use the
// agent upgrade window configuration object to generate a sequence of specific
// scheduled windows.
type ScheduledAgentUpgradeWindow struct {
	// Start is the start time of the upgrade window.
	Start time.Time `protobuf:"bytes,1,opt,name=Start,proto3,stdtime" json:"start"`
	// Stop is the stop time of the upgrade window.
	Stop                 time.Time `protobuf:"bytes,2,opt,name=Stop,proto3,stdtime" json:"stop"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ScheduledAgentUpgradeWindow) Reset()         { *m = ScheduledAgentUpgradeWindow{} }
func (m *ScheduledAgentUpgradeWindow) String() string { return proto.CompactTextString(m) }
func (*ScheduledAgentUpgradeWindow) ProtoMessage()    {}
func (*ScheduledAgentUpgradeWindow) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{306}
}
func (m *ScheduledAgentUpgradeWindow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduledAgentUpgradeWindow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduledAgentUpgradeWindow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduledAgentUpgradeWindow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduledAgentUpgradeWindow.Merge(m, src)
}
func (m *ScheduledAgentUpgradeWindow) XXX_Size() int {
	return m.Size()
}
func (m *ScheduledAgentUpgradeWindow) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduledAgentUpgradeWindow.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduledAgentUpgradeWindow proto.InternalMessageInfo

// AgentUpgradeSchedule is the canonical representation of upcoming
// agent upgrade windows as generated by the AgentUpgradeWindow config object.
type AgentUpgradeSchedule struct {
	// Windows is the list of upcoming windows.
	Windows              []ScheduledAgentUpgradeWindow `protobuf:"bytes,1,rep,name=Windows,proto3" json:"windows"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *AgentUpgradeSchedule) Reset()         { *m = AgentUpgradeSchedule{} }
func (m *AgentUpgradeSchedule) String() string { return proto.CompactTextString(m) }
func (*AgentUpgradeSchedule) ProtoMessage()    {}
func (*AgentUpgradeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{307}
}
func (m *AgentUpgradeSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgentUpgradeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgentUpgradeSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgentUpgradeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgentUpgradeSchedule.Merge(m, src)
}
func (m *AgentUpgradeSchedule) XXX_Size() int {
	return m.Size()
}
func (m *AgentUpgradeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_AgentUpgradeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_AgentUpgradeSchedule proto.InternalMessageInfo

// UserGroupV1 is a representation of an externally sourced user group.
type UserGroupV1 struct {
	// Header is the resource header for the user group.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the user group resource spec.
	Spec                 UserGroupSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UserGroupV1) Reset()      { *m = UserGroupV1{} }
func (*UserGroupV1) ProtoMessage() {}
func (*UserGroupV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{308}
}
func (m *UserGroupV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserGroupV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserGroupV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserGroupV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserGroupV1.Merge(m, src)
}
func (m *UserGroupV1) XXX_Size() int {
	return m.Size()
}
func (m *UserGroupV1) XXX_DiscardUnknown() {
	xxx_messageInfo_UserGroupV1.DiscardUnknown(m)
}

var xxx_messageInfo_UserGroupV1 proto.InternalMessageInfo

// UserGroupSpecV1 is the specification of a user group.
type UserGroupSpecV1 struct {
	// Applications are a list of application IDs belonging to this user group.
	Applications         []string `protobuf:"bytes,1,rep,name=Applications,proto3" json:"Applications,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserGroupSpecV1) Reset()         { *m = UserGroupSpecV1{} }
func (m *UserGroupSpecV1) String() string { return proto.CompactTextString(m) }
func (*UserGroupSpecV1) ProtoMessage()    {}
func (*UserGroupSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{309}
}
func (m *UserGroupSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserGroupSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserGroupSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserGroupSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserGroupSpecV1.Merge(m, src)
}
func (m *UserGroupSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *UserGroupSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_UserGroupSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_UserGroupSpecV1 proto.InternalMessageInfo

// OktaImportRuleSpecV1 is a Okta import rule specification.
type OktaImportRuleSpecV1 struct {
	// Priority represents the priority of the rule application. Lower numbered rules will be applied first.
	Priority int32 `protobuf:"varint,1,opt,name=Priority,proto3" json:"priority"`
	// Mappings is a list of matches that will map match conditions to labels.
	Mappings             []*OktaImportRuleMappingV1 `protobuf:"bytes,2,rep,name=Mappings,proto3" json:"mappings"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *OktaImportRuleSpecV1) Reset()         { *m = OktaImportRuleSpecV1{} }
func (m *OktaImportRuleSpecV1) String() string { return proto.CompactTextString(m) }
func (*OktaImportRuleSpecV1) ProtoMessage()    {}
func (*OktaImportRuleSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{310}
}
func (m *OktaImportRuleSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaImportRuleSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaImportRuleSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaImportRuleSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaImportRuleSpecV1.Merge(m, src)
}
func (m *OktaImportRuleSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *OktaImportRuleSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaImportRuleSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_OktaImportRuleSpecV1 proto.InternalMessageInfo

// OktaImportRuleMappingV1 is a list of matches that map match rules to labels.
type OktaImportRuleMappingV1 struct {
	// Match is a set of matching rules for this mapping. If any of these match, then the mapping will be applied.
	Match []*OktaImportRuleMatchV1 `protobuf:"bytes,1,rep,name=Match,proto3" json:"match"`
	// AddLabels specifies which labels to add if any of the previous matches match.
	AddLabels            map[string]string `protobuf:"bytes,2,rep,name=AddLabels,proto3" json:"add_labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OktaImportRuleMappingV1) Reset()         { *m = OktaImportRuleMappingV1{} }
func (m *OktaImportRuleMappingV1) String() string { return proto.CompactTextString(m) }
func (*OktaImportRuleMappingV1) ProtoMessage()    {}
func (*OktaImportRuleMappingV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{311}
}
func (m *OktaImportRuleMappingV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaImportRuleMappingV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaImportRuleMappingV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaImportRuleMappingV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaImportRuleMappingV1.Merge(m, src)
}
func (m *OktaImportRuleMappingV1) XXX_Size() int {
	return m.Size()
}
func (m *OktaImportRuleMappingV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaImportRuleMappingV1.DiscardUnknown(m)
}

var xxx_messageInfo_OktaImportRuleMappingV1 proto.InternalMessageInfo

// OktaImportRuleV1 is a representation of labeling rules for importing of Okta objects.
type OktaImportRuleV1 struct {
	// Header is the resource header for the SAML IdP service provider.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the specification for the Okta import rule.
	Spec                 OktaImportRuleSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *OktaImportRuleV1) Reset()      { *m = OktaImportRuleV1{} }
func (*OktaImportRuleV1) ProtoMessage() {}
func (*OktaImportRuleV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{312}
}
func (m *OktaImportRuleV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaImportRuleV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaImportRuleV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaImportRuleV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaImportRuleV1.Merge(m, src)
}
func (m *OktaImportRuleV1) XXX_Size() int {
	return m.Size()
}
func (m *OktaImportRuleV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaImportRuleV1.DiscardUnknown(m)
}

var xxx_messageInfo_OktaImportRuleV1 proto.InternalMessageInfo

// OktaImportRuleMatchV1 is a match rule for a mapping.
type OktaImportRuleMatchV1 struct {
	// AppIDs is a list of app IDs to match against.
	AppIDs []string `protobuf:"bytes,1,rep,name=AppIDs,proto3" json:"app_ids,omitempty"`
	// GroupIDs is a list of group IDs to match against.
	GroupIDs []string `protobuf:"bytes,2,rep,name=GroupIDs,proto3" json:"group_ids,omitempty"`
	// AppNameRegexes is a list of regexes to match against app names.
	AppNameRegexes []string `protobuf:"bytes,3,rep,name=AppNameRegexes,proto3" json:"app_name_regexes,omitempty"`
	// GroupNameRegexes is a list of regexes to match against group names.
	GroupNameRegexes     []string `protobuf:"bytes,4,rep,name=GroupNameRegexes,proto3" json:"group_name_regexes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OktaImportRuleMatchV1) Reset()         { *m = OktaImportRuleMatchV1{} }
func (m *OktaImportRuleMatchV1) String() string { return proto.CompactTextString(m) }
func (*OktaImportRuleMatchV1) ProtoMessage()    {}
func (*OktaImportRuleMatchV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{313}
}
func (m *OktaImportRuleMatchV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaImportRuleMatchV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaImportRuleMatchV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaImportRuleMatchV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaImportRuleMatchV1.Merge(m, src)
}
func (m *OktaImportRuleMatchV1) XXX_Size() int {
	return m.Size()
}
func (m *OktaImportRuleMatchV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaImportRuleMatchV1.DiscardUnknown(m)
}

var xxx_messageInfo_OktaImportRuleMatchV1 proto.InternalMessageInfo

// OktaAssignmentV1 is a representation of an action or set of actions taken by Teleport to assign Okta users to applications or groups.
type OktaAssignmentV1 struct {
	// Header is the resource header for the Okta assignment.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is the specification for the Okta assignment.
	Spec                 OktaAssignmentSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *OktaAssignmentV1) Reset()      { *m = OktaAssignmentV1{} }
func (*OktaAssignmentV1) ProtoMessage() {}
func (*OktaAssignmentV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{314}
}
func (m *OktaAssignmentV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaAssignmentV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaAssignmentV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaAssignmentV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaAssignmentV1.Merge(m, src)
}
func (m *OktaAssignmentV1) XXX_Size() int {
	return m.Size()
}
func (m *OktaAssignmentV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaAssignmentV1.DiscardUnknown(m)
}

var xxx_messageInfo_OktaAssignmentV1 proto.InternalMessageInfo

// OktaAssignmentSpecV1 is a Okta assignment specification.
type OktaAssignmentSpecV1 struct {
	// User is the user that these actions will be applied to.
	User string `protobuf:"bytes,1,opt,name=User,proto3" json:"user"`
	// Targets is a list of Okta targets to take on a user.
	Targets []*OktaAssignmentTargetV1 `protobuf:"bytes,2,rep,name=Targets,proto3" json:"targets"`
	// CleanupTime is an optional field that notes when the assignment should be cleaned up.
	// If absent, the assignment will never be cleaned up.
	CleanupTime time.Time `protobuf:"bytes,3,opt,name=CleanupTime,proto3,stdtime" json:"cleanup_time"`
	// Status is the status of the assignment.
	Status OktaAssignmentSpecV1_OktaAssignmentStatus `protobuf:"varint,4,opt,name=status,proto3,enum=types.OktaAssignmentSpecV1_OktaAssignmentStatus" json:"status"`
	// LastTransition is an optional field that notes when the last state transition
	// occurred for this action. If absent, this object has never transitioned.
	LastTransition time.Time `protobuf:"bytes,5,opt,name=LastTransition,proto3,stdtime" json:"last_transition"`
	// Finalized is set when the assignment has been properly cleaned up.
	Finalized            bool     `protobuf:"varint,6,opt,name=Finalized,proto3" json:"finalized"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OktaAssignmentSpecV1) Reset()         { *m = OktaAssignmentSpecV1{} }
func (m *OktaAssignmentSpecV1) String() string { return proto.CompactTextString(m) }
func (*OktaAssignmentSpecV1) ProtoMessage()    {}
func (*OktaAssignmentSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{315}
}
func (m *OktaAssignmentSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaAssignmentSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaAssignmentSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaAssignmentSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaAssignmentSpecV1.Merge(m, src)
}
func (m *OktaAssignmentSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *OktaAssignmentSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaAssignmentSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_OktaAssignmentSpecV1 proto.InternalMessageInfo

// OktaAssignmentTargetV1 is a target of an Okta assignment.
type OktaAssignmentTargetV1 struct {
	// Type is the type of Okta resource this assignment is targeting.
	Type OktaAssignmentTargetV1_OktaAssignmentTargetType `protobuf:"varint,1,opt,name=type,proto3,enum=types.OktaAssignmentTargetV1_OktaAssignmentTargetType" json:"type"`
	// ID is the ID of the Okta resource that's being targeted.
	Id                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OktaAssignmentTargetV1) Reset()         { *m = OktaAssignmentTargetV1{} }
func (m *OktaAssignmentTargetV1) String() string { return proto.CompactTextString(m) }
func (*OktaAssignmentTargetV1) ProtoMessage()    {}
func (*OktaAssignmentTargetV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{316}
}
func (m *OktaAssignmentTargetV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaAssignmentTargetV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaAssignmentTargetV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaAssignmentTargetV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaAssignmentTargetV1.Merge(m, src)
}
func (m *OktaAssignmentTargetV1) XXX_Size() int {
	return m.Size()
}
func (m *OktaAssignmentTargetV1) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaAssignmentTargetV1.DiscardUnknown(m)
}

var xxx_messageInfo_OktaAssignmentTargetV1 proto.InternalMessageInfo

// IntegrationV1 represents a connection between Teleport and some other 3rd party system.
// This connection allows API access to that service from Teleport.
// Each Integration instance must have a SubKind defined which identifies the external system.
type IntegrationV1 struct {
	// Header is the resource header.
	ResourceHeader `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	// Spec is an Integration specification.
	Spec                 IntegrationSpecV1 `protobuf:"bytes,2,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *IntegrationV1) Reset()      { *m = IntegrationV1{} }
func (*IntegrationV1) ProtoMessage() {}
func (*IntegrationV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{317}
}
func (m *IntegrationV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegrationV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntegrationV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntegrationV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegrationV1.Merge(m, src)
}
func (m *IntegrationV1) XXX_Size() int {
	return m.Size()
}
func (m *IntegrationV1) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegrationV1.DiscardUnknown(m)
}

var xxx_messageInfo_IntegrationV1 proto.InternalMessageInfo

// IntegrationSpecV1 contains properties of all the supported integrations.
type IntegrationSpecV1 struct {
	// Types that are valid to be assigned to SubKindSpec:
	//
	//	*IntegrationSpecV1_AWSOIDC
	//	*IntegrationSpecV1_AzureOIDC
	SubKindSpec          isIntegrationSpecV1_SubKindSpec `protobuf_oneof:"SubKindSpec"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *IntegrationSpecV1) Reset()         { *m = IntegrationSpecV1{} }
func (m *IntegrationSpecV1) String() string { return proto.CompactTextString(m) }
func (*IntegrationSpecV1) ProtoMessage()    {}
func (*IntegrationSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{318}
}
func (m *IntegrationSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IntegrationSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IntegrationSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IntegrationSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegrationSpecV1.Merge(m, src)
}
func (m *IntegrationSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *IntegrationSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegrationSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_IntegrationSpecV1 proto.InternalMessageInfo

type isIntegrationSpecV1_SubKindSpec interface {
	isIntegrationSpecV1_SubKindSpec()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IntegrationSpecV1_AWSOIDC struct {
	AWSOIDC *AWSOIDCIntegrationSpecV1 `protobuf:"bytes,1,opt,name=AWSOIDC,proto3,oneof" json:"aws_oidc,omitempty"`
}
type IntegrationSpecV1_AzureOIDC struct {
	AzureOIDC *AzureOIDCIntegrationSpecV1 `protobuf:"bytes,2,opt,name=AzureOIDC,proto3,oneof" json:"azure_oidc,omitempty"`
}

func (*IntegrationSpecV1_AWSOIDC) isIntegrationSpecV1_SubKindSpec()   {}
func (*IntegrationSpecV1_AzureOIDC) isIntegrationSpecV1_SubKindSpec() {}

func (m *IntegrationSpecV1) GetSubKindSpec() isIntegrationSpecV1_SubKindSpec {
	if m != nil {
		return m.SubKindSpec
	}
	return nil
}

func (m *IntegrationSpecV1) GetAWSOIDC() *AWSOIDCIntegrationSpecV1 {
	if x, ok := m.GetSubKindSpec().(*IntegrationSpecV1_AWSOIDC); ok {
		return x.AWSOIDC
	}
	return nil
}

func (m *IntegrationSpecV1) GetAzureOIDC() *AzureOIDCIntegrationSpecV1 {
	if x, ok := m.GetSubKindSpec().(*IntegrationSpecV1_AzureOIDC); ok {
		return x.AzureOIDC
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IntegrationSpecV1) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IntegrationSpecV1_AWSOIDC)(nil),
		(*IntegrationSpecV1_AzureOIDC)(nil),
	}
}

// AWSOIDCIntegrationSpecV1 contains the spec properties for the AWS OIDC SubKind Integration.
type AWSOIDCIntegrationSpecV1 struct {
	// RoleARN contains the Role ARN used to set up the Integration.
	// This is the AWS Role that Teleport will use to issue tokens for API Calls.
	RoleARN string `protobuf:"bytes,1,opt,name=RoleARN,proto3" json:"role_arn,omitempty"`
	// IssuerS3URI is the Identity Provider that was configured in AWS.
	// This bucket/prefix/* files must be publicly accessible and contain the following:
	// > .well-known/openid-configuration
	// > .well-known/jwks
	// Format: s3://<bucket>/<prefix>
	// Optional. The proxy's endpoint is used if it is not specified.
	//
	// DEPRECATED: Thumbprint validation requires the issuer to update the IdP in AWS everytime the issuer changes the certificate.
	// Amazon had some whitelisted providers where the thumbprint was ignored. S3 hosted providers was in that list.
	// Amazon is now trusting all the root certificate authorities, and this workaround is no longer needed.
	// DELETE IN 18.0.
	IssuerS3URI          string   `protobuf:"bytes,2,opt,name=IssuerS3URI,proto3" json:"issuer_s3_uri,omitempty"` // Deprecated: Do not use.
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AWSOIDCIntegrationSpecV1) Reset()         { *m = AWSOIDCIntegrationSpecV1{} }
func (m *AWSOIDCIntegrationSpecV1) String() string { return proto.CompactTextString(m) }
func (*AWSOIDCIntegrationSpecV1) ProtoMessage()    {}
func (*AWSOIDCIntegrationSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{319}
}
func (m *AWSOIDCIntegrationSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSOIDCIntegrationSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSOIDCIntegrationSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSOIDCIntegrationSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSOIDCIntegrationSpecV1.Merge(m, src)
}
func (m *AWSOIDCIntegrationSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *AWSOIDCIntegrationSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSOIDCIntegrationSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_AWSOIDCIntegrationSpecV1 proto.InternalMessageInfo

// AzureOIDCIntegrationSpecV1 contains the spec properties for the Azure OIDC SubKind Integration.
type AzureOIDCIntegrationSpecV1 struct {
	// TenantID specifies the ID of Entra Tenant (Directory)
	// that this plugin integrates with.
	TenantID string `protobuf:"bytes,1,opt,name=TenantID,proto3" json:"tenant_id,omitempty"`
	// ClientID specifies the ID of Azure enterprise application (client)
	// that corresponds to this plugin.
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"client_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureOIDCIntegrationSpecV1) Reset()         { *m = AzureOIDCIntegrationSpecV1{} }
func (m *AzureOIDCIntegrationSpecV1) String() string { return proto.CompactTextString(m) }
func (*AzureOIDCIntegrationSpecV1) ProtoMessage()    {}
func (*AzureOIDCIntegrationSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{320}
}
func (m *AzureOIDCIntegrationSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureOIDCIntegrationSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureOIDCIntegrationSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureOIDCIntegrationSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureOIDCIntegrationSpecV1.Merge(m, src)
}
func (m *AzureOIDCIntegrationSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *AzureOIDCIntegrationSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureOIDCIntegrationSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_AzureOIDCIntegrationSpecV1 proto.InternalMessageInfo

// HeadlessAuthentication holds data for an ongoing headless authentication attempt.
type HeadlessAuthentication struct {
	// Header is the resource header.
	ResourceHeader `protobuf:"bytes,1,opt,name=header,proto3,embedded=header" json:"header"`
	// User is a teleport user name.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// PublicKey is an ssh public key to sign in case of successful auth.
	//
	// Deprecated: prefer SshPublicKey and/or TlsPublicKey.
	PublicKey []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"` // Deprecated: Do not use.
	// State is the headless authentication request state.
	State HeadlessAuthenticationState `protobuf:"varint,4,opt,name=state,proto3,enum=types.HeadlessAuthenticationState" json:"state,omitempty"`
	// MFADevice is the mfa device used to approve the request in case of successful auth.
	MfaDevice *MFADevice `protobuf:"bytes,5,opt,name=mfa_device,json=mfaDevice,proto3" json:"mfa_device,omitempty"`
	// ClientIPAddress is the IP address of the client being authenticated.
	ClientIpAddress string `protobuf:"bytes,6,opt,name=client_ip_address,json=clientIpAddress,proto3" json:"client_ip_address,omitempty"`
	// SshPublicKey is a public key that will be used as the subject of the issued
	// SSH certificate in case of successful auth. It must be in SSH authorized_keys format.
	SshPublicKey []byte `protobuf:"bytes,7,opt,name=ssh_public_key,json=sshPublicKey,proto3" json:"ssh_public_key,omitempty"`
	// TlsPublicKey is a public key that will be used as the subject of the issued
	// TLS certificate in case of successful auth. It must be in PEM-encoded
	// PKCS#1 or PKIX format.
	TlsPublicKey         []byte   `protobuf:"bytes,8,opt,name=tls_public_key,json=tlsPublicKey,proto3" json:"tls_public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeadlessAuthentication) Reset()         { *m = HeadlessAuthentication{} }
func (m *HeadlessAuthentication) String() string { return proto.CompactTextString(m) }
func (*HeadlessAuthentication) ProtoMessage()    {}
func (*HeadlessAuthentication) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{321}
}
func (m *HeadlessAuthentication) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeadlessAuthentication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeadlessAuthentication.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeadlessAuthentication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeadlessAuthentication.Merge(m, src)
}
func (m *HeadlessAuthentication) XXX_Size() int {
	return m.Size()
}
func (m *HeadlessAuthentication) XXX_DiscardUnknown() {
	xxx_messageInfo_HeadlessAuthentication.DiscardUnknown(m)
}

var xxx_messageInfo_HeadlessAuthentication proto.InternalMessageInfo

// WatchKind specifies resource kind to watch
// When adding fields to this struct, make sure to review/update WatchKind.Contains method.
type WatchKind struct {
	// Kind is a resource kind to watch
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// LoadSecrets specifies whether to load secrets
	LoadSecrets bool `protobuf:"varint,2,opt,name=LoadSecrets,proto3" json:"load_secrets"`
	// Name is an optional specific resource type to watch,
	// if specified only the events with a specific resource
	// name will be sent
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"name"`
	// Filter is an optional mapping of custom filter parameters.
	// Valid values vary by resource kind.
	Filter map[string]string `protobuf:"bytes,4,rep,name=Filter,proto3" json:"filter,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// SubKind is a resource subkind to watch
	SubKind string `protobuf:"bytes,5,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version optionally specifies the resource version to watch.
	// Currently this field is ignored.
	Version              string   `protobuf:"bytes,6,opt,name=Version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WatchKind) Reset()         { *m = WatchKind{} }
func (m *WatchKind) String() string { return proto.CompactTextString(m) }
func (*WatchKind) ProtoMessage()    {}
func (*WatchKind) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{322}
}
func (m *WatchKind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchKind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchKind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchKind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchKind.Merge(m, src)
}
func (m *WatchKind) XXX_Size() int {
	return m.Size()
}
func (m *WatchKind) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchKind.DiscardUnknown(m)
}

var xxx_messageInfo_WatchKind proto.InternalMessageInfo

// WatchStatusV1 is intended to be attached to OpInit events and contain information about a successful WatchEvents call.
type WatchStatusV1 struct {
	// Kind is the resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind. Currently unused for this resource.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the resource spec.
	Spec                 WatchStatusSpecV1 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WatchStatusV1) Reset()         { *m = WatchStatusV1{} }
func (m *WatchStatusV1) String() string { return proto.CompactTextString(m) }
func (*WatchStatusV1) ProtoMessage()    {}
func (*WatchStatusV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{323}
}
func (m *WatchStatusV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchStatusV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchStatusV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchStatusV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchStatusV1.Merge(m, src)
}
func (m *WatchStatusV1) XXX_Size() int {
	return m.Size()
}
func (m *WatchStatusV1) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchStatusV1.DiscardUnknown(m)
}

var xxx_messageInfo_WatchStatusV1 proto.InternalMessageInfo

// WatchStatusSpecV1 contains resource kinds confirmed by WatchEvents to be included in the event stream.
type WatchStatusSpecV1 struct {
	Kinds                []WatchKind `protobuf:"bytes,1,rep,name=Kinds,proto3" json:"kinds"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *WatchStatusSpecV1) Reset()         { *m = WatchStatusSpecV1{} }
func (m *WatchStatusSpecV1) String() string { return proto.CompactTextString(m) }
func (*WatchStatusSpecV1) ProtoMessage()    {}
func (*WatchStatusSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{324}
}
func (m *WatchStatusSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatchStatusSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatchStatusSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatchStatusSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatchStatusSpecV1.Merge(m, src)
}
func (m *WatchStatusSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *WatchStatusSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_WatchStatusSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_WatchStatusSpecV1 proto.InternalMessageInfo

// ServerInfoV1 contains info that should be applied to joining Nodes.
type ServerInfoV1 struct {
	// Kind is the resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the resource spec.
	Spec                 ServerInfoSpecV1 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ServerInfoV1) Reset()         { *m = ServerInfoV1{} }
func (m *ServerInfoV1) String() string { return proto.CompactTextString(m) }
func (*ServerInfoV1) ProtoMessage()    {}
func (*ServerInfoV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{325}
}
func (m *ServerInfoV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoV1.Merge(m, src)
}
func (m *ServerInfoV1) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoV1.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoV1 proto.InternalMessageInfo

// ServerInfoSpecV1 contains fields used to match Nodes to this ServerInfo.
type ServerInfoSpecV1 struct {
	// NewLabels is the set of labels to add to nodes matching this ServerInfo.
	NewLabels            map[string]string `protobuf:"bytes,2,rep,name=NewLabels,proto3" json:"new_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServerInfoSpecV1) Reset()         { *m = ServerInfoSpecV1{} }
func (m *ServerInfoSpecV1) String() string { return proto.CompactTextString(m) }
func (*ServerInfoSpecV1) ProtoMessage()    {}
func (*ServerInfoSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{326}
}
func (m *ServerInfoSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerInfoSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerInfoSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerInfoSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerInfoSpecV1.Merge(m, src)
}
func (m *ServerInfoSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *ServerInfoSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerInfoSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_ServerInfoSpecV1 proto.InternalMessageInfo

// JamfSpecV1 is the base configuration for the Jamf MDM service.
type JamfSpecV1 struct {
	// Enabled toggles the service on or off.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Name of the service device source.
	// See the teleport.devicetrust.v1.DeviceSource proto.
	// Defaults to "jamf".
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Initial sync delay for the service.
	// Set to negative to perform syncs immediately on startup.
	// Defaults to a random delay (a few minutes max).
	SyncDelay Duration `protobuf:"varint,3,opt,name=sync_delay,json=syncDelay,proto3,casttype=Duration" json:"sync_delay,omitempty"`
	// Jamf Pro API endpoint.
	// Example: "https://yourtenant.jamfcloud.com/api".
	// Required.
	ApiEndpoint string `protobuf:"bytes,4,opt,name=api_endpoint,json=apiEndpoint,proto3" json:"api_endpoint,omitempty"`
	// Inventory sync entries.
	// If empty a default sync configuration is used.
	Inventory            []*JamfInventoryEntry `protobuf:"bytes,7,rep,name=inventory,proto3" json:"inventory,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *JamfSpecV1) Reset()         { *m = JamfSpecV1{} }
func (m *JamfSpecV1) String() string { return proto.CompactTextString(m) }
func (*JamfSpecV1) ProtoMessage()    {}
func (*JamfSpecV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{327}
}
func (m *JamfSpecV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JamfSpecV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JamfSpecV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JamfSpecV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JamfSpecV1.Merge(m, src)
}
func (m *JamfSpecV1) XXX_Size() int {
	return m.Size()
}
func (m *JamfSpecV1) XXX_DiscardUnknown() {
	xxx_messageInfo_JamfSpecV1.DiscardUnknown(m)
}

var xxx_messageInfo_JamfSpecV1 proto.InternalMessageInfo

// JamfInventoryEntry is an inventory sync entry for [JamfSpecV1].
type JamfInventoryEntry struct {
	// Jamf Pro API RSQL filter, used when querying endpoints like
	// "/api/v1/computers-inventory".
	// See https://developer.jamf.com/jamf-pro/reference/get_v1-computers-inventory.
	FilterRsql string `protobuf:"bytes,1,opt,name=filter_rsql,json=filterRsql,proto3" json:"filter_rsql,omitempty"`
	// Sync period for PARTIAL syncs.
	// PARTIAL syncs are scheduled in the time window between FULL syncs, so
	// sync_period_partial must always be smaller than sync_period_full, otherwise
	// it would never trigger.
	// Set to zero or negative to disable PARTIAL syncs.
	SyncPeriodPartial Duration `protobuf:"varint,2,opt,name=sync_period_partial,json=syncPeriodPartial,proto3,casttype=Duration" json:"sync_period_partial,omitempty"`
	// Sync period for FULL syncs.
	// Ideally sync_period_full is a multiple of sync_period_partial, so schedules
	// line up perfectly.
	// Set to zero or negative to disable FULL syncs.
	SyncPeriodFull Duration `protobuf:"varint,3,opt,name=sync_period_full,json=syncPeriodFull,proto3,casttype=Duration" json:"sync_period_full,omitempty"`
	// on_missing is the trigger used on devices missing from the MDM view in a
	// FULL sync.
	// Only runs on successful FULL syncs.
	// Corresponds to [teleport.devicetrust.v1.SyncInventoryDeviceAction].
	// Must be either "NOOP" or "DELETE".
	// Defaults to "NOOP".
	OnMissing string `protobuf:"bytes,4,opt,name=on_missing,json=onMissing,proto3" json:"on_missing,omitempty"`
	// Custom page size for inventory queries.
	// A server default is used if zeroed or negative.
	PageSize             int32    `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JamfInventoryEntry) Reset()         { *m = JamfInventoryEntry{} }
func (m *JamfInventoryEntry) String() string { return proto.CompactTextString(m) }
func (*JamfInventoryEntry) ProtoMessage()    {}
func (*JamfInventoryEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{328}
}
func (m *JamfInventoryEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JamfInventoryEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JamfInventoryEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JamfInventoryEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JamfInventoryEntry.Merge(m, src)
}
func (m *JamfInventoryEntry) XXX_Size() int {
	return m.Size()
}
func (m *JamfInventoryEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_JamfInventoryEntry.DiscardUnknown(m)
}

var xxx_messageInfo_JamfInventoryEntry proto.InternalMessageInfo

// MessageWithHeader is a message with a resource header. This is used primarily
// for parsing of resource headers and isn't expected to be used directly by any
// resources.
//
// When using a oneof in a protobuf messages, the existing utils.FastMarshal
// utility does not work, so using something like protojson or jsonpb is required.
// However, these do not respect gogoproto's extensions. When using a ResourceHeader,
// protojson will not recognize that the ResourceHeader is intended to be embedded and
// the resulting JSON will have the header as a separate field. This means that using
// utils.FastUnmarshal will not work for extracting a ResourceHeader from the
// JSON, and we explicitly extract this header to do things like version checking in
// lib/services.
//
// This can be avoided by explicitly embedding the members of the ResourceHeader in
// a message. However, if we would like to avoid this, we can use this MessageWitHheader
// to extract the resource header and its elements, which can later be used for the
// aforementioned processing in lib/services.
type MessageWithHeader struct {
	// Header is the resource header for a resource.
	ResourceHeader       `protobuf:"bytes,1,opt,name=Header,proto3,embedded=Header" json:""`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageWithHeader) Reset()      { *m = MessageWithHeader{} }
func (*MessageWithHeader) ProtoMessage() {}
func (*MessageWithHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{329}
}
func (m *MessageWithHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageWithHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageWithHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageWithHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageWithHeader.Merge(m, src)
}
func (m *MessageWithHeader) XXX_Size() int {
	return m.Size()
}
func (m *MessageWithHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageWithHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MessageWithHeader proto.InternalMessageInfo

// AWSMatcher matches AWS EC2 instances and AWS Databases
type AWSMatcher struct {
	// Types are AWS database types to match, "ec2", "rds", "redshift", "elasticache",
	// or "memorydb".
	Types []string `protobuf:"bytes,1,rep,name=Types,proto3" json:"types,omitempty"`
	// Regions are AWS regions to query for databases.
	Regions []string `protobuf:"bytes,2,rep,name=Regions,proto3" json:"regions,omitempty"`
	// AssumeRoleARN is the AWS role to assume for database discovery.
	AssumeRole *AssumeRole `protobuf:"bytes,3,opt,name=AssumeRole,proto3" json:"assume_role,omitempty"`
	// Tags are AWS resource Tags to match.
	Tags Labels `protobuf:"bytes,4,opt,name=Tags,proto3,customtype=Labels" json:"tags,omitempty"`
	// Params sets the join method when installing on discovered EC2 nodes
	Params *InstallerParams `protobuf:"bytes,5,opt,name=Params,proto3" json:"install,omitempty"`
	// SSM provides options to use when sending a document command to
	// an EC2 node
	SSM *AWSSSM `protobuf:"bytes,6,opt,name=SSM,proto3" json:"ssm,omitempty"`
	// Integration is the integration name used to generate credentials to interact with AWS APIs.
	// Environment credentials will not be used when this value is set.
	Integration string `protobuf:"bytes,7,opt,name=Integration,proto3" json:"integration,omitempty"`
	// KubeAppDiscovery controls whether Kubernetes App Discovery will be enabled for agents running on
	// discovered clusters, currently only affects AWS EKS discovery in integration mode.
	KubeAppDiscovery bool `protobuf:"varint,8,opt,name=KubeAppDiscovery,proto3" json:"kube_app_discovery,omitempty"`
	// SetupAccessForARN is the role that the discovery service should create EKS Access Entries for.
	// This value should match the IAM identity that Teleport Kubernetes Service uses.
	// If this value is empty, the discovery service will attempt to set up access for its own identity (self).
	SetupAccessForARN    string   `protobuf:"bytes,9,opt,name=SetupAccessForARN,proto3" json:"setup_access_for_arn,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AWSMatcher) Reset()         { *m = AWSMatcher{} }
func (m *AWSMatcher) String() string { return proto.CompactTextString(m) }
func (*AWSMatcher) ProtoMessage()    {}
func (*AWSMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{330}
}
func (m *AWSMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSMatcher.Merge(m, src)
}
func (m *AWSMatcher) XXX_Size() int {
	return m.Size()
}
func (m *AWSMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_AWSMatcher proto.InternalMessageInfo

// AssumeRole provides a role ARN and ExternalID to assume an AWS role
// when interacting with AWS resources.
type AssumeRole struct {
	// RoleARN is the fully specified AWS IAM role ARN.
	RoleARN string `protobuf:"bytes,1,opt,name=RoleARN,proto3" json:"role_arn"`
	// ExternalID is the external ID used to assume a role in another account.
	ExternalID           string   `protobuf:"bytes,2,opt,name=ExternalID,proto3" json:"external_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AssumeRole) Reset()         { *m = AssumeRole{} }
func (m *AssumeRole) String() string { return proto.CompactTextString(m) }
func (*AssumeRole) ProtoMessage()    {}
func (*AssumeRole) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{331}
}
func (m *AssumeRole) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssumeRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssumeRole.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssumeRole) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssumeRole.Merge(m, src)
}
func (m *AssumeRole) XXX_Size() int {
	return m.Size()
}
func (m *AssumeRole) XXX_DiscardUnknown() {
	xxx_messageInfo_AssumeRole.DiscardUnknown(m)
}

var xxx_messageInfo_AssumeRole proto.InternalMessageInfo

// InstallParams sets join method to use on discovered nodes
type InstallerParams struct {
	// JoinMethod is the method to use when joining the cluster
	JoinMethod JoinMethod `protobuf:"bytes,1,opt,name=JoinMethod,proto3,casttype=JoinMethod" json:"join_method"`
	// JoinToken is the token to use when joining the cluster
	JoinToken string `protobuf:"bytes,2,opt,name=JoinToken,proto3" json:"join_token"`
	// ScriptName is the name of the teleport installer script
	// resource for the cloud instance to execute
	ScriptName string `protobuf:"bytes,3,opt,name=ScriptName,proto3" json:"script_name,omitempty"`
	// InstallTeleport disables agentless discovery
	InstallTeleport bool `protobuf:"varint,4,opt,name=InstallTeleport,proto3" json:"install_teleport,omitempty"`
	// SSHDConfig provides the path to write sshd configuration changes
	SSHDConfig string `protobuf:"bytes,5,opt,name=SSHDConfig,proto3" json:"sshd_config,omitempty"`
	// PublicProxyAddr is the address of the proxy the discovered node should use
	// to connect to the cluster.
	PublicProxyAddr string `protobuf:"bytes,6,opt,name=PublicProxyAddr,proto3" json:"proxy_addr,omitempty"`
	// Azure is the set of Azure-specific installation parameters.
	Azure *AzureInstallerParams `protobuf:"bytes,7,opt,name=Azure,proto3" json:"azure,omitempty"`
	// EnrollMode indicates the enrollment mode to be used when adding a node.
	// Valid values:
	// 0: uses eice for EC2 matchers which use an integration and script for all the other methods
	// 1: uses script mode
	// 2: uses eice mode
	EnrollMode           InstallParamEnrollMode `protobuf:"varint,8,opt,name=EnrollMode,proto3,enum=types.InstallParamEnrollMode" json:"enroll_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *InstallerParams) Reset()         { *m = InstallerParams{} }
func (m *InstallerParams) String() string { return proto.CompactTextString(m) }
func (*InstallerParams) ProtoMessage()    {}
func (*InstallerParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{332}
}
func (m *InstallerParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallerParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallerParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallerParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallerParams.Merge(m, src)
}
func (m *InstallerParams) XXX_Size() int {
	return m.Size()
}
func (m *InstallerParams) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallerParams.DiscardUnknown(m)
}

var xxx_messageInfo_InstallerParams proto.InternalMessageInfo

// AWSSSM provides options to use when executing SSM documents
type AWSSSM struct {
	// DocumentName is the name of the document to use when executing an
	// SSM command
	DocumentName         string   `protobuf:"bytes,1,opt,name=DocumentName,proto3" json:"document_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AWSSSM) Reset()         { *m = AWSSSM{} }
func (m *AWSSSM) String() string { return proto.CompactTextString(m) }
func (*AWSSSM) ProtoMessage()    {}
func (*AWSSSM) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{333}
}
func (m *AWSSSM) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSSM) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSSSM.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSSSM) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSSM.Merge(m, src)
}
func (m *AWSSSM) XXX_Size() int {
	return m.Size()
}
func (m *AWSSSM) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSSM.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSSM proto.InternalMessageInfo

// AzureInstallerParams is the set of Azure-specific installation parameters.
type AzureInstallerParams struct {
	// ClientID is the client ID of the managed identity discovered nodes
	// should use to join the cluster.
	ClientID             string   `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"client_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureInstallerParams) Reset()         { *m = AzureInstallerParams{} }
func (m *AzureInstallerParams) String() string { return proto.CompactTextString(m) }
func (*AzureInstallerParams) ProtoMessage()    {}
func (*AzureInstallerParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{334}
}
func (m *AzureInstallerParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureInstallerParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureInstallerParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureInstallerParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureInstallerParams.Merge(m, src)
}
func (m *AzureInstallerParams) XXX_Size() int {
	return m.Size()
}
func (m *AzureInstallerParams) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureInstallerParams.DiscardUnknown(m)
}

var xxx_messageInfo_AzureInstallerParams proto.InternalMessageInfo

// AzureMatcher matches Azure resources.
// It defines which resource types, filters and some configuration params.
type AzureMatcher struct {
	// Subscriptions are Azure subscriptions to query for resources.
	Subscriptions []string `protobuf:"bytes,1,rep,name=Subscriptions,proto3" json:"subscriptions,omitempty"`
	// ResourceGroups are Azure resource groups to query for resources.
	ResourceGroups []string `protobuf:"bytes,2,rep,name=ResourceGroups,proto3" json:"resource_groups,omitempty"`
	// Types are Azure types to match: "mysql", "postgres", "aks", "vm"
	Types []string `protobuf:"bytes,3,rep,name=Types,proto3" json:"types,omitempty"`
	// Regions are Azure locations to match for databases.
	Regions []string `protobuf:"bytes,4,rep,name=Regions,proto3" json:"regions,omitempty"`
	// ResourceTags are Azure tags on resources to match.
	ResourceTags Labels `protobuf:"bytes,5,opt,name=ResourceTags,proto3,customtype=Labels" json:"tags,omitempty"`
	// Params sets the join method when installing on
	// discovered Azure nodes.
	Params               *InstallerParams `protobuf:"bytes,6,opt,name=Params,proto3" json:"install_params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AzureMatcher) Reset()         { *m = AzureMatcher{} }
func (m *AzureMatcher) String() string { return proto.CompactTextString(m) }
func (*AzureMatcher) ProtoMessage()    {}
func (*AzureMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{335}
}
func (m *AzureMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureMatcher.Merge(m, src)
}
func (m *AzureMatcher) XXX_Size() int {
	return m.Size()
}
func (m *AzureMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_AzureMatcher proto.InternalMessageInfo

// GCPMatcher matches GCP resources.
type GCPMatcher struct {
	// Types are GKE resource types to match: "gke", "vm".
	Types []string `protobuf:"bytes,1,rep,name=Types,proto3" json:"types,omitempty"`
	// Locations are GKE locations to search resources for.
	Locations []string `protobuf:"bytes,2,rep,name=Locations,proto3" json:"locations,omitempty"`
	// Tags is obsolete and only exists for backwards compatibility. Use Labels instead.
	Tags Labels `protobuf:"bytes,3,opt,name=Tags,proto3,customtype=Labels" json:"tags,omitempty"`
	// ProjectIDs are the GCP project ID where the resources are deployed.
	ProjectIDs []string `protobuf:"bytes,4,rep,name=ProjectIDs,proto3" json:"project_ids,omitempty"`
	// ServiceAccounts are the emails of service accounts attached to VMs.
	ServiceAccounts []string `protobuf:"bytes,5,rep,name=ServiceAccounts,proto3" json:"service_accounts,omitempty"`
	// Params sets the join method when installing on
	// discovered GCP nodes.
	Params *InstallerParams `protobuf:"bytes,6,opt,name=Params,proto3" json:"install_params,omitempty"`
	// Labels are GCP labels to match.
	Labels               Labels   `protobuf:"bytes,7,opt,name=Labels,proto3,customtype=Labels" json:"labels,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GCPMatcher) Reset()         { *m = GCPMatcher{} }
func (m *GCPMatcher) String() string { return proto.CompactTextString(m) }
func (*GCPMatcher) ProtoMessage()    {}
func (*GCPMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{336}
}
func (m *GCPMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCPMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCPMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPMatcher.Merge(m, src)
}
func (m *GCPMatcher) XXX_Size() int {
	return m.Size()
}
func (m *GCPMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_GCPMatcher proto.InternalMessageInfo

// KubernetesMatcher matches Kubernetes services.
type KubernetesMatcher struct {
	// Types are Kubernetes services types to match. Currently only 'app' is supported.
	Types []string `protobuf:"bytes,1,rep,name=Types,proto3" json:"types,omitempty"`
	// Namespaces are Kubernetes namespaces in which to discover services
	Namespaces []string `protobuf:"bytes,2,rep,name=Namespaces,proto3" json:"namespaces,omitempty"`
	// Labels are Kubernetes services labels to match.
	Labels               Labels   `protobuf:"bytes,3,opt,name=Labels,proto3,customtype=Labels" json:"labels,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesMatcher) Reset()         { *m = KubernetesMatcher{} }
func (m *KubernetesMatcher) String() string { return proto.CompactTextString(m) }
func (*KubernetesMatcher) ProtoMessage()    {}
func (*KubernetesMatcher) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{337}
}
func (m *KubernetesMatcher) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesMatcher) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesMatcher.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesMatcher) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesMatcher.Merge(m, src)
}
func (m *KubernetesMatcher) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesMatcher) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesMatcher.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesMatcher proto.InternalMessageInfo

// OktaOptions specify options related to the Okta service.
type OktaOptions struct {
	// SyncPeriod is the duration between synchronization calls in nanoseconds.
	SyncPeriod           Duration `protobuf:"varint,1,opt,name=SyncPeriod,proto3,casttype=Duration" json:"sync_period,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OktaOptions) Reset()         { *m = OktaOptions{} }
func (m *OktaOptions) String() string { return proto.CompactTextString(m) }
func (*OktaOptions) ProtoMessage()    {}
func (*OktaOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{338}
}
func (m *OktaOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OktaOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OktaOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OktaOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OktaOptions.Merge(m, src)
}
func (m *OktaOptions) XXX_Size() int {
	return m.Size()
}
func (m *OktaOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_OktaOptions.DiscardUnknown(m)
}

var xxx_messageInfo_OktaOptions proto.InternalMessageInfo

// AccessGraphSync is a configuration for Access Graph service.
type AccessGraphSync struct {
	// AWS is a configuration for AWS Access Graph service poll service.
	AWS                  []*AccessGraphAWSSync `protobuf:"bytes,1,rep,name=AWS,proto3" json:"aws,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *AccessGraphSync) Reset()         { *m = AccessGraphSync{} }
func (m *AccessGraphSync) String() string { return proto.CompactTextString(m) }
func (*AccessGraphSync) ProtoMessage()    {}
func (*AccessGraphSync) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{339}
}
func (m *AccessGraphSync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessGraphSync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessGraphSync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessGraphSync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessGraphSync.Merge(m, src)
}
func (m *AccessGraphSync) XXX_Size() int {
	return m.Size()
}
func (m *AccessGraphSync) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessGraphSync.DiscardUnknown(m)
}

var xxx_messageInfo_AccessGraphSync proto.InternalMessageInfo

// AccessGraphAWSSync is a configuration for AWS Access Graph service poll service.
type AccessGraphAWSSync struct {
	// Regions are AWS regions to import resources from.
	Regions []string `protobuf:"bytes,1,rep,name=Regions,proto3" json:"regions,omitempty"`
	// AssumeRoleARN is the AWS role to assume for database discovery.
	AssumeRole *AssumeRole `protobuf:"bytes,3,opt,name=AssumeRole,proto3" json:"assume_role,omitempty"`
	// Integration is the integration name used to generate credentials to interact with AWS APIs.
	Integration          string   `protobuf:"bytes,4,opt,name=Integration,proto3" json:"integration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessGraphAWSSync) Reset()         { *m = AccessGraphAWSSync{} }
func (m *AccessGraphAWSSync) String() string { return proto.CompactTextString(m) }
func (*AccessGraphAWSSync) ProtoMessage()    {}
func (*AccessGraphAWSSync) Descriptor() ([]byte, []int) {
	return fileDescriptor_9198ee693835762e, []int{340}
}
func (m *AccessGraphAWSSync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessGraphAWSSync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessGraphAWSSync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessGraphAWSSync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessGraphAWSSync.Merge(m, src)
}
func (m *AccessGraphAWSSync) XXX_Size() int {
	return m.Size()
}
func (m *AccessGraphAWSSync) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessGraphAWSSync.DiscardUnknown(m)
}

var xxx_messageInfo_AccessGraphAWSSync proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("types.IAMPolicyStatus", IAMPolicyStatus_name, IAMPolicyStatus_value)
	proto.RegisterEnum("types.DatabaseTLSMode", DatabaseTLSMode_name, DatabaseTLSMode_value)
	proto.RegisterEnum("types.PrivateKeyType", PrivateKeyType_name, PrivateKeyType_value)
	proto.RegisterEnum("types.ProxyListenerMode", ProxyListenerMode_name, ProxyListenerMode_value)
	proto.RegisterEnum("types.RoutingStrategy", RoutingStrategy_name, RoutingStrategy_value)
	proto.RegisterEnum("types.UserTokenUsage", UserTokenUsage_name, UserTokenUsage_value)
	proto.RegisterEnum("types.RequestState", RequestState_name, RequestState_value)
	proto.RegisterEnum("types.AccessRequestScope", AccessRequestScope_name, AccessRequestScope_value)
	proto.RegisterEnum("types.CreateHostUserMode", CreateHostUserMode_name, CreateHostUserMode_value)
	proto.RegisterEnum("types.CreateDatabaseUserMode", CreateDatabaseUserMode_name, CreateDatabaseUserMode_value)
	proto.RegisterEnum("types.CertExtensionMode", CertExtensionMode_name, CertExtensionMode_value)
	proto.RegisterEnum("types.CertExtensionType", CertExtensionType_name, CertExtensionType_value)
	proto.RegisterEnum("types.PasswordState", PasswordState_name, PasswordState_value)
	proto.RegisterEnum("types.TrustedDeviceRequirement", TrustedDeviceRequirement_name, TrustedDeviceRequirement_value)
	proto.RegisterEnum("types.SessionState", SessionState_name, SessionState_value)
	proto.RegisterEnum("types.AlertSeverity", AlertSeverity_name, AlertSeverity_value)
	proto.RegisterEnum("types.RequireMFAType", RequireMFAType_name, RequireMFAType_value)
	proto.RegisterEnum("types.SignatureAlgorithmSuite", SignatureAlgorithmSuite_name, SignatureAlgorithmSuite_value)
	proto.RegisterEnum("types.PluginStatusCode", PluginStatusCode_name, PluginStatusCode_value)
	proto.RegisterEnum("types.OktaPluginSyncStatusCode", OktaPluginSyncStatusCode_name, OktaPluginSyncStatusCode_value)
	proto.RegisterEnum("types.HeadlessAuthenticationState", HeadlessAuthenticationState_name, HeadlessAuthenticationState_value)
	proto.RegisterEnum("types.InstallParamEnrollMode", InstallParamEnrollMode_name, InstallParamEnrollMode_value)
	proto.RegisterEnum("types.KeepAlive_KeepAliveType", KeepAlive_KeepAliveType_name, KeepAlive_KeepAliveType_value)
	proto.RegisterEnum("types.CertAuthoritySpecV2_SigningAlgType", CertAuthoritySpecV2_SigningAlgType_name, CertAuthoritySpecV2_SigningAlgType_value)
	proto.RegisterEnum("types.ClusterAuditConfigSpecV2_FIPSEndpointState", ClusterAuditConfigSpecV2_FIPSEndpointState_name, ClusterAuditConfigSpecV2_FIPSEndpointState_value)
	proto.RegisterEnum("types.ConnectionDiagnosticTrace_TraceType", ConnectionDiagnosticTrace_TraceType_name, ConnectionDiagnosticTrace_TraceType_value)
	proto.RegisterEnum("types.ConnectionDiagnosticTrace_StatusType", ConnectionDiagnosticTrace_StatusType_name, ConnectionDiagnosticTrace_StatusType_value)
	proto.RegisterEnum("types.OktaAssignmentSpecV1_OktaAssignmentStatus", OktaAssignmentSpecV1_OktaAssignmentStatus_name, OktaAssignmentSpecV1_OktaAssignmentStatus_value)
	proto.RegisterEnum("types.OktaAssignmentTargetV1_OktaAssignmentTargetType", OktaAssignmentTargetV1_OktaAssignmentTargetType_name, OktaAssignmentTargetV1_OktaAssignmentTargetType_value)
	proto.RegisterType((*KeepAlive)(nil), "types.KeepAlive")
	proto.RegisterType((*Metadata)(nil), "types.Metadata")
	proto.RegisterMapType((map[string]string)(nil), "types.Metadata.LabelsEntry")
	proto.RegisterType((*Rotation)(nil), "types.Rotation")
	proto.RegisterType((*RotationSchedule)(nil), "types.RotationSchedule")
	proto.RegisterType((*ResourceHeader)(nil), "types.ResourceHeader")
	proto.RegisterType((*DatabaseServerV3)(nil), "types.DatabaseServerV3")
	proto.RegisterType((*DatabaseServerSpecV3)(nil), "types.DatabaseServerSpecV3")
	proto.RegisterType((*DatabaseV3List)(nil), "types.DatabaseV3List")
	proto.RegisterType((*DatabaseV3)(nil), "types.DatabaseV3")
	proto.RegisterType((*DatabaseSpecV3)(nil), "types.DatabaseSpecV3")
	proto.RegisterMapType((map[string]CommandLabelV2)(nil), "types.DatabaseSpecV3.DynamicLabelsEntry")
	proto.RegisterType((*DatabaseAdminUser)(nil), "types.DatabaseAdminUser")
	proto.RegisterType((*OracleOptions)(nil), "types.OracleOptions")
	proto.RegisterType((*DatabaseStatusV3)(nil), "types.DatabaseStatusV3")
	proto.RegisterType((*AWS)(nil), "types.AWS")
	proto.RegisterMapType((map[string]string)(nil), "types.AWS.SessionTagsEntry")
	proto.RegisterType((*SecretStore)(nil), "types.SecretStore")
	proto.RegisterType((*Redshift)(nil), "types.Redshift")
	proto.RegisterType((*RDS)(nil), "types.RDS")
	proto.RegisterType((*RDSProxy)(nil), "types.RDSProxy")
	proto.RegisterType((*ElastiCache)(nil), "types.ElastiCache")
	proto.RegisterType((*MemoryDB)(nil), "types.MemoryDB")
	proto.RegisterType((*RedshiftServerless)(nil), "types.RedshiftServerless")
	proto.RegisterType((*OpenSearch)(nil), "types.OpenSearch")
	proto.RegisterType((*DocumentDB)(nil), "types.DocumentDB")
	proto.RegisterType((*GCPCloudSQL)(nil), "types.GCPCloudSQL")
	proto.RegisterType((*Azure)(nil), "types.Azure")
	proto.RegisterType((*AzureRedis)(nil), "types.AzureRedis")
	proto.RegisterType((*AD)(nil), "types.AD")
	proto.RegisterType((*DatabaseTLS)(nil), "types.DatabaseTLS")
	proto.RegisterType((*MySQLOptions)(nil), "types.MySQLOptions")
	proto.RegisterType((*MongoAtlas)(nil), "types.MongoAtlas")
	proto.RegisterType((*InstanceV1)(nil), "types.InstanceV1")
	proto.RegisterType((*InstanceSpecV1)(nil), "types.InstanceSpecV1")
	proto.RegisterType((*InstanceControlLogEntry)(nil), "types.InstanceControlLogEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.InstanceControlLogEntry.LabelsEntry")
	proto.RegisterType((*InstanceFilter)(nil), "types.InstanceFilter")
	proto.RegisterType((*ServerV2)(nil), "types.ServerV2")
	proto.RegisterType((*ServerSpecV2)(nil), "types.ServerSpecV2")
	proto.RegisterMapType((map[string]CommandLabelV2)(nil), "types.ServerSpecV2.CmdLabelsEntry")
	proto.RegisterType((*AWSInfo)(nil), "types.AWSInfo")
	proto.RegisterType((*CloudMetadata)(nil), "types.CloudMetadata")
	proto.RegisterType((*AppServerV3)(nil), "types.AppServerV3")
	proto.RegisterType((*AppServerSpecV3)(nil), "types.AppServerSpecV3")
	proto.RegisterType((*AppV3List)(nil), "types.AppV3List")
	proto.RegisterType((*AppV3)(nil), "types.AppV3")
	proto.RegisterType((*AppSpecV3)(nil), "types.AppSpecV3")
	proto.RegisterMapType((map[string]CommandLabelV2)(nil), "types.AppSpecV3.DynamicLabelsEntry")
	proto.RegisterType((*AppServerOrSAMLIdPServiceProviderV1)(nil), "types.AppServerOrSAMLIdPServiceProviderV1")
	proto.RegisterType((*Rewrite)(nil), "types.Rewrite")
	proto.RegisterType((*Header)(nil), "types.Header")
	proto.RegisterType((*CommandLabelV2)(nil), "types.CommandLabelV2")
	proto.RegisterType((*AppAWS)(nil), "types.AppAWS")
	proto.RegisterType((*SSHKeyPair)(nil), "types.SSHKeyPair")
	proto.RegisterType((*TLSKeyPair)(nil), "types.TLSKeyPair")
	proto.RegisterType((*JWTKeyPair)(nil), "types.JWTKeyPair")
	proto.RegisterType((*CertAuthorityV2)(nil), "types.CertAuthorityV2")
	proto.RegisterType((*CertAuthoritySpecV2)(nil), "types.CertAuthoritySpecV2")
	proto.RegisterType((*CAKeySet)(nil), "types.CAKeySet")
	proto.RegisterType((*RoleMapping)(nil), "types.RoleMapping")
	proto.RegisterType((*ProvisionTokenV1)(nil), "types.ProvisionTokenV1")
	proto.RegisterType((*ProvisionTokenV2)(nil), "types.ProvisionTokenV2")
	proto.RegisterType((*ProvisionTokenV2List)(nil), "types.ProvisionTokenV2List")
	proto.RegisterType((*TokenRule)(nil), "types.TokenRule")
	proto.RegisterType((*ProvisionTokenSpecV2)(nil), "types.ProvisionTokenSpecV2")
	proto.RegisterType((*ProvisionTokenSpecV2TPM)(nil), "types.ProvisionTokenSpecV2TPM")
	proto.RegisterType((*ProvisionTokenSpecV2TPM_Rule)(nil), "types.ProvisionTokenSpecV2TPM.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2GitHub)(nil), "types.ProvisionTokenSpecV2GitHub")
	proto.RegisterType((*ProvisionTokenSpecV2GitHub_Rule)(nil), "types.ProvisionTokenSpecV2GitHub.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2GitLab)(nil), "types.ProvisionTokenSpecV2GitLab")
	proto.RegisterType((*ProvisionTokenSpecV2GitLab_Rule)(nil), "types.ProvisionTokenSpecV2GitLab.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2CircleCI)(nil), "types.ProvisionTokenSpecV2CircleCI")
	proto.RegisterType((*ProvisionTokenSpecV2CircleCI_Rule)(nil), "types.ProvisionTokenSpecV2CircleCI.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2Spacelift)(nil), "types.ProvisionTokenSpecV2Spacelift")
	proto.RegisterType((*ProvisionTokenSpecV2Spacelift_Rule)(nil), "types.ProvisionTokenSpecV2Spacelift.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2Kubernetes)(nil), "types.ProvisionTokenSpecV2Kubernetes")
	proto.RegisterType((*ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig)(nil), "types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig")
	proto.RegisterType((*ProvisionTokenSpecV2Kubernetes_Rule)(nil), "types.ProvisionTokenSpecV2Kubernetes.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2Azure)(nil), "types.ProvisionTokenSpecV2Azure")
	proto.RegisterType((*ProvisionTokenSpecV2Azure_Rule)(nil), "types.ProvisionTokenSpecV2Azure.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2GCP)(nil), "types.ProvisionTokenSpecV2GCP")
	proto.RegisterType((*ProvisionTokenSpecV2GCP_Rule)(nil), "types.ProvisionTokenSpecV2GCP.Rule")
	proto.RegisterType((*ProvisionTokenSpecV2TerraformCloud)(nil), "types.ProvisionTokenSpecV2TerraformCloud")
	proto.RegisterType((*ProvisionTokenSpecV2TerraformCloud_Rule)(nil), "types.ProvisionTokenSpecV2TerraformCloud.Rule")
	proto.RegisterType((*StaticTokensV2)(nil), "types.StaticTokensV2")
	proto.RegisterType((*StaticTokensSpecV2)(nil), "types.StaticTokensSpecV2")
	proto.RegisterType((*ClusterNameV2)(nil), "types.ClusterNameV2")
	proto.RegisterType((*ClusterNameSpecV2)(nil), "types.ClusterNameSpecV2")
	proto.RegisterType((*ClusterAuditConfigV2)(nil), "types.ClusterAuditConfigV2")
	proto.RegisterType((*ClusterAuditConfigSpecV2)(nil), "types.ClusterAuditConfigSpecV2")
	proto.RegisterType((*ClusterNetworkingConfigV2)(nil), "types.ClusterNetworkingConfigV2")
	proto.RegisterType((*ClusterNetworkingConfigSpecV2)(nil), "types.ClusterNetworkingConfigSpecV2")
	proto.RegisterType((*TunnelStrategyV1)(nil), "types.TunnelStrategyV1")
	proto.RegisterType((*AgentMeshTunnelStrategy)(nil), "types.AgentMeshTunnelStrategy")
	proto.RegisterType((*ProxyPeeringTunnelStrategy)(nil), "types.ProxyPeeringTunnelStrategy")
	proto.RegisterType((*SessionRecordingConfigV2)(nil), "types.SessionRecordingConfigV2")
	proto.RegisterType((*SessionRecordingConfigSpecV2)(nil), "types.SessionRecordingConfigSpecV2")
	proto.RegisterType((*AuthPreferenceV2)(nil), "types.AuthPreferenceV2")
	proto.RegisterType((*AuthPreferenceSpecV2)(nil), "types.AuthPreferenceSpecV2")
	proto.RegisterType((*U2F)(nil), "types.U2F")
	proto.RegisterType((*Webauthn)(nil), "types.Webauthn")
	proto.RegisterType((*DeviceTrust)(nil), "types.DeviceTrust")
	proto.RegisterType((*HardwareKey)(nil), "types.HardwareKey")
	proto.RegisterType((*HardwareKeySerialNumberValidation)(nil), "types.HardwareKeySerialNumberValidation")
	proto.RegisterType((*Namespace)(nil), "types.Namespace")
	proto.RegisterType((*NamespaceSpec)(nil), "types.NamespaceSpec")
	proto.RegisterType((*UserTokenV3)(nil), "types.UserTokenV3")
	proto.RegisterType((*UserTokenSpecV3)(nil), "types.UserTokenSpecV3")
	proto.RegisterType((*UserTokenSecretsV3)(nil), "types.UserTokenSecretsV3")
	proto.RegisterType((*UserTokenSecretsSpecV3)(nil), "types.UserTokenSecretsSpecV3")
	proto.RegisterType((*AccessRequestV3)(nil), "types.AccessRequestV3")
	proto.RegisterType((*AccessReviewThreshold)(nil), "types.AccessReviewThreshold")
	proto.RegisterType((*PromotedAccessList)(nil), "types.PromotedAccessList")
	proto.RegisterType((*AccessReview)(nil), "types.AccessReview")
	proto.RegisterType((*AccessReviewSubmission)(nil), "types.AccessReviewSubmission")
	proto.RegisterType((*ThresholdIndexSet)(nil), "types.ThresholdIndexSet")
	proto.RegisterType((*ThresholdIndexSets)(nil), "types.ThresholdIndexSets")
	proto.RegisterType((*AccessRequestSpecV3)(nil), "types.AccessRequestSpecV3")
	proto.RegisterMapType((map[string]ThresholdIndexSets)(nil), "types.AccessRequestSpecV3.RoleThresholdMappingEntry")
	proto.RegisterType((*AccessRequestFilter)(nil), "types.AccessRequestFilter")
	proto.RegisterType((*AccessCapabilities)(nil), "types.AccessCapabilities")
	proto.RegisterType((*AccessCapabilitiesRequest)(nil), "types.AccessCapabilitiesRequest")
	proto.RegisterType((*ResourceID)(nil), "types.ResourceID")
	proto.RegisterType((*PluginDataV3)(nil), "types.PluginDataV3")
	proto.RegisterType((*PluginDataEntry)(nil), "types.PluginDataEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.PluginDataEntry.DataEntry")
	proto.RegisterType((*PluginDataSpecV3)(nil), "types.PluginDataSpecV3")
	proto.RegisterMapType((map[string]*PluginDataEntry)(nil), "types.PluginDataSpecV3.EntriesEntry")
	proto.RegisterType((*PluginDataFilter)(nil), "types.PluginDataFilter")
	proto.RegisterType((*PluginDataUpdateParams)(nil), "types.PluginDataUpdateParams")
	proto.RegisterMapType((map[string]string)(nil), "types.PluginDataUpdateParams.ExpectEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.PluginDataUpdateParams.SetEntry")
	proto.RegisterType((*RoleFilter)(nil), "types.RoleFilter")
	proto.RegisterType((*RoleV6)(nil), "types.RoleV6")
	proto.RegisterType((*RoleSpecV6)(nil), "types.RoleSpecV6")
	proto.RegisterType((*RoleOptions)(nil), "types.RoleOptions")
	proto.RegisterType((*RecordSession)(nil), "types.RecordSession")
	proto.RegisterType((*CertExtension)(nil), "types.CertExtension")
	proto.RegisterType((*RoleConditions)(nil), "types.RoleConditions")
	proto.RegisterType((*SPIFFERoleCondition)(nil), "types.SPIFFERoleCondition")
	proto.RegisterType((*DatabasePermission)(nil), "types.DatabasePermission")
	proto.RegisterType((*KubernetesResource)(nil), "types.KubernetesResource")
	proto.RegisterType((*SessionRequirePolicy)(nil), "types.SessionRequirePolicy")
	proto.RegisterType((*SessionJoinPolicy)(nil), "types.SessionJoinPolicy")
	proto.RegisterType((*AccessRequestConditions)(nil), "types.AccessRequestConditions")
	proto.RegisterType((*AccessReviewConditions)(nil), "types.AccessReviewConditions")
	proto.RegisterType((*AccessRequestAllowedPromotion)(nil), "types.AccessRequestAllowedPromotion")
	proto.RegisterType((*AccessRequestAllowedPromotions)(nil), "types.AccessRequestAllowedPromotions")
	proto.RegisterType((*ClaimMapping)(nil), "types.ClaimMapping")
	proto.RegisterType((*TraitMapping)(nil), "types.TraitMapping")
	proto.RegisterType((*Rule)(nil), "types.Rule")
	proto.RegisterType((*ImpersonateConditions)(nil), "types.ImpersonateConditions")
	proto.RegisterType((*BoolValue)(nil), "types.BoolValue")
	proto.RegisterType((*UserFilter)(nil), "types.UserFilter")
	proto.RegisterType((*UserV2)(nil), "types.UserV2")
	proto.RegisterType((*UserStatusV2)(nil), "types.UserStatusV2")
	proto.RegisterType((*UserSpecV2)(nil), "types.UserSpecV2")
	proto.RegisterType((*ExternalIdentity)(nil), "types.ExternalIdentity")
	proto.RegisterType((*LoginStatus)(nil), "types.LoginStatus")
	proto.RegisterType((*CreatedBy)(nil), "types.CreatedBy")
	proto.RegisterType((*LocalAuthSecrets)(nil), "types.LocalAuthSecrets")
	proto.RegisterType((*MFADevice)(nil), "types.MFADevice")
	proto.RegisterType((*TOTPDevice)(nil), "types.TOTPDevice")
	proto.RegisterType((*U2FDevice)(nil), "types.U2FDevice")
	proto.RegisterType((*WebauthnDevice)(nil), "types.WebauthnDevice")
	proto.RegisterType((*WebauthnLocalAuth)(nil), "types.WebauthnLocalAuth")
	proto.RegisterType((*ConnectorRef)(nil), "types.ConnectorRef")
	proto.RegisterType((*UserRef)(nil), "types.UserRef")
	proto.RegisterType((*ReverseTunnelV2)(nil), "types.ReverseTunnelV2")
	proto.RegisterType((*ReverseTunnelSpecV2)(nil), "types.ReverseTunnelSpecV2")
	proto.RegisterType((*TunnelConnectionV2)(nil), "types.TunnelConnectionV2")
	proto.RegisterType((*TunnelConnectionSpecV2)(nil), "types.TunnelConnectionSpecV2")
	proto.RegisterType((*SemaphoreFilter)(nil), "types.SemaphoreFilter")
	proto.RegisterType((*AcquireSemaphoreRequest)(nil), "types.AcquireSemaphoreRequest")
	proto.RegisterType((*SemaphoreLease)(nil), "types.SemaphoreLease")
	proto.RegisterType((*SemaphoreLeaseRef)(nil), "types.SemaphoreLeaseRef")
	proto.RegisterType((*SemaphoreV3)(nil), "types.SemaphoreV3")
	proto.RegisterType((*SemaphoreSpecV3)(nil), "types.SemaphoreSpecV3")
	proto.RegisterType((*WebSessionV2)(nil), "types.WebSessionV2")
	proto.RegisterType((*WebSessionSpecV2)(nil), "types.WebSessionSpecV2")
	proto.RegisterType((*DeviceWebToken)(nil), "types.DeviceWebToken")
	proto.RegisterType((*WebSessionFilter)(nil), "types.WebSessionFilter")
	proto.RegisterType((*SAMLSessionData)(nil), "types.SAMLSessionData")
	proto.RegisterType((*SAMLAttribute)(nil), "types.SAMLAttribute")
	proto.RegisterType((*SAMLAttributeValue)(nil), "types.SAMLAttributeValue")
	proto.RegisterType((*SAMLNameID)(nil), "types.SAMLNameID")
	proto.RegisterType((*RemoteClusterV3)(nil), "types.RemoteClusterV3")
	proto.RegisterType((*RemoteClusterStatusV3)(nil), "types.RemoteClusterStatusV3")
	proto.RegisterType((*KubernetesCluster)(nil), "types.KubernetesCluster")
	proto.RegisterMapType((map[string]CommandLabelV2)(nil), "types.KubernetesCluster.DynamicLabelsEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.KubernetesCluster.StaticLabelsEntry")
	proto.RegisterType((*KubernetesClusterV3)(nil), "types.KubernetesClusterV3")
	proto.RegisterType((*KubernetesClusterSpecV3)(nil), "types.KubernetesClusterSpecV3")
	proto.RegisterMapType((map[string]CommandLabelV2)(nil), "types.KubernetesClusterSpecV3.DynamicLabelsEntry")
	proto.RegisterType((*KubeAzure)(nil), "types.KubeAzure")
	proto.RegisterType((*KubeAWS)(nil), "types.KubeAWS")
	proto.RegisterType((*KubeGCP)(nil), "types.KubeGCP")
	proto.RegisterType((*KubernetesClusterV3List)(nil), "types.KubernetesClusterV3List")
	proto.RegisterType((*KubernetesServerV3)(nil), "types.KubernetesServerV3")
	proto.RegisterType((*KubernetesServerSpecV3)(nil), "types.KubernetesServerSpecV3")
	proto.RegisterType((*WebTokenV3)(nil), "types.WebTokenV3")
	proto.RegisterType((*WebTokenSpecV3)(nil), "types.WebTokenSpecV3")
	proto.RegisterType((*GetWebSessionRequest)(nil), "types.GetWebSessionRequest")
	proto.RegisterType((*DeleteWebSessionRequest)(nil), "types.DeleteWebSessionRequest")
	proto.RegisterType((*GetWebTokenRequest)(nil), "types.GetWebTokenRequest")
	proto.RegisterType((*DeleteWebTokenRequest)(nil), "types.DeleteWebTokenRequest")
	proto.RegisterType((*ResourceRequest)(nil), "types.ResourceRequest")
	proto.RegisterType((*ResourceWithSecretsRequest)(nil), "types.ResourceWithSecretsRequest")
	proto.RegisterType((*ResourcesWithSecretsRequest)(nil), "types.ResourcesWithSecretsRequest")
	proto.RegisterType((*ResourceInNamespaceRequest)(nil), "types.ResourceInNamespaceRequest")
	proto.RegisterType((*ResourcesInNamespaceRequest)(nil), "types.ResourcesInNamespaceRequest")
	proto.RegisterType((*OIDCConnectorV3)(nil), "types.OIDCConnectorV3")
	proto.RegisterType((*OIDCConnectorV3List)(nil), "types.OIDCConnectorV3List")
	proto.RegisterType((*OIDCConnectorSpecV3)(nil), "types.OIDCConnectorSpecV3")
	proto.RegisterType((*MaxAge)(nil), "types.MaxAge")
	proto.RegisterType((*SSOClientRedirectSettings)(nil), "types.SSOClientRedirectSettings")
	proto.RegisterType((*OIDCAuthRequest)(nil), "types.OIDCAuthRequest")
	proto.RegisterType((*SAMLConnectorV2)(nil), "types.SAMLConnectorV2")
	proto.RegisterType((*SAMLConnectorV2List)(nil), "types.SAMLConnectorV2List")
	proto.RegisterType((*SAMLConnectorSpecV2)(nil), "types.SAMLConnectorSpecV2")
	proto.RegisterType((*SAMLAuthRequest)(nil), "types.SAMLAuthRequest")
	proto.RegisterType((*AttributeMapping)(nil), "types.AttributeMapping")
	proto.RegisterType((*AsymmetricKeyPair)(nil), "types.AsymmetricKeyPair")
	proto.RegisterType((*GithubConnectorV3)(nil), "types.GithubConnectorV3")
	proto.RegisterType((*GithubConnectorV3List)(nil), "types.GithubConnectorV3List")
	proto.RegisterType((*GithubConnectorSpecV3)(nil), "types.GithubConnectorSpecV3")
	proto.RegisterType((*GithubAuthRequest)(nil), "types.GithubAuthRequest")
	proto.RegisterType((*SSOWarnings)(nil), "types.SSOWarnings")
	proto.RegisterType((*CreateUserParams)(nil), "types.CreateUserParams")
	proto.RegisterType((*SSODiagnosticInfo)(nil), "types.SSODiagnosticInfo")
	proto.RegisterType((*GithubTokenInfo)(nil), "types.GithubTokenInfo")
	proto.RegisterType((*GithubClaims)(nil), "types.GithubClaims")
	proto.RegisterType((*TeamMapping)(nil), "types.TeamMapping")
	proto.RegisterType((*TeamRolesMapping)(nil), "types.TeamRolesMapping")
	proto.RegisterType((*TrustedClusterV2)(nil), "types.TrustedClusterV2")
	proto.RegisterType((*TrustedClusterV2List)(nil), "types.TrustedClusterV2List")
	proto.RegisterType((*TrustedClusterSpecV2)(nil), "types.TrustedClusterSpecV2")
	proto.RegisterType((*LockV2)(nil), "types.LockV2")
	proto.RegisterType((*LockSpecV2)(nil), "types.LockSpecV2")
	proto.RegisterType((*LockTarget)(nil), "types.LockTarget")
	proto.RegisterType((*AddressCondition)(nil), "types.AddressCondition")
	proto.RegisterType((*NetworkRestrictionsSpecV4)(nil), "types.NetworkRestrictionsSpecV4")
	proto.RegisterType((*NetworkRestrictionsV4)(nil), "types.NetworkRestrictionsV4")
	proto.RegisterType((*WindowsDesktopServiceV3)(nil), "types.WindowsDesktopServiceV3")
	proto.RegisterType((*WindowsDesktopServiceSpecV3)(nil), "types.WindowsDesktopServiceSpecV3")
	proto.RegisterType((*WindowsDesktopFilter)(nil), "types.WindowsDesktopFilter")
	proto.RegisterType((*WindowsDesktopV3)(nil), "types.WindowsDesktopV3")
	proto.RegisterType((*WindowsDesktopSpecV3)(nil), "types.WindowsDesktopSpecV3")
	proto.RegisterType((*Resolution)(nil), "types.Resolution")
	proto.RegisterType((*RegisterUsingTokenRequest)(nil), "types.RegisterUsingTokenRequest")
	proto.RegisterType((*RecoveryCodesV1)(nil), "types.RecoveryCodesV1")
	proto.RegisterType((*RecoveryCodesSpecV1)(nil), "types.RecoveryCodesSpecV1")
	proto.RegisterType((*RecoveryCode)(nil), "types.RecoveryCode")
	proto.RegisterType((*NullableSessionState)(nil), "types.NullableSessionState")
	proto.RegisterType((*SessionTrackerFilter)(nil), "types.SessionTrackerFilter")
	proto.RegisterType((*SessionTrackerV1)(nil), "types.SessionTrackerV1")
	proto.RegisterType((*SessionTrackerSpecV1)(nil), "types.SessionTrackerSpecV1")
	proto.RegisterType((*SessionTrackerPolicySet)(nil), "types.SessionTrackerPolicySet")
	proto.RegisterType((*Participant)(nil), "types.Participant")
	proto.RegisterType((*UIConfigV1)(nil), "types.UIConfigV1")
	proto.RegisterType((*UIConfigSpecV1)(nil), "types.UIConfigSpecV1")
	proto.RegisterType((*InstallerV1)(nil), "types.InstallerV1")
	proto.RegisterType((*InstallerSpecV1)(nil), "types.InstallerSpecV1")
	proto.RegisterType((*InstallerV1List)(nil), "types.InstallerV1List")
	proto.RegisterType((*SortBy)(nil), "types.SortBy")
	proto.RegisterType((*ConnectionDiagnosticV1)(nil), "types.ConnectionDiagnosticV1")
	proto.RegisterType((*ConnectionDiagnosticSpecV1)(nil), "types.ConnectionDiagnosticSpecV1")
	proto.RegisterType((*ConnectionDiagnosticTrace)(nil), "types.ConnectionDiagnosticTrace")
	proto.RegisterType((*DatabaseServiceV1)(nil), "types.DatabaseServiceV1")
	proto.RegisterType((*DatabaseServiceSpecV1)(nil), "types.DatabaseServiceSpecV1")
	proto.RegisterType((*DatabaseResourceMatcher)(nil), "types.DatabaseResourceMatcher")
	proto.RegisterType((*ResourceMatcherAWS)(nil), "types.ResourceMatcherAWS")
	proto.RegisterType((*ClusterAlert)(nil), "types.ClusterAlert")
	proto.RegisterType((*ClusterAlertSpec)(nil), "types.ClusterAlertSpec")
	proto.RegisterType((*GetClusterAlertsRequest)(nil), "types.GetClusterAlertsRequest")
	proto.RegisterMapType((map[string]string)(nil), "types.GetClusterAlertsRequest.LabelsEntry")
	proto.RegisterType((*AlertAcknowledgement)(nil), "types.AlertAcknowledgement")
	proto.RegisterType((*Release)(nil), "types.Release")
	proto.RegisterType((*Asset)(nil), "types.Asset")
	proto.RegisterType((*PluginV1)(nil), "types.PluginV1")
	proto.RegisterType((*PluginSpecV1)(nil), "types.PluginSpecV1")
	proto.RegisterType((*PluginSlackAccessSettings)(nil), "types.PluginSlackAccessSettings")
	proto.RegisterType((*PluginGitlabSettings)(nil), "types.PluginGitlabSettings")
	proto.RegisterType((*PluginOpsgenieAccessSettings)(nil), "types.PluginOpsgenieAccessSettings")
	proto.RegisterType((*PluginServiceNowSettings)(nil), "types.PluginServiceNowSettings")
	proto.RegisterType((*PluginPagerDutySettings)(nil), "types.PluginPagerDutySettings")
	proto.RegisterType((*PluginJiraSettings)(nil), "types.PluginJiraSettings")
	proto.RegisterType((*PluginOpenAISettings)(nil), "types.PluginOpenAISettings")
	proto.RegisterType((*PluginMattermostSettings)(nil), "types.PluginMattermostSettings")
	proto.RegisterType((*PluginJamfSettings)(nil), "types.PluginJamfSettings")
	proto.RegisterType((*PluginOktaSettings)(nil), "types.PluginOktaSettings")
	proto.RegisterType((*PluginOktaSyncSettings)(nil), "types.PluginOktaSyncSettings")
	proto.RegisterType((*DiscordChannels)(nil), "types.DiscordChannels")
	proto.RegisterType((*PluginDiscordSettings)(nil), "types.PluginDiscordSettings")
	proto.RegisterMapType((map[string]*DiscordChannels)(nil), "types.PluginDiscordSettings.RoleToRecipientsEntry")
	proto.RegisterType((*PluginEntraIDSettings)(nil), "types.PluginEntraIDSettings")
	proto.RegisterType((*PluginEntraIDSyncSettings)(nil), "types.PluginEntraIDSyncSettings")
	proto.RegisterType((*PluginEntraIDAccessGraphSettings)(nil), "types.PluginEntraIDAccessGraphSettings")
	proto.RegisterType((*PluginEntraIDAppSSOSettings)(nil), "types.PluginEntraIDAppSSOSettings")
	proto.RegisterType((*PluginSCIMSettings)(nil), "types.PluginSCIMSettings")
	proto.RegisterType((*PluginBootstrapCredentialsV1)(nil), "types.PluginBootstrapCredentialsV1")
	proto.RegisterType((*PluginIdSecretCredential)(nil), "types.PluginIdSecretCredential")
	proto.RegisterType((*PluginOAuth2AuthorizationCodeCredentials)(nil), "types.PluginOAuth2AuthorizationCodeCredentials")
	proto.RegisterType((*PluginStatusV1)(nil), "types.PluginStatusV1")
	proto.RegisterType((*PluginGitlabStatusV1)(nil), "types.PluginGitlabStatusV1")
	proto.RegisterType((*PluginEntraIDStatusV1)(nil), "types.PluginEntraIDStatusV1")
	proto.RegisterType((*PluginOktaStatusV1)(nil), "types.PluginOktaStatusV1")
	proto.RegisterType((*PluginOktaStatusDetailsSSO)(nil), "types.PluginOktaStatusDetailsSSO")
	proto.RegisterType((*PluginOktaStatusDetailsAppGroupSync)(nil), "types.PluginOktaStatusDetailsAppGroupSync")
	proto.RegisterType((*PluginOktaStatusDetailsUsersSync)(nil), "types.PluginOktaStatusDetailsUsersSync")
	proto.RegisterType((*PluginOktaStatusDetailsSCIM)(nil), "types.PluginOktaStatusDetailsSCIM")
	proto.RegisterType((*PluginOktaStatusDetailsAccessListsSync)(nil), "types.PluginOktaStatusDetailsAccessListsSync")
	proto.RegisterType((*PluginCredentialsV1)(nil), "types.PluginCredentialsV1")
	proto.RegisterType((*PluginOAuth2AccessTokenCredentials)(nil), "types.PluginOAuth2AccessTokenCredentials")
	proto.RegisterType((*PluginBearerTokenCredentials)(nil), "types.PluginBearerTokenCredentials")
	proto.RegisterType((*PluginStaticCredentialsRef)(nil), "types.PluginStaticCredentialsRef")
	proto.RegisterMapType((map[string]string)(nil), "types.PluginStaticCredentialsRef.LabelsEntry")
	proto.RegisterType((*PluginListV1)(nil), "types.PluginListV1")
	proto.RegisterType((*PluginStaticCredentialsV1)(nil), "types.PluginStaticCredentialsV1")
	proto.RegisterType((*PluginStaticCredentialsSpecV1)(nil), "types.PluginStaticCredentialsSpecV1")
	proto.RegisterType((*PluginStaticCredentialsBasicAuth)(nil), "types.PluginStaticCredentialsBasicAuth")
	proto.RegisterType((*PluginStaticCredentialsOAuthClientSecret)(nil), "types.PluginStaticCredentialsOAuthClientSecret")
	proto.RegisterType((*SAMLIdPServiceProviderV1)(nil), "types.SAMLIdPServiceProviderV1")
	proto.RegisterType((*SAMLIdPServiceProviderSpecV1)(nil), "types.SAMLIdPServiceProviderSpecV1")
	proto.RegisterType((*SAMLAttributeMapping)(nil), "types.SAMLAttributeMapping")
	proto.RegisterType((*IdPOptions)(nil), "types.IdPOptions")
	proto.RegisterType((*IdPSAMLOptions)(nil), "types.IdPSAMLOptions")
	proto.RegisterType((*KubernetesResourceV1)(nil), "types.KubernetesResourceV1")
	proto.RegisterType((*KubernetesResourceSpecV1)(nil), "types.KubernetesResourceSpecV1")
	proto.RegisterType((*ClusterMaintenanceConfigV1)(nil), "types.ClusterMaintenanceConfigV1")
	proto.RegisterType((*ClusterMaintenanceConfigSpecV1)(nil), "types.ClusterMaintenanceConfigSpecV1")
	proto.RegisterType((*AgentUpgradeWindow)(nil), "types.AgentUpgradeWindow")
	proto.RegisterType((*ScheduledAgentUpgradeWindow)(nil), "types.ScheduledAgentUpgradeWindow")
	proto.RegisterType((*AgentUpgradeSchedule)(nil), "types.AgentUpgradeSchedule")
	proto.RegisterType((*UserGroupV1)(nil), "types.UserGroupV1")
	proto.RegisterType((*UserGroupSpecV1)(nil), "types.UserGroupSpecV1")
	proto.RegisterType((*OktaImportRuleSpecV1)(nil), "types.OktaImportRuleSpecV1")
	proto.RegisterType((*OktaImportRuleMappingV1)(nil), "types.OktaImportRuleMappingV1")
	proto.RegisterMapType((map[string]string)(nil), "types.OktaImportRuleMappingV1.AddLabelsEntry")
	proto.RegisterType((*OktaImportRuleV1)(nil), "types.OktaImportRuleV1")
	proto.RegisterType((*OktaImportRuleMatchV1)(nil), "types.OktaImportRuleMatchV1")
	proto.RegisterType((*OktaAssignmentV1)(nil), "types.OktaAssignmentV1")
	proto.RegisterType((*OktaAssignmentSpecV1)(nil), "types.OktaAssignmentSpecV1")
	proto.RegisterType((*OktaAssignmentTargetV1)(nil), "types.OktaAssignmentTargetV1")
	proto.RegisterType((*IntegrationV1)(nil), "types.IntegrationV1")
	proto.RegisterType((*IntegrationSpecV1)(nil), "types.IntegrationSpecV1")
	proto.RegisterType((*AWSOIDCIntegrationSpecV1)(nil), "types.AWSOIDCIntegrationSpecV1")
	proto.RegisterType((*AzureOIDCIntegrationSpecV1)(nil), "types.AzureOIDCIntegrationSpecV1")
	proto.RegisterType((*HeadlessAuthentication)(nil), "types.HeadlessAuthentication")
	proto.RegisterType((*WatchKind)(nil), "types.WatchKind")
	proto.RegisterMapType((map[string]string)(nil), "types.WatchKind.FilterEntry")
	proto.RegisterType((*WatchStatusV1)(nil), "types.WatchStatusV1")
	proto.RegisterType((*WatchStatusSpecV1)(nil), "types.WatchStatusSpecV1")
	proto.RegisterType((*ServerInfoV1)(nil), "types.ServerInfoV1")
	proto.RegisterType((*ServerInfoSpecV1)(nil), "types.ServerInfoSpecV1")
	proto.RegisterMapType((map[string]string)(nil), "types.ServerInfoSpecV1.NewLabelsEntry")
	proto.RegisterType((*JamfSpecV1)(nil), "types.JamfSpecV1")
	proto.RegisterType((*JamfInventoryEntry)(nil), "types.JamfInventoryEntry")
	proto.RegisterType((*MessageWithHeader)(nil), "types.MessageWithHeader")
	proto.RegisterType((*AWSMatcher)(nil), "types.AWSMatcher")
	proto.RegisterType((*AssumeRole)(nil), "types.AssumeRole")
	proto.RegisterType((*InstallerParams)(nil), "types.InstallerParams")
	proto.RegisterType((*AWSSSM)(nil), "types.AWSSSM")
	proto.RegisterType((*AzureInstallerParams)(nil), "types.AzureInstallerParams")
	proto.RegisterType((*AzureMatcher)(nil), "types.AzureMatcher")
	proto.RegisterType((*GCPMatcher)(nil), "types.GCPMatcher")
	proto.RegisterType((*KubernetesMatcher)(nil), "types.KubernetesMatcher")
	proto.RegisterType((*OktaOptions)(nil), "types.OktaOptions")
	proto.RegisterType((*AccessGraphSync)(nil), "types.AccessGraphSync")
	proto.RegisterType((*AccessGraphAWSSync)(nil), "types.AccessGraphAWSSync")
}

func init() { proto.RegisterFile("teleport/legacy/types/types.proto", fileDescriptor_9198ee693835762e) }

var fileDescriptor_9198ee693835762e = []byte{
	// 27712 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xfd, 0x7b, 0x70, 0x5c, 0x59,
	0x7a, 0x18, 0x86, 0x4f, 0x3f, 0x00, 0x34, 0x3e, 0xbc, 0x1a, 0x07, 0x20, 0x09, 0x62, 0x86, 0x6c,
	0xce, 0xe5, 0x0c, 0x87, 0x9c, 0x07, 0xb9, 0x04, 0x77, 0xb8, 0x3b, 0x3b, 0xcf, 0x06, 0x1a, 0x24,
	0x9a, 0x04, 0x41, 0xec, 0x6d, 0x90, 0xdc, 0xd1, 0x3e, 0xee, 0x5e, 0x74, 0x1f, 0x00, 0x77, 0xd8,
	0xdd, 0xb7, 0xf7, 0xde, 0xdb, 0x24, 0xb1, 0xb2, 0x7f, 0x96, 0x64, 0xc9, 0xfa, 0x29, 0x8e, 0x5e,
	0xb6, 0x14, 0xc9, 0x29, 0x59, 0xa5, 0x92, 0x63, 0x47, 0x79, 0x58, 0x95, 0x92, 0xac, 0x8a, 0x53,
	0xaa, 0xc8, 0x52, 0x4a, 0x51, 0x54, 0x4a, 0xca, 0x51, 0x55, 0xde, 0x1b, 0x15, 0x14, 0x45, 0x2e,
	0x57, 0x0a, 0x95, 0xa4, 0xa4, 0xb8, 0xca, 0x95, 0xac, 0x4b, 0x4e, 0xea, 0x7c, 0xe7, 0x71, 0xcf,
	0xb9, 0x7d, 0xbb, 0xd1, 0x98, 0xe1, 0xd8, 0xe2, 0x94, 0xfe, 0x21, 0xd1, 0xdf, 0xf9, 0xbe, 0xef,
	0x9c, 0x7b, 0x9e, 0xdf, 0x77, 0xce, 0xf7, 0x80, 0x17, 0x23, 0xda, 0xa4, 0x1d, 0x3f, 0x88, 0xae,
	0x34, 0xe9, 0xae, 0x5b, 0xdf, 0xbf, 0x12, 0xed, 0x77, 0x68, 0xc8, 0xff, 0xbd, 0xdc, 0x09, 0xfc,
	0xc8, 0x27, 0x23, 0xf8, 0x63, 0x71, 0x7e, 0xd7, 0xdf, 0xf5, 0x11, 0x72, 0x85, 0xfd, 0xc5, 0x0b,
	0x17, 0xcf, 0xee, 0xfa, 0xfe, 0x6e, 0x93, 0x5e, 0xc1, 0x5f, 0xdb, 0xdd, 0x9d, 0x2b, 0x8d, 0x6e,
	0xe0, 0x46, 0x9e, 0xdf, 0x16, 0xe5, 0xa5, 0x64, 0x79, 0xe4, 0xb5, 0x68, 0x18, 0xb9, 0xad, 0x4e,
	0x3f, 0x06, 0x8f, 0x03, 0xb7, 0xd3, 0xa1, 0x81, 0xa8, 0x7d, 0xf1, 0x92, 0x6a, 0xa0, 0x1b, 0x45,
	0x8c, 0x92, 0x31, 0xbf, 0xf2, 0xe8, 0xaa, 0xfe, 0x53, 0xa0, 0xbe, 0x91, 0xfe, 0x2d, 0x92, 0x61,
	0x82, 0xb3, 0xf5, 0xf3, 0x39, 0x18, 0xbf, 0x4d, 0x69, 0xa7, 0xdc, 0xf4, 0x1e, 0x51, 0x72, 0x1e,
	0xf2, 0x1b, 0x6e, 0x8b, 0x2e, 0x64, 0xce, 0x65, 0x2e, 0x8e, 0x2f, 0xcf, 0x1c, 0x1e, 0x94, 0x26,
	0x42, 0x1a, 0x3c, 0xa2, 0x81, 0xd3, 0x76, 0x5b, 0xd4, 0xc6, 0x42, 0xf2, 0x1a, 0x8c, 0xb3, 0xff,
	0xc3, 0x8e, 0x5b, 0xa7, 0x0b, 0x59, 0xc4, 0x9c, 0x3a, 0x3c, 0x28, 0x8d, 0xb7, 0x25, 0xd0, 0x8e,
	0xcb, 0x49, 0x15, 0xc6, 0x56, 0x9f, 0x74, 0xbc, 0x80, 0x86, 0x0b, 0xf9, 0x73, 0x99, 0x8b, 0x13,
	0x4b, 0x8b, 0x97, 0xf9, 0xb7, 0x5e, 0x96, 0xdf, 0x7a, 0x79, 0x4b, 0x76, 0xc6, 0xf2, 0xdc, 0xef,
	0x1e, 0x94, 0x9e, 0x3b, 0x3c, 0x28, 0x8d, 0x51, 0x4e, 0xf2, 0x13, 0x7f, 0x58, 0xca, 0xd8, 0x92,
	0x9e, 0xbc, 0x03, 0xf9, 0xad, 0xfd, 0x0e, 0x5d, 0x18, 0x3f, 0x97, 0xb9, 0x38, 0xbd, 0x74, 0xf6,
	0x32, 0x1f, 0x1e, 0xd5, 0xf8, 0xf8, 0x2f, 0x86, 0xb5, 0x5c, 0x38, 0x3c, 0x28, 0xe5, 0x19, 0x8a,
	0x8d, 0x54, 0xe4, 0x0d, 0x18, 0x5d, 0xf3, 0xc3, 0xa8, 0x5a, 0x59, 0x00, 0x6c, 0xf2, 0x89, 0xc3,
	0x83, 0xd2, 0xec, 0x9e, 0x1f, 0x46, 0x8e, 0xd7, 0x78, 0xdd, 0x6f, 0x79, 0x11, 0x6d, 0x75, 0xa2,
	0x7d, 0x5b, 0x20, 0x59, 0x4f, 0x60, 0xca, 0xe0, 0x47, 0x26, 0x60, 0xec, 0xde, 0xc6, 0xed, 0x8d,
	0xbb, 0x0f, 0x36, 0x8a, 0xcf, 0x91, 0x02, 0xe4, 0x37, 0xee, 0x56, 0x56, 0x8b, 0x19, 0x32, 0x06,
	0xb9, 0xf2, 0xe6, 0x66, 0x31, 0x4b, 0x26, 0xa1, 0x50, 0x29, 0x6f, 0x95, 0x97, 0xcb, 0xb5, 0xd5,
	0x62, 0x8e, 0xcc, 0xc1, 0xcc, 0x83, 0xea, 0x46, 0xe5, 0xee, 0x83, 0x9a, 0x53, 0x59, 0xad, 0xdd,
	0xde, 0xba, 0xbb, 0x59, 0xcc, 0x93, 0x69, 0x80, 0xdb, 0xf7, 0x96, 0x57, 0xed, 0x8d, 0xd5, 0xad,
	0xd5, 0x5a, 0x71, 0x84, 0xcc, 0x43, 0x51, 0x92, 0x38, 0xb5, 0x55, 0xfb, 0x7e, 0x75, 0x65, 0xb5,
	0x38, 0x7a, 0x2b, 0x5f, 0xc8, 0x15, 0xf3, 0xf6, 0xd8, 0x3a, 0x75, 0x43, 0x5a, 0xad, 0x58, 0x7f,
	0x27, 0x07, 0x85, 0x3b, 0x34, 0x72, 0x1b, 0x6e, 0xe4, 0x92, 0x17, 0x8c, 0xf1, 0xc1, 0x4f, 0xd4,
	0x06, 0xe6, 0x7c, 0xef, 0xc0, 0x8c, 0x1c, 0x1e, 0x94, 0x32, 0x6f, 0xe8, 0x03, 0xf2, 0x36, 0x4c,
	0x54, 0x68, 0x58, 0x0f, 0xbc, 0x0e, 0x9b, 0x34, 0x0b, 0x39, 0x44, 0x3b, 0x7d, 0x78, 0x50, 0x3a,
	0xd1, 0x88, 0xc1, 0x5a, 0x87, 0xe8, 0xd8, 0xa4, 0x0a, 0xa3, 0xeb, 0xee, 0x36, 0x6d, 0x86, 0x0b,
	0x23, 0xe7, 0x72, 0x17, 0x27, 0x96, 0x9e, 0x17, 0x83, 0x20, 0x1b, 0x78, 0x99, 0x97, 0xae, 0xb6,
	0xa3, 0x60, 0x7f, 0x79, 0xfe, 0xf0, 0xa0, 0x54, 0x6c, 0x22, 0x40, 0xef, 0x60, 0x8e, 0x42, 0x6a,
	0xf1, 0xc4, 0x18, 0x3d, 0x72, 0x62, 0x9c, 0xf9, 0xdd, 0x83, 0x52, 0x86, 0x0d, 0x98, 0x98, 0x18,
	0x31, 0x3f, 0x73, 0x8a, 0x2c, 0x41, 0xc1, 0xa6, 0x8f, 0xbc, 0x90, 0x7d, 0x59, 0x01, 0xbf, 0xec,
	0xe4, 0xe1, 0x41, 0x89, 0x04, 0x02, 0xa6, 0x35, 0x43, 0xe1, 0x2d, 0xbe, 0x05, 0x13, 0x5a, 0xab,
	0x49, 0x11, 0x72, 0x0f, 0xe9, 0x3e, 0xef, 0x61, 0x9b, 0xfd, 0x49, 0xe6, 0x61, 0xe4, 0x91, 0xdb,
	0xec, 0x8a, 0x2e, 0xb5, 0xf9, 0x8f, 0x2f, 0x65, 0xbf, 0x98, 0xb9, 0x95, 0x2f, 0x8c, 0x15, 0x0b,
	0x76, 0xb6, 0x5a, 0xb1, 0xfe, 0x46, 0x1e, 0x0a, 0xb6, 0xcf, 0x17, 0x22, 0xb9, 0x04, 0x23, 0xb5,
	0xc8, 0x8d, 0xe4, 0x30, 0xcd, 0x1d, 0x1e, 0x94, 0x66, 0xd8, 0x22, 0xa5, 0x5a, 0xfd, 0x1c, 0x83,
	0xa1, 0x6e, 0xee, 0xb9, 0xa1, 0x1c, 0x2e, 0x44, 0xed, 0x30, 0x80, 0x8e, 0x8a, 0x18, 0xe4, 0x02,
	0xe4, 0xef, 0xf8, 0x0d, 0x2a, 0x46, 0x8c, 0x1c, 0x1e, 0x94, 0xa6, 0x5b, 0x7e, 0x43, 0x47, 0xc4,
	0x72, 0xf2, 0x3a, 0x8c, 0xaf, 0x74, 0x83, 0x80, 0xb6, 0xd9, 0x5c, 0xcf, 0x23, 0xf2, 0xf4, 0xe1,
	0x41, 0x09, 0xea, 0x1c, 0xe8, 0x78, 0x0d, 0x3b, 0x46, 0x60, 0xc3, 0x50, 0x8b, 0xdc, 0x20, 0xa2,
	0x8d, 0x85, 0x91, 0xa1, 0x86, 0x81, 0xad, 0xcf, 0xd9, 0x90, 0x93, 0x24, 0x87, 0x41, 0x70, 0x22,
	0x6b, 0x30, 0x71, 0x33, 0x70, 0xeb, 0x74, 0x93, 0x06, 0x9e, 0xdf, 0xc0, 0xf1, 0xcd, 0x2d, 0x5f,
	0x38, 0x3c, 0x28, 0x9d, 0xdc, 0x65, 0x60, 0xa7, 0x83, 0xf0, 0x98, 0xfa, 0xbb, 0x07, 0xa5, 0x42,
	0x45, 0x6c, 0x99, 0xb6, 0x4e, 0x4a, 0xbe, 0xc9, 0x06, 0x27, 0x8c, 0xb0, 0x6b, 0x69, 0x63, 0x61,
	0xec, 0xc8, 0x26, 0x5a, 0xa2, 0x89, 0x27, 0x9b, 0x6e, 0x18, 0x39, 0x01, 0xa7, 0x4b, 0xb4, 0x53,
	0x67, 0x49, 0xee, 0x42, 0xa1, 0x56, 0xdf, 0xa3, 0x8d, 0x6e, 0x93, 0xe2, 0x94, 0x99, 0x58, 0x3a,
	0x25, 0x26, 0xb5, 0x1c, 0x4f, 0x59, 0xbc, 0xbc, 0x28, 0x78, 0x93, 0x50, 0x40, 0xf4, 0xf9, 0x24,
	0xb1, 0xbe, 0x54, 0xf8, 0xd9, 0x5f, 0x28, 0x3d, 0xf7, 0x7d, 0x7f, 0x70, 0xee, 0x39, 0xeb, 0x3f,
	0xce, 0x42, 0x31, 0xc9, 0x84, 0xec, 0xc0, 0xd4, 0xbd, 0x4e, 0xc3, 0x8d, 0xe8, 0x4a, 0xd3, 0xa3,
	0xed, 0x28, 0xc4, 0x49, 0x32, 0xf8, 0x9b, 0x5e, 0x12, 0xf5, 0x2e, 0x74, 0x91, 0xd0, 0xa9, 0x73,
	0xca, 0xc4, 0x57, 0x99, 0x6c, 0xe3, 0x7a, 0x6a, 0xb8, 0x81, 0x87, 0x38, 0xc3, 0x8e, 0x57, 0x0f,
	0xdf, 0xfa, 0xfb, 0xd4, 0x23, 0xd8, 0x8a, 0x09, 0xd4, 0x6e, 0x6c, 0xef, 0xe3, 0xcc, 0x1c, 0x7e,
	0x02, 0x31, 0x92, 0x94, 0x09, 0xc4, 0xc0, 0xd6, 0x3f, 0xc9, 0xc0, 0xb4, 0x4d, 0x43, 0xbf, 0x1b,
	0xd4, 0xe9, 0x1a, 0x75, 0x1b, 0x34, 0x60, 0xd3, 0xff, 0xb6, 0xd7, 0x6e, 0x88, 0x35, 0x85, 0xd3,
	0xff, 0xa1, 0xd7, 0xd6, 0xb7, 0x6e, 0x2c, 0x27, 0x9f, 0x83, 0xb1, 0x5a, 0x77, 0x1b, 0x51, 0xb3,
	0xf1, 0x0e, 0x10, 0x76, 0xb7, 0x9d, 0x04, 0xba, 0x44, 0x23, 0x57, 0x60, 0xec, 0x3e, 0x0d, 0xc2,
	0x78, 0x37, 0xc4, 0xa3, 0xe1, 0x11, 0x07, 0xe9, 0x04, 0x02, 0x8b, 0xdc, 0x8c, 0x77, 0x64, 0x71,
	0xa8, 0xcd, 0x24, 0xf6, 0xc1, 0x78, 0xaa, 0xb4, 0x04, 0x44, 0x9f, 0x2a, 0x12, 0xcb, 0xfa, 0xc9,
	0x2c, 0x14, 0x2b, 0x6e, 0xe4, 0x6e, 0xbb, 0xa1, 0xe8, 0xcf, 0xfb, 0xd7, 0xd8, 0x1e, 0xaf, 0x7d,
	0x28, 0xee, 0xf1, 0xac, 0xe5, 0x1f, 0xfb, 0xf3, 0x5e, 0x4e, 0x7e, 0xde, 0x04, 0x3b, 0x61, 0xc5,
	0xe7, 0xc5, 0x1f, 0xf5, 0xee, 0xd1, 0x1f, 0x55, 0x14, 0x1f, 0x55, 0x90, 0x1f, 0x15, 0x7f, 0x0a,
	0x79, 0x17, 0xf2, 0xb5, 0x0e, 0xad, 0x8b, 0x4d, 0x44, 0x9e, 0x0b, 0xe6, 0xc7, 0x31, 0x84, 0xfb,
	0xd7, 0x96, 0x27, 0x05, 0x9b, 0x7c, 0xd8, 0xa1, 0x75, 0x1b, 0xc9, 0xb4, 0x45, 0xf3, 0x0f, 0x73,
	0x30, 0x9f, 0x46, 0xa6, 0x7f, 0xc7, 0xe8, 0x80, 0xef, 0xb8, 0x08, 0x05, 0x76, 0x84, 0xb3, 0x63,
	0x11, 0xb7, 0x8b, 0xf1, 0xe5, 0x49, 0xd6, 0xe4, 0x3d, 0x01, 0xb3, 0x55, 0x29, 0x39, 0xaf, 0x24,
	0x82, 0x42, 0xcc, 0x4f, 0x48, 0x04, 0x52, 0x0e, 0x60, 0x63, 0x2d, 0x97, 0x30, 0x0a, 0x0e, 0x71,
	0xb7, 0x48, 0x70, 0x3c, 0xd6, 0x81, 0x80, 0x18, 0xc7, 0x8c, 0x3c, 0x14, 0x56, 0xa1, 0x20, 0x3f,
	0x6b, 0x61, 0x12, 0x19, 0xcd, 0x26, 0x3a, 0xe9, 0xfe, 0x35, 0x3e, 0x98, 0x0d, 0xf1, 0x5b, 0x67,
	0x23, 0x71, 0xc8, 0x35, 0x28, 0x6c, 0x06, 0xfe, 0x93, 0xfd, 0x6a, 0x25, 0x5c, 0x98, 0x3a, 0x97,
	0xbb, 0x38, 0xbe, 0x7c, 0xea, 0xf0, 0xa0, 0x34, 0xd7, 0x61, 0x30, 0xc7, 0x6b, 0xe8, 0x27, 0xad,
	0x42, 0xbc, 0x95, 0x2f, 0x64, 0x8a, 0xd9, 0x5b, 0xf9, 0x42, 0xb6, 0x98, 0xe3, 0xe2, 0xc5, 0xad,
	0x7c, 0x21, 0x5f, 0x1c, 0xb9, 0x95, 0x2f, 0x8c, 0xa0, 0xc0, 0x31, 0x5e, 0x84, 0x5b, 0xf9, 0xc2,
	0x44, 0x71, 0xd2, 0x38, 0xed, 0x91, 0x41, 0xe4, 0xd7, 0xfd, 0xa6, 0x9d, 0xbb, 0x67, 0x57, 0xed,
	0xd1, 0x95, 0xf2, 0x0a, 0x0d, 0x22, 0x3b, 0x57, 0x7e, 0x50, 0xb3, 0xa7, 0x2a, 0xfb, 0x6d, 0xb7,
	0xe5, 0xd5, 0xf9, 0xd1, 0x69, 0xe7, 0x6e, 0xae, 0x6c, 0x5a, 0x65, 0x98, 0x8e, 0xbf, 0x65, 0xdd,
	0x0b, 0x23, 0x72, 0x05, 0xc6, 0x25, 0x84, 0x6d, 0x74, 0xb9, 0xd4, 0xaf, 0xb6, 0x63, 0x1c, 0xeb,
	0x77, 0xb2, 0x00, 0x71, 0xc9, 0x33, 0xba, 0x16, 0xbe, 0x60, 0xac, 0x85, 0x13, 0xc9, 0xb5, 0xd0,
	0x77, 0x15, 0x90, 0xf7, 0x61, 0x94, 0x89, 0x05, 0x5d, 0x29, 0x12, 0x9d, 0x4a, 0x92, 0x62, 0xe1,
	0xfd, 0x6b, 0xcb, 0xd3, 0x82, 0x78, 0x34, 0x44, 0x88, 0x2d, 0xc8, 0xb4, 0x65, 0xf4, 0xf3, 0x63,
	0xf1, 0x60, 0x88, 0x05, 0x74, 0x11, 0xd4, 0x80, 0x8a, 0x0e, 0xc5, 0x95, 0xd1, 0x91, 0x83, 0xac,
	0x4a, 0xc9, 0x69, 0x60, 0x03, 0x2e, 0x3a, 0x75, 0xec, 0xf0, 0xa0, 0x94, 0xeb, 0x06, 0x1e, 0x4e,
	0x02, 0x72, 0x05, 0xc4, 0x34, 0x10, 0x1d, 0xc8, 0x66, 0xdf, 0x6c, 0xdd, 0x75, 0xea, 0x34, 0x88,
	0xe2, 0x1e, 0x5f, 0xc8, 0xc8, 0xd9, 0x42, 0x3a, 0x60, 0x4e, 0x95, 0x85, 0x3c, 0x4e, 0x83, 0x8b,
	0xa9, 0xbd, 0x72, 0xd9, 0x40, 0xe5, 0x62, 0xe4, 0x39, 0x79, 0x2a, 0x35, 0x78, 0x99, 0xd3, 0x23,
	0x52, 0x9a, 0x15, 0x90, 0x6b, 0xc0, 0x66, 0xa8, 0xe8, 0x7d, 0x10, 0xf5, 0x94, 0x1f, 0xd4, 0x96,
	0x4f, 0x08, 0x4e, 0x53, 0xee, 0x63, 0x9d, 0x9c, 0x61, 0x93, 0xb7, 0x81, 0x4d, 0x61, 0xd1, 0xef,
	0x44, 0x10, 0xdd, 0x5c, 0xd9, 0x5c, 0x69, 0xfa, 0xdd, 0x46, 0xed, 0xcb, 0xeb, 0x31, 0xf1, 0x6e,
	0xbd, 0xa3, 0x13, 0xdf, 0x5c, 0xd9, 0x24, 0x6f, 0xc3, 0x48, 0xf9, 0xdb, 0xdd, 0x80, 0x0a, 0xf9,
	0x64, 0x52, 0xd6, 0xc9, 0x60, 0xcb, 0xa7, 0x04, 0xe1, 0x8c, 0xcb, 0x7e, 0xea, 0x72, 0x1d, 0x96,
	0xb3, 0x9a, 0xb7, 0xd6, 0x6b, 0x42, 0xf6, 0x20, 0x89, 0x6e, 0xd9, 0x5a, 0xd7, 0x9a, 0x1d, 0x19,
	0x5f, 0xcd, 0xa8, 0xc8, 0x15, 0xc8, 0x96, 0x2b, 0xa8, 0x11, 0x4d, 0x2c, 0x8d, 0xcb, 0x6a, 0x2b,
	0xcb, 0xf3, 0x82, 0x64, 0xd2, 0xd5, 0x97, 0x41, 0xb6, 0x5c, 0x21, 0xcb, 0x30, 0x72, 0x67, 0xbf,
	0xf6, 0xe5, 0x75, 0xb1, 0x99, 0xcd, 0xc9, 0x79, 0xcd, 0x60, 0x77, 0x71, 0xd9, 0x87, 0x71, 0x8b,
	0x5b, 0xfb, 0xe1, 0xb7, 0x9a, 0x7a, 0x8b, 0x11, 0x8d, 0x6c, 0xc2, 0x78, 0xb9, 0xd1, 0xf2, 0xda,
	0xf7, 0x42, 0x1a, 0x2c, 0x4c, 0x20, 0x9f, 0x85, 0x44, 0xbb, 0x55, 0xf9, 0xf2, 0xc2, 0xe1, 0x41,
	0x69, 0xde, 0x65, 0x3f, 0x9d, 0x6e, 0x48, 0x03, 0x8d, 0x5b, 0xcc, 0x84, 0x6c, 0x02, 0xdc, 0xf1,
	0xdb, 0xbb, 0x7e, 0x39, 0x6a, 0xba, 0x61, 0x62, 0x7b, 0x8c, 0x0b, 0x94, 0xf8, 0x70, 0xa2, 0xc5,
	0x60, 0x8e, 0xcb, 0x80, 0x1a, 0x43, 0x8d, 0x07, 0xb9, 0x01, 0xa3, 0x77, 0x03, 0xb7, 0xde, 0xa4,
	0x0b, 0x53, 0xc8, 0x6d, 0x5e, 0x70, 0xe3, 0x40, 0xf9, 0xa5, 0x0b, 0x82, 0x61, 0xd1, 0x47, 0xb0,
	0xae, 0xa6, 0x70, 0xc4, 0xc5, 0x07, 0x40, 0x7a, 0xe7, 0x64, 0x8a, 0x92, 0xf0, 0x9a, 0xae, 0x24,
	0xc4, 0x8b, 0x7e, 0xc5, 0x6f, 0xb5, 0xdc, 0x76, 0x03, 0x69, 0xef, 0x2f, 0x69, 0xba, 0x83, 0xf5,
	0x2d, 0x98, 0xed, 0xe9, 0xac, 0x23, 0xf4, 0xbb, 0xf7, 0x60, 0xa6, 0x42, 0x77, 0xdc, 0x6e, 0x33,
	0x52, 0x27, 0x09, 0x5f, 0xa2, 0xa8, 0x69, 0x35, 0x78, 0x91, 0x23, 0x8f, 0x0f, 0x3b, 0x89, 0x6c,
	0xbd, 0x0b, 0x53, 0xc6, 0xe7, 0x33, 0x55, 0xa1, 0xdc, 0x6d, 0x78, 0x11, 0x0e, 0x64, 0x26, 0x56,
	0x15, 0x5c, 0x06, 0xc4, 0xe1, 0xb2, 0x63, 0x04, 0xeb, 0xdf, 0xd1, 0xa5, 0x15, 0xb1, 0x13, 0x31,
	0xb5, 0x5a, 0xec, 0x07, 0x99, 0x58, 0x76, 0xea, 0xd9, 0x0f, 0xd4, 0x6e, 0x70, 0x89, 0xaf, 0xcd,
	0x6c, 0xcf, 0xda, 0x9c, 0x10, 0x23, 0x91, 0x73, 0x1f, 0x87, 0x7c, 0x45, 0xaa, 0x99, 0x9a, 0xfb,
	0xf8, 0x33, 0xf5, 0x7d, 0x98, 0xbc, 0xe3, 0xb6, 0xdd, 0x5d, 0xda, 0x60, 0x5f, 0xc0, 0xf7, 0x9e,
	0xf1, 0xe5, 0xe7, 0x0f, 0x0f, 0x4a, 0xa7, 0x5a, 0x1c, 0x8e, 0x5f, 0xa9, 0x4f, 0x22, 0x83, 0x80,
	0x5c, 0x95, 0x2b, 0x7b, 0x24, 0x65, 0x65, 0x4f, 0x89, 0xda, 0x47, 0x70, 0x65, 0x8b, 0xf5, 0x6c,
	0xfd, 0xe6, 0x38, 0x7e, 0x23, 0x79, 0x1d, 0x46, 0x6d, 0xba, 0xcb, 0x8e, 0x9a, 0x4c, 0x3c, 0x48,
	0x01, 0x42, 0xf4, 0x8e, 0xe1, 0x38, 0x28, 0x67, 0xd0, 0x46, 0xb8, 0xe7, 0xed, 0x44, 0xa2, 0x77,
	0x94, 0x9c, 0x21, 0xc0, 0x9a, 0x9c, 0x21, 0x20, 0xa6, 0x3a, 0xcb, 0x61, 0x6c, 0xf7, 0xb3, 0x2b,
	0x35, 0xd1, 0x69, 0xb2, 0x87, 0xed, 0x8a, 0xb6, 0x8d, 0x04, 0x86, 0x94, 0xc0, 0xb0, 0xc9, 0x75,
	0x18, 0x2f, 0xd7, 0xeb, 0x7e, 0x57, 0xd3, 0x19, 0xf9, 0xba, 0xe5, 0x40, 0xf3, 0x8a, 0x24, 0x46,
	0x25, 0x35, 0x98, 0x58, 0x65, 0x8a, 0x96, 0xb7, 0xe2, 0xd6, 0xf7, 0x64, 0x27, 0xc9, 0x3d, 0x4c,
	0x2b, 0x89, 0x57, 0x2e, 0x45, 0x60, 0x9d, 0x01, 0xf5, 0x4b, 0x06, 0x0d, 0x97, 0x6c, 0xc1, 0x44,
	0x8d, 0xd6, 0x03, 0x1a, 0xd5, 0x22, 0x3f, 0xa0, 0x89, 0x2d, 0x59, 0x2b, 0x59, 0x3e, 0x2b, 0x75,
	0xbd, 0x10, 0x81, 0x4e, 0xc8, 0xa0, 0x3a, 0x57, 0x0d, 0x99, 0x0b, 0xed, 0x2d, 0x3f, 0xd8, 0xaf,
	0x2c, 0x8b, 0x6d, 0x3a, 0x3e, 0xd3, 0x39, 0x58, 0x17, 0xda, 0x19, 0xa4, 0xb1, 0x6d, 0x0a, 0xed,
	0x1c, 0x0b, 0x47, 0xaa, 0x52, 0x43, 0xd9, 0x4a, 0x6c, 0xda, 0x33, 0x71, 0x2f, 0x23, 0x58, 0x1b,
	0xa9, 0x46, 0x88, 0x92, 0x99, 0x31, 0x52, 0x02, 0x8b, 0x74, 0x80, 0xc8, 0x51, 0xe3, 0x82, 0x6e,
	0x93, 0x86, 0xa1, 0xd8, 0xcb, 0x4f, 0x27, 0x06, 0x3f, 0x46, 0x58, 0x7e, 0x59, 0x30, 0x3f, 0x23,
	0xa7, 0x81, 0xd0, 0xd3, 0x58, 0xa1, 0x56, 0x4f, 0x0a, 0x6f, 0xf2, 0x16, 0xc0, 0xea, 0x93, 0x88,
	0x06, 0x6d, 0xb7, 0xa9, 0xee, 0xc1, 0xf0, 0xea, 0x87, 0x0a, 0xa8, 0x39, 0xd0, 0x1a, 0x32, 0x59,
	0x81, 0xa9, 0x72, 0x18, 0x76, 0x5b, 0xd4, 0xf6, 0x9b, 0xb4, 0x6c, 0x6f, 0xe0, 0xbe, 0x3f, 0xbe,
	0x7c, 0xe6, 0xf0, 0xa0, 0x74, 0xda, 0xc5, 0x02, 0x27, 0xf0, 0x9b, 0xd4, 0x71, 0x03, 0x7d, 0x76,
	0x9b, 0x34, 0xe4, 0x2e, 0xc0, 0xdd, 0x0e, 0x6d, 0xd7, 0xa8, 0x1b, 0xd4, 0xf7, 0x12, 0xdb, 0x7c,
	0x5c, 0xb0, 0xfc, 0x82, 0xf8, 0xc2, 0x79, 0xbf, 0x43, 0xdb, 0x21, 0xc2, 0xf4, 0x56, 0xc5, 0x98,
	0xe4, 0x01, 0xcc, 0x54, 0xcb, 0x77, 0x36, 0xfd, 0xa6, 0x57, 0xdf, 0x17, 0x92, 0xd3, 0x34, 0xde,
	0x0e, 0x9e, 0x14, 0x5c, 0x13, 0xa5, 0x7c, 0x7b, 0xf2, 0xdc, 0x96, 0xd3, 0x41, 0xa8, 0x23, 0xe4,
	0xa7, 0x24, 0x17, 0xf2, 0x21, 0x9b, 0x83, 0x21, 0x13, 0x06, 0xb7, 0xdc, 0xdd, 0x70, 0x61, 0xc6,
	0xb8, 0xed, 0x2a, 0x3f, 0xa8, 0x5d, 0xd6, 0x4a, 0xb9, 0x98, 0xb2, 0xc8, 0x27, 0x22, 0x42, 0x9d,
	0xc8, 0xdd, 0x0d, 0xcd, 0x89, 0xa8, 0xb0, 0xc9, 0x2d, 0x80, 0x8a, 0x5f, 0xef, 0xb6, 0x68, 0x3b,
	0xaa, 0x2c, 0x2f, 0x14, 0x4d, 0x55, 0x40, 0x15, 0xc4, 0x5b, 0x5b, 0xc3, 0xaf, 0x1b, 0x33, 0x51,
	0xa3, 0x5e, 0x7c, 0x0f, 0x8a, 0xc9, 0x86, 0x1c, 0xf3, 0x02, 0x6b, 0xaa, 0x38, 0xad, 0x7d, 0xfd,
	0xea, 0x13, 0x2f, 0x8c, 0x42, 0xeb, 0x7b, 0x8d, 0x15, 0xc8, 0x76, 0x87, 0xdb, 0x74, 0x7f, 0x33,
	0xa0, 0x3b, 0xde, 0x13, 0xb1, 0x99, 0xe1, 0xee, 0xf0, 0x90, 0xee, 0x3b, 0x1d, 0x84, 0xea, 0xbb,
	0x83, 0x42, 0x25, 0x9f, 0x87, 0xc2, 0xed, 0x3b, 0xb5, 0xdb, 0x74, 0xbf, 0x5a, 0x11, 0x07, 0x15,
	0x27, 0x6b, 0x85, 0x0e, 0x23, 0x35, 0xe6, 0x9a, 0xc2, 0xb4, 0x96, 0xe3, 0x9d, 0x90, 0xd5, 0xbc,
	0xd2, 0xec, 0x86, 0x11, 0x0d, 0xaa, 0x15, 0xbd, 0xe6, 0x3a, 0x07, 0x26, 0xf6, 0x25, 0x85, 0x6a,
	0xfd, 0xc3, 0x2c, 0xee, 0x82, 0x6c, 0xc2, 0x57, 0xdb, 0x61, 0xe4, 0xb6, 0xeb, 0x54, 0x31, 0xc0,
	0x09, 0xef, 0x09, 0x68, 0x62, 0xc2, 0xc7, 0xc8, 0x66, 0xd5, 0xd9, 0xa1, 0xab, 0x66, 0x55, 0xca,
	0x9b, 0x8b, 0x6a, 0x45, 0xbf, 0x5e, 0x0d, 0x04, 0x34, 0x51, 0x65, 0x8c, 0x4c, 0x2e, 0xc0, 0x58,
	0xb5, 0x7c, 0xa7, 0xdc, 0x8d, 0xf6, 0x70, 0x0f, 0x2e, 0x70, 0xf9, 0x9c, 0xcd, 0x56, 0xb7, 0x1b,
	0xed, 0xd9, 0xb2, 0x90, 0x5c, 0x41, 0xbd, 0xa7, 0x4d, 0x23, 0x7e, 0x0d, 0x2b, 0x0e, 0xdd, 0x90,
	0x83, 0x12, 0x6a, 0x0f, 0x03, 0x91, 0x57, 0x61, 0xe4, 0xfe, 0xe6, 0x4a, 0xb5, 0x22, 0x14, 0x67,
	0x3c, 0x89, 0x1e, 0x75, 0xea, 0x66, 0x4b, 0x38, 0x8a, 0xf5, 0x5b, 0x99, 0x78, 0x7f, 0x23, 0x17,
	0x0c, 0x79, 0x04, 0x2f, 0x5d, 0x98, 0x3c, 0xa2, 0x5f, 0xba, 0xa0, 0x64, 0x62, 0x03, 0x59, 0xe9,
	0x86, 0x91, 0xdf, 0x5a, 0x6d, 0x37, 0x3a, 0xbe, 0xd7, 0x8e, 0x90, 0x8a, 0xf7, 0x9a, 0x75, 0x78,
	0x50, 0x3a, 0x5b, 0xc7, 0x52, 0x87, 0x8a, 0x62, 0x27, 0xc1, 0x25, 0x85, 0xfa, 0x13, 0x74, 0xa4,
	0xf5, 0x7b, 0x59, 0xe3, 0x5c, 0x62, 0xcd, 0xb3, 0x69, 0xa7, 0xe9, 0xd5, 0x51, 0x15, 0xbf, 0x19,
	0xf8, 0xdd, 0x8e, 0x9a, 0x0e, 0xd8, 0xbc, 0x20, 0x2e, 0x75, 0x76, 0x59, 0xb1, 0xc9, 0x3b, 0x85,
	0x9a, 0x7c, 0x00, 0x93, 0x4c, 0x44, 0x10, 0x3f, 0xc3, 0x85, 0x2c, 0x8e, 0xc4, 0x0b, 0x78, 0x7d,
	0x16, 0xd2, 0x40, 0xb1, 0x31, 0x64, 0x0b, 0x9d, 0x82, 0x34, 0x60, 0x61, 0x2b, 0x70, 0xdb, 0xa1,
	0x17, 0xad, 0xb6, 0xeb, 0xc1, 0x3e, 0x8a, 0x34, 0xab, 0x6d, 0x77, 0xbb, 0x49, 0x1b, 0xf8, 0xb9,
	0x85, 0xe5, 0x8b, 0x87, 0x07, 0xa5, 0x97, 0x22, 0x8e, 0xe3, 0x50, 0x85, 0xe4, 0x50, 0x8e, 0xa5,
	0x71, 0xee, 0xcb, 0x89, 0x89, 0x40, 0xb2, 0x5b, 0xf1, 0xf5, 0x84, 0x9f, 0xee, 0x28, 0x02, 0xa9,
	0xd1, 0x60, 0x9b, 0x8f, 0xde, 0x4c, 0x9d, 0xc0, 0xfa, 0xe7, 0x99, 0xf8, 0xe4, 0x24, 0xef, 0xc0,
	0x84, 0x98, 0xea, 0xda, 0xbc, 0xc0, 0xad, 0x4f, 0xae, 0x8b, 0xc4, 0xc8, 0xea, 0xe8, 0x4c, 0x61,
	0x2f, 0xaf, 0xac, 0x6b, 0x73, 0x03, 0x15, 0x76, 0xb7, 0xde, 0x4c, 0x52, 0x49, 0x34, 0x36, 0x09,
	0xb6, 0xd6, 0x6b, 0x66, 0xaf, 0xe0, 0x24, 0x88, 0x9a, 0x61, 0x4a, 0x37, 0x68, 0xc8, 0x9f, 0xfc,
	0xc3, 0xff, 0x87, 0x4c, 0xda, 0x01, 0x4d, 0x96, 0x61, 0xea, 0x81, 0x1f, 0x3c, 0xc4, 0xf1, 0xd5,
	0x3a, 0x01, 0x47, 0xfe, 0xb1, 0x2c, 0x48, 0x7e, 0x90, 0x49, 0xa2, 0xb7, 0x4d, 0xeb, 0x0d, 0xb3,
	0x6d, 0x09, 0x0e, 0x06, 0x01, 0x1b, 0x07, 0xc5, 0x51, 0xad, 0x0e, 0x1c, 0x87, 0xb8, 0x09, 0xc6,
	0x14, 0xd6, 0xd1, 0xad, 0xff, 0x34, 0xa3, 0x1f, 0xc4, 0xac, 0x93, 0x2b, 0x7e, 0xcb, 0xf5, 0xda,
	0xda, 0xe7, 0xf0, 0x17, 0x21, 0x84, 0x26, 0x5b, 0xa2, 0x21, 0x93, 0x6b, 0x50, 0xe0, 0xbf, 0xd4,
	0x26, 0x89, 0xd7, 0x51, 0x82, 0xd0, 0xdc, 0xe1, 0x25, 0x62, 0xcf, 0xc8, 0xe4, 0x8e, 0x3b, 0x32,
	0xbf, 0x99, 0xd1, 0xcf, 0xd0, 0x8f, 0x7b, 0x4a, 0x24, 0x4e, 0x87, 0xec, 0x71, 0x4e, 0x87, 0x4f,
	0xfc, 0x09, 0xdf, 0x97, 0x81, 0x09, 0xed, 0x7a, 0x81, 0x7d, 0xc3, 0x66, 0xe0, 0x7f, 0x44, 0xeb,
	0x91, 0xf9, 0x0d, 0x1d, 0x0e, 0x4c, 0x7c, 0x83, 0x42, 0xfd, 0x04, 0xdf, 0x60, 0xfd, 0x69, 0x46,
	0x28, 0x37, 0x43, 0x6f, 0xf3, 0xe6, 0x96, 0x9c, 0x3d, 0xce, 0xd9, 0xf6, 0x01, 0x8c, 0xd8, 0xb4,
	0xe1, 0x85, 0x42, 0x31, 0x99, 0xd5, 0x15, 0x29, 0x2c, 0x88, 0x05, 0x9e, 0x80, 0xfd, 0xd4, 0x0f,
	0x26, 0x2c, 0x67, 0x12, 0x68, 0x35, 0xbc, 0xd1, 0xa4, 0x4f, 0x3c, 0xbe, 0x18, 0xc5, 0x19, 0x89,
	0x12, 0xa8, 0x17, 0x3a, 0x3b, 0xac, 0x44, 0x88, 0xc2, 0xfa, 0xc2, 0x33, 0x68, 0xac, 0x0f, 0x01,
	0xe2, 0x2a, 0xc9, 0x6d, 0x28, 0x8a, 0xd9, 0xe0, 0xb5, 0x77, 0xb9, 0x04, 0x24, 0xfa, 0xa0, 0x74,
	0x78, 0x50, 0x7a, 0xbe, 0xae, 0xca, 0x84, 0xb8, 0xa8, 0xf1, 0xed, 0x21, 0xb4, 0xfe, 0xdd, 0x2c,
	0x64, 0xcb, 0x38, 0x20, 0xb7, 0xe9, 0x7e, 0xe4, 0x6e, 0xdf, 0xf0, 0x9a, 0xc6, 0x62, 0x7a, 0x88,
	0x50, 0x67, 0xc7, 0x33, 0xee, 0x19, 0x34, 0x64, 0xb6, 0x98, 0x6e, 0x07, 0xdb, 0x6f, 0x22, 0xa1,
	0xb6, 0x98, 0x1e, 0x06, 0xdb, 0x6f, 0x26, 0xc9, 0x14, 0x22, 0xb1, 0x60, 0x94, 0x2f, 0x2c, 0x31,
	0x07, 0xe1, 0xf0, 0xa0, 0x34, 0xca, 0xd7, 0x9f, 0x2d, 0x4a, 0xc8, 0x69, 0xc8, 0xd5, 0x36, 0x37,
	0xc4, 0x0e, 0x88, 0xf7, 0x79, 0x61, 0xa7, 0x6d, 0x33, 0x18, 0xab, 0x73, 0xbd, 0x52, 0xde, 0x44,
	0x0d, 0x7e, 0x24, 0xae, 0xb3, 0xd9, 0x70, 0x3b, 0x49, 0x1d, 0x5e, 0x21, 0x92, 0x77, 0x61, 0xe2,
	0x76, 0x65, 0x65, 0xcd, 0x0f, 0xf9, 0xee, 0x35, 0x1a, 0x4f, 0xfe, 0x87, 0x8d, 0xba, 0x83, 0x57,
	0xe8, 0xc9, 0x63, 0x40, 0xc3, 0xb7, 0x7e, 0x28, 0x0b, 0x13, 0xda, 0x05, 0x17, 0xf9, 0xbc, 0x78,
	0xd9, 0xcc, 0x18, 0xa2, 0xbb, 0x86, 0xc1, 0x4a, 0xf9, 0x6d, 0x48, 0xcb, 0x6f, 0x50, 0xf1, 0xce,
	0x19, 0xdf, 0x3c, 0x64, 0x87, 0xb9, 0x79, 0x78, 0x0b, 0x80, 0xcf, 0x01, 0x6c, 0xb2, 0x26, 0x4e,
	0x68, 0x06, 0x0e, 0xfa, 0xb8, 0xc4, 0xc8, 0xe4, 0x3e, 0xcc, 0x6d, 0x05, 0xdd, 0x30, 0xaa, 0xed,
	0x87, 0x11, 0x6d, 0x31, 0x6e, 0x9b, 0xbe, 0xdf, 0x14, 0xf3, 0xef, 0xa5, 0xc3, 0x83, 0xd2, 0xb9,
	0x88, 0x15, 0x3b, 0x21, 0x96, 0x63, 0x03, 0x9c, 0x8e, 0xef, 0xeb, 0xf7, 0x11, 0x69, 0x0c, 0x2c,
	0x1b, 0x26, 0xf5, 0xdb, 0x0c, 0x76, 0xb2, 0x88, 0x57, 0x20, 0x71, 0x47, 0xad, 0x9d, 0x2c, 0xa2,
	0x95, 0xbd, 0xaf, 0x52, 0x26, 0x89, 0xf5, 0x79, 0xfd, 0x26, 0x6d, 0xd8, 0x85, 0x6d, 0xfd, 0x40,
	0x26, 0xde, 0x46, 0xee, 0x5f, 0x25, 0x6f, 0xc3, 0x28, 0x7f, 0x75, 0x13, 0x8f, 0x93, 0x27, 0x94,
	0x36, 0xaa, 0x3f, 0xc9, 0xf1, 0x2b, 0xec, 0xdf, 0xe7, 0x2f, 0xf3, 0xcf, 0xd9, 0x82, 0x44, 0xdd,
	0x7e, 0x9b, 0x17, 0x61, 0x92, 0x3b, 0xde, 0xf3, 0x5e, 0x4d, 0xbb, 0xfd, 0xb6, 0x7e, 0x3b, 0x0f,
	0xd3, 0x26, 0x9a, 0xfe, 0x34, 0x97, 0x19, 0xea, 0x69, 0xee, 0x03, 0x28, 0xb0, 0xfe, 0xf0, 0xea,
	0x54, 0x4a, 0x64, 0x2f, 0xe1, 0x9b, 0x80, 0x80, 0x19, 0x4f, 0xce, 0xc0, 0x87, 0x83, 0x29, 0xa7,
	0xb6, 0xa2, 0x22, 0x4b, 0xda, 0xfb, 0x51, 0x2e, 0x16, 0x52, 0xe4, 0xfb, 0x91, 0xbe, 0x1e, 0xd4,
	0x4b, 0xd2, 0x1b, 0x30, 0xca, 0x04, 0x73, 0x75, 0x77, 0x82, 0xad, 0x64, 0x32, 0x7b, 0xc2, 0xb6,
	0x84, 0x23, 0x91, 0x07, 0x50, 0x58, 0x77, 0xc3, 0xa8, 0x46, 0x69, 0x7b, 0x88, 0x47, 0xf7, 0x92,
	0xe8, 0xaa, 0x39, 0x7c, 0xd1, 0x0e, 0x29, 0x6d, 0x27, 0x5e, 0x4d, 0x15, 0x33, 0xf2, 0x75, 0x80,
	0x15, 0xbf, 0x1d, 0x05, 0x7e, 0x73, 0xdd, 0xdf, 0x5d, 0x18, 0x45, 0xa5, 0xf5, 0x6c, 0x62, 0x00,
	0x62, 0x04, 0xae, 0xb7, 0xaa, 0x9b, 0x99, 0x3a, 0x2f, 0x70, 0x9a, 0xfe, 0xae, 0xbe, 0x0e, 0x62,
	0x7c, 0x72, 0x03, 0x8a, 0xf2, 0x46, 0xe0, 0x5e, 0x67, 0x37, 0xc0, 0x09, 0x32, 0x16, 0x4b, 0x1e,
	0xf4, 0x49, 0xe4, 0x74, 0x05, 0x5c, 0xdf, 0x29, 0x93, 0x34, 0xe4, 0x6b, 0x70, 0x2a, 0x09, 0x93,
	0xa3, 0x5c, 0x88, 0x65, 0x72, 0x9d, 0x5d, 0xca, 0xbc, 0xef, 0xc7, 0xc2, 0xfa, 0x6e, 0x16, 0x4e,
	0xf5, 0xf9, 0x58, 0xb6, 0x1e, 0xf0, 0xb8, 0xd6, 0xd6, 0x43, 0xe2, 0x94, 0xe6, 0xc6, 0x42, 0xe7,
	0x20, 0x2b, 0x0e, 0xb8, 0xfc, 0x72, 0xf1, 0xf0, 0xa0, 0x34, 0x69, 0x8c, 0x63, 0xb6, 0x5a, 0x21,
	0xb7, 0x20, 0xcf, 0x86, 0x68, 0x88, 0x37, 0x6f, 0x79, 0x19, 0x34, 0x1d, 0x79, 0xfa, 0xf4, 0xc1,
	0xa1, 0x43, 0x1e, 0xe4, 0xf3, 0x90, 0xdb, 0xda, 0x5a, 0xc7, 0xb9, 0x93, 0xc3, 0x6f, 0x9f, 0x8a,
	0xa2, 0xa6, 0x31, 0x55, 0xa7, 0x18, 0xed, 0x65, 0x65, 0x22, 0xc1, 0xd0, 0xc9, 0x57, 0x12, 0xb6,
	0x38, 0xaf, 0x0e, 0x1e, 0xe8, 0xe1, 0x4d, 0x73, 0x3e, 0x81, 0x45, 0x8c, 0xf5, 0x73, 0xd9, 0x78,
	0x0d, 0xdf, 0xf0, 0x9a, 0x11, 0x0d, 0xc8, 0x22, 0x5f, 0x92, 0xb1, 0x70, 0x66, 0xab, 0xdf, 0x64,
	0x21, 0x5e, 0xdf, 0x9c, 0x95, 0x5a, 0xc8, 0xaf, 0x6a, 0x0b, 0x39, 0x87, 0x0b, 0x79, 0xba, 0xef,
	0x92, 0x7d, 0x35, 0x65, 0x5e, 0xe2, 0x42, 0x4c, 0x99, 0x7b, 0x2f, 0xc1, 0xd4, 0x86, 0xbf, 0xfa,
	0x24, 0x52, 0x88, 0x6c, 0x01, 0x16, 0x6c, 0x13, 0xc8, 0x38, 0xde, 0x6d, 0x36, 0x68, 0xb0, 0xb5,
	0xe7, 0xb6, 0x8d, 0x47, 0x67, 0xbb, 0x07, 0xce, 0x70, 0x37, 0xe8, 0x63, 0x13, 0x77, 0x8c, 0xe3,
	0x26, 0xe1, 0xd6, 0xf7, 0x67, 0x65, 0x67, 0xdc, 0x5f, 0x7a, 0x46, 0x1f, 0x37, 0xdf, 0x34, 0x1e,
	0x37, 0xe7, 0xd4, 0xb5, 0xac, 0x7a, 0xa9, 0x5f, 0x3a, 0xe2, 0x81, 0xff, 0x7f, 0x1c, 0x81, 0x49,
	0x1d, 0x9d, 0xf5, 0x43, 0xb9, 0xd1, 0x08, 0xf4, 0x7e, 0x70, 0x1b, 0x8d, 0xc0, 0x46, 0xa8, 0xf1,
	0x9e, 0x9f, 0x1b, 0xf8, 0x9e, 0xff, 0x0d, 0x18, 0x5f, 0x69, 0x35, 0x8c, 0x57, 0x46, 0x2b, 0xa5,
	0x79, 0x97, 0x15, 0x12, 0x5f, 0x0b, 0xea, 0xb6, 0xb1, 0xde, 0x6a, 0xf4, 0xbe, 0x2d, 0xc6, 0x2c,
	0x0d, 0x53, 0x80, 0x91, 0x4f, 0x62, 0x0a, 0x70, 0x1d, 0xc6, 0xef, 0x85, 0x74, 0xab, 0xdb, 0x6e,
	0xd3, 0x26, 0x4e, 0xab, 0x02, 0x97, 0xf5, 0xbb, 0x21, 0x75, 0x22, 0x84, 0xea, 0x0d, 0x50, 0xa8,
	0xfa, 0x00, 0x8f, 0x0d, 0x18, 0xe0, 0x6b, 0x50, 0xd8, 0xa4, 0x34, 0xc0, 0x3e, 0x9d, 0x88, 0x45,
	0xba, 0x0e, 0xa5, 0x81, 0xc3, 0x3a, 0xd6, 0x30, 0x11, 0x10, 0x88, 0x86, 0x5d, 0xc1, 0xe4, 0x90,
	0x76, 0x05, 0xe4, 0x45, 0x98, 0xec, 0x74, 0xb7, 0x9b, 0x5e, 0x1d, 0xf9, 0x0a, 0x83, 0x04, 0x7b,
	0x82, 0xc3, 0x18, 0xdb, 0x90, 0x7c, 0x05, 0xa6, 0x50, 0xc7, 0x51, 0x53, 0x6e, 0xda, 0x78, 0x8e,
	0x33, 0xca, 0xb8, 0xa4, 0x53, 0x67, 0x20, 0x27, 0xc5, 0x6e, 0xc6, 0x64, 0xb4, 0x58, 0x83, 0x69,
	0x73, 0x24, 0x9f, 0xc2, 0xab, 0x9c, 0xb2, 0x91, 0x28, 0x14, 0xc7, 0x6f, 0xe5, 0x0b, 0x50, 0x9c,
	0xe0, 0xd6, 0x11, 0x36, 0x6c, 0xaa, 0x6f, 0xb2, 0xc9, 0xed, 0xee, 0x36, 0x0d, 0xda, 0x34, 0xa2,
	0xa1, 0x50, 0x02, 0x42, 0x3b, 0x5f, 0xee, 0x74, 0x42, 0xeb, 0x1f, 0x64, 0x61, 0xac, 0xfc, 0xa0,
	0x56, 0x6d, 0xef, 0xf8, 0xf8, 0xb6, 0xa6, 0x9e, 0x54, 0xf4, 0xb7, 0x35, 0xf5, 0xa4, 0xa2, 0x3f,
	0xa4, 0x5c, 0x49, 0x51, 0xe3, 0xd0, 0xfc, 0x56, 0x53, 0xe3, 0x0c, 0x05, 0x34, 0x7e, 0x5d, 0xca,
	0x0d, 0xf1, 0xba, 0xa4, 0x2e, 0x00, 0xf3, 0x47, 0x5e, 0x00, 0x92, 0xb7, 0x61, 0xa2, 0xda, 0x8e,
	0xe8, 0x6e, 0x10, 0xcf, 0x74, 0xa5, 0x52, 0x2a, 0xb0, 0x2e, 0xda, 0x6b, 0xd8, 0x6c, 0x1a, 0xf1,
	0x4b, 0x47, 0x75, 0xd9, 0x88, 0xd3, 0x88, 0xdf, 0x4d, 0x26, 0xee, 0x03, 0x24, 0xa2, 0x55, 0x49,
	0xcc, 0x11, 0xf9, 0x82, 0xcf, 0x85, 0xcf, 0xe9, 0xf8, 0xd6, 0x9d, 0x75, 0xec, 0xf2, 0x6c, 0xfa,
	0x0b, 0xbe, 0xf5, 0xc3, 0x59, 0x98, 0x28, 0x77, 0x3a, 0xcf, 0xb8, 0x1d, 0xd5, 0x17, 0x8d, 0xed,
	0x55, 0xea, 0x42, 0xea, 0xbb, 0x86, 0x32, 0xa1, 0xfa, 0xe5, 0x2c, 0xcc, 0x24, 0x28, 0xf4, 0xd6,
	0x67, 0x86, 0xb4, 0x9e, 0xca, 0x0e, 0x69, 0x3d, 0x95, 0x1b, 0xce, 0x7a, 0x2a, 0xff, 0x49, 0xb6,
	0xcc, 0x57, 0x20, 0x57, 0xee, 0x74, 0x92, 0xaf, 0xb0, 0x9d, 0xce, 0xfd, 0x6b, 0x5c, 0x9f, 0x75,
	0x3b, 0x1d, 0x9b, 0x61, 0x18, 0xfb, 0xd8, 0xe8, 0x90, 0xfb, 0x98, 0xf5, 0x06, 0x8c, 0x23, 0x2f,
	0xb4, 0x59, 0x3a, 0x07, 0xb8, 0x98, 0x85, 0xb9, 0x92, 0x51, 0x97, 0x58, 0xe6, 0xff, 0x22, 0x03,
	0x23, 0xf8, 0xfb, 0x19, 0x9d, 0x63, 0x4b, 0xc6, 0x1c, 0x2b, 0x6a, 0x73, 0x6c, 0x98, 0xd9, 0xf5,
	0x7f, 0xe6, 0xb1, 0xb7, 0xc4, 0xbc, 0x12, 0xa6, 0x42, 0x99, 0x14, 0x53, 0xa1, 0xb7, 0x40, 0xdb,
	0x35, 0xf5, 0xdb, 0x22, 0xed, 0xcc, 0xd0, 0x35, 0x8d, 0x18, 0x99, 0x3c, 0x4c, 0x1a, 0x0d, 0xe5,
	0x70, 0x30, 0xce, 0x27, 0x9b, 0xfa, 0x54, 0xec, 0x85, 0xd6, 0x80, 0x54, 0xdb, 0x21, 0xad, 0x77,
	0x03, 0x5a, 0x7b, 0xe8, 0x75, 0xee, 0xd3, 0xc0, 0xdb, 0xd9, 0x17, 0xda, 0x3d, 0x9e, 0xcb, 0x9e,
	0x28, 0x75, 0xc2, 0x87, 0x5e, 0x87, 0xa9, 0x22, 0xde, 0xce, 0xbe, 0x9d, 0x42, 0x43, 0xde, 0x87,
	0x31, 0x9b, 0x3e, 0x0e, 0xbc, 0x48, 0x3e, 0x85, 0x4f, 0x2b, 0xc5, 0x19, 0xa1, 0x5c, 0x31, 0x0c,
	0xf8, 0x0f, 0x7d, 0xfc, 0x45, 0x39, 0x59, 0xe2, 0x1b, 0x1f, 0x7f, 0xf2, 0x9e, 0x8a, 0xbf, 0xb6,
	0xfc, 0xa0, 0xd6, 0x6f, 0xdf, 0x23, 0x97, 0x60, 0x04, 0x77, 0x4f, 0x21, 0x13, 0xa0, 0x09, 0x39,
	0x9e, 0xa1, 0xfa, 0xd6, 0x8e, 0x18, 0xe4, 0x2c, 0x80, 0x7a, 0x81, 0x08, 0x17, 0x0a, 0x78, 0x5a,
	0x6b, 0x90, 0xe4, 0xd6, 0x3f, 0x7e, 0x9c, 0xad, 0xff, 0xd3, 0xb3, 0x94, 0xf9, 0xe5, 0x2c, 0x9c,
	0x57, 0xdb, 0xd9, 0xdd, 0xa0, 0x56, 0xbe, 0xb3, 0x5e, 0x6d, 0x6c, 0x0a, 0xe9, 0x7f, 0x33, 0xf0,
	0x1f, 0x79, 0x4c, 0xfb, 0xbb, 0x7a, 0xc4, 0x62, 0x5c, 0xe7, 0xb3, 0x96, 0x5f, 0x1d, 0x66, 0x0d,
	0x9b, 0x02, 0xed, 0xd4, 0x10, 0x66, 0x0f, 0x9d, 0x4e, 0xcf, 0x4d, 0xe2, 0xda, 0x73, 0x76, 0xcc,
	0x80, 0xfc, 0x40, 0x06, 0x4e, 0xa6, 0x37, 0x44, 0x68, 0x84, 0x25, 0x29, 0x79, 0xf6, 0x69, 0xed,
	0xf2, 0x2b, 0x87, 0x07, 0xa5, 0xf3, 0xa1, 0xdb, 0x6a, 0x3a, 0x5e, 0x83, 0xd7, 0xe6, 0xd5, 0xa9,
	0xd3, 0x11, 0x08, 0x46, 0xbd, 0x7d, 0x6a, 0xfa, 0x12, 0xc8, 0x35, 0xb9, 0x90, 0x59, 0x06, 0x28,
	0xc8, 0xdb, 0x19, 0xeb, 0xd7, 0x32, 0xa0, 0xcd, 0xa8, 0x82, 0x4d, 0x1b, 0x5e, 0x40, 0xeb, 0x11,
	0xee, 0x68, 0xca, 0x23, 0x82, 0xc3, 0x12, 0x26, 0x24, 0x08, 0x23, 0xef, 0xc1, 0x18, 0xbf, 0xcb,
	0xe1, 0x77, 0x28, 0xf1, 0x4c, 0x14, 0xf7, 0x3e, 0xdc, 0x75, 0x86, 0x63, 0xe8, 0xb3, 0x58, 0x10,
	0x31, 0xf9, 0xf6, 0xd6, 0x83, 0xad, 0x95, 0xa6, 0xeb, 0xb5, 0x42, 0xb1, 0x8f, 0x61, 0xb7, 0x7e,
	0xf4, 0x38, 0x72, 0xea, 0x08, 0xd5, 0xe5, 0x5b, 0x85, 0x6a, 0xdd, 0x94, 0xd7, 0x4e, 0x47, 0xd8,
	0x41, 0x95, 0x60, 0xe4, 0x7e, 0xac, 0x7e, 0x2e, 0x8f, 0x1f, 0x1e, 0x94, 0xf8, 0x74, 0xb1, 0x39,
	0xdc, 0xfa, 0xeb, 0x19, 0x98, 0x36, 0xe7, 0x13, 0xb9, 0x0c, 0xa3, 0xc2, 0x1b, 0x21, 0x83, 0x6a,
	0x36, 0xeb, 0x85, 0x51, 0xee, 0x87, 0x60, 0x78, 0x1f, 0x08, 0x2c, 0xb6, 0x13, 0x0b, 0x0e, 0xe2,
	0x1e, 0x09, 0x77, 0xe2, 0x3a, 0x07, 0xd9, 0xb2, 0x8c, 0x58, 0x4c, 0x0c, 0x0b, 0xbb, 0xcd, 0x48,
	0xbf, 0x7d, 0x0d, 0x10, 0x62, 0x8b, 0x12, 0x6b, 0x05, 0x46, 0xf9, 0x12, 0x4e, 0xd8, 0x5f, 0x64,
	0x8e, 0x61, 0x7f, 0x61, 0x1d, 0x64, 0x00, 0x6a, 0xb5, 0xb5, 0xdb, 0x74, 0x7f, 0xd3, 0xf5, 0x02,
	0x7c, 0x2e, 0xc0, 0xed, 0xf2, 0xb6, 0x58, 0x5c, 0x93, 0xe2, 0xb9, 0x80, 0x6f, 0xad, 0x0f, 0xe9,
	0xbe, 0xf1, 0x5c, 0x20, 0x51, 0x71, 0x4f, 0x0e, 0xbc, 0x47, 0x6e, 0x44, 0x19, 0x61, 0x16, 0x09,
	0xf9, 0x9e, 0xcc, 0xa1, 0x09, 0x4a, 0x0d, 0x99, 0x7c, 0x1d, 0xa6, 0xe3, 0x5f, 0xea, 0xd1, 0x63,
	0x5a, 0x2d, 0x60, 0xb3, 0x70, 0xf9, 0xec, 0xe1, 0x41, 0x69, 0x51, 0xe3, 0x9a, 0x7c, 0x0e, 0x49,
	0x30, 0xb3, 0x7e, 0x31, 0x83, 0x4f, 0x7d, 0xf2, 0x03, 0x2f, 0x40, 0x5e, 0x59, 0x95, 0x4d, 0xf2,
	0x9b, 0x9a, 0xc4, 0xc5, 0x2e, 0x96, 0x93, 0xf3, 0x90, 0x8b, 0xbf, 0x04, 0xb7, 0x48, 0xf3, 0x0b,
	0x58, 0x29, 0xb9, 0x09, 0x63, 0x43, 0xb5, 0x19, 0x97, 0x46, 0x4a, 0x5b, 0x25, 0x35, 0x8e, 0xc2,
	0xad, 0x07, 0x5b, 0x9f, 0xdd, 0x51, 0xf8, 0xf1, 0x2c, 0xcc, 0xb0, 0x7e, 0x2d, 0x77, 0xa3, 0x3d,
	0x3f, 0xf0, 0xa2, 0xfd, 0x67, 0xf6, 0x9e, 0xe2, 0x1d, 0x43, 0xc8, 0x59, 0x94, 0xa7, 0x8c, 0xfe,
	0x6d, 0x43, 0x5d, 0x57, 0xfc, 0x57, 0x23, 0x30, 0x97, 0x42, 0x45, 0x5e, 0x37, 0xae, 0x12, 0x17,
	0xa4, 0xb7, 0xe1, 0x77, 0x0f, 0x4a, 0x93, 0x12, 0x7d, 0x2b, 0xf6, 0x3e, 0x5c, 0x32, 0xdf, 0xcd,
	0x79, 0x4f, 0xe1, 0xcd, 0xa2, 0xfe, 0x6e, 0x6e, 0xbe, 0x96, 0x5f, 0x82, 0x11, 0xdb, 0x6f, 0x52,
	0x69, 0xe4, 0x81, 0x07, 0x7b, 0xc0, 0x00, 0xc6, 0xdb, 0x18, 0x03, 0x90, 0x35, 0x18, 0x63, 0x7f,
	0xdc, 0x71, 0x3b, 0xe2, 0xd6, 0x97, 0x28, 0x31, 0x1b, 0xa1, 0x1d, 0xaf, 0xbd, 0xab, 0x4b, 0xda,
	0x4d, 0xea, 0xb4, 0xdc, 0x8e, 0x21, 0x81, 0x70, 0x44, 0x43, 0x62, 0x2f, 0xf4, 0x97, 0xd8, 0x33,
	0x47, 0x4a, 0xec, 0x3b, 0x00, 0x35, 0x6f, 0xb7, 0xed, 0xb5, 0x77, 0xcb, 0xcd, 0x5d, 0xe1, 0xb3,
	0x79, 0xa9, 0xff, 0x28, 0x5c, 0x8e, 0x91, 0x71, 0xe2, 0x3e, 0x8f, 0x4f, 0x33, 0x1c, 0xe6, 0xb8,
	0xcd, 0x5d, 0xc3, 0xb6, 0x5c, 0xe3, 0x4c, 0x36, 0x00, 0xca, 0xf5, 0xc8, 0x7b, 0xc4, 0xa6, 0x70,
	0x28, 0xac, 0x91, 0x65, 0x93, 0x57, 0xca, 0xb7, 0xe9, 0x7e, 0x8d, 0x46, 0xf1, 0x25, 0xb7, 0x8b,
	0xa8, 0x6c, 0x25, 0x18, 0x86, 0xc3, 0x31, 0x07, 0xd2, 0x81, 0x13, 0xe5, 0x46, 0xc3, 0x63, 0xdf,
	0xe0, 0x36, 0xf1, 0xd5, 0x86, 0x36, 0x90, 0xf5, 0x64, 0x3a, 0xeb, 0x4b, 0x82, 0xf5, 0x8b, 0xae,
	0xa2, 0x72, 0x22, 0x4e, 0x96, 0xac, 0x26, 0x9d, 0xb1, 0x55, 0x83, 0x69, 0xf3, 0xe3, 0x4d, 0x5f,
	0xd3, 0x49, 0x28, 0xd8, 0xb5, 0xb2, 0x53, 0x5b, 0x2b, 0x5f, 0x2d, 0x66, 0x48, 0x11, 0x26, 0xc5,
	0xaf, 0x25, 0x67, 0xe9, 0xcd, 0xeb, 0xc5, 0xac, 0x01, 0x79, 0xf3, 0xea, 0x52, 0x31, 0xb7, 0x98,
	0x5d, 0xc8, 0x24, 0xdc, 0x3c, 0xc6, 0x8a, 0x05, 0x7e, 0x9d, 0x61, 0xfd, 0x4a, 0x06, 0x0a, 0xb2,
	0xed, 0xe4, 0x3a, 0xe4, 0x6a, 0xb5, 0xb5, 0x84, 0x63, 0x46, 0x7c, 0xca, 0xf0, 0xfd, 0x34, 0x0c,
	0x75, 0xeb, 0x3b, 0x46, 0xc0, 0xe8, 0xb6, 0xd6, 0x6b, 0x42, 0x38, 0x90, 0x74, 0xf1, 0xe6, 0xcd,
	0xe9, 0x52, 0xac, 0xd5, 0xaf, 0x43, 0xee, 0xd6, 0x83, 0x2d, 0x21, 0xcc, 0x4b, 0xba, 0x78, 0x3f,
	0xe5, 0x74, 0x1f, 0x3d, 0xd6, 0x77, 0x79, 0x46, 0x60, 0xd9, 0x30, 0xa1, 0x4d, 0x64, 0x7e, 0xe8,
	0xb6, 0x7c, 0xe5, 0x60, 0x29, 0x0e, 0x5d, 0x06, 0xb1, 0x45, 0x09, 0x93, 0x11, 0xd6, 0xfd, 0xba,
	0xdb, 0x14, 0xa7, 0x37, 0xca, 0x08, 0x4d, 0x06, 0xb0, 0x39, 0xdc, 0xfa, 0xad, 0x0c, 0x14, 0x51,
	0x92, 0x42, 0xeb, 0x39, 0xff, 0x21, 0x6d, 0xdf, 0xbf, 0x4a, 0xde, 0x90, 0x4b, 0x2e, 0xa3, 0x54,
	0xc7, 0x11, 0x5c, 0x72, 0x89, 0xbb, 0x67, 0xb1, 0xec, 0x34, 0x1f, 0xd6, 0xec, 0xf0, 0xbe, 0x6f,
	0x47, 0xf8, 0xb0, 0x96, 0x60, 0x04, 0x9b, 0x23, 0x36, 0x47, 0x6c, 0x79, 0xc4, 0x00, 0x36, 0x87,
	0x6b, 0x7b, 0xd3, 0x4f, 0x66, 0x7b, 0xbe, 0x61, 0xe9, 0x33, 0xe5, 0x3f, 0x66, 0x7e, 0xdc, 0x50,
	0xfb, 0xf5, 0x87, 0x30, 0x9f, 0xec, 0x12, 0x54, 0xeb, 0xcb, 0x30, 0x63, 0xc2, 0xa5, 0x86, 0x7f,
	0x2a, 0xb5, 0xae, 0xfb, 0x4b, 0x76, 0x12, 0xdf, 0xfa, 0x5f, 0x33, 0x30, 0x8e, 0x7f, 0xda, 0xdd,
	0x26, 0x1a, 0x43, 0x94, 0x1f, 0xd4, 0xc4, 0x15, 0x9e, 0x2e, 0xcc, 0xb9, 0x8f, 0x43, 0x47, 0xdc,
	0xf2, 0x19, 0x7b, 0x8c, 0x42, 0x16, 0xa4, 0xfc, 0x6e, 0x4e, 0xbe, 0x53, 0x2a, 0x52, 0x7e, 0x89,
	0x17, 0x26, 0x48, 0x05, 0x32, 0x9a, 0x50, 0x3d, 0xa8, 0xb1, 0xe9, 0xa7, 0xbf, 0x4e, 0x22, 0x9d,
	0xdf, 0x34, 0x4d, 0xa8, 0x38, 0x1a, 0x3e, 0x4e, 0x3e, 0xa8, 0x95, 0xed, 0x0d, 0xe3, 0x71, 0x92,
	0xb5, 0xd1, 0x30, 0xd5, 0x15, 0x48, 0xd6, 0x3f, 0x82, 0x64, 0x07, 0x8a, 0x03, 0xef, 0x98, 0x6b,
	0xe3, 0x6d, 0x18, 0x29, 0x37, 0x9b, 0xfe, 0x63, 0xb1, 0x4b, 0xc8, 0x5b, 0x06, 0xd5, 0x7f, 0xfc,
	0x3c, 0x73, 0x19, 0x8a, 0xe1, 0x13, 0xc3, 0x00, 0x64, 0x05, 0xc6, 0xcb, 0x0f, 0x6a, 0xd5, 0x6a,
	0x65, 0x6b, 0x8b, 0xdb, 0xff, 0xe7, 0x96, 0x5f, 0x96, 0xfd, 0xe3, 0x79, 0x0d, 0x27, 0xf9, 0x3e,
	0x16, 0xcb, 0xef, 0x31, 0x1d, 0x79, 0x17, 0xe0, 0x96, 0xef, 0xb5, 0xef, 0xd0, 0x68, 0xcf, 0x6f,
	0x88, 0x8f, 0x3f, 0x73, 0x78, 0x50, 0x9a, 0xf8, 0xc8, 0xf7, 0xda, 0x4e, 0x0b, 0xc1, 0xac, 0xed,
	0x31, 0x92, 0xad, 0xfd, 0xcd, 0x7a, 0x7a, 0xd9, 0xe7, 0x06, 0x0e, 0x23, 0x71, 0x4f, 0x6f, 0xfb,
	0x3d, 0xb6, 0x0d, 0x12, 0x8d, 0xb4, 0x60, 0xa6, 0xd6, 0xdd, 0xdd, 0xa5, 0x6c, 0x67, 0x17, 0xf7,
	0x16, 0xa3, 0x42, 0xc7, 0x55, 0x51, 0x17, 0xb8, 0x3e, 0xc2, 0xb4, 0x94, 0x70, 0xf9, 0x75, 0x36,
	0x91, 0xbf, 0x73, 0x50, 0x12, 0xef, 0x6e, 0x4c, 0x54, 0x0b, 0x25, 0x7d, 0xef, 0xad, 0x45, 0x92,
	0x37, 0xb9, 0x0b, 0xa3, 0x37, 0xbd, 0x68, 0xad, 0xbb, 0x2d, 0xec, 0xd9, 0x5f, 0x1c, 0xb0, 0x68,
	0x38, 0x22, 0xbf, 0xf8, 0xdd, 0xf5, 0xa2, 0xbd, 0xae, 0x6e, 0x51, 0x2c, 0xd8, 0x90, 0x07, 0x50,
	0x58, 0xf1, 0x82, 0x7a, 0x93, 0xae, 0x54, 0xc5, 0xd9, 0x7f, 0x7e, 0x00, 0x4b, 0x89, 0xca, 0xfb,
	0xa5, 0x8e, 0xbf, 0xea, 0x9e, 0x2e, 0x0b, 0x48, 0x0c, 0xf2, 0x37, 0x33, 0xf0, 0xbc, 0x6a, 0x7d,
	0x79, 0x97, 0xb6, 0xa3, 0x3b, 0x6e, 0x54, 0xdf, 0xa3, 0x81, 0xe8, 0xa5, 0xf1, 0x41, 0xbd, 0xf4,
	0xa5, 0x9e, 0x5e, 0xba, 0x18, 0xf7, 0x92, 0xcb, 0x98, 0x39, 0x2d, 0xce, 0xad, 0xb7, 0xcf, 0x06,
	0xd5, 0x4a, 0x1c, 0x80, 0xf8, 0x26, 0x5f, 0xf8, 0x43, 0xbd, 0x3c, 0xe0, 0x83, 0x63, 0x64, 0x61,
	0xc7, 0xac, 0x7e, 0x1b, 0xf6, 0x3c, 0x0a, 0x4a, 0x6e, 0x4b, 0xe7, 0x11, 0x2e, 0x95, 0x9c, 0x1b,
	0xc0, 0x9b, 0x3b, 0x94, 0xcc, 0x0d, 0x70, 0x13, 0xe3, 0xa3, 0xbd, 0xee, 0x6e, 0x0b, 0x41, 0xe4,
	0x88, 0xd1, 0x5e, 0x77, 0xe3, 0xd1, 0x6e, 0xba, 0xc9, 0xd1, 0x5e, 0x77, 0xb7, 0xc9, 0x0a, 0xf7,
	0x78, 0xe3, 0xee, 0x51, 0x67, 0x07, 0x71, 0x5b, 0xd9, 0xe4, 0x27, 0x73, 0x8a, 0xe7, 0xdb, 0x57,
	0x61, 0xbc, 0xd6, 0x71, 0xeb, 0xb4, 0xe9, 0xed, 0x44, 0xe2, 0x69, 0xe7, 0xa5, 0x01, 0xac, 0x14,
	0xae, 0x78, 0x16, 0x90, 0x3f, 0x75, 0x35, 0x49, 0xe1, 0xb0, 0x16, 0x6e, 0x6d, 0xde, 0x59, 0x98,
	0x39, 0xb2, 0x85, 0x5b, 0x9b, 0x77, 0x84, 0xcc, 0xd1, 0x69, 0x19, 0x32, 0xc7, 0xe6, 0x1d, 0xd2,
	0x81, 0xe9, 0x2d, 0x1a, 0x04, 0xee, 0x8e, 0x1f, 0xb4, 0xf8, 0x3d, 0x19, 0x37, 0xb9, 0xbf, 0x34,
	0x88, 0x9f, 0x41, 0xc0, 0x4d, 0xcc, 0x22, 0x09, 0x73, 0x92, 0x97, 0x6b, 0x09, 0xfe, 0xd6, 0xaf,
	0xe7, 0xe0, 0x54, 0x9f, 0x56, 0x92, 0x0d, 0xb9, 0x2b, 0x66, 0x8c, 0x0b, 0xcd, 0x3e, 0xe8, 0x97,
	0x8f, 0xdc, 0x28, 0xd7, 0xa1, 0xb8, 0x7a, 0x1b, 0xc5, 0x69, 0xf6, 0x93, 0x36, 0x56, 0xca, 0xf2,
	0x3c, 0x39, 0x77, 0x78, 0x50, 0x7a, 0x81, 0x3e, 0x44, 0x63, 0x24, 0x97, 0x17, 0x3a, 0x75, 0xc3,
	0x5d, 0xae, 0x87, 0x72, 0xf1, 0xfb, 0xb3, 0x90, 0xc7, 0xb3, 0x2d, 0x11, 0x24, 0x24, 0x73, 0xac,
	0x20, 0x21, 0x1f, 0xc0, 0xe4, 0xea, 0x6d, 0xae, 0xec, 0xae, 0xb9, 0xe1, 0x9e, 0xd8, 0x79, 0xf1,
	0x6d, 0x8f, 0x3e, 0x74, 0x84, 0x6e, 0xbc, 0xe7, 0x1a, 0x62, 0xa5, 0x41, 0x41, 0xee, 0xc1, 0x1c,
	0x6f, 0x9b, 0xb7, 0xe3, 0xd5, 0x79, 0xac, 0x01, 0xcf, 0x6d, 0x8a, 0x6d, 0xf8, 0xfc, 0xe1, 0x41,
	0xa9, 0x44, 0x1f, 0xa2, 0x99, 0x95, 0x28, 0x77, 0x42, 0x44, 0xd0, 0xed, 0xad, 0x52, 0xe8, 0x75,
	0x07, 0x68, 0x7b, 0x1c, 0x2b, 0x64, 0xb5, 0xb1, 0xba, 0x19, 0x2e, 0x47, 0xb2, 0x7e, 0x6d, 0x04,
	0x16, 0xfb, 0xef, 0xa0, 0xe4, 0xcb, 0xe6, 0x00, 0x5e, 0x38, 0x72, 0xcf, 0x3d, 0x7a, 0x0c, 0xbf,
	0x02, 0xf3, 0xab, 0xed, 0x88, 0x06, 0x9d, 0xc0, 0x93, 0x2e, 0xef, 0x6b, 0x7e, 0x28, 0xcd, 0xda,
	0xd0, 0xbe, 0x8c, 0xaa, 0x72, 0x71, 0x2f, 0x89, 0x46, 0x76, 0x1a, 0xab, 0x54, 0x0e, 0x64, 0x15,
	0xa6, 0x35, 0x78, 0xb3, 0xbb, 0x2b, 0x64, 0x06, 0x9c, 0xd0, 0x3a, 0xcf, 0x66, 0x57, 0xb7, 0xf9,
	0x49, 0x10, 0x2d, 0xfe, 0x62, 0x4e, 0x4c, 0x8b, 0xf3, 0x90, 0xab, 0x75, 0xb7, 0xc5, 0x74, 0xe0,
	0xca, 0x81, 0x71, 0x90, 0xb0, 0x52, 0xf2, 0x45, 0x00, 0x9b, 0x76, 0xfc, 0xd0, 0x8b, 0xfc, 0x60,
	0x5f, 0xf7, 0x9c, 0x08, 0x14, 0xd4, 0xb4, 0x11, 0x95, 0x50, 0xb2, 0x06, 0x33, 0xf1, 0xaf, 0xbb,
	0x8f, 0xdb, 0xe2, 0x32, 0x75, 0x9c, 0xdf, 0x62, 0xc4, 0xe4, 0x8e, 0xcf, 0xca, 0xf4, 0xa3, 0x31,
	0x41, 0x46, 0x96, 0xa0, 0xf0, 0xc0, 0x0f, 0x1e, 0xee, 0xb0, 0x81, 0xca, 0xc7, 0x87, 0xf7, 0x63,
	0x01, 0xd3, 0x0f, 0x29, 0x89, 0xc7, 0xe6, 0xfc, 0x6a, 0xfb, 0x91, 0x17, 0xf8, 0xed, 0x16, 0x6d,
	0x47, 0xfa, 0xbb, 0x27, 0x8d, 0xc1, 0x86, 0xcf, 0x5a, 0x0c, 0x66, 0xba, 0x7a, 0xb9, 0x1e, 0xf9,
	0x81, 0x78, 0xf4, 0xe4, 0xc3, 0xcd, 0x00, 0xc6, 0x70, 0x33, 0x00, 0xeb, 0x44, 0x9b, 0xee, 0x88,
	0xdb, 0x7a, 0xec, 0xc4, 0x80, 0xee, 0x18, 0x0e, 0x79, 0x74, 0x87, 0x09, 0x1f, 0x36, 0xdd, 0xc1,
	0x0b, 0x06, 0x23, 0x8e, 0xcd, 0x4e, 0xcf, 0xd5, 0x94, 0x40, 0xb3, 0x7e, 0x77, 0xbc, 0xef, 0xbc,
	0x65, 0xbb, 0xfd, 0xf1, 0xe6, 0xed, 0xba, 0x3b, 0xc4, 0xbc, 0x7d, 0x5d, 0x59, 0x9e, 0xea, 0x5e,
	0xa8, 0x08, 0xd1, 0x8f, 0x1b, 0x8e, 0xb3, 0xf8, 0x4b, 0x85, 0xe3, 0x4c, 0x22, 0xd1, 0x49, 0xd9,
	0x61, 0x3b, 0x29, 0x37, 0x54, 0x27, 0x91, 0x65, 0x98, 0x52, 0x91, 0x90, 0x36, 0xdd, 0xc8, 0xd8,
	0x9b, 0x54, 0xf8, 0x2a, 0xa7, 0xe3, 0x46, 0xfa, 0xde, 0x64, 0x92, 0x90, 0x77, 0x60, 0x42, 0x98,
	0x5f, 0x23, 0x87, 0x91, 0xd8, 0x00, 0x4e, 0xda, 0x6a, 0x27, 0xe8, 0x75, 0x74, 0xb6, 0x24, 0x37,
	0xbd, 0x0e, 0x6d, 0x7a, 0x6d, 0x5a, 0xc3, 0xdb, 0x7a, 0x31, 0x63, 0x70, 0x49, 0x76, 0x44, 0x89,
	0xc3, 0x2f, 0xf2, 0x8d, 0x7b, 0x3a, 0x83, 0x28, 0x39, 0x59, 0xc7, 0x8e, 0x35, 0x59, 0xb9, 0xfd,
	0x49, 0xb0, 0xee, 0xef, 0x7a, 0xd2, 0xe2, 0x4e, 0xda, 0x9f, 0x04, 0x4e, 0x93, 0x41, 0x13, 0xf6,
	0x27, 0x1c, 0x95, 0x69, 0x12, 0xec, 0x47, 0xb5, 0x22, 0x5e, 0x86, 0x50, 0x93, 0x40, 0x22, 0xd3,
	0xcc, 0x91, 0x23, 0xc9, 0x6a, 0x56, 0x5b, 0xae, 0xd7, 0x14, 0xce, 0x86, 0x71, 0x35, 0x94, 0x41,
	0x93, 0xd5, 0x20, 0x2a, 0xa9, 0xc3, 0xa4, 0x4d, 0x77, 0x36, 0x03, 0x3f, 0xa2, 0xf5, 0x88, 0x36,
	0x84, 0xf4, 0x24, 0x15, 0x88, 0x65, 0xdf, 0xe7, 0x92, 0xe1, 0xf2, 0x1b, 0xbf, 0x7b, 0x50, 0xca,
	0x7c, 0xe7, 0xa0, 0x04, 0x0c, 0xc4, 0x6d, 0x68, 0x0f, 0x0f, 0x4a, 0xa7, 0xd8, 0xf8, 0x77, 0x24,
	0xb1, 0x7e, 0xc4, 0xe8, 0x4c, 0xc9, 0xf7, 0xb2, 0x4d, 0x57, 0x75, 0x49, 0x5c, 0xd9, 0x64, 0x9f,
	0xca, 0xde, 0x4c, 0xad, 0xac, 0xa4, 0xf5, 0x76, 0x6a, 0xa5, 0xa9, 0x95, 0x90, 0x77, 0x61, 0x62,
	0xa5, 0xba, 0xe2, 0xb7, 0x77, 0xbc, 0xdd, 0xda, 0x5a, 0x19, 0x45, 0x30, 0x61, 0x3f, 0x5d, 0xf7,
	0x9c, 0x3a, 0xc2, 0x9d, 0x70, 0xcf, 0x35, 0xdc, 0x68, 0x62, 0x7c, 0x72, 0x13, 0xa6, 0xe5, 0x4f,
	0x9b, 0xee, 0xdc, 0xb3, 0xab, 0x28, 0x79, 0x49, 0xa3, 0x75, 0xc5, 0x81, 0x75, 0x44, 0x37, 0xd0,
	0x25, 0xf2, 0x04, 0x19, 0x9b, 0x8c, 0x15, 0xda, 0x69, 0xfa, 0xfb, 0xac, 0x79, 0x5b, 0x1e, 0x0d,
	0x50, 0xd6, 0x12, 0x93, 0xb1, 0xa1, 0x4a, 0x9c, 0xc8, 0x33, 0xb6, 0xdb, 0x04, 0x11, 0xd9, 0x80,
	0x59, 0x31, 0xc5, 0xef, 0x7b, 0xa1, 0xb7, 0xed, 0x35, 0xbd, 0x68, 0x1f, 0xa5, 0x2c, 0x21, 0x85,
	0xc8, 0x75, 0xf1, 0x48, 0x95, 0x6a, 0xcc, 0x7a, 0x49, 0xad, 0x5f, 0xc9, 0xc2, 0x0b, 0x83, 0x34,
	0x0e, 0x52, 0x33, 0x37, 0xb3, 0x8b, 0x43, 0x68, 0x29, 0x47, 0x6f, 0x67, 0xab, 0x30, 0x7d, 0x37,
	0xd8, 0x75, 0xdb, 0xde, 0xb7, 0x51, 0x93, 0x54, 0x66, 0x38, 0xd8, 0x19, 0xbe, 0x56, 0x62, 0xce,
	0xf6, 0x04, 0xd1, 0xe2, 0x23, 0xb1, 0xcd, 0x7d, 0x5c, 0x87, 0x8e, 0xeb, 0x30, 0xbe, 0xe2, 0xb7,
	0x23, 0xfa, 0x24, 0x4a, 0xf8, 0x1d, 0x72, 0x60, 0xd2, 0x99, 0x45, 0xa2, 0x5a, 0xff, 0x6f, 0x16,
	0xce, 0x0c, 0x14, 0xb9, 0xc9, 0x96, 0xd9, 0x6b, 0x97, 0x86, 0x91, 0xd3, 0x8f, 0xee, 0xb6, 0xa5,
	0x1e, 0x8b, 0x91, 0x23, 0xed, 0xa5, 0x17, 0xff, 0x9b, 0x8c, 0xe8, 0xa4, 0xcf, 0xc1, 0x18, 0x56,
	0xa5, 0xba, 0x88, 0xdf, 0x46, 0xe1, 0x2e, 0xec, 0x99, 0xb7, 0x51, 0x1c, 0x8d, 0x5c, 0x83, 0xc2,
	0x8a, 0xdb, 0x6c, 0x6a, 0x5e, 0x99, 0xa8, 0x49, 0xd4, 0x11, 0x96, 0x30, 0x30, 0x92, 0x88, 0xe4,
	0x2d, 0x00, 0xfe, 0xb7, 0x76, 0x56, 0xe0, 0x66, 0x29, 0xc8, 0x12, 0xc7, 0x85, 0x86, 0x8c, 0xb1,
	0xdc, 0xea, 0xbe, 0x72, 0x1f, 0xe3, 0xb1, 0xdc, 0x18, 0xc0, 0x88, 0xe5, 0xc6, 0x00, 0xd6, 0xaf,
	0xe6, 0xe0, 0xec, 0x60, 0xbd, 0x91, 0xdc, 0x33, 0x87, 0xe0, 0xd5, 0xa1, 0xb4, 0xcd, 0xa3, 0xc7,
	0x40, 0x46, 0x46, 0xe4, 0x1d, 0x72, 0xb1, 0xd7, 0xac, 0xf9, 0xbb, 0x07, 0x25, 0xcd, 0x6a, 0xed,
	0x96, 0xef, 0xb5, 0xb5, 0xb7, 0x89, 0x6f, 0x01, 0xd4, 0x22, 0x37, 0xf2, 0xea, 0xb7, 0x1e, 0xdc,
	0x96, 0x81, 0x03, 0xae, 0x0f, 0xd7, 0xb2, 0x98, 0x8e, 0xef, 0x2b, 0xc2, 0xa3, 0x02, 0xa1, 0xce,
	0x47, 0x8f, 0x1f, 0x1a, 0x9a, 0x71, 0x8c, 0xbc, 0xf8, 0x25, 0x28, 0x26, 0x49, 0xc9, 0x05, 0xc8,
	0x63, 0x03, 0x34, 0xdb, 0xec, 0x04, 0x07, 0x2c, 0x5f, 0xbc, 0x23, 0xe6, 0xce, 0x2a, 0x4c, 0x8b,
	0x07, 0x71, 0xf3, 0x0e, 0x0e, 0xd7, 0xab, 0x7c, 0x4f, 0xef, 0xbd, 0x87, 0x4b, 0x10, 0x59, 0x7f,
	0x96, 0x81, 0xd3, 0x7d, 0x35, 0x72, 0xb2, 0x69, 0x0e, 0xd8, 0xcb, 0x47, 0xa9, 0xf0, 0x47, 0x8e,
	0xd5, 0xe2, 0x8f, 0xca, 0xb9, 0xff, 0x1e, 0x4c, 0xd6, 0xba, 0xdb, 0x49, 0x25, 0x8b, 0xbb, 0x91,
	0x6b, 0x70, 0xfd, 0x04, 0xd3, 0xf1, 0xd9, 0xf7, 0xcb, 0x17, 0x7f, 0x61, 0xd0, 0xc1, 0x15, 0x3f,
	0xfc, 0x7e, 0xe5, 0x90, 0x85, 0x2e, 0x7f, 0x7a, 0x27, 0x26, 0x88, 0xac, 0x5f, 0xce, 0xa6, 0x6b,
	0xab, 0x4c, 0xbb, 0x3f, 0x86, 0xb6, 0x7a, 0x73, 0x65, 0xf3, 0xe8, 0x6f, 0xff, 0xcf, 0xe4, 0xb7,
	0xe3, 0x03, 0xa8, 0xd8, 0xf1, 0xe4, 0x85, 0xa2, 0x78, 0x00, 0x95, 0xbb, 0x63, 0x68, 0x3e, 0x80,
	0x4a, 0x64, 0xf2, 0x26, 0x8c, 0xaf, 0xfb, 0xdc, 0x15, 0x57, 0x7e, 0x31, 0xf7, 0x58, 0x92, 0x40,
	0x7d, 0x7b, 0x54, 0x98, 0x4c, 0xb7, 0x30, 0x07, 0x5e, 0x9a, 0x95, 0xa3, 0x6e, 0x91, 0x98, 0x2e,
	0xe6, 0xb5, 0x9b, 0x49, 0x66, 0xfd, 0x59, 0x1e, 0xac, 0xa3, 0x2f, 0x0d, 0xc8, 0x87, 0x66, 0xdf,
	0x5d, 0x1e, 0xfa, 0xba, 0x61, 0xa8, 0x2d, 0xb7, 0xdc, 0x6d, 0x78, 0xb4, 0x5d, 0x37, 0xfd, 0x68,
	0x05, 0x4c, 0xdf, 0x02, 0x25, 0xde, 0xe2, 0x7f, 0x91, 0x8b, 0x97, 0x4d, 0xe2, 0x98, 0xcb, 0x7c,
	0x8c, 0x63, 0x8e, 0xdc, 0x86, 0xa2, 0x0e, 0xd1, 0x5e, 0x35, 0x51, 0x0a, 0x31, 0x18, 0x25, 0xce,
	0x81, 0x1e, 0x42, 0xf3, 0xac, 0xcc, 0x0d, 0x7f, 0x56, 0xc6, 0xa2, 0x38, 0xd6, 0x9f, 0xef, 0x15,
	0xc5, 0x93, 0x6e, 0x68, 0x1a, 0xba, 0xf4, 0xa1, 0x0d, 0xc5, 0x01, 0x34, 0x62, 0xfa, 0xd0, 0xa6,
	0x1c, 0x42, 0x3a, 0xba, 0x74, 0x03, 0xc6, 0x9f, 0x9a, 0x17, 0x9c, 0x72, 0x03, 0xe6, 0xf4, 0x69,
	0x6e, 0xc0, 0x8a, 0x84, 0x1d, 0x66, 0x76, 0xb7, 0xcd, 0x03, 0x80, 0x8e, 0xc5, 0x87, 0x59, 0xd0,
	0x6d, 0x3b, 0xc9, 0x20, 0xa0, 0x0a, 0xd1, 0xfa, 0xd1, 0x2c, 0x4c, 0xf3, 0xcd, 0x93, 0x3f, 0x4b,
	0x3c, 0xb3, 0x4f, 0x3e, 0x6f, 0x1b, 0x4f, 0x3e, 0x32, 0xe2, 0x89, 0xfe, 0x69, 0x43, 0x3d, 0xf8,
	0xec, 0x01, 0xe9, 0xa5, 0x21, 0x36, 0x4c, 0xea, 0xd0, 0xc1, 0x6f, 0x3d, 0x57, 0xe3, 0xe0, 0x38,
	0xe2, 0xec, 0xc2, 0x07, 0xb7, 0xd0, 0x36, 0x78, 0x58, 0x7f, 0x3d, 0x0b, 0x53, 0xda, 0x03, 0xfd,
	0x33, 0xdb, 0xf1, 0x5f, 0x32, 0x3a, 0x7e, 0x41, 0x99, 0xe2, 0xab, 0x2f, 0x1b, 0xaa, 0xdf, 0xbb,
	0x30, 0xdb, 0x43, 0x92, 0xb4, 0x73, 0xc8, 0x0c, 0x63, 0xe7, 0xf0, 0x7a, 0x6f, 0xa4, 0x0d, 0x1e,
	0xb0, 0x56, 0xb9, 0x6f, 0xeb, 0xa1, 0x3d, 0x7e, 0x3c, 0x0b, 0xf3, 0xe2, 0x17, 0x86, 0xa6, 0xe2,
	0xd2, 0xc3, 0x33, 0x3b, 0x16, 0x65, 0x63, 0x2c, 0x4a, 0xe6, 0x58, 0x68, 0x1f, 0xd8, 0x7f, 0x48,
	0xac, 0x1f, 0x04, 0x58, 0xe8, 0x47, 0x30, 0xb4, 0xc7, 0x5b, 0xec, 0x4f, 0x90, 0x1d, 0xc2, 0x9f,
	0x60, 0x1d, 0x8a, 0x58, 0x95, 0x08, 0x3e, 0x13, 0x32, 0x1d, 0x34, 0x17, 0x2b, 0x7c, 0x3c, 0x7e,
	0x98, 0x08, 0x86, 0x13, 0x26, 0x94, 0xd0, 0x1e, 0x4a, 0xf2, 0x8b, 0x19, 0x98, 0x46, 0xe0, 0xea,
	0x23, 0xda, 0x8e, 0x90, 0x59, 0x5e, 0x98, 0xbf, 0xab, 0x17, 0xa1, 0x5a, 0x14, 0x78, 0xed, 0x5d,
	0xf1, 0x24, 0xb4, 0x2d, 0x9e, 0x84, 0xde, 0xe1, 0x4f, 0x59, 0x97, 0xeb, 0x7e, 0xeb, 0xca, 0x6e,
	0xe0, 0x3e, 0xf2, 0xb8, 0xed, 0x89, 0xdb, 0xbc, 0x12, 0xc7, 0x4b, 0xef, 0x78, 0x89, 0x08, 0xe8,
	0x82, 0x15, 0x3e, 0xb7, 0xf1, 0x86, 0x52, 0xac, 0x36, 0xa9, 0x2b, 0x9b, 0x2d, 0x22, 0xdf, 0x03,
	0xa7, 0x78, 0x64, 0x09, 0xa6, 0x72, 0x79, 0xed, 0xae, 0xdf, 0x0d, 0x97, 0xdd, 0xfa, 0x43, 0x26,
	0x77, 0x71, 0x17, 0x1e, 0xfc, 0xf2, 0xba, 0x2a, 0x74, 0xb6, 0x79, 0xa9, 0xe1, 0xb2, 0x98, 0xce,
	0x80, 0xac, 0xc1, 0x2c, 0x2f, 0x2a, 0x77, 0x23, 0xbf, 0x56, 0x77, 0x9b, 0x5e, 0x7b, 0x17, 0x0f,
	0x84, 0x02, 0x3f, 0x8f, 0xdc, 0x6e, 0xe4, 0x3b, 0x21, 0x87, 0xeb, 0xaa, 0x73, 0x0f, 0x11, 0xa9,
	0xc2, 0x8c, 0x4d, 0xdd, 0xc6, 0x1d, 0xf7, 0xc9, 0x8a, 0xdb, 0x71, 0xeb, 0x4c, 0x11, 0x2f, 0xe0,
	0xf3, 0x29, 0x9e, 0xca, 0x01, 0x75, 0x1b, 0x4e, 0xcb, 0x7d, 0xe2, 0xd4, 0x45, 0xa1, 0x79, 0x87,
	0x6a, 0xd0, 0x29, 0x56, 0x5e, 0x5b, 0xb1, 0x1a, 0x4f, 0xb2, 0xf2, 0xda, 0xfd, 0x59, 0xc5, 0x74,
	0x92, 0xd5, 0x96, 0x1b, 0xec, 0xd2, 0x88, 0x9b, 0x6e, 0xc2, 0xb9, 0xcc, 0xc5, 0x8c, 0xc6, 0x2a,
	0xc2, 0x32, 0x07, 0xcd, 0x38, 0x93, 0xac, 0x34, 0x3a, 0x36, 0xf3, 0x1e, 0x04, 0x5e, 0x44, 0xf5,
	0x2f, 0x9c, 0xc0, 0x66, 0x61, 0xff, 0xa3, 0xd1, 0x6b, 0xbf, 0x4f, 0xec, 0xa1, 0x8c, 0xb9, 0x69,
	0x1f, 0x39, 0xd9, 0xc3, 0x2d, 0xfd, 0x2b, 0x7b, 0x28, 0x15, 0x37, 0xfd, 0x3b, 0xa7, 0xf0, 0x3b,
	0x35, 0x6e, 0x7d, 0x3e, 0xb4, 0x87, 0x92, 0x6c, 0xb0, 0x4e, 0x8b, 0x68, 0x9b, 0xcd, 0x68, 0x61,
	0xba, 0x3a, 0x8d, 0x4d, 0x7b, 0x49, 0xd8, 0x5f, 0x15, 0x03, 0x59, 0xec, 0xa4, 0x18, 0xb2, 0x26,
	0x89, 0xc9, 0x5f, 0x82, 0x99, 0x7b, 0x21, 0xbd, 0x51, 0xdd, 0xac, 0xc9, 0x40, 0x14, 0x78, 0xdb,
	0x33, 0xbd, 0x74, 0xf5, 0x88, 0x4d, 0xe7, 0xb2, 0x4e, 0x83, 0x61, 0xcb, 0xf9, 0xb8, 0x75, 0x43,
	0xea, 0xec, 0x78, 0x9d, 0x50, 0x45, 0xf5, 0xd1, 0xc7, 0x2d, 0x51, 0x95, 0xb5, 0x06, 0xb3, 0x3d,
	0x6c, 0xc8, 0x34, 0x00, 0x03, 0x3a, 0xf7, 0x36, 0x6a, 0xab, 0x5b, 0xc5, 0xe7, 0x48, 0x11, 0x26,
	0xf1, 0xf7, 0xea, 0x46, 0x79, 0x79, 0x7d, 0xb5, 0x52, 0xcc, 0x90, 0x59, 0x98, 0x42, 0x48, 0xa5,
	0x5a, 0xe3, 0xa0, 0x2c, 0x0f, 0x5a, 0x6b, 0x17, 0xf9, 0xd2, 0x8d, 0xd8, 0x02, 0xc0, 0x33, 0xc5,
	0xfa, 0x5b, 0x59, 0x38, 0x2d, 0x8f, 0x15, 0x1a, 0x31, 0x11, 0xcc, 0x6b, 0xef, 0x3e, 0xe3, 0xa7,
	0xc3, 0x0d, 0xe3, 0x74, 0x78, 0x29, 0x71, 0x52, 0x27, 0xbe, 0x72, 0xc0, 0x11, 0xf1, 0x9b, 0xe3,
	0x70, 0x66, 0x20, 0x15, 0xf9, 0x32, 0x3b, 0xcd, 0x3d, 0xda, 0x8e, 0xaa, 0x8d, 0x26, 0xdd, 0xf2,
	0x5a, 0xd4, 0xef, 0x46, 0xc2, 0x54, 0xfa, 0x3c, 0x5e, 0xb0, 0x60, 0xa1, 0xe3, 0x35, 0x9a, 0xd4,
	0x89, 0x78, 0xb1, 0x31, 0xdd, 0x7a, 0xa9, 0x19, 0x4b, 0x95, 0x42, 0xa1, 0xda, 0x8e, 0x68, 0xf0,
	0x08, 0xcd, 0xb1, 0x14, 0xcb, 0x87, 0x94, 0x76, 0x1c, 0x97, 0x95, 0x3a, 0x9e, 0x28, 0x36, 0x59,
	0xf6, 0x50, 0x93, 0x1b, 0x1a, 0xcb, 0x15, 0xa6, 0x8e, 0xdd, 0x71, 0x9f, 0x08, 0xfb, 0x10, 0x11,
	0x91, 0x4c, 0xb1, 0xe4, 0x5e, 0x76, 0x2d, 0xf7, 0x89, 0xdd, 0x4b, 0x42, 0xbe, 0x0e, 0x27, 0xc4,
	0x01, 0x24, 0xbc, 0xa4, 0xe5, 0x17, 0x73, 0x1f, 0xec, 0x57, 0x0e, 0x0f, 0x4a, 0xa7, 0x64, 0x2c,
	0x37, 0xe9, 0x17, 0x9f, 0xf6, 0xd5, 0xe9, 0x5c, 0xc8, 0x16, 0x3b, 0x90, 0x13, 0xdd, 0x71, 0x87,
	0x86, 0xa1, 0xbb, 0x2b, 0x6d, 0x49, 0xb8, 0x5f, 0x89, 0xd6, 0x99, 0x4e, 0x8b, 0x97, 0xdb, 0x7d,
	0x29, 0xc9, 0x1a, 0x4c, 0x3f, 0xa0, 0xdb, 0xfa, 0xf8, 0x8c, 0xaa, 0xad, 0xaa, 0xf8, 0x98, 0x6e,
	0xf7, 0x1f, 0x9c, 0x04, 0x1d, 0xf1, 0xf0, 0xc2, 0xf6, 0xc9, 0xfe, 0xba, 0x17, 0x46, 0xb4, 0x4d,
	0x03, 0x8c, 0xbe, 0x31, 0x86, 0x9b, 0xc1, 0x42, 0x2c, 0x21, 0x9b, 0xe5, 0xcb, 0x2f, 0x1e, 0x1e,
	0x94, 0xce, 0x70, 0x3f, 0xaa, 0xa6, 0x80, 0x3b, 0x89, 0x04, 0x04, 0xbd, 0x5c, 0xc9, 0x37, 0x61,
	0xc6, 0xf6, 0xbb, 0x91, 0xd7, 0xde, 0xad, 0x45, 0x81, 0x1b, 0xd1, 0x5d, 0x7e, 0x20, 0xc5, 0x61,
	0x3e, 0x12, 0xa5, 0xe2, 0xad, 0x8f, 0x03, 0x9d, 0x50, 0x40, 0x8d, 0x13, 0xc1, 0x24, 0x20, 0xdf,
	0x80, 0x69, 0xee, 0x1f, 0xab, 0x2a, 0x18, 0x37, 0x82, 0x27, 0x9b, 0x85, 0xf7, 0xaf, 0x8a, 0xe7,
	0x7c, 0x84, 0xa6, 0x55, 0x90, 0xe0, 0x46, 0xbe, 0x2a, 0x3a, 0x6b, 0xd3, 0x6b, 0xef, 0xaa, 0x69,
	0x0c, 0xd8, 0xf3, 0x6f, 0xc4, 0x5d, 0xd2, 0x61, 0xcd, 0x95, 0xd3, 0xb8, 0x8f, 0x6d, 0x52, 0x2f,
	0x1f, 0x12, 0xc1, 0x99, 0x72, 0x18, 0x7a, 0x61, 0x24, 0x1c, 0x0a, 0x56, 0x9f, 0xd0, 0x7a, 0x97,
	0x21, 0x33, 0x45, 0x91, 0x06, 0xdc, 0xa0, 0x75, 0x64, 0xf9, 0xf2, 0xe1, 0x41, 0xe9, 0x55, 0x17,
	0x11, 0x1d, 0xe1, 0x83, 0xe0, 0x50, 0x89, 0xea, 0x3c, 0xe6, 0xb8, 0xda, 0x37, 0x0c, 0x66, 0x4a,
	0xbe, 0x01, 0x27, 0x57, 0xdc, 0x90, 0x56, 0xdb, 0x21, 0x6d, 0x87, 0x5e, 0xe4, 0x3d, 0xa2, 0xa2,
	0x53, 0xf1, 0xf0, 0x2b, 0x60, 0xaa, 0x06, 0xab, 0xee, 0x86, 0x6c, 0x61, 0x2a, 0x14, 0x47, 0x0c,
	0x8a, 0x56, 0x4d, 0x1f, 0x2e, 0xc4, 0x86, 0xe9, 0x5a, 0x6d, 0xad, 0xe2, 0xb9, 0x6a, 0x5d, 0x4d,
	0x61, 0x7f, 0xbd, 0x8a, 0x77, 0x2d, 0xe1, 0x9e, 0xd3, 0xf0, 0x5c, 0xb5, 0xa0, 0xfa, 0x74, 0x56,
	0x82, 0x83, 0x75, 0x90, 0x81, 0x62, 0x72, 0x28, 0xc9, 0x57, 0x60, 0x9c, 0x1b, 0xf6, 0xd0, 0x70,
	0x4f, 0xb8, 0x8b, 0x4a, 0x3b, 0x11, 0x05, 0x37, 0x89, 0x84, 0x83, 0x0f, 0x37, 0x1b, 0xa2, 0xba,
	0x0d, 0x02, 0x3a, 0xf8, 0x48, 0x22, 0xd2, 0x80, 0x49, 0x3e, 0x5a, 0x14, 0x63, 0xfc, 0x08, 0xfb,
	0xce, 0x17, 0xf5, 0xd5, 0x21, 0x8a, 0x12, 0xfc, 0xf1, 0x19, 0x47, 0xcc, 0x09, 0x8e, 0x60, 0x54,
	0x61, 0x70, 0x5d, 0x06, 0x28, 0x48, 0x42, 0xeb, 0x34, 0x9c, 0xea, 0xd3, 0x66, 0xeb, 0x11, 0x3e,
	0xed, 0xf6, 0xa9, 0x91, 0x7c, 0x05, 0xe6, 0x91, 0x70, 0xc5, 0x6f, 0xb7, 0x69, 0x3d, 0xc2, 0xed,
	0x48, 0x5e, 0x87, 0xe6, 0xb8, 0xfd, 0x00, 0xff, 0xde, 0xba, 0x42, 0x70, 0x92, 0xb7, 0xa2, 0xa9,
	0x1c, 0xac, 0x9f, 0xc9, 0xc2, 0x82, 0xd8, 0xe1, 0x6c, 0x5a, 0xf7, 0x83, 0xc6, 0xb3, 0x7f, 0xa2,
	0xae, 0x1a, 0x27, 0xea, 0x79, 0x15, 0x1f, 0x20, 0xed, 0x23, 0x07, 0x1c, 0xa8, 0xbf, 0x9c, 0x81,
	0x17, 0x06, 0x11, 0xb1, 0xde, 0x51, 0x31, 0x8d, 0xc6, 0x7b, 0x62, 0x17, 0x75, 0x60, 0x0e, 0x07,
	0x74, 0x65, 0x8f, 0xd6, 0x1f, 0x86, 0x6b, 0x7e, 0x18, 0xa1, 0x89, 0x79, 0xb6, 0xcf, 0xe3, 0xe3,
	0xeb, 0xa9, 0x8f, 0x8f, 0x27, 0xf9, 0x2c, 0xab, 0x23, 0x0f, 0x1e, 0x75, 0xe9, 0x21, 0xdd, 0x0f,
	0xed, 0x34, 0xd6, 0x68, 0x2a, 0x5c, 0xee, 0x46, 0x7b, 0x9b, 0x01, 0xdd, 0xa1, 0x01, 0x6d, 0xd7,
	0xe9, 0x67, 0xcc, 0x54, 0xd8, 0xfc, 0xb8, 0xa1, 0x6e, 0x30, 0xfe, 0x8d, 0x29, 0x98, 0x4f, 0x23,
	0x63, 0xfd, 0xa2, 0x29, 0xcd, 0xc9, 0x4c, 0x52, 0x7f, 0x35, 0x03, 0x93, 0x35, 0x5a, 0xf7, 0xdb,
	0x8d, 0x1b, 0x68, 0xe2, 0x21, 0x7a, 0xc7, 0xe1, 0x42, 0x03, 0x83, 0x3b, 0x3b, 0x09, 0xdb, 0x8f,
	0xef, 0x1e, 0x94, 0x3e, 0x18, 0x4e, 0x57, 0xad, 0xfb, 0xe8, 0xe3, 0x1f, 0x61, 0xa4, 0x63, 0x55,
	0x05, 0xbe, 0xd6, 0x18, 0x95, 0x92, 0x65, 0x98, 0x12, 0xcb, 0xd5, 0xd7, 0x43, 0x5a, 0xf1, 0x10,
	0x0a, 0xb2, 0xa0, 0xe7, 0xfe, 0xd1, 0x20, 0x21, 0xd7, 0x20, 0x77, 0x6f, 0xe9, 0x86, 0x18, 0x03,
	0x19, 0x2b, 0xfa, 0xde, 0xd2, 0x0d, 0xbc, 0x0e, 0x63, 0x2a, 0xc6, 0x54, 0x77, 0xc9, 0xb0, 0xba,
	0xb8, 0xb7, 0x74, 0x83, 0xfc, 0x15, 0x38, 0x51, 0xf1, 0x42, 0x51, 0x05, 0x37, 0x5a, 0x6f, 0xa0,
	0xab, 0xd6, 0x68, 0x9f, 0xd9, 0xfb, 0x85, 0xd4, 0xd9, 0xfb, 0x62, 0x43, 0x31, 0x71, 0xb8, 0x45,
	0x7c, 0x23, 0x19, 0xba, 0x2b, 0xbd, 0x1e, 0xf2, 0x11, 0x4c, 0xe3, 0x3d, 0x38, 0xda, 0xf1, 0x63,
	0xb4, 0xd4, 0xb1, 0x3e, 0x35, 0x7f, 0x2e, 0xb5, 0xe6, 0x45, 0xbc, 0x56, 0x77, 0xd0, 0x1b, 0x00,
	0x23, 0xab, 0x1a, 0x5a, 0xbf, 0xc1, 0x99, 0xdc, 0x82, 0x19, 0x21, 0x7e, 0xdd, 0xdd, 0xd9, 0xda,
	0xa3, 0x15, 0x77, 0x5f, 0x18, 0x4c, 0xa0, 0x46, 0x27, 0x64, 0x36, 0xc7, 0xdf, 0x71, 0xa2, 0x3d,
	0xea, 0x34, 0x5c, 0x43, 0x50, 0x49, 0x10, 0x92, 0xef, 0x85, 0x89, 0x75, 0xbf, 0xce, 0x24, 0x6f,
	0xdc, 0x19, 0xb8, 0x0d, 0xc5, 0x87, 0x98, 0xab, 0x88, 0x83, 0x13, 0xe2, 0xd4, 0x77, 0x0f, 0x4a,
	0x6f, 0x1f, 0x77, 0xd2, 0x68, 0x15, 0xd8, 0x7a, 0x6d, 0x64, 0x05, 0x0a, 0x0f, 0xe8, 0x36, 0xfb,
	0xda, 0x64, 0x1e, 0x13, 0x09, 0x16, 0x26, 0x52, 0xe2, 0x97, 0x61, 0x22, 0x25, 0x60, 0x24, 0x80,
	0x59, 0xec, 0x9f, 0x4d, 0x37, 0x0c, 0x1f, 0xfb, 0x41, 0x03, 0x03, 0x56, 0xf7, 0x33, 0xcf, 0x58,
	0x4a, 0xed, 0xfc, 0x17, 0x78, 0xe7, 0x77, 0x34, 0x0e, 0xba, 0x00, 0xd9, 0xc3, 0x9e, 0x7c, 0x13,
	0xa6, 0x6d, 0xfa, 0xad, 0xae, 0x17, 0xd0, 0x3b, 0x37, 0xca, 0xb8, 0x2a, 0x27, 0x0d, 0x87, 0x37,
	0xb3, 0x90, 0x4b, 0xa9, 0x01, 0x87, 0xc9, 0x1b, 0x28, 0xa7, 0xb5, 0xe3, 0x9a, 0x2f, 0x60, 0x3a,
	0x09, 0xd9, 0x84, 0x89, 0x0a, 0x7d, 0xe4, 0xd5, 0x29, 0x3a, 0xe5, 0x08, 0x83, 0x58, 0x95, 0x88,
	0x21, 0x2e, 0xe1, 0x77, 0x31, 0x0d, 0x04, 0x70, 0x17, 0x1f, 0xd3, 0x02, 0x52, 0x21, 0x92, 0xeb,
	0x90, 0xab, 0x56, 0x36, 0x85, 0x3d, 0xac, 0xf4, 0x73, 0xa9, 0x36, 0x36, 0x65, 0xd8, 0x7a, 0x34,
	0x68, 0xf2, 0x1a, 0x86, 0x35, 0x6d, 0xb5, 0xb2, 0x49, 0x76, 0x60, 0x0a, 0x3b, 0x60, 0x8d, 0xba,
	0xbc, 0x6f, 0x67, 0xfa, 0xf4, 0xed, 0xe5, 0xd4, 0xbe, 0x5d, 0xe0, 0x7d, 0xbb, 0x27, 0xa8, 0x8d,
	0x38, 0xdc, 0x3a, 0x5b, 0x26, 0xd2, 0x8a, 0xdc, 0x00, 0x32, 0x7a, 0xf4, 0xd6, 0x3a, 0x1a, 0x6c,
	0x08, 0x91, 0x56, 0xa6, 0x12, 0x50, 0xe1, 0xac, 0xfb, 0x9a, 0xdb, 0xf7, 0xf2, 0x21, 0x5f, 0x82,
	0xfc, 0xdd, 0x87, 0x91, 0xbb, 0x30, 0x6b, 0xf4, 0x23, 0x03, 0xc9, 0xcf, 0xc7, 0x5b, 0x48, 0xff,
	0xa1, 0x11, 0xdc, 0x05, 0x69, 0xc8, 0x12, 0x8c, 0x6d, 0x56, 0xef, 0xd7, 0x9a, 0x7e, 0xb4, 0x40,
	0x94, 0x9e, 0x44, 0x3a, 0xde, 0x23, 0x27, 0x6c, 0xfa, 0x66, 0x7e, 0x11, 0x89, 0xc8, 0x86, 0x6f,
	0xcd, 0x0d, 0x1a, 0x8f, 0xdd, 0x00, 0xbd, 0x29, 0xe7, 0x8c, 0x6a, 0xb5, 0x12, 0x3e, 0x7c, 0x7b,
	0x02, 0x90, 0x70, 0xb1, 0xd4, 0x59, 0x90, 0xef, 0x81, 0xd3, 0xa1, 0xb7, 0xdb, 0x76, 0xa3, 0x6e,
	0x40, 0x1d, 0xb7, 0xb9, 0xeb, 0x07, 0x5e, 0xb4, 0xd7, 0x72, 0xc2, 0xae, 0x17, 0xd1, 0x85, 0x79,
	0x23, 0xfb, 0x60, 0x4d, 0xe2, 0x95, 0x25, 0x5a, 0x8d, 0x61, 0xd9, 0xa7, 0xc2, 0xf4, 0x02, 0x71,
	0x7b, 0x31, 0x2b, 0xa6, 0xa0, 0xe8, 0xb6, 0x3b, 0x37, 0xca, 0xd6, 0x7f, 0x92, 0xc1, 0xcd, 0x98,
	0xbc, 0x8a, 0xb1, 0x25, 0xd4, 0xb3, 0x1c, 0xde, 0xc3, 0xba, 0x9d, 0x44, 0x34, 0x57, 0x8e, 0x42,
	0x5e, 0x87, 0xd1, 0x1b, 0x6e, 0x9d, 0x46, 0xf2, 0x21, 0x14, 0x91, 0x77, 0x10, 0xa2, 0x5f, 0xda,
	0x72, 0x1c, 0x26, 0x27, 0xf2, 0x49, 0x5a, 0x8e, 0x93, 0x46, 0xae, 0x94, 0xe5, 0x3b, 0x28, 0xca,
	0x89, 0x62, 0x72, 0x6b, 0x59, 0x25, 0x13, 0x36, 0xc3, 0xa9, 0x1c, 0xac, 0x3f, 0xc9, 0xc4, 0xbb,
	0x0b, 0x79, 0x05, 0xf2, 0xf6, 0xa6, 0x6a, 0x3f, 0xf7, 0x5a, 0x4c, 0x34, 0x1f, 0x11, 0xc8, 0x57,
	0xe1, 0x84, 0xc6, 0xa7, 0xc7, 0x80, 0xf9, 0x65, 0x74, 0xaa, 0xd3, 0x5a, 0x92, 0x6e, 0xc5, 0x9c,
	0xce, 0x03, 0x85, 0xe2, 0xb8, 0xa0, 0x42, 0xdb, 0x1e, 0xe7, 0xad, 0x7d, 0xac, 0xce, 0xbb, 0x81,
	0x08, 0xc9, 0x8f, 0x4d, 0xe3, 0xc0, 0x7d, 0xea, 0xac, 0xdf, 0xc8, 0x18, 0xbb, 0x86, 0xca, 0xce,
	0x97, 0x39, 0x22, 0x3b, 0xdf, 0x5b, 0x00, 0xe5, 0x6e, 0xe4, 0xaf, 0xb6, 0x03, 0xbf, 0xc9, 0x6f,
	0x43, 0x44, 0x40, 0x63, 0xbc, 0xe3, 0xa5, 0x08, 0x36, 0x5c, 0x7f, 0x14, 0x72, 0xaa, 0xad, 0x77,
	0xee, 0xe3, 0xda, 0x7a, 0x5b, 0xbf, 0x97, 0x31, 0xd6, 0x0d, 0x93, 0xf6, 0xe4, 0xd2, 0xd3, 0x4c,
	0x71, 0x7a, 0x97, 0x5e, 0xbc, 0xf0, 0xfe, 0xff, 0x19, 0x38, 0xc9, 0x8d, 0xa6, 0x37, 0xba, 0xad,
	0x6d, 0x1a, 0xdc, 0x77, 0x9b, 0x5e, 0x83, 0x7b, 0x8e, 0x72, 0x41, 0xf6, 0x62, 0xef, 0x22, 0x4c,
	0xc7, 0xe7, 0x0a, 0x27, 0x37, 0xe2, 0x76, 0xda, 0x58, 0xe8, 0x3c, 0x52, 0xa5, 0xba, 0xc2, 0x99,
	0x4e, 0x6f, 0xfd, 0x4a, 0x06, 0x5e, 0x3c, 0xb2, 0x16, 0x72, 0x05, 0xc6, 0x64, 0x24, 0xe9, 0x0c,
	0x76, 0x3c, 0x1a, 0x30, 0xf6, 0x46, 0x91, 0x96, 0x58, 0xe4, 0x6b, 0x70, 0x42, 0x67, 0xb5, 0x15,
	0xb8, 0x9e, 0x1e, 0xaf, 0x39, 0xa5, 0xd5, 0x11, 0x43, 0x49, 0x4a, 0x5d, 0xe9, 0x4c, 0xac, 0xff,
	0x27, 0xa3, 0xe5, 0xeb, 0x7c, 0x46, 0x65, 0xf1, 0xeb, 0x86, 0x2c, 0x2e, 0xa3, 0x7a, 0xa9, 0xaf,
	0x62, 0x65, 0xa9, 0xfa, 0xd3, 0x8c, 0x66, 0x88, 0x8b, 0x80, 0x1f, 0xce, 0xc2, 0xc4, 0xbd, 0x90,
	0x06, 0xfc, 0x41, 0xf6, 0xb3, 0x15, 0xbd, 0x49, 0x7d, 0xd7, 0x50, 0xf1, 0x75, 0xfe, 0x28, 0x83,
	0x17, 0xf5, 0x3a, 0x05, 0xeb, 0x0d, 0x2d, 0x47, 0x0f, 0xf6, 0x06, 0x66, 0xe7, 0x41, 0x28, 0x8f,
	0xc1, 0xb3, 0x6e, 0xa6, 0xeb, 0xc2, 0x9c, 0x6d, 0xeb, 0xe4, 0x03, 0x18, 0xb9, 0x87, 0xd7, 0x8e,
	0x66, 0x94, 0x00, 0xc5, 0x1f, 0x0b, 0xf9, 0x26, 0xdd, 0x65, 0x7f, 0xea, 0x67, 0x0c, 0x96, 0x91,
	0x1a, 0x8c, 0xad, 0x04, 0x14, 0xb3, 0x6f, 0xe6, 0x87, 0xf7, 0x71, 0xad, 0x73, 0x92, 0xa4, 0x8f,
	0xab, 0xe0, 0x64, 0xfd, 0x74, 0x16, 0x48, 0xfc, 0x8d, 0x98, 0x6a, 0x22, 0x7c, 0x66, 0x07, 0xfd,
	0x7d, 0x63, 0xd0, 0xcf, 0xf4, 0x0c, 0x3a, 0xff, 0xbc, 0xa1, 0xc6, 0xfe, 0xb7, 0x32, 0x70, 0x32,
	0x9d, 0x90, 0x9c, 0x87, 0xd1, 0xbb, 0x5b, 0x9b, 0x32, 0xd0, 0x84, 0xf8, 0x14, 0xbf, 0x83, 0x3a,
	0xbf, 0x2d, 0x8a, 0xc8, 0x1b, 0x30, 0xfa, 0x65, 0x7b, 0x85, 0x9d, 0x43, 0x5a, 0x4c, 0xe4, 0x6f,
	0x05, 0x4e, 0xdd, 0x3c, 0x8a, 0x04, 0x92, 0x3e, 0xb6, 0xb9, 0xa7, 0x36, 0xb6, 0x3f, 0x9e, 0x85,
	0x99, 0x72, 0xbd, 0x4e, 0xc3, 0x90, 0x09, 0x39, 0x34, 0x8c, 0x9e, 0xd9, 0x81, 0x4d, 0x0f, 0x21,
	0x61, 0x7c, 0xdb, 0x50, 0xa3, 0xfa, 0x3b, 0x19, 0x38, 0x21, 0xa9, 0x1e, 0x79, 0xf4, 0xf1, 0xd6,
	0x5e, 0x40, 0xc3, 0x3d, 0xbf, 0xd9, 0x18, 0x3a, 0xf0, 0x3a, 0x13, 0xf4, 0x30, 0x9a, 0xaa, 0xfe,
	0x3a, 0xbf, 0x83, 0x10, 0x43, 0xd0, 0xe3, 0x11, 0x57, 0xaf, 0xc0, 0x58, 0xb9, 0xd3, 0x09, 0xfc,
	0x47, 0x7c, 0xd9, 0x4f, 0x09, 0x97, 0x5f, 0x0e, 0x32, 0x5c, 0x84, 0x39, 0x88, 0x35, 0xa3, 0x42,
	0xdb, 0x3c, 0xe6, 0xd5, 0x14, 0x6f, 0x46, 0x83, 0xb6, 0x75, 0xf9, 0x18, 0xcb, 0xad, 0x1a, 0x90,
	0xcd, 0xc0, 0x6f, 0xf9, 0x11, 0x6d, 0xf0, 0xef, 0x41, 0xcf, 0xea, 0x23, 0x83, 0xf5, 0x6c, 0x79,
	0x51, 0xd3, 0x08, 0xd6, 0x13, 0x31, 0x80, 0xcd, 0xe1, 0xd6, 0xff, 0x35, 0x02, 0x93, 0x7a, 0xef,
	0x10, 0x8b, 0x47, 0x53, 0xf6, 0x03, 0xdd, 0xbd, 0xdf, 0x45, 0x88, 0x2d, 0x4a, 0xe2, 0xd8, 0x18,
	0xd9, 0x23, 0x63, 0x63, 0x3c, 0x80, 0xa9, 0xcd, 0xc0, 0xef, 0xf8, 0x21, 0x6d, 0xf0, 0xac, 0xcc,
	0x7c, 0x2b, 0x9c, 0xd3, 0xf4, 0x47, 0x36, 0x90, 0xf8, 0xae, 0x89, 0xb7, 0x27, 0x1d, 0x81, 0xed,
	0x24, 0x73, 0x36, 0x9b, 0x7c, 0xb8, 0xc9, 0x84, 0x1b, 0x8a, 0xd0, 0x76, 0xca, 0x64, 0x82, 0x41,
	0x4c, 0x93, 0x09, 0x06, 0xd1, 0xd7, 0xda, 0xc8, 0xd3, 0x5a, 0x6b, 0xe4, 0xa7, 0x33, 0x30, 0x51,
	0x6e, 0xb7, 0x45, 0xcc, 0x8d, 0x23, 0xdc, 0x8d, 0xbf, 0x26, 0xac, 0x26, 0xde, 0xfe, 0x58, 0x56,
	0x13, 0x28, 0xb7, 0x84, 0x28, 0xa9, 0xc6, 0x15, 0xea, 0x1a, 0x94, 0xd6, 0x0e, 0xf2, 0x36, 0x14,
	0xd5, 0x24, 0xaf, 0xb6, 0x1b, 0xf4, 0x09, 0x0d, 0x17, 0xc6, 0xce, 0xe5, 0x2e, 0x4e, 0x89, 0xa0,
	0x96, 0xba, 0x64, 0x9a, 0x44, 0x24, 0x5b, 0x00, 0xae, 0x9a, 0x5d, 0x89, 0x7c, 0x58, 0xbd, 0xd3,
	0x4f, 0x48, 0xcf, 0xf8, 0x1b, 0x1f, 0xa6, 0x74, 0xe9, 0x39, 0xe6, 0x43, 0x5a, 0x30, 0xc3, 0x93,
	0x51, 0x61, 0x92, 0x6a, 0x8c, 0xdd, 0x0c, 0x47, 0x8e, 0xc3, 0x2b, 0xe2, 0x1e, 0xec, 0x79, 0x91,
	0xe2, 0x0a, 0xf3, 0x5e, 0x3b, 0x29, 0x81, 0x9c, 0x93, 0xbc, 0x79, 0x08, 0x51, 0xfb, 0x54, 0x6f,
	0x7b, 0xf9, 0xa4, 0xff, 0xf1, 0x0c, 0x9c, 0xd4, 0x27, 0x7d, 0xad, 0xbb, 0xdd, 0xf2, 0x50, 0x17,
	0x24, 0x97, 0x61, 0x5c, 0xcc, 0x49, 0xa5, 0x44, 0xf5, 0x86, 0xa0, 0x8e, 0x51, 0xc8, 0x2a, 0x9b,
	0x86, 0x8c, 0x87, 0x90, 0xba, 0xe7, 0x12, 0xfb, 0x14, 0x2b, 0x8a, 0x13, 0x1d, 0x06, 0xf8, 0xdb,
	0x9c, 0x9f, 0x0c, 0x62, 0xbd, 0x07, 0xb3, 0xe6, 0x48, 0xd4, 0x68, 0x44, 0x2e, 0xc1, 0x98, 0x1c,
	0xbe, 0x4c, 0xfa, 0xf0, 0xc9, 0x72, 0xeb, 0x01, 0x90, 0x1e, 0xfa, 0x10, 0xcd, 0x9b, 0x68, 0x24,
	0xcd, 0xef, 0xe4, 0xe3, 0x62, 0x0f, 0xa2, 0xca, 0xfc, 0x3f, 0x61, 0xd8, 0x7b, 0x33, 0x52, 0xeb,
	0x4f, 0xa6, 0x61, 0x2e, 0x65, 0xcf, 0x3d, 0x42, 0x26, 0x2a, 0x99, 0x1b, 0xc4, 0xb8, 0x8a, 0x56,
	0x20, 0xb7, 0x85, 0xf7, 0x64, 0x92, 0xf6, 0x01, 0xdb, 0xc1, 0xa0, 0xcc, 0xed, 0x9f, 0x86, 0x5c,
	0xa4, 0x07, 0x14, 0x19, 0x79, 0x6a, 0x01, 0x45, 0x96, 0x61, 0x4a, 0x7c, 0x95, 0xd8, 0xae, 0x34,
	0x4b, 0xd5, 0x80, 0x17, 0x38, 0x3d, 0xdb, 0x96, 0x49, 0xc2, 0x79, 0x84, 0x7e, 0xf3, 0x11, 0x15,
	0x3c, 0xc6, 0x74, 0x1e, 0x58, 0x90, 0xca, 0x43, 0x23, 0x21, 0xff, 0x01, 0xe6, 0xd3, 0x41, 0x88,
	0xbe, 0x67, 0x15, 0x06, 0xed, 0x59, 0x8d, 0xa7, 0xb3, 0x67, 0x9d, 0x91, 0x6d, 0x4c, 0xdf, 0xbb,
	0x52, 0x9a, 0x45, 0x7e, 0x29, 0x03, 0xb3, 0x3c, 0xaa, 0x85, 0xde, 0xd8, 0x81, 0x91, 0x0a, 0xea,
	0x4f, 0xa7, 0xb1, 0x2f, 0x88, 0x3c, 0x12, 0xe9, 0x6d, 0xed, 0x6d, 0x14, 0xf9, 0x1e, 0x00, 0xb5,
	0xa2, 0xc2, 0x05, 0xc0, 0xa5, 0xf6, 0x42, 0xca, 0x2e, 0xa0, 0x90, 0xe2, 0x98, 0xd7, 0x91, 0xa2,
	0x33, 0xb2, 0x28, 0x29, 0x28, 0xf9, 0x2b, 0x30, 0xcf, 0xd6, 0x8b, 0x82, 0x88, 0x18, 0x3c, 0x0b,
	0x13, 0x58, 0xcb, 0xe7, 0xfb, 0xcb, 0x44, 0x97, 0xd3, 0xc8, 0x78, 0x84, 0xce, 0x38, 0x13, 0x65,
	0xa4, 0xbb, 0xeb, 0xa7, 0x56, 0x84, 0xa1, 0xad, 0xb0, 0xf5, 0x3c, 0x2e, 0x75, 0x9f, 0xfd, 0xed,
	0xb4, 0x5c, 0x0b, 0x7c, 0x7f, 0x0b, 0x4d, 0xe7, 0x4f, 0x04, 0x91, 0x2f, 0x03, 0x51, 0xe1, 0x20,
	0x38, 0x8c, 0xca, 0x98, 0xd5, 0xfc, 0xda, 0x38, 0x0e, 0x2b, 0x11, 0xc8, 0x62, 0x7d, 0x92, 0xf4,
	0x12, 0x13, 0x0a, 0xf3, 0xe2, 0xa3, 0x19, 0x54, 0x26, 0xbb, 0x09, 0x17, 0xa6, 0x8d, 0x08, 0x47,
	0x71, 0x49, 0x9c, 0xb2, 0x52, 0xcb, 0x98, 0x63, 0x5c, 0x39, 0xa5, 0xb1, 0x23, 0xd7, 0x61, 0x1c,
	0x3d, 0x30, 0xd7, 0xa4, 0xd1, 0x96, 0x30, 0x20, 0x41, 0x5f, 0x4d, 0x67, 0xcf, 0x34, 0xbd, 0x8a,
	0x51, 0x99, 0x3a, 0x50, 0x09, 0xf6, 0xed, 0x6e, 0x1b, 0x2f, 0x77, 0xc5, 0x7d, 0x47, 0x23, 0xd8,
	0x77, 0x82, 0xae, 0xe9, 0xa2, 0x8b, 0x48, 0xe4, 0x9b, 0x30, 0x71, 0xc7, 0x7d, 0x22, 0xef, 0x76,
	0xc5, 0x05, 0xee, 0xa0, 0x1d, 0xc8, 0x92, 0x5f, 0xd3, 0x72, 0x9f, 0x38, 0x8d, 0x6e, 0x32, 0x3e,
	0x28, 0x6e, 0x43, 0x3a, 0x4b, 0xf2, 0x75, 0x00, 0xed, 0xc6, 0x99, 0x1c, 0x59, 0xc1, 0x8b, 0x32,
	0x6e, 0x57, 0xea, 0x4d, 0x34, 0xf2, 0xd7, 0x18, 0x26, 0x24, 0x87, 0xf9, 0x4f, 0x4f, 0x72, 0x38,
	0xf1, 0xe9, 0x49, 0x0e, 0x8b, 0xdb, 0x70, 0xba, 0xef, 0xd2, 0x49, 0x09, 0xa7, 0x7a, 0xc5, 0x0c,
	0xa7, 0x7a, 0xba, 0xdf, 0x11, 0x1b, 0x9a, 0x61, 0xce, 0xe7, 0x8a, 0xf3, 0xfd, 0xa5, 0x93, 0xef,
	0x64, 0x13, 0x47, 0xae, 0x50, 0x2c, 0x78, 0x5a, 0x8c, 0x7e, 0x32, 0x49, 0x16, 0x53, 0x18, 0xf2,
	0x43, 0x39, 0x1b, 0x2b, 0x34, 0x89, 0xac, 0xcf, 0xfc, 0x78, 0xfe, 0xa4, 0xa7, 0xef, 0x3b, 0x30,
	0xcd, 0x93, 0x97, 0xdd, 0xa6, 0xfb, 0x8f, 0xfd, 0xa0, 0x21, 0x53, 0xfb, 0xa2, 0x0c, 0xde, 0x93,
	0x32, 0x34, 0x81, 0x4b, 0x2a, 0xd2, 0xa9, 0x6f, 0x04, 0x6b, 0x3f, 0x9d, 0xba, 0x8b, 0x31, 0x84,
	0x41, 0xfe, 0x7e, 0xe4, 0x4d, 0x25, 0xa8, 0xd1, 0x40, 0x0f, 0x76, 0x1e, 0x48, 0x60, 0x8a, 0xbc,
	0x46, 0x03, 0xeb, 0x0f, 0x72, 0x40, 0x78, 0x4d, 0x2b, 0x6e, 0xc7, 0x45, 0x97, 0x57, 0x0f, 0x83,
	0xc5, 0x14, 0x05, 0x8e, 0xbb, 0xdd, 0xa4, 0x7a, 0xa4, 0x25, 0x61, 0x24, 0xab, 0xca, 0x9c, 0xa4,
	0xa2, 0xd3, 0x43, 0xd8, 0x67, 0xab, 0xcb, 0x7e, 0x92, 0xad, 0xee, 0x9b, 0xf0, 0x7c, 0xb9, 0x83,
	0x59, 0x10, 0x65, 0x2d, 0x37, 0xfc, 0x40, 0x6e, 0x52, 0x86, 0x33, 0x95, 0xab, 0xd0, 0x7a, 0x5a,
	0x3a, 0x88, 0x85, 0x26, 0xa7, 0xb0, 0x79, 0xd9, 0x89, 0x74, 0xe7, 0x7c, 0x29, 0xa7, 0x74, 0xb0,
	0x24, 0x45, 0x4e, 0xe1, 0x24, 0x92, 0x87, 0x17, 0x48, 0x39, 0x05, 0xd3, 0x7b, 0xc4, 0x3c, 0xbc,
	0x80, 0xf6, 0x91, 0x75, 0x14, 0x09, 0x79, 0x07, 0x26, 0xca, 0xdd, 0xc8, 0x17, 0x8c, 0x85, 0x75,
	0x77, 0x6c, 0x87, 0x2d, 0x9a, 0x62, 0xa8, 0x3e, 0x31, 0xba, 0xf5, 0xc7, 0x39, 0x38, 0xdd, 0x3b,
	0xbc, 0xa2, 0x54, 0xad, 0x8f, 0xcc, 0x11, 0xeb, 0x23, 0x6d, 0x36, 0xf0, 0xc7, 0x82, 0xa7, 0x36,
	0x1b, 0x78, 0x32, 0xc5, 0x8f, 0x39, 0x1b, 0x6a, 0x30, 0xa1, 0x9f, 0x77, 0xf9, 0x8f, 0x7b, 0xde,
	0xe9, 0x5c, 0x98, 0x52, 0xcf, 0x63, 0x12, 0x8c, 0xc4, 0x4f, 0x47, 0xc9, 0x70, 0x04, 0x1c, 0x83,
	0xfc, 0xff, 0xe0, 0x1c, 0xdf, 0x93, 0x92, 0x1f, 0xbb, 0xbc, 0x2f, 0x39, 0x8a, 0x81, 0x5b, 0x3a,
	0x3c, 0x28, 0x5d, 0xe6, 0x57, 0x25, 0x4e, 0x4f, 0xb7, 0x39, 0xdb, 0xfb, 0x8e, 0x6c, 0x99, 0x56,
	0xc9, 0x91, 0xbc, 0x31, 0x83, 0xa2, 0x96, 0xdd, 0xee, 0x8d, 0x34, 0xb7, 0x17, 0x1e, 0x31, 0x98,
	0x83, 0x4d, 0x8f, 0x17, 0x79, 0x1d, 0x96, 0x4d, 0xbd, 0x0e, 0x93, 0xf7, 0x29, 0xb9, 0xd4, 0xfb,
	0x94, 0x0a, 0xcc, 0xd4, 0xba, 0xdb, 0xb2, 0xee, 0xa4, 0xdf, 0x5b, 0xd8, 0xdd, 0x4e, 0xfb, 0xa0,
	0x24, 0x89, 0xf5, 0x23, 0x59, 0x98, 0xdc, 0x6c, 0x76, 0x77, 0xbd, 0x76, 0xc5, 0x8d, 0xdc, 0x67,
	0xf6, 0x86, 0xee, 0x2d, 0xe3, 0x86, 0x4e, 0x79, 0x77, 0xa9, 0x0f, 0x1b, 0xea, 0x7a, 0xee, 0xa7,
	0x32, 0x30, 0x13, 0x93, 0xf0, 0x73, 0x76, 0x0d, 0xf2, 0xec, 0x87, 0xd0, 0x5b, 0xcf, 0xf5, 0x30,
	0xe6, 0x29, 0x95, 0xd4, 0x5f, 0xe2, 0xce, 0xcc, 0xcc, 0x57, 0x82, 0x1c, 0x16, 0xbf, 0x00, 0xe3,
	0x31, 0xdb, 0xe3, 0xa4, 0x52, 0xfa, 0xd5, 0x0c, 0x14, 0x93, 0x5f, 0x42, 0x6e, 0xc3, 0x18, 0xe3,
	0xe4, 0x51, 0xa9, 0x52, 0xbf, 0xd4, 0xe7, 0x9b, 0x2f, 0x0b, 0x34, 0xde, 0x3c, 0xec, 0x7c, 0xca,
	0x21, 0xb6, 0xe4, 0xb0, 0x68, 0xc3, 0xa4, 0x8e, 0x95, 0xd2, 0xba, 0xd7, 0x4d, 0xe1, 0xe2, 0x64,
	0x7a, 0x3f, 0x18, 0x09, 0xa0, 0x8c, 0x56, 0x0b, 0xb9, 0xe1, 0x82, 0x31, 0xb9, 0xb0, 0xaf, 0x12,
	0xf3, 0x86, 0x4f, 0xb3, 0xa5, 0x38, 0x88, 0xb9, 0x3e, 0xcf, 0x52, 0x26, 0xb4, 0xc2, 0x23, 0xaf,
	0xc3, 0x28, 0xaf, 0x4f, 0x4f, 0x84, 0xd2, 0x41, 0x88, 0x2e, 0xe2, 0x72, 0x1c, 0xeb, 0x6f, 0xe7,
	0xe0, 0x64, 0xdc, 0xbc, 0x7b, 0x9d, 0x86, 0x1b, 0xd1, 0x4d, 0x37, 0x70, 0x5b, 0xe1, 0x11, 0x2b,
	0xe0, 0x62, 0x4f, 0xd3, 0x30, 0x31, 0x86, 0x6c, 0x9a, 0xd6, 0x20, 0x2b, 0xd1, 0x20, 0xbc, 0xbe,
	0xe4, 0x0d, 0x92, 0xcd, 0x20, 0xb7, 0x21, 0x57, 0xa3, 0x91, 0xd8, 0x36, 0x2f, 0xf4, 0xf4, 0xaa,
	0xde, 0xae, 0xcb, 0x35, 0x1a, 0xf1, 0x41, 0xe4, 0xb1, 0x72, 0xa8, 0x11, 0x1d, 0xb5, 0x46, 0x23,
	0xf2, 0x00, 0x46, 0x57, 0x9f, 0x74, 0x68, 0x3d, 0x12, 0x89, 0xc0, 0x2e, 0x0d, 0xe6, 0xc7, 0x71,
	0xb5, 0x3c, 0x60, 0x14, 0x01, 0x7a, 0x67, 0x71, 0x94, 0xc5, 0xeb, 0x50, 0x90, 0x95, 0x1f, 0x67,
	0xe6, 0x2e, 0xbe, 0x05, 0x13, 0x5a, 0x25, 0xc7, 0x9a, 0xf4, 0x3f, 0xcf, 0xf6, 0x55, 0xbf, 0x29,
	0x73, 0x87, 0xad, 0xf6, 0x88, 0x79, 0x99, 0xd8, 0xc7, 0x9d, 0x8b, 0x79, 0xce, 0x43, 0x51, 0x34,
	0x40, 0xde, 0xab, 0xc2, 0x4c, 0xed, 0xa1, 0xd7, 0x89, 0x83, 0x54, 0x1a, 0x87, 0x29, 0x66, 0x75,
	0x10, 0x3a, 0x77, 0xf2, 0x30, 0x4d, 0xd2, 0x59, 0x7f, 0x96, 0x81, 0x51, 0xf6, 0xd7, 0xfd, 0xeb,
	0xcf, 0xe8, 0x96, 0x79, 0xcd, 0xd8, 0x32, 0x67, 0xb5, 0x38, 0xd1, 0xb8, 0x71, 0x5c, 0x3f, 0x62,
	0xb3, 0x3c, 0x10, 0x03, 0xc4, 0x91, 0xc9, 0x4d, 0x18, 0x13, 0x56, 0x3d, 0xc2, 0xfc, 0x5a, 0x0f,
	0x3c, 0x2d, 0xed, 0x7d, 0x94, 0x72, 0xee, 0x77, 0x92, 0xb7, 0x19, 0x92, 0x9a, 0x89, 0xe4, 0x32,
	0x5c, 0xa8, 0x91, 0x71, 0xd2, 0x47, 0x7f, 0x39, 0x1e, 0x36, 0x59, 0xcb, 0x11, 0xdb, 0xc7, 0x33,
	0xbe, 0x2c, 0x1e, 0x32, 0x72, 0x83, 0x98, 0x9c, 0x94, 0x09, 0xf9, 0x52, 0xdf, 0x38, 0xfe, 0xe9,
	0x3c, 0x0f, 0x36, 0x2c, 0x1b, 0xf6, 0x2e, 0x4c, 0xde, 0xf0, 0x83, 0xc7, 0x6e, 0xc0, 0x43, 0x48,
	0x0a, 0xcb, 0x01, 0xa6, 0x3a, 0x4e, 0xed, 0x70, 0x38, 0x0f, 0x42, 0xf9, 0xdd, 0x83, 0x52, 0x7e,
	0xd9, 0xf7, 0x9b, 0xb6, 0x81, 0x4e, 0xee, 0xc2, 0xd4, 0x1d, 0xf7, 0x89, 0xa6, 0xf4, 0x72, 0x07,
	0x98, 0x4b, 0x6c, 0x02, 0x33, 0xad, 0xf9, 0x68, 0x13, 0x2b, 0x93, 0x9e, 0x78, 0x30, 0xbd, 0xe9,
	0x07, 0x91, 0xa8, 0xc4, 0x6b, 0xef, 0x8a, 0x8f, 0xed, 0x35, 0x12, 0xbb, 0x92, 0x6a, 0x24, 0x76,
	0xba, 0xe3, 0x07, 0x91, 0xb3, 0xa3, 0xc8, 0x8d, 0x20, 0x53, 0x06, 0x63, 0xf2, 0x2e, 0xcc, 0x6a,
	0x41, 0xf4, 0x6e, 0xf8, 0x41, 0xcb, 0x95, 0x42, 0x39, 0xde, 0x03, 0xa3, 0xbd, 0xc9, 0x0e, 0x82,
	0xed, 0x5e, 0x4c, 0xf2, 0xd5, 0x34, 0x97, 0xa2, 0x91, 0xd8, 0xca, 0x2c, 0xc5, 0xa5, 0xa8, 0x9f,
	0x95, 0x59, 0xaf, 0x73, 0xd1, 0xee, 0x20, 0x2b, 0xd4, 0xc2, 0xf2, 0x55, 0xa1, 0x7e, 0x1f, 0x6d,
	0x65, 0xaa, 0xc6, 0xad, 0x8f, 0xb5, 0xe9, 0x12, 0xe4, 0x96, 0x37, 0x6f, 0xe0, 0xeb, 0x85, 0x34,
	0xb4, 0x69, 0xef, 0xb9, 0xed, 0x3a, 0x0a, 0xcb, 0xc2, 0xf2, 0x5b, 0xdf, 0x91, 0x97, 0x37, 0x6f,
	0x10, 0x17, 0xe6, 0x36, 0x69, 0xd0, 0xf2, 0xa2, 0xaf, 0x5c, 0xbd, 0xaa, 0x0d, 0x54, 0x01, 0x9b,
	0x76, 0x45, 0x34, 0xad, 0xd4, 0x41, 0x14, 0xe7, 0xc9, 0xd5, 0xab, 0xa9, 0xc3, 0xa1, 0x1a, 0x96,
	0xc6, 0x8b, 0xed, 0x8c, 0x77, 0xdc, 0x27, 0xb1, 0xc1, 0x7e, 0x28, 0x9c, 0x33, 0xcf, 0xc8, 0x89,
	0x15, 0x1b, 0xfb, 0x1b, 0x3b, 0xa3, 0x49, 0xc4, 0x74, 0x9d, 0x78, 0x7a, 0x85, 0xc2, 0xad, 0x65,
	0x51, 0x5e, 0xe9, 0x48, 0x0f, 0x5e, 0x5d, 0x60, 0xd7, 0xd0, 0xc9, 0x3d, 0xa5, 0xb1, 0x71, 0x8d,
	0x47, 0xa4, 0x9b, 0xbb, 0xa2, 0x6b, 0x6c, 0xfc, 0x22, 0xc5, 0xf8, 0xac, 0x19, 0xa5, 0xe6, 0x73,
	0x0f, 0x06, 0xdb, 0xe4, 0xd2, 0xab, 0x08, 0x4e, 0x1e, 0x5f, 0x11, 0xa4, 0x90, 0x5f, 0xf7, 0xeb,
	0x0f, 0x45, 0x64, 0xac, 0x2f, 0xb3, 0xe5, 0xde, 0xf4, 0xeb, 0x0f, 0x9f, 0x9e, 0x75, 0x2d, 0xb2,
	0x27, 0x1b, 0xac, 0xa9, 0x6c, 0x16, 0x88, 0x3e, 0x11, 0x16, 0x9b, 0xf3, 0x4a, 0x13, 0xd2, 0xca,
	0xb8, 0xe0, 0xc3, 0x27, 0x8d, 0xec, 0x5a, 0xdb, 0x24, 0x27, 0x14, 0x8a, 0x15, 0x1a, 0x3e, 0x8c,
	0xfc, 0xce, 0x4a, 0xd3, 0xeb, 0x6c, 0xfb, 0x6e, 0x20, 0xe3, 0x95, 0xf6, 0xae, 0xef, 0x57, 0x52,
	0xd7, 0xf7, 0x6c, 0x83, 0xd3, 0x3b, 0x75, 0xc9, 0xc0, 0xee, 0x61, 0x49, 0xbe, 0x0a, 0xd3, 0x6c,
	0x72, 0xaf, 0x3e, 0x89, 0x68, 0x9b, 0x8f, 0xfc, 0x2c, 0x8a, 0x0e, 0xf3, 0x5a, 0x80, 0x7e, 0x55,
	0xc8, 0xe7, 0x14, 0x2e, 0x76, 0xaa, 0x08, 0x8c, 0xa8, 0x62, 0x06, 0x2b, 0xd2, 0x80, 0x85, 0x3b,
	0xee, 0x13, 0x2d, 0x49, 0x9e, 0x36, 0x49, 0x09, 0x4e, 0xb0, 0x8b, 0x87, 0x07, 0xa5, 0x97, 0xd8,
	0x04, 0x8b, 0x43, 0xe8, 0xf6, 0x99, 0xaf, 0x7d, 0x39, 0x91, 0xef, 0x85, 0x53, 0xe2, 0xb3, 0x2a,
	0x98, 0xb5, 0xc6, 0x0f, 0xf6, 0x6b, 0x7b, 0x2e, 0xfa, 0xea, 0xcc, 0x1d, 0x6f, 0x43, 0x94, 0x1d,
	0xd6, 0x90, 0x7c, 0x9c, 0x90, 0x33, 0xb2, 0xfb, 0xd5, 0x40, 0x3e, 0x82, 0x69, 0xfe, 0x64, 0xb3,
	0xe6, 0x87, 0x11, 0x2a, 0xf4, 0xf3, 0xc7, 0x33, 0x41, 0xe7, 0xef, 0x40, 0xdc, 0x69, 0x23, 0x71,
	0x01, 0x90, 0xe0, 0x4c, 0xde, 0x86, 0x89, 0x4d, 0xaf, 0xcd, 0xe3, 0xfe, 0x55, 0x37, 0xf1, 0xea,
	0x51, 0x9c, 0x3f, 0x1d, 0xaf, 0xed, 0x48, 0xad, 0xba, 0xa3, 0xb6, 0x0b, 0x1d, 0x9b, 0x3c, 0x80,
	0x89, 0x5a, 0x6d, 0xed, 0x86, 0xc7, 0x0e, 0xc0, 0xce, 0xfe, 0xc2, 0xc9, 0x3e, 0xad, 0x3c, 0x9f,
	0xda, 0xca, 0xa9, 0x30, 0xdc, 0xc3, 0xc4, 0xe3, 0x4e, 0xdd, 0xef, 0xec, 0xdb, 0x3a, 0xa7, 0x14,
	0xb3, 0xec, 0x53, 0x4f, 0xd9, 0x2c, 0xbb, 0x0a, 0x33, 0x9a, 0x81, 0x25, 0x1a, 0x57, 0x2e, 0xc4,
	0x01, 0x66, 0x74, 0x33, 0xec, 0xa4, 0x1b, 0x62, 0x92, 0x4e, 0xda, 0x63, 0x9f, 0x3e, 0xae, 0x3d,
	0xb6, 0x07, 0xb3, 0x7c, 0x30, 0xc4, 0x3c, 0xc0, 0x91, 0x5e, 0xec, 0xd3, 0x87, 0x97, 0x52, 0xfb,
	0x70, 0x4e, 0x8c, 0xb4, 0x9c, 0x64, 0xf8, 0x44, 0xd9, 0xcb, 0x95, 0xec, 0x00, 0x11, 0x40, 0x91,
	0xf6, 0x1c, 0xeb, 0x7a, 0xbe, 0x4f, 0x5d, 0x2f, 0xa5, 0xd6, 0x35, 0x2d, 0xeb, 0xda, 0xe6, 0xd5,
	0xa4, 0x70, 0x24, 0x6d, 0x59, 0x8f, 0x9c, 0x5f, 0xd8, 0xb1, 0x2f, 0x18, 0xf7, 0xa0, 0xbd, 0x08,
	0x3c, 0xe8, 0x6e, 0x72, 0xd2, 0x26, 0xfb, 0x3d, 0x85, 0x33, 0x79, 0x02, 0x27, 0x7b, 0x5b, 0x81,
	0x75, 0x9e, 0xc1, 0x3a, 0xcf, 0x18, 0x75, 0x26, 0x91, 0xf8, 0xbc, 0x31, 0x3f, 0x2b, 0x59, 0x6b,
	0x1f, 0xfe, 0xe4, 0x07, 0x33, 0x70, 0xea, 0xce, 0x8d, 0x32, 0xa6, 0x66, 0xf3, 0x78, 0x18, 0x28,
	0xe5, 0xbe, 0x79, 0x56, 0xdc, 0x95, 0x27, 0xef, 0xef, 0xa5, 0xc4, 0x81, 0x5b, 0x05, 0x93, 0x11,
	0xcf, 0xb7, 0x76, 0x5c, 0x9e, 0xf1, 0x4d, 0xb0, 0x48, 0xf1, 0xf1, 0xfc, 0xd9, 0x3f, 0x2c, 0x65,
	0xec, 0x7e, 0x55, 0xdd, 0xca, 0x17, 0xa6, 0x8a, 0xd3, 0x69, 0x06, 0xdf, 0xbf, 0x99, 0x4d, 0x9c,
	0x1d, 0xa4, 0x0a, 0x63, 0x62, 0x4a, 0x08, 0x61, 0xba, 0x77, 0xe0, 0xcf, 0xa4, 0x0e, 0xfc, 0x98,
	0x98, 0x5d, 0xb6, 0xa4, 0x27, 0x8f, 0x19, 0x2b, 0xb4, 0xcc, 0x17, 0xda, 0xc7, 0xd7, 0xf9, 0xd1,
	0x80, 0x20, 0xe3, 0x10, 0xac, 0x1c, 0xdf, 0x2f, 0xc9, 0x74, 0x7b, 0xc3, 0xd3, 0x50, 0xd6, 0x46,
	0x1e, 0xf2, 0x94, 0x22, 0x39, 0xe5, 0xdc, 0x62, 0xe6, 0x0f, 0x79, 0x6a, 0x15, 0xb2, 0x5a, 0xac,
	0xdf, 0xc8, 0xc0, 0x94, 0x71, 0xf8, 0x90, 0xeb, 0x9a, 0xe7, 0x56, 0xec, 0xcc, 0x6c, 0xe0, 0xe0,
	0x7e, 0x94, 0xf4, 0xe9, 0xba, 0x2e, 0xcc, 0xb7, 0xb3, 0xfd, 0xe9, 0x70, 0x3e, 0x26, 0x1d, 0xf9,
	0x06, 0xdf, 0xd5, 0xa9, 0x44, 0x65, 0xf9, 0x3e, 0x89, 0xca, 0xfe, 0xc1, 0xf3, 0x30, 0x6d, 0x6a,
	0x27, 0xe4, 0x75, 0x18, 0xc5, 0x2b, 0x4e, 0xa9, 0xea, 0xf2, 0x54, 0xdd, 0x08, 0x31, 0x52, 0x75,
	0x23, 0x84, 0xbc, 0x0c, 0xa0, 0xec, 0x68, 0xe5, 0x05, 0xff, 0xc8, 0xe1, 0x41, 0x29, 0xf3, 0x86,
	0xad, 0x15, 0x90, 0x6f, 0x00, 0x6c, 0xf8, 0x0d, 0xaa, 0x92, 0x29, 0x0e, 0x78, 0xc4, 0x7e, 0xa5,
	0x27, 0xdc, 0xfe, 0x89, 0xb6, 0xdf, 0xa0, 0xbd, 0xb1, 0xf5, 0x35, 0x8e, 0xe4, 0x4b, 0x30, 0x62,
	0x77, 0x99, 0x5a, 0xcd, 0x6f, 0x34, 0x26, 0xe4, 0x21, 0xd0, 0x6d, 0xd2, 0x58, 0x67, 0x0b, 0xba,
	0x49, 0xfb, 0x2c, 0x06, 0x20, 0xef, 0xf3, 0x30, 0xfc, 0x22, 0x86, 0xdd, 0x48, 0xfc, 0xe4, 0xa1,
	0x09, 0x07, 0x3d, 0x51, 0xec, 0x34, 0x12, 0x72, 0x17, 0xc6, 0xf4, 0xbb, 0x7a, 0xcd, 0x05, 0x58,
	0x7f, 0xcf, 0xd1, 0x14, 0x40, 0x91, 0x85, 0x31, 0x79, 0x8d, 0x2f, 0xb9, 0x90, 0x77, 0x60, 0x9c,
	0xb1, 0x67, 0x3b, 0x49, 0x28, 0x04, 0x7f, 0x7c, 0xd8, 0xd0, 0x1a, 0xc4, 0x36, 0x22, 0x23, 0xd2,
	0x9c, 0x22, 0x20, 0x5f, 0xc5, 0x44, 0x83, 0xa2, 0xab, 0x07, 0x1a, 0x37, 0x5c, 0xe8, 0xe9, 0x6a,
	0xcc, 0x3c, 0xd8, 0x9b, 0x83, 0x5a, 0xf1, 0x23, 0xbb, 0x2a, 0x02, 0xd5, 0x30, 0xa9, 0x13, 0x5e,
	0xed, 0xa9, 0x60, 0x41, 0x06, 0x55, 0xea, 0x4d, 0x8a, 0x69, 0xf0, 0x25, 0x1d, 0x28, 0xc6, 0x72,
	0x97, 0xa8, 0x0b, 0x06, 0xd5, 0xf5, 0x46, 0x4f, 0x5d, 0xfa, 0x00, 0xf6, 0x54, 0xd7, 0xc3, 0x9d,
	0x34, 0x60, 0x5a, 0xee, 0xe1, 0xa2, 0xbe, 0x89, 0x41, 0xf5, 0xbd, 0xdc, 0x53, 0xdf, 0x5c, 0x63,
	0xbb, 0xb7, 0x9e, 0x04, 0x4f, 0xf2, 0x0e, 0x4c, 0x49, 0x08, 0xae, 0x0f, 0x91, 0xec, 0x1a, 0x2f,
	0x67, 0x1a, 0xdb, 0x68, 0xb9, 0x6f, 0xa6, 0x0a, 0xd5, 0x91, 0x75, 0x6a, 0x3e, 0x3b, 0xa6, 0x0c,
	0xea, 0xe4, 0xac, 0x30, 0x91, 0xc9, 0x87, 0x30, 0x51, 0x6d, 0xb1, 0x0f, 0xf1, 0xdb, 0x6e, 0x44,
	0x85, 0x7b, 0x98, 0x34, 0xd4, 0xd0, 0x4a, 0xb4, 0xa9, 0xca, 0x93, 0x6f, 0xc6, 0x45, 0x46, 0xf2,
	0xcd, 0x18, 0xcc, 0x3a, 0x8f, 0x3f, 0xce, 0x88, 0x39, 0x2c, 0x5d, 0xc7, 0xce, 0xa4, 0x18, 0x4b,
	0x68, 0xec, 0x45, 0xac, 0x48, 0x06, 0x95, 0x8f, 0x23, 0x89, 0x58, 0x91, 0x3a, 0x4f, 0xf2, 0x2e,
	0x4c, 0x88, 0xac, 0x32, 0x65, 0x7b, 0x23, 0x5c, 0x28, 0xe2, 0xc7, 0xa3, 0xc3, 0xbb, 0x4c, 0x40,
	0xe3, 0xb8, 0x41, 0xc2, 0x2a, 0x30, 0xc6, 0x27, 0x5f, 0x81, 0xf9, 0x07, 0x5e, 0xbb, 0xe1, 0x3f,
	0x0e, 0xc5, 0x31, 0x25, 0x36, 0xba, 0xd9, 0xd8, 0x27, 0xe7, 0x31, 0x2f, 0x57, 0xe2, 0x52, 0xcf,
	0xc6, 0x97, 0xca, 0x81, 0xfc, 0xe5, 0x1e, 0xce, 0x7c, 0x06, 0x91, 0x41, 0x33, 0x68, 0xa9, 0x67,
	0x06, 0xf5, 0x56, 0x9f, 0x9c, 0x4e, 0xa9, 0xd5, 0x10, 0x1f, 0x88, 0x79, 0xbe, 0xdf, 0xf2, 0xbd,
	0xf6, 0xc2, 0x1c, 0xee, 0x85, 0xcf, 0x27, 0x5d, 0xcc, 0x11, 0x6f, 0xd3, 0x6f, 0x7a, 0xf5, 0xfd,
	0x65, 0xeb, 0xf0, 0xa0, 0x74, 0x36, 0x29, 0x16, 0x7f, 0xe4, 0x1b, 0x57, 0xd7, 0x29, 0xac, 0xc9,
	0x87, 0x30, 0xc9, 0xfe, 0x57, 0x7a, 0xfb, 0xbc, 0x61, 0x5e, 0xa7, 0x61, 0x8a, 0x7a, 0x70, 0x8c,
	0x30, 0xed, 0x4d, 0x8a, 0x4a, 0x6f, 0xb0, 0x22, 0x6f, 0x01, 0x30, 0x01, 0x4e, 0x6c, 0xc7, 0x27,
	0xe2, 0xd0, 0x9c, 0x28, 0xf6, 0xf5, 0x6e, 0xc4, 0x31, 0x32, 0x79, 0x07, 0x26, 0xd8, 0xaf, 0x5a,
	0xb7, 0xe1, 0xb3, 0xb5, 0x71, 0x12, 0x69, 0xb9, 0xd7, 0x1d, 0xa3, 0x0d, 0x39, 0xdc, 0xf0, 0xba,
	0x8b, 0xd1, 0xc9, 0x1a, 0xcc, 0x60, 0x08, 0xd5, 0x6a, 0x83, 0xb6, 0x23, 0x7c, 0x34, 0x5d, 0x38,
	0xa5, 0x3d, 0x2a, 0xb3, 0x22, 0xc7, 0x53, 0x65, 0xba, 0xb8, 0x9f, 0x20, 0x23, 0x21, 0xcc, 0xc5,
	0xbb, 0x4b, 0xfc, 0x44, 0xbd, 0x80, 0x9d, 0x24, 0x85, 0xdc, 0x5e, 0x0c, 0xbe, 0x1f, 0xb3, 0x11,
	0xd1, 0x36, 0x2e, 0x79, 0xc1, 0xaf, 0x57, 0x98, 0xc6, 0x9d, 0xd8, 0x40, 0x6e, 0xae, 0x6c, 0x26,
	0x63, 0x8c, 0x9e, 0xc6, 0x2f, 0xc0, 0x61, 0xde, 0xad, 0xc7, 0x69, 0x5e, 0x53, 0xe2, 0x8c, 0xa6,
	0x50, 0x93, 0x6f, 0xc3, 0x09, 0xb9, 0x83, 0x88, 0x22, 0x31, 0xaf, 0x17, 0x8f, 0xb9, 0x13, 0x37,
	0xb6, 0x55, 0xd5, 0x3d, 0x53, 0x3a, 0xbd, 0x0a, 0xe2, 0xc2, 0x04, 0x0e, 0xab, 0xa8, 0xf1, 0xf9,
	0x41, 0x35, 0x5e, 0xec, 0xa9, 0xf1, 0x24, 0x4e, 0x94, 0xde, 0xca, 0x74, 0x9e, 0x64, 0x19, 0xa6,
	0xc4, 0x3a, 0x12, 0xb3, 0xed, 0x05, 0xec, 0x2d, 0xbc, 0xe7, 0x91, 0x2b, 0xb0, 0x67, 0xc2, 0x99,
	0x24, 0xfa, 0x8e, 0xcc, 0x2f, 0xf6, 0xcf, 0x18, 0x3b, 0x72, 0xf2, 0x3e, 0xdf, 0x44, 0x66, 0x3b,
	0x52, 0x2c, 0xc5, 0xac, 0x3e, 0xe9, 0x04, 0xe2, 0x16, 0xe7, 0x6c, 0x9c, 0x7a, 0x43, 0x13, 0x7e,
	0x1c, 0xaa, 0x30, 0xf4, 0x2d, 0x21, 0x8d, 0x03, 0xb9, 0x07, 0x73, 0xea, 0xd4, 0xd6, 0x18, 0x97,
	0xe2, 0x14, 0x26, 0xf1, 0x51, 0x9f, 0xce, 0x37, 0x8d, 0x9e, 0xb8, 0x70, 0xca, 0x38, 0xa7, 0x35,
	0xd6, 0xe7, 0x90, 0x35, 0xa6, 0x15, 0x36, 0x0f, 0xf9, 0x74, 0xf6, 0xfd, 0xf8, 0x90, 0x8f, 0x60,
	0x31, 0x79, 0x36, 0x6b, 0xb5, 0xbc, 0x88, 0xb5, 0xbc, 0x7a, 0x78, 0x50, 0xba, 0xd0, 0x73, 0xbc,
	0xa7, 0x57, 0x34, 0x80, 0x1b, 0xf9, 0x06, 0x2c, 0x98, 0xe7, 0xb3, 0x56, 0x93, 0x85, 0x35, 0xe1,
	0xd2, 0x51, 0x07, 0x7b, 0x7a, 0x0d, 0x7d, 0x79, 0x90, 0x08, 0x4a, 0xa9, 0xb3, 0x5b, 0xab, 0xe6,
	0x7c, 0xfc, 0x41, 0x3d, 0xab, 0x24, 0xbd, 0xba, 0xa3, 0x58, 0x92, 0xc7, 0x70, 0x36, 0xed, 0x98,
	0xd0, 0x2a, 0x7d, 0x49, 0xdd, 0x93, 0xbe, 0x96, 0x7e, 0xe4, 0xa4, 0xd7, 0x7c, 0x04, 0x5b, 0xf2,
	0x55, 0x38, 0xa1, 0xad, 0x2f, 0xad, 0xbe, 0x97, 0xb1, 0x3e, 0xf4, 0xa8, 0xd5, 0x17, 0x66, 0x7a,
	0x2d, 0xe9, 0x3c, 0x48, 0x0b, 0xe6, 0xe4, 0x87, 0xe3, 0x85, 0xb4, 0x38, 0x7a, 0x2e, 0x18, 0xbb,
	0x6a, 0x2f, 0x86, 0x96, 0x8f, 0x7d, 0xdb, 0xe9, 0xc4, 0x84, 0xfa, 0x4c, 0x4f, 0xe1, 0x4b, 0xd6,
	0x60, 0xb4, 0xb6, 0x59, 0xbd, 0x71, 0x63, 0x75, 0xe1, 0x15, 0xac, 0x41, 0xba, 0xdf, 0x70, 0xa0,
	0xa1, 0x34, 0x09, 0xab, 0xaf, 0x8e, 0xb7, 0xb3, 0x63, 0x78, 0x39, 0x71, 0xd4, 0x5b, 0xf9, 0xc2,
	0xc5, 0xe2, 0xa5, 0x5b, 0xf9, 0xc2, 0xa5, 0xe2, 0xab, 0xf6, 0x0b, 0xe9, 0xa9, 0xb4, 0xf9, 0xc7,
	0xda, 0x17, 0x06, 0x95, 0xc6, 0x5d, 0x61, 0xfd, 0x7c, 0x06, 0xe6, 0x52, 0xda, 0x41, 0x2e, 0x40,
	0x1e, 0x73, 0x82, 0x68, 0xef, 0xdc, 0x89, 0x5c, 0x20, 0x58, 0x4e, 0x3e, 0x07, 0x63, 0x95, 0x8d,
	0x5a, 0xad, 0xbc, 0x21, 0x55, 0x36, 0xbe, 0x5d, 0xb5, 0x43, 0x27, 0x74, 0xcd, 0xe7, 0x31, 0x81,
	0x46, 0xde, 0x80, 0xd1, 0xea, 0x26, 0x12, 0x70, 0x43, 0x2b, 0x54, 0x61, 0xbc, 0x4e, 0x12, 0x5f,
	0x20, 0x59, 0x3f, 0x9a, 0x01, 0xd2, 0xdb, 0xa9, 0xe4, 0x2a, 0x4c, 0xe8, 0x43, 0xc7, 0x15, 0x4c,
	0x7c, 0xca, 0xd1, 0x06, 0xc6, 0xd6, 0x71, 0x48, 0x05, 0x46, 0x30, 0x6b, 0x9a, 0x7a, 0x97, 0x4b,
	0x3d, 0x00, 0x4e, 0xf5, 0x1c, 0x00, 0x23, 0x98, 0x93, 0xcd, 0xe6, 0xc4, 0xd6, 0xef, 0x64, 0x80,
	0xf4, 0x1e, 0x9a, 0x43, 0xdb, 0x05, 0xbc, 0xa9, 0x39, 0xca, 0xea, 0x51, 0xff, 0x55, 0xca, 0x16,
	0x5d, 0x59, 0x8a, 0x5d, 0x6a, 0x2f, 0x18, 0xca, 0x79, 0x7f, 0xef, 0xaa, 0x4b, 0x30, 0x72, 0x9f,
	0x06, 0xdb, 0xd2, 0x86, 0x10, 0xed, 0x8e, 0x1e, 0x31, 0x80, 0xae, 0xac, 0x22, 0x86, 0xf5, 0xc7,
	0x19, 0x98, 0x4f, 0x93, 0xe4, 0x8e, 0x70, 0x82, 0xb2, 0x12, 0xfe, 0x5b, 0x68, 0x13, 0xc0, 0x8d,
	0x92, 0x94, 0xd7, 0x56, 0x09, 0x46, 0xd8, 0xc7, 0xca, 0x11, 0xc6, 0xcb, 0x02, 0xd6, 0x1b, 0xa1,
	0xcd, 0xe1, 0x0c, 0x81, 0x07, 0x76, 0xca, 0x63, 0x4c, 0x30, 0x44, 0x40, 0x41, 0xc1, 0xe6, 0x70,
	0x86, 0x70, 0xc7, 0x6f, 0xa8, 0x84, 0xc1, 0x88, 0xd0, 0x62, 0x00, 0x9b, 0xc3, 0xc9, 0x05, 0x18,
	0xbb, 0xdb, 0x5e, 0xa7, 0xee, 0x23, 0x19, 0xad, 0x1a, 0x6d, 0x18, 0xfc, 0xb6, 0xd3, 0x64, 0x30,
	0x5b, 0x16, 0x5a, 0x3f, 0x95, 0x81, 0xd9, 0x1e, 0x21, 0xf2, 0x68, 0x3f, 0xaf, 0xc1, 0x0e, 0x17,
	0xc3, 0x7c, 0x1f, 0x6f, 0x7e, 0x3e, 0xbd, 0xf9, 0xd6, 0xff, 0x9d, 0x87, 0x53, 0x7d, 0x74, 0xfa,
	0xd8, 0x21, 0x2c, 0x73, 0xa4, 0x43, 0xd8, 0xd7, 0x98, 0x0e, 0xed, 0x7a, 0xad, 0x70, 0xcb, 0x8f,
	0x5b, 0x1c, 0xdb, 0x95, 0x63, 0x99, 0xcc, 0x99, 0x2c, 0x0d, 0x90, 0x4f, 0xf3, 0xbc, 0xf5, 0x4e,
	0xe4, 0xf7, 0x8a, 0x14, 0x06, 0xb3, 0x1e, 0x97, 0xac, 0xdc, 0x9f, 0x13, 0x97, 0x2c, 0xd3, 0x49,
	0x20, 0xff, 0x54, 0x9d, 0x04, 0xd2, 0x0d, 0x0c, 0x47, 0x3e, 0x89, 0xb9, 0xe9, 0x0a, 0x4c, 0x71,
	0x23, 0x8e, 0x72, 0xc8, 0x07, 0x69, 0xb4, 0xc7, 0xf0, 0xc3, 0x0d, 0x7b, 0xc7, 0xc2, 0xa0, 0x21,
	0x6b, 0xa6, 0x41, 0xfb, 0x18, 0x3e, 0x3e, 0x5d, 0xe8, 0x6f, 0xb0, 0x6e, 0x3c, 0x3a, 0xeb, 0xa4,
	0xd6, 0x4f, 0x65, 0x4d, 0x7f, 0xad, 0x3f, 0x8f, 0x33, 0xef, 0x12, 0x8c, 0x3c, 0xd8, 0xa3, 0x81,
	0xdc, 0xef, 0xb0, 0x21, 0x8f, 0x19, 0x40, 0x6f, 0x08, 0x62, 0x90, 0x1b, 0x30, 0xbd, 0xc9, 0x47,
	0x42, 0x76, 0x6f, 0x3e, 0x56, 0xb5, 0x3a, 0xe2, 0x42, 0x20, 0xa5, 0x7f, 0x13, 0x54, 0xd6, 0x4d,
	0x38, 0x63, 0x2c, 0x48, 0x11, 0x5f, 0x82, 0xdb, 0x95, 0xf3, 0x13, 0x71, 0x3a, 0xb6, 0xa4, 0x8f,
	0x77, 0x0f, 0x3b, 0x01, 0xb5, 0x76, 0xe0, 0xec, 0x40, 0x46, 0xec, 0x20, 0x82, 0x8e, 0xfa, 0x95,
	0x30, 0x7e, 0x1b, 0x48, 0x6a, 0x6b, 0x74, 0xd6, 0xf7, 0xc2, 0xa4, 0xde, 0xcb, 0xb8, 0xa7, 0xb2,
	0xdf, 0x62, 0x53, 0xe3, 0x7b, 0x2a, 0x03, 0xd8, 0x1c, 0x1e, 0x5f, 0xe1, 0x66, 0xd3, 0xaf, 0x70,
	0xe3, 0xe1, 0xcf, 0x1d, 0x35, 0xfc, 0xac, 0x72, 0x5c, 0xb2, 0x5a, 0xe5, 0xf8, 0x5b, 0xaf, 0x1c,
	0x03, 0x48, 0xd8, 0x1c, 0xfe, 0x54, 0x2b, 0xff, 0x6d, 0x99, 0x7b, 0x03, 0xcd, 0xd6, 0xa5, 0x4e,
	0x1c, 0xe7, 0xf2, 0x9d, 0x4b, 0xd3, 0x74, 0x63, 0xcc, 0xf8, 0x90, 0xcc, 0x1e, 0x75, 0x48, 0x1e,
	0x67, 0x22, 0x5e, 0x81, 0xb1, 0xb2, 0x78, 0x1a, 0xce, 0xc7, 0x82, 0x8d, 0xdb, 0xf3, 0x0e, 0x2c,
	0xb1, 0xac, 0x9f, 0xcd, 0xc0, 0x89, 0xd4, 0xab, 0x32, 0x56, 0x2b, 0xbf, 0x93, 0xd3, 0xd6, 0x61,
	0xf2, 0x42, 0x8e, 0x63, 0x1c, 0xc7, 0x7b, 0x78, 0xf8, 0x6f, 0xb1, 0x5e, 0x84, 0x71, 0xf5, 0x50,
	0x43, 0xe6, 0xe5, 0xd0, 0xa1, 0xbd, 0x90, 0xbc, 0xef, 0xaf, 0x01, 0xb0, 0x16, 0x3c, 0x55, 0xeb,
	0x36, 0xeb, 0xb7, 0xb3, 0x3c, 0x2f, 0xdb, 0x33, 0x1b, 0xd0, 0x2f, 0xdd, 0x24, 0x8d, 0x7d, 0x52,
	0xff, 0x30, 0x7e, 0x64, 0x15, 0x46, 0x6b, 0x91, 0x1b, 0x75, 0xa5, 0xd3, 0xf3, 0x9c, 0x4e, 0x86,
	0x05, 0xf7, 0x97, 0x62, 0xb7, 0xd7, 0x10, 0x21, 0x86, 0x72, 0x80, 0x10, 0xcd, 0xb2, 0xcd, 0x83,
	0x49, 0x9d, 0x96, 0x7c, 0x08, 0xd3, 0x32, 0x4a, 0x19, 0xf7, 0x04, 0x17, 0x8f, 0x4a, 0xd2, 0x46,
	0x42, 0x46, 0x29, 0xd3, 0x3d, 0xc7, 0x0d, 0x7c, 0x7d, 0xa7, 0xee, 0xe8, 0xc8, 0xd6, 0x9f, 0x8c,
	0xf2, 0x79, 0x20, 0xc2, 0x0d, 0x6e, 0xc3, 0xf4, 0xdd, 0x6a, 0x65, 0x45, 0xbb, 0xf8, 0x32, 0xb3,
	0x55, 0xac, 0x3e, 0x89, 0x68, 0xd0, 0x76, 0x9b, 0x02, 0x61, 0x3f, 0x3e, 0x1b, 0x7c, 0xaf, 0x51,
	0x4f, 0xbf, 0x14, 0x4b, 0x70, 0x64, 0x75, 0x70, 0xe5, 0x46, 0xd5, 0x91, 0x1d, 0xb2, 0x8e, 0xd0,
	0x6d, 0x35, 0xfb, 0xd4, 0x61, 0x72, 0x24, 0x7b, 0x50, 0xbc, 0x89, 0x72, 0x8c, 0x56, 0x4b, 0x6e,
	0x70, 0x2d, 0xe7, 0x45, 0x2d, 0xcf, 0x73, 0x01, 0x28, 0xbd, 0x9e, 0x1e, 0xae, 0xf1, 0x02, 0xce,
	0x1f, 0xb9, 0x80, 0xff, 0x5a, 0x06, 0x46, 0xb9, 0xa0, 0x24, 0xe6, 0x57, 0x1f, 0x51, 0xec, 0xc1,
	0xd3, 0x11, 0xc5, 0x8a, 0xb8, 0x81, 0x1b, 0x33, 0x8d, 0x97, 0x91, 0x4a, 0x62, 0xc2, 0x4a, 0x4b,
	0x49, 0xbc, 0xc2, 0xe6, 0x25, 0x47, 0xcf, 0x57, 0x52, 0x8d, 0x3d, 0x84, 0xc7, 0x8e, 0x74, 0x42,
	0x93, 0x5e, 0xd5, 0x63, 0xc2, 0x43, 0xd8, 0xf4, 0x0b, 0x5e, 0x87, 0x71, 0xe1, 0x77, 0xbc, 0xbc,
	0x2f, 0x1e, 0xaa, 0x8a, 0xc6, 0x6b, 0x7c, 0x63, 0x79, 0x3f, 0x16, 0x02, 0x85, 0xe7, 0xb2, 0xb3,
	0xbd, 0x6f, 0xe4, 0x9f, 0x93, 0x88, 0xe4, 0x2e, 0xcf, 0xcb, 0xc4, 0x03, 0x32, 0x9a, 0x11, 0x98,
	0x15, 0x5c, 0x44, 0x34, 0x91, 0xce, 0x8b, 0x29, 0xf1, 0x17, 0x63, 0x1e, 0x64, 0x1d, 0x8a, 0x68,
	0xc1, 0x41, 0x1b, 0xdc, 0x9c, 0xa3, 0x5a, 0xe1, 0xbe, 0xad, 0xc2, 0x0a, 0x2f, 0xe2, 0x65, 0x8e,
	0x30, 0x04, 0x31, 0xdd, 0x4a, 0x7a, 0x28, 0x99, 0xe2, 0x56, 0x4c, 0xce, 0x3e, 0xf2, 0x0e, 0x4c,
	0xa8, 0x80, 0x98, 0xca, 0xb1, 0x0d, 0x2f, 0xac, 0xe3, 0x08, 0x9a, 0x66, 0x06, 0x20, 0x0d, 0x9d,
	0x2c, 0x41, 0x81, 0x2d, 0xe2, 0x64, 0xe6, 0xbb, 0xae, 0x80, 0xe9, 0xd6, 0xea, 0x12, 0x8f, 0xd4,
	0x60, 0x8e, 0x2d, 0x9a, 0x9a, 0xd7, 0xde, 0x6d, 0xd2, 0x75, 0x7f, 0xd7, 0xef, 0x46, 0xf7, 0xec,
	0x75, 0xb1, 0xb9, 0x72, 0x51, 0xd9, 0x6d, 0x35, 0x8d, 0xe2, 0xc0, 0xc8, 0x6b, 0x9c, 0x42, 0xad,
	0xed, 0x61, 0x7f, 0x98, 0x85, 0x09, 0x6d, 0x3e, 0x91, 0x4b, 0x50, 0xa8, 0x86, 0xeb, 0x7e, 0xfd,
	0xa1, 0x0a, 0x79, 0x35, 0x75, 0x78, 0x50, 0x1a, 0xf7, 0x42, 0xa7, 0x89, 0x40, 0x5b, 0x15, 0x93,
	0x65, 0x98, 0xe2, 0x7f, 0xc9, 0x40, 0xe5, 0xd9, 0xd8, 0xe8, 0x8e, 0x23, 0xcb, 0x10, 0xe5, 0xfa,
	0xbe, 0x66, 0x90, 0x90, 0xaf, 0x03, 0x70, 0x00, 0x3a, 0x49, 0xe6, 0x86, 0x77, 0xef, 0x14, 0x15,
	0xa4, 0xb8, 0x47, 0x6a, 0x0c, 0xc9, 0x37, 0x79, 0x00, 0x4d, 0x39, 0xff, 0xf3, 0xc3, 0xfb, 0xa7,
	0x32, 0xfe, 0x4e, 0xba, 0x9b, 0xbc, 0xce, 0x52, 0x44, 0xe7, 0x5b, 0xb4, 0x69, 0xdd, 0x7f, 0x44,
	0x83, 0xfd, 0x72, 0x84, 0x88, 0x1a, 0x86, 0xf5, 0x3f, 0x65, 0xb4, 0x55, 0x43, 0x36, 0x30, 0x59,
	0x23, 0x9f, 0x11, 0xc2, 0x66, 0x43, 0x09, 0xf3, 0x12, 0x6e, 0xd3, 0x9d, 0xe5, 0xe7, 0x85, 0xcd,
	0xe7, 0x9c, 0x9a, 0x57, 0x89, 0x24, 0x8e, 0x1c, 0x48, 0x3e, 0x80, 0x3c, 0x76, 0x5d, 0xf6, 0xc8,
	0x4f, 0x93, 0xe7, 0x69, 0x9e, 0xf5, 0x19, 0x7e, 0x08, 0x52, 0x92, 0xcf, 0x09, 0x07, 0x33, 0xde,
	0xf9, 0xd3, 0xda, 0xa1, 0xc8, 0xda, 0xa1, 0x0e, 0xd2, 0x38, 0x52, 0x82, 0x36, 0x7b, 0xfe, 0xad,
	0x2c, 0x14, 0x93, 0x6b, 0x95, 0xbc, 0x0f, 0x93, 0xf2, 0xa4, 0xc3, 0x6c, 0xde, 0xec, 0x2b, 0x27,
	0x45, 0x94, 0x6b, 0x79, 0xdc, 0x25, 0x93, 0x79, 0xeb, 0x04, 0x4c, 0xea, 0xd8, 0x12, 0x91, 0x8b,
	0xb4, 0x55, 0x12, 0xf9, 0x51, 0x27, 0x11, 0x83, 0x51, 0xa2, 0x91, 0x37, 0x21, 0x77, 0xe7, 0x46,
	0x59, 0x78, 0x33, 0xc8, 0x2d, 0xe9, 0xce, 0x8d, 0x32, 0x5f, 0xcd, 0xdc, 0x5a, 0xcb, 0xb4, 0x1d,
	0x63, 0xf8, 0x64, 0x5d, 0x0b, 0x71, 0x3a, 0x6a, 0xa4, 0x36, 0x92, 0x60, 0xf5, 0x71, 0x47, 0xc7,
	0x3a, 0xe5, 0x69, 0xc2, 0x45, 0xb0, 0xbf, 0x7f, 0x2f, 0x07, 0xe3, 0xaa, 0x7e, 0x42, 0x00, 0x85,
	0x2a, 0xa1, 0xc9, 0xe0, 0xdf, 0xe4, 0x34, 0x14, 0xa4, 0x1c, 0x25, 0x9c, 0x1a, 0xc6, 0x42, 0x21,
	0x43, 0x2d, 0x80, 0x14, 0x98, 0xf8, 0x32, 0xb7, 0xe5, 0x4f, 0x72, 0x15, 0x94, 0x34, 0xd4, 0x4f,
	0x6c, 0xca, 0xb3, 0x01, 0xb3, 0x15, 0x1a, 0x99, 0x86, 0xac, 0xc7, 0x03, 0xc8, 0x8c, 0xdb, 0x59,
	0xaf, 0x41, 0xde, 0x87, 0x82, 0xdb, 0x68, 0xd0, 0x86, 0xe3, 0x4a, 0xe3, 0x87, 0x41, 0x93, 0xa6,
	0xc0, 0xb8, 0xf1, 0x43, 0x00, 0xa9, 0xca, 0x11, 0x29, 0xc3, 0x78, 0xd3, 0xe5, 0xf6, 0x5c, 0x8d,
	0x21, 0x4e, 0x94, 0x98, 0x43, 0x81, 0x91, 0xdd, 0x0b, 0x69, 0x83, 0xbc, 0x02, 0x79, 0x36, 0x9a,
	0xe2, 0x08, 0x91, 0xe2, 0x1b, 0x1b, 0x4c, 0xde, 0x61, 0x6b, 0xcf, 0xd9, 0x88, 0x40, 0x5e, 0x82,
	0x5c, 0x77, 0x69, 0x47, 0x1c, 0x0e, 0xc5, 0x38, 0xdc, 0xb0, 0x42, 0x63, 0xc5, 0xe4, 0x1a, 0x14,
	0x1e, 0x9b, 0x91, 0x6a, 0x4f, 0x24, 0x86, 0x51, 0xe1, 0x2b, 0xc4, 0xe5, 0x02, 0x8c, 0xf2, 0x83,
	0xc0, 0x3a, 0x0b, 0x10, 0x57, 0xdd, 0xeb, 0x7b, 0x62, 0x7d, 0x1d, 0xc6, 0x55, 0x95, 0xe4, 0x0c,
	0xc0, 0x43, 0xba, 0xef, 0xec, 0xb9, 0xed, 0x46, 0x93, 0xcb, 0x77, 0x93, 0xf6, 0xf8, 0x43, 0xba,
	0xbf, 0x86, 0x00, 0x72, 0x0a, 0xc6, 0x3a, 0x6c, 0x54, 0xc5, 0xd4, 0x9d, 0xb4, 0x47, 0x3b, 0xdd,
	0x6d, 0x36, 0x43, 0x17, 0x60, 0x0c, 0x6f, 0xde, 0xc4, 0x42, 0x9b, 0xb2, 0xe5, 0x4f, 0xeb, 0x4f,
	0x73, 0x98, 0xa5, 0x41, 0x6b, 0x27, 0x39, 0x0f, 0x53, 0xf5, 0x80, 0xe2, 0x99, 0xe3, 0x32, 0x49,
	0x4a, 0xd4, 0x33, 0x19, 0x03, 0xab, 0x0d, 0x72, 0x01, 0x66, 0x44, 0x66, 0x7c, 0xd6, 0xa0, 0xfa,
	0xb6, 0x08, 0x2b, 0x3d, 0x69, 0x4f, 0x71, 0xf0, 0x6d, 0xba, 0xbf, 0xb2, 0x8d, 0x81, 0x8f, 0x8a,
	0x7a, 0xdc, 0xca, 0x48, 0x25, 0x34, 0xb5, 0x67, 0x34, 0x38, 0xda, 0x34, 0x9d, 0x84, 0x51, 0xd7,
	0xdd, 0xed, 0x7a, 0x3c, 0x40, 0xc9, 0xa4, 0x2d, 0x7e, 0x91, 0xd7, 0x60, 0x36, 0x0e, 0x6f, 0x2a,
	0x3f, 0x63, 0x04, 0x3f, 0xa3, 0xa8, 0x0a, 0x56, 0x38, 0x9c, 0xbc, 0x01, 0x44, 0xaf, 0xcf, 0xdf,
	0xfe, 0x88, 0xd6, 0xf9, 0x54, 0x9b, 0xb4, 0x67, 0xb5, 0x92, 0xbb, 0x58, 0x40, 0x5e, 0x84, 0xc9,
	0x80, 0x86, 0x28, 0xc5, 0x61, 0xb7, 0x61, 0x12, 0x23, 0x7b, 0x42, 0xc2, 0x58, 0xdf, 0x5d, 0x84,
	0xa2, 0xd6, 0x1d, 0x18, 0x1a, 0x94, 0xc7, 0x54, 0xb6, 0xa7, 0x63, 0xb8, 0xdd, 0xa9, 0x36, 0xc8,
	0x57, 0x60, 0x51, 0xc3, 0xe4, 0xf9, 0x94, 0x1c, 0xda, 0xf4, 0x76, 0xbd, 0xed, 0x26, 0x15, 0xd3,
	0xa8, 0x77, 0xb2, 0x2a, 0x1d, 0xcc, 0x5e, 0x88, 0xa9, 0x79, 0xa6, 0xa5, 0x55, 0x41, 0x4b, 0xd6,
	0x61, 0x3e, 0xc1, 0x99, 0x36, 0x9c, 0x6e, 0xa7, 0x6f, 0x44, 0xa0, 0x98, 0x27, 0x31, 0x79, 0xd2,
	0xc6, 0xbd, 0x8e, 0xb5, 0x0c, 0xb3, 0x3d, 0x3b, 0x8c, 0x96, 0x2c, 0x9b, 0xef, 0x98, 0x83, 0x93,
	0x65, 0x5b, 0x6d, 0x98, 0xd4, 0x4f, 0x8c, 0x23, 0x42, 0x90, 0x9f, 0x44, 0x47, 0x7c, 0xbe, 0x9d,
	0x8e, 0x1e, 0x1e, 0x94, 0xb2, 0x5e, 0x03, 0xdd, 0xef, 0x2f, 0x42, 0x41, 0x0a, 0x37, 0x42, 0xa6,
	0xc0, 0x1b, 0x5e, 0x21, 0x55, 0xef, 0xdb, 0xaa, 0xd4, 0x7a, 0x05, 0xc6, 0xc4, 0xa1, 0x30, 0xf8,
	0x5e, 0xd7, 0xfa, 0xa1, 0x2c, 0xcc, 0xd8, 0x94, 0x6d, 0x59, 0x94, 0xe7, 0x1d, 0x78, 0x66, 0xd5,
	0xcc, 0xf4, 0x70, 0x6e, 0xc6, 0xb7, 0x0d, 0x88, 0xf8, 0xff, 0xf7, 0x33, 0x30, 0x97, 0x82, 0xfb,
	0xb1, 0x32, 0xde, 0x5d, 0x87, 0xf1, 0x8a, 0xe7, 0x36, 0xcb, 0x8d, 0x86, 0xf2, 0xca, 0x47, 0x91,
	0x18, 0xd3, 0x62, 0xb8, 0x0c, 0xaa, 0x8b, 0x07, 0x0a, 0x95, 0xbc, 0x2a, 0x26, 0x45, 0x9c, 0xed,
	0x1e, 0x27, 0xc5, 0x77, 0x0f, 0x4a, 0xc0, 0xdb, 0x14, 0x67, 0xf5, 0xc5, 0x10, 0x8b, 0x1c, 0x18,
	0x5b, 0xcd, 0x3f, 0xb3, 0x43, 0x97, 0x1e, 0x62, 0x31, 0xf9, 0x79, 0x43, 0x05, 0xfd, 0xff, 0xb1,
	0x2c, 0x9c, 0x4c, 0x27, 0xfc, 0xb8, 0xc9, 0x0b, 0x31, 0xdd, 0x82, 0x16, 0x16, 0x16, 0x93, 0x17,
	0xf2, 0xdc, 0x0c, 0x88, 0x1f, 0x23, 0x90, 0x1d, 0x98, 0x5a, 0x77, 0xc3, 0x68, 0x8d, 0xba, 0x41,
	0xb4, 0x4d, 0xdd, 0x68, 0x08, 0x19, 0xf9, 0x25, 0xf9, 0x7c, 0x8a, 0xc7, 0xf4, 0x9e, 0xa4, 0x4c,
	0x48, 0xb1, 0x26, 0x5b, 0x35, 0x51, 0xf2, 0x43, 0x4c, 0x94, 0x6f, 0xc1, 0x4c, 0x8d, 0xb6, 0xdc,
	0xce, 0x9e, 0x1f, 0x48, 0xb7, 0xcb, 0xcb, 0x30, 0xa5, 0x40, 0xa9, 0xb3, 0xc5, 0x2c, 0x36, 0xf0,
	0xb5, 0x8e, 0x88, 0xb7, 0x12, 0xb3, 0xd8, 0xfa, 0x5b, 0x59, 0x38, 0x55, 0xae, 0x0b, 0xab, 0x26,
	0x51, 0x20, 0x8d, 0x2f, 0x3f, 0xe5, 0xba, 0xc9, 0x15, 0x18, 0xbf, 0xe3, 0x3e, 0x59, 0xa7, 0x6e,
	0x48, 0x43, 0x91, 0x3a, 0x8a, 0x0b, 0x94, 0xee, 0x93, 0xd8, 0xd8, 0xc7, 0x8e, 0x71, 0x74, 0x8d,
	0x3b, 0xff, 0x09, 0x35, 0x6e, 0x0b, 0x46, 0xd7, 0xfc, 0x66, 0x43, 0x1c, 0xb7, 0xe2, 0x19, 0x70,
	0x0f, 0x21, 0xb6, 0x28, 0x61, 0x8a, 0xea, 0xb4, 0x6a, 0x31, 0x36, 0xe1, 0x53, 0xef, 0x92, 0x0b,
	0x30, 0x86, 0x15, 0xa9, 0xe4, 0xbb, 0x78, 0x68, 0x34, 0x29, 0x26, 0x00, 0x6a, 0xd8, 0xb2, 0x50,
	0xef, 0x89, 0x91, 0x4f, 0xd6, 0x13, 0xd6, 0xbf, 0x8f, 0x2f, 0x8c, 0xfa, 0x57, 0xb2, 0x93, 0x48,
	0x6b, 0x48, 0x66, 0xc8, 0x86, 0x64, 0x9f, 0xda, 0x90, 0xe4, 0xfa, 0x0e, 0xc9, 0x0f, 0x67, 0x61,
	0x42, 0x35, 0xf6, 0x33, 0x16, 0x9b, 0x58, 0x7d, 0xd7, 0x50, 0xa1, 0x12, 0x6a, 0xda, 0x5e, 0x21,
	0x22, 0x12, 0x7c, 0x00, 0xa3, 0x62, 0x31, 0x65, 0x12, 0x46, 0x88, 0x89, 0xd1, 0x5d, 0x9e, 0x16,
	0xac, 0x47, 0x71, 0x40, 0x43, 0x5b, 0xd0, 0x61, 0x2c, 0x8a, 0x07, 0x74, 0x5b, 0x3c, 0x38, 0x3f,
	0xb3, 0x67, 0x54, 0x7a, 0x2c, 0x8a, 0xf8, 0xc3, 0x86, 0x3a, 0x9d, 0xfe, 0x71, 0x01, 0x8a, 0x49,
	0x92, 0xa3, 0xa3, 0x3f, 0x6f, 0x76, 0xb7, 0xb9, 0xb6, 0xc0, 0xa3, 0x3f, 0x77, 0xba, 0xdb, 0x36,
	0x83, 0xa1, 0x3d, 0x4a, 0xe0, 0x3d, 0xc2, 0xaf, 0x9e, 0x14, 0xf6, 0x28, 0x81, 0xf7, 0xc8, 0xb0,
	0x47, 0x09, 0xbc, 0x47, 0xa8, 0xa2, 0xaf, 0xd7, 0xd0, 0x7d, 0x16, 0x55, 0x05, 0xa1, 0xa2, 0x37,
	0xc3, 0x64, 0x46, 0x16, 0x89, 0xc6, 0x8e, 0xca, 0x65, 0xea, 0x06, 0x22, 0x52, 0xb1, 0xd8, 0xce,
	0xf0, 0xa8, 0xdc, 0x46, 0x30, 0x4f, 0xa0, 0x6c, 0xeb, 0x48, 0xa4, 0x09, 0x44, 0xfb, 0x29, 0x17,
	0xf0, 0xd1, 0x5a, 0xab, 0x34, 0x20, 0x9a, 0xd7, 0x59, 0x3b, 0xfa, 0x6a, 0x4e, 0xe1, 0xfb, 0x34,
	0x2f, 0x4a, 0x37, 0x45, 0xf8, 0x35, 0xbc, 0x9a, 0x29, 0x1c, 0xc9, 0x4c, 0xfa, 0x97, 0x03, 0x0f,
	0xcf, 0xa6, 0x2e, 0x68, 0x62, 0x26, 0xe4, 0x3d, 0x98, 0xd0, 0x9d, 0xa2, 0xb9, 0xeb, 0xee, 0x0b,
	0x3c, 0xa2, 0x56, 0x9f, 0x1c, 0x7e, 0x3a, 0x01, 0xd9, 0x86, 0x53, 0x2b, 0x7e, 0x3b, 0xec, 0xb6,
	0x64, 0xec, 0xae, 0x38, 0x62, 0x28, 0xe0, 0x50, 0xa0, 0x87, 0x65, 0x5d, 0xa0, 0x08, 0x1f, 0x5c,
	0x69, 0xe1, 0x6d, 0x2a, 0x20, 0xfd, 0x18, 0x91, 0x2d, 0x98, 0xc0, 0xcb, 0x46, 0x61, 0x42, 0x36,
	0x61, 0x6e, 0x1b, 0x71, 0x49, 0x85, 0x2d, 0x0c, 0x1e, 0x7c, 0xc6, 0x6d, 0x35, 0xa5, 0x81, 0xb1,
	0x7e, 0x69, 0xaa, 0x21, 0x93, 0xaf, 0xc3, 0x34, 0x57, 0x8b, 0x1f, 0xd0, 0x6d, 0x3e, 0x77, 0x26,
	0x0d, 0x1d, 0xdf, 0x2c, 0xe4, 0x0f, 0xd2, 0xe2, 0x8a, 0xf7, 0x31, 0xdd, 0xe6, 0x63, 0x6f, 0x98,
	0xf7, 0x1b, 0xf8, 0xe4, 0x1e, 0xcc, 0xad, 0xb9, 0x21, 0x07, 0x6a, 0xde, 0xad, 0x53, 0x78, 0xf7,
	0x89, 0x66, 0x97, 0x7b, 0x6e, 0x28, 0xef, 0x8c, 0x53, 0xbd, 0x59, 0xd3, 0xe8, 0xc9, 0x0f, 0x65,
	0x60, 0xc1, 0xb8, 0x52, 0x16, 0xc6, 0x3f, 0x2d, 0xda, 0x8e, 0xd0, 0x8e, 0x7f, 0x5a, 0xa5, 0x6e,
	0xee, 0x87, 0xc6, 0x87, 0x24, 0x71, 0x6b, 0x1d, 0xc4, 0xe5, 0xba, 0x3d, 0x63, 0x3f, 0x1e, 0x62,
	0xa1, 0xe2, 0x9a, 0x9e, 0x31, 0x17, 0x6a, 0x62, 0x5d, 0x4b, 0x34, 0xeb, 0x7a, 0xb2, 0xbf, 0xc5,
	0x15, 0x52, 0x46, 0x5d, 0x21, 0xcd, 0xc3, 0x08, 0xf6, 0xaa, 0x0c, 0xc6, 0x81, 0x3f, 0xac, 0xcf,
	0xe9, 0xfb, 0x90, 0x10, 0x0b, 0x07, 0xee, 0x43, 0xd6, 0x7f, 0x37, 0x0a, 0x33, 0x89, 0x69, 0x21,
	0xf4, 0xd4, 0x4c, 0x8f, 0x9e, 0x5a, 0x03, 0xe0, 0x97, 0xa8, 0x43, 0xde, 0x76, 0x4a, 0x1f, 0xa2,
	0x09, 0xe1, 0x0a, 0xa8, 0xd6, 0x94, 0xc6, 0x86, 0x31, 0xe5, 0x2b, 0x76, 0xc8, 0xdb, 0x67, 0xc5,
	0x94, 0x2f, 0x7a, 0x8d, 0x69, 0xcc, 0x86, 0x94, 0x60, 0x04, 0x23, 0xe8, 0xe9, 0x2e, 0x5c, 0x1e,
	0x03, 0xd8, 0x1c, 0x4e, 0xce, 0xc3, 0x28, 0x13, 0xa2, 0xaa, 0x15, 0xb1, 0x09, 0xe2, 0xd9, 0xc2,
	0xa4, 0x2c, 0x26, 0xb1, 0x88, 0x22, 0x72, 0x1d, 0x26, 0xf9, 0x5f, 0x22, 0x88, 0xc2, 0xa8, 0x69,
	0x91, 0xe6, 0x78, 0x0d, 0x19, 0x47, 0xc1, 0xc0, 0x63, 0xda, 0x45, 0xad, 0x8b, 0x37, 0x2b, 0xd5,
	0x8a, 0x08, 0xb9, 0x8a, 0xda, 0x45, 0xc8, 0x81, 0x98, 0x1a, 0x5d, 0x21, 0x30, 0x59, 0x46, 0x18,
	0x52, 0x17, 0x50, 0xa7, 0x44, 0x59, 0x86, 0x1b, 0x50, 0xdb, 0xa2, 0x84, 0x5c, 0xe2, 0x8f, 0x16,
	0x28, 0x16, 0xf2, 0x0c, 0x54, 0xf8, 0x22, 0x80, 0x17, 0x13, 0x28, 0x1b, 0xaa, 0x62, 0x56, 0x39,
	0xfb, 0x7b, 0xb5, 0xe5, 0x7a, 0x4d, 0xb1, 0xad, 0x60, 0xe5, 0x88, 0x4b, 0x19, 0xd4, 0x8e, 0x11,
	0xc8, 0x3b, 0x30, 0xcd, 0x7e, 0xac, 0xf8, 0xad, 0x96, 0xdf, 0x46, 0xf6, 0x13, 0x71, 0x3c, 0x1e,
	0x24, 0xa9, 0x63, 0x11, 0xaf, 0x25, 0x81, 0xcb, 0xce, 0x13, 0x7c, 0x10, 0xed, 0xf2, 0xe7, 0x94,
	0xc9, 0xf8, 0x3c, 0x41, 0xd2, 0x90, 0xc3, 0x6d, 0x1d, 0x89, 0xbc, 0x05, 0x53, 0xec, 0xe7, 0x4d,
	0xef, 0x11, 0xe5, 0x15, 0x4e, 0xc5, 0x4f, 0xf4, 0x48, 0xb5, 0xcb, 0x4a, 0x78, 0x7d, 0x26, 0x26,
	0xf9, 0x32, 0x9c, 0x40, 0x4e, 0x75, 0xbf, 0x43, 0x1b, 0xe5, 0x9d, 0x1d, 0xaf, 0xe9, 0x71, 0x13,
	0x21, 0x1e, 0x2e, 0x00, 0x6f, 0xb7, 0x79, 0xc5, 0x88, 0xe1, 0xb8, 0x31, 0x8a, 0x9d, 0x4e, 0x49,
	0x1e, 0x40, 0x71, 0xa5, 0x1b, 0x46, 0x7e, 0xab, 0x1c, 0x45, 0x81, 0xb7, 0xdd, 0x8d, 0x68, 0xb8,
	0x30, 0x63, 0x38, 0xd5, 0xb3, 0xc5, 0xa1, 0x0a, 0xf9, 0x7d, 0x50, 0x1d, 0x29, 0x1c, 0x57, 0x91,
	0xd8, 0x3d, 0x4c, 0xac, 0xff, 0x36, 0x03, 0x53, 0x06, 0x29, 0x79, 0x13, 0x26, 0x6f, 0x04, 0x1e,
	0x6d, 0x37, 0x9a, 0xfb, 0x9a, 0xa2, 0x8a, 0x5a, 0xcc, 0x8e, 0x80, 0xf3, 0xaf, 0x36, 0xd0, 0xd4,
	0x3d, 0x4f, 0x36, 0xd5, 0x7e, 0xef, 0x0a, 0xf7, 0x24, 0x14, 0x13, 0x34, 0x17, 0x47, 0xf9, 0xc0,
	0x09, 0x2a, 0x66, 0xa7, 0x86, 0x42, 0xde, 0x85, 0x51, 0xfe, 0x74, 0x2a, 0x8c, 0xc9, 0x4e, 0xa7,
	0x7d, 0x26, 0xf7, 0x5a, 0xc5, 0x89, 0x88, 0x86, 0x2b, 0xa1, 0x2d, 0x88, 0xac, 0x9f, 0xce, 0x00,
	0xe9, 0x45, 0x3d, 0xe2, 0xde, 0xeb, 0x48, 0x83, 0x98, 0x0f, 0xd4, 0x6a, 0xcc, 0x19, 0xb7, 0xd1,
	0xac, 0x26, 0x5e, 0xc0, 0x3b, 0x5e, 0xac, 0x3a, 0xfd, 0x22, 0x8e, 0x17, 0x5b, 0x3f, 0x98, 0x05,
	0x88, 0xb1, 0xc9, 0x17, 0x79, 0xa2, 0x92, 0x2f, 0x77, 0xdd, 0xa6, 0xb7, 0xe3, 0x99, 0x91, 0xfb,
	0x90, 0xc9, 0xb7, 0x64, 0x89, 0x6d, 0x22, 0x92, 0xf7, 0x61, 0xa6, 0xb6, 0x69, 0xd2, 0x6a, 0x49,
	0x19, 0xc2, 0x8e, 0x93, 0x20, 0x4f, 0x62, 0xa3, 0xd1, 0xa8, 0x3e, 0x1a, 0xdc, 0x68, 0x94, 0x0f,
	0x84, 0x28, 0x61, 0x1b, 0x4b, 0x6d, 0x53, 0xd8, 0x29, 0x37, 0xaa, 0x15, 0xb1, 0x4b, 0x61, 0xeb,
	0xc2, 0x8e, 0xd3, 0x11, 0x06, 0xcc, 0x6c, 0x9f, 0x30, 0xf0, 0xe2, 0x8e, 0x1c, 0xe9, 0xe3, 0x99,
	0xfa, 0x33, 0x78, 0xed, 0xd7, 0xf2, 0x23, 0x2a, 0x6e, 0x3b, 0x9e, 0x59, 0xbd, 0x27, 0x7e, 0x77,
	0x1f, 0x31, 0x1c, 0xee, 0x8c, 0xaf, 0x13, 0x56, 0x1f, 0xd7, 0x62, 0x25, 0x85, 0xbf, 0xc0, 0xa7,
	0xd8, 0x89, 0xfc, 0xdd, 0x0c, 0x9c, 0x48, 0xa5, 0x25, 0x97, 0x01, 0xe2, 0x3b, 0x25, 0xd1, 0x4b,
	0xb8, 0x63, 0xc6, 0xb1, 0x2d, 0x6c, 0x0d, 0x83, 0x7c, 0x2d, 0x79, 0x1b, 0x74, 0xf4, 0x41, 0xb8,
	0x28, 0x63, 0x17, 0x99, 0xb7, 0x41, 0x29, 0x77, 0x40, 0xd6, 0xdf, 0xcf, 0xc1, 0xac, 0x16, 0x3a,
	0x83, 0xb7, 0xf5, 0x08, 0x23, 0xde, 0x87, 0x30, 0xc9, 0xbe, 0xc6, 0xab, 0x0b, 0xaf, 0x1f, 0x6e,
	0x23, 0xf2, 0x6a, 0x8f, 0xcb, 0x94, 0xe0, 0x76, 0x59, 0x47, 0xe6, 0x11, 0xc5, 0x70, 0xeb, 0xc4,
	0x37, 0x81, 0x7a, 0xaf, 0xf7, 0x8f, 0xc1, 0x9c, 0x84, 0x30, 0x55, 0xd9, 0x6f, 0xbb, 0x2d, 0x55,
	0x1b, 0xb7, 0x15, 0x79, 0xad, 0x6f, 0x6d, 0x06, 0x36, 0xaf, 0x2e, 0x76, 0x2e, 0xe0, 0x65, 0x29,
	0x7e, 0xad, 0x06, 0xd5, 0xe2, 0xfb, 0x30, 0xdb, 0xd3, 0xe8, 0x63, 0x05, 0x37, 0x7b, 0x00, 0xa4,
	0xb7, 0x1d, 0x29, 0x1c, 0x5e, 0x33, 0x43, 0xe7, 0x9d, 0x50, 0xcf, 0xc2, 0x98, 0x92, 0x99, 0x5b,
	0x9e, 0x2c, 0xe9, 0xa1, 0xcf, 0x7e, 0x26, 0xab, 0xbb, 0xad, 0x3d, 0xeb, 0xab, 0xee, 0x03, 0x43,
	0x1b, 0x3e, 0xdb, 0x6f, 0x4c, 0x87, 0xba, 0x75, 0xf8, 0x4e, 0x0e, 0x4e, 0xf5, 0xa1, 0x24, 0xfb,
	0xc9, 0x49, 0xc4, 0x6f, 0x21, 0xae, 0x0e, 0xae, 0xf0, 0x69, 0x4c, 0x25, 0xf2, 0x45, 0xee, 0xb8,
	0x5e, 0xc7, 0xb4, 0xbf, 0x42, 0xff, 0xe6, 0x59, 0xe8, 0x15, 0x34, 0xe9, 0xb1, 0xce, 0xa1, 0xe4,
	0x7d, 0x18, 0x41, 0x9f, 0xc5, 0x44, 0xe8, 0x2e, 0x86, 0x81, 0x70, 0x2d, 0xce, 0x19, 0xfb, 0x69,
	0xc4, 0x39, 0x63, 0x00, 0xf2, 0x05, 0xc8, 0x95, 0x1f, 0xd4, 0xc4, 0xb8, 0x4c, 0xeb, 0xe4, 0x0f,
	0x6a, 0x71, 0x78, 0x75, 0xd7, 0x88, 0x83, 0xce, 0x28, 0x18, 0xe1, 0xcd, 0x95, 0x4d, 0x31, 0x2a,
	0x3a, 0xe1, 0xcd, 0x95, 0xcd, 0x98, 0x70, 0xb7, 0x6e, 0x84, 0x42, 0xb9, 0xb9, 0xb2, 0xf9, 0xe9,
	0x4d, 0xfb, 0x7f, 0x33, 0xcb, 0xbd, 0xed, 0xf9, 0x87, 0xbd, 0x0f, 0x93, 0x46, 0x68, 0xd3, 0x4c,
	0x2c, 0x8f, 0xa9, 0x08, 0xb2, 0x09, 0xe3, 0x1a, 0x83, 0x40, 0x26, 0x2a, 0x60, 0xbf, 0x51, 0xe2,
	0xd5, 0xcd, 0x58, 0x14, 0x07, 0x94, 0x89, 0x93, 0x89, 0x0a, 0x14, 0x09, 0xb9, 0x06, 0x85, 0x2d,
	0xda, 0x76, 0xdb, 0x91, 0xba, 0x10, 0x45, 0x03, 0xd9, 0x08, 0x61, 0xa6, 0xd4, 0xa0, 0x10, 0xd1,
	0x98, 0xb3, 0xbb, 0x1d, 0xd6, 0x03, 0x0f, 0xa3, 0x72, 0xa8, 0xb3, 0x98, 0x1b, 0x73, 0x6a, 0x25,
	0x26, 0x83, 0x04, 0x91, 0xf5, 0x33, 0x19, 0x18, 0x13, 0x03, 0xc9, 0x13, 0xcc, 0xec, 0xc6, 0x67,
	0x89, 0x48, 0x30, 0xb3, 0xeb, 0x25, 0x13, 0xcc, 0xec, 0xf2, 0xd0, 0x17, 0xe3, 0xc2, 0x71, 0x54,
	0x3d, 0x0d, 0xf2, 0x5c, 0xe7, 0x1c, 0x68, 0x56, 0x1b, 0xa3, 0x0e, 0xeb, 0x25, 0x63, 0xfd, 0x6d,
	0xd1, 0xb2, 0x9b, 0x2b, 0x9b, 0x64, 0x09, 0x0a, 0xeb, 0x3e, 0x0f, 0x74, 0xa2, 0x67, 0x0b, 0x6c,
	0x0a, 0x98, 0xde, 0x41, 0x12, 0x8f, 0xb5, 0x6f, 0x33, 0xf0, 0x85, 0x2e, 0xa3, 0xb5, 0xaf, 0xc3,
	0x81, 0x89, 0xf6, 0x29, 0xd4, 0xa1, 0xdb, 0x47, 0x53, 0x36, 0x89, 0xfb, 0xd7, 0x30, 0x82, 0xfb,
	0x2d, 0xdd, 0xfb, 0x48, 0x14, 0xc9, 0x9d, 0x62, 0xb1, 0xdf, 0x4e, 0x71, 0xff, 0x9a, 0x9d, 0x42,
	0x85, 0xef, 0x6a, 0x31, 0xb8, 0x46, 0x83, 0x47, 0xcf, 0xf0, 0x2e, 0x9d, 0xfe, 0xae, 0x96, 0xfc,
	0xbc, 0xa1, 0x36, 0xe9, 0xff, 0x3a, 0x0b, 0x27, 0xd3, 0x09, 0xf5, 0x6f, 0xc9, 0x0c, 0xf8, 0x96,
	0x8b, 0x50, 0x58, 0xf3, 0xc3, 0x48, 0xb3, 0xa7, 0xc3, 0xeb, 0xff, 0x3d, 0x01, 0xb3, 0x55, 0x29,
	0xd3, 0xb9, 0xd9, 0xdf, 0x6a, 0x79, 0x22, 0x3f, 0xf4, 0x31, 0x67, 0x3a, 0x37, 0x2f, 0x22, 0x37,
	0xa1, 0x60, 0x0b, 0xef, 0x97, 0x44, 0xd7, 0x48, 0xb0, 0x92, 0xa6, 0x48, 0x20, 0x20, 0x46, 0x84,
	0x59, 0x01, 0x23, 0x65, 0x18, 0x13, 0xa3, 0x9f, 0x78, 0x3a, 0x4e, 0x99, 0x32, 0x66, 0xd0, 0x67,
	0x49, 0xc7, 0x76, 0x14, 0x7c, 0x04, 0xac, 0x56, 0xa4, 0x23, 0x0b, 0xee, 0x28, 0xfc, 0x91, 0xd0,
	0x34, 0x5d, 0x54, 0x88, 0xd6, 0x0f, 0x65, 0x01, 0xe4, 0xad, 0xcd, 0x33, 0x3b, 0xc3, 0xbe, 0x60,
	0xcc, 0x30, 0xcd, 0x92, 0x67, 0xf8, 0x84, 0x88, 0x77, 0xd1, 0xa2, 0x66, 0xf8, 0x74, 0x88, 0x25,
	0x18, 0xd9, 0x8a, 0x2f, 0xb4, 0x84, 0x5b, 0x05, 0x5e, 0x47, 0x73, 0xb8, 0xb5, 0x0d, 0xf3, 0x37,
	0x69, 0x14, 0x5f, 0x6f, 0xc9, 0xa7, 0xc7, 0xc1, 0x6c, 0x5f, 0x87, 0x71, 0x81, 0xaf, 0xf6, 0x2f,
	0x7e, 0x17, 0x23, 0xc2, 0x36, 0xe0, 0x5d, 0x8c, 0x44, 0x60, 0xbb, 0x51, 0x85, 0x36, 0x69, 0x44,
	0x3f, 0xdd, 0x6a, 0x6a, 0x40, 0xf8, 0xa7, 0xe0, 0x97, 0x0d, 0x57, 0xc3, 0x91, 0xfd, 0x73, 0x1f,
	0x4e, 0xa8, 0xb6, 0x3f, 0x4d, 0xbe, 0x57, 0x98, 0x4a, 0x29, 0xe2, 0x25, 0xc7, 0x1c, 0x07, 0xd8,
	0x9e, 0x3c, 0x81, 0x45, 0x49, 0xf0, 0xc0, 0x53, 0x26, 0x89, 0x43, 0xd1, 0x92, 0x77, 0x60, 0x42,
	0xa3, 0x11, 0xf1, 0x7e, 0xf1, 0x9a, 0xfa, 0xb1, 0x17, 0xed, 0x39, 0x21, 0x87, 0xeb, 0xd7, 0xd4,
	0x1a, 0xba, 0xf5, 0x55, 0x78, 0x5e, 0xb9, 0xbe, 0xa4, 0x54, 0x9d, 0x60, 0x9e, 0x39, 0x1e, 0xf3,
	0x8d, 0xf8, 0xb3, 0xaa, 0x6d, 0xe5, 0xae, 0x2a, 0x79, 0x13, 0xfd, 0xb3, 0xc4, 0xc7, 0xbc, 0xd0,
	0xe3, 0x00, 0xab, 0xf9, 0xb9, 0x5a, 0x6f, 0x6b, 0x8d, 0x4d, 0x61, 0x68, 0x10, 0x67, 0x92, 0xc4,
	0x3f, 0x94, 0x85, 0x99, 0xbb, 0xd5, 0xca, 0x8a, 0xb2, 0x3e, 0xfa, 0x8c, 0xa5, 0x6b, 0x34, 0xbe,
	0xad, 0xff, 0x7e, 0x63, 0xdd, 0x83, 0xb9, 0x44, 0x37, 0xa0, 0xe8, 0xf0, 0x1e, 0xf7, 0xcd, 0x50,
	0x60, 0x29, 0x36, 0x9c, 0x4c, 0x63, 0x7f, 0xff, 0x9a, 0x9d, 0xc0, 0xb6, 0xfe, 0xc9, 0x78, 0x82,
	0xaf, 0xd8, 0xc2, 0x5e, 0x87, 0xf1, 0x6a, 0x18, 0x76, 0x69, 0x70, 0xcf, 0x5e, 0xd7, 0xaf, 0x0a,
	0x3c, 0x04, 0x3a, 0xdd, 0xa0, 0x69, 0xc7, 0x08, 0xe4, 0x12, 0x14, 0x44, 0x08, 0x5c, 0xb9, 0x27,
	0xe0, 0xad, 0xad, 0x8a, 0xa0, 0x6b, 0xab, 0x62, 0xf2, 0x26, 0x4c, 0xf2, 0xbf, 0xf9, 0x6c, 0x13,
	0x1d, 0x8e, 0x97, 0x83, 0x02, 0x9d, 0xcf, 0x4e, 0xdb, 0x40, 0x23, 0xaf, 0x42, 0xae, 0xbc, 0x62,
	0x8b, 0xeb, 0x20, 0x21, 0x37, 0x62, 0x12, 0xe6, 0x2e, 0x35, 0x95, 0x88, 0x15, 0x9b, 0x49, 0x7f,
	0xd2, 0x35, 0x5e, 0xdc, 0x64, 0xf3, 0x5c, 0xd1, 0x02, 0x96, 0x38, 0xcc, 0x10, 0x46, 0xae, 0xc0,
	0x58, 0xc5, 0x0b, 0x3b, 0x4d, 0x77, 0x5f, 0xdc, 0x63, 0xf3, 0x5c, 0x44, 0x1c, 0x64, 0x78, 0xbc,
	0x73, 0x10, 0xb9, 0x24, 0x73, 0xb4, 0x14, 0x62, 0x17, 0x8f, 0x3e, 0x89, 0x58, 0x5e, 0x87, 0x51,
	0x11, 0x28, 0x76, 0x5c, 0x0b, 0x01, 0x9f, 0x0c, 0x10, 0x2b, 0x70, 0x7a, 0x9d, 0x30, 0xe1, 0x69,
	0x3a, 0x61, 0x6e, 0xc3, 0xa9, 0x9b, 0x78, 0x7b, 0x63, 0xc6, 0x72, 0xb9, 0x67, 0x57, 0xc5, 0x7d,
	0x38, 0x3e, 0x03, 0xf1, 0x0b, 0x9e, 0x64, 0x38, 0x18, 0xa7, 0x1b, 0xe8, 0xa9, 0xf5, 0xfa, 0x31,
	0x22, 0x5f, 0x81, 0xf9, 0xb4, 0x22, 0x71, 0x6b, 0x8e, 0x51, 0x4b, 0xd2, 0x2b, 0xd0, 0xa3, 0x96,
	0xa4, 0x71, 0x20, 0xeb, 0x50, 0xe4, 0xf0, 0x72, 0xa3, 0xe5, 0xb5, 0xf9, 0xcd, 0x3f, 0xbf, 0x55,
	0x47, 0x9f, 0x0b, 0xc1, 0xd5, 0x65, 0x85, 0xfc, 0x05, 0xc0, 0xf0, 0xd2, 0x49, 0x50, 0x92, 0x9f,
	0xc8, 0x30, 0x6d, 0x8e, 0x87, 0x55, 0xbd, 0x67, 0xaf, 0x87, 0x22, 0xe2, 0xd5, 0xc9, 0xd8, 0x01,
	0xa7, 0x16, 0x05, 0x5e, 0x7b, 0x57, 0x78, 0xe0, 0x6c, 0x09, 0x0f, 0x9c, 0x77, 0x3e, 0x96, 0x07,
	0x0e, 0x67, 0x15, 0x1e, 0x1e, 0x94, 0x26, 0x03, 0x51, 0x27, 0xae, 0x22, 0xa3, 0x05, 0x98, 0x16,
	0xbe, 0xd9, 0xf4, 0x1f, 0xdf, 0x6b, 0xf3, 0xa0, 0x8e, 0xb4, 0xc1, 0x3f, 0x72, 0x06, 0x77, 0x70,
	0x9e, 0x16, 0x9e, 0x95, 0x3b, 0x5d, 0x85, 0xd0, 0xf3, 0xa1, 0xa9, 0x1c, 0x98, 0xe2, 0x29, 0xbd,
	0x3c, 0xb8, 0x47, 0x69, 0x31, 0x56, 0x3c, 0xa5, 0x4b, 0x88, 0x83, 0xd3, 0x48, 0x9f, 0x3c, 0x06,
	0x09, 0xb9, 0x02, 0xa3, 0x77, 0xdc, 0x27, 0xe5, 0x5d, 0x2a, 0x72, 0x6f, 0x4d, 0xc9, 0xed, 0x0f,
	0x81, 0xcb, 0x85, 0xdf, 0xe7, 0x5e, 0x04, 0xcf, 0xd9, 0x02, 0x8d, 0x7c, 0x5f, 0x06, 0x4e, 0xf2,
	0x65, 0x2c, 0xbf, 0xb2, 0x46, 0xa3, 0x88, 0xf5, 0x83, 0x08, 0x7d, 0x25, 0x33, 0x57, 0xd4, 0x6a,
	0x77, 0xd3, 0xf1, 0x78, 0x12, 0x73, 0xb1, 0x33, 0xa8, 0x8e, 0x0b, 0x45, 0xa9, 0x11, 0x66, 0x33,
	0x95, 0x5e, 0x58, 0xc8, 0x7f, 0x41, 0xb6, 0x9c, 0xbc, 0xa1, 0x3b, 0x3e, 0xe6, 0x50, 0xce, 0x1d,
	0x6b, 0xb9, 0x4f, 0x1c, 0x77, 0x97, 0x1a, 0xef, 0xd9, 0xe2, 0x9e, 0xf9, 0xa7, 0x32, 0x70, 0xba,
	0x6f, 0xe3, 0xc8, 0x75, 0x38, 0x25, 0xf3, 0xd9, 0xef, 0x45, 0x51, 0x27, 0x74, 0xa4, 0x32, 0x20,
	0x5c, 0x25, 0xed, 0x13, 0xa2, 0x78, 0x8d, 0x95, 0x4a, 0xfd, 0x20, 0x24, 0xef, 0xc3, 0x0b, 0x5e,
	0x3b, 0xa4, 0xf5, 0x6e, 0x40, 0xe3, 0x84, 0xf8, 0x5e, 0x23, 0x70, 0x02, 0xb7, 0xbd, 0x2b, 0xfd,
	0x3e, 0xed, 0xd3, 0x12, 0x47, 0xa6, 0xc5, 0xf7, 0x1a, 0x81, 0x8d, 0x08, 0xd6, 0x4f, 0x4e, 0xf1,
	0x53, 0xb1, 0xdc, 0x8d, 0xf6, 0xe4, 0x39, 0xba, 0x94, 0xe6, 0x2d, 0xc4, 0xcd, 0x03, 0x35, 0x6f,
	0x21, 0xd3, 0x47, 0x48, 0x3e, 0x67, 0x64, 0x53, 0x9f, 0x33, 0x5e, 0x87, 0xf1, 0x95, 0x3d, 0x5a,
	0x7f, 0xa8, 0x3c, 0x36, 0x0a, 0xe2, 0xbe, 0x98, 0x01, 0x79, 0x0c, 0xd7, 0x18, 0x81, 0x5c, 0x01,
	0x40, 0xf7, 0x41, 0x2e, 0x64, 0x69, 0x71, 0xd8, 0xd1, 0xdb, 0x50, 0x58, 0x5c, 0x68, 0x28, 0xc8,
	0xbe, 0x66, 0xdf, 0xd0, 0x4d, 0x34, 0x38, 0xfb, 0x30, 0xd8, 0x11, 0xe8, 0x31, 0x02, 0xfb, 0x3c,
	0x6d, 0xa9, 0x88, 0x8d, 0xbd, 0xd8, 0xb3, 0x9e, 0x74, 0x24, 0x72, 0x19, 0xc6, 0x37, 0xa5, 0x79,
	0x3a, 0xee, 0xeb, 0x93, 0x48, 0x01, 0xb1, 0x29, 0xfb, 0x42, 0xc6, 0x8e, 0x51, 0xc8, 0x17, 0x60,
	0x6c, 0x85, 0x06, 0xd1, 0xd6, 0xd6, 0x3a, 0xda, 0x51, 0xf0, 0x70, 0xe5, 0x05, 0x0c, 0x2d, 0x1d,
	0x45, 0xcd, 0xef, 0x1e, 0x94, 0xa6, 0x22, 0xaf, 0x45, 0x55, 0x18, 0x56, 0x5b, 0x62, 0x93, 0x65,
	0x28, 0xf2, 0x97, 0xde, 0x58, 0x9c, 0xc6, 0xcd, 0xbe, 0xc0, 0x8f, 0x1e, 0xf1, 0x2c, 0xfc, 0x98,
	0x6e, 0xab, 0xc0, 0xda, 0x3d, 0xf8, 0x64, 0x55, 0xc6, 0xa3, 0xd7, 0x3f, 0x13, 0xe2, 0xfb, 0x9d,
	0xe4, 0x22, 0x60, 0x5f, 0xdb, 0x4b, 0x41, 0xca, 0x30, 0xb5, 0xe2, 0xb7, 0x3a, 0x6e, 0xe4, 0x61,
	0x72, 0xa7, 0x7d, 0xb1, 0xaf, 0xe3, 0x1d, 0x55, 0x5d, 0x2f, 0x30, 0x0e, 0x09, 0xbd, 0x80, 0xdc,
	0x80, 0x69, 0xdb, 0xef, 0xb2, 0x61, 0x92, 0x8a, 0x25, 0xdf, 0xba, 0xd1, 0xda, 0x21, 0x60, 0x25,
	0xec, 0xa4, 0x11, 0x5a, 0xa4, 0x11, 0x8f, 0xcf, 0xa0, 0x22, 0x1b, 0x29, 0x37, 0xfc, 0xfa, 0x7e,
	0xad, 0x87, 0xd7, 0xee, 0x61, 0x96, 0xf2, 0x38, 0x70, 0x0d, 0x26, 0x6a, 0xb5, 0xbb, 0x5b, 0x34,
	0x8c, 0x6e, 0x34, 0xfd, 0xc7, 0xb8, 0x5d, 0x17, 0x44, 0xda, 0x91, 0xd0, 0x77, 0x22, 0x1a, 0x46,
	0xce, 0x4e, 0xd3, 0x7f, 0x6c, 0xeb, 0x58, 0xe4, 0x1b, 0xac, 0x3f, 0x34, 0xe1, 0x46, 0x44, 0x1e,
	0x1c, 0x24, 0x7f, 0xe1, 0xa6, 0x18, 0x2f, 0x1a, 0x26, 0x85, 0x99, 0x9d, 0xa5, 0xa1, 0xa3, 0x03,
	0x12, 0x53, 0x89, 0xcb, 0x8d, 0x46, 0x40, 0xc3, 0x50, 0xec, 0xab, 0xdc, 0x01, 0x09, 0xf5, 0x67,
	0x97, 0x17, 0x18, 0x0e, 0x48, 0x1a, 0x01, 0xf9, 0x91, 0x0c, 0x9c, 0xd0, 0x7d, 0x18, 0x70, 0xb9,
	0xa0, 0xe5, 0x06, 0xdf, 0x65, 0xdf, 0xb8, 0x2c, 0xcf, 0x95, 0xcb, 0x1a, 0xda, 0xe5, 0x47, 0x57,
	0x2f, 0x97, 0xe3, 0x9f, 0x35, 0x49, 0x84, 0x51, 0x94, 0x4a, 0xa9, 0xfc, 0xe2, 0x16, 0x2c, 0x64,
	0xec, 0x79, 0x37, 0x85, 0x98, 0xac, 0x30, 0xe1, 0x83, 0xcd, 0x28, 0xb4, 0x05, 0xaa, 0x6e, 0xe2,
	0x36, 0x2d, 0x2e, 0x09, 0xc5, 0xfc, 0xe3, 0x56, 0x43, 0x5e, 0xc7, 0x94, 0x31, 0x34, 0x1a, 0x52,
	0x85, 0x19, 0x0e, 0x60, 0xdb, 0x02, 0xcf, 0x4a, 0x31, 0x17, 0x47, 0xc6, 0x16, 0x6c, 0xf0, 0xf9,
	0x1a, 0x33, 0x53, 0xe8, 0xa1, 0xf2, 0x12, 0x74, 0xe4, 0x7d, 0x98, 0x0e, 0xc3, 0x3d, 0x47, 0x5b,
	0xaf, 0xf3, 0xb8, 0x8a, 0x31, 0xe2, 0x9f, 0x28, 0x49, 0xb8, 0x69, 0x4d, 0x86, 0xe1, 0x5e, 0xbc,
	0xa2, 0xdf, 0x87, 0x69, 0x34, 0x3f, 0x89, 0x19, 0x9c, 0x88, 0x19, 0x88, 0x92, 0x24, 0x83, 0xa8,
	0x19, 0xc6, 0x0c, 0xfe, 0x46, 0x06, 0x4e, 0xb3, 0x8a, 0xd2, 0x47, 0xe8, 0xe4, 0xc7, 0x19, 0x21,
	0x8c, 0x81, 0xd6, 0x97, 0xa7, 0x2e, 0x61, 0x85, 0xe1, 0x5e, 0x1a, 0x07, 0x6c, 0x14, 0x6b, 0x7c,
	0x7a, 0xa3, 0x4e, 0x7d, 0xec, 0x46, 0xf5, 0xe5, 0xa9, 0x37, 0x2a, 0x6a, 0x86, 0x69, 0x1c, 0x50,
	0x53, 0xab, 0x95, 0xef, 0xac, 0xc7, 0xea, 0xc6, 0x67, 0xcb, 0x13, 0xc3, 0xf8, 0xb6, 0x01, 0x9e,
	0x18, 0xf7, 0xb8, 0x0f, 0xad, 0xd6, 0x0d, 0x52, 0x53, 0x33, 0xc0, 0x49, 0x4d, 0x2d, 0x41, 0x63,
	0x27, 0xb0, 0xad, 0xef, 0x16, 0x12, 0x7c, 0x85, 0xf5, 0xa5, 0x05, 0xa3, 0x5c, 0x11, 0xd3, 0xd3,
	0xd1, 0x73, 0x35, 0xcd, 0x16, 0x25, 0xe4, 0x34, 0xe4, 0x6a, 0xb5, 0xbb, 0xa2, 0x93, 0xd1, 0x06,
	0x33, 0x0c, 0x7d, 0x9b, 0xc1, 0xd8, 0x08, 0xa1, 0x61, 0xa5, 0x16, 0x21, 0x9a, 0x9d, 0x77, 0x36,
	0x42, 0x59, 0x7f, 0x4b, 0xb5, 0x28, 0x1f, 0xf7, 0xb7, 0x50, 0x8b, 0x62, 0x65, 0x68, 0x05, 0x16,
	0xca, 0x61, 0x48, 0x03, 0x36, 0x21, 0x84, 0xbd, 0x5e, 0x20, 0x44, 0x77, 0x71, 0xb0, 0x63, 0xa5,
	0x6e, 0x3d, 0xb4, 0xfb, 0x22, 0x92, 0x8b, 0x50, 0x28, 0x77, 0x1b, 0x1e, 0x6d, 0xd7, 0x8d, 0xf0,
	0x4f, 0xae, 0x80, 0xd9, 0xaa, 0x94, 0x7c, 0x19, 0x4e, 0x24, 0x42, 0xa0, 0x89, 0x1e, 0x18, 0x8b,
	0xf7, 0x5e, 0xa9, 0x5a, 0xc4, 0x36, 0x06, 0xbc, 0x4b, 0xd2, 0x29, 0x49, 0x19, 0x8a, 0xab, 0xe8,
	0x79, 0x54, 0xa1, 0xfc, 0xb9, 0xc3, 0x0f, 0xb8, 0xd7, 0x17, 0x57, 0x04, 0xb9, 0x57, 0x92, 0xd3,
	0x50, 0x85, 0x76, 0x0f, 0x3a, 0xb9, 0x0d, 0x73, 0x49, 0x18, 0x3b, 0xc1, 0xb9, 0xce, 0x87, 0xfb,
	0x4d, 0x0f, 0x17, 0x3c, 0xc3, 0xd3, 0xa8, 0xc8, 0x36, 0xcc, 0xc6, 0x36, 0x36, 0xa6, 0x26, 0x28,
	0x4d, 0x77, 0x55, 0xb9, 0xd4, 0x06, 0x9f, 0x17, 0x93, 0x71, 0x2e, 0xb6, 0xd7, 0x51, 0x1a, 0xa1,
	0xdd, 0xcb, 0x8e, 0x34, 0x60, 0xba, 0xe6, 0xed, 0xb6, 0xbd, 0xf6, 0xee, 0x6d, 0xba, 0xbf, 0xe9,
	0x7a, 0x81, 0x30, 0xa2, 0x94, 0x26, 0xd2, 0xe5, 0x70, 0xbf, 0xd5, 0xa2, 0x51, 0x80, 0x1b, 0x21,
	0x2b, 0x47, 0x87, 0x65, 0x26, 0xe1, 0x2f, 0x86, 0x9c, 0x0e, 0x9d, 0x01, 0x3b, 0xae, 0x67, 0x08,
	0x01, 0x26, 0x4f, 0x43, 0x1b, 0x9f, 0x1c, 0x52, 0x1b, 0x6f, 0xc2, 0xec, 0x6a, 0xbb, 0x1e, 0xec,
	0xe3, 0xab, 0x93, 0x6c, 0xdc, 0xd4, 0x11, 0x8d, 0x7b, 0x49, 0x34, 0xee, 0x05, 0x57, 0xce, 0xb0,
	0xb4, 0xe6, 0xf5, 0x32, 0x26, 0x35, 0x98, 0x45, 0x09, 0xbb, 0x5a, 0xd9, 0xac, 0xb6, 0xbd, 0xc8,
	0xc3, 0xa4, 0xe9, 0x5c, 0xb8, 0x78, 0x59, 0xf0, 0x3c, 0xc3, 0xb5, 0x2e, 0xaf, 0xd1, 0x71, 0x3c,
	0x89, 0xa2, 0x33, 0xed, 0xa1, 0x1f, 0xa4, 0xfa, 0xcc, 0xfc, 0xab, 0x51, 0x7d, 0x30, 0xad, 0x58,
	0xc2, 0x91, 0xbf, 0x18, 0x9f, 0xc3, 0x21, 0x16, 0xb1, 0xe3, 0xdc, 0xef, 0xa2, 0x30, 0x69, 0xa4,
	0x15, 0x33, 0xe9, 0xac, 0x5f, 0x9b, 0xe4, 0x7b, 0xbb, 0xae, 0x6f, 0xf4, 0x33, 0x9e, 0x4c, 0xe8,
	0x21, 0xd9, 0xe3, 0xe8, 0x21, 0xb9, 0xa3, 0xf5, 0x90, 0xfc, 0x51, 0x7a, 0x48, 0x42, 0x51, 0x18,
	0x39, 0xb6, 0xa2, 0x30, 0x7a, 0x2c, 0x45, 0x61, 0xec, 0x58, 0x8a, 0x82, 0xa1, 0xf3, 0x14, 0x8e,
	0xd2, 0x79, 0xfe, 0x42, 0xad, 0x78, 0x56, 0xd5, 0x8a, 0x34, 0x61, 0xe1, 0x58, 0x6a, 0xc5, 0x0f,
	0xf7, 0xd5, 0x0a, 0x8a, 0x1f, 0x47, 0xbc, 0x3b, 0x3f, 0x84, 0x56, 0x30, 0xac, 0x4e, 0x30, 0xfb,
	0x74, 0x74, 0x02, 0xf2, 0xd4, 0x74, 0x82, 0xb9, 0x4f, 0xaa, 0x13, 0xcc, 0x3f, 0x4d, 0x9d, 0xe0,
	0xc4, 0x9f, 0x47, 0x9d, 0xe0, 0xe4, 0xbf, 0x1e, 0x9d, 0xe0, 0x2f, 0x41, 0x31, 0x29, 0xa6, 0x1c,
	0x1d, 0xa7, 0xf3, 0xa9, 0xc5, 0x94, 0x63, 0x42, 0x54, 0x52, 0x4c, 0x20, 0x57, 0x00, 0x36, 0x03,
	0xef, 0x91, 0x1b, 0xd1, 0xdb, 0xd2, 0x34, 0x48, 0xc4, 0x98, 0xe5, 0x50, 0x36, 0xf2, 0xb6, 0x86,
	0xa2, 0x24, 0xe4, 0x6c, 0x9a, 0x84, 0x6c, 0xfd, 0x48, 0x16, 0x66, 0x79, 0xfc, 0xa7, 0x67, 0xff,
	0x85, 0xea, 0x3d, 0x43, 0xef, 0x91, 0x86, 0xa8, 0x89, 0xaf, 0x1b, 0xf0, 0x46, 0xf5, 0x75, 0x38,
	0xd1, 0xd3, 0x15, 0xa8, 0xfb, 0x54, 0x64, 0xe4, 0xad, 0x1e, 0xed, 0x67, 0x21, 0xbd, 0x92, 0xfb,
	0xd7, 0xec, 0x1e, 0x0a, 0xeb, 0x4f, 0xf3, 0x3d, 0xfc, 0xc5, 0x6b, 0x95, 0xfe, 0xfe, 0x94, 0x39,
	0xde, 0xfb, 0x53, 0x76, 0xb8, 0xf7, 0xa7, 0x84, 0x50, 0x91, 0x1b, 0x46, 0xa8, 0xf8, 0x32, 0x4c,
	0x6d, 0x51, 0xb7, 0x15, 0x6e, 0xf9, 0x22, 0x91, 0x04, 0x37, 0x44, 0x97, 0x81, 0xb5, 0x58, 0x99,
	0x14, 0xdd, 0x95, 0x41, 0x5d, 0xc4, 0x08, 0xd8, 0x31, 0xc8, 0x33, 0x4b, 0xd8, 0x26, 0x07, 0x5d,
	0x1f, 0x1b, 0x19, 0xa0, 0x8f, 0xd5, 0x60, 0x52, 0xd0, 0xc5, 0xc1, 0x49, 0x63, 0xc5, 0x81, 0x15,
	0x21, 0x5c, 0xd6, 0xae, 0x32, 0x8e, 0xaa, 0xda, 0xb9, 0xce, 0x60, 0x30, 0x61, 0x5d, 0xb0, 0xda,
	0x6e, 0x74, 0x7c, 0xaf, 0x8d, 0x5d, 0x30, 0x16, 0x77, 0x01, 0x15, 0x60, 0xde, 0x05, 0x1a, 0x12,
	0x79, 0x07, 0xa6, 0xcb, 0x9b, 0x55, 0x9d, 0xac, 0x10, 0x3f, 0x81, 0xb9, 0x1d, 0xcf, 0x31, 0x48,
	0x13, 0xb8, 0x83, 0x64, 0xe8, 0xf1, 0x7f, 0x35, 0x32, 0xb4, 0xf5, 0x2f, 0x26, 0xe5, 0xf2, 0xfe,
	0x74, 0xaf, 0xda, 0xcd, 0xcb, 0xf3, 0xdc, 0x31, 0x2f, 0xcf, 0xf3, 0x47, 0x09, 0x92, 0x86, 0x7c,
	0x3b, 0x72, 0x2c, 0xf9, 0x76, 0xf4, 0x13, 0x5f, 0x84, 0x8f, 0x1d, 0x53, 0x62, 0x4d, 0xac, 0xb5,
	0xc2, 0x30, 0x6b, 0x2d, 0x55, 0xca, 0x1d, 0xff, 0xe4, 0x52, 0x2e, 0x1c, 0x5b, 0xca, 0xad, 0xc5,
	0x8e, 0x9d, 0x13, 0x47, 0xda, 0xcb, 0x9f, 0x11, 0xfa, 0xe5, 0x6c, 0x7a, 0xf0, 0x2f, 0xe5, 0xe2,
	0xf9, 0x99, 0x12, 0x9d, 0xbf, 0x99, 0x2e, 0x3a, 0x0f, 0x3e, 0x6f, 0x8e, 0x25, 0x3c, 0xff, 0xc8,
	0xd3, 0x15, 0x9e, 0x9f, 0xee, 0x95, 0xfa, 0x5f, 0x88, 0xcf, 0x7f, 0x21, 0x3e, 0x0f, 0x29, 0x3e,
	0x07, 0xb8, 0xbc, 0x1e, 0xb8, 0x41, 0x1b, 0x2f, 0x74, 0xae, 0xc0, 0x98, 0x8c, 0x7e, 0x98, 0x89,
	0xef, 0x26, 0x7b, 0xc3, 0x1e, 0x4a, 0x2c, 0xb2, 0x04, 0x05, 0x49, 0xac, 0x67, 0x72, 0x78, 0x2c,
	0x60, 0x46, 0x60, 0x39, 0x01, 0xb3, 0xfe, 0x5e, 0x5e, 0x6e, 0xe1, 0x6c, 0xce, 0xf0, 0xa4, 0xfc,
	0x64, 0x59, 0x5b, 0xb2, 0x9a, 0xf0, 0x9e, 0x58, 0x94, 0x09, 0xbb, 0x67, 0x93, 0xe4, 0x63, 0xc5,
	0xa3, 0x8c, 0xb3, 0x0d, 0xe6, 0x86, 0xc8, 0x36, 0xf8, 0x96, 0x91, 0xaa, 0x2f, 0x1f, 0xe7, 0x86,
	0x62, 0xdb, 0xda, 0xe0, 0x24, 0x7d, 0xd7, 0xf5, 0x9c, 0x7a, 0x23, 0x71, 0xc8, 0x23, 0xa4, 0x1c,
	0x90, 0x4d, 0x4f, 0x69, 0x23, 0xa3, 0xc7, 0x89, 0xf4, 0x3a, 0xf6, 0xaf, 0x35, 0xd2, 0xeb, 0x2a,
	0x80, 0x96, 0xf0, 0x9d, 0x3f, 0x74, 0xbf, 0x8c, 0xab, 0xff, 0xc8, 0x64, 0xef, 0x1a, 0xa1, 0xf5,
	0x7b, 0x04, 0x66, 0x6b, 0xb5, 0xbb, 0x15, 0xcf, 0xdd, 0x6d, 0xfb, 0x61, 0xe4, 0xd5, 0xab, 0xed,
	0x1d, 0x9f, 0x89, 0xe2, 0xea, 0x38, 0xd0, 0x42, 0x7a, 0xc6, 0x47, 0x81, 0x2a, 0x66, 0xaa, 0xde,
	0x6a, 0x10, 0xf8, 0x81, 0xae, 0xea, 0x51, 0x06, 0xb0, 0x39, 0x9c, 0x49, 0xbb, 0xb5, 0x2e, 0xcf,
	0xdc, 0xcd, 0xad, 0x0f, 0x50, 0xda, 0x0d, 0x39, 0xc8, 0x96, 0x65, 0x84, 0xf6, 0x4e, 0x58, 0xa1,
	0xfd, 0x9c, 0x32, 0xe2, 0xc5, 0xc6, 0xc5, 0xfc, 0xb0, 0x13, 0xc2, 0x08, 0x6e, 0x9b, 0x1d, 0x84,
	0xeb, 0xe6, 0x42, 0x3d, 0x6b, 0x60, 0x1f, 0x4e, 0x18, 0x0e, 0xa1, 0xc3, 0x5e, 0xcb, 0xbf, 0x2a,
	0xa4, 0x6b, 0x0b, 0xe3, 0x0f, 0xa4, 0xdc, 0xcd, 0xeb, 0xb9, 0x6d, 0x52, 0x6b, 0x60, 0xe7, 0xd9,
	0x99, 0xd4, 0x12, 0xb5, 0xba, 0x27, 0x8c, 0x98, 0xbd, 0xda, 0xa6, 0xc1, 0xb3, 0xf8, 0xf4, 0xab,
	0xda, 0x49, 0xd9, 0x0a, 0x06, 0xd7, 0x44, 0x7e, 0x3d, 0x03, 0xa7, 0x0c, 0x0c, 0xb5, 0x5d, 0x85,
	0x2a, 0x56, 0x42, 0xea, 0xbc, 0xfe, 0xe8, 0xe9, 0xcc, 0xeb, 0xf3, 0xe6, 0xb7, 0xc4, 0x1b, 0xaa,
	0xfe, 0x0d, 0xfd, 0x5a, 0x48, 0x1e, 0xc1, 0x2c, 0x16, 0xc9, 0x27, 0x02, 0x36, 0x67, 0xc5, 0xcb,
	0xc2, 0x7c, 0xdc, 0x6c, 0xee, 0xe4, 0x8c, 0x99, 0x58, 0x97, 0xbe, 0x73, 0x50, 0x9a, 0x32, 0xd0,
	0x65, 0x14, 0x5c, 0x27, 0x7e, 0x67, 0xf0, 0xda, 0x3b, 0xbe, 0x2e, 0x28, 0xf5, 0x54, 0x41, 0xfe,
	0x51, 0x06, 0x16, 0x18, 0x94, 0x7f, 0xc6, 0x8d, 0xc0, 0x6f, 0xa9, 0x72, 0x69, 0x77, 0xd6, 0xa7,
	0xdb, 0x9a, 0x4f, 0xa7, 0xdb, 0x5e, 0xc6, 0x26, 0xf3, 0x3d, 0xc1, 0xd9, 0x09, 0xfc, 0x56, 0xdc,
	0x7c, 0x23, 0xa1, 0x79, 0xbf, 0x46, 0x92, 0xef, 0xcf, 0xc0, 0x69, 0xe3, 0x56, 0x53, 0xcf, 0x15,
	0x20, 0x5c, 0xc9, 0xe7, 0x54, 0x90, 0x89, 0xb8, 0x68, 0xf9, 0xb2, 0x98, 0xff, 0x17, 0xb0, 0x05,
	0xf1, 0x69, 0x81, 0x6d, 0x71, 0x5a, 0x1c, 0x4b, 0x6b, 0x42, 0xff, 0x5a, 0x88, 0x07, 0xb3, 0x68,
	0xaf, 0x61, 0xd8, 0x47, 0xce, 0xf7, 0xb7, 0x8f, 0x54, 0x19, 0xf3, 0x30, 0x10, 0x79, 0x7f, 0x23,
	0xc9, 0x5e, 0xae, 0xe4, 0x2f, 0xc3, 0xe9, 0x1e, 0xa0, 0x5a, 0x6d, 0x27, 0xfa, 0xae, 0xb6, 0xd7,
	0x0e, 0x0f, 0x4a, 0xaf, 0xa4, 0xd5, 0x96, 0xb6, 0xd2, 0xfa, 0xd7, 0x40, 0x5c, 0x80, 0xb8, 0x50,
	0x88, 0x1f, 0xe9, 0x13, 0xf4, 0x35, 0x31, 0x3f, 0x34, 0x7c, 0xb6, 0x97, 0x6b, 0x6d, 0xd0, 0x8f,
	0xbc, 0x18, 0x89, 0x50, 0x98, 0xd4, 0x82, 0xb0, 0xef, 0x0b, 0xb3, 0x81, 0x3e, 0x95, 0x7c, 0xe7,
	0xa0, 0x64, 0x60, 0x33, 0x85, 0x48, 0x8f, 0xee, 0x6e, 0x48, 0x7b, 0x3a, 0x22, 0xf9, 0xd5, 0x0c,
	0xcc, 0x33, 0x40, 0x3c, 0xa9, 0xc4, 0x47, 0x2d, 0x0c, 0x9a, 0xf5, 0x7b, 0x4f, 0x67, 0xd6, 0xbf,
	0x88, 0x6d, 0xd4, 0x67, 0x7d, 0x4f, 0x97, 0xa4, 0x36, 0x0e, 0x67, 0xbb, 0x61, 0x1a, 0x64, 0xcc,
	0xf6, 0xd3, 0x43, 0xcc, 0x76, 0x3e, 0x00, 0x47, 0xcf, 0xf6, 0xbe, 0xb5, 0x90, 0x2d, 0x98, 0x14,
	0xba, 0x10, 0xef, 0xb0, 0xb3, 0x46, 0x00, 0x67, 0xbd, 0x88, 0x2b, 0xa8, 0x22, 0x46, 0x7d, 0xcf,
	0x17, 0x1a, 0x5c, 0x48, 0x1b, 0xe6, 0xf8, 0x6f, 0xf3, 0x6e, 0xaa, 0xd4, 0xf7, 0x6e, 0xea, 0xa2,
	0xf8, 0xa2, 0x73, 0x82, 0x7f, 0xe2, 0x8a, 0x4a, 0x8f, 0x4d, 0x93, 0xc2, 0x98, 0x74, 0x80, 0x18,
	0x60, 0xbe, 0x68, 0xcf, 0x0d, 0xbe, 0x91, 0x7a, 0x45, 0xd4, 0x59, 0x4a, 0xd6, 0x99, 0x5c, 0xb9,
	0x29, 0xbc, 0x89, 0x0b, 0x33, 0x02, 0xea, 0x3f, 0xa4, 0x7c, 0x87, 0x7f, 0xd1, 0x88, 0x0e, 0x94,
	0x28, 0xe5, 0x4a, 0x94, 0xac, 0x09, 0xa3, 0x37, 0x25, 0x36, 0xf4, 0x24, 0x3f, 0x72, 0x17, 0x66,
	0xcb, 0x9d, 0x4e, 0xd3, 0xa3, 0x0d, 0xfc, 0x4a, 0x9e, 0x5c, 0xda, 0x8a, 0x13, 0x0a, 0xb9, 0xbc,
	0x50, 0x68, 0x76, 0xc9, 0xcc, 0xd2, 0xbd, 0xb4, 0xd6, 0x0f, 0x67, 0x7a, 0x1a, 0x4d, 0x5e, 0x87,
	0x71, 0xfc, 0xa1, 0x05, 0x9c, 0xc0, 0x2b, 0x1e, 0xde, 0x44, 0xbc, 0x3c, 0x8a, 0x11, 0x98, 0xb0,
	0xa4, 0x07, 0x9d, 0xcb, 0x71, 0x61, 0x49, 0xdc, 0x2b, 0xc4, 0x37, 0x09, 0x25, 0x69, 0xb7, 0x9e,
	0x8b, 0x85, 0x2e, 0xb4, 0x5b, 0x17, 0xd6, 0xea, 0xd6, 0xf7, 0x67, 0xcd, 0x69, 0x47, 0x2e, 0x6a,
	0x72, 0xbb, 0x16, 0xf6, 0x4e, 0xca, 0xed, 0x9a, 0xb4, 0xfe, 0x77, 0x33, 0x30, 0x77, 0x37, 0xd8,
	0x75, 0xdb, 0xde, 0xb7, 0x79, 0x98, 0x5f, 0x1f, 0xc7, 0x65, 0x70, 0x6e, 0xb6, 0xa7, 0x95, 0x63,
	0xca, 0xd7, 0x2a, 0x66, 0x33, 0x05, 0xa7, 0x8c, 0x9d, 0xd6, 0x1e, 0xf4, 0x04, 0xc2, 0x86, 0x69,
	0xa9, 0xbe, 0x38, 0x3a, 0x87, 0x5b, 0x3f, 0x96, 0x85, 0x09, 0x6d, 0x09, 0x90, 0xcf, 0xc3, 0xa4,
	0xce, 0x47, 0xbf, 0xf0, 0xd3, 0xab, 0xb5, 0x0d, 0x2c, 0xbc, 0xf1, 0xa3, 0x6e, 0xcb, 0xb8, 0xf1,
	0x63, 0x13, 0x1d, 0xa1, 0xc7, 0x54, 0x6d, 0xde, 0x4f, 0x51, 0x6d, 0x8e, 0x95, 0x85, 0xfc, 0x9d,
	0x5e, 0x05, 0x67, 0xf8, 0xa4, 0xe1, 0xd6, 0x4f, 0x66, 0xa0, 0x98, 0x5c, 0xa4, 0x9f, 0x4a, 0xaf,
	0x1c, 0xe3, 0x75, 0xe7, 0x47, 0xb3, 0x2a, 0x03, 0x83, 0xf4, 0x6f, 0x7c, 0x56, 0x0d, 0xce, 0xde,
	0x35, 0x1e, 0x5e, 0x9e, 0x37, 0x43, 0x75, 0xe9, 0x91, 0x01, 0xd2, 0xe3, 0xf3, 0xe5, 0x7f, 0xf6,
	0x17, 0x4a, 0xcf, 0x59, 0x1f, 0xc2, 0x7c, 0xb2, 0x3b, 0xf0, 0xf1, 0xa5, 0x0c, 0x33, 0x26, 0x3c,
	0x99, 0xbf, 0x25, 0x49, 0x65, 0x27, 0xf1, 0xad, 0xdf, 0xcf, 0x26, 0x79, 0x0b, 0xe3, 0x33, 0xb6,
	0xe9, 0xb4, 0xdd, 0xed, 0xa6, 0xca, 0xdf, 0xc0, 0x37, 0x1d, 0x0e, 0xb2, 0x65, 0xd9, 0x71, 0x12,
	0x1a, 0x29, 0x2f, 0xbd, 0x5c, 0xba, 0x97, 0x1e, 0xb9, 0x9e, 0xb0, 0xb7, 0xd5, 0x42, 0xca, 0x3c,
	0xa6, 0xdb, 0x4e, 0x6c, 0x73, 0x9b, 0x30, 0xb3, 0x5d, 0x81, 0x79, 0x23, 0x3e, 0xb2, 0xa4, 0x1f,
	0x89, 0xef, 0xda, 0x23, 0x2c, 0xe0, 0xc4, 0xa9, 0xc8, 0x64, 0x0d, 0xc6, 0x58, 0x33, 0xef, 0xb8,
	0x1d, 0xf1, 0xa6, 0x42, 0x94, 0xcf, 0x6e, 0x53, 0x29, 0x7c, 0x9a, 0xdb, 0x6e, 0x93, 0xb2, 0x23,
	0xdf, 0x48, 0xe2, 0xcf, 0x11, 0xad, 0x7f, 0x96, 0x61, 0xeb, 0xbf, 0xfe, 0xf0, 0x33, 0x96, 0x15,
	0x89, 0x7d, 0xd2, 0x00, 0xdb, 0xc8, 0x3f, 0xca, 0xf2, 0x14, 0x1c, 0x62, 0xfa, 0xbc, 0x05, 0xa3,
	0x5b, 0x6e, 0xb0, 0x4b, 0x23, 0x91, 0x9c, 0x42, 0xe7, 0xc2, 0x0b, 0xe2, 0x80, 0x37, 0x11, 0xfe,
	0xb6, 0x05, 0x81, 0x7e, 0x17, 0x96, 0x1d, 0xea, 0x2e, 0x4c, 0xbb, 0x97, 0xcf, 0x3d, 0xb5, 0x7b,
	0xf9, 0xef, 0x51, 0xd9, 0x36, 0xca, 0xd1, 0x10, 0xe1, 0x77, 0xcf, 0x25, 0xb3, 0xd5, 0xf4, 0x04,
	0x4a, 0x8e, 0xd9, 0x91, 0xeb, 0x7a, 0xfe, 0x1b, 0xcd, 0xf1, 0xed, 0x88, 0x4c, 0x37, 0xd6, 0x1f,
	0xe5, 0x78, 0x1f, 0x8b, 0x8e, 0xba, 0x60, 0x38, 0xc5, 0xe2, 0x3a, 0x61, 0x1b, 0xbd, 0x1e, 0x9f,
	0x00, 0xcd, 0xa6, 0x2e, 0x40, 0x9e, 0xcd, 0x4d, 0xd1, 0x9b, 0x88, 0xc7, 0xe6, 0xaf, 0x8e, 0xc7,
	0xca, 0xd9, 0x5a, 0xc6, 0x33, 0x49, 0xcf, 0x38, 0x86, 0xc7, 0x96, 0xbe, 0x96, 0x11, 0x83, 0x5c,
	0x84, 0xfc, 0x86, 0xdf, 0x90, 0x61, 0x9e, 0xe7, 0x31, 0x34, 0x82, 0xdf, 0xa0, 0xc6, 0xa5, 0x39,
	0x62, 0xb0, 0x6f, 0x55, 0x09, 0x2c, 0xf4, 0x6f, 0x6d, 0xed, 0xb8, 0x22, 0x16, 0xa1, 0xfe, 0xad,
	0x71, 0xae, 0x8b, 0x55, 0x98, 0x36, 0x73, 0x0e, 0x0b, 0xcb, 0x51, 0xbc, 0x5d, 0x4f, 0xa4, 0x2e,
	0xd6, 0x9f, 0x45, 0x4c, 0x22, 0xb2, 0x0c, 0x53, 0x46, 0x78, 0x49, 0xf1, 0xb8, 0x89, 0xd7, 0x9b,
	0x66, 0x70, 0x4a, 0xfd, 0x7a, 0xd3, 0x20, 0x61, 0xe7, 0xb9, 0x68, 0xbf, 0xf6, 0xc4, 0xd9, 0xd3,
	0x76, 0x81, 0x43, 0xae, 0x41, 0x81, 0xc7, 0x20, 0xa8, 0x56, 0xf4, 0x67, 0xaa, 0x10, 0x61, 0x89,
	0x18, 0x1e, 0x12, 0x51, 0xf3, 0x39, 0xff, 0x1c, 0x14, 0xc5, 0x96, 0x14, 0x67, 0xf7, 0x7d, 0x01,
	0xf2, 0x2b, 0xd5, 0x8a, 0xad, 0x6f, 0x23, 0x75, 0xaf, 0x11, 0xd8, 0x08, 0x45, 0x47, 0xa6, 0x0d,
	0x1a, 0x3d, 0xf6, 0x83, 0x87, 0x36, 0x0d, 0xa3, 0xc0, 0xe3, 0x09, 0xeb, 0x70, 0x21, 0x7e, 0x9e,
	0xbc, 0x03, 0x23, 0x68, 0xc2, 0x98, 0x38, 0x19, 0x92, 0x75, 0x2c, 0x4f, 0x89, 0x09, 0x3c, 0x82,
	0xf6, 0x90, 0x36, 0x27, 0x22, 0x6f, 0x41, 0xbe, 0x42, 0xdb, 0xfb, 0x89, 0x94, 0x5d, 0x3d, 0xc4,
	0x6a, 0x43, 0x68, 0xd0, 0xf6, 0xbe, 0x8d, 0x24, 0xd6, 0x4f, 0x66, 0xe1, 0x44, 0x4a, 0xb3, 0xee,
	0x7f, 0xfe, 0x19, 0xdd, 0x15, 0x97, 0x8d, 0x5d, 0x51, 0xbe, 0x4f, 0xf7, 0xed, 0xf8, 0xd4, 0x4d,
	0xf2, 0xe7, 0x32, 0x70, 0xca, 0x9c, 0xa0, 0xc2, 0x66, 0xf9, 0xfe, 0x35, 0xf2, 0x36, 0x8c, 0xae,
	0x51, 0xb7, 0x41, 0x65, 0x3a, 0x9f, 0x13, 0x2a, 0x5a, 0x18, 0x77, 0xb0, 0xe6, 0x85, 0x9c, 0x6d,
	0xec, 0x8e, 0xc7, 0xa1, 0xa4, 0x22, 0x1a, 0xc7, 0xe5, 0x71, 0x4b, 0x06, 0x3b, 0x48, 0xab, 0x6a,
	0x80, 0x95, 0xc7, 0x77, 0x32, 0xf0, 0xfc, 0x00, 0x1a, 0x36, 0x70, 0x6c, 0xe8, 0xf5, 0x81, 0xc3,
	0x13, 0x15, 0xa1, 0xe4, 0x3d, 0x98, 0xd9, 0x12, 0xf2, 0xbc, 0x1c, 0x8e, 0x6c, 0xbc, 0x5e, 0xa4,
	0xa8, 0xef, 0xc8, 0x71, 0x49, 0x22, 0x1b, 0x51, 0x38, 0x72, 0x03, 0xa3, 0x70, 0xe8, 0x41, 0x2d,
	0xf2, 0xc3, 0x06, 0xb5, 0xf8, 0x10, 0xe6, 0xcd, 0x6f, 0x13, 0xb1, 0x45, 0xe3, 0x90, 0x1e, 0x99,
	0xfe, 0x21, 0x3d, 0x06, 0x46, 0x30, 0xb4, 0x7e, 0x2c, 0x03, 0x45, 0x93, 0xf7, 0x27, 0x1d, 0xcf,
	0x77, 0x8d, 0xf1, 0x7c, 0x3e, 0x7d, 0x3c, 0xfb, 0x0f, 0xe4, 0xff, 0x91, 0x49, 0x7e, 0xec, 0x50,
	0x23, 0x68, 0xc1, 0x68, 0xc5, 0x6f, 0xb9, 0x5e, 0x5b, 0x4f, 0x16, 0xdd, 0x40, 0x88, 0x2d, 0x4a,
	0x86, 0x8b, 0x80, 0x72, 0x0e, 0x46, 0x36, 0xfc, 0x76, 0xb9, 0x22, 0x4c, 0x7a, 0x91, 0x4f, 0xdb,
	0x6f, 0x3b, 0x6e, 0xc3, 0xe6, 0x05, 0x64, 0x1d, 0xa0, 0x56, 0x0f, 0x28, 0x6d, 0xd7, 0xbc, 0x6f,
	0xd3, 0x84, 0xa4, 0xc1, 0x7a, 0xa8, 0xd9, 0xc5, 0x8d, 0x85, 0x3f, 0x5d, 0x22, 0xa2, 0x13, 0x7a,
	0xdf, 0xd6, 0xf7, 0x5b, 0x8d, 0xde, 0xa2, 0x00, 0x31, 0x11, 0x66, 0xce, 0xf4, 0x1a, 0x22, 0x1b,
	0xfa, 0x94, 0xc8, 0x9c, 0xc9, 0x00, 0x46, 0xe6, 0x4c, 0x06, 0x60, 0x5b, 0xfb, 0x1a, 0xf5, 0x76,
	0xf7, 0xb8, 0xb5, 0xd0, 0x14, 0x9f, 0xaa, 0x7b, 0x08, 0xd1, 0xb7, 0x76, 0x8e, 0x63, 0xfd, 0xcb,
	0x11, 0x38, 0x6d, 0xd3, 0x5d, 0x8f, 0x89, 0xc9, 0xf7, 0x42, 0xaf, 0xbd, 0x6b, 0xc4, 0xa8, 0xb0,
	0x12, 0x13, 0x49, 0x04, 0x74, 0x67, 0x10, 0xd5, 0x31, 0x97, 0xa0, 0xc0, 0x4e, 0x45, 0x6d, 0x2e,
	0xe1, 0x1b, 0x0a, 0x3b, 0x3b, 0x45, 0x10, 0x54, 0x59, 0x4c, 0x5e, 0x15, 0xa7, 0xb6, 0x96, 0x72,
	0x83, 0x9d, 0xda, 0xdf, 0x3d, 0x28, 0x41, 0x6d, 0x3f, 0x8c, 0x28, 0x6a, 0x6c, 0xe2, 0xe4, 0x56,
	0xa2, 0x75, 0xbe, 0x8f, 0x68, 0x7d, 0x07, 0xe6, 0xcb, 0x0d, 0xbe, 0x59, 0xbb, 0xcd, 0xcd, 0xc0,
	0x6b, 0xd7, 0xbd, 0x8e, 0xdb, 0x94, 0xea, 0x22, 0xf6, 0xb2, 0xab, 0xca, 0x9d, 0x8e, 0x42, 0xb0,
	0x53, 0xc9, 0xd8, 0x67, 0x54, 0x36, 0x6a, 0x18, 0xca, 0x41, 0x3c, 0x8f, 0xe1, 0x67, 0x34, 0xda,
	0x21, 0x7e, 0x45, 0x68, 0xab, 0x62, 0x14, 0xea, 0xf1, 0x7d, 0x78, 0x6b, 0xbd, 0x16, 0xfb, 0x6a,
	0xf2, 0x88, 0xe0, 0xfc, 0x9d, 0x39, 0x6a, 0x86, 0x68, 0x99, 0x67, 0xe0, 0xc5, 0x74, 0xb5, 0xda,
	0x1a, 0xa3, 0x2b, 0xf4, 0xd0, 0x85, 0xe1, 0x9e, 0x4e, 0xc7, 0xf1, 0xc8, 0x15, 0x36, 0x15, 0x5a,
	0x7e, 0x44, 0x71, 0x9e, 0x8f, 0xc7, 0x2a, 0x40, 0x80, 0x50, 0xae, 0x02, 0x68, 0x28, 0xe4, 0x1d,
	0x98, 0x5b, 0x5d, 0x59, 0x92, 0x97, 0x9a, 0x15, 0xbf, 0xde, 0xc5, 0x77, 0x61, 0xc0, 0xfa, 0x70,
	0x0c, 0x69, 0x7d, 0x89, 0x4d, 0xee, 0x34, 0x34, 0x72, 0x01, 0xc6, 0xaa, 0x15, 0xde, 0xf7, 0x13,
	0x7a, 0xda, 0x1b, 0x61, 0xa8, 0x23, 0x0b, 0xc9, 0xdd, 0x58, 0x46, 0x9d, 0x3c, 0x52, 0x98, 0x3c,
	0x3d, 0x84, 0x7c, 0xfa, 0x16, 0x4c, 0x2d, 0xfb, 0x51, 0xb5, 0x1d, 0x46, 0x6e, 0xbb, 0x4e, 0xab,
	0x15, 0x3d, 0x06, 0xed, 0xb6, 0x1f, 0x39, 0x9e, 0x28, 0x61, 0x2d, 0x37, 0x31, 0xc9, 0x17, 0x91,
	0xf4, 0x26, 0x6d, 0xd3, 0x20, 0x8e, 0x3d, 0x3b, 0xc2, 0xfb, 0x96, 0x91, 0xee, 0xaa, 0x12, 0xdb,
	0x44, 0x14, 0x29, 0x79, 0x78, 0x8a, 0xba, 0x15, 0xbf, 0x41, 0xc3, 0xfb, 0x57, 0x3f, 0x63, 0x29,
	0x79, 0xb4, 0x6f, 0xc3, 0x2d, 0xf3, 0x6a, 0xea, 0xfe, 0xfa, 0x6f, 0x63, 0x4a, 0x9e, 0x1e, 0x5c,
	0xf2, 0x45, 0x18, 0xc1, 0x9f, 0x42, 0xd8, 0x9a, 0x4b, 0x61, 0x1b, 0x0b, 0x5a, 0x75, 0x9e, 0x61,
	0x1e, 0x09, 0x48, 0x15, 0xc6, 0x84, 0x9c, 0x7f, 0x9c, 0xc4, 0x12, 0x42, 0x61, 0xe0, 0x33, 0x43,
	0xd0, 0x5b, 0x0d, 0x98, 0xd4, 0x2b, 0x64, 0x2b, 0x62, 0xcd, 0x0d, 0xf7, 0x68, 0x83, 0xfd, 0x12,
	0x39, 0xa1, 0x70, 0x45, 0xec, 0x21, 0xd4, 0x61, 0xed, 0xb0, 0x35, 0x14, 0xb6, 0xc5, 0x57, 0xc3,
	0x7b, 0xa1, 0x68, 0x8a, 0xd0, 0xfc, 0x3d, 0xbc, 0x45, 0x6a, 0xd8, 0xa2, 0xc8, 0xfa, 0x1e, 0x98,
	0xdf, 0xe8, 0x36, 0x9b, 0xee, 0x76, 0x93, 0xca, 0x9c, 0x01, 0x91, 0x1b, 0x51, 0xb2, 0x0c, 0x23,
	0x35, 0x2d, 0x67, 0xed, 0x9c, 0x4a, 0xca, 0x10, 0xe3, 0xa0, 0x4d, 0x64, 0x06, 0xc3, 0x6a, 0x24,
	0xb2, 0xd5, 0x72, 0x52, 0xeb, 0x77, 0x33, 0x30, 0x2f, 0x9f, 0xa3, 0x03, 0xb7, 0xfe, 0x50, 0xe5,
	0x2d, 0xbe, 0x60, 0xcc, 0x35, 0x9c, 0xb0, 0x89, 0x69, 0xc4, 0x67, 0xdd, 0x2d, 0xd9, 0x08, 0xf3,
	0xfc, 0x4c, 0x6b, 0xf0, 0x51, 0x8d, 0x21, 0xef, 0xc0, 0x84, 0x38, 0x43, 0xb5, 0x60, 0x70, 0x18,
	0x71, 0x47, 0x68, 0x1f, 0x49, 0xe3, 0x08, 0x1d, 0x1d, 0x45, 0x03, 0xf3, 0x53, 0xee, 0x5f, 0xfd,
	0x34, 0x44, 0x03, 0xb3, 0x8e, 0x01, 0x53, 0xf7, 0x37, 0x27, 0x92, 0x7d, 0x2b, 0xe6, 0xee, 0x75,
	0x3d, 0xfc, 0x53, 0x26, 0x56, 0xd4, 0xe2, 0xf0, 0x4f, 0xba, 0xa2, 0xa6, 0x50, 0xd5, 0x98, 0x64,
	0x8f, 0x18, 0x93, 0xf7, 0xe4, 0x98, 0xe4, 0xfa, 0x4f, 0x8c, 0xb9, 0x01, 0xe3, 0x50, 0x8b, 0x57,
	0x48, 0x7e, 0x28, 0x2d, 0xff, 0x39, 0x8c, 0x73, 0xcd, 0x49, 0x92, 0xbb, 0xa8, 0xe0, 0xa4, 0x5f,
	0x1d, 0x8c, 0x0c, 0xcf, 0xf4, 0x88, 0xad, 0xf9, 0x4b, 0x30, 0x59, 0x8e, 0x22, 0xb7, 0xbe, 0x47,
	0x1b, 0x15, 0xb6, 0x3d, 0x69, 0x91, 0x6a, 0x5c, 0x01, 0xd7, 0xdf, 0x70, 0x74, 0x5c, 0x1e, 0x79,
	0xd1, 0x0d, 0x85, 0x6d, 0xa5, 0x8a, 0xbc, 0xc8, 0x20, 0x66, 0xe4, 0x45, 0x06, 0x21, 0x57, 0x60,
	0xac, 0xda, 0x7e, 0xe4, 0xb1, 0x3e, 0x29, 0xc4, 0x49, 0xcc, 0x3d, 0x0e, 0xd2, 0x37, 0x57, 0x81,
	0x45, 0xde, 0xd2, 0x64, 0xec, 0xf1, 0x58, 0x9f, 0xe6, 0x37, 0x30, 0x2a, 0xc6, 0x85, 0x2e, 0x3f,
	0x2b, 0xa1, 0xfb, 0x3a, 0x8c, 0xc9, 0x8b, 0x35, 0x88, 0x75, 0x68, 0x41, 0xd9, 0xeb, 0x09, 0x2f,
	0x91, 0x31, 0xd5, 0xad, 0x96, 0xdb, 0x6a, 0x42, 0x4b, 0x75, 0xab, 0xe5, 0xb6, 0x32, 0x52, 0xdd,
	0x6a, 0x59, 0xae, 0xd4, 0x9d, 0xc4, 0xe4, 0x91, 0x77, 0x12, 0xf7, 0x61, 0x72, 0xd3, 0x0d, 0x22,
	0x8f, 0xc9, 0x28, 0xed, 0x28, 0x5c, 0x98, 0x32, 0xae, 0xf1, 0xb4, 0xa2, 0xe5, 0xb3, 0x32, 0x3b,
	0x6b, 0x47, 0xc3, 0x37, 0xd3, 0x88, 0xc6, 0xf0, 0x74, 0xcb, 0xca, 0xe9, 0x4f, 0x62, 0x59, 0x89,
	0x9d, 0x8a, 0x57, 0x37, 0x33, 0xf1, 0x05, 0x01, 0xca, 0xd0, 0x89, 0xfb, 0x1b, 0x85, 0x48, 0xbe,
	0x06, 0x93, 0xec, 0xef, 0x4d, 0xbf, 0xe9, 0xd5, 0x3d, 0x1a, 0x2e, 0x14, 0xf1, 0xe3, 0xce, 0xa6,
	0xae, 0x7e, 0x44, 0xda, 0xaf, 0xd1, 0x88, 0x2f, 0x60, 0x64, 0x9c, 0xbc, 0x93, 0x35, 0xb8, 0x91,
	0xf7, 0x61, 0x92, 0xcd, 0xbe, 0x6d, 0x37, 0xe4, 0xa2, 0xe9, 0x6c, 0x6c, 0x1b, 0xdb, 0x10, 0xf0,
	0x9e, 0xe0, 0xa7, 0x3a, 0x01, 0x3b, 0xe6, 0xcb, 0x1d, 0xbe, 0x41, 0x12, 0x6d, 0xb6, 0x77, 0x7a,
	0x36, 0x47, 0x89, 0x46, 0x3e, 0x80, 0xc9, 0x72, 0xa7, 0x13, 0xef, 0x38, 0x73, 0xda, 0xbd, 0x4c,
	0xa7, 0xe3, 0xa4, 0xee, 0x3a, 0x06, 0x45, 0x72, 0x63, 0x9e, 0x3f, 0xd6, 0xc6, 0x4c, 0xde, 0x50,
	0xd2, 0xfa, 0x89, 0xf8, 0x92, 0x51, 0xe8, 0x31, 0x86, 0xe8, 0xcf, 0x05, 0xf7, 0x15, 0x98, 0xe2,
	0xb7, 0x6e, 0x52, 0x9a, 0x39, 0xd9, 0xb3, 0x7a, 0x52, 0x84, 0x1a, 0x93, 0x86, 0xac, 0xc2, 0x34,
	0x77, 0x23, 0x6d, 0x8a, 0xa8, 0xb4, 0x0b, 0xa7, 0xe2, 0xb4, 0xfb, 0xdc, 0xfb, 0xb4, 0x89, 0xc9,
	0x0a, 0x5c, 0x83, 0x4b, 0x82, 0xc8, 0xfa, 0xe3, 0x0c, 0x9c, 0xea, 0x33, 0xe2, 0x2a, 0x66, 0x69,
	0x66, 0x70, 0xcc, 0x52, 0xb6, 0x73, 0x98, 0x4a, 0x3a, 0x7e, 0xbf, 0x90, 0xb2, 0xf4, 0xf1, 0x92,
	0xf2, 0x96, 0x0f, 0x44, 0xe4, 0x03, 0x11, 0x55, 0xdf, 0xf2, 0xf1, 0xa6, 0x30, 0xd7, 0x7b, 0x08,
	0x09, 0x3c, 0xde, 0xa8, 0x65, 0xeb, 0xf0, 0xa0, 0x74, 0x56, 0xa4, 0x1b, 0x51, 0xc3, 0xfa, 0x91,
	0x6f, 0xac, 0xe0, 0x14, 0xd6, 0xd6, 0x41, 0x06, 0x26, 0xb4, 0x75, 0x48, 0xce, 0x69, 0x4e, 0xa9,
	0x45, 0x9e, 0xb0, 0x46, 0xe3, 0x90, 0xe5, 0x27, 0x11, 0x2e, 0xaa, 0xec, 0xd1, 0xf7, 0xa1, 0x77,
	0x98, 0x28, 0xa4, 0xc5, 0x75, 0x6d, 0x19, 0x97, 0x97, 0x36, 0x96, 0x63, 0x52, 0x69, 0x37, 0x8c,
	0xca, 0xf5, 0xc8, 0x7b, 0x44, 0x87, 0x38, 0x74, 0xe2, 0xa4, 0xd2, 0x6e, 0x18, 0x39, 0x2e, 0x92,
	0xf5, 0x24, 0x95, 0x56, 0x0c, 0xad, 0x1f, 0xc8, 0x00, 0xdc, 0xab, 0xae, 0x60, 0x60, 0xe6, 0x4f,
	0x2a, 0x14, 0xa4, 0x07, 0xbb, 0x94, 0xdc, 0x07, 0x88, 0x03, 0xff, 0x7d, 0x06, 0xa6, 0x4d, 0x34,
	0xf2, 0x1e, 0xcc, 0xd4, 0xea, 0x81, 0xdf, 0x6c, 0x6e, 0xbb, 0xf5, 0x87, 0xeb, 0x5e, 0x9b, 0xf2,
	0x30, 0x83, 0x23, 0xfc, 0x2c, 0x0a, 0x55, 0x91, 0xd3, 0x64, 0x65, 0x76, 0x12, 0x99, 0xfc, 0xd5,
	0x0c, 0x4c, 0xd5, 0xf6, 0xfc, 0xc7, 0x2a, 0x32, 0xa0, 0x18, 0x90, 0xaf, 0xb3, 0xb5, 0x1d, 0xee,
	0xf9, 0x8f, 0xe3, 0x6c, 0x77, 0x86, 0x2d, 0xe2, 0xbb, 0xc3, 0x3d, 0x13, 0xd7, 0x7d, 0xd4, 0x64,
	0xa2, 0xf0, 0xb2, 0x51, 0x89, 0x6d, 0xd6, 0x69, 0xfd, 0x59, 0x06, 0x26, 0x50, 0xe7, 0x69, 0x36,
	0x51, 0xe6, 0xfa, 0x2c, 0xa5, 0x4e, 0x53, 0xdf, 0x35, 0x60, 0x60, 0xdf, 0x84, 0x99, 0x04, 0x1a,
	0xb1, 0x60, 0xb4, 0x86, 0x81, 0x08, 0xf4, 0x0b, 0x0a, 0x1e, 0x9a, 0xc0, 0x16, 0x25, 0xd6, 0xaa,
	0x46, 0x76, 0xff, 0x2a, 0xbe, 0x32, 0x2e, 0x01, 0x78, 0x12, 0x24, 0x35, 0x1b, 0x92, 0x6c, 0xc9,
	0xfd, 0xab, 0xb6, 0x86, 0x65, 0x6d, 0xc0, 0x68, 0xcd, 0x0f, 0xa2, 0xe5, 0x7d, 0xae, 0x4c, 0x54,
	0x68, 0x58, 0xd7, 0x9f, 0x11, 0x3d, 0xbc, 0xba, 0xaf, 0xdb, 0xa2, 0x88, 0x94, 0x60, 0xe4, 0x86,
	0x47, 0x9b, 0x0d, 0xdd, 0x5e, 0x74, 0x87, 0x01, 0x6c, 0x0e, 0x67, 0x0a, 0xd7, 0xc9, 0x38, 0x7f,
	0x41, 0x6c, 0x98, 0xfa, 0x49, 0xd7, 0xcd, 0x8a, 0xd1, 0xbf, 0x2f, 0x9a, 0x19, 0xd4, 0x8d, 0x9a,
	0x06, 0x74, 0xf5, 0x7f, 0x94, 0x81, 0xc5, 0xfe, 0x24, 0xba, 0xad, 0x6b, 0x66, 0x80, 0xad, 0xeb,
	0xcb, 0xc9, 0x67, 0x2f, 0x44, 0x13, 0xcf, 0x5e, 0xf1, 0x63, 0x57, 0x05, 0x4d, 0x8d, 0xeb, 0x54,
	0x26, 0x2d, 0x38, 0x37, 0xa0, 0xcd, 0x88, 0xc8, 0x87, 0x39, 0x42, 0x1a, 0x5b, 0xd0, 0x5a, 0xbf,
	0x91, 0x87, 0xd3, 0x7d, 0x29, 0xc8, 0x9a, 0x96, 0x0a, 0x65, 0x5a, 0x25, 0x61, 0xe8, 0x8b, 0x7f,
	0x19, 0xff, 0x45, 0x6b, 0xb2, 0xa4, 0xf3, 0xd3, 0x5d, 0x95, 0x02, 0x23, 0x8b, 0xbc, 0x5e, 0x3b,
	0x92, 0x17, 0x47, 0x47, 0x66, 0xd0, 0x9b, 0x0d, 0x03, 0xdd, 0xe4, 0x68, 0xe4, 0x7a, 0xcd, 0x50,
	0x5f, 0x76, 0x0d, 0x0e, 0xb2, 0x65, 0x59, 0x6c, 0x80, 0x9c, 0x4f, 0x37, 0x40, 0xb6, 0xfe, 0x65,
	0x06, 0xc6, 0x55, 0xb3, 0xc9, 0x22, 0x9c, 0xdc, 0xb2, 0xcb, 0x2b, 0xab, 0xce, 0xd6, 0x87, 0x9b,
	0xab, 0xce, 0xbd, 0x8d, 0xda, 0xe6, 0xea, 0x4a, 0xf5, 0x46, 0x75, 0xb5, 0x52, 0x7c, 0x8e, 0xcc,
	0xc2, 0xd4, 0xbd, 0x8d, 0xdb, 0x1b, 0x77, 0x1f, 0x6c, 0x38, 0xab, 0xb6, 0x7d, 0xd7, 0x2e, 0x66,
	0xc8, 0x14, 0x8c, 0xdb, 0xcb, 0xe5, 0x15, 0x67, 0xe3, 0x6e, 0x65, 0xb5, 0x98, 0x25, 0x45, 0x98,
	0x5c, 0xb9, 0xbb, 0xb1, 0xb1, 0xba, 0xb2, 0x55, 0xbd, 0x5f, 0xdd, 0xfa, 0xb0, 0x98, 0x23, 0x04,
	0xa6, 0x11, 0x61, 0xd3, 0xae, 0x6e, 0xac, 0x54, 0x37, 0xcb, 0xeb, 0xc5, 0x3c, 0x83, 0x31, 0x7c,
	0x0d, 0x36, 0xa2, 0x18, 0xdd, 0xbe, 0xb7, 0xbc, 0x5a, 0x1c, 0x65, 0x28, 0xec, 0x2f, 0x0d, 0x65,
	0x8c, 0x55, 0x8f, 0x28, 0x95, 0xf2, 0x56, 0x79, 0xb9, 0x5c, 0x5b, 0x2d, 0x16, 0xc8, 0x29, 0x98,
	0x33, 0x40, 0xce, 0xfa, 0xdd, 0x9b, 0xd5, 0x8d, 0xe2, 0x38, 0x99, 0x87, 0xa2, 0x82, 0x55, 0x96,
	0x9d, 0x7b, 0xb5, 0x55, 0xbb, 0x08, 0x49, 0xe8, 0x46, 0xf9, 0xce, 0x6a, 0x71, 0xc2, 0x7a, 0x97,
	0xbb, 0xa5, 0xf1, 0xae, 0x26, 0x27, 0x81, 0xd4, 0xb6, 0xca, 0x5b, 0xf7, 0x6a, 0x89, 0x8f, 0x9f,
	0x80, 0xb1, 0xda, 0xbd, 0x95, 0x95, 0xd5, 0x5a, 0xad, 0x98, 0x21, 0x00, 0xa3, 0x37, 0xca, 0xd5,
	0xf5, 0xd5, 0x4a, 0x31, 0x6b, 0xfd, 0x44, 0x06, 0x66, 0xa5, 0x04, 0x28, 0xdf, 0x30, 0x3e, 0xe1,
	0x5a, 0x7c, 0xcf, 0x50, 0x6c, 0xa5, 0xcf, 0x50, 0xa2, 0x92, 0x01, 0xcb, 0xf0, 0xe7, 0x32, 0x70,
	0x22, 0x15, 0x9b, 0x7c, 0x08, 0x45, 0xd9, 0x82, 0x3b, 0x6e, 0x54, 0xdf, 0x8b, 0xf7, 0xb1, 0xb3,
	0x89, 0x5a, 0x12, 0x68, 0xfc, 0x5a, 0x33, 0x4e, 0xce, 0xda, 0xc3, 0x66, 0xf8, 0xd0, 0xe1, 0xd6,
	0xcf, 0x66, 0xe0, 0x54, 0x9f, 0x6a, 0xc8, 0x0a, 0x8c, 0xaa, 0x24, 0x12, 0x03, 0x0c, 0xaa, 0xe6,
	0xbf, 0x73, 0x50, 0x12, 0x88, 0x98, 0xcd, 0x12, 0xff, 0xb2, 0x47, 0x55, 0x56, 0x08, 0x4c, 0xcd,
	0xc0, 0xbb, 0xef, 0x74, 0xa2, 0xe7, 0x45, 0x4d, 0xe5, 0x07, 0xb5, 0xe5, 0x09, 0xd1, 0x77, 0x39,
	0xf7, 0x71, 0x88, 0xb9, 0x19, 0xac, 0x9f, 0xca, 0x30, 0xe1, 0x2e, 0x89, 0xc8, 0x64, 0xde, 0x72,
	0x18, 0x76, 0x5b, 0xd4, 0xf6, 0x9b, 0xb4, 0x6c, 0x6f, 0x88, 0x63, 0x03, 0xa5, 0x55, 0x17, 0x0b,
	0x50, 0xad, 0x70, 0xdc, 0xa0, 0x6d, 0x3c, 0x9e, 0xea, 0x34, 0xe4, 0x2d, 0x80, 0xd5, 0x27, 0x11,
	0x0d, 0xda, 0x6e, 0x53, 0x85, 0x0c, 0xe1, 0x21, 0x73, 0x04, 0xd4, 0x94, 0xb7, 0x35, 0x64, 0xeb,
	0xaf, 0x65, 0x60, 0x52, 0x28, 0x4d, 0xe5, 0x26, 0x0d, 0xa2, 0x4f, 0x36, 0xbd, 0xde, 0x32, 0xa6,
	0x97, 0xf2, 0x1f, 0xd0, 0xf8, 0xb3, 0xe2, 0xd4, 0x99, 0xf5, 0x8f, 0x33, 0x50, 0x4c, 0x22, 0x92,
	0xf7, 0xa0, 0x50, 0xa3, 0x8f, 0x68, 0xe0, 0x45, 0xfb, 0x62, 0xa3, 0x94, 0xe9, 0xb6, 0x38, 0x8e,
	0x28, 0xe3, 0xf3, 0x21, 0x14, 0xbf, 0x6c, 0x45, 0x33, 0xec, 0x7e, 0xaf, 0x5d, 0x7b, 0xe4, 0x9e,
	0xd6, 0xb5, 0x87, 0xf5, 0xbf, 0x64, 0xe1, 0xd4, 0x4d, 0x1a, 0xe9, 0xdf, 0xa4, 0x5e, 0xbb, 0x3f,
	0x37, 0xdc, 0x77, 0x69, 0x5f, 0xb2, 0x00, 0x63, 0x58, 0x24, 0xc7, 0xd7, 0x96, 0x3f, 0xc9, 0xb2,
	0x9a, 0xd7, 0x39, 0x23, 0x9f, 0x4f, 0x9f, 0xba, 0x2f, 0x6b, 0x19, 0x3e, 0xd4, 0xb4, 0xbe, 0x00,
	0xd3, 0x18, 0xc2, 0xba, 0xcb, 0x96, 0x03, 0x6d, 0x88, 0xeb, 0x9f, 0x82, 0x9d, 0x80, 0x92, 0x57,
	0xa1, 0xc8, 0x20, 0xe5, 0xfa, 0xc3, 0xb6, 0xff, 0xb8, 0x49, 0x1b, 0xbb, 0xb4, 0x81, 0xc7, 0x7a,
	0xc1, 0xee, 0x81, 0x4b, 0x9e, 0xf7, 0xda, 0x5c, 0x75, 0xa3, 0x0d, 0xbc, 0xa3, 0x11, 0x3c, 0x63,
	0xe8, 0xe2, 0x5b, 0x30, 0xf1, 0x31, 0xb3, 0xf5, 0x58, 0xff, 0x73, 0x06, 0xe6, 0xf1, 0xe3, 0xb4,
	0x8a, 0x65, 0x26, 0x45, 0xd9, 0x5b, 0x5a, 0x02, 0x0b, 0x97, 0x81, 0xcc, 0xa5, 0xa0, 0x7a, 0x31,
	0xbe, 0x13, 0xca, 0x0e, 0x71, 0x27, 0x54, 0x3b, 0x4e, 0xd6, 0xe8, 0x21, 0xaf, 0xb4, 0x6e, 0xe5,
	0x0b, 0xb9, 0x62, 0x3e, 0x1e, 0x72, 0xeb, 0xaf, 0x66, 0x61, 0xcc, 0xa6, 0x98, 0x4e, 0x97, 0x5c,
	0x80, 0xb1, 0x0d, 0x3f, 0xa2, 0xe1, 0x1d, 0x23, 0x77, 0x72, 0x9b, 0x81, 0x9c, 0x56, 0xc3, 0x96,
	0x85, 0x6c, 0xc2, 0x6f, 0x06, 0x7e, 0xa3, 0x5b, 0x8f, 0xf4, 0x09, 0xdf, 0xe1, 0x20, 0x5b, 0x96,
	0x91, 0xd7, 0x61, 0x5c, 0x70, 0x56, 0x6f, 0x8c, 0x68, 0x1b, 0x1b, 0x50, 0x95, 0x8e, 0x39, 0x46,
	0x40, 0x99, 0x96, 0x0b, 0x18, 0x79, 0x4d, 0xa6, 0xed, 0x91, 0x19, 0xa4, 0xa8, 0x3e, 0x32, 0x40,
	0x54, 0xff, 0x1c, 0x8c, 0x96, 0xc3, 0x90, 0x46, 0xd2, 0xa9, 0x7e, 0x52, 0xc5, 0xa3, 0x0a, 0x69,
	0xc4, 0x19, 0xbb, 0x58, 0x6e, 0x0b, 0x3c, 0xeb, 0x9f, 0x65, 0x61, 0x04, 0xff, 0xc4, 0x77, 0xd5,
	0xa0, 0xbe, 0x67, 0xbc, 0xab, 0x06, 0xf5, 0x3d, 0x1b, 0xa1, 0xe4, 0x2a, 0xde, 0x54, 0xc8, 0x5c,
	0x2b, 0xe2, 0xeb, 0xf1, 0x0a, 0xbe, 0x11, 0x83, 0x6d, 0x1d, 0x47, 0x3d, 0x38, 0xe7, 0x52, 0x43,
	0x69, 0x9c, 0x84, 0xec, 0xdd, 0x9a, 0xf8, 0x62, 0x0c, 0xd0, 0xe4, 0x87, 0x76, 0xf6, 0x6e, 0x0d,
	0x7b, 0x63, 0xad, 0xbc, 0xf4, 0xe6, 0x75, 0x3d, 0xcd, 0x77, 0xb8, 0xe7, 0x2e, 0xbd, 0x79, 0xdd,
	0x16, 0x25, 0xac, 0x7f, 0xb1, 0xcd, 0xf8, 0xf0, 0xca, 0x5d, 0xc0, 0xb1, 0x7f, 0xf1, 0xdb, 0xf0,
	0x91, 0xd5, 0x8e, 0x11, 0xc8, 0x12, 0x4c, 0x88, 0xd0, 0x03, 0x88, 0xaf, 0x85, 0x06, 0x10, 0xa1,
	0x09, 0x38, 0x85, 0x8e, 0xc4, 0x9f, 0xe0, 0xc4, 0x00, 0xc9, 0x8c, 0x90, 0xe2, 0x09, 0x4e, 0x0e,
	0x61, 0x68, 0x6b, 0x28, 0x98, 0xca, 0x1e, 0xdf, 0xf0, 0x62, 0xd7, 0xee, 0x69, 0xcd, 0x87, 0x1d,
	0x43, 0x92, 0x2b, 0x04, 0xeb, 0x97, 0xb2, 0x50, 0xd8, 0x6c, 0x76, 0x77, 0xbd, 0xf6, 0xfd, 0xab,
	0x84, 0x00, 0xaa, 0x71, 0x32, 0x66, 0x3d, 0xfb, 0x9b, 0x9c, 0x86, 0x82, 0xd4, 0xdc, 0xe4, 0x86,
	0x14, 0x0a, 0xad, 0x6d, 0x01, 0xe4, 0xb8, 0xf3, 0x9e, 0xb5, 0xe5, 0x4f, 0x72, 0x15, 0x94, 0xfe,
	0xd5, 0x4f, 0x51, 0xcb, 0xb3, 0xc5, 0x62, 0x2b, 0x34, 0xf2, 0x06, 0xe0, 0x21, 0x21, 0x94, 0x07,
	0x79, 0xa1, 0xcd, 0x9b, 0x26, 0xe4, 0x14, 0x4e, 0x82, 0x68, 0xe4, 0x1a, 0x88, 0x89, 0x29, 0x32,
	0x0f, 0x9f, 0x30, 0x09, 0x78, 0x2e, 0x37, 0x49, 0x22, 0x50, 0xc9, 0x3b, 0x30, 0x51, 0x0f, 0x28,
	0xbe, 0x3a, 0xba, 0xcd, 0x38, 0xa1, 0xb0, 0x4e, 0xb9, 0x12, 0x97, 0xdf, 0xbf, 0x6a, 0xeb, 0xe8,
	0xd6, 0x7f, 0x3e, 0x0a, 0x93, 0x7a, 0x7b, 0x88, 0x0d, 0x73, 0x61, 0x93, 0xe9, 0xee, 0xc2, 0xf6,
	0xa9, 0x83, 0x85, 0xe2, 0x38, 0x3d, 0x67, 0x36, 0x88, 0xe1, 0x71, 0x43, 0x28, 0x19, 0x33, 0x61,
	0xed, 0x39, 0x7b, 0x36, 0x8c, 0xc1, 0x1c, 0x8f, 0x94, 0xa1, 0xe0, 0x77, 0xc2, 0x5d, 0xda, 0xf6,
	0xe4, 0x7b, 0xcb, 0x79, 0x83, 0xd1, 0x5d, 0x51, 0xd8, 0xc3, 0x4b, 0x91, 0x91, 0x37, 0x61, 0xd4,
	0xef, 0xd0, 0xb6, 0xeb, 0x89, 0x33, 0xee, 0xf9, 0x04, 0x03, 0xda, 0x2e, 0x57, 0x35, 0x42, 0x81,
	0x4c, 0xae, 0x40, 0xde, 0x7f, 0xa8, 0xc6, 0xeb, 0xb4, 0x49, 0xf4, 0x30, 0x72, 0x35, 0x12, 0x44,
	0x64, 0x04, 0x1f, 0xb9, 0xad, 0x1d, 0x31, 0x62, 0x26, 0xc1, 0x2d, 0xb7, 0xb5, 0xa3, 0x13, 0x30,
	0x44, 0xf2, 0x3e, 0x40, 0xc7, 0xdd, 0xa5, 0x81, 0xd3, 0xe8, 0x46, 0xfb, 0x62, 0xdc, 0xce, 0x1a,
	0x64, 0x9b, 0xac, 0xb8, 0xd2, 0x8d, 0xf6, 0x35, 0xda, 0xf1, 0x8e, 0x04, 0x92, 0x32, 0x40, 0xcb,
	0x8d, 0x22, 0x1a, 0xb4, 0x7c, 0x61, 0x7c, 0x36, 0xa1, 0x12, 0xf6, 0x72, 0x06, 0x77, 0x54, 0xb1,
	0xc6, 0x41, 0x23, 0xc2, 0x46, 0x7b, 0x81, 0x2b, 0xf2, 0x3f, 0x27, 0x1a, 0xed, 0x05, 0xc6, 0x57,
	0x32, 0x44, 0xf2, 0x45, 0x18, 0x6b, 0x78, 0x61, 0xdd, 0x0f, 0x1a, 0x22, 0x98, 0xc6, 0x0b, 0x06,
	0x4d, 0x85, 0x97, 0x69, 0x64, 0x12, 0x9d, 0xb5, 0x56, 0x44, 0x57, 0xdc, 0xf0, 0x1f, 0xe3, 0x35,
	0x7f, 0xb2, 0xb5, 0x35, 0x55, 0xac, 0xb7, 0x36, 0x26, 0x62, 0x43, 0xb9, 0xeb, 0x45, 0x4d, 0x77,
	0x5b, 0xbc, 0x73, 0x9b, 0x43, 0x79, 0x13, 0x8b, 0xf4, 0xa1, 0xe4, 0xc8, 0xe4, 0x2d, 0x28, 0xd0,
	0x76, 0x14, 0xb8, 0x8e, 0xd7, 0x10, 0x4e, 0x7b, 0x66, 0xa3, 0xd9, 0x01, 0xec, 0x56, 0x2b, 0x7a,
	0xa3, 0x11, 0xbf, 0xda, 0x60, 0xfd, 0x13, 0xd6, 0xbd, 0x96, 0xf0, 0xb5, 0x33, 0xfb, 0xa7, 0xb6,
	0x52, 0xbd, 0xa3, 0xf7, 0x0f, 0x43, 0x24, 0x67, 0x01, 0xe2, 0x27, 0x6e, 0xfe, 0x20, 0x61, 0x6b,
	0x90, 0x2f, 0xe5, 0xff, 0xb7, 0x5f, 0x28, 0x65, 0x96, 0x01, 0x0a, 0x32, 0x9a, 0x88, 0xb5, 0x0e,
	0xa7, 0xfb, 0x2e, 0x0a, 0x72, 0x09, 0x8a, 0x3b, 0xae, 0xb8, 0x12, 0xab, 0xef, 0xb9, 0xed, 0x36,
	0x6d, 0x8a, 0xed, 0x68, 0x46, 0xc2, 0x57, 0x38, 0x98, 0x73, 0xb6, 0xde, 0x87, 0xf9, 0xb4, 0xde,
	0x20, 0x2f, 0xc2, 0xa4, 0x1e, 0x38, 0x45, 0x30, 0x99, 0x70, 0x3b, 0x9e, 0x0c, 0x9d, 0x22, 0x18,
	0xfc, 0x7a, 0x06, 0x5e, 0x18, 0xb4, 0xb6, 0xc8, 0x22, 0x14, 0x3a, 0x81, 0xe7, 0xa3, 0x0c, 0xc7,
	0x77, 0x40, 0xf5, 0x9b, 0x9c, 0x01, 0xe0, 0xc2, 0x46, 0xe4, 0xee, 0x0a, 0x63, 0x7c, 0x7b, 0x1c,
	0x21, 0x5b, 0xee, 0x6e, 0x48, 0x5e, 0x83, 0xd9, 0x06, 0xdd, 0x71, 0xbb, 0xcd, 0xc8, 0x09, 0xeb,
	0x7b, 0xb4, 0x81, 0xfe, 0x2f, 0x68, 0x64, 0x65, 0x17, 0x45, 0x41, 0x4d, 0xc2, 0x7b, 0x5a, 0x3c,
	0xd2, 0xa7, 0xc5, 0xb7, 0xf2, 0x85, 0x4c, 0x31, 0x6b, 0xa3, 0xad, 0x91, 0xf5, 0x7d, 0x59, 0x58,
	0xe8, 0x37, 0x99, 0xc8, 0xbb, 0x69, 0x7d, 0xc0, 0x6f, 0xf5, 0x75, 0xb8, 0x7e, 0xab, 0xaf, 0xd5,
	0x46, 0x96, 0x40, 0x79, 0xaf, 0x1c, 0xe5, 0x89, 0x2e, 0x61, 0x8c, 0xa6, 0xe3, 0x86, 0xe1, 0x63,
	0xb6, 0x5e, 0x72, 0x5a, 0x18, 0x4b, 0x01, 0xd3, 0x69, 0x24, 0x8c, 0x7c, 0x01, 0xa0, 0xde, 0xf4,
	0x43, 0x8a, 0x8f, 0xe7, 0xe2, 0x20, 0xe6, 0x26, 0xbc, 0x0a, 0xaa, 0xbf, 0x96, 0x22, 0x74, 0xc5,
	0x6f, 0x50, 0x31, 0x80, 0x2e, 0x9c, 0xea, 0xb3, 0x7b, 0xb0, 0xe1, 0x89, 0xd3, 0x1c, 0xcb, 0xa4,
	0x29, 0x5d, 0x95, 0xec, 0x38, 0xd9, 0xe3, 0xd9, 0x7e, 0x73, 0x64, 0x1f, 0x48, 0xef, 0x16, 0xc1,
	0xb8, 0x0b, 0x43, 0xd4, 0x6e, 0xa0, 0xb8, 0x73, 0xc8, 0xbd, 0xa0, 0x49, 0x4a, 0x30, 0x21, 0x93,
	0xa2, 0x31, 0x41, 0x97, 0x33, 0x07, 0x01, 0xba, 0x4d, 0x71, 0xf2, 0x60, 0xb4, 0x55, 0xf4, 0x51,
	0x12, 0x47, 0xe8, 0x38, 0x42, 0xb6, 0xf6, 0x3b, 0xf2, 0xeb, 0x5e, 0x90, 0xf3, 0xdb, 0xdc, 0xb8,
	0x45, 0xe9, 0x4f, 0x67, 0xe4, 0xf0, 0xf7, 0xee, 0x7c, 0x47, 0xb5, 0x8f, 0x00, 0x7a, 0x94, 0x88,
	0x86, 0xe1, 0xdf, 0xec, 0x48, 0x97, 0xab, 0x4e, 0x1c, 0xe9, 0xe2, 0x27, 0xb9, 0x00, 0x33, 0x01,
	0xb7, 0x39, 0x8c, 0x7c, 0xd1, 0x9f, 0x38, 0x52, 0xf6, 0x14, 0x07, 0x6f, 0xf9, 0xd8, 0xa7, 0xa2,
	0x5d, 0xb7, 0x54, 0x87, 0x69, 0x07, 0x01, 0xb9, 0x0c, 0xe3, 0xec, 0x20, 0xc0, 0xa8, 0x24, 0x09,
	0x53, 0x76, 0xc4, 0xc3, 0x63, 0xd5, 0x2e, 0x7c, 0x24, 0xfe, 0x16, 0xbc, 0xfe, 0xcb, 0x8c, 0x64,
	0xa6, 0x1f, 0x43, 0xe4, 0x14, 0x8c, 0xf9, 0xc1, 0xae, 0xf6, 0x69, 0xa3, 0x7e, 0xb0, 0xcb, 0xbe,
	0xeb, 0x22, 0x14, 0xb9, 0x67, 0x05, 0x77, 0x59, 0x0f, 0xf7, 0xdb, 0x5c, 0x4f, 0x2d, 0xd8, 0xd3,
	0x1c, 0x8e, 0x99, 0x9f, 0xf7, 0xdb, 0x75, 0x86, 0x19, 0x86, 0xbe, 0xa3, 0x07, 0x23, 0x12, 0x9f,
	0x3d, 0x1d, 0x86, 0x7e, 0x1c, 0x95, 0xa8, 0x41, 0x96, 0x61, 0x8a, 0xf1, 0x51, 0x21, 0x91, 0xc4,
	0x29, 0x79, 0xa6, 0xf7, 0x94, 0xdc, 0x6f, 0xd7, 0x65, 0x13, 0xed, 0xc9, 0x50, 0xfb, 0x25, 0xbe,
	0xe6, 0x67, 0xb2, 0x70, 0x32, 0x1d, 0x1d, 0xc7, 0x8b, 0x55, 0x82, 0x0e, 0x46, 0xfc, 0x7a, 0xd3,
	0x1e, 0x67, 0x10, 0x1e, 0x43, 0x21, 0xad, 0xb5, 0xd9, 0xd4, 0xd6, 0xbe, 0x0a, 0xb3, 0xc8, 0x48,
	0xc8, 0x25, 0x4d, 0x2f, 0x8c, 0x44, 0x68, 0x00, 0x7b, 0x86, 0x15, 0xf0, 0x0d, 0x6e, 0x9d, 0x81,
	0xc9, 0xcb, 0x30, 0x2d, 0xb7, 0x28, 0xff, 0x71, 0x9b, 0x55, 0xcc, 0xf7, 0xa7, 0x29, 0x01, 0xbd,
	0x8b, 0x40, 0x72, 0x02, 0x46, 0xdd, 0x4e, 0x87, 0x55, 0xc9, 0xb7, 0xa5, 0x11, 0xb7, 0xd3, 0xa9,
	0x36, 0xc8, 0x79, 0x98, 0x42, 0x77, 0x2a, 0x67, 0x07, 0x6d, 0x4a, 0x84, 0x01, 0x9b, 0x3d, 0x89,
	0x40, 0x6e, 0x67, 0x12, 0xb2, 0x85, 0xc0, 0x68, 0x25, 0xca, 0x18, 0xa2, 0x80, 0xdb, 0x91, 0x08,
	0xa2, 0x67, 0xbe, 0x08, 0x33, 0xe2, 0x34, 0x15, 0x3b, 0x3c, 0x52, 0x8a, 0xf9, 0xc7, 0xc4, 0x5c,
	0x91, 0x2c, 0x02, 0x04, 0xa8, 0xda, 0x90, 0x94, 0x7f, 0x90, 0x81, 0x13, 0xa9, 0xc7, 0x31, 0xf9,
	0x26, 0x70, 0xef, 0x92, 0xc8, 0x77, 0x02, 0x5a, 0xf7, 0x3a, 0x1e, 0xfa, 0xdf, 0xf3, 0xeb, 0xaa,
	0xa5, 0x41, 0x07, 0x39, 0x7a, 0xaa, 0x6c, 0xf9, 0xb6, 0x22, 0xe2, 0x7a, 0x74, 0x31, 0x48, 0x80,
	0x17, 0xbf, 0x0a, 0x27, 0x52, 0x51, 0x53, 0xf4, 0xdb, 0xd7, 0xcd, 0xa4, 0x9a, 0xf2, 0x01, 0x22,
	0xf1, 0xd1, 0x9a, 0xde, 0x2b, 0x3e, 0xef, 0xb7, 0xd4, 0xe7, 0x25, 0x0e, 0x6e, 0xb2, 0x9a, 0x9c,
	0x96, 0x69, 0xb2, 0xa7, 0x24, 0xea, 0x3b, 0x33, 0xc9, 0x57, 0xe1, 0x84, 0x98, 0x2a, 0xbb, 0x81,
	0xdb, 0xd9, 0x8b, 0xd9, 0xf1, 0x86, 0xbe, 0x92, 0xc6, 0x8e, 0xcf, 0xa1, 0x9b, 0x0c, 0x5f, 0x71,
	0x9d, 0x73, 0x7b, 0x81, 0xe2, 0x1b, 0x02, 0x79, 0xe8, 0xa7, 0xb4, 0x26, 0x65, 0x0e, 0x66, 0xd2,
	0xe6, 0xe0, 0xd0, 0x0b, 0x40, 0xd4, 0xf9, 0xfd, 0x19, 0x38, 0x77, 0x54, 0x9b, 0xc9, 0x03, 0x38,
	0x89, 0x4f, 0xe4, 0xa1, 0xaf, 0x3e, 0xdb, 0xa9, 0xbb, 0xf5, 0x3d, 0x2a, 0x66, 0x89, 0x95, 0xfa,
	0xf1, 0x9d, 0x4e, 0xad, 0x76, 0x57, 0xfb, 0xee, 0x4e, 0xa7, 0x16, 0xfa, 0xf2, 0xf7, 0x0a, 0x23,
	0x17, 0x6d, 0x68, 0xc0, 0xf3, 0x03, 0x28, 0xb5, 0x65, 0x95, 0xd1, 0x97, 0xd5, 0x45, 0x28, 0xee,
	0xd0, 0x06, 0x13, 0xa1, 0x68, 0x03, 0x9b, 0xf6, 0x68, 0x89, 0x67, 0xa6, 0xb5, 0xa7, 0x15, 0xbc,
	0x16, 0xfa, 0xf7, 0x97, 0x44, 0x2d, 0x2d, 0xb9, 0x43, 0xea, 0x22, 0x1a, 0xb9, 0x0c, 0x73, 0x89,
	0x58, 0x02, 0xb1, 0x73, 0xaa, 0x3d, 0xcb, 0x8a, 0xcc, 0xc8, 0x33, 0x2f, 0xc2, 0xa4, 0x1c, 0x86,
	0x40, 0xb9, 0xb8, 0xd8, 0x13, 0x02, 0xc6, 0x66, 0xb9, 0xa8, 0xee, 0xef, 0x65, 0xa5, 0xc8, 0xb4,
	0xec, 0xfb, 0x51, 0x18, 0x05, 0x6e, 0xc7, 0xd0, 0x9b, 0x48, 0x0b, 0x4e, 0xfb, 0x6e, 0x37, 0xda,
	0x5b, 0x72, 0xd8, 0xbf, 0x7e, 0x20, 0xfd, 0x4d, 0xeb, 0xd2, 0x68, 0x6e, 0x62, 0xe9, 0x8a, 0xb9,
	0x75, 0x96, 0x19, 0x76, 0x59, 0x47, 0x66, 0x27, 0xbc, 0xc6, 0x75, 0xed, 0x39, 0xfb, 0x14, 0xe7,
	0xd9, 0x83, 0x45, 0xd6, 0x60, 0x72, 0x9b, 0xba, 0x01, 0x0d, 0xb8, 0xa1, 0x68, 0xaa, 0xe2, 0xb4,
	0x8c, 0x08, 0x68, 0x3f, 0x6a, 0x72, 0x9d, 0xd8, 0x8e, 0x4b, 0xc8, 0x7b, 0x30, 0xee, 0x35, 0x44,
	0x68, 0x43, 0xa1, 0x3e, 0x99, 0x22, 0x7b, 0xb5, 0xc1, 0x23, 0x1d, 0xc6, 0x3c, 0x98, 0xee, 0xe5,
	0x09, 0xe8, 0xf2, 0x94, 0xa1, 0x61, 0x5a, 0xcb, 0xf2, 0x74, 0xee, 0x25, 0x23, 0xd3, 0x90, 0x55,
	0xc3, 0x9e, 0xf5, 0x1a, 0xe4, 0x24, 0x8c, 0x86, 0x5a, 0xac, 0x45, 0x5b, 0xfc, 0xb2, 0xfe, 0x12,
	0x5c, 0x1c, 0xb6, 0x8f, 0xc8, 0x1b, 0x40, 0xfa, 0x74, 0xf8, 0xb8, 0x3d, 0xeb, 0xf6, 0xf4, 0xdb,
	0x8b, 0xa0, 0x87, 0x8a, 0xf3, 0xe4, 0x80, 0x4b, 0xd8, 0xbd, 0xc0, 0xb3, 0x7e, 0x20, 0x07, 0xd3,
	0xa6, 0x4e, 0x4d, 0x5e, 0x83, 0xbc, 0x62, 0x3b, 0xad, 0xee, 0x7e, 0x75, 0x24, 0xc6, 0xdc, 0x46,
	0x24, 0x76, 0x40, 0xe0, 0x53, 0x91, 0xd3, 0xd2, 0xaf, 0x67, 0xed, 0x49, 0x04, 0xca, 0x6b, 0xd9,
	0x5b, 0xc0, 0x13, 0xa1, 0xe3, 0x5e, 0x16, 0x79, 0x2d, 0x3a, 0xc4, 0xed, 0x6c, 0x81, 0x69, 0xf6,
	0x78, 0xaf, 0x36, 0xc9, 0x68, 0xd9, 0x7e, 0xc2, 0x0a, 0x35, 0x95, 0x29, 0xdf, 0x5f, 0x65, 0x12,
	0x9f, 0xd2, 0x47, 0x65, 0x1a, 0x19, 0xa0, 0x32, 0xc5, 0x94, 0xba, 0xca, 0x84, 0x8a, 0xf3, 0x58,
	0x3f, 0xc5, 0x39, 0xa6, 0xe1, 0x8a, 0xf3, 0x4b, 0xe2, 0x73, 0x03, 0xf7, 0xb1, 0x83, 0xfd, 0xc0,
	0x8d, 0xda, 0xf8, 0x87, 0xd8, 0xee, 0x63, 0x7c, 0x54, 0x5b, 0x1e, 0x07, 0xf9, 0x12, 0x67, 0xfd,
	0xcd, 0x4c, 0x42, 0xc9, 0x91, 0x43, 0xf1, 0x32, 0x4c, 0x7b, 0x2d, 0x26, 0x7d, 0xd1, 0x86, 0x26,
	0x35, 0x4c, 0xd9, 0x53, 0x12, 0xca, 0x25, 0x87, 0x57, 0x60, 0x46, 0xa1, 0x71, 0xef, 0x67, 0x6e,
	0xa1, 0x6f, 0x2b, 0x6a, 0xe1, 0xfd, 0xfc, 0x1a, 0xcc, 0x2a, 0x44, 0x21, 0xa8, 0x72, 0xc1, 0x61,
	0xca, 0x2e, 0xca, 0x02, 0x91, 0xd2, 0x37, 0xb4, 0x76, 0x93, 0xa7, 0xd2, 0xa7, 0xd4, 0x2a, 0xeb,
	0xb7, 0x72, 0x86, 0x00, 0x28, 0xab, 0x59, 0x86, 0x09, 0xb6, 0x35, 0x8a, 0x4e, 0x12, 0xdb, 0xca,
	0x8b, 0x7d, 0xba, 0x5f, 0xbc, 0x65, 0xd6, 0x6a, 0x77, 0x6d, 0x08, 0x43, 0x5f, 0x3e, 0x6d, 0x3a,
	0x7c, 0xf7, 0xe7, 0x32, 0x0c, 0x4e, 0x3f, 0xc9, 0x8e, 0xef, 0x21, 0xaf, 0x0e, 0x66, 0x57, 0xee,
	0x74, 0xb0, 0x8d, 0x6c, 0xf6, 0xe1, 0x29, 0xa0, 0x7e, 0xc9, 0x0a, 0xee, 0x01, 0xea, 0x4b, 0xa1,
	0xc9, 0x3c, 0x97, 0x72, 0xae, 0xf6, 0x30, 0xc7, 0x5e, 0x42, 0xce, 0xc5, 0xae, 0xfc, 0x53, 0xb2,
	0x5d, 0x85, 0x49, 0xa6, 0x7d, 0x2b, 0x86, 0x79, 0xc3, 0x55, 0xa9, 0xdf, 0xc7, 0xaf, 0x54, 0xef,
	0xd8, 0x13, 0x8c, 0x4e, 0xb2, 0xd9, 0x83, 0xd3, 0xba, 0x8c, 0x68, 0x36, 0x72, 0x44, 0x06, 0x73,
	0x1b, 0xd8, 0x03, 0xb1, 0x28, 0x89, 0x4d, 0x3d, 0xe9, 0x9a, 0x00, 0x81, 0x66, 0xed, 0xc1, 0x62,
	0xff, 0x21, 0x61, 0x6a, 0x07, 0xd5, 0xfd, 0xa3, 0x6d, 0xf9, 0x53, 0x3b, 0x20, 0xb3, 0xfa, 0x01,
	0x79, 0x1a, 0x0a, 0xd2, 0x1e, 0x4e, 0x2a, 0x2a, 0x2e, 0xb7, 0x85, 0xb3, 0xfe, 0x4e, 0x0e, 0xce,
	0x0f, 0x31, 0x5c, 0x03, 0xea, 0xfc, 0x00, 0x26, 0xf8, 0x85, 0x21, 0xdf, 0x3e, 0xf9, 0x63, 0xbb,
	0x3c, 0x06, 0x18, 0x53, 0xb1, 0xd7, 0x31, 0x11, 0x26, 0xde, 0xef, 0x20, 0x54, 0x7f, 0x93, 0x6f,
	0xc2, 0x0c, 0xdf, 0xd0, 0xb8, 0x39, 0xc2, 0x4e, 0xb7, 0x39, 0xc4, 0x8e, 0xf6, 0xbc, 0xb4, 0x9d,
	0x4e, 0x90, 0xe2, 0x26, 0x87, 0x3b, 0x46, 0x4d, 0xc1, 0xc8, 0x16, 0x4c, 0x20, 0xda, 0x8e, 0xeb,
	0x35, 0x87, 0x32, 0xe2, 0x95, 0x96, 0xd9, 0x3a, 0x19, 0xb7, 0xa2, 0x62, 0x80, 0x1b, 0xf8, 0x9b,
	0x29, 0x79, 0xed, 0x6e, 0xcb, 0x71, 0x3b, 0x1d, 0x3e, 0x17, 0xc4, 0xab, 0xcf, 0x88, 0x3d, 0xd5,
	0xee, 0xb6, 0xca, 0x9d, 0x0e, 0x0e, 0x29, 0x3e, 0x0f, 0xcd, 0x32, 0x3c, 0xbe, 0x6a, 0x25, 0xe6,
	0x28, 0x62, 0x32, 0x06, 0x7c, 0xdd, 0x0a, 0xdc, 0x79, 0xe0, 0xc6, 0x02, 0xfc, 0xba, 0xdb, 0xe6,
	0x3f, 0xac, 0x7f, 0x9e, 0x95, 0xb2, 0x59, 0xff, 0x79, 0xff, 0x17, 0x43, 0x94, 0x32, 0x44, 0x17,
	0xa1, 0xc8, 0xba, 0x3e, 0xde, 0x54, 0xd4, 0x18, 0x4d, 0xb7, 0xbb, 0x2d, 0xd5, 0x77, 0x7a, 0xc7,
	0x8f, 0xea, 0x1d, 0xff, 0x05, 0x29, 0x90, 0xa6, 0x6e, 0x0f, 0xfd, 0xbb, 0xdc, 0xfa, 0xdf, 0x73,
	0x70, 0x61, 0xb8, 0x4d, 0xe0, 0x2f, 0xc6, 0x2d, 0x65, 0xdc, 0x12, 0x4a, 0xf0, 0x48, 0x52, 0x09,
	0x4e, 0x5b, 0x7b, 0xa3, 0x69, 0x6b, 0xaf, 0x47, 0xe5, 0x1e, 0x4b, 0x51, 0xb9, 0x53, 0x17, 0x68,
	0xe1, 0x88, 0x05, 0x3a, 0xae, 0xcf, 0x93, 0x7f, 0x9a, 0x85, 0xb9, 0x94, 0x27, 0x11, 0xf2, 0x55,
	0x98, 0x93, 0xa2, 0x3d, 0x3f, 0x39, 0xb8, 0xc8, 0xcd, 0x4f, 0xdf, 0x4b, 0x69, 0x42, 0x3d, 0xa2,
	0xa5, 0x08, 0xde, 0xb3, 0x42, 0x9c, 0x8f, 0xcb, 0xff, 0xfc, 0x08, 0xf2, 0xe4, 0x43, 0x38, 0x89,
	0x61, 0x46, 0xeb, 0x8e, 0x26, 0xcf, 0x3b, 0x01, 0xdd, 0x11, 0xf3, 0xe1, 0xc5, 0x1e, 0xb1, 0xd7,
	0xab, 0x6b, 0xcd, 0xb1, 0xe9, 0xce, 0xda, 0x73, 0xf6, 0x7c, 0x98, 0x02, 0x4f, 0xea, 0x08, 0xff,
	0x61, 0x06, 0xac, 0xa3, 0xfb, 0x0b, 0xef, 0x2a, 0x93, 0x1d, 0x3e, 0x6e, 0x4f, 0xb8, 0x5a, 0xef,
	0x9d, 0x87, 0xa9, 0x80, 0xee, 0x04, 0xff, 0x1f, 0x75, 0x57, 0xf3, 0xe4, 0xb8, 0x71, 0xdd, 0x17,
	0x24, 0x67, 0x96, 0x7c, 0x9c, 0x0f, 0x4c, 0x6b, 0xb5, 0x3b, 0xde, 0x9d, 0x9d, 0x95, 0xa0, 0xd5,
	0x5a, 0x4b, 0x59, 0xb2, 0x57, 0x1b, 0x59, 0x5a, 0x25, 0x8a, 0x82, 0x21, 0xc1, 0x21, 0x76, 0x48,
	0x90, 0x02, 0xc0, 0x19, 0xaf, 0x64, 0x1b, 0x45, 0x0d, 0xb1, 0x33, 0x8c, 0x39, 0x20, 0x4d, 0x82,
	0x92, 0x57, 0x97, 0x24, 0x17, 0xbb, 0x2a, 0x89, 0xf3, 0xe1, 0xca, 0xc1, 0x95, 0x4a, 0x55, 0x2e,
	0x3a, 0xe4, 0x0f, 0xc8, 0x2d, 0xff, 0x80, 0xab, 0x5c, 0xae, 0xf2, 0x21, 0xa7, 0xa4, 0x4a, 0x95,
	0xa8, 0x2a, 0x39, 0x24, 0xc7, 0x54, 0x72, 0xf0, 0x29, 0xd5, 0xaf, 0xbb, 0x81, 0x06, 0x40, 0x52,
	0x33, 0x5a, 0x39, 0x29, 0x9f, 0x66, 0xf8, 0xfa, 0xbd, 0x46, 0xa3, 0xbf, 0xf0, 0xba, 0xdf, 0x7b,
	0xbf, 0xe7, 0x4f, 0x4f, 0xa5, 0xee, 0x2b, 0xd9, 0x6b, 0x9c, 0x28, 0x3a, 0x46, 0x80, 0x1d, 0x5d,
	0x48, 0xc9, 0x16, 0x42, 0x5a, 0x3d, 0x3a, 0xfa, 0xcd, 0x1d, 0x07, 0x3a, 0x9b, 0xe4, 0x06, 0xb2,
	0x1f, 0x0f, 0x0b, 0xc5, 0x9c, 0x9a, 0xb7, 0x39, 0x24, 0xd3, 0xe3, 0xc1, 0xd0, 0xd7, 0xfe, 0x5e,
	0x11, 0x1a, 0xc1, 0xbc, 0xce, 0x23, 0xef, 0x4b, 0x4e, 0x3c, 0xf9, 0x8c, 0x1a, 0x32, 0x4f, 0x44,
	0xf6, 0x77, 0xe0, 0x28, 0x41, 0x48, 0x48, 0xa0, 0x04, 0x21, 0xe5, 0x69, 0x3c, 0x11, 0x1e, 0x08,
	0x1b, 0x20, 0xdd, 0xed, 0x0e, 0xef, 0x91, 0xbb, 0x70, 0x99, 0x99, 0xfd, 0x44, 0x43, 0x37, 0x13,
	0x0d, 0x3d, 0xbc, 0x67, 0x8b, 0x72, 0xed, 0xa7, 0x4a, 0x64, 0xf8, 0x48, 0x37, 0xff, 0xf0, 0x1e,
	0x79, 0xe3, 0x7c, 0xee, 0x38, 0x45, 0xe1, 0x8e, 0x13, 0xb9, 0xe2, 0xbc, 0x99, 0x70, 0xc5, 0xb9,
	0xbd, 0xbc, 0x9f, 0xf8, 0x15, 0x6b, 0x3a, 0x37, 0xff, 0xff, 0x28, 0x70, 0x73, 0xa9, 0x04, 0xd9,
	0x81, 0xa2, 0xde, 0x31, 0xdd, 0x78, 0x64, 0xe9, 0x6a, 0x11, 0x14, 0xb2, 0x0f, 0xa5, 0xbd, 0xde,
	0x74, 0x70, 0x4c, 0x27, 0xf0, 0xdc, 0x4b, 0xa3, 0x4c, 0xb5, 0x11, 0x7b, 0xe3, 0x92, 0x1d, 0xcb,
	0x12, 0x0f, 0xb6, 0x70, 0x15, 0x64, 0x72, 0x5f, 0xa7, 0x2f, 0x0c, 0x32, 0x15, 0x66, 0xc4, 0xe8,
	0x0e, 0x93, 0x21, 0xa6, 0x17, 0xdf, 0x87, 0x42, 0x0b, 0x59, 0xdc, 0xc0, 0x0b, 0x00, 0x7b, 0xbd,
	0x04, 0xc5, 0x8e, 0x30, 0x7e, 0x48, 0xfe, 0x6b, 0xc2, 0xd0, 0x61, 0x47, 0xa5, 0xda, 0x9f, 0x2a,
	0xe2, 0x54, 0xff, 0xf9, 0x2f, 0x22, 0xa5, 0x6d, 0xe8, 0x2f, 0x4f, 0xdb, 0xd0, 0xff, 0x82, 0x69,
	0x1b, 0xb4, 0xbf, 0xe3, 0xb0, 0x9b, 0x66, 0xbf, 0x93, 0xca, 0xfb, 0xf6, 0xb4, 0x7e, 0x88, 0x46,
	0x62, 0x76, 0xbe, 0x20, 0xa5, 0xfd, 0xc9, 0x3e, 0x6b, 0xb1, 0x3b, 0xa2, 0x34, 0x55, 0xff, 0x3d,
	0x07, 0x3b, 0xcb, 0xc4, 0xe7, 0xa6, 0xa8, 0x53, 0x2e, 0x96, 0xa2, 0xee, 0x2e, 0x14, 0x19, 0x2d,
	0x99, 0xa7, 0x9d, 0x8b, 0xd2, 0x0e, 0x17, 0xc5, 0xe4, 0x05, 0x58, 0xd5, 0xab, 0x4e, 0x9c, 0xeb,
	0x02, 0xbd, 0x61, 0x7a, 0xc7, 0x53, 0xf4, 0xb3, 0xe0, 0x45, 0xe4, 0xbb, 0xd9, 0xf4, 0x2e, 0x3c,
	0xc9, 0xc5, 0x0d, 0xa9, 0x43, 0x32, 0x88, 0xb8, 0xd8, 0xde, 0x18, 0xc1, 0x95, 0x83, 0x22, 0xda,
	0xd9, 0x54, 0x31, 0x1a, 0xac, 0x76, 0x26, 0xfe, 0xd4, 0x0f, 0x65, 0x4f, 0x95, 0x31, 0x52, 0x6c,
	0x5e, 0xc2, 0xfd, 0x48, 0x7a, 0x4f, 0x58, 0xd8, 0xe0, 0xaa, 0x1c, 0xca, 0x8d, 0x8e, 0x27, 0x94,
	0x6c, 0x4b, 0x2c, 0xda, 0x8f, 0x14, 0xb8, 0x32, 0xaf, 0x59, 0x64, 0x07, 0x0a, 0xc1, 0xdc, 0xc4,
	0x34, 0x01, 0x0b, 0x5e, 0x2a, 0x63, 0x8e, 0xec, 0xc7, 0xa3, 0xc9, 0x59, 0x2f, 0x94, 0xdd, 0x73,
	0x24, 0xb2, 0x0d, 0xf4, 0x47, 0x1d, 0xff, 0x27, 0xb7, 0xc4, 0x66, 0x9b, 0xcf, 0xa4, 0xb2, 0xc1,
	0x3f, 0x9a, 0x0e, 0x60, 0xf6, 0x3b, 0xed, 0x31, 0x03, 0x58, 0xbd, 0x0f, 0x05, 0xda, 0xac, 0xd4,
	0x64, 0xa4, 0xd3, 0x41, 0x6f, 0x35, 0x39, 0x13, 0x6b, 0xd5, 0xb4, 0x77, 0x36, 0xb4, 0x91, 0x59,
	0x3b, 0x82, 0x8d, 0x24, 0x07, 0x31, 0x92, 0x90, 0x5c, 0xe5, 0xd7, 0x54, 0x5e, 0xd3, 0xde, 0x68,
	0xc4, 0x5c, 0x44, 0xf7, 0xbe, 0xf2, 0x4f, 0x9f, 0xde, 0x02, 0xfa, 0x93, 0xc9, 0xcc, 0x83, 0xec,
	0xd2, 0xfe, 0x3c, 0x07, 0x57, 0xe2, 0xa8, 0x34, 0xb1, 0x24, 0x7e, 0x63, 0x43, 0x24, 0xf4, 0x84,
	0x0b, 0xbf, 0xd0, 0x98, 0xb2, 0x2f, 0xb8, 0xc4, 0x73, 0x78, 0x1f, 0xb6, 0x17, 0xf1, 0x93, 0x97,
	0xa1, 0x84, 0x40, 0x06, 0xe3, 0xde, 0xb1, 0x2f, 0x6f, 0x65, 0x81, 0x20, 0xda, 0x71, 0xb9, 0xf6,
	0x0b, 0x05, 0xae, 0x73, 0xc7, 0xc6, 0x56, 0x6f, 0x10, 0x84, 0x7e, 0xd0, 0x0b, 0x8e, 0xfd, 0x2f,
	0x27, 0xc4, 0x67, 0x3f, 0xb1, 0x2d, 0xbd, 0x98, 0xf4, 0x5f, 0xcd, 0x3c, 0x6d, 0xf1, 0xdb, 0x92,
	0xbb, 0x08, 0xce, 0x71, 0xcc, 0x26, 0x6f, 0x81, 0x85, 0x54, 0x06, 0x94, 0x20, 0x87, 0x54, 0x22,
	0x87, 0xf6, 0x07, 0xb0, 0xbb, 0xfc, 0x01, 0xe4, 0x3b, 0xb0, 0x8e, 0xc9, 0x07, 0xba, 0xe3, 0x93,
	0x49, 0xaf, 0xef, 0x8b, 0x3b, 0x2d, 0x71, 0xa5, 0x28, 0x97, 0x31, 0x40, 0x12, 0x1e, 0xe2, 0x77,
	0x82, 0x69, 0x0d, 0xb8, 0x50, 0xc2, 0x7b, 0x58, 0xae, 0x4d, 0xfb, 0x43, 0x05, 0x48, 0xb6, 0x0e,
	0xf2, 0x4d, 0x58, 0xeb, 0xba, 0x55, 0x27, 0xec, 0x4d, 0xc2, 0xc6, 0x68, 0x36, 0xe1, 0x40, 0x1f,
	0x2c, 0xe2, 0x2b, 0x3c, 0xa6, 0x3b, 0xc3, 0x24, 0xf4, 0x4e, 0x47, 0xb3, 0x89, 0x9d, 0xe0, 0x43,
	0xd4, 0x7c, 0xdf, 0xff, 0x5e, 0xbf, 0xf7, 0x24, 0x89, 0x9a, 0xcf, 0x69, 0x09, 0xd4, 0x7c, 0x4e,
	0xd3, 0x3e, 0x51, 0xe0, 0x86, 0xf0, 0x78, 0xe8, 0xcf, 0x69, 0x4b, 0x15, 0xe3, 0x9a, 0x27, 0x02,
	0xe8, 0x6c, 0x99, 0x6e, 0xba, 0x25, 0x42, 0xff, 0xb1, 0x81, 0xa8, 0xa4, 0x32, 0x59, 0xf2, 0x7b,
	0x50, 0x70, 0xc2, 0xd1, 0xf8, 0x1c, 0xb1, 0xff, 0x6a, 0x34, 0xa2, 0xe1, 0x68, 0x8c, 0x55, 0xa0,
	0xa4, 0xe6, 0xc3, 0x15, 0xb9, 0x71, 0xa2, 0xc5, 0xa4, 0x05, 0x97, 0x39, 0x12, 0x4c, 0xca, 0x3a,
	0xb4, 0xe4, 0x9d, 0xf6, 0x36, 0x05, 0xc0, 0x00, 0x07, 0xda, 0xb2, 0x45, 0x1d, 0xda, 0x9f, 0x29,
	0x50, 0xa6, 0xca, 0x03, 0x1e, 0xc7, 0x9e, 0x76, 0x4a, 0x27, 0xf5, 0x40, 0x61, 0x5c, 0x8c, 0xaa,
	0x3f, 0xd7, 0xc7, 0xf5, 0x75, 0xd8, 0x4c, 0x09, 0x10, 0x0d, 0x43, 0x4b, 0x87, 0x83, 0xe3, 0x1e,
	0x03, 0xe1, 0x66, 0x96, 0xb9, 0x04, 0x4d, 0xfb, 0x63, 0x05, 0xae, 0xd0, 0xc3, 0xbb, 0x89, 0xf7,
	0xb6, 0xf6, 0x6c, 0x28, 0xd6, 0x3b, 0x55, 0x88, 0x84, 0xeb, 0x0c, 0x0b, 0x7b, 0x63, 0x0a, 0x11,
	0xa7, 0xd9, 0x51, 0x29, 0x69, 0x40, 0x91, 0x7f, 0x5f, 0xa6, 0x1c, 0x1f, 0x6b, 0x57, 0xba, 0x15,
	0x88, 0x2b, 0xe6, 0x4c, 0xf4, 0x4d, 0x70, 0x0b, 0xe3, 0x32, 0x76, 0x24, 0xad, 0xfd, 0x97, 0x02,
	0xd7, 0x16, 0xc8, 0x90, 0xb7, 0x61, 0x05, 0x5d, 0xf2, 0xf9, 0xe8, 0xed, 0x2c, 0x78, 0x44, 0x78,
	0x7c, 0x7a, 0x78, 0x8f, 0x7d, 0x88, 0xce, 0xe8, 0x0f, 0x9b, 0x49, 0x91, 0xf7, 0xa1, 0xa4, 0xf7,
	0xfb, 0xfc, 0x5c, 0x92, 0x4b, 0x9c, 0x4b, 0x16, 0x3c, 0xf1, 0xd5, 0x88, 0x9f, 0x9d, 0x4b, 0x98,
	0x73, 0x68, 0xbf, 0xef, 0xf1, 0x70, 0x83, 0xb8, 0xbe, 0xeb, 0xbf, 0x03, 0x1b, 0x49, 0xe6, 0x0b,
	0x9d, 0x4b, 0x7e, 0xaa, 0x80, 0x9a, 0x6c, 0xc3, 0xaf, 0x07, 0x1a, 0x61, 0xde, 0x30, 0x7f, 0xce,
	0xa4, 0xfa, 0xcb, 0x1c, 0x3c, 0x3b, 0xb7, 0x87, 0xc9, 0x2b, 0xb0, 0xaa, 0x8f, 0xc7, 0x66, 0x8d,
	0xcf, 0x2a, 0xae, 0xf0, 0xe0, 0x75, 0x6f, 0xe2, 0xd8, 0xc6, 0x98, 0xc8, 0x7d, 0x28, 0xe2, 0xcc,
	0xa4, 0x02, 0xb9, 0x18, 0xa9, 0x8a, 0xdd, 0x86, 0xa4, 0x90, 0xaa, 0x04, 0x23, 0xa9, 0xc3, 0x06,
	0x8f, 0x92, 0xb6, 0xfd, 0x13, 0xff, 0x07, 0x11, 0x64, 0x2a, 0xa2, 0xba, 0x8a, 0x3b, 0x64, 0x6f,
	0xc2, 0xca, 0xe4, 0x38, 0xe1, 0xa4, 0x14, 0x69, 0x82, 0x8a, 0x75, 0xca, 0x35, 0x31, 0xb8, 0x2c,
	0x8c, 0x5b, 0x67, 0x8d, 0x58, 0x50, 0x57, 0x46, 0x32, 0x1a, 0x2e, 0x7d, 0x3a, 0x1d, 0x9c, 0x04,
	0x67, 0x7e, 0x10, 0xfe, 0xfa, 0x86, 0x2b, 0x7e, 0xc6, 0xb9, 0x86, 0xeb, 0xaf, 0x0a, 0x6c, 0x31,
	0xa7, 0xc5, 0xa8, 0x46, 0x23, 0x21, 0x24, 0xa2, 0x46, 0x83, 0x39, 0x65, 0x59, 0x1c, 0x70, 0x0d,
	0x2e, 0xb3, 0xf8, 0x6c, 0xb1, 0x32, 0x6e, 0xce, 0x6d, 0x02, 0xe3, 0x39, 0xbc, 0xc7, 0xd4, 0x17,
	0x16, 0x1b, 0x30, 0xb5, 0x85, 0x28, 0x39, 0x84, 0x72, 0x75, 0xe8, 0xf7, 0x82, 0xd9, 0xd8, 0x3d,
	0x9f, 0x19, 0x70, 0x9b, 0xbf, 0xcb, 0xda, 0x31, 0x13, 0x43, 0xf3, 0x21, 0xee, 0xe4, 0x72, 0x45,
	0xc4, 0x8d, 0xdc, 0x85, 0x0b, 0x78, 0xe5, 0xf8, 0x8d, 0x25, 0xfd, 0x93, 0x26, 0xa2, 0x5c, 0xd2,
	0x17, 0x9e, 0xfb, 0x13, 0x7b, 0xb0, 0xd1, 0xec, 0x4d, 0x43, 0x77, 0xd2, 0x0b, 0xa6, 0x88, 0xeb,
	0x74, 0x0e, 0xdc, 0x0b, 0x91, 0x7d, 0x9a, 0x5d, 0x45, 0x86, 0x91, 0x28, 0xbb, 0x8a, 0x4c, 0x56,
	0x47, 0xf5, 0xa5, 0xfa, 0x20, 0xe8, 0x0d, 0x07, 0x1f, 0x8b, 0xa8, 0x0a, 0xa6, 0x2f, 0x3d, 0x16,
	0x44, 0x3b, 0x2e, 0xd7, 0xbe, 0x9d, 0x19, 0x37, 0xd6, 0xca, 0x32, 0x5c, 0xe6, 0x31, 0x77, 0x2c,
	0x06, 0xad, 0x63, 0x58, 0x35, 0xd3, 0xda, 0x57, 0x15, 0xb2, 0x01, 0xd0, 0xb1, 0xdb, 0x55, 0xc3,
	0x71, 0xe8, 0xef, 0x1c, 0xfd, 0xcd, 0x03, 0xd4, 0xea, 0xdd, 0xa6, 0x9a, 0x97, 0x62, 0xd4, 0x0a,
	0xda, 0xcf, 0x15, 0xb8, 0x3a, 0x7f, 0x28, 0x89, 0x0b, 0x18, 0xa5, 0xc8, 0x0d, 0xc2, 0xdf, 0x5c,
	0x3a, 0xee, 0x73, 0xc9, 0xe9, 0x68, 0xc7, 0x90, 0x45, 0xd1, 0xe5, 0x84, 0xd5, 0x27, 0xce, 0x9b,
	0x3c, 0xe8, 0x6b, 0x55, 0xd8, 0x5e, 0x54, 0x47, 0xf2, 0x55, 0x37, 0xa1, 0xac, 0x77, 0x3a, 0x4d,
	0xb3, 0xaa, 0xbb, 0x66, 0xdb, 0x52, 0x15, 0x52, 0x82, 0x95, 0x7d, 0xbb, 0xdd, 0xed, 0xa8, 0x39,
	0xed, 0x27, 0x0a, 0xac, 0x9b, 0x41, 0xe8, 0x9f, 0x30, 0x2f, 0xd5, 0xa7, 0x5d, 0x7c, 0x6f, 0x25,
	0x16, 0xdf, 0x76, 0x14, 0xcf, 0x1b, 0x3d, 0xe0, 0x5c, 0x2b, 0xef, 0x1f, 0x15, 0xd8, 0xca, 0xc8,
	0x10, 0x07, 0x2e, 0xeb, 0x47, 0x4e, 0xdb, 0xac, 0x55, 0x79, 0xcb, 0x84, 0x56, 0xce, 0xa9, 0xd9,
	0xa7, 0xb0, 0x18, 0x98, 0x8f, 0xa6, 0xde, 0x68, 0xd0, 0x97, 0xb2, 0x7f, 0x35, 0x2e, 0xd9, 0xa2,
	0x26, 0xfc, 0x92, 0x7d, 0x3c, 0x9b, 0xf8, 0x58, 0x6d, 0x2e, 0x71, 0xa3, 0x19, 0xd1, 0xb3, 0x15,
	0xa3, 0x53, 0x66, 0x8f, 0x96, 0x67, 0xab, 0x8e, 0xeb, 0xdb, 0x5b, 0x87, 0x32, 0x3f, 0xb5, 0xe0,
	0x81, 0xe0, 0xc7, 0x0a, 0x6c, 0x2f, 0x6a, 0x2b, 0x3d, 0x08, 0x25, 0x03, 0xe2, 0xae, 0x46, 0x88,
	0xc0, 0xc9, 0x48, 0x38, 0xc1, 0x46, 0xde, 0x81, 0x32, 0x4b, 0x46, 0xef, 0xdc, 0xef, 0xda, 0x26,
	0x9f, 0x20, 0x37, 0xff, 0xe3, 0xd3, 0x5b, 0xd7, 0x58, 0xea, 0x7a, 0x6f, 0x7a, 0xdf, 0x9b, 0x4d,
	0x06, 0x09, 0xf4, 0x54, 0x59, 0x42, 0xfb, 0xa1, 0x02, 0xd7, 0x17, 0xbf, 0x24, 0xfd, 0xca, 0xb8,
	0x54, 0x37, 0x8f, 0x63, 0x8a, 0xf0, 0x2b, 0x83, 0xfa, 0x7a, 0x2a, 0xa8, 0x28, 0x62, 0xa4, 0x42,
	0x51, 0x66, 0xcd, 0x5c, 0x26, 0x9d, 0x5e, 0x52, 0x48, 0x30, 0x6a, 0xff, 0x99, 0x83, 0xab, 0x74,
	0x02, 0x0d, 0xfd, 0xe9, 0x54, 0x9f, 0x85, 0xa7, 0x7e, 0x10, 0x72, 0x95, 0x8a, 0xbc, 0x01, 0xab,
	0xa7, 0x17, 0xbb, 0x0d, 0x64, 0xec, 0x84, 0x00, 0x6e, 0xca, 0xc2, 0xa9, 0x93, 0xfe, 0x4f, 0x9e,
	0x07, 0x39, 0x81, 0x61, 0x1e, 0x31, 0xab, 0x72, 0xdb, 0x8a, 0x5d, 0x1a, 0x47, 0xb9, 0xc6, 0xde,
	0x84, 0x15, 0xbc, 0x01, 0xe0, 0xdb, 0xa3, 0x50, 0x6b, 0xe7, 0xb7, 0x0e, 0xef, 0x07, 0x6c, 0x26,
	0x40, 0xbe, 0x0e, 0x10, 0xa3, 0xcf, 0xf2, 0xfd, 0x4f, 0x1c, 0xa5, 0x23, 0x00, 0x5a, 0xbb, 0x74,
	0xf6, 0xb8, 0xc7, 0x21, 0x5d, 0x2b, 0xb0, 0x25, 0xba, 0x65, 0x2c, 0xa0, 0x6e, 0xb8, 0x89, 0x6a,
	0x93, 0x15, 0x98, 0x63, 0x01, 0x77, 0x73, 0x3b, 0x93, 0x84, 0x0d, 0x11, 0xef, 0x52, 0x99, 0xd6,
	0x6e, 0x67, 0x32, 0xad, 0x15, 0x19, 0x97, 0x9c, 0x4e, 0x4d, 0xfb, 0xb7, 0x1c, 0x94, 0x8e, 0xa8,
	0xe2, 0x81, 0xc7, 0xe9, 0xe5, 0xc7, 0xf3, 0xd7, 0xa0, 0xdc, 0x1c, 0xf5, 0xb8, 0x2d, 0x60, 0xca,
	0x91, 0xbb, 0x30, 0x50, 0x67, 0x38, 0xea, 0x09, 0xb3, 0xc2, 0xd4, 0x96, 0x99, 0x3e, 0x27, 0xc8,
	0xe8, 0x21, 0xac, 0x32, 0xdb, 0x0c, 0xbf, 0xf8, 0x11, 0xaa, 0x67, 0xd4, 0xa2, 0x57, 0x59, 0xb1,
	0x74, 0x7d, 0xcd, 0xec, 0x3b, 0xb2, 0x1e, 0xc4, 0x81, 0xbb, 0xa4, 0xcb, 0x83, 0x95, 0xf3, 0x5d,
	0x1e, 0x48, 0x00, 0x25, 0xab, 0xe7, 0x01, 0x28, 0xb9, 0xfe, 0x00, 0xca, 0x52, 0x7b, 0x2e, 0xa4,
	0x89, 0xfe, 0x51, 0x0e, 0xd6, 0xf1, 0xad, 0x22, 0x47, 0x8d, 0xdf, 0xcc, 0xab, 0x90, 0xb7, 0x12,
	0x57, 0x21, 0xdb, 0xf2, 0x78, 0xb1, 0x37, 0x5b, 0x72, 0x07, 0xf2, 0x10, 0xb6, 0x32, 0x8c, 0xe4,
	0x75, 0x58, 0xa1, 0xcd, 0x17, 0x47, 0x47, 0x35, 0x3d, 0x03, 0x62, 0x30, 0x3b, 0xfa, 0xe2, 0x53,
	0x9b, 0x71, 0x6b, 0xff, 0xad, 0xc0, 0x1a, 0x87, 0x36, 0x0e, 0x1e, 0x8f, 0x3e, 0xb7, 0x3b, 0xef,
	0xa4, 0xbb, 0x93, 0x85, 0xcc, 0xf2, 0xee, 0xfc, 0xbf, 0xee, 0xc4, 0x07, 0x89, 0x4e, 0xbc, 0x16,
	0x41, 0xdb, 0x88, 0xd7, 0x59, 0xd2, 0x87, 0xff, 0x80, 0x60, 0x6f, 0x49, 0x46, 0xf2, 0x5d, 0x28,
	0x59, 0xfe, 0x47, 0x89, 0x13, 0xd8, 0x9d, 0x05, 0x95, 0xbe, 0x1a, 0x31, 0xb2, 0x35, 0x85, 0x1f,
	0xaf, 0xc0, 0xff, 0xc8, 0xcb, 0x98, 0x85, 0xe2, 0x2a, 0xe9, 0x21, 0x2c, 0x29, 0x76, 0x91, 0xa9,
	0xcf, 0x03, 0x33, 0x30, 0x0a, 0xfc, 0x47, 0x79, 0x80, 0xd8, 0xa7, 0x9d, 0x2e, 0xc0, 0x84, 0x45,
	0x5c, 0xdc, 0x45, 0x23, 0x49, 0x9e, 0xe3, 0xc2, 0x50, 0x7e, 0x87, 0x5f, 0xb2, 0xe6, 0x16, 0x43,
	0x0f, 0xe1, 0x75, 0x6b, 0x95, 0xfb, 0x8c, 0xf7, 0xfd, 0x61, 0x8f, 0xed, 0xed, 0xf9, 0xbd, 0xdb,
	0x88, 0x34, 0x17, 0x51, 0x17, 0xe4, 0xa8, 0x43, 0xcf, 0xf2, 0x1a, 0x65, 0xc8, 0xc4, 0x89, 0x14,
	0x2e, 0x16, 0x27, 0xd2, 0x81, 0xd2, 0x20, 0xf8, 0xd0, 0x0f, 0xc2, 0xd1, 0xe4, 0x09, 0x5a, 0xa3,
	0xe3, 0x2b, 0x2b, 0xda, 0x05, 0xa6, 0x28, 0x63, 0xe3, 0x80, 0x1f, 0xc6, 0x88, 0x5f, 0x1e, 0x86,
	0x88, 0x18, 0xc5, 0xb9, 0xac, 0xa8, 0xab, 0x0f, 0x0b, 0xc5, 0x55, 0xf5, 0xf2, 0xc3, 0x42, 0xb1,
	0xa8, 0x96, 0x1e, 0x16, 0x8a, 0x25, 0x15, 0x6c, 0xc9, 0xf4, 0x12, 0x99, 0x56, 0x24, 0x6b, 0x48,
	0xd2, 0xd2, 0xa1, 0xfd, 0x2a, 0x07, 0x24, 0xdb, 0x0c, 0xf2, 0x16, 0x94, 0xd9, 0x06, 0xeb, 0x4d,
	0xa6, 0xdf, 0xe7, 0x21, 0x04, 0x2c, 0x96, 0x5e, 0x22, 0xcb, 0xb1, 0xf4, 0x8c, 0x6c, 0x4f, 0xbf,
	0x3f, 0x24, 0xdf, 0x81, 0x67, 0xb0, 0x7b, 0xc7, 0xfe, 0x64, 0x30, 0xea, 0x7b, 0x08, 0x7c, 0xd6,
	0x1b, 0xf2, 0x7c, 0x32, 0xaf, 0x60, 0xe2, 0xb3, 0x6c, 0xf1, 0x82, 0x61, 0x40, 0x4f, 0xfd, 0x0e,
	0x72, 0x76, 0x18, 0x23, 0x71, 0x41, 0x95, 0xe5, 0x1f, 0xcf, 0x86, 0x43, 0x3e, 0xb2, 0x15, 0x7a,
	0x68, 0x4d, 0x97, 0x2d, 0xa8, 0x78, 0x23, 0xae, 0xb8, 0x3e, 0x1b, 0x0e, 0xc9, 0x1b, 0x00, 0xa3,
	0xc0, 0x3b, 0x1b, 0x4c, 0xa7, 0xcc, 0xfc, 0x10, 0x45, 0xd9, 0xc4, 0x54, 0x79, 0x30, 0x46, 0x41,
	0x8b, 0x11, 0xc9, 0x6f, 0x01, 0x86, 0xe0, 0x61, 0x6c, 0x2a, 0x73, 0x35, 0xe1, 0x08, 0xd1, 0x82,
	0x98, 0x0c, 0xea, 0x39, 0xf1, 0x9d, 0xc1, 0xc7, 0xc2, 0x53, 0xf8, 0x3d, 0xd8, 0xe2, 0x4e, 0x9e,
	0x47, 0x83, 0xf0, 0x94, 0x6b, 0xcb, 0x4f, 0xa3, 0x6a, 0x4b, 0xea, 0xf2, 0x3f, 0x17, 0x00, 0xf4,
	0x23, 0x47, 0xc0, 0x3e, 0xdc, 0x85, 0x15, 0x7a, 0x06, 0x10, 0x77, 0x09, 0x78, 0x13, 0x8b, 0xf5,
	0xca, 0x37, 0xb1, 0xc8, 0x41, 0x57, 0xa3, 0xed, 0x9f, 0xe0, 0x75, 0x56, 0x2e, 0xbe, 0x78, 0x98,
	0x30, 0x52, 0x42, 0xe7, 0x64, 0x24, 0xd2, 0x04, 0x88, 0x81, 0x18, 0xf8, 0xa9, 0x74, 0x2b, 0x8e,
	0x68, 0xe6, 0x05, 0x1c, 0xfa, 0x37, 0x06, 0x73, 0x90, 0xa7, 0x4f, 0xcc, 0x46, 0x0e, 0xa0, 0xe0,
	0xf6, 0xa2, 0x18, 0x92, 0x05, 0xf0, 0x14, 0xcf, 0xf1, 0x7c, 0x3f, 0x31, 0x44, 0xc5, 0x46, 0xd8,
	0x4b, 0xa4, 0x45, 0xc3, 0x4a, 0x88, 0x01, 0xab, 0x3c, 0x97, 0xe3, 0x02, 0x58, 0x23, 0x9e, 0xca,
	0x91, 0x83, 0x19, 0x22, 0x51, 0xd6, 0x29, 0x78, 0xd6, 0xc6, 0xd7, 0x20, 0xef, 0x38, 0x2d, 0x1e,
	0x94, 0xb9, 0x1e, 0x9f, 0x30, 0x1c, 0xa7, 0x25, 0x12, 0x15, 0x9f, 0x49, 0x62, 0x94, 0x99, 0xfc,
	0x36, 0x94, 0x25, 0xf5, 0x99, 0x87, 0x33, 0x63, 0x1f, 0x0c, 0x62, 0xb2, 0xbc, 0x69, 0x48, 0xdc,
	0xa4, 0x09, 0xea, 0xc1, 0xec, 0x03, 0x5f, 0x1f, 0x8f, 0x31, 0xfe, 0xe1, 0x43, 0x7f, 0xc2, 0xd4,
	0xb6, 0x62, 0x8c, 0x03, 0xe8, 0xf5, 0xc6, 0x63, 0xaf, 0x2f, 0x4a, 0xe5, 0xfb, 0x94, 0xb4, 0x24,
	0xe9, 0xc0, 0x96, 0xe3, 0x87, 0xb3, 0x31, 0x73, 0x9e, 0xa8, 0x8f, 0x26, 0xf4, 0x40, 0xc1, 0x82,
	0x9f, 0x11, 0x32, 0x6d, 0x4a, 0x0b, 0x85, 0xc7, 0xca, 0xe3, 0xd1, 0x24, 0x75, 0xb8, 0xc8, 0x0a,
	0x6b, 0xbe, 0x3c, 0xe4, 0xf4, 0xab, 0x9a, 0x3c, 0xa6, 0xe0, 0x57, 0x55, 0x1c, 0x53, 0xe2, 0xc3,
	0xc9, 0xd7, 0xe7, 0x00, 0x74, 0xa0, 0xf1, 0x4b, 0x02, 0xe8, 0x48, 0xc0, 0x72, 0x7c, 0x52, 0x90,
	0x30, 0xa2, 0xf8, 0x58, 0xbc, 0x0d, 0xf0, 0x70, 0x34, 0x08, 0x5a, 0x7e, 0x78, 0x3a, 0xea, 0x4b,
	0x38, 0x21, 0xe5, 0xdf, 0x1f, 0x0d, 0x02, 0xef, 0x0c, 0xc9, 0xbf, 0xfa, 0xf4, 0x96, 0xc4, 0x64,
	0x4b, 0xff, 0x93, 0xaf, 0x41, 0x89, 0xfe, 0x72, 0x63, 0x17, 0x10, 0x76, 0xed, 0x88, 0xd2, 0x3c,
	0xe5, 0x79, 0xc4, 0x40, 0x1e, 0x20, 0x76, 0xf8, 0x60, 0x1c, 0x4a, 0xca, 0xab, 0x00, 0x0a, 0x1f,
	0x8c, 0xc3, 0x34, 0xec, 0x9f, 0xc4, 0x4c, 0x1a, 0x51, 0xd3, 0x05, 0xfa, 0x3c, 0x87, 0x28, 0xc7,
	0xbb, 0x35, 0x3e, 0xd7, 0x3c, 0x81, 0x37, 0x26, 0xe7, 0x09, 0x4b, 0x89, 0x61, 0x23, 0x9c, 0x46,
	0x8d, 0x19, 0x43, 0xb8, 0x52, 0x2b, 0x12, 0x2d, 0xf7, 0xbd, 0x63, 0x24, 0x27, 0x1a, 0x11, 0x31,
	0x93, 0x3d, 0xd8, 0x64, 0x3a, 0x7e, 0x94, 0xc5, 0x86, 0xab, 0xb8, 0xb8, 0xb7, 0xc5, 0x69, 0x6e,
	0xe4, 0xc7, 0xa7, 0x04, 0x48, 0x1d, 0x56, 0xf0, 0x40, 0xc8, 0x5d, 0xb8, 0x6f, 0xc8, 0x27, 0xe1,
	0xf4, 0x3a, 0xc2, 0x7d, 0x05, 0xcf, 0xc0, 0xf2, 0xbe, 0x82, 0xac, 0xe4, 0x5b, 0x00, 0x46, 0x30,
	0x19, 0x0d, 0x87, 0x88, 0x88, 0x57, 0xc4, 0xa3, 0xd4, 0xcd, 0xe4, 0x7a, 0xc4, 0x5a, 0x62, 0x26,
	0x8e, 0xde, 0x82, 0xbf, 0xbd, 0x14, 0x6e, 0x9e, 0x54, 0x97, 0x66, 0xc2, 0x2a, 0x5b, 0x8c, 0x88,
	0x2e, 0xc9, 0xf1, 0xb2, 0x25, 0x6c, 0x42, 0x86, 0x2e, 0xc9, 0xe9, 0x59, 0x74, 0x49, 0x49, 0x40,
	0x3b, 0x80, 0x2b, 0xf3, 0x5e, 0x2c, 0x71, 0x84, 0x55, 0xce, 0x7b, 0x84, 0xfd, 0xdb, 0x3c, 0xac,
	0x61, 0x6d, 0x62, 0x17, 0xd6, 0x61, 0xdd, 0x99, 0x7d, 0x10, 0x41, 0x2f, 0x88, 0xdd, 0x18, 0xdb,
	0x37, 0x95, 0x0b, 0x64, 0x33, 0x55, 0x42, 0x82, 0x18, 0xb0, 0x21, 0xbe, 0x04, 0xfb, 0xc2, 0x2d,
	0x3c, 0x02, 0x76, 0x14, 0xf0, 0x41, 0xd9, 0x2c, 0x5e, 0x29, 0xa1, 0xf8, 0x7b, 0x90, 0xbf, 0xc8,
	0xf7, 0xa0, 0x70, 0xae, 0xef, 0xc1, 0xfb, 0xb0, 0x26, 0x9e, 0x86, 0x3b, 0xf9, 0xca, 0xd3, 0xed,
	0xe4, 0x89, 0xca, 0x48, 0x33, 0xda, 0xd1, 0x57, 0x97, 0xee, 0xe8, 0x68, 0xfb, 0x13, 0xab, 0x2c,
	0x93, 0x98, 0x97, 0xd7, 0x81, 0x69, 0x6e, 0xf6, 0xab, 0x9d, 0x2f, 0xf0, 0x95, 0x7c, 0x1d, 0x4a,
	0xcd, 0x91, 0x30, 0xfb, 0x48, 0xf7, 0xed, 0x43, 0x41, 0x94, 0xd5, 0x85, 0x88, 0x33, 0xfa, 0xba,
	0xe5, 0xbf, 0x8c, 0xaf, 0xdb, 0x03, 0x00, 0x1e, 0x6f, 0x10, 0xa7, 0xa7, 0xc0, 0x25, 0x23, 0x22,
	0x6b, 0x93, 0xd7, 0xfe, 0x12, 0x33, 0xdd, 0x9d, 0xb8, 0x83, 0x88, 0x7e, 0x7c, 0x3c, 0x9a, 0x05,
	0x61, 0x22, 0x9f, 0x1b, 0x0f, 0xb2, 0xa7, 0x9f, 0x04, 0x2c, 0x93, 0xb7, 0x87, 0x94, 0xd8, 0x97,
	0x3b, 0x20, 0xe4, 0xdd, 0xc8, 0xb3, 0x6d, 0x69, 0x7a, 0x6b, 0x2d, 0xd3, 0x43, 0x0b, 0xfd, 0xd9,
	0xb4, 0x9f, 0x2b, 0x32, 0xaa, 0xee, 0x17, 0x18, 0xea, 0x37, 0x01, 0x22, 0xbb, 0xbb, 0x18, 0x6b,
	0x76, 0x5e, 0x8a, 0xa8, 0x72, 0x2f, 0xc7, 0xbc, 0xd2, 0xdb, 0xe4, 0xbf, 0xac, 0xb7, 0x71, 0xa1,
	0xdc, 0xfe, 0x5e, 0xd8, 0x8b, 0x1d, 0x35, 0xc0, 0x89, 0x34, 0x59, 0xdc, 0x99, 0x44, 0x1a, 0xee,
	0x58, 0x0f, 0x5e, 0x98, 0x86, 0x3b, 0x12, 0xd4, 0xde, 0x85, 0x4d, 0x39, 0xfc, 0xef, 0x49, 0x70,
	0x4c, 0x7e, 0x97, 0x61, 0x7c, 0x29, 0x89, 0x13, 0x8b, 0xc4, 0x44, 0x77, 0xdc, 0x27, 0xc1, 0x31,
	0xd3, 0x7f, 0x7a, 0x1f, 0xc9, 0x6d, 0xc5, 0x33, 0xde, 0x2f, 0x15, 0x20, 0x59, 0x76, 0x79, 0x37,
	0x51, 0xfe, 0x1f, 0xb4, 0xcb, 0x94, 0x56, 0x56, 0xb8, 0x88, 0x56, 0x56, 0xf9, 0x0b, 0x05, 0x36,
	0x4d, 0xbd, 0xc5, 0x21, 0x70, 0x99, 0xfd, 0xe0, 0x79, 0xb8, 0x69, 0xea, 0x2d, 0xaf, 0xd3, 0x6e,
	0x9a, 0xd5, 0x47, 0xde, 0x5c, 0x64, 0xbb, 0x9b, 0xf0, 0x95, 0x2c, 0x4b, 0x6c, 0x67, 0xd8, 0x81,
	0xed, 0x6c, 0xb1, 0x40, 0xbf, 0x9b, 0x2f, 0x2c, 0x80, 0xf2, 0xf2, 0x95, 0x77, 0x60, 0x53, 0x20,
	0xbd, 0xb9, 0x4d, 0x07, 0xb1, 0x64, 0x37, 0xa1, 0x7c, 0x68, 0xd8, 0x66, 0xfd, 0x91, 0x57, 0xef,
	0x36, 0x9b, 0xea, 0x25, 0xb2, 0x0e, 0x25, 0x4e, 0xa8, 0xea, 0xaa, 0x42, 0xd6, 0xa0, 0x68, 0x5a,
	0x8e, 0x51, 0xed, 0xda, 0x86, 0x9a, 0xab, 0xbc, 0x03, 0x1b, 0x9d, 0xc9, 0xe0, 0xc3, 0x5e, 0xe8,
	0x1f, 0xf8, 0x4f, 0xd0, 0x4c, 0x70, 0x19, 0xf2, 0xb6, 0x7e, 0xa4, 0x5e, 0x22, 0x00, 0xab, 0x9d,
	0x83, 0xaa, 0x73, 0xef, 0x9e, 0xaa, 0x90, 0x32, 0x5c, 0xde, 0xaf, 0x76, 0xbc, 0x83, 0x96, 0xa3,
	0xe6, 0xe8, 0x0f, 0xfd, 0xc8, 0xc1, 0x1f, 0xf9, 0xca, 0x37, 0x60, 0x0b, 0x75, 0x85, 0xe6, 0x60,
	0x1a, 0xfa, 0x81, 0x3f, 0xc1, 0x36, 0xac, 0x41, 0xd1, 0xf1, 0xe9, 0x22, 0x0f, 0x7d, 0xd6, 0x80,
	0xd6, 0x6c, 0x18, 0x0e, 0xc6, 0x43, 0xff, 0x07, 0xaa, 0x52, 0x79, 0x00, 0x9b, 0xf6, 0x68, 0x16,
	0x0e, 0x82, 0x13, 0x27, 0xa4, 0x1c, 0x27, 0x4f, 0xc8, 0xb3, 0xb0, 0xd5, 0xb5, 0xf4, 0xd6, 0x9e,
	0xb9, 0xdf, 0x6d, 0x77, 0x1d, 0xaf, 0xa5, 0xbb, 0xd5, 0x06, 0x33, 0x52, 0xb4, 0xda, 0x8e, 0xeb,
	0xd9, 0x46, 0xd5, 0xb0, 0x5c, 0x55, 0xa9, 0xfc, 0x89, 0x02, 0x1b, 0xdd, 0x29, 0x77, 0xac, 0xed,
	0x62, 0x78, 0xdc, 0x73, 0xb0, 0xd3, 0x75, 0x0c, 0xdb, 0x73, 0xdb, 0x07, 0x86, 0xe5, 0x75, 0x1d,
	0x7d, 0x3f, 0x0d, 0xab, 0x78, 0x0b, 0x6e, 0x48, 0x1c, 0xb6, 0x51, 0x6d, 0x1f, 0x1a, 0xb6, 0xd7,
	0xd1, 0x1d, 0xe7, 0xa8, 0x6d, 0xd7, 0x54, 0x85, 0x5c, 0x87, 0xab, 0x73, 0x18, 0x5a, 0x75, 0x5d,
	0xcd, 0x65, 0xca, 0x2c, 0xe3, 0x48, 0x6f, 0x7a, 0x7b, 0x6d, 0x57, 0xcd, 0x57, 0x5a, 0xf4, 0x43,
	0x87, 0x70, 0x62, 0x0c, 0x37, 0xbe, 0x08, 0x05, 0xab, 0x6d, 0x19, 0x69, 0x43, 0xd2, 0x1a, 0x14,
	0xf5, 0x4e, 0xc7, 0x6e, 0x1f, 0xe2, 0x80, 0x02, 0xac, 0xd6, 0x0c, 0x8b, 0xb6, 0x2c, 0x4f, 0x4b,
	0x3a, 0x76, 0xbb, 0xd5, 0x76, 0x8d, 0x9a, 0x5a, 0xa8, 0xd8, 0x62, 0xc1, 0x88, 0x4a, 0x8f, 0x47,
	0xcc, 0x6a, 0x53, 0x33, 0xea, 0x7a, 0xb7, 0xe9, 0xf2, 0x0e, 0x79, 0xe4, 0xd9, 0xc6, 0xbb, 0x5d,
	0xc3, 0x71, 0x1d, 0x55, 0x21, 0x2a, 0xac, 0x59, 0x86, 0x51, 0x73, 0x3c, 0xdb, 0x38, 0x34, 0x8d,
	0x23, 0x35, 0x47, 0xeb, 0x64, 0xff, 0xd3, 0x27, 0x54, 0x3e, 0x51, 0x80, 0x30, 0x28, 0x36, 0x81,
	0xef, 0x8d, 0xe3, 0xb3, 0x0b, 0xd7, 0x1b, 0xb4, 0x63, 0xf1, 0xd5, 0x5a, 0xed, 0x5a, 0xba, 0xcb,
	0xae, 0x02, 0x49, 0x95, 0xb7, 0xeb, 0x75, 0x55, 0x21, 0x37, 0xe0, 0x99, 0x14, 0xbd, 0x66, 0xb7,
	0x3b, 0x6a, 0xee, 0x7a, 0xae, 0xa8, 0x90, 0x6b, 0x99, 0xc2, 0x03, 0xc3, 0xe8, 0xa8, 0x79, 0x3a,
	0x44, 0xa9, 0x02, 0x31, 0x01, 0x99, 0x78, 0xa1, 0xf2, 0x43, 0x05, 0xae, 0xb2, 0x66, 0x8a, 0xd9,
	0x1c, 0x35, 0x75, 0x07, 0xb6, 0x39, 0xc0, 0xe4, 0xbc, 0x86, 0x5e, 0x01, 0x35, 0x51, 0xca, 0x9a,
	0xf9, 0x2c, 0x6c, 0x25, 0xa8, 0xd8, 0x8e, 0x1c, 0x5d, 0xab, 0x09, 0xf2, 0x9e, 0xe1, 0xb8, 0x9e,
	0x51, 0xaf, 0xb7, 0x6d, 0x97, 0x35, 0x24, 0x5f, 0xd1, 0x60, 0xab, 0xea, 0x4f, 0x42, 0x7a, 0x06,
	0x09, 0xa6, 0x83, 0x51, 0x80, 0x4d, 0x58, 0x87, 0x92, 0xf1, 0x2d, 0xd7, 0xb0, 0x1c, 0xb3, 0x6d,
	0xa9, 0x97, 0x2a, 0x3b, 0x29, 0x1e, 0xb1, 0x6a, 0x1c, 0xa7, 0xa1, 0x5e, 0xaa, 0xf4, 0x60, 0x5d,
	0x38, 0xb2, 0xb2, 0x59, 0xb1, 0x0b, 0xd7, 0xc5, 0x5c, 0xc3, 0xf5, 0x9b, 0x7e, 0x85, 0x6d, 0xb8,
	0x92, 0x2d, 0x37, 0x5c, 0x55, 0xa1, 0xa3, 0x90, 0x2a, 0xa1, 0xf4, 0x5c, 0xe5, 0x6f, 0x14, 0xd8,
	0xe6, 0x99, 0x34, 0xb9, 0x05, 0x81, 0x61, 0x5a, 0x23, 0xe8, 0x5b, 0x05, 0xee, 0xb8, 0x76, 0xd7,
	0x71, 0x8d, 0x9a, 0x57, 0x33, 0x0e, 0xcd, 0xaa, 0x81, 0xd3, 0xc5, 0xb4, 0x8d, 0x96, 0x61, 0xb9,
	0xa9, 0x47, 0xbf, 0x0c, 0x5f, 0x5d, 0xc2, 0x6b, 0xb5, 0x5d, 0xf1, 0x9b, 0xae, 0x92, 0xaf, 0xc2,
	0x0b, 0x4b, 0x98, 0x23, 0xc6, 0x5c, 0xe5, 0xdb, 0xb0, 0x96, 0xc8, 0xd3, 0x71, 0x0d, 0x9e, 0x91,
	0x7f, 0x77, 0xfc, 0xa0, 0x3f, 0x08, 0x4e, 0xd4, 0x4b, 0xe9, 0x02, 0x7b, 0x16, 0x04, 0xb4, 0x00,
	0x17, 0xa4, 0x5c, 0xe0, 0xfa, 0x93, 0xb3, 0x41, 0xd0, 0x0b, 0xfd, 0xbe, 0x9a, 0xab, 0xbc, 0x0a,
	0xeb, 0x09, 0x74, 0x40, 0xda, 0xf3, 0xcd, 0x36, 0xdf, 0xaf, 0x5a, 0x46, 0xcd, 0xec, 0xb6, 0xd4,
	0x15, 0xba, 0x14, 0x1b, 0xe6, 0x7e, 0x43, 0x85, 0xca, 0x4f, 0x14, 0xaa, 0x31, 0x63, 0xff, 0xb4,
	0xea, 0xba, 0x18, 0x2b, 0x3a, 0x4f, 0x18, 0xe6, 0xa8, 0xe1, 0x38, 0xcc, 0x00, 0xba, 0x03, 0xdb,
	0xfc, 0x87, 0xa7, 0x5b, 0x35, 0xaf, 0xa1, 0xdb, 0xb5, 0x23, 0xdd, 0xa6, 0x93, 0xe7, 0x91, 0x9a,
	0xc3, 0x15, 0x21, 0x51, 0x3c, 0xb7, 0xdd, 0xad, 0x36, 0xd4, 0x3c, 0x9d, 0x80, 0x09, 0x7a, 0xc7,
	0xb4, 0xd4, 0x02, 0xae, 0xaf, 0x0c, 0x37, 0x56, 0x4b, 0xcb, 0x57, 0x2a, 0x9f, 0x29, 0x70, 0xcd,
	0x19, 0x9c, 0x04, 0xbd, 0x70, 0x36, 0xf1, 0xf5, 0xe1, 0xc9, 0x68, 0x32, 0x08, 0x4f, 0xcf, 0x9c,
	0xd9, 0x20, 0xf4, 0xc9, 0x5d, 0x78, 0xd1, 0x31, 0xf7, 0x2d, 0xdd, 0xa5, 0xeb, 0x43, 0x6f, 0xee,
	0xb7, 0x6d, 0xd3, 0x6d, 0xb4, 0x3c, 0xa7, 0x6b, 0x66, 0xa6, 0xce, 0x6d, 0x78, 0x6e, 0x31, 0x6b,
	0xd3, 0xd8, 0xd7, 0xab, 0x8f, 0x54, 0x65, 0x79, 0x85, 0x7b, 0x7a, 0x53, 0xb7, 0xaa, 0x46, 0xcd,
	0x3b, 0xbc, 0xa7, 0xe6, 0xc8, 0x8b, 0xf0, 0xfc, 0x62, 0xd6, 0xba, 0xd9, 0x71, 0x28, 0x5b, 0x7e,
	0xf9, 0x73, 0x1b, 0x4e, 0x8b, 0x72, 0x15, 0x2a, 0x03, 0x50, 0xd3, 0x71, 0xcf, 0x19, 0x73, 0xbb,
	0xdd, 0xb5, 0x2c, 0xb6, 0x4b, 0x6e, 0x42, 0xb9, 0xed, 0x36, 0x0c, 0x9b, 0x43, 0xdf, 0x22, 0xd6,
	0x6d, 0xd7, 0xd2, 0xbb, 0x6e, 0xa3, 0x6d, 0x9b, 0xef, 0xe1, 0x76, 0xb9, 0x0d, 0x57, 0x9c, 0xa6,
	0x5e, 0x3d, 0xc0, 0x99, 0x69, 0x5a, 0x5e, 0xb5, 0xa1, 0x5b, 0x96, 0xd1, 0x54, 0xa1, 0xf2, 0xd7,
	0x0a, 0xb3, 0x7b, 0xcf, 0x0b, 0x90, 0x22, 0x5f, 0x83, 0x97, 0xda, 0x07, 0xae, 0xee, 0x75, 0x9a,
	0xdd, 0x7d, 0xd3, 0xf2, 0x9c, 0x47, 0x56, 0x55, 0x7c, 0x48, 0xab, 0xd9, 0x1d, 0xe5, 0x25, 0xb8,
	0xbd, 0x94, 0x3b, 0x06, 0xa9, 0xbd, 0x03, 0xda, 0x52, 0x4e, 0xfe, 0x22, 0x95, 0x5f, 0x28, 0x70,
	0x63, 0x89, 0xad, 0x90, 0xbc, 0x02, 0x77, 0x1b, 0x86, 0x5e, 0x6b, 0x1a, 0x8e, 0xe3, 0xd1, 0xf7,
	0x35, 0x2c, 0x97, 0x9b, 0xe5, 0xe7, 0xee, 0x17, 0x77, 0xe1, 0xc5, 0xe5, 0xec, 0xf1, 0x97, 0xe7,
	0x25, 0xb8, 0xbd, 0x9c, 0x95, 0x7f, 0x89, 0x72, 0x74, 0xd7, 0x58, 0xce, 0x19, 0x7d, 0xc1, 0xf2,
	0x95, 0x1f, 0x2b, 0x70, 0x75, 0xfe, 0x81, 0x9d, 0xb6, 0xcd, 0xb4, 0x1c, 0x57, 0x6f, 0x36, 0xbd,
	0x8e, 0x6e, 0xeb, 0x2d, 0xcf, 0xb0, 0xec, 0x76, 0xb3, 0x39, 0x6f, 0xe7, 0xbe, 0x0d, 0xcf, 0x2d,
	0x66, 0x75, 0xaa, 0xb6, 0xd9, 0xa1, 0x5b, 0xa0, 0x06, 0xbb, 0x8b, 0xb9, 0x0c, 0xb3, 0x6a, 0xa8,
	0xb9, 0xbd, 0xb7, 0x7f, 0xf6, 0xaf, 0xbb, 0x97, 0x7e, 0xf6, 0xd9, 0xae, 0xf2, 0xcb, 0xcf, 0x76,
	0x95, 0x7f, 0xf9, 0x6c, 0x57, 0x79, 0xef, 0xe5, 0x0b, 0xa4, 0x01, 0xff, 0x60, 0x15, 0xfd, 0x50,
	0xee, 0xff, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8d, 0x7b, 0x56, 0xb8, 0x21, 0x9b, 0x01, 0x00,
}

func (this *PluginSpecV1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1)
	if !ok {
		that2, ok := that.(PluginSpecV1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Settings == nil {
		if this.Settings != nil {
			return false
		}
	} else if this.Settings == nil {
		return false
	} else if !this.Settings.Equal(that1.Settings) {
		return false
	}
	if this.Generation != that1.Generation {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginSpecV1_SlackAccessPlugin) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_SlackAccessPlugin)
	if !ok {
		that2, ok := that.(PluginSpecV1_SlackAccessPlugin)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SlackAccessPlugin.Equal(that1.SlackAccessPlugin) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Opsgenie) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Opsgenie)
	if !ok {
		that2, ok := that.(PluginSpecV1_Opsgenie)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Opsgenie.Equal(that1.Opsgenie) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Openai) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Openai)
	if !ok {
		that2, ok := that.(PluginSpecV1_Openai)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Openai.Equal(that1.Openai) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Okta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Okta)
	if !ok {
		that2, ok := that.(PluginSpecV1_Okta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Okta.Equal(that1.Okta) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Jamf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Jamf)
	if !ok {
		that2, ok := that.(PluginSpecV1_Jamf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Jamf.Equal(that1.Jamf) {
		return false
	}
	return true
}
func (this *PluginSpecV1_PagerDuty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_PagerDuty)
	if !ok {
		that2, ok := that.(PluginSpecV1_PagerDuty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PagerDuty.Equal(that1.PagerDuty) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Mattermost) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Mattermost)
	if !ok {
		that2, ok := that.(PluginSpecV1_Mattermost)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Mattermost.Equal(that1.Mattermost) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Jira) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Jira)
	if !ok {
		that2, ok := that.(PluginSpecV1_Jira)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Jira.Equal(that1.Jira) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Discord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Discord)
	if !ok {
		that2, ok := that.(PluginSpecV1_Discord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Discord.Equal(that1.Discord) {
		return false
	}
	return true
}
func (this *PluginSpecV1_ServiceNow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_ServiceNow)
	if !ok {
		that2, ok := that.(PluginSpecV1_ServiceNow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServiceNow.Equal(that1.ServiceNow) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Gitlab) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Gitlab)
	if !ok {
		that2, ok := that.(PluginSpecV1_Gitlab)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Gitlab.Equal(that1.Gitlab) {
		return false
	}
	return true
}
func (this *PluginSpecV1_EntraId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_EntraId)
	if !ok {
		that2, ok := that.(PluginSpecV1_EntraId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EntraId.Equal(that1.EntraId) {
		return false
	}
	return true
}
func (this *PluginSpecV1_Scim) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSpecV1_Scim)
	if !ok {
		that2, ok := that.(PluginSpecV1_Scim)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Scim.Equal(that1.Scim) {
		return false
	}
	return true
}
func (this *PluginSlackAccessSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSlackAccessSettings)
	if !ok {
		that2, ok := that.(PluginSlackAccessSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FallbackChannel != that1.FallbackChannel {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginGitlabSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginGitlabSettings)
	if !ok {
		that2, ok := that.(PluginGitlabSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiEndpoint != that1.ApiEndpoint {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginOpsgenieAccessSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginOpsgenieAccessSettings)
	if !ok {
		that2, ok := that.(PluginOpsgenieAccessSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if len(this.AlertTags) != len(that1.AlertTags) {
		return false
	}
	for i := range this.AlertTags {
		if this.AlertTags[i] != that1.AlertTags[i] {
			return false
		}
	}
	if len(this.DefaultSchedules) != len(that1.DefaultSchedules) {
		return false
	}
	for i := range this.DefaultSchedules {
		if this.DefaultSchedules[i] != that1.DefaultSchedules[i] {
			return false
		}
	}
	if this.ApiEndpoint != that1.ApiEndpoint {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginServiceNowSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginServiceNowSettings)
	if !ok {
		that2, ok := that.(PluginServiceNowSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ApiEndpoint != that1.ApiEndpoint {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.CloseCode != that1.CloseCode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginPagerDutySettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginPagerDutySettings)
	if !ok {
		that2, ok := that.(PluginPagerDutySettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserEmail != that1.UserEmail {
		return false
	}
	if this.ApiEndpoint != that1.ApiEndpoint {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginJiraSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginJiraSettings)
	if !ok {
		that2, ok := that.(PluginJiraSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerUrl != that1.ServerUrl {
		return false
	}
	if this.ProjectKey != that1.ProjectKey {
		return false
	}
	if this.IssueType != that1.IssueType {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginOpenAISettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginOpenAISettings)
	if !ok {
		that2, ok := that.(PluginOpenAISettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginMattermostSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginMattermostSettings)
	if !ok {
		that2, ok := that.(PluginMattermostSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ServerUrl != that1.ServerUrl {
		return false
	}
	if this.Team != that1.Team {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.ReportToEmail != that1.ReportToEmail {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginJamfSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginJamfSettings)
	if !ok {
		that2, ok := that.(PluginJamfSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.JamfSpec.Equal(that1.JamfSpec) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginOktaSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginOktaSettings)
	if !ok {
		that2, ok := that.(PluginOktaSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OrgUrl != that1.OrgUrl {
		return false
	}
	if this.EnableUserSync != that1.EnableUserSync {
		return false
	}
	if this.SsoConnectorId != that1.SsoConnectorId {
		return false
	}
	if !this.SyncSettings.Equal(that1.SyncSettings) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginOktaSyncSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginOktaSyncSettings)
	if !ok {
		that2, ok := that.(PluginOktaSyncSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SyncUsers != that1.SyncUsers {
		return false
	}
	if this.SsoConnectorId != that1.SsoConnectorId {
		return false
	}
	if this.SyncAccessLists != that1.SyncAccessLists {
		return false
	}
	if len(this.DefaultOwners) != len(that1.DefaultOwners) {
		return false
	}
	for i := range this.DefaultOwners {
		if this.DefaultOwners[i] != that1.DefaultOwners[i] {
			return false
		}
	}
	if this.AppId != that1.AppId {
		return false
	}
	if len(this.GroupFilters) != len(that1.GroupFilters) {
		return false
	}
	for i := range this.GroupFilters {
		if this.GroupFilters[i] != that1.GroupFilters[i] {
			return false
		}
	}
	if len(this.AppFilters) != len(that1.AppFilters) {
		return false
	}
	for i := range this.AppFilters {
		if this.AppFilters[i] != that1.AppFilters[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DiscordChannels) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DiscordChannels)
	if !ok {
		that2, ok := that.(DiscordChannels)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ChannelIds) != len(that1.ChannelIds) {
		return false
	}
	for i := range this.ChannelIds {
		if this.ChannelIds[i] != that1.ChannelIds[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginDiscordSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginDiscordSettings)
	if !ok {
		that2, ok := that.(PluginDiscordSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RoleToRecipients) != len(that1.RoleToRecipients) {
		return false
	}
	for i := range this.RoleToRecipients {
		if !this.RoleToRecipients[i].Equal(that1.RoleToRecipients[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginEntraIDSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginEntraIDSettings)
	if !ok {
		that2, ok := that.(PluginEntraIDSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SyncSettings.Equal(that1.SyncSettings) {
		return false
	}
	if !this.AccessGraphSettings.Equal(that1.AccessGraphSettings) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginEntraIDSyncSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginEntraIDSyncSettings)
	if !ok {
		that2, ok := that.(PluginEntraIDSyncSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DefaultOwners) != len(that1.DefaultOwners) {
		return false
	}
	for i := range this.DefaultOwners {
		if this.DefaultOwners[i] != that1.DefaultOwners[i] {
			return false
		}
	}
	if this.SsoConnectorId != that1.SsoConnectorId {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginEntraIDAccessGraphSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginEntraIDAccessGraphSettings)
	if !ok {
		that2, ok := that.(PluginEntraIDAccessGraphSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AppSsoSettingsCache) != len(that1.AppSsoSettingsCache) {
		return false
	}
	for i := range this.AppSsoSettingsCache {
		if !this.AppSsoSettingsCache[i].Equal(that1.AppSsoSettingsCache[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginEntraIDAppSSOSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginEntraIDAppSSOSettings)
	if !ok {
		that2, ok := that.(PluginEntraIDAppSSOSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppId != that1.AppId {
		return false
	}
	if !bytes.Equal(this.FederatedSsoV2, that1.FederatedSsoV2) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PluginSCIMSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PluginSCIMSettings)
	if !ok {
		that2, ok := that.(PluginSCIMSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SamlConnectorName != that1.SamlConnectorName {
		return false
	}
	if this.DefaultRole != that1.DefaultRole {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *JamfSpecV1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JamfSpecV1)
	if !ok {
		that2, ok := that.(JamfSpecV1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.SyncDelay != that1.SyncDelay {
		return false
	}
	if this.ApiEndpoint != that1.ApiEndpoint {
		return false
	}
	if len(this.Inventory) != len(that1.Inventory) {
		return false
	}
	for i := range this.Inventory {
		if !this.Inventory[i].Equal(that1.Inventory[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *JamfInventoryEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*JamfInventoryEntry)
	if !ok {
		that2, ok := that.(JamfInventoryEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FilterRsql != that1.FilterRsql {
		return false
	}
	if this.SyncPeriodPartial != that1.SyncPeriodPartial {
		return false
	}
	if this.SyncPeriodFull != that1.SyncPeriodFull {
		return false
	}
	if this.OnMissing != that1.OnMissing {
		return false
	}
	if this.PageSize != that1.PageSize {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (m *KeepAlive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeepAlive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeepAlive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x52
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x48
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTypes(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x22
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0x42
	}
	if m.Expires != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintTypes(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rotation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rotation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastRotated, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastRotated):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTypes(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x3a
	if m.GracePeriod != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GracePeriod))
		i--
		dAtA[i] = 0x30
	}
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Started, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Started):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintTypes(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x2a
	if len(m.CurrentID) > 0 {
		i -= len(m.CurrentID)
		copy(dAtA[i:], m.CurrentID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CurrentID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Phase) > 0 {
		i -= len(m.Phase)
		copy(dAtA[i:], m.Phase)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Phase)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RotationSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RotationSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RotationSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Standby, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Standby):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintTypes(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdateServers, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateServers):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintTypes(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x12
	n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdateClients, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateClients):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintTypes(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResourceHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseServerV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseServerV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseServerV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseServerSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseServerSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseServerSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyIDs) > 0 {
		for iNdEx := len(m.ProxyIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProxyIDs[iNdEx])
			copy(dAtA[i:], m.ProxyIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyIDs[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Database != nil {
		{
			size, err := m.Database.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseV3List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseV3List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseV3List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Databases) > 0 {
		for iNdEx := len(m.Databases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Databases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Oracle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.MongoAtlas.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.AdminUser != nil {
		{
			size, err := m.AdminUser.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	{
		size, err := m.MySQL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.AD.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.TLS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.GCP.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.DynamicLabels) > 0 {
		for k := range m.DynamicLabels {
			v := m.DynamicLabels[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CACert) > 0 {
		i -= len(m.CACert)
		copy(dAtA[i:], m.CACert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CACert)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseAdminUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseAdminUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseAdminUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultDatabase) > 0 {
		i -= len(m.DefaultDatabase)
		copy(dAtA[i:], m.DefaultDatabase)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultDatabase)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AuditUser) > 0 {
		i -= len(m.AuditUser)
		copy(dAtA[i:], m.AuditUser)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuditUser)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseStatusV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseStatusV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseStatusV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.ManagedUsers) > 0 {
		for iNdEx := len(m.ManagedUsers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ManagedUsers[iNdEx])
			copy(dAtA[i:], m.ManagedUsers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ManagedUsers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.MySQL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.CACert) > 0 {
		i -= len(m.CACert)
		copy(dAtA[i:], m.CACert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CACert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.DocumentDB.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if len(m.SessionTags) > 0 {
		for k := range m.SessionTags {
			v := m.SessionTags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.IAMPolicyStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IAMPolicyStatus))
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.OpenSearch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if len(m.AssumeRoleARN) > 0 {
		i -= len(m.AssumeRoleARN)
		copy(dAtA[i:], m.AssumeRoleARN)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssumeRoleARN)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.RedshiftServerless.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.RDSProxy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.MemoryDB.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.SecretStore.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.ElastiCache.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.AccountID) > 0 {
		i -= len(m.AccountID)
		copy(dAtA[i:], m.AccountID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountID)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.RDS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Redshift.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecretStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KMSKeyID) > 0 {
		i -= len(m.KMSKeyID)
		copy(dAtA[i:], m.KMSKeyID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KMSKeyID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyPrefix) > 0 {
		i -= len(m.KeyPrefix)
		copy(dAtA[i:], m.KeyPrefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Redshift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Redshift) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Redshift) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RDS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RDS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RDS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VPCID) > 0 {
		i -= len(m.VPCID)
		copy(dAtA[i:], m.VPCID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VPCID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Subnets[iNdEx])
			copy(dAtA[i:], m.Subnets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Subnets[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IAMAuth {
		i--
		if m.IAMAuth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ResourceID) > 0 {
		i -= len(m.ResourceID)
		copy(dAtA[i:], m.ResourceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InstanceID) > 0 {
		i -= len(m.InstanceID)
		copy(dAtA[i:], m.InstanceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RDSProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RDSProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RDSProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResourceID) > 0 {
		i -= len(m.ResourceID)
		copy(dAtA[i:], m.ResourceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CustomEndpointName) > 0 {
		i -= len(m.CustomEndpointName)
		copy(dAtA[i:], m.CustomEndpointName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomEndpointName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ElastiCache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElastiCache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElastiCache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointType) > 0 {
		i -= len(m.EndpointType)
		copy(dAtA[i:], m.EndpointType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndpointType)))
		i--
		dAtA[i] = 0x22
	}
	if m.TransitEncryptionEnabled {
		i--
		if m.TransitEncryptionEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserGroupIDs) > 0 {
		for iNdEx := len(m.UserGroupIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserGroupIDs[iNdEx])
			copy(dAtA[i:], m.UserGroupIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.UserGroupIDs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ReplicationGroupID) > 0 {
		i -= len(m.ReplicationGroupID)
		copy(dAtA[i:], m.ReplicationGroupID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReplicationGroupID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoryDB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryDB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryDB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointType) > 0 {
		i -= len(m.EndpointType)
		copy(dAtA[i:], m.EndpointType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndpointType)))
		i--
		dAtA[i] = 0x22
	}
	if m.TLSEnabled {
		i--
		if m.TLSEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ACLName) > 0 {
		i -= len(m.ACLName)
		copy(dAtA[i:], m.ACLName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ACLName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedshiftServerless) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedshiftServerless) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedshiftServerless) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.WorkgroupID) > 0 {
		i -= len(m.WorkgroupID)
		copy(dAtA[i:], m.WorkgroupID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WorkgroupID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EndpointName) > 0 {
		i -= len(m.EndpointName)
		copy(dAtA[i:], m.EndpointName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndpointName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WorkgroupName) > 0 {
		i -= len(m.WorkgroupName)
		copy(dAtA[i:], m.WorkgroupName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WorkgroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenSearch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSearch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSearch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointType) > 0 {
		i -= len(m.EndpointType)
		copy(dAtA[i:], m.EndpointType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndpointType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DomainID) > 0 {
		i -= len(m.DomainID)
		copy(dAtA[i:], m.DomainID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DomainName) > 0 {
		i -= len(m.DomainName)
		copy(dAtA[i:], m.DomainName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DomainName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DocumentDB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentDB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentDB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointType) > 0 {
		i -= len(m.EndpointType)
		copy(dAtA[i:], m.EndpointType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndpointType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InstanceID) > 0 {
		i -= len(m.InstanceID)
		copy(dAtA[i:], m.InstanceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPCloudSQL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPCloudSQL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudSQL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InstanceID) > 0 {
		i -= len(m.InstanceID)
		copy(dAtA[i:], m.InstanceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProjectID) > 0 {
		i -= len(m.ProjectID)
		copy(dAtA[i:], m.ProjectID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Azure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Azure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Azure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsFlexiServer {
		i--
		if m.IsFlexiServer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Redis.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ResourceID) > 0 {
		i -= len(m.ResourceID)
		copy(dAtA[i:], m.ResourceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureRedis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureRedis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureRedis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusteringPolicy) > 0 {
		i -= len(m.ClusteringPolicy)
		copy(dAtA[i:], m.ClusteringPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusteringPolicy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AD) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AD) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KDCHostName) > 0 {
		i -= len(m.KDCHostName)
		copy(dAtA[i:], m.KDCHostName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KDCHostName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LDAPCert) > 0 {
		i -= len(m.LDAPCert)
		copy(dAtA[i:], m.LDAPCert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LDAPCert)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SPN) > 0 {
		i -= len(m.SPN)
		copy(dAtA[i:], m.SPN)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SPN)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Krb5File) > 0 {
		i -= len(m.Krb5File)
		copy(dAtA[i:], m.Krb5File)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Krb5File)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeytabFile) > 0 {
		i -= len(m.KeytabFile)
		copy(dAtA[i:], m.KeytabFile)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeytabFile)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseTLS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseTLS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseTLS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TrustSystemCertPool {
		i--
		if m.TrustSystemCertPool {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CACert) > 0 {
		i -= len(m.CACert)
		copy(dAtA[i:], m.CACert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CACert)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MySQLOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MySQLOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MySQLOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerVersion) > 0 {
		i -= len(m.ServerVersion)
		copy(dAtA[i:], m.ServerVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MongoAtlas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MongoAtlas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MongoAtlas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstanceV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *InstanceSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalUpgraderVersion) > 0 {
		i -= len(m.ExternalUpgraderVersion)
		copy(dAtA[i:], m.ExternalUpgraderVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalUpgraderVersion)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExternalUpgrader) > 0 {
		i -= len(m.ExternalUpgrader)
		copy(dAtA[i:], m.ExternalUpgrader)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalUpgrader)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ControlLog) > 0 {
		for iNdEx := len(m.ControlLog) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ControlLog[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	n42, err42 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastSeen, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSeen):])
	if err42 != nil {
		return 0, err42
	}
	i -= n42
	i = encodeVarintTypes(dAtA, i, uint64(n42))
	i--
	dAtA[i] = 0x2a
	if len(m.AuthID) > 0 {
		i -= len(m.AuthID)
		copy(dAtA[i:], m.AuthID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Services[iNdEx])
			copy(dAtA[i:], m.Services[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Services[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstanceControlLogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceControlLogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceControlLogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.TTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x20
	}
	n43, err43 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Time):])
	if err43 != nil {
		return 0, err43
	}
	i -= n43
	i = encodeVarintTypes(dAtA, i, uint64(n43))
	i--
	dAtA[i] = 0x1a
	if m.ID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstanceFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewerThanVersion) > 0 {
		i -= len(m.NewerThanVersion)
		copy(dAtA[i:], m.NewerThanVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NewerThanVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OlderThanVersion) > 0 {
		i -= len(m.OlderThanVersion)
		copy(dAtA[i:], m.OlderThanVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OlderThanVersion)))
		i--
		dAtA[i] = 0x32
	}
	if m.NoExtUpgrader {
		i--
		if m.NoExtUpgrader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExternalUpgrader) > 0 {
		i -= len(m.ExternalUpgrader)
		copy(dAtA[i:], m.ExternalUpgrader)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalUpgrader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Services[iNdEx])
			copy(dAtA[i:], m.Services[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Services[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CloudMetadata != nil {
		{
			size, err := m.CloudMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.PublicAddrs) > 0 {
		for iNdEx := len(m.PublicAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PublicAddrs[iNdEx])
			copy(dAtA[i:], m.PublicAddrs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicAddrs[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.ProxyIDs) > 0 {
		for iNdEx := len(m.ProxyIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProxyIDs[iNdEx])
			copy(dAtA[i:], m.ProxyIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyIDs[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.PeerAddr) > 0 {
		i -= len(m.PeerAddr)
		copy(dAtA[i:], m.PeerAddr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PeerAddr)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x3a
	}
	if m.UseTunnel {
		i--
		if m.UseTunnel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.CmdLabels) > 0 {
		for k := range m.CmdLabels {
			v := m.CmdLabels[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubnetID) > 0 {
		i -= len(m.SubnetID)
		copy(dAtA[i:], m.SubnetID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubnetID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Integration) > 0 {
		i -= len(m.Integration)
		copy(dAtA[i:], m.Integration)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Integration)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VPCID) > 0 {
		i -= len(m.VPCID)
		copy(dAtA[i:], m.VPCID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VPCID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InstanceID) > 0 {
		i -= len(m.InstanceID)
		copy(dAtA[i:], m.InstanceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InstanceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountID) > 0 {
		i -= len(m.AccountID)
		copy(dAtA[i:], m.AccountID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AWS != nil {
		{
			size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppServerV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppServerV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppServerV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppServerSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppServerSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppServerSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyIDs) > 0 {
		for iNdEx := len(m.ProxyIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProxyIDs[iNdEx])
			copy(dAtA[i:], m.ProxyIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyIDs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppV3List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppV3List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppV3List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Apps) > 0 {
		for iNdEx := len(m.Apps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Apps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Integration) > 0 {
		i -= len(m.Integration)
		copy(dAtA[i:], m.Integration)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Integration)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.UserGroups) > 0 {
		for iNdEx := len(m.UserGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserGroups[iNdEx])
			copy(dAtA[i:], m.UserGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.UserGroups[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Cloud) > 0 {
		i -= len(m.Cloud)
		copy(dAtA[i:], m.Cloud)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Cloud)))
		i--
		dAtA[i] = 0x3a
	}
	if m.AWS != nil {
		{
			size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Rewrite != nil {
		{
			size, err := m.Rewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.InsecureSkipVerify {
		i--
		if m.InsecureSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DynamicLabels) > 0 {
		for k := range m.DynamicLabels {
			v := m.DynamicLabels[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PublicAddr) > 0 {
		i -= len(m.PublicAddr)
		copy(dAtA[i:], m.PublicAddr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppServerOrSAMLIdPServiceProviderV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppServerOrSAMLIdPServiceProviderV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppServerOrSAMLIdPServiceProviderV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Resource != nil {
		{
			size := m.Resource.Size()
			i -= size
			if _, err := m.Resource.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppServerOrSAMLIdPServiceProviderV1_AppServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppServerOrSAMLIdPServiceProviderV1_AppServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppServer != nil {
		{
			size, err := m.AppServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SAMLIdPServiceProvider != nil {
		{
			size, err := m.SAMLIdPServiceProvider.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Rewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JWTClaims) > 0 {
		i -= len(m.JWTClaims)
		copy(dAtA[i:], m.JWTClaims)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JWTClaims)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Redirect) > 0 {
		for iNdEx := len(m.Redirect) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Redirect[iNdEx])
			copy(dAtA[i:], m.Redirect[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Redirect[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandLabelV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLabelV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLabelV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Period != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Period))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppAWS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppAWS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppAWS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SSHKeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSHKeyPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSHKeyPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrivateKeyType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PrivateKeyType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PrivateKey) > 0 {
		i -= len(m.PrivateKey)
		copy(dAtA[i:], m.PrivateKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLSKeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSKeyPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLSKeyPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeyType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JWTKeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JWTKeyPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JWTKeyPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrivateKeyType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PrivateKeyType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PrivateKey) > 0 {
		i -= len(m.PrivateKey)
		copy(dAtA[i:], m.PrivateKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertAuthorityV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertAuthorityV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertAuthorityV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertAuthoritySpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertAuthoritySpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertAuthoritySpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.AdditionalTrustedKeys.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.ActiveKeys.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.SigningAlg != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SigningAlg))
		i--
		dAtA[i] = 0x48
	}
	if m.Rotation != nil {
		{
			size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.RoleMap) > 0 {
		for iNdEx := len(m.RoleMap) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoleMap[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CAKeySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CAKeySet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CAKeySet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JWT) > 0 {
		for iNdEx := len(m.JWT) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JWT[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TLS) > 0 {
		for iNdEx := len(m.TLS) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TLS[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SSH) > 0 {
		for iNdEx := len(m.SSH) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SSH[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RoleMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Local) > 0 {
		for iNdEx := len(m.Local) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Local[iNdEx])
			copy(dAtA[i:], m.Local[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Local[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Remote) > 0 {
		i -= len(m.Remote)
		copy(dAtA[i:], m.Remote)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Remote)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1a
	}
	n66, err66 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err66 != nil {
		return 0, err66
	}
	i -= n66
	i = encodeVarintTypes(dAtA, i, uint64(n66))
	i--
	dAtA[i] = 0x12
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenV2List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenV2List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenV2List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProvisionTokens) > 0 {
		for iNdEx := len(m.ProvisionTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProvisionTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TokenRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AWSARN) > 0 {
		i -= len(m.AWSARN)
		copy(dAtA[i:], m.AWSARN)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AWSARN)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AWSRole) > 0 {
		i -= len(m.AWSRole)
		copy(dAtA[i:], m.AWSRole)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AWSRole)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AWSRegions) > 0 {
		for iNdEx := len(m.AWSRegions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AWSRegions[iNdEx])
			copy(dAtA[i:], m.AWSRegions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AWSRegions[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AWSAccount) > 0 {
		i -= len(m.AWSAccount)
		copy(dAtA[i:], m.AWSAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AWSAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TerraformCloud != nil {
		{
			size, err := m.TerraformCloud.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.TPM != nil {
		{
			size, err := m.TPM.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Spacelift != nil {
		{
			size, err := m.Spacelift.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.GCP != nil {
		{
			size, err := m.GCP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.GitLab != nil {
		{
			size, err := m.GitLab.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Azure != nil {
		{
			size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Kubernetes != nil {
		{
			size, err := m.Kubernetes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	{
		size := m.SuggestedAgentMatcherLabels.Size()
		i -= size
		if _, err := m.SuggestedAgentMatcherLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.CircleCI != nil {
		{
			size, err := m.CircleCI.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.GitHub != nil {
		{
			size, err := m.GitHub.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.SuggestedLabels.Size()
		i -= size
		if _, err := m.SuggestedLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.BotName) > 0 {
		i -= len(m.BotName)
		copy(dAtA[i:], m.BotName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BotName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.JoinMethod) > 0 {
		i -= len(m.JoinMethod)
		copy(dAtA[i:], m.JoinMethod)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JoinMethod)))
		i--
		dAtA[i] = 0x22
	}
	if m.AWSIIDTTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AWSIIDTTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2TPM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2TPM) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2TPM) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EKCertAllowedCAs) > 0 {
		for iNdEx := len(m.EKCertAllowedCAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EKCertAllowedCAs[iNdEx])
			copy(dAtA[i:], m.EKCertAllowedCAs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EKCertAllowedCAs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2TPM_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2TPM_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2TPM_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EKCertificateSerial) > 0 {
		i -= len(m.EKCertificateSerial)
		copy(dAtA[i:], m.EKCertificateSerial)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EKCertificateSerial)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EKPublicHash) > 0 {
		i -= len(m.EKPublicHash)
		copy(dAtA[i:], m.EKPublicHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EKPublicHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2GitHub) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2GitHub) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2GitHub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EnterpriseSlug) > 0 {
		i -= len(m.EnterpriseSlug)
		copy(dAtA[i:], m.EnterpriseSlug)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EnterpriseSlug)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EnterpriseServerHost) > 0 {
		i -= len(m.EnterpriseServerHost)
		copy(dAtA[i:], m.EnterpriseServerHost)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EnterpriseServerHost)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2GitHub_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2GitHub_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2GitHub_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RefType) > 0 {
		i -= len(m.RefType)
		copy(dAtA[i:], m.RefType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RefType)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Ref) > 0 {
		i -= len(m.Ref)
		copy(dAtA[i:], m.Ref)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ref)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Environment) > 0 {
		i -= len(m.Environment)
		copy(dAtA[i:], m.Environment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Environment)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Workflow) > 0 {
		i -= len(m.Workflow)
		copy(dAtA[i:], m.Workflow)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Workflow)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RepositoryOwner) > 0 {
		i -= len(m.RepositoryOwner)
		copy(dAtA[i:], m.RepositoryOwner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RepositoryOwner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Repository) > 0 {
		i -= len(m.Repository)
		copy(dAtA[i:], m.Repository)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Repository)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sub) > 0 {
		i -= len(m.Sub)
		copy(dAtA[i:], m.Sub)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sub)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2GitLab) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2GitLab) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2GitLab) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2GitLab_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2GitLab_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2GitLab_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProjectVisibility) > 0 {
		i -= len(m.ProjectVisibility)
		copy(dAtA[i:], m.ProjectVisibility)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectVisibility)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DeploymentTier) > 0 {
		i -= len(m.DeploymentTier)
		copy(dAtA[i:], m.DeploymentTier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeploymentTier)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CIConfigRefURI) > 0 {
		i -= len(m.CIConfigRefURI)
		copy(dAtA[i:], m.CIConfigRefURI)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CIConfigRefURI)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.CIConfigSHA) > 0 {
		i -= len(m.CIConfigSHA)
		copy(dAtA[i:], m.CIConfigSHA)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CIConfigSHA)))
		i--
		dAtA[i] = 0x6a
	}
	if m.EnvironmentProtected != nil {
		{
			size := m.EnvironmentProtected.Size()
			i -= size
			if _, err := m.EnvironmentProtected.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.RefProtected != nil {
		{
			size := m.RefProtected.Size()
			i -= size
			if _, err := m.RefProtected.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.UserEmail) > 0 {
		i -= len(m.UserEmail)
		copy(dAtA[i:], m.UserEmail)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserEmail)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UserID) > 0 {
		i -= len(m.UserID)
		copy(dAtA[i:], m.UserID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.UserLogin) > 0 {
		i -= len(m.UserLogin)
		copy(dAtA[i:], m.UserLogin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserLogin)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Environment) > 0 {
		i -= len(m.Environment)
		copy(dAtA[i:], m.Environment)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Environment)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PipelineSource) > 0 {
		i -= len(m.PipelineSource)
		copy(dAtA[i:], m.PipelineSource)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PipelineSource)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProjectPath) > 0 {
		i -= len(m.ProjectPath)
		copy(dAtA[i:], m.ProjectPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectPath)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NamespacePath) > 0 {
		i -= len(m.NamespacePath)
		copy(dAtA[i:], m.NamespacePath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NamespacePath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RefType) > 0 {
		i -= len(m.RefType)
		copy(dAtA[i:], m.RefType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RefType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ref) > 0 {
		i -= len(m.Ref)
		copy(dAtA[i:], m.Ref)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ref)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sub) > 0 {
		i -= len(m.Sub)
		copy(dAtA[i:], m.Sub)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Sub)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2CircleCI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2CircleCI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2CircleCI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OrganizationID) > 0 {
		i -= len(m.OrganizationID)
		copy(dAtA[i:], m.OrganizationID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OrganizationID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2CircleCI_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2CircleCI_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2CircleCI_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ContextID) > 0 {
		i -= len(m.ContextID)
		copy(dAtA[i:], m.ContextID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContextID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProjectID) > 0 {
		i -= len(m.ProjectID)
		copy(dAtA[i:], m.ProjectID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2Spacelift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2Spacelift) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2Spacelift) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2Spacelift_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2Spacelift_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2Spacelift_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Scope) > 0 {
		i -= len(m.Scope)
		copy(dAtA[i:], m.Scope)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Scope)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CallerType) > 0 {
		i -= len(m.CallerType)
		copy(dAtA[i:], m.CallerType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CallerType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CallerID) > 0 {
		i -= len(m.CallerID)
		copy(dAtA[i:], m.CallerID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CallerID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SpaceID) > 0 {
		i -= len(m.SpaceID)
		copy(dAtA[i:], m.SpaceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SpaceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2Kubernetes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2Kubernetes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2Kubernetes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StaticJWKS != nil {
		{
			size, err := m.StaticJWKS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JWKS) > 0 {
		i -= len(m.JWKS)
		copy(dAtA[i:], m.JWKS)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JWKS)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2Kubernetes_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2Kubernetes_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2Kubernetes_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceAccount) > 0 {
		i -= len(m.ServiceAccount)
		copy(dAtA[i:], m.ServiceAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceAccount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2Azure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2Azure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2Azure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2Azure_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2Azure_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2Azure_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResourceGroups) > 0 {
		for iNdEx := len(m.ResourceGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourceGroups[iNdEx])
			copy(dAtA[i:], m.ResourceGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceGroups[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Subscription) > 0 {
		i -= len(m.Subscription)
		copy(dAtA[i:], m.Subscription)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Subscription)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2GCP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2GCP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2GCP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2GCP_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2GCP_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2GCP_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceAccounts) > 0 {
		for iNdEx := len(m.ServiceAccounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ServiceAccounts[iNdEx])
			copy(dAtA[i:], m.ServiceAccounts[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceAccounts[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Locations) > 0 {
		for iNdEx := len(m.Locations) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Locations[iNdEx])
			copy(dAtA[i:], m.Locations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Locations[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ProjectIDs) > 0 {
		for iNdEx := len(m.ProjectIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProjectIDs[iNdEx])
			copy(dAtA[i:], m.ProjectIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2TerraformCloud) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2TerraformCloud) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2TerraformCloud) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Audience) > 0 {
		i -= len(m.Audience)
		copy(dAtA[i:], m.Audience)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Audience)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionTokenSpecV2TerraformCloud_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionTokenSpecV2TerraformCloud_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionTokenSpecV2TerraformCloud_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RunPhase) > 0 {
		i -= len(m.RunPhase)
		copy(dAtA[i:], m.RunPhase)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RunPhase)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.WorkspaceName) > 0 {
		i -= len(m.WorkspaceName)
		copy(dAtA[i:], m.WorkspaceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WorkspaceName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.WorkspaceID) > 0 {
		i -= len(m.WorkspaceID)
		copy(dAtA[i:], m.WorkspaceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WorkspaceID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProjectName) > 0 {
		i -= len(m.ProjectName)
		copy(dAtA[i:], m.ProjectName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProjectID) > 0 {
		i -= len(m.ProjectID)
		copy(dAtA[i:], m.ProjectID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrganizationName) > 0 {
		i -= len(m.OrganizationName)
		copy(dAtA[i:], m.OrganizationName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OrganizationName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrganizationID) > 0 {
		i -= len(m.OrganizationID)
		copy(dAtA[i:], m.OrganizationID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OrganizationID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StaticTokensV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticTokensV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticTokensV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StaticTokensSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticTokensSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticTokensSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StaticTokens) > 0 {
		for iNdEx := len(m.StaticTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaticTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClusterNameV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterNameV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterNameV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterNameSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterNameSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterNameSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterAuditConfigV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAuditConfigV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterAuditConfigV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterAuditConfigSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAuditConfigSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterAuditConfigSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UseFIPSEndpoint != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UseFIPSEndpoint))
		i--
		dAtA[i] = 0x78
	}
	if m.RetentionPeriod != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RetentionPeriod))
		i--
		dAtA[i] = 0x70
	}
	if m.WriteTargetValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WriteTargetValue))))
		i--
		dAtA[i] = 0x69
	}
	if m.WriteMinCapacity != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WriteMinCapacity))
		i--
		dAtA[i] = 0x60
	}
	if m.WriteMaxCapacity != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WriteMaxCapacity))
		i--
		dAtA[i] = 0x58
	}
	if m.ReadTargetValue != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReadTargetValue))))
		i--
		dAtA[i] = 0x51
	}
	if m.ReadMinCapacity != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ReadMinCapacity))
		i--
		dAtA[i] = 0x48
	}
	if m.ReadMaxCapacity != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ReadMaxCapacity))
		i--
		dAtA[i] = 0x40
	}
	if m.EnableAutoScaling {
		i--
		if m.EnableAutoScaling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.EnableContinuousBackups {
		i--
		if m.EnableContinuousBackups {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.AuditEventsURI.Size()
		i -= size
		if _, err := m.AuditEventsURI.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.AuditSessionsURI) > 0 {
		i -= len(m.AuditSessionsURI)
		copy(dAtA[i:], m.AuditSessionsURI)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuditSessionsURI)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterNetworkingConfigV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterNetworkingConfigV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterNetworkingConfigV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterNetworkingConfigSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterNetworkingConfigSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterNetworkingConfigSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SSHDialTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SSHDialTimeout))
		i--
		dAtA[i] = 0x68
	}
	if m.CaseInsensitiveRouting {
		i--
		if m.CaseInsensitiveRouting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.AssistCommandExecutionWorkers != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AssistCommandExecutionWorkers))
		i--
		dAtA[i] = 0x58
	}
	if m.ProxyPingInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProxyPingInterval))
		i--
		dAtA[i] = 0x50
	}
	if m.TunnelStrategy != nil {
		{
			size, err := m.TunnelStrategy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.RoutingStrategy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RoutingStrategy))
		i--
		dAtA[i] = 0x40
	}
	if m.ProxyListenerMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProxyListenerMode))
		i--
		dAtA[i] = 0x38
	}
	if m.WebIdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WebIdleTimeout))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ClientIdleTimeoutMessage) > 0 {
		i -= len(m.ClientIdleTimeoutMessage)
		copy(dAtA[i:], m.ClientIdleTimeoutMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientIdleTimeoutMessage)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SessionControlTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SessionControlTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.KeepAliveCountMax != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.KeepAliveCountMax))
		i--
		dAtA[i] = 0x18
	}
	if m.KeepAliveInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.KeepAliveInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.ClientIdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientIdleTimeout))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunnelStrategyV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelStrategyV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelStrategyV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Strategy != nil {
		{
			size := m.Strategy.Size()
			i -= size
			if _, err := m.Strategy.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TunnelStrategyV1_AgentMesh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelStrategyV1_AgentMesh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AgentMesh != nil {
		{
			size, err := m.AgentMesh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TunnelStrategyV1_ProxyPeering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelStrategyV1_ProxyPeering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProxyPeering != nil {
		{
			size, err := m.ProxyPeering.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AgentMeshTunnelStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentMeshTunnelStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AgentMeshTunnelStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ProxyPeeringTunnelStrategy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProxyPeeringTunnelStrategy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProxyPeeringTunnelStrategy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AgentConnectionCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AgentConnectionCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionRecordingConfigV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionRecordingConfigV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionRecordingConfigV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionRecordingConfigSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionRecordingConfigSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionRecordingConfigSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProxyChecksHostKeys != nil {
		{
			size := m.ProxyChecksHostKeys.Size()
			i -= size
			if _, err := m.ProxyChecksHostKeys.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthPreferenceV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthPreferenceV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthPreferenceV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthPreferenceSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthPreferenceSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthPreferenceSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SignatureAlgorithmSuite != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SignatureAlgorithmSuite))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.HardwareKey != nil {
		{
			size, err := m.HardwareKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.PIVSlot) > 0 {
		i -= len(m.PIVSlot)
		copy(dAtA[i:], m.PIVSlot)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PIVSlot)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Okta != nil {
		{
			size, err := m.Okta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DefaultSessionTTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultSessionTTL))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.AllowHeadless != nil {
		{
			size := m.AllowHeadless.Size()
			i -= size
			if _, err := m.AllowHeadless.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.IDP != nil {
		{
			size, err := m.IDP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.DeviceTrust != nil {
		{
			size, err := m.DeviceTrust.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.RequireMFAType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequireMFAType))
		i--
		dAtA[i] = 0x60
	}
	if m.AllowPasswordless != nil {
		{
			size := m.AllowPasswordless.Size()
			i -= size
			if _, err := m.AllowPasswordless.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.LockingMode) > 0 {
		i -= len(m.LockingMode)
		copy(dAtA[i:], m.LockingMode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LockingMode)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MessageOfTheDay) > 0 {
		i -= len(m.MessageOfTheDay)
		copy(dAtA[i:], m.MessageOfTheDay)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MessageOfTheDay)))
		i--
		dAtA[i] = 0x42
	}
	if m.AllowLocalAuth != nil {
		{
			size := m.AllowLocalAuth.Size()
			i -= size
			if _, err := m.AllowLocalAuth.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DisconnectExpiredCert != nil {
		{
			size := m.DisconnectExpiredCert.Size()
			i -= size
			if _, err := m.DisconnectExpiredCert.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.U2F != nil {
		{
			size, err := m.U2F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ConnectorName) > 0 {
		i -= len(m.ConnectorName)
		copy(dAtA[i:], m.ConnectorName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectorName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SecondFactor) > 0 {
		i -= len(m.SecondFactor)
		copy(dAtA[i:], m.SecondFactor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecondFactor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *U2F) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *U2F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *U2F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceAttestationCAs) > 0 {
		for iNdEx := len(m.DeviceAttestationCAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeviceAttestationCAs[iNdEx])
			copy(dAtA[i:], m.DeviceAttestationCAs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceAttestationCAs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Facets) > 0 {
		for iNdEx := len(m.Facets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Facets[iNdEx])
			copy(dAtA[i:], m.Facets[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Facets[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AppID) > 0 {
		i -= len(m.AppID)
		copy(dAtA[i:], m.AppID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Webauthn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Webauthn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Webauthn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AttestationDeniedCAs) > 0 {
		for iNdEx := len(m.AttestationDeniedCAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AttestationDeniedCAs[iNdEx])
			copy(dAtA[i:], m.AttestationDeniedCAs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationDeniedCAs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AttestationAllowedCAs) > 0 {
		for iNdEx := len(m.AttestationAllowedCAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AttestationAllowedCAs[iNdEx])
			copy(dAtA[i:], m.AttestationAllowedCAs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationAllowedCAs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RPID) > 0 {
		i -= len(m.RPID)
		copy(dAtA[i:], m.RPID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RPID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceTrust) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceTrust) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceTrust) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EKCertAllowedCAs) > 0 {
		for iNdEx := len(m.EKCertAllowedCAs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EKCertAllowedCAs[iNdEx])
			copy(dAtA[i:], m.EKCertAllowedCAs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EKCertAllowedCAs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.AutoEnroll {
		i--
		if m.AutoEnroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HardwareKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardwareKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardwareKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SerialNumberValidation != nil {
		{
			size, err := m.SerialNumberValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PIVSlot) > 0 {
		i -= len(m.PIVSlot)
		copy(dAtA[i:], m.PIVSlot)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PIVSlot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HardwareKeySerialNumberValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardwareKeySerialNumberValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardwareKeySerialNumberValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SerialNumberTraitName) > 0 {
		i -= len(m.SerialNumberTraitName)
		copy(dAtA[i:], m.SerialNumberTraitName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SerialNumberTraitName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Namespace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Namespace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Namespace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UserTokenV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTokenV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTokenV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserTokenSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTokenSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTokenSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n115, err115 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err115 != nil {
		return 0, err115
	}
	i -= n115
	i = encodeVarintTypes(dAtA, i, uint64(n115))
	i--
	dAtA[i] = 0x22
	if m.Usage != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Usage))
		i--
		dAtA[i] = 0x18
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserTokenSecretsV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTokenSecretsV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTokenSecretsV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserTokenSecretsSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTokenSecretsSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserTokenSecretsSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n118, err118 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err118 != nil {
		return 0, err118
	}
	i -= n118
	i = encodeVarintTypes(dAtA, i, uint64(n118))
	i--
	dAtA[i] = 0x1a
	if len(m.QRCode) > 0 {
		i -= len(m.QRCode)
		copy(dAtA[i:], m.QRCode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.QRCode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OTPKey) > 0 {
		i -= len(m.OTPKey)
		copy(dAtA[i:], m.OTPKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OTPKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessReviewThreshold) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessReviewThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessReviewThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Deny != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Deny))
		i--
		dAtA[i] = 0x20
	}
	if m.Approve != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Approve))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PromotedAccessList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PromotedAccessList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PromotedAccessList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessReview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessReview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessReview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AssumeStartTime != nil {
		n121, err121 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.AssumeStartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.AssumeStartTime):])
		if err121 != nil {
			return 0, err121
		}
		i -= n121
		i = encodeVarintTypes(dAtA, i, uint64(n121))
		i--
		dAtA[i] = 0x52
	}
	if m.AccessList != nil {
		{
			size, err := m.AccessList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ThresholdIndexes) > 0 {
		dAtA124 := make([]byte, len(m.ThresholdIndexes)*10)
		var j123 int
		for _, num := range m.ThresholdIndexes {
			for num >= 1<<7 {
				dAtA124[j123] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j123++
			}
			dAtA124[j123] = uint8(num)
			j123++
		}
		i -= j123
		copy(dAtA[i:], dAtA124[:j123])
		i = encodeVarintTypes(dAtA, i, uint64(j123))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.Annotations.Size()
		i -= size
		if _, err := m.Annotations.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	n126, err126 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err126 != nil {
		return 0, err126
	}
	i -= n126
	i = encodeVarintTypes(dAtA, i, uint64(n126))
	i--
	dAtA[i] = 0x2a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProposedState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ProposedState))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessReviewSubmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessReviewSubmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessReviewSubmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Review.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.RequestID) > 0 {
		i -= len(m.RequestID)
		copy(dAtA[i:], m.RequestID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdIndexSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdIndexSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdIndexSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Indexes) > 0 {
		dAtA129 := make([]byte, len(m.Indexes)*10)
		var j128 int
		for _, num := range m.Indexes {
			for num >= 1<<7 {
				dAtA129[j128] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j128++
			}
			dAtA129[j128] = uint8(num)
			j128++
		}
		i -= j128
		copy(dAtA[i:], dAtA129[:j128])
		i = encodeVarintTypes(dAtA, i, uint64(j128))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdIndexSets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdIndexSets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdIndexSets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sets) > 0 {
		for iNdEx := len(m.Sets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AssumeStartTime != nil {
		n130, err130 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.AssumeStartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.AssumeStartTime):])
		if err130 != nil {
			return 0, err130
		}
		i -= n130
		i = encodeVarintTypes(dAtA, i, uint64(n130))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.AccessList != nil {
		{
			size, err := m.AccessList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	n132, err132 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.SessionTTL, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.SessionTTL):])
	if err132 != nil {
		return 0, err132
	}
	i -= n132
	i = encodeVarintTypes(dAtA, i, uint64(n132))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	n133, err133 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.MaxDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.MaxDuration):])
	if err133 != nil {
		return 0, err133
	}
	i -= n133
	i = encodeVarintTypes(dAtA, i, uint64(n133))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.DryRun {
		i--
		if m.DryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.LoginHint) > 0 {
		i -= len(m.LoginHint)
		copy(dAtA[i:], m.LoginHint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LoginHint)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.RequestedResourceIDs) > 0 {
		for iNdEx := len(m.RequestedResourceIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestedResourceIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.SuggestedReviewers) > 0 {
		for iNdEx := len(m.SuggestedReviewers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SuggestedReviewers[iNdEx])
			copy(dAtA[i:], m.SuggestedReviewers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SuggestedReviewers[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Reviews) > 0 {
		for iNdEx := len(m.Reviews) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reviews[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.RoleThresholdMapping) > 0 {
		for k := range m.RoleThresholdMapping {
			v := m.RoleThresholdMapping[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Thresholds) > 0 {
		for iNdEx := len(m.Thresholds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Thresholds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	{
		size := m.SystemAnnotations.Size()
		i -= size
		if _, err := m.SystemAnnotations.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.ResolveAnnotations.Size()
		i -= size
		if _, err := m.ResolveAnnotations.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.ResolveReason) > 0 {
		i -= len(m.ResolveReason)
		copy(dAtA[i:], m.ResolveReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResolveReason)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RequestReason) > 0 {
		i -= len(m.RequestReason)
		copy(dAtA[i:], m.RequestReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestReason)))
		i--
		dAtA[i] = 0x32
	}
	n137, err137 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err137 != nil {
		return 0, err137
	}
	i -= n137
	i = encodeVarintTypes(dAtA, i, uint64(n137))
	i--
	dAtA[i] = 0x2a
	n138, err138 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err138 != nil {
		return 0, err138
	}
	i -= n138
	i = encodeVarintTypes(dAtA, i, uint64(n138))
	i--
	dAtA[i] = 0x22
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x32
	}
	if m.Scope != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SearchKeywords) > 0 {
		for iNdEx := len(m.SearchKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchKeywords[iNdEx])
			copy(dAtA[i:], m.SearchKeywords[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SearchKeywords[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AutoRequest {
		i--
		if m.AutoRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.RequireReason {
		i--
		if m.RequireReason {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RequestPrompt) > 0 {
		i -= len(m.RequestPrompt)
		copy(dAtA[i:], m.RequestPrompt)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestPrompt)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ApplicableRolesForResources) > 0 {
		for iNdEx := len(m.ApplicableRolesForResources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ApplicableRolesForResources[iNdEx])
			copy(dAtA[i:], m.ApplicableRolesForResources[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ApplicableRolesForResources[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SuggestedReviewers) > 0 {
		for iNdEx := len(m.SuggestedReviewers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SuggestedReviewers[iNdEx])
			copy(dAtA[i:], m.SuggestedReviewers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SuggestedReviewers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RequestableRoles) > 0 {
		for iNdEx := len(m.RequestableRoles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequestableRoles[iNdEx])
			copy(dAtA[i:], m.RequestableRoles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestableRoles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessCapabilitiesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessCapabilitiesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessCapabilitiesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FilterRequestableRolesByResource {
		i--
		if m.FilterRequestableRolesByResource {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Login) > 0 {
		i -= len(m.Login)
		copy(dAtA[i:], m.Login)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Login)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResourceIDs) > 0 {
		for iNdEx := len(m.ResourceIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SuggestedReviewers {
		i--
		if m.SuggestedReviewers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RequestableRoles {
		i--
		if m.RequestableRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubResourceName) > 0 {
		i -= len(m.SubResourceName)
		copy(dAtA[i:], m.SubResourceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubResourceName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginDataV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginDataV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginDataV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginDataEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginDataEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginDataEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for k := range m.Data {
			v := m.Data[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginDataSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginDataSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginDataSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Entries) > 0 {
		for k := range m.Entries {
			v := m.Entries[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginDataFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginDataFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginDataFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plugin) > 0 {
		i -= len(m.Plugin)
		copy(dAtA[i:], m.Plugin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Plugin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Resource) > 0 {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginDataUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginDataUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginDataUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Expect) > 0 {
		for k := range m.Expect {
			v := m.Expect[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Set) > 0 {
		for k := range m.Set {
			v := m.Set[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Plugin) > 0 {
		i -= len(m.Plugin)
		copy(dAtA[i:], m.Plugin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Plugin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Resource) > 0 {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SkipSystemRoles {
		i--
		if m.SkipSystemRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.SearchKeywords) > 0 {
		for iNdEx := len(m.SearchKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchKeywords[iNdEx])
			copy(dAtA[i:], m.SearchKeywords[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SearchKeywords[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RoleV6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleV6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleV6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleSpecV6) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleSpecV6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleSpecV6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Deny.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Allow.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RoleOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n147, err147 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MFAVerificationInterval, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.MFAVerificationInterval):])
	if err147 != nil {
		return 0, err147
	}
	i -= n147
	i = encodeVarintTypes(dAtA, i, uint64(n147))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xf2
	if m.CreateDatabaseUserMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreateDatabaseUserMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.CreateHostUserMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreateHostUserMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.CreateDatabaseUser != nil {
		{
			size := m.CreateDatabaseUser.Size()
			i -= size
			if _, err := m.CreateDatabaseUser.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.CreateDesktopUser != nil {
		{
			size := m.CreateDesktopUser.Size()
			i -= size
			if _, err := m.CreateDesktopUser.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.IDP != nil {
		{
			size, err := m.IDP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.DeviceTrustMode) > 0 {
		i -= len(m.DeviceTrustMode)
		copy(dAtA[i:], m.DeviceTrustMode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceTrustMode)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.RequireMFAType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequireMFAType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.SSHFileCopy != nil {
		{
			size := m.SSHFileCopy.Size()
			i -= size
			if _, err := m.SSHFileCopy.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.PinSourceIP {
		i--
		if m.PinSourceIP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CreateHostUser != nil {
		{
			size := m.CreateHostUser.Size()
			i -= size
			if _, err := m.CreateHostUser.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.DesktopDirectorySharing != nil {
		{
			size := m.DesktopDirectorySharing.Size()
			i -= size
			if _, err := m.DesktopDirectorySharing.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.MaxKubernetesConnections != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxKubernetesConnections))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.CertExtensions) > 0 {
		for iNdEx := len(m.CertExtensions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CertExtensions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if m.DesktopClipboard != nil {
		{
			size := m.DesktopClipboard.Size()
			i -= size
			if _, err := m.DesktopClipboard.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.RecordSession != nil {
		{
			size, err := m.RecordSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Lock) > 0 {
		i -= len(m.Lock)
		copy(dAtA[i:], m.Lock)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Lock)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.RequestPrompt) > 0 {
		i -= len(m.RequestPrompt)
		copy(dAtA[i:], m.RequestPrompt)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestPrompt)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.RequestAccess) > 0 {
		i -= len(m.RequestAccess)
		copy(dAtA[i:], m.RequestAccess)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestAccess)))
		i--
		dAtA[i] = 0x5a
	}
	if m.MaxSessions != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxSessions))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxConnections != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxConnections))
		i--
		dAtA[i] = 0x48
	}
	if m.PermitX11Forwarding {
		i--
		if m.PermitX11Forwarding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.BPF) > 0 {
		for iNdEx := len(m.BPF) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.BPF[iNdEx])
			copy(dAtA[i:], m.BPF[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.BPF[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.DisconnectExpiredCert {
		i--
		if m.DisconnectExpiredCert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ClientIdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ClientIdleTimeout))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CertificateFormat) > 0 {
		i -= len(m.CertificateFormat)
		copy(dAtA[i:], m.CertificateFormat)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertificateFormat)))
		i--
		dAtA[i] = 0x22
	}
	if m.PortForwarding != nil {
		{
			size := m.PortForwarding.Size()
			i -= size
			if _, err := m.PortForwarding.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxSessionTTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxSessionTTL))
		i--
		dAtA[i] = 0x10
	}
	if m.ForwardAgent {
		i--
		if m.ForwardAgent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecordSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SSH) > 0 {
		i -= len(m.SSH)
		copy(dAtA[i:], m.SSH)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SSH)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Default) > 0 {
		i -= len(m.Default)
		copy(dAtA[i:], m.Default)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Default)))
		i--
		dAtA[i] = 0x12
	}
	if m.Desktop != nil {
		{
			size := m.Desktop.Size()
			i -= size
			if _, err := m.Desktop.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertExtension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertExtension) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertExtension) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleConditions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleConditions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SPIFFE) > 0 {
		for iNdEx := len(m.SPIFFE) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SPIFFE[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.DatabasePermissions) > 0 {
		for iNdEx := len(m.DatabasePermissions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DatabasePermissions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.GroupLabelsExpression) > 0 {
		i -= len(m.GroupLabelsExpression)
		copy(dAtA[i:], m.GroupLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupLabelsExpression)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if len(m.WindowsDesktopLabelsExpression) > 0 {
		i -= len(m.WindowsDesktopLabelsExpression)
		copy(dAtA[i:], m.WindowsDesktopLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WindowsDesktopLabelsExpression)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.DatabaseServiceLabelsExpression) > 0 {
		i -= len(m.DatabaseServiceLabelsExpression)
		copy(dAtA[i:], m.DatabaseServiceLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DatabaseServiceLabelsExpression)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if len(m.DatabaseLabelsExpression) > 0 {
		i -= len(m.DatabaseLabelsExpression)
		copy(dAtA[i:], m.DatabaseLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DatabaseLabelsExpression)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.KubernetesLabelsExpression) > 0 {
		i -= len(m.KubernetesLabelsExpression)
		copy(dAtA[i:], m.KubernetesLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KubernetesLabelsExpression)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.ClusterLabelsExpression) > 0 {
		i -= len(m.ClusterLabelsExpression)
		copy(dAtA[i:], m.ClusterLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterLabelsExpression)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.AppLabelsExpression) > 0 {
		i -= len(m.AppLabelsExpression)
		copy(dAtA[i:], m.AppLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppLabelsExpression)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.NodeLabelsExpression) > 0 {
		i -= len(m.NodeLabelsExpression)
		copy(dAtA[i:], m.NodeLabelsExpression)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeLabelsExpression)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.DatabaseRoles) > 0 {
		for iNdEx := len(m.DatabaseRoles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DatabaseRoles[iNdEx])
			copy(dAtA[i:], m.DatabaseRoles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DatabaseRoles[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.DesktopGroups) > 0 {
		for iNdEx := len(m.DesktopGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DesktopGroups[iNdEx])
			copy(dAtA[i:], m.DesktopGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DesktopGroups[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size := m.GroupLabels.Size()
		i -= size
		if _, err := m.GroupLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xda
	{
		size := m.DatabaseServiceLabels.Size()
		i -= size
		if _, err := m.DatabaseServiceLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xd2
	if len(m.GCPServiceAccounts) > 0 {
		for iNdEx := len(m.GCPServiceAccounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GCPServiceAccounts[iNdEx])
			copy(dAtA[i:], m.GCPServiceAccounts[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GCPServiceAccounts[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.KubernetesResources) > 0 {
		for iNdEx := len(m.KubernetesResources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KubernetesResources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.AzureIdentities) > 0 {
		for iNdEx := len(m.AzureIdentities) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AzureIdentities[iNdEx])
			copy(dAtA[i:], m.AzureIdentities[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AzureIdentities[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.HostSudoers) > 0 {
		for iNdEx := len(m.HostSudoers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HostSudoers[iNdEx])
			copy(dAtA[i:], m.HostSudoers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.HostSudoers[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.HostGroups) > 0 {
		for iNdEx := len(m.HostGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.HostGroups[iNdEx])
			copy(dAtA[i:], m.HostGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.HostGroups[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.JoinSessions) > 0 {
		for iNdEx := len(m.JoinSessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JoinSessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.RequireSessionJoin) > 0 {
		for iNdEx := len(m.RequireSessionJoin) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequireSessionJoin[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	{
		size := m.WindowsDesktopLabels.Size()
		i -= size
		if _, err := m.WindowsDesktopLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	if len(m.WindowsDesktopLogins) > 0 {
		for iNdEx := len(m.WindowsDesktopLogins) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.WindowsDesktopLogins[iNdEx])
			copy(dAtA[i:], m.WindowsDesktopLogins[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.WindowsDesktopLogins[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.AWSRoleARNs) > 0 {
		for iNdEx := len(m.AWSRoleARNs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AWSRoleARNs[iNdEx])
			copy(dAtA[i:], m.AWSRoleARNs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AWSRoleARNs[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.ReviewRequests != nil {
		{
			size, err := m.ReviewRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Impersonate != nil {
		{
			size, err := m.Impersonate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.DatabaseUsers) > 0 {
		for iNdEx := len(m.DatabaseUsers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DatabaseUsers[iNdEx])
			copy(dAtA[i:], m.DatabaseUsers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DatabaseUsers[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.DatabaseNames) > 0 {
		for iNdEx := len(m.DatabaseNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DatabaseNames[iNdEx])
			copy(dAtA[i:], m.DatabaseNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DatabaseNames[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	{
		size := m.DatabaseLabels.Size()
		i -= size
		if _, err := m.DatabaseLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size := m.KubernetesLabels.Size()
		i -= size
		if _, err := m.KubernetesLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.ClusterLabels.Size()
		i -= size
		if _, err := m.ClusterLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size := m.AppLabels.Size()
		i -= size
		if _, err := m.AppLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.KubeUsers) > 0 {
		for iNdEx := len(m.KubeUsers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KubeUsers[iNdEx])
			copy(dAtA[i:], m.KubeUsers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KubeUsers[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.KubeGroups) > 0 {
		for iNdEx := len(m.KubeGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KubeGroups[iNdEx])
			copy(dAtA[i:], m.KubeGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KubeGroups[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.NodeLabels.Size()
		i -= size
		if _, err := m.NodeLabels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Namespaces) > 0 {
		for iNdEx := len(m.Namespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Namespaces[iNdEx])
			copy(dAtA[i:], m.Namespaces[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespaces[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Logins) > 0 {
		for iNdEx := len(m.Logins) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Logins[iNdEx])
			copy(dAtA[i:], m.Logins[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Logins[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SPIFFERoleCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SPIFFERoleCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SPIFFERoleCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IPSANs) > 0 {
		for iNdEx := len(m.IPSANs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IPSANs[iNdEx])
			copy(dAtA[i:], m.IPSANs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IPSANs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.DNSSANs) > 0 {
		for iNdEx := len(m.DNSSANs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DNSSANs[iNdEx])
			copy(dAtA[i:], m.DNSSANs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DNSSANs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabasePermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabasePermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabasePermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.Match.Size()
		i -= size
		if _, err := m.Match.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Permissions) > 0 {
		for iNdEx := len(m.Permissions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Permissions[iNdEx])
			copy(dAtA[i:], m.Permissions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Permissions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Verbs) > 0 {
		for iNdEx := len(m.Verbs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Verbs[iNdEx])
			copy(dAtA[i:], m.Verbs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Verbs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionRequirePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionRequirePolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionRequirePolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OnLeave) > 0 {
		i -= len(m.OnLeave)
		copy(dAtA[i:], m.OnLeave)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OnLeave)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Modes) > 0 {
		for iNdEx := len(m.Modes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Modes[iNdEx])
			copy(dAtA[i:], m.Modes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Modes[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Count != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Kinds) > 0 {
		for iNdEx := len(m.Kinds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Kinds[iNdEx])
			copy(dAtA[i:], m.Kinds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Kinds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionJoinPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionJoinPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionJoinPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Modes) > 0 {
		for iNdEx := len(m.Modes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Modes[iNdEx])
			copy(dAtA[i:], m.Modes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Modes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Kinds) > 0 {
		for iNdEx := len(m.Kinds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Kinds[iNdEx])
			copy(dAtA[i:], m.Kinds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Kinds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestConditions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestConditions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxDuration))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SearchAsRoles) > 0 {
		for iNdEx := len(m.SearchAsRoles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchAsRoles[iNdEx])
			copy(dAtA[i:], m.SearchAsRoles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SearchAsRoles[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.SuggestedReviewers) > 0 {
		for iNdEx := len(m.SuggestedReviewers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SuggestedReviewers[iNdEx])
			copy(dAtA[i:], m.SuggestedReviewers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SuggestedReviewers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Thresholds) > 0 {
		for iNdEx := len(m.Thresholds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Thresholds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.Annotations.Size()
		i -= size
		if _, err := m.Annotations.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ClaimsToRoles) > 0 {
		for iNdEx := len(m.ClaimsToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClaimsToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessReviewConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessReviewConditions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessReviewConditions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PreviewAsRoles) > 0 {
		for iNdEx := len(m.PreviewAsRoles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PreviewAsRoles[iNdEx])
			copy(dAtA[i:], m.PreviewAsRoles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.PreviewAsRoles[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Where) > 0 {
		i -= len(m.Where)
		copy(dAtA[i:], m.Where)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Where)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClaimsToRoles) > 0 {
		for iNdEx := len(m.ClaimsToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClaimsToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestAllowedPromotion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestAllowedPromotion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestAllowedPromotion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccessListName) > 0 {
		i -= len(m.AccessListName)
		copy(dAtA[i:], m.AccessListName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessListName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestAllowedPromotions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestAllowedPromotions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestAllowedPromotions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Promotions) > 0 {
		for iNdEx := len(m.Promotions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Promotions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClaimMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Claim) > 0 {
		i -= len(m.Claim)
		copy(dAtA[i:], m.Claim)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Claim)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TraitMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraitMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TraitMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Trait) > 0 {
		i -= len(m.Trait)
		copy(dAtA[i:], m.Trait)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Trait)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Actions[iNdEx])
			copy(dAtA[i:], m.Actions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Actions[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Where) > 0 {
		i -= len(m.Where)
		copy(dAtA[i:], m.Where)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Where)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Verbs) > 0 {
		for iNdEx := len(m.Verbs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Verbs[iNdEx])
			copy(dAtA[i:], m.Verbs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Verbs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Resources[iNdEx])
			copy(dAtA[i:], m.Resources[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Resources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ImpersonateConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImpersonateConditions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImpersonateConditions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Where) > 0 {
		i -= len(m.Where)
		copy(dAtA[i:], m.Where)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Where)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Users[iNdEx])
			copy(dAtA[i:], m.Users[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Users[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BoolValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoolValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value {
		i--
		if m.Value {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SearchKeywords) > 0 {
		for iNdEx := len(m.SearchKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchKeywords[iNdEx])
			copy(dAtA[i:], m.SearchKeywords[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SearchKeywords[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserStatusV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatusV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserStatusV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PasswordState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PasswordState))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TrustedDeviceIDs) > 0 {
		for iNdEx := len(m.TrustedDeviceIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TrustedDeviceIDs[iNdEx])
			copy(dAtA[i:], m.TrustedDeviceIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedDeviceIDs[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.LocalAuth != nil {
		{
			size, err := m.LocalAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.CreatedBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	n176, err176 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err176 != nil {
		return 0, err176
	}
	i -= n176
	i = encodeVarintTypes(dAtA, i, uint64(n176))
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Traits.Size()
		i -= size
		if _, err := m.Traits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.GithubIdentities) > 0 {
		for iNdEx := len(m.GithubIdentities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GithubIdentities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SAMLIdentities) > 0 {
		for iNdEx := len(m.SAMLIdentities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SAMLIdentities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OIDCIdentities) > 0 {
		for iNdEx := len(m.OIDCIdentities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OIDCIdentities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExternalIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalIdentity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalIdentity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SAMLSingleLogoutURL) > 0 {
		i -= len(m.SAMLSingleLogoutURL)
		copy(dAtA[i:], m.SAMLSingleLogoutURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SAMLSingleLogoutURL)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConnectorID) > 0 {
		i -= len(m.ConnectorID)
		copy(dAtA[i:], m.ConnectorID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectorID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n179, err179 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LockExpires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LockExpires):])
	if err179 != nil {
		return 0, err179
	}
	i -= n179
	i = encodeVarintTypes(dAtA, i, uint64(n179))
	i--
	dAtA[i] = 0x22
	n180, err180 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LockedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LockedTime):])
	if err180 != nil {
		return 0, err180
	}
	i -= n180
	i = encodeVarintTypes(dAtA, i, uint64(n180))
	i--
	dAtA[i] = 0x1a
	if len(m.LockedMessage) > 0 {
		i -= len(m.LockedMessage)
		copy(dAtA[i:], m.LockedMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LockedMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsLocked {
		i--
		if m.IsLocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreatedBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatedBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatedBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	n182, err182 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Time):])
	if err182 != nil {
		return 0, err182
	}
	i -= n182
	i = encodeVarintTypes(dAtA, i, uint64(n182))
	i--
	dAtA[i] = 0x12
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalAuthSecrets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalAuthSecrets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalAuthSecrets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.MFA) > 0 {
		for iNdEx := len(m.MFA) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MFA[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TOTPKey) > 0 {
		i -= len(m.TOTPKey)
		copy(dAtA[i:], m.TOTPKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TOTPKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PasswordHash) > 0 {
		i -= len(m.PasswordHash)
		copy(dAtA[i:], m.PasswordHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PasswordHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MFADevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFADevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Device != nil {
		{
			size := m.Device.Size()
			i -= size
			if _, err := m.Device.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	n185, err185 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUsed, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUsed):])
	if err185 != nil {
		return 0, err185
	}
	i -= n185
	i = encodeVarintTypes(dAtA, i, uint64(n185))
	i--
	dAtA[i] = 0x3a
	n186, err186 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.AddedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.AddedAt):])
	if err186 != nil {
		return 0, err186
	}
	i -= n186
	i = encodeVarintTypes(dAtA, i, uint64(n186))
	i--
	dAtA[i] = 0x32
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MFADevice_Totp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice_Totp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Totp != nil {
		{
			size, err := m.Totp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *MFADevice_U2F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice_U2F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.U2F != nil {
		{
			size, err := m.U2F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *MFADevice_Webauthn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice_Webauthn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *TOTPDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TOTPDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TOTPDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *U2FDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *U2FDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *U2FDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Counter != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyHandle) > 0 {
		i -= len(m.KeyHandle)
		copy(dAtA[i:], m.KeyHandle)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebauthnDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebauthnDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebauthnDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CredentialBackedUp != nil {
		{
			size, err := m.CredentialBackedUp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CredentialBackupEligible != nil {
		{
			size, err := m.CredentialBackupEligible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CredentialRpId) > 0 {
		i -= len(m.CredentialRpId)
		copy(dAtA[i:], m.CredentialRpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CredentialRpId)))
		i--
		dAtA[i] = 0x42
	}
	if m.ResidentKey {
		i--
		if m.ResidentKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.AttestationObject) > 0 {
		i -= len(m.AttestationObject)
		copy(dAtA[i:], m.AttestationObject)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationObject)))
		i--
		dAtA[i] = 0x32
	}
	if m.SignatureCounter != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SignatureCounter))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Aaguid) > 0 {
		i -= len(m.Aaguid)
		copy(dAtA[i:], m.Aaguid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Aaguid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AttestationType) > 0 {
		i -= len(m.AttestationType)
		copy(dAtA[i:], m.AttestationType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PublicKeyCbor) > 0 {
		i -= len(m.PublicKeyCbor)
		copy(dAtA[i:], m.PublicKeyCbor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyCbor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebauthnLocalAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebauthnLocalAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebauthnLocalAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserID) > 0 {
		i -= len(m.UserID)
		copy(dAtA[i:], m.UserID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConnectorRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectorRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectorRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReverseTunnelV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReverseTunnelV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReverseTunnelV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReverseTunnelSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReverseTunnelSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReverseTunnelSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DialAddrs) > 0 {
		for iNdEx := len(m.DialAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DialAddrs[iNdEx])
			copy(dAtA[i:], m.DialAddrs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DialAddrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelConnectionV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelConnectionV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelConnectionV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelConnectionSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelConnectionSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelConnectionSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	n197, err197 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastHeartbeat, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastHeartbeat):])
	if err197 != nil {
		return 0, err197
	}
	i -= n197
	i = encodeVarintTypes(dAtA, i, uint64(n197))
	i--
	dAtA[i] = 0x1a
	if len(m.ProxyName) > 0 {
		i -= len(m.ProxyName)
		copy(dAtA[i:], m.ProxyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SemaphoreName) > 0 {
		i -= len(m.SemaphoreName)
		copy(dAtA[i:], m.SemaphoreName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SemaphoreName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SemaphoreKind) > 0 {
		i -= len(m.SemaphoreKind)
		copy(dAtA[i:], m.SemaphoreKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SemaphoreKind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcquireSemaphoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcquireSemaphoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcquireSemaphoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x2a
	}
	n198, err198 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err198 != nil {
		return 0, err198
	}
	i -= n198
	i = encodeVarintTypes(dAtA, i, uint64(n198))
	i--
	dAtA[i] = 0x22
	if m.MaxLeases != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxLeases))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SemaphoreName) > 0 {
		i -= len(m.SemaphoreName)
		copy(dAtA[i:], m.SemaphoreName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SemaphoreName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SemaphoreKind) > 0 {
		i -= len(m.SemaphoreKind)
		copy(dAtA[i:], m.SemaphoreKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SemaphoreKind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreLease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n199, err199 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err199 != nil {
		return 0, err199
	}
	i -= n199
	i = encodeVarintTypes(dAtA, i, uint64(n199))
	i--
	dAtA[i] = 0x2a
	if len(m.LeaseID) > 0 {
		i -= len(m.LeaseID)
		copy(dAtA[i:], m.LeaseID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LeaseID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SemaphoreName) > 0 {
		i -= len(m.SemaphoreName)
		copy(dAtA[i:], m.SemaphoreName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SemaphoreName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SemaphoreKind) > 0 {
		i -= len(m.SemaphoreKind)
		copy(dAtA[i:], m.SemaphoreKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SemaphoreKind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreLeaseRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreLeaseRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreLeaseRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x1a
	}
	n200, err200 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err200 != nil {
		return 0, err200
	}
	i -= n200
	i = encodeVarintTypes(dAtA, i, uint64(n200))
	i--
	dAtA[i] = 0x12
	if len(m.LeaseID) > 0 {
		i -= len(m.LeaseID)
		copy(dAtA[i:], m.LeaseID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LeaseID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SemaphoreSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SemaphoreSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SemaphoreSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Leases) > 0 {
		for iNdEx := len(m.Leases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Leases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WebSessionV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSessionV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebSessionV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebSessionSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSessionSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebSessionSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TLSPriv) > 0 {
		i -= len(m.TLSPriv)
		copy(dAtA[i:], m.TLSPriv)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TLSPriv)))
		i--
		dAtA[i] = 0x7a
	}
	if m.TrustedDeviceRequirement != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrustedDeviceRequirement))
		i--
		dAtA[i] = 0x70
	}
	if m.HasDeviceExtensions {
		i--
		if m.HasDeviceExtensions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.DeviceWebToken != nil {
		{
			size, err := m.DeviceWebToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SAMLSession != nil {
		{
			size, err := m.SAMLSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ConsumedAccessRequestID) > 0 {
		i -= len(m.ConsumedAccessRequestID)
		copy(dAtA[i:], m.ConsumedAccessRequestID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConsumedAccessRequestID)))
		i--
		dAtA[i] = 0x52
	}
	if m.IdleTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IdleTimeout))
		i--
		dAtA[i] = 0x48
	}
	n207, err207 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LoginTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LoginTime):])
	if err207 != nil {
		return 0, err207
	}
	i -= n207
	i = encodeVarintTypes(dAtA, i, uint64(n207))
	i--
	dAtA[i] = 0x42
	n208, err208 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err208 != nil {
		return 0, err208
	}
	i -= n208
	i = encodeVarintTypes(dAtA, i, uint64(n208))
	i--
	dAtA[i] = 0x3a
	n209, err209 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.BearerTokenExpires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.BearerTokenExpires):])
	if err209 != nil {
		return 0, err209
	}
	i -= n209
	i = encodeVarintTypes(dAtA, i, uint64(n209))
	i--
	dAtA[i] = 0x32
	if len(m.BearerToken) > 0 {
		i -= len(m.BearerToken)
		copy(dAtA[i:], m.BearerToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BearerToken)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TLSCert) > 0 {
		i -= len(m.TLSCert)
		copy(dAtA[i:], m.TLSCert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TLSCert)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Priv) > 0 {
		i -= len(m.Priv)
		copy(dAtA[i:], m.Priv)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Priv)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pub) > 0 {
		i -= len(m.Pub)
		copy(dAtA[i:], m.Pub)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Pub)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceWebToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceWebToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceWebToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebSessionFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSessionFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebSessionFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLSessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLSessionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLSessionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CustomAttributes) > 0 {
		for iNdEx := len(m.CustomAttributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CustomAttributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.UserScopedAffiliation) > 0 {
		i -= len(m.UserScopedAffiliation)
		copy(dAtA[i:], m.UserScopedAffiliation)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserScopedAffiliation)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.UserGivenName) > 0 {
		i -= len(m.UserGivenName)
		copy(dAtA[i:], m.UserGivenName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserGivenName)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.UserSurname) > 0 {
		i -= len(m.UserSurname)
		copy(dAtA[i:], m.UserSurname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserSurname)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.UserCommonName) > 0 {
		i -= len(m.UserCommonName)
		copy(dAtA[i:], m.UserCommonName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserCommonName)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.UserEmail) > 0 {
		i -= len(m.UserEmail)
		copy(dAtA[i:], m.UserEmail)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserEmail)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Groups[iNdEx])
			copy(dAtA[i:], m.Groups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Groups[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SubjectID) > 0 {
		i -= len(m.SubjectID)
		copy(dAtA[i:], m.SubjectID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubjectID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.NameIDFormat) > 0 {
		i -= len(m.NameIDFormat)
		copy(dAtA[i:], m.NameIDFormat)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NameIDFormat)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NameID) > 0 {
		i -= len(m.NameID)
		copy(dAtA[i:], m.NameID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NameID)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0x22
	}
	n210, err210 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExpireTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExpireTime):])
	if err210 != nil {
		return 0, err210
	}
	i -= n210
	i = encodeVarintTypes(dAtA, i, uint64(n210))
	i--
	dAtA[i] = 0x1a
	n211, err211 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreateTime):])
	if err211 != nil {
		return 0, err211
	}
	i -= n211
	i = encodeVarintTypes(dAtA, i, uint64(n211))
	i--
	dAtA[i] = 0x12
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLAttribute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NameFormat) > 0 {
		i -= len(m.NameFormat)
		copy(dAtA[i:], m.NameFormat)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NameFormat)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FriendlyName) > 0 {
		i -= len(m.FriendlyName)
		copy(dAtA[i:], m.FriendlyName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FriendlyName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLAttributeValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLAttributeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLAttributeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NameID != nil {
		{
			size, err := m.NameID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLNameID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLNameID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLNameID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SPProvidedID) > 0 {
		i -= len(m.SPProvidedID)
		copy(dAtA[i:], m.SPProvidedID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SPProvidedID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SPNameQualifier) > 0 {
		i -= len(m.SPNameQualifier)
		copy(dAtA[i:], m.SPNameQualifier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SPNameQualifier)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NameQualifier) > 0 {
		i -= len(m.NameQualifier)
		copy(dAtA[i:], m.NameQualifier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NameQualifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteClusterV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteClusterV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteClusterV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteClusterStatusV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteClusterStatusV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteClusterStatusV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n215, err215 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastHeartbeat, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastHeartbeat):])
	if err215 != nil {
		return 0, err215
	}
	i -= n215
	i = encodeVarintTypes(dAtA, i, uint64(n215))
	i--
	dAtA[i] = 0x12
	if len(m.Connection) > 0 {
		i -= len(m.Connection)
		copy(dAtA[i:], m.Connection)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Connection)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DynamicLabels) > 0 {
		for k := range m.DynamicLabels {
			v := m.DynamicLabels[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.StaticLabels) > 0 {
		for k := range m.StaticLabels {
			v := m.StaticLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesClusterV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesClusterV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesClusterV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesClusterSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesClusterSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesClusterSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.GCP.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Kubeconfig) > 0 {
		i -= len(m.Kubeconfig)
		copy(dAtA[i:], m.Kubeconfig)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kubeconfig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DynamicLabels) > 0 {
		for k := range m.DynamicLabels {
			v := m.DynamicLabels[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KubeAzure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubeAzure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubeAzure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubscriptionID) > 0 {
		i -= len(m.SubscriptionID)
		copy(dAtA[i:], m.SubscriptionID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubscriptionID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TenantID) > 0 {
		i -= len(m.TenantID)
		copy(dAtA[i:], m.TenantID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TenantID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ResourceGroup) > 0 {
		i -= len(m.ResourceGroup)
		copy(dAtA[i:], m.ResourceGroup)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceName) > 0 {
		i -= len(m.ResourceName)
		copy(dAtA[i:], m.ResourceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubeAWS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubeAWS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubeAWS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AccountID) > 0 {
		i -= len(m.AccountID)
		copy(dAtA[i:], m.AccountID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubeGCP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubeGCP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubeGCP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectID) > 0 {
		i -= len(m.ProjectID)
		copy(dAtA[i:], m.ProjectID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesClusterV3List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesClusterV3List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesClusterV3List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KubernetesClusters) > 0 {
		for iNdEx := len(m.KubernetesClusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KubernetesClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesServerV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesServerV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesServerV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesServerSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesServerSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesServerSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyIDs) > 0 {
		for iNdEx := len(m.ProxyIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProxyIDs[iNdEx])
			copy(dAtA[i:], m.ProxyIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyIDs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebTokenV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebTokenV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebTokenV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebTokenSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebTokenSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebTokenSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWebSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWebSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWebSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteWebSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteWebSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteWebSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWebTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWebTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWebTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteWebTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteWebTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteWebTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceWithSecretsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceWithSecretsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceWithSecretsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithSecrets {
		i--
		if m.WithSecrets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourcesWithSecretsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcesWithSecretsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcesWithSecretsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithSecrets {
		i--
		if m.WithSecrets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceInNamespaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceInNamespaceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceInNamespaceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourcesInNamespaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcesInNamespaceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcesInNamespaceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OIDCConnectorV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCConnectorV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCConnectorV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OIDCConnectorV3List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCConnectorV3List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCConnectorV3List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OIDCConnectors) > 0 {
		for iNdEx := len(m.OIDCConnectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OIDCConnectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OIDCConnectorSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCConnectorSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCConnectorSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClientRedirectSettings != nil {
		{
			size, err := m.ClientRedirectSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.MaxAge != nil {
		{
			size, err := m.MaxAge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.UsernameClaim) > 0 {
		i -= len(m.UsernameClaim)
		copy(dAtA[i:], m.UsernameClaim)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UsernameClaim)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.AllowUnverifiedEmail {
		i--
		if m.AllowUnverifiedEmail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	{
		size := m.RedirectURLs.Size()
		i -= size
		if _, err := m.RedirectURLs.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if len(m.GoogleAdminEmail) > 0 {
		i -= len(m.GoogleAdminEmail)
		copy(dAtA[i:], m.GoogleAdminEmail)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GoogleAdminEmail)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.GoogleServiceAccount) > 0 {
		i -= len(m.GoogleServiceAccount)
		copy(dAtA[i:], m.GoogleServiceAccount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GoogleServiceAccount)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.GoogleServiceAccountURI) > 0 {
		i -= len(m.GoogleServiceAccountURI)
		copy(dAtA[i:], m.GoogleServiceAccountURI)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GoogleServiceAccountURI)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ClaimsToRoles) > 0 {
		for iNdEx := len(m.ClaimsToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClaimsToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Prompt) > 0 {
		i -= len(m.Prompt)
		copy(dAtA[i:], m.Prompt)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Prompt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Scope) > 0 {
		for iNdEx := len(m.Scope) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scope[iNdEx])
			copy(dAtA[i:], m.Scope[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Scope[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Display) > 0 {
		i -= len(m.Display)
		copy(dAtA[i:], m.Display)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Display)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ACR) > 0 {
		i -= len(m.ACR)
		copy(dAtA[i:], m.ACR)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ACR)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClientSecret) > 0 {
		i -= len(m.ClientSecret)
		copy(dAtA[i:], m.ClientSecret)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientSecret)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IssuerURL) > 0 {
		i -= len(m.IssuerURL)
		copy(dAtA[i:], m.IssuerURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IssuerURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaxAge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxAge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxAge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SSOClientRedirectSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSOClientRedirectSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSOClientRedirectSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InsecureAllowedCidrRanges) > 0 {
		for iNdEx := len(m.InsecureAllowedCidrRanges) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InsecureAllowedCidrRanges[iNdEx])
			copy(dAtA[i:], m.InsecureAllowedCidrRanges[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.InsecureAllowedCidrRanges[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AllowedHttpsHostnames) > 0 {
		for iNdEx := len(m.AllowedHttpsHostnames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedHttpsHostnames[iNdEx])
			copy(dAtA[i:], m.AllowedHttpsHostnames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedHttpsHostnames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OIDCAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDCAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDCAuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TlsAttestationStatement != nil {
		{
			size, err := m.TlsAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.SshAttestationStatement != nil {
		{
			size, err := m.SshAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.TlsPublicKey) > 0 {
		i -= len(m.TlsPublicKey)
		copy(dAtA[i:], m.TlsPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.SshPublicKey) > 0 {
		i -= len(m.SshPublicKey)
		copy(dAtA[i:], m.SshPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SshPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.ClientUserAgent) > 0 {
		i -= len(m.ClientUserAgent)
		copy(dAtA[i:], m.ClientUserAgent)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientUserAgent)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ClientLoginIP) > 0 {
		i -= len(m.ClientLoginIP)
		copy(dAtA[i:], m.ClientLoginIP)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientLoginIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.AttestationStatement != nil {
		{
			size, err := m.AttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.ProxyAddress) > 0 {
		i -= len(m.ProxyAddress)
		copy(dAtA[i:], m.ProxyAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ConnectorSpec != nil {
		{
			size, err := m.ConnectorSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SSOTestFlow {
		i--
		if m.SSOTestFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.KubernetesCluster) > 0 {
		i -= len(m.KubernetesCluster)
		copy(dAtA[i:], m.KubernetesCluster)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KubernetesCluster)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.RouteToCluster) > 0 {
		i -= len(m.RouteToCluster)
		copy(dAtA[i:], m.RouteToCluster)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteToCluster)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Compatibility) > 0 {
		i -= len(m.Compatibility)
		copy(dAtA[i:], m.Compatibility)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Compatibility)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ClientRedirectURL) > 0 {
		i -= len(m.ClientRedirectURL)
		copy(dAtA[i:], m.ClientRedirectURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientRedirectURL)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreateWebSession {
		i--
		if m.CreateWebSession {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.CertTTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CertTTL))
		i--
		dAtA[i] = 0x40
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RedirectURL) > 0 {
		i -= len(m.RedirectURL)
		copy(dAtA[i:], m.RedirectURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RedirectURL)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CSRFToken) > 0 {
		i -= len(m.CSRFToken)
		copy(dAtA[i:], m.CSRFToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CSRFToken)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StateToken) > 0 {
		i -= len(m.StateToken)
		copy(dAtA[i:], m.StateToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StateToken)))
		i--
		dAtA[i] = 0x22
	}
	if m.CheckUser {
		i--
		if m.CheckUser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConnectorID) > 0 {
		i -= len(m.ConnectorID)
		copy(dAtA[i:], m.ConnectorID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectorID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLConnectorV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLConnectorV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLConnectorV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLConnectorV2List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLConnectorV2List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLConnectorV2List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SAMLConnectors) > 0 {
		for iNdEx := len(m.SAMLConnectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SAMLConnectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SAMLConnectorSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLConnectorSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLConnectorSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SingleLogoutURL) > 0 {
		i -= len(m.SingleLogoutURL)
		copy(dAtA[i:], m.SingleLogoutURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SingleLogoutURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ClientRedirectSettings != nil {
		{
			size, err := m.ClientRedirectSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.AllowIDPInitiated {
		i--
		if m.AllowIDPInitiated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.EncryptionKeyPair != nil {
		{
			size, err := m.EncryptionKeyPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x62
	}
	if m.SigningKeyPair != nil {
		{
			size, err := m.SigningKeyPair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.AttributesToRoles) > 0 {
		for iNdEx := len(m.AttributesToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttributesToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.EntityDescriptorURL) > 0 {
		i -= len(m.EntityDescriptorURL)
		copy(dAtA[i:], m.EntityDescriptorURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EntityDescriptorURL)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.EntityDescriptor) > 0 {
		i -= len(m.EntityDescriptor)
		copy(dAtA[i:], m.EntityDescriptor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EntityDescriptor)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ServiceProviderIssuer) > 0 {
		i -= len(m.ServiceProviderIssuer)
		copy(dAtA[i:], m.ServiceProviderIssuer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceProviderIssuer)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Audience) > 0 {
		i -= len(m.Audience)
		copy(dAtA[i:], m.Audience)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Audience)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AssertionConsumerService) > 0 {
		i -= len(m.AssertionConsumerService)
		copy(dAtA[i:], m.AssertionConsumerService)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssertionConsumerService)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Display) > 0 {
		i -= len(m.Display)
		copy(dAtA[i:], m.Display)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Display)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SSO) > 0 {
		i -= len(m.SSO)
		copy(dAtA[i:], m.SSO)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SSO)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLAuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TlsAttestationStatement != nil {
		{
			size, err := m.TlsAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SshAttestationStatement != nil {
		{
			size, err := m.SshAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.TlsPublicKey) > 0 {
		i -= len(m.TlsPublicKey)
		copy(dAtA[i:], m.TlsPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SshPublicKey) > 0 {
		i -= len(m.SshPublicKey)
		copy(dAtA[i:], m.SshPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SshPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ClientUserAgent) > 0 {
		i -= len(m.ClientUserAgent)
		copy(dAtA[i:], m.ClientUserAgent)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientUserAgent)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.ClientLoginIP) > 0 {
		i -= len(m.ClientLoginIP)
		copy(dAtA[i:], m.ClientLoginIP)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientLoginIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.AttestationStatement != nil {
		{
			size, err := m.AttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ConnectorSpec != nil {
		{
			size, err := m.ConnectorSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SSOTestFlow {
		i--
		if m.SSOTestFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.KubernetesCluster) > 0 {
		i -= len(m.KubernetesCluster)
		copy(dAtA[i:], m.KubernetesCluster)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KubernetesCluster)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.RouteToCluster) > 0 {
		i -= len(m.RouteToCluster)
		copy(dAtA[i:], m.RouteToCluster)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteToCluster)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Compatibility) > 0 {
		i -= len(m.Compatibility)
		copy(dAtA[i:], m.Compatibility)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Compatibility)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ClientRedirectURL) > 0 {
		i -= len(m.ClientRedirectURL)
		copy(dAtA[i:], m.ClientRedirectURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientRedirectURL)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreateWebSession {
		i--
		if m.CreateWebSession {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.CSRFToken) > 0 {
		i -= len(m.CSRFToken)
		copy(dAtA[i:], m.CSRFToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CSRFToken)))
		i--
		dAtA[i] = 0x42
	}
	if m.CertTTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CertTTL))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RedirectURL) > 0 {
		i -= len(m.RedirectURL)
		copy(dAtA[i:], m.RedirectURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RedirectURL)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CheckUser {
		i--
		if m.CheckUser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConnectorID) > 0 {
		i -= len(m.ConnectorID)
		copy(dAtA[i:], m.ConnectorID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectorID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttributeMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttributeMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AsymmetricKeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsymmetricKeyPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsymmetricKeyPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrivateKey) > 0 {
		i -= len(m.PrivateKey)
		copy(dAtA[i:], m.PrivateKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GithubConnectorV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubConnectorV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubConnectorV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GithubConnectorV3List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubConnectorV3List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubConnectorV3List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GithubConnectors) > 0 {
		for iNdEx := len(m.GithubConnectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GithubConnectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GithubConnectorSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubConnectorSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubConnectorSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClientRedirectSettings != nil {
		{
			size, err := m.ClientRedirectSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.APIEndpointURL) > 0 {
		i -= len(m.APIEndpointURL)
		copy(dAtA[i:], m.APIEndpointURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.APIEndpointURL)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.EndpointURL) > 0 {
		i -= len(m.EndpointURL)
		copy(dAtA[i:], m.EndpointURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndpointURL)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.TeamsToRoles) > 0 {
		for iNdEx := len(m.TeamsToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TeamsToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Display) > 0 {
		i -= len(m.Display)
		copy(dAtA[i:], m.Display)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Display)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TeamsToLogins) > 0 {
		for iNdEx := len(m.TeamsToLogins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TeamsToLogins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RedirectURL) > 0 {
		i -= len(m.RedirectURL)
		copy(dAtA[i:], m.RedirectURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RedirectURL)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClientSecret) > 0 {
		i -= len(m.ClientSecret)
		copy(dAtA[i:], m.ClientSecret)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientSecret)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GithubAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubAuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TlsAttestationStatement != nil {
		{
			size, err := m.TlsAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.SshAttestationStatement != nil {
		{
			size, err := m.SshAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.TlsPublicKey) > 0 {
		i -= len(m.TlsPublicKey)
		copy(dAtA[i:], m.TlsPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SshPublicKey) > 0 {
		i -= len(m.SshPublicKey)
		copy(dAtA[i:], m.SshPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SshPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ClientUserAgent) > 0 {
		i -= len(m.ClientUserAgent)
		copy(dAtA[i:], m.ClientUserAgent)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientUserAgent)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.ClientLoginIP) > 0 {
		i -= len(m.ClientLoginIP)
		copy(dAtA[i:], m.ClientLoginIP)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientLoginIP)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.AttestationStatement != nil {
		{
			size, err := m.AttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.ConnectorSpec != nil {
		{
			size, err := m.ConnectorSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.SSOTestFlow {
		i--
		if m.SSOTestFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.KubernetesCluster) > 0 {
		i -= len(m.KubernetesCluster)
		copy(dAtA[i:], m.KubernetesCluster)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KubernetesCluster)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.RouteToCluster) > 0 {
		i -= len(m.RouteToCluster)
		copy(dAtA[i:], m.RouteToCluster)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteToCluster)))
		i--
		dAtA[i] = 0x62
	}
	if m.Expires != nil {
		n254, err254 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires):])
		if err254 != nil {
			return 0, err254
		}
		i -= n254
		i = encodeVarintTypes(dAtA, i, uint64(n254))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Compatibility) > 0 {
		i -= len(m.Compatibility)
		copy(dAtA[i:], m.Compatibility)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Compatibility)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ClientRedirectURL) > 0 {
		i -= len(m.ClientRedirectURL)
		copy(dAtA[i:], m.ClientRedirectURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientRedirectURL)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RedirectURL) > 0 {
		i -= len(m.RedirectURL)
		copy(dAtA[i:], m.RedirectURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RedirectURL)))
		i--
		dAtA[i] = 0x42
	}
	if m.CreateWebSession {
		i--
		if m.CreateWebSession {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.CertTTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CertTTL))
		i--
		dAtA[i] = 0x30
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CSRFToken) > 0 {
		i -= len(m.CSRFToken)
		copy(dAtA[i:], m.CSRFToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CSRFToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StateToken) > 0 {
		i -= len(m.StateToken)
		copy(dAtA[i:], m.StateToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StateToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConnectorID) > 0 {
		i -= len(m.ConnectorID)
		copy(dAtA[i:], m.ConnectorID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectorID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SSOWarnings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSOWarnings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSOWarnings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Warnings) > 0 {
		for iNdEx := len(m.Warnings) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Warnings[iNdEx])
			copy(dAtA[i:], m.Warnings[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Warnings[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateUserParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateUserParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateUserParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SessionTTL != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SessionTTL))
		i--
		dAtA[i] = 0x40
	}
	{
		size := m.Traits.Size()
		i -= size
		if _, err := m.Traits.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.KubeUsers) > 0 {
		for iNdEx := len(m.KubeUsers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KubeUsers[iNdEx])
			copy(dAtA[i:], m.KubeUsers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KubeUsers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.KubeGroups) > 0 {
		for iNdEx := len(m.KubeGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KubeGroups[iNdEx])
			copy(dAtA[i:], m.KubeGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KubeGroups[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Logins) > 0 {
		for iNdEx := len(m.Logins) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Logins[iNdEx])
			copy(dAtA[i:], m.Logins[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Logins[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConnectorName) > 0 {
		i -= len(m.ConnectorName)
		copy(dAtA[i:], m.ConnectorName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ConnectorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SSODiagnosticInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSODiagnosticInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSODiagnosticInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppliedLoginRules) > 0 {
		for iNdEx := len(m.AppliedLoginRules) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppliedLoginRules[iNdEx])
			copy(dAtA[i:], m.AppliedLoginRules[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppliedLoginRules[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x92
		}
	}
	if m.GithubTokenInfo != nil {
		{
			size, err := m.GithubTokenInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.GithubTeamsToRoles) > 0 {
		for iNdEx := len(m.GithubTeamsToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GithubTeamsToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.GithubTeamsToLogins) > 0 {
		for iNdEx := len(m.GithubTeamsToLogins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GithubTeamsToLogins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xfa
		}
	}
	if m.GithubClaims != nil {
		{
			size, err := m.GithubClaims.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.OIDCConnectorTraitMapping) > 0 {
		for iNdEx := len(m.OIDCConnectorTraitMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OIDCConnectorTraitMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xca
		}
	}
	{
		size := m.OIDCTraitsFromClaims.Size()
		i -= size
		if _, err := m.OIDCTraitsFromClaims.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	if m.OIDCIdentity != nil {
		{
			size := m.OIDCIdentity.Size()
			i -= size
			if _, err := m.OIDCIdentity.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	{
		size := m.OIDCClaims.Size()
		i -= size
		if _, err := m.OIDCClaims.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	if m.OIDCClaimsToRolesWarnings != nil {
		{
			size, err := m.OIDCClaimsToRolesWarnings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.OIDCClaimsToRoles) > 0 {
		for iNdEx := len(m.OIDCClaimsToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OIDCClaimsToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.SAMLConnectorTraitMapping) > 0 {
		for iNdEx := len(m.SAMLConnectorTraitMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SAMLConnectorTraitMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	{
		size := m.SAMLTraitsFromAssertions.Size()
		i -= size
		if _, err := m.SAMLTraitsFromAssertions.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if m.SAMLAssertionInfo != nil {
		{
			size := m.SAMLAssertionInfo.Size()
			i -= size
			if _, err := m.SAMLAssertionInfo.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	{
		size := m.SAMLAttributeStatements.Size()
		i -= size
		if _, err := m.SAMLAttributeStatements.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.SAMLAttributesToRolesWarnings != nil {
		{
			size, err := m.SAMLAttributesToRolesWarnings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SAMLAttributesToRoles) > 0 {
		for iNdEx := len(m.SAMLAttributesToRoles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SAMLAttributesToRoles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.CreateUserParams != nil {
		{
			size, err := m.CreateUserParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.TestFlow {
		i--
		if m.TestFlow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GithubTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Scope) > 0 {
		i -= len(m.Scope)
		copy(dAtA[i:], m.Scope)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Scope)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Expires != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Expires))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TokenType) > 0 {
		i -= len(m.TokenType)
		copy(dAtA[i:], m.TokenType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TokenType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GithubClaims) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GithubClaims) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GithubClaims) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Teams) > 0 {
		for iNdEx := len(m.Teams) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Teams[iNdEx])
			copy(dAtA[i:], m.Teams[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Teams[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.OrganizationToTeams.Size()
		i -= size
		if _, err := m.OrganizationToTeams.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TeamMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TeamMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KubeUsers) > 0 {
		for iNdEx := len(m.KubeUsers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KubeUsers[iNdEx])
			copy(dAtA[i:], m.KubeUsers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KubeUsers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.KubeGroups) > 0 {
		for iNdEx := len(m.KubeGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KubeGroups[iNdEx])
			copy(dAtA[i:], m.KubeGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KubeGroups[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Logins) > 0 {
		for iNdEx := len(m.Logins) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Logins[iNdEx])
			copy(dAtA[i:], m.Logins[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Logins[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Team) > 0 {
		i -= len(m.Team)
		copy(dAtA[i:], m.Team)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Team)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TeamRolesMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamRolesMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TeamRolesMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Team) > 0 {
		i -= len(m.Team)
		copy(dAtA[i:], m.Team)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Team)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Organization) > 0 {
		i -= len(m.Organization)
		copy(dAtA[i:], m.Organization)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Organization)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrustedClusterV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustedClusterV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustedClusterV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrustedClusterV2List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustedClusterV2List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustedClusterV2List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TrustedClusters) > 0 {
		for iNdEx := len(m.TrustedClusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustedClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TrustedClusterSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustedClusterSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustedClusterSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoleMap) > 0 {
		for iNdEx := len(m.RoleMap) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoleMap[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ReverseTunnelAddress) > 0 {
		i -= len(m.ReverseTunnelAddress)
		copy(dAtA[i:], m.ReverseTunnelAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReverseTunnelAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProxyAddress) > 0 {
		i -= len(m.ProxyAddress)
		copy(dAtA[i:], m.ProxyAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LockV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LockSpecV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockSpecV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockSpecV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CreatedBy) > 0 {
		i -= len(m.CreatedBy)
		copy(dAtA[i:], m.CreatedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatedBy)))
		i--
		dAtA[i] = 0x2a
	}
	n272, err272 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err272 != nil {
		return 0, err272
	}
	i -= n272
	i = encodeVarintTypes(dAtA, i, uint64(n272))
	i--
	dAtA[i] = 0x22
	if m.Expires != nil {
		n273, err273 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires):])
		if err273 != nil {
			return 0, err273
		}
		i -= n273
		i = encodeVarintTypes(dAtA, i, uint64(n273))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LockTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LockTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AccessRequest) > 0 {
		i -= len(m.AccessRequest)
		copy(dAtA[i:], m.AccessRequest)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessRequest)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.WindowsDesktop) > 0 {
		i -= len(m.WindowsDesktop)
		copy(dAtA[i:], m.WindowsDesktop)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WindowsDesktop)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MFADevice) > 0 {
		i -= len(m.MFADevice)
		copy(dAtA[i:], m.MFADevice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MFADevice)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Login) > 0 {
		i -= len(m.Login)
		copy(dAtA[i:], m.Login)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Login)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddressCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CIDR) > 0 {
		i -= len(m.CIDR)
		copy(dAtA[i:], m.CIDR)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CIDR)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkRestrictionsSpecV4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRestrictionsSpecV4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkRestrictionsSpecV4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Deny) > 0 {
		for iNdEx := len(m.Deny) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deny[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Allow) > 0 {
		for iNdEx := len(m.Allow) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allow[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkRestrictionsV4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRestrictionsV4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkRestrictionsV4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowsDesktopServiceV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsDesktopServiceV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowsDesktopServiceV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WindowsDesktopServiceSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsDesktopServiceSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowsDesktopServiceSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyIDs) > 0 {
		for iNdEx := len(m.ProxyIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProxyIDs[iNdEx])
			copy(dAtA[i:], m.ProxyIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ProxyIDs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TeleportVersion) > 0 {
		i -= len(m.TeleportVersion)
		copy(dAtA[i:], m.TeleportVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TeleportVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowsDesktopFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsDesktopFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowsDesktopFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowsDesktopV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsDesktopV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowsDesktopV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WindowsDesktopSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsDesktopSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowsDesktopSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ScreenSize != nil {
		{
			size, err := m.ScreenSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.NonAD {
		i--
		if m.NonAD {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Resolution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resolution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resolution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Height != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Width != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterUsingTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterUsingTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterUsingTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BotGeneration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BotGeneration))
		i--
		dAtA[i] = 0x70
	}
	if len(m.BotInstanceID) > 0 {
		i -= len(m.BotInstanceID)
		copy(dAtA[i:], m.BotInstanceID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BotInstanceID)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Expires != nil {
		n282, err282 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires):])
		if err282 != nil {
			return 0, err282
		}
		i -= n282
		i = encodeVarintTypes(dAtA, i, uint64(n282))
		i--
		dAtA[i] = 0x62
	}
	if len(m.IDToken) > 0 {
		i -= len(m.IDToken)
		copy(dAtA[i:], m.IDToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IDToken)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EC2IdentityDocument) > 0 {
		i -= len(m.EC2IdentityDocument)
		copy(dAtA[i:], m.EC2IdentityDocument)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EC2IdentityDocument)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.RemoteAddr) > 0 {
		i -= len(m.RemoteAddr)
		copy(dAtA[i:], m.RemoteAddr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RemoteAddr)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PublicSSHKey) > 0 {
		i -= len(m.PublicSSHKey)
		copy(dAtA[i:], m.PublicSSHKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicSSHKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PublicTLSKey) > 0 {
		i -= len(m.PublicTLSKey)
		copy(dAtA[i:], m.PublicTLSKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicTLSKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DNSNames) > 0 {
		for iNdEx := len(m.DNSNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DNSNames[iNdEx])
			copy(dAtA[i:], m.DNSNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DNSNames[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AdditionalPrincipals) > 0 {
		for iNdEx := len(m.AdditionalPrincipals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AdditionalPrincipals[iNdEx])
			copy(dAtA[i:], m.AdditionalPrincipals[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AdditionalPrincipals[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryCodesV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCodesV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCodesV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryCodesSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCodesSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCodesSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n285, err285 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err285 != nil {
		return 0, err285
	}
	i -= n285
	i = encodeVarintTypes(dAtA, i, uint64(n285))
	i--
	dAtA[i] = 0x12
	if len(m.Codes) > 0 {
		for iNdEx := len(m.Codes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Codes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsUsed {
		i--
		if m.IsUsed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.HashedCode) > 0 {
		i -= len(m.HashedCode)
		copy(dAtA[i:], m.HashedCode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HashedCode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NullableSessionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullableSessionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NullableSessionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionTrackerFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DesktopName) > 0 {
		i -= len(m.DesktopName)
		copy(dAtA[i:], m.DesktopName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DesktopName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionTrackerV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SessionTrackerSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InitialCommand) > 0 {
		for iNdEx := len(m.InitialCommand) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InitialCommand[iNdEx])
			copy(dAtA[i:], m.InitialCommand[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.InitialCommand[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.TargetSubKind) > 0 {
		i -= len(m.TargetSubKind)
		copy(dAtA[i:], m.TargetSubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TargetSubKind)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.DesktopName) > 0 {
		i -= len(m.DesktopName)
		copy(dAtA[i:], m.DesktopName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DesktopName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.AppSessionID) > 0 {
		i -= len(m.AppSessionID)
		copy(dAtA[i:], m.AppSessionID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppSessionID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.DatabaseName) > 0 {
		i -= len(m.DatabaseName)
		copy(dAtA[i:], m.DatabaseName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DatabaseName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.HostPolicies) > 0 {
		for iNdEx := len(m.HostPolicies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HostPolicies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.HostUser) > 0 {
		i -= len(m.HostUser)
		copy(dAtA[i:], m.HostUser)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostUser)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.KubernetesCluster) > 0 {
		i -= len(m.KubernetesCluster)
		copy(dAtA[i:], m.KubernetesCluster)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KubernetesCluster)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Login) > 0 {
		i -= len(m.Login)
		copy(dAtA[i:], m.Login)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Login)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Invited) > 0 {
		for iNdEx := len(m.Invited) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Invited[iNdEx])
			copy(dAtA[i:], m.Invited[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Invited[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AttachedData) > 0 {
		i -= len(m.AttachedData)
		copy(dAtA[i:], m.AttachedData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttachedData)))
		i--
		dAtA[i] = 0x32
	}
	n289, err289 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err289 != nil {
		return 0, err289
	}
	i -= n289
	i = encodeVarintTypes(dAtA, i, uint64(n289))
	i--
	dAtA[i] = 0x2a
	n290, err290 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err290 != nil {
		return 0, err290
	}
	i -= n290
	i = encodeVarintTypes(dAtA, i, uint64(n290))
	i--
	dAtA[i] = 0x22
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionTrackerPolicySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerPolicySet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerPolicySet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RequireSessionJoin) > 0 {
		for iNdEx := len(m.RequireSessionJoin) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequireSessionJoin[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Participant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Participant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Participant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n291, err291 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastActive, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastActive):])
	if err291 != nil {
		return 0, err291
	}
	i -= n291
	i = encodeVarintTypes(dAtA, i, uint64(n291))
	i--
	dAtA[i] = 0x22
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UIConfigV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UIConfigV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UIConfigV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UIConfigSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UIConfigSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UIConfigSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ShowResources) > 0 {
		i -= len(m.ShowResources)
		copy(dAtA[i:], m.ShowResources)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ShowResources)))
		i--
		dAtA[i] = 0x12
	}
	if m.ScrollbackLines != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ScrollbackLines))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InstallerV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallerV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstallerSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallerSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Script) > 0 {
		i -= len(m.Script)
		copy(dAtA[i:], m.Script)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Script)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstallerV1List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerV1List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallerV1List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Installers) > 0 {
		for iNdEx := len(m.Installers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Installers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SortBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SortBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Field) > 0 {
		i -= len(m.Field)
		copy(dAtA[i:], m.Field)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Field)))
		i--
		dAtA[i] = 0x12
	}
	if m.IsDesc {
		i--
		if m.IsDesc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConnectionDiagnosticV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionDiagnosticV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionDiagnosticV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConnectionDiagnosticSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionDiagnosticSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionDiagnosticSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Traces) > 0 {
		for iNdEx := len(m.Traces) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Traces[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConnectionDiagnosticTrace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionDiagnosticTrace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionDiagnosticTrace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseServiceV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseServiceV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseServiceV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DatabaseServiceSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseServiceSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseServiceSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceMatchers) > 0 {
		for iNdEx := len(m.ResourceMatchers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceMatchers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseResourceMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseResourceMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseResourceMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Labels != nil {
		{
			size := m.Labels.Size()
			i -= size
			if _, err := m.Labels.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceMatcherAWS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceMatcherAWS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceMatcherAWS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AssumeRoleARN) > 0 {
		i -= len(m.AssumeRoleARN)
		copy(dAtA[i:], m.AssumeRoleARN)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssumeRoleARN)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterAlert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAlert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterAlert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClusterAlertSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterAlertSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterAlertSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n304, err304 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err304 != nil {
		return 0, err304
	}
	i -= n304
	i = encodeVarintTypes(dAtA, i, uint64(n304))
	i--
	dAtA[i] = 0x1a
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Severity != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterAlertsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterAlertsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterAlertsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithUntargeted {
		i--
		if m.WithUntargeted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.WithAcknowledged {
		i--
		if m.WithAcknowledged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.WithSuperseded {
		i--
		if m.WithSuperseded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AlertID) > 0 {
		i -= len(m.AlertID)
		copy(dAtA[i:], m.AlertID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AlertID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Severity != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AlertAcknowledgement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertAcknowledgement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AlertAcknowledgement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n305, err305 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err305 != nil {
		return 0, err305
	}
	i -= n305
	i = encodeVarintTypes(dAtA, i, uint64(n305))
	i--
	dAtA[i] = 0x22
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AlertID) > 0 {
		i -= len(m.AlertID)
		copy(dAtA[i:], m.AlertID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AlertID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Release) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Release) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Release) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReleaseID) > 0 {
		i -= len(m.ReleaseID)
		copy(dAtA[i:], m.ReleaseID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReleaseID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Product) > 0 {
		i -= len(m.Product)
		copy(dAtA[i:], m.Product)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Product)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NotesMD) > 0 {
		i -= len(m.NotesMD)
		copy(dAtA[i:], m.NotesMD)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NotesMD)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Asset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Asset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Asset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PublicURL) > 0 {
		i -= len(m.PublicURL)
		copy(dAtA[i:], m.PublicURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicURL)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ReleaseIDs) > 0 {
		for iNdEx := len(m.ReleaseIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReleaseIDs[iNdEx])
			copy(dAtA[i:], m.ReleaseIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ReleaseIDs[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DisplaySize) > 0 {
		i -= len(m.DisplaySize)
		copy(dAtA[i:], m.DisplaySize)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisplaySize)))
		i--
		dAtA[i] = 0x3a
	}
	if m.AssetSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AssetSize))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SHA256) > 0 {
		i -= len(m.SHA256)
		copy(dAtA[i:], m.SHA256)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SHA256)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OS) > 0 {
		i -= len(m.OS)
		copy(dAtA[i:], m.OS)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OS)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Arch) > 0 {
		i -= len(m.Arch)
		copy(dAtA[i:], m.Arch)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Arch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Credentials != nil {
		{
			size, err := m.Credentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Settings != nil {
		{
			size := m.Settings.Size()
			i -= size
			if _, err := m.Settings.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Generation) > 0 {
		i -= len(m.Generation)
		copy(dAtA[i:], m.Generation)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Generation)))
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}

func (m *PluginSpecV1_SlackAccessPlugin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_SlackAccessPlugin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SlackAccessPlugin != nil {
		{
			size, err := m.SlackAccessPlugin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Opsgenie) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Opsgenie) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Opsgenie != nil {
		{
			size, err := m.Opsgenie.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Openai) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Openai) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Openai != nil {
		{
			size, err := m.Openai.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Okta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Okta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Okta != nil {
		{
			size, err := m.Okta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Jamf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Jamf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Jamf != nil {
		{
			size, err := m.Jamf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_PagerDuty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_PagerDuty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PagerDuty != nil {
		{
			size, err := m.PagerDuty.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Mattermost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Mattermost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Mattermost != nil {
		{
			size, err := m.Mattermost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Jira) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Jira) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Jira != nil {
		{
			size, err := m.Jira.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Discord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Discord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Discord != nil {
		{
			size, err := m.Discord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_ServiceNow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_ServiceNow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ServiceNow != nil {
		{
			size, err := m.ServiceNow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Gitlab) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Gitlab) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gitlab != nil {
		{
			size, err := m.Gitlab.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_EntraId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_EntraId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntraId != nil {
		{
			size, err := m.EntraId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *PluginSpecV1_Scim) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSpecV1_Scim) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scim != nil {
		{
			size, err := m.Scim.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *PluginSlackAccessSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginSlackAccessSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSlackAccessSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FallbackChannel) > 0 {
		i -= len(m.FallbackChannel)
		copy(dAtA[i:], m.FallbackChannel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FallbackChannel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginGitlabSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginGitlabSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginGitlabSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiEndpoint) > 0 {
		i -= len(m.ApiEndpoint)
		copy(dAtA[i:], m.ApiEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiEndpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginOpsgenieAccessSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOpsgenieAccessSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOpsgenieAccessSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiEndpoint) > 0 {
		i -= len(m.ApiEndpoint)
		copy(dAtA[i:], m.ApiEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiEndpoint)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DefaultSchedules) > 0 {
		for iNdEx := len(m.DefaultSchedules) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DefaultSchedules[iNdEx])
			copy(dAtA[i:], m.DefaultSchedules[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultSchedules[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AlertTags) > 0 {
		for iNdEx := len(m.AlertTags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlertTags[iNdEx])
			copy(dAtA[i:], m.AlertTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AlertTags[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Priority) > 0 {
		i -= len(m.Priority)
		copy(dAtA[i:], m.Priority)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Priority)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *PluginServiceNowSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginServiceNowSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginServiceNowSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CloseCode) > 0 {
		i -= len(m.CloseCode)
		copy(dAtA[i:], m.CloseCode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CloseCode)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ApiEndpoint) > 0 {
		i -= len(m.ApiEndpoint)
		copy(dAtA[i:], m.ApiEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiEndpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginPagerDutySettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginPagerDutySettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginPagerDutySettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ApiEndpoint) > 0 {
		i -= len(m.ApiEndpoint)
		copy(dAtA[i:], m.ApiEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiEndpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserEmail) > 0 {
		i -= len(m.UserEmail)
		copy(dAtA[i:], m.UserEmail)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserEmail)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginJiraSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginJiraSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginJiraSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IssueType) > 0 {
		i -= len(m.IssueType)
		copy(dAtA[i:], m.IssueType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IssueType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectKey) > 0 {
		i -= len(m.ProjectKey)
		copy(dAtA[i:], m.ProjectKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerUrl) > 0 {
		i -= len(m.ServerUrl)
		copy(dAtA[i:], m.ServerUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginOpenAISettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOpenAISettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOpenAISettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PluginMattermostSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginMattermostSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginMattermostSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReportToEmail) > 0 {
		i -= len(m.ReportToEmail)
		copy(dAtA[i:], m.ReportToEmail)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReportToEmail)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Team) > 0 {
		i -= len(m.Team)
		copy(dAtA[i:], m.Team)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Team)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerUrl) > 0 {
		i -= len(m.ServerUrl)
		copy(dAtA[i:], m.ServerUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginJamfSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginJamfSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginJamfSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.JamfSpec != nil {
		{
			size, err := m.JamfSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SyncSettings != nil {
		{
			size, err := m.SyncSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.SsoConnectorId) > 0 {
		i -= len(m.SsoConnectorId)
		copy(dAtA[i:], m.SsoConnectorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SsoConnectorId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EnableUserSync {
		i--
		if m.EnableUserSync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.OrgUrl) > 0 {
		i -= len(m.OrgUrl)
		copy(dAtA[i:], m.OrgUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OrgUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaSyncSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaSyncSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaSyncSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppFilters) > 0 {
		for iNdEx := len(m.AppFilters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppFilters[iNdEx])
			copy(dAtA[i:], m.AppFilters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppFilters[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.GroupFilters) > 0 {
		for iNdEx := len(m.GroupFilters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupFilters[iNdEx])
			copy(dAtA[i:], m.GroupFilters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupFilters[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AppId) > 0 {
		i -= len(m.AppId)
		copy(dAtA[i:], m.AppId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DefaultOwners) > 0 {
		for iNdEx := len(m.DefaultOwners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DefaultOwners[iNdEx])
			copy(dAtA[i:], m.DefaultOwners[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultOwners[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SyncAccessLists {
		i--
		if m.SyncAccessLists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.SsoConnectorId) > 0 {
		i -= len(m.SsoConnectorId)
		copy(dAtA[i:], m.SsoConnectorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SsoConnectorId)))
		i--
		dAtA[i] = 0x12
	}
	if m.SyncUsers {
		i--
		if m.SyncUsers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiscordChannels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscordChannels) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiscordChannels) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChannelIds) > 0 {
		for iNdEx := len(m.ChannelIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ChannelIds[iNdEx])
			copy(dAtA[i:], m.ChannelIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ChannelIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginDiscordSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginDiscordSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginDiscordSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoleToRecipients) > 0 {
		for k := range m.RoleToRecipients {
			v := m.RoleToRecipients[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginEntraIDSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginEntraIDSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginEntraIDSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccessGraphSettings != nil {
		{
			size, err := m.AccessGraphSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SyncSettings != nil {
		{
			size, err := m.SyncSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginEntraIDSyncSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginEntraIDSyncSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginEntraIDSyncSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SsoConnectorId) > 0 {
		i -= len(m.SsoConnectorId)
		copy(dAtA[i:], m.SsoConnectorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SsoConnectorId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DefaultOwners) > 0 {
		for iNdEx := len(m.DefaultOwners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DefaultOwners[iNdEx])
			copy(dAtA[i:], m.DefaultOwners[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultOwners[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginEntraIDAccessGraphSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginEntraIDAccessGraphSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginEntraIDAccessGraphSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppSsoSettingsCache) > 0 {
		for iNdEx := len(m.AppSsoSettingsCache) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppSsoSettingsCache[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginEntraIDAppSSOSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginEntraIDAppSSOSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginEntraIDAppSSOSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FederatedSsoV2) > 0 {
		i -= len(m.FederatedSsoV2)
		copy(dAtA[i:], m.FederatedSsoV2)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FederatedSsoV2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppId) > 0 {
		i -= len(m.AppId)
		copy(dAtA[i:], m.AppId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginSCIMSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginSCIMSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginSCIMSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultRole) > 0 {
		i -= len(m.DefaultRole)
		copy(dAtA[i:], m.DefaultRole)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultRole)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SamlConnectorName) > 0 {
		i -= len(m.SamlConnectorName)
		copy(dAtA[i:], m.SamlConnectorName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SamlConnectorName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginBootstrapCredentialsV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginBootstrapCredentialsV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginBootstrapCredentialsV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Credentials != nil {
		{
			size := m.Credentials.Size()
			i -= size
			if _, err := m.Credentials.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginBootstrapCredentialsV1_Oauth2AuthorizationCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginBootstrapCredentialsV1_Oauth2AuthorizationCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Oauth2AuthorizationCode != nil {
		{
			size, err := m.Oauth2AuthorizationCode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PluginBootstrapCredentialsV1_BearerToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginBootstrapCredentialsV1_BearerToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerToken != nil {
		{
			size, err := m.BearerToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PluginBootstrapCredentialsV1_IdSecret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginBootstrapCredentialsV1_IdSecret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IdSecret != nil {
		{
			size, err := m.IdSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PluginIdSecretCredential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginIdSecretCredential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginIdSecretCredential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginOAuth2AuthorizationCodeCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOAuth2AuthorizationCodeCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOAuth2AuthorizationCodeCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RedirectUri) > 0 {
		i -= len(m.RedirectUri)
		copy(dAtA[i:], m.RedirectUri)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RedirectUri)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AuthorizationCode) > 0 {
		i -= len(m.AuthorizationCode)
		copy(dAtA[i:], m.AuthorizationCode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AuthorizationCode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginStatusV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginStatusV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStatusV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details != nil {
		{
			size := m.Details.Size()
			i -= size
			if _, err := m.Details.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.LastRawError) > 0 {
		i -= len(m.LastRawError)
		copy(dAtA[i:], m.LastRawError)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastRawError)))
		i--
		dAtA[i] = 0x32
	}
	n331, err331 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastSyncTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSyncTime):])
	if err331 != nil {
		return 0, err331
	}
	i -= n331
	i = encodeVarintTypes(dAtA, i, uint64(n331))
	i--
	dAtA[i] = 0x1a
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginStatusV1_Gitlab) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStatusV1_Gitlab) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Gitlab != nil {
		{
			size, err := m.Gitlab.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PluginStatusV1_EntraId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStatusV1_EntraId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EntraId != nil {
		{
			size, err := m.EntraId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PluginStatusV1_Okta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStatusV1_Okta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Okta != nil {
		{
			size, err := m.Okta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *PluginGitlabStatusV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginGitlabStatusV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginGitlabStatusV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImportedProjects != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ImportedProjects))
		i--
		dAtA[i] = 0x18
	}
	if m.ImportedGroups != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ImportedGroups))
		i--
		dAtA[i] = 0x10
	}
	if m.ImportedUsers != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ImportedUsers))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginEntraIDStatusV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginEntraIDStatusV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginEntraIDStatusV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImportedGroups != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ImportedGroups))
		i--
		dAtA[i] = 0x10
	}
	if m.ImportedUsers != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ImportedUsers))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaStatusV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaStatusV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaStatusV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccessListsSyncDetails != nil {
		{
			size, err := m.AccessListsSyncDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ScimDetails != nil {
		{
			size, err := m.ScimDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UsersSyncDetails != nil {
		{
			size, err := m.UsersSyncDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AppGroupSyncDetails != nil {
		{
			size, err := m.AppGroupSyncDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SsoDetails != nil {
		{
			size, err := m.SsoDetails.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaStatusDetailsSSO) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaStatusDetailsSSO) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaStatusDetailsSSO) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppId) > 0 {
		i -= len(m.AppId)
		copy(dAtA[i:], m.AppId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaStatusDetailsAppGroupSync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaStatusDetailsAppGroupSync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaStatusDetailsAppGroupSync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NumGroupsSynced != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumGroupsSynced))
		i--
		dAtA[i] = 0x30
	}
	if m.NumAppsSynced != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumAppsSynced))
		i--
		dAtA[i] = 0x28
	}
	if m.LastFailed != nil {
		n340, err340 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastFailed, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastFailed):])
		if err340 != nil {
			return 0, err340
		}
		i -= n340
		i = encodeVarintTypes(dAtA, i, uint64(n340))
		i--
		dAtA[i] = 0x22
	}
	if m.LastSuccessful != nil {
		n341, err341 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastSuccessful, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastSuccessful):])
		if err341 != nil {
			return 0, err341
		}
		i -= n341
		i = encodeVarintTypes(dAtA, i, uint64(n341))
		i--
		dAtA[i] = 0x1a
	}
	if m.StatusCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaStatusDetailsUsersSync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaStatusDetailsUsersSync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaStatusDetailsUsersSync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x32
	}
	if m.NumUsersSynced != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumUsersSynced))
		i--
		dAtA[i] = 0x28
	}
	if m.LastFailed != nil {
		n342, err342 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastFailed, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastFailed):])
		if err342 != nil {
			return 0, err342
		}
		i -= n342
		i = encodeVarintTypes(dAtA, i, uint64(n342))
		i--
		dAtA[i] = 0x22
	}
	if m.LastSuccessful != nil {
		n343, err343 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastSuccessful, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastSuccessful):])
		if err343 != nil {
			return 0, err343
		}
		i -= n343
		i = encodeVarintTypes(dAtA, i, uint64(n343))
		i--
		dAtA[i] = 0x1a
	}
	if m.StatusCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaStatusDetailsSCIM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaStatusDetailsSCIM) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaStatusDetailsSCIM) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginOktaStatusDetailsAccessListsSync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOktaStatusDetailsAccessListsSync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOktaStatusDetailsAccessListsSync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x4a
	}
	if m.NumGroupsSynced != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumGroupsSynced))
		i--
		dAtA[i] = 0x40
	}
	if len(m.GroupFilters) > 0 {
		for iNdEx := len(m.GroupFilters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupFilters[iNdEx])
			copy(dAtA[i:], m.GroupFilters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupFilters[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.NumAppsSynced != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumAppsSynced))
		i--
		dAtA[i] = 0x30
	}
	if len(m.AppFilters) > 0 {
		for iNdEx := len(m.AppFilters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppFilters[iNdEx])
			copy(dAtA[i:], m.AppFilters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppFilters[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LastFailed != nil {
		n344, err344 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastFailed, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastFailed):])
		if err344 != nil {
			return 0, err344
		}
		i -= n344
		i = encodeVarintTypes(dAtA, i, uint64(n344))
		i--
		dAtA[i] = 0x22
	}
	if m.LastSuccessful != nil {
		n345, err345 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.LastSuccessful, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastSuccessful):])
		if err345 != nil {
			return 0, err345
		}
		i -= n345
		i = encodeVarintTypes(dAtA, i, uint64(n345))
		i--
		dAtA[i] = 0x1a
	}
	if m.StatusCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginCredentialsV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginCredentialsV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginCredentialsV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Credentials != nil {
		{
			size := m.Credentials.Size()
			i -= size
			if _, err := m.Credentials.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginCredentialsV1_Oauth2AccessToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginCredentialsV1_Oauth2AccessToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Oauth2AccessToken != nil {
		{
			size, err := m.Oauth2AccessToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PluginCredentialsV1_BearerToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginCredentialsV1_BearerToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerToken != nil {
		{
			size, err := m.BearerToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PluginCredentialsV1_IdSecret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginCredentialsV1_IdSecret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IdSecret != nil {
		{
			size, err := m.IdSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PluginCredentialsV1_StaticCredentialsRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginCredentialsV1_StaticCredentialsRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticCredentialsRef != nil {
		{
			size, err := m.StaticCredentialsRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PluginOAuth2AccessTokenCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginOAuth2AccessTokenCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginOAuth2AccessTokenCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n350, err350 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err350 != nil {
		return 0, err350
	}
	i -= n350
	i = encodeVarintTypes(dAtA, i, uint64(n350))
	i--
	dAtA[i] = 0x1a
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessToken) > 0 {
		i -= len(m.AccessToken)
		copy(dAtA[i:], m.AccessToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccessToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginBearerTokenCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginBearerTokenCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginBearerTokenCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginStaticCredentialsRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginStaticCredentialsRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginListV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginListV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginListV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Plugins) > 0 {
		for iNdEx := len(m.Plugins) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Plugins[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginStaticCredentialsV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginStaticCredentialsV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Spec != nil {
		{
			size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PluginStaticCredentialsSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginStaticCredentialsSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Credentials != nil {
		{
			size := m.Credentials.Size()
			i -= size
			if _, err := m.Credentials.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PluginStaticCredentialsSpecV1_APIToken) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsSpecV1_APIToken) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.APIToken)
	copy(dAtA[i:], m.APIToken)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.APIToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *PluginStaticCredentialsSpecV1_BasicAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsSpecV1_BasicAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BasicAuth != nil {
		{
			size, err := m.BasicAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PluginStaticCredentialsSpecV1_OAuthClientSecret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsSpecV1_OAuthClientSecret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OAuthClientSecret != nil {
		{
			size, err := m.OAuthClientSecret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PluginStaticCredentialsBasicAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginStaticCredentialsBasicAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsBasicAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginStaticCredentialsOAuthClientSecret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginStaticCredentialsOAuthClientSecret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginStaticCredentialsOAuthClientSecret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClientSecret) > 0 {
		i -= len(m.ClientSecret)
		copy(dAtA[i:], m.ClientSecret)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientSecret)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLIdPServiceProviderV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLIdPServiceProviderV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLIdPServiceProviderV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SAMLIdPServiceProviderSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLIdPServiceProviderSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLIdPServiceProviderSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RelayState) > 0 {
		i -= len(m.RelayState)
		copy(dAtA[i:], m.RelayState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RelayState)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Preset) > 0 {
		i -= len(m.Preset)
		copy(dAtA[i:], m.Preset)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Preset)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AttributeMapping) > 0 {
		for iNdEx := len(m.AttributeMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttributeMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ACSURL) > 0 {
		i -= len(m.ACSURL)
		copy(dAtA[i:], m.ACSURL)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ACSURL)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EntityID) > 0 {
		i -= len(m.EntityID)
		copy(dAtA[i:], m.EntityID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EntityID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EntityDescriptor) > 0 {
		i -= len(m.EntityDescriptor)
		copy(dAtA[i:], m.EntityDescriptor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EntityDescriptor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SAMLAttributeMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SAMLAttributeMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SAMLAttributeMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NameFormat) > 0 {
		i -= len(m.NameFormat)
		copy(dAtA[i:], m.NameFormat)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NameFormat)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdPOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdPOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdPOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SAML != nil {
		{
			size, err := m.SAML.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdPSAMLOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdPSAMLOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdPSAMLOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled != nil {
		{
			size := m.Enabled.Size()
			i -= size
			if _, err := m.Enabled.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesResourceV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourceV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesResourceV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesResourceSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourceSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesResourceSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterMaintenanceConfigV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterMaintenanceConfigV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterMaintenanceConfigV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nonce != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClusterMaintenanceConfigSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterMaintenanceConfigSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterMaintenanceConfigSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AgentUpgrades != nil {
		{
			size, err := m.AgentUpgrades.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AgentUpgradeWindow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentUpgradeWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AgentUpgradeWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Weekdays) > 0 {
		for iNdEx := len(m.Weekdays) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Weekdays[iNdEx])
			copy(dAtA[i:], m.Weekdays[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Weekdays[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.UTCStartHour != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UTCStartHour))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScheduledAgentUpgradeWindow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduledAgentUpgradeWindow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduledAgentUpgradeWindow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n364, err364 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Stop, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Stop):])
	if err364 != nil {
		return 0, err364
	}
	i -= n364
	i = encodeVarintTypes(dAtA, i, uint64(n364))
	i--
	dAtA[i] = 0x12
	n365, err365 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Start):])
	if err365 != nil {
		return 0, err365
	}
	i -= n365
	i = encodeVarintTypes(dAtA, i, uint64(n365))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AgentUpgradeSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentUpgradeSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AgentUpgradeSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Windows) > 0 {
		for iNdEx := len(m.Windows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Windows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserGroupV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserGroupV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserGroupV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UserGroupSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserGroupSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserGroupSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Applications) > 0 {
		for iNdEx := len(m.Applications) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Applications[iNdEx])
			copy(dAtA[i:], m.Applications[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Applications[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OktaImportRuleSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaImportRuleSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaImportRuleSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mappings) > 0 {
		for iNdEx := len(m.Mappings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Mappings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OktaImportRuleMappingV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaImportRuleMappingV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaImportRuleMappingV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AddLabels) > 0 {
		for k := range m.AddLabels {
			v := m.AddLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Match) > 0 {
		for iNdEx := len(m.Match) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Match[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OktaImportRuleV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaImportRuleV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaImportRuleV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OktaImportRuleMatchV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaImportRuleMatchV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaImportRuleMatchV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupNameRegexes) > 0 {
		for iNdEx := len(m.GroupNameRegexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupNameRegexes[iNdEx])
			copy(dAtA[i:], m.GroupNameRegexes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupNameRegexes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AppNameRegexes) > 0 {
		for iNdEx := len(m.AppNameRegexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppNameRegexes[iNdEx])
			copy(dAtA[i:], m.AppNameRegexes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppNameRegexes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.GroupIDs) > 0 {
		for iNdEx := len(m.GroupIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupIDs[iNdEx])
			copy(dAtA[i:], m.GroupIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GroupIDs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AppIDs) > 0 {
		for iNdEx := len(m.AppIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AppIDs[iNdEx])
			copy(dAtA[i:], m.AppIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AppIDs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OktaAssignmentV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaAssignmentV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaAssignmentV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OktaAssignmentSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaAssignmentSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaAssignmentSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Finalized {
		i--
		if m.Finalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	n372, err372 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastTransition, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastTransition):])
	if err372 != nil {
		return 0, err372
	}
	i -= n372
	i = encodeVarintTypes(dAtA, i, uint64(n372))
	i--
	dAtA[i] = 0x2a
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	n373, err373 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CleanupTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CleanupTime):])
	if err373 != nil {
		return 0, err373
	}
	i -= n373
	i = encodeVarintTypes(dAtA, i, uint64(n373))
	i--
	dAtA[i] = 0x1a
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OktaAssignmentTargetV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaAssignmentTargetV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaAssignmentTargetV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IntegrationV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegrationV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegrationV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *IntegrationSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntegrationSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegrationSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubKindSpec != nil {
		{
			size := m.SubKindSpec.Size()
			i -= size
			if _, err := m.SubKindSpec.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IntegrationSpecV1_AWSOIDC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegrationSpecV1_AWSOIDC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AWSOIDC != nil {
		{
			size, err := m.AWSOIDC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *IntegrationSpecV1_AzureOIDC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IntegrationSpecV1_AzureOIDC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureOIDC != nil {
		{
			size, err := m.AzureOIDC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AWSOIDCIntegrationSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSOIDCIntegrationSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSOIDCIntegrationSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IssuerS3URI) > 0 {
		i -= len(m.IssuerS3URI)
		copy(dAtA[i:], m.IssuerS3URI)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IssuerS3URI)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoleARN) > 0 {
		i -= len(m.RoleARN)
		copy(dAtA[i:], m.RoleARN)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RoleARN)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureOIDCIntegrationSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureOIDCIntegrationSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureOIDCIntegrationSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TenantID) > 0 {
		i -= len(m.TenantID)
		copy(dAtA[i:], m.TenantID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TenantID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeadlessAuthentication) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeadlessAuthentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeadlessAuthentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TlsPublicKey) > 0 {
		i -= len(m.TlsPublicKey)
		copy(dAtA[i:], m.TlsPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsPublicKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SshPublicKey) > 0 {
		i -= len(m.SshPublicKey)
		copy(dAtA[i:], m.SshPublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SshPublicKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ClientIpAddress) > 0 {
		i -= len(m.ClientIpAddress)
		copy(dAtA[i:], m.ClientIpAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientIpAddress)))
		i--
		dAtA[i] = 0x32
	}
	if m.MfaDevice != nil {
		{
			size, err := m.MfaDevice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WatchKind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchKind) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchKind) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Filter) > 0 {
		for k := range m.Filter {
			v := m.Filter[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LoadSecrets {
		i--
		if m.LoadSecrets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatchStatusV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchStatusV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchStatusV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatchStatusSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchStatusSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatchStatusSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Kinds) > 0 {
		for iNdEx := len(m.Kinds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Kinds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServerInfoV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerInfoV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServerInfoSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerInfoSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerInfoSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewLabels) > 0 {
		for k := range m.NewLabels {
			v := m.NewLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *JamfSpecV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JamfSpecV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JamfSpecV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Inventory) > 0 {
		for iNdEx := len(m.Inventory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inventory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ApiEndpoint) > 0 {
		i -= len(m.ApiEndpoint)
		copy(dAtA[i:], m.ApiEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ApiEndpoint)))
		i--
		dAtA[i] = 0x22
	}
	if m.SyncDelay != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SyncDelay))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JamfInventoryEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JamfInventoryEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JamfInventoryEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PageSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OnMissing) > 0 {
		i -= len(m.OnMissing)
		copy(dAtA[i:], m.OnMissing)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OnMissing)))
		i--
		dAtA[i] = 0x22
	}
	if m.SyncPeriodFull != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SyncPeriodFull))
		i--
		dAtA[i] = 0x18
	}
	if m.SyncPeriodPartial != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SyncPeriodPartial))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FilterRsql) > 0 {
		i -= len(m.FilterRsql)
		copy(dAtA[i:], m.FilterRsql)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FilterRsql)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageWithHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageWithHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageWithHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.ResourceHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AWSMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SetupAccessForARN) > 0 {
		i -= len(m.SetupAccessForARN)
		copy(dAtA[i:], m.SetupAccessForARN)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SetupAccessForARN)))
		i--
		dAtA[i] = 0x4a
	}
	if m.KubeAppDiscovery {
		i--
		if m.KubeAppDiscovery {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Integration) > 0 {
		i -= len(m.Integration)
		copy(dAtA[i:], m.Integration)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Integration)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SSM != nil {
		{
			size, err := m.SSM.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.Tags.Size()
		i -= size
		if _, err := m.Tags.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.AssumeRole != nil {
		{
			size, err := m.AssumeRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AssumeRole) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssumeRole) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssumeRole) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoleARN) > 0 {
		i -= len(m.RoleARN)
		copy(dAtA[i:], m.RoleARN)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RoleARN)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstallerParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallerParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallerParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EnrollMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EnrollMode))
		i--
		dAtA[i] = 0x40
	}
	if m.Azure != nil {
		{
			size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PublicProxyAddr) > 0 {
		i -= len(m.PublicProxyAddr)
		copy(dAtA[i:], m.PublicProxyAddr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicProxyAddr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SSHDConfig) > 0 {
		i -= len(m.SSHDConfig)
		copy(dAtA[i:], m.SSHDConfig)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SSHDConfig)))
		i--
		dAtA[i] = 0x2a
	}
	if m.InstallTeleport {
		i--
		if m.InstallTeleport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ScriptName) > 0 {
		i -= len(m.ScriptName)
		copy(dAtA[i:], m.ScriptName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ScriptName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JoinToken) > 0 {
		i -= len(m.JoinToken)
		copy(dAtA[i:], m.JoinToken)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JoinToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JoinMethod) > 0 {
		i -= len(m.JoinMethod)
		copy(dAtA[i:], m.JoinMethod)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JoinMethod)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSSSM) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSSM) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSSM) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DocumentName) > 0 {
		i -= len(m.DocumentName)
		copy(dAtA[i:], m.DocumentName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DocumentName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureInstallerParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureInstallerParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureInstallerParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClientID) > 0 {
		i -= len(m.ClientID)
		copy(dAtA[i:], m.ClientID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	{
		size := m.ResourceTags.Size()
		i -= size
		if _, err := m.ResourceTags.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ResourceGroups) > 0 {
		for iNdEx := len(m.ResourceGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourceGroups[iNdEx])
			copy(dAtA[i:], m.ResourceGroups[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceGroups[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Subscriptions) > 0 {
		for iNdEx := len(m.Subscriptions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Subscriptions[iNdEx])
			copy(dAtA[i:], m.Subscriptions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Subscriptions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.Labels.Size()
		i -= size
		if _, err := m.Labels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ServiceAccounts) > 0 {
		for iNdEx := len(m.ServiceAccounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ServiceAccounts[iNdEx])
			copy(dAtA[i:], m.ServiceAccounts[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceAccounts[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ProjectIDs) > 0 {
		for iNdEx := len(m.ProjectIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProjectIDs[iNdEx])
			copy(dAtA[i:], m.ProjectIDs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectIDs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.Tags.Size()
		i -= size
		if _, err := m.Tags.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Locations) > 0 {
		for iNdEx := len(m.Locations) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Locations[iNdEx])
			copy(dAtA[i:], m.Locations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Locations[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesMatcher) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesMatcher) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size := m.Labels.Size()
		i -= size
		if _, err := m.Labels.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Namespaces) > 0 {
		for iNdEx := len(m.Namespaces) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Namespaces[iNdEx])
			copy(dAtA[i:], m.Namespaces[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespaces[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Types) > 0 {
		for iNdEx := len(m.Types) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Types[iNdEx])
			copy(dAtA[i:], m.Types[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Types[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OktaOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OktaOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OktaOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SyncPeriod != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SyncPeriod))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessGraphSync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessGraphSync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessGraphSync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AWS) > 0 {
		for iNdEx := len(m.AWS) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AWS[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessGraphAWSSync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessGraphAWSSync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessGraphAWSSync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Integration) > 0 {
		i -= len(m.Integration)
		copy(dAtA[i:], m.Integration)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Integration)))
		i--
		dAtA[i] = 0x22
	}
	if m.AssumeRole != nil {
		{
			size, err := m.AssumeRole.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *KeepAlive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.Expires != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires)
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rotation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CurrentID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Started)
	n += 1 + l + sovTypes(uint64(l))
	if m.GracePeriod != 0 {
		n += 1 + sovTypes(uint64(m.GracePeriod))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastRotated)
	n += 1 + l + sovTypes(uint64(l))
	l = m.Schedule.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RotationSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateClients)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateServers)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Standby)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseServerV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseServerSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Rotation.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ProxyIDs) > 0 {
		for _, s := range m.ProxyIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseV3List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Databases) > 0 {
		for _, e := range m.Databases {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CACert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DynamicLabels) > 0 {
		for k, v := range m.DynamicLabels {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + l + sovTypes(uint64(l))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = m.AWS.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.GCP.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Azure.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.TLS.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AD.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.MySQL.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.AdminUser != nil {
		l = m.AdminUser.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.MongoAtlas.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Oracle.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseAdminUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultDatabase)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuditUser)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseStatusV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CACert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.AWS.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.MySQL.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.ManagedUsers) > 0 {
		for _, s := range m.ManagedUsers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Azure.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AWS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Redshift.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.RDS.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.ElastiCache.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.SecretStore.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.MemoryDB.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.RDSProxy.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.RedshiftServerless.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssumeRoleARN)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.OpenSearch.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.IAMPolicyStatus != 0 {
		n += 1 + sovTypes(uint64(m.IAMPolicyStatus))
	}
	if len(m.SessionTags) > 0 {
		for k, v := range m.SessionTags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = m.DocumentDB.Size()
	n += 2 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecretStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyPrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KMSKeyID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Redshift) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RDS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IAMAuth {
		n += 2
	}
	if len(m.Subnets) > 0 {
		for _, s := range m.Subnets {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.VPCID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RDSProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CustomEndpointName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ElastiCache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReplicationGroupID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.UserGroupIDs) > 0 {
		for _, s := range m.UserGroupIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TransitEncryptionEnabled {
		n += 2
	}
	l = len(m.EndpointType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryDB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ACLName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TLSEnabled {
		n += 2
	}
	l = len(m.EndpointType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedshiftServerless) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkgroupName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndpointName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.WorkgroupID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenSearch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DomainID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndpointType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DocumentDB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndpointType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GCPCloudSQL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Azure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Redis.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.IsFlexiServer {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AzureRedis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusteringPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeytabFile)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Krb5File)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SPN)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LDAPCert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KDCHostName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseTLS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	l = len(m.CACert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TrustSystemCertPool {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MySQLOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MongoAtlas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstanceV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstanceSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, s := range m.Services {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AuthID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSeen)
	n += 1 + l + sovTypes(uint64(l))
	if len(m.ControlLog) > 0 {
		for _, e := range m.ControlLog {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ExternalUpgrader)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExternalUpgraderVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstanceControlLogEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovTypes(uint64(m.ID))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovTypes(uint64(l))
	if m.TTL != 0 {
		n += 1 + sovTypes(uint64(m.TTL))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstanceFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, s := range m.Services {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ExternalUpgrader)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NoExtUpgrader {
		n += 2
	}
	l = len(m.OlderThanVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NewerThanVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CmdLabels) > 0 {
		for k, v := range m.CmdLabels {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + l + sovTypes(uint64(l))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = m.Rotation.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.UseTunnel {
		n += 2
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PeerAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ProxyIDs) > 0 {
		for _, s := range m.ProxyIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PublicAddrs) > 0 {
		for _, s := range m.PublicAddrs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CloudMetadata != nil {
		l = m.CloudMetadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AWSInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VPCID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Integration)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubnetID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloudMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AWS != nil {
		l = m.AWS.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppServerV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppServerSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Rotation.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ProxyIDs) > 0 {
		for _, s := range m.ProxyIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppV3List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DynamicLabels) > 0 {
		for k, v := range m.DynamicLabels {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + l + sovTypes(uint64(l))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.InsecureSkipVerify {
		n += 2
	}
	if m.Rewrite != nil {
		l = m.Rewrite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AWS != nil {
		l = m.AWS.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Cloud)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Integration)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppServerOrSAMLIdPServiceProviderV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Resource != nil {
		n += m.Resource.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppServerOrSAMLIdPServiceProviderV1_AppServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppServer != nil {
		l = m.AppServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SAMLIdPServiceProvider != nil {
		l = m.SAMLIdPServiceProvider.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Rewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Redirect) > 0 {
		for _, s := range m.Redirect {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.JWTClaims)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandLabelV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Period != 0 {
		n += 1 + sovTypes(uint64(m.Period))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppAWS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SSHKeyPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrivateKeyType != 0 {
		n += 1 + sovTypes(uint64(m.PrivateKeyType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSKeyPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovTypes(uint64(m.KeyType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JWTKeyPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrivateKeyType != 0 {
		n += 1 + sovTypes(uint64(m.PrivateKeyType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertAuthorityV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertAuthoritySpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RoleMap) > 0 {
		for _, e := range m.RoleMap {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Rotation != nil {
		l = m.Rotation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SigningAlg != 0 {
		n += 1 + sovTypes(uint64(m.SigningAlg))
	}
	l = m.ActiveKeys.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AdditionalTrustedKeys.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CAKeySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SSH) > 0 {
		for _, e := range m.SSH {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TLS) > 0 {
		for _, e := range m.TLS {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.JWT) > 0 {
		for _, e := range m.JWT {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Remote)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Local) > 0 {
		for _, s := range m.Local {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenV2List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProvisionTokens) > 0 {
		for _, e := range m.ProvisionTokens {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TokenRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AWSAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AWSRegions) > 0 {
		for _, s := range m.AWSRegions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AWSRole)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AWSARN)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AWSIIDTTL != 0 {
		n += 1 + sovTypes(uint64(m.AWSIIDTTL))
	}
	l = len(m.JoinMethod)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BotName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SuggestedLabels.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.GitHub != nil {
		l = m.GitHub.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CircleCI != nil {
		l = m.CircleCI.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SuggestedAgentMatcherLabels.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Kubernetes != nil {
		l = m.Kubernetes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Azure != nil {
		l = m.Azure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GitLab != nil {
		l = m.GitLab.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GCP != nil {
		l = m.GCP.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Spacelift != nil {
		l = m.Spacelift.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TPM != nil {
		l = m.TPM.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TerraformCloud != nil {
		l = m.TerraformCloud.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2TPM) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EKCertAllowedCAs) > 0 {
		for _, s := range m.EKCertAllowedCAs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2TPM_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EKPublicHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EKCertificateSerial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2GitHub) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.EnterpriseServerHost)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EnterpriseSlug)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2GitHub_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sub)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Repository)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RepositoryOwner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Workflow)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Environment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RefType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2GitLab) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2GitLab_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sub)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RefType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NamespacePath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PipelineSource)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Environment)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserLogin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserEmail)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RefProtected != nil {
		l = m.RefProtected.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnvironmentProtected != nil {
		l = m.EnvironmentProtected.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CIConfigSHA)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CIConfigRefURI)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeploymentTier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectVisibility)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2CircleCI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OrganizationID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2CircleCI_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContextID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2Spacelift) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2Spacelift_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SpaceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CallerID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CallerType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2Kubernetes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StaticJWKS != nil {
		l = m.StaticJWKS.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JWKS)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2Kubernetes_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2Azure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2Azure_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Subscription)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ResourceGroups) > 0 {
		for _, s := range m.ResourceGroups {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2GCP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2GCP_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProjectIDs) > 0 {
		for _, s := range m.ProjectIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Locations) > 0 {
		for _, s := range m.Locations {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ServiceAccounts) > 0 {
		for _, s := range m.ServiceAccounts {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2TerraformCloud) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Audience)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionTokenSpecV2TerraformCloud_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrganizationID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.OrganizationName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.WorkspaceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.WorkspaceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RunPhase)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StaticTokensV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StaticTokensSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StaticTokens) > 0 {
		for _, e := range m.StaticTokens {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterNameV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterNameSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterAuditConfigV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterAuditConfigSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AuditSessionsURI)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.AuditEventsURI.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.EnableContinuousBackups {
		n += 2
	}
	if m.EnableAutoScaling {
		n += 2
	}
	if m.ReadMaxCapacity != 0 {
		n += 1 + sovTypes(uint64(m.ReadMaxCapacity))
	}
	if m.ReadMinCapacity != 0 {
		n += 1 + sovTypes(uint64(m.ReadMinCapacity))
	}
	if m.ReadTargetValue != 0 {
		n += 9
	}
	if m.WriteMaxCapacity != 0 {
		n += 1 + sovTypes(uint64(m.WriteMaxCapacity))
	}
	if m.WriteMinCapacity != 0 {
		n += 1 + sovTypes(uint64(m.WriteMinCapacity))
	}
	if m.WriteTargetValue != 0 {
		n += 9
	}
	if m.RetentionPeriod != 0 {
		n += 1 + sovTypes(uint64(m.RetentionPeriod))
	}
	if m.UseFIPSEndpoint != 0 {
		n += 1 + sovTypes(uint64(m.UseFIPSEndpoint))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterNetworkingConfigV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterNetworkingConfigSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientIdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ClientIdleTimeout))
	}
	if m.KeepAliveInterval != 0 {
		n += 1 + sovTypes(uint64(m.KeepAliveInterval))
	}
	if m.KeepAliveCountMax != 0 {
		n += 1 + sovTypes(uint64(m.KeepAliveCountMax))
	}
	if m.SessionControlTimeout != 0 {
		n += 1 + sovTypes(uint64(m.SessionControlTimeout))
	}
	l = len(m.ClientIdleTimeoutMessage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WebIdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.WebIdleTimeout))
	}
	if m.ProxyListenerMode != 0 {
		n += 1 + sovTypes(uint64(m.ProxyListenerMode))
	}
	if m.RoutingStrategy != 0 {
		n += 1 + sovTypes(uint64(m.RoutingStrategy))
	}
	if m.TunnelStrategy != nil {
		l = m.TunnelStrategy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ProxyPingInterval != 0 {
		n += 1 + sovTypes(uint64(m.ProxyPingInterval))
	}
	if m.AssistCommandExecutionWorkers != 0 {
		n += 1 + sovTypes(uint64(m.AssistCommandExecutionWorkers))
	}
	if m.CaseInsensitiveRouting {
		n += 2
	}
	if m.SSHDialTimeout != 0 {
		n += 1 + sovTypes(uint64(m.SSHDialTimeout))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelStrategyV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Strategy != nil {
		n += m.Strategy.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelStrategyV1_AgentMesh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentMesh != nil {
		l = m.AgentMesh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelStrategyV1_ProxyPeering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProxyPeering != nil {
		l = m.ProxyPeering.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AgentMeshTunnelStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProxyPeeringTunnelStrategy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentConnectionCount != 0 {
		n += 1 + sovTypes(uint64(m.AgentConnectionCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionRecordingConfigV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionRecordingConfigSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ProxyChecksHostKeys != nil {
		l = m.ProxyChecksHostKeys.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthPreferenceV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthPreferenceSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecondFactor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ConnectorName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.U2F != nil {
		l = m.U2F.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DisconnectExpiredCert != nil {
		l = m.DisconnectExpiredCert.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowLocalAuth != nil {
		l = m.AllowLocalAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MessageOfTheDay)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LockingMode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowPasswordless != nil {
		l = m.AllowPasswordless.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequireMFAType != 0 {
		n += 1 + sovTypes(uint64(m.RequireMFAType))
	}
	if m.DeviceTrust != nil {
		l = m.DeviceTrust.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IDP != nil {
		l = m.IDP.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowHeadless != nil {
		l = m.AllowHeadless.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DefaultSessionTTL != 0 {
		n += 2 + sovTypes(uint64(m.DefaultSessionTTL))
	}
	if m.Okta != nil {
		l = m.Okta.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.PIVSlot)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.HardwareKey != nil {
		l = m.HardwareKey.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SignatureAlgorithmSuite != 0 {
		n += 2 + sovTypes(uint64(m.SignatureAlgorithmSuite))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *U2F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Facets) > 0 {
		for _, s := range m.Facets {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DeviceAttestationCAs) > 0 {
		for _, s := range m.DeviceAttestationCAs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Webauthn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RPID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AttestationAllowedCAs) > 0 {
		for _, s := range m.AttestationAllowedCAs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AttestationDeniedCAs) > 0 {
		for _, s := range m.AttestationDeniedCAs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceTrust) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AutoEnroll {
		n += 2
	}
	if len(m.EKCertAllowedCAs) > 0 {
		for _, s := range m.EKCertAllowedCAs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HardwareKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PIVSlot)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SerialNumberValidation != nil {
		l = m.SerialNumberValidation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HardwareKeySerialNumberValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.SerialNumberTraitName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Namespace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NamespaceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTokenV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTokenSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Usage != 0 {
		n += 1 + sovTypes(uint64(m.Usage))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTokenSecretsV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserTokenSecretsSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OTPKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.QRCode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessReviewThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Approve != 0 {
		n += 1 + sovTypes(uint64(m.Approve))
	}
	if m.Deny != 0 {
		n += 1 + sovTypes(uint64(m.Deny))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PromotedAccessList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessReview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ProposedState != 0 {
		n += 1 + sovTypes(uint64(m.ProposedState))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovTypes(uint64(l))
	l = m.Annotations.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.ThresholdIndexes) > 0 {
		l = 0
		for _, e := range m.ThresholdIndexes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.AccessList != nil {
		l = m.AccessList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AssumeStartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.AssumeStartTime)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessReviewSubmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Review.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThresholdIndexSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Indexes) > 0 {
		l = 0
		for _, e := range m.Indexes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThresholdIndexSets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sets) > 0 {
		for _, e := range m.Sets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.RequestReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResolveReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.ResolveAnnotations.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.SystemAnnotations.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Thresholds) > 0 {
		for _, e := range m.Thresholds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RoleThresholdMapping) > 0 {
		for k, v := range m.RoleThresholdMapping {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + l + sovTypes(uint64(l))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Reviews) > 0 {
		for _, e := range m.Reviews {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SuggestedReviewers) > 0 {
		for _, s := range m.SuggestedReviewers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RequestedResourceIDs) > 0 {
		for _, e := range m.RequestedResourceIDs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.LoginHint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DryRun {
		n += 3
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.MaxDuration)
	n += 2 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.SessionTTL)
	n += 2 + l + sovTypes(uint64(l))
	if m.AccessList != nil {
		l = m.AccessList.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AssumeStartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.AssumeStartTime)
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if len(m.SearchKeywords) > 0 {
		for _, s := range m.SearchKeywords {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Scope != 0 {
		n += 1 + sovTypes(uint64(m.Scope))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestableRoles) > 0 {
		for _, s := range m.RequestableRoles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SuggestedReviewers) > 0 {
		for _, s := range m.SuggestedReviewers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ApplicableRolesForResources) > 0 {
		for _, s := range m.ApplicableRolesForResources {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.RequestPrompt)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequireReason {
		n += 2
	}
	if m.AutoRequest {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessCapabilitiesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequestableRoles {
		n += 2
	}
	if m.SuggestedReviewers {
		n += 2
	}
	if len(m.ResourceIDs) > 0 {
		for _, e := range m.ResourceIDs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FilterRequestableRolesByResource {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubResourceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginDataV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginDataEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginDataSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for k, v := range m.Entries {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginDataFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Plugin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginDataUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Plugin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Set) > 0 {
		for k, v := range m.Set {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Expect) > 0 {
		for k, v := range m.Expect {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SearchKeywords) > 0 {
		for _, s := range m.SearchKeywords {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SkipSystemRoles {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleV6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleSpecV6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Options.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Allow.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Deny.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForwardAgent {
		n += 2
	}
	if m.MaxSessionTTL != 0 {
		n += 1 + sovTypes(uint64(m.MaxSessionTTL))
	}
	if m.PortForwarding != nil {
		l = m.PortForwarding.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CertificateFormat)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientIdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ClientIdleTimeout))
	}
	if m.DisconnectExpiredCert {
		n += 2
	}
	if len(m.BPF) > 0 {
		for _, s := range m.BPF {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PermitX11Forwarding {
		n += 2
	}
	if m.MaxConnections != 0 {
		n += 1 + sovTypes(uint64(m.MaxConnections))
	}
	if m.MaxSessions != 0 {
		n += 1 + sovTypes(uint64(m.MaxSessions))
	}
	l = len(m.RequestAccess)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RequestPrompt)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Lock)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RecordSession != nil {
		l = m.RecordSession.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DesktopClipboard != nil {
		l = m.DesktopClipboard.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.CertExtensions) > 0 {
		for _, e := range m.CertExtensions {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.MaxKubernetesConnections != 0 {
		n += 2 + sovTypes(uint64(m.MaxKubernetesConnections))
	}
	if m.DesktopDirectorySharing != nil {
		l = m.DesktopDirectorySharing.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CreateHostUser != nil {
		l = m.CreateHostUser.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.PinSourceIP {
		n += 3
	}
	if m.SSHFileCopy != nil {
		l = m.SSHFileCopy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.RequireMFAType != 0 {
		n += 2 + sovTypes(uint64(m.RequireMFAType))
	}
	l = len(m.DeviceTrustMode)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.IDP != nil {
		l = m.IDP.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CreateDesktopUser != nil {
		l = m.CreateDesktopUser.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CreateDatabaseUser != nil {
		l = m.CreateDatabaseUser.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CreateHostUserMode != 0 {
		n += 2 + sovTypes(uint64(m.CreateHostUserMode))
	}
	if m.CreateDatabaseUserMode != 0 {
		n += 2 + sovTypes(uint64(m.CreateDatabaseUserMode))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MFAVerificationInterval)
	n += 2 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Desktop != nil {
		l = m.Desktop.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SSH)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertExtension) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoleConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Logins) > 0 {
		for _, s := range m.Logins {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.NodeLabels.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.KubeGroups) > 0 {
		for _, s := range m.KubeGroups {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.KubeUsers) > 0 {
		for _, s := range m.KubeUsers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.AppLabels.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ClusterLabels.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.KubernetesLabels.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.DatabaseLabels.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.DatabaseNames) > 0 {
		for _, s := range m.DatabaseNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DatabaseUsers) > 0 {
		for _, s := range m.DatabaseUsers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Impersonate != nil {
		l = m.Impersonate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ReviewRequests != nil {
		l = m.ReviewRequests.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AWSRoleARNs) > 0 {
		for _, s := range m.AWSRoleARNs {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.WindowsDesktopLogins) > 0 {
		for _, s := range m.WindowsDesktopLogins {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = m.WindowsDesktopLabels.Size()
	n += 2 + l + sovTypes(uint64(l))
	if len(m.RequireSessionJoin) > 0 {
		for _, e := range m.RequireSessionJoin {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.JoinSessions) > 0 {
		for _, e := range m.JoinSessions {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HostGroups) > 0 {
		for _, s := range m.HostGroups {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.HostSudoers) > 0 {
		for _, s := range m.HostSudoers {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AzureIdentities) > 0 {
		for _, s := range m.AzureIdentities {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.KubernetesResources) > 0 {
		for _, e := range m.KubernetesResources {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.GCPServiceAccounts) > 0 {
		for _, s := range m.GCPServiceAccounts {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = m.DatabaseServiceLabels.Size()
	n += 2 + l + sovTypes(uint64(l))
	l = m.GroupLabels.Size()
	n += 2 + l + sovTypes(uint64(l))
	if len(m.DesktopGroups) > 0 {
		for _, s := range m.DesktopGroups {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DatabaseRoles) > 0 {
		for _, s := range m.DatabaseRoles {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.NodeLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.AppLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.KubernetesLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.DatabaseLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.DatabaseServiceLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.WindowsDesktopLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.GroupLabelsExpression)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.DatabasePermissions) > 0 {
		for _, e := range m.DatabasePermissions {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SPIFFE) > 0 {
		for _, e := range m.SPIFFE {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SPIFFERoleCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DNSSANs) > 0 {
		for _, s := range m.DNSSANs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IPSANs) > 0 {
		for _, s := range m.IPSANs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabasePermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for _, s := range m.Permissions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Match.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Verbs) > 0 {
		for _, s := range m.Verbs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionRequirePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovTypes(uint64(m.Count))
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OnLeave)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionJoinPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Modes) > 0 {
		for _, s := range m.Modes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ClaimsToRoles) > 0 {
		for _, e := range m.ClaimsToRoles {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Annotations.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Thresholds) > 0 {
		for _, e := range m.Thresholds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SuggestedReviewers) > 0 {
		for _, s := range m.SuggestedReviewers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SearchAsRoles) > 0 {
		for _, s := range m.SearchAsRoles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.MaxDuration != 0 {
		n += 1 + sovTypes(uint64(m.MaxDuration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessReviewConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ClaimsToRoles) > 0 {
		for _, e := range m.ClaimsToRoles {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Where)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.PreviewAsRoles) > 0 {
		for _, s := range m.PreviewAsRoles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestAllowedPromotion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessListName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestAllowedPromotions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Promotions) > 0 {
		for _, e := range m.Promotions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClaimMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Claim)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TraitMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Trait)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, s := range m.Resources {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Verbs) > 0 {
		for _, s := range m.Verbs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Where)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Actions) > 0 {
		for _, s := range m.Actions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImpersonateConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, s := range m.Users {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Where)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoolValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SearchKeywords) > 0 {
		for _, s := range m.SearchKeywords {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserStatusV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PasswordState != 0 {
		n += 1 + sovTypes(uint64(m.PasswordState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OIDCIdentities) > 0 {
		for _, e := range m.OIDCIdentities {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SAMLIdentities) > 0 {
		for _, e := range m.SAMLIdentities {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.GithubIdentities) > 0 {
		for _, e := range m.GithubIdentities {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Traits.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	l = m.CreatedBy.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.LocalAuth != nil {
		l = m.LocalAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TrustedDeviceIDs) > 0 {
		for _, s := range m.TrustedDeviceIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExternalIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnectorID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SAMLSingleLogoutURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsLocked {
		n += 2
	}
	l = len(m.LockedMessage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LockedTime)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LockExpires)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreatedBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovTypes(uint64(l))
	l = m.User.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalAuthSecrets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PasswordHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TOTPKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.MFA) > 0 {
		for _, e := range m.MFA {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFADevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.AddedAt)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUsed)
	n += 1 + l + sovTypes(uint64(l))
	if m.Device != nil {
		n += m.Device.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFADevice_Totp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Totp != nil {
		l = m.Totp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MFADevice_U2F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.U2F != nil {
		l = m.U2F.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MFADevice_Webauthn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TOTPDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *U2FDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyHandle)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Counter != 0 {
		n += 1 + sovTypes(uint64(m.Counter))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebauthnDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyCbor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AttestationType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Aaguid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SignatureCounter != 0 {
		n += 1 + sovTypes(uint64(m.SignatureCounter))
	}
	l = len(m.AttestationObject)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResidentKey {
		n += 2
	}
	l = len(m.CredentialRpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CredentialBackupEligible != nil {
		l = m.CredentialBackupEligible.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CredentialBackedUp != nil {
		l = m.CredentialBackedUp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebauthnLocalAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectorRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReverseTunnelV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReverseTunnelSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.DialAddrs) > 0 {
		for _, s := range m.DialAddrs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelConnectionV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelConnectionSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProxyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastHeartbeat)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SemaphoreKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SemaphoreName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AcquireSemaphoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SemaphoreKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SemaphoreName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxLeases != 0 {
		n += 1 + sovTypes(uint64(m.MaxLeases))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SemaphoreKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SemaphoreName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LeaseID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreLeaseRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LeaseID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SemaphoreSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Leases) > 0 {
		for _, e := range m.Leases {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSessionV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSessionSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Pub)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Priv)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TLSCert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BearerToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.BearerTokenExpires)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LoginTime)
	n += 1 + l + sovTypes(uint64(l))
	if m.IdleTimeout != 0 {
		n += 1 + sovTypes(uint64(m.IdleTimeout))
	}
	l = len(m.ConsumedAccessRequestID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SAMLSession != nil {
		l = m.SAMLSession.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeviceWebToken != nil {
		l = m.DeviceWebToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HasDeviceExtensions {
		n += 2
	}
	if m.TrustedDeviceRequirement != 0 {
		n += 1 + sovTypes(uint64(m.TrustedDeviceRequirement))
	}
	l = len(m.TLSPriv)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceWebToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSessionFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLSessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreateTime)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ExpireTime)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NameID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NameIDFormat)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubjectID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserEmail)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserCommonName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserSurname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserGivenName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserScopedAffiliation)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CustomAttributes) > 0 {
		for _, e := range m.CustomAttributes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FriendlyName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NameFormat)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLAttributeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NameID != nil {
		l = m.NameID.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLNameID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NameQualifier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SPNameQualifier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SPProvidedID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteClusterV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteClusterStatusV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Connection)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastHeartbeat)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StaticLabels) > 0 {
		for k, v := range m.StaticLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.DynamicLabels) > 0 {
		for k, v := range m.DynamicLabels {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + l + sovTypes(uint64(l))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesClusterV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesClusterSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DynamicLabels) > 0 {
		for k, v := range m.DynamicLabels {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + l + sovTypes(uint64(l))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Kubeconfig)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Azure.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.AWS.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.GCP.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubeAzure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TenantID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubeAWS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubeGCP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesClusterV3List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KubernetesClusters) > 0 {
		for _, e := range m.KubernetesClusters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesServerV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesServerSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Rotation.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ProxyIDs) > 0 {
		for _, s := range m.ProxyIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebTokenV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebTokenSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWebSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteWebSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWebTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteWebTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceWithSecretsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.WithSecrets {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcesWithSecretsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithSecrets {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceInNamespaceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcesInNamespaceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OIDCConnectorV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OIDCConnectorV3List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OIDCConnectors) > 0 {
		for _, e := range m.OIDCConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OIDCConnectorSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IssuerURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientSecret)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ACR)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Display)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Prompt)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ClaimsToRoles) > 0 {
		for _, e := range m.ClaimsToRoles {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.GoogleServiceAccountURI)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GoogleServiceAccount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GoogleAdminEmail)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.RedirectURLs.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.AllowUnverifiedEmail {
		n += 2
	}
	l = len(m.UsernameClaim)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaxAge != nil {
		l = m.MaxAge.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ClientRedirectSettings != nil {
		l = m.ClientRedirectSettings.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaxAge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SSOClientRedirectSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowedHttpsHostnames) > 0 {
		for _, s := range m.AllowedHttpsHostnames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.InsecureAllowedCidrRanges) > 0 {
		for _, s := range m.InsecureAllowedCidrRanges {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OIDCAuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnectorID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CheckUser {
		n += 2
	}
	l = len(m.StateToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CSRFToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CertTTL != 0 {
		n += 1 + sovTypes(uint64(m.CertTTL))
	}
	if m.CreateWebSession {
		n += 2
	}
	l = len(m.ClientRedirectURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Compatibility)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RouteToCluster)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KubernetesCluster)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SSOTestFlow {
		n += 2
	}
	if m.ConnectorSpec != nil {
		l = m.ConnectorSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProxyAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.AttestationStatement != nil {
		l = m.AttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientLoginIP)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientUserAgent)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SshPublicKey)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TlsPublicKey)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SshAttestationStatement != nil {
		l = m.SshAttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsAttestationStatement != nil {
		l = m.TlsAttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLConnectorV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLConnectorV2List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SAMLConnectors) > 0 {
		for _, e := range m.SAMLConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLConnectorSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SSO)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Display)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssertionConsumerService)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Audience)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceProviderIssuer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EntityDescriptor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EntityDescriptorURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AttributesToRoles) > 0 {
		for _, e := range m.AttributesToRoles {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SigningKeyPair != nil {
		l = m.SigningKeyPair.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EncryptionKeyPair != nil {
		l = m.EncryptionKeyPair.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowIDPInitiated {
		n += 2
	}
	if m.ClientRedirectSettings != nil {
		l = m.ClientRedirectSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SingleLogoutURL)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLAuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ConnectorID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CheckUser {
		n += 2
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CertTTL != 0 {
		n += 1 + sovTypes(uint64(m.CertTTL))
	}
	l = len(m.CSRFToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreateWebSession {
		n += 2
	}
	l = len(m.ClientRedirectURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Compatibility)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RouteToCluster)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KubernetesCluster)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SSOTestFlow {
		n += 2
	}
	if m.ConnectorSpec != nil {
		l = m.ConnectorSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AttestationStatement != nil {
		l = m.AttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientLoginIP)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientUserAgent)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SshPublicKey)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TlsPublicKey)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SshAttestationStatement != nil {
		l = m.SshAttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsAttestationStatement != nil {
		l = m.TlsAttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttributeMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AsymmetricKeyPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GithubConnectorV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GithubConnectorV3List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GithubConnectors) > 0 {
		for _, e := range m.GithubConnectors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GithubConnectorSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientSecret)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TeamsToLogins) > 0 {
		for _, e := range m.TeamsToLogins {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Display)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TeamsToRoles) > 0 {
		for _, e := range m.TeamsToRoles {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.EndpointURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.APIEndpointURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientRedirectSettings != nil {
		l = m.ClientRedirectSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GithubAuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnectorID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StateToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CSRFToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CertTTL != 0 {
		n += 1 + sovTypes(uint64(m.CertTTL))
	}
	if m.CreateWebSession {
		n += 2
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientRedirectURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Compatibility)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expires != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires)
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RouteToCluster)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KubernetesCluster)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SSOTestFlow {
		n += 2
	}
	if m.ConnectorSpec != nil {
		l = m.ConnectorSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AttestationStatement != nil {
		l = m.AttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientLoginIP)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientUserAgent)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SshPublicKey)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TlsPublicKey)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SshAttestationStatement != nil {
		l = m.SshAttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TlsAttestationStatement != nil {
		l = m.TlsAttestationStatement.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SSOWarnings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Warnings) > 0 {
		for _, s := range m.Warnings {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateUserParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnectorName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Logins) > 0 {
		for _, s := range m.Logins {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.KubeGroups) > 0 {
		for _, s := range m.KubeGroups {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.KubeUsers) > 0 {
		for _, s := range m.KubeUsers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Traits.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.SessionTTL != 0 {
		n += 1 + sovTypes(uint64(m.SessionTTL))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SSODiagnosticInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestFlow {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.CreateUserParams != nil {
		l = m.CreateUserParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.SAMLAttributesToRoles) > 0 {
		for _, e := range m.SAMLAttributesToRoles {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SAMLAttributesToRolesWarnings != nil {
		l = m.SAMLAttributesToRolesWarnings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SAMLAttributeStatements.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.SAMLAssertionInfo != nil {
		l = m.SAMLAssertionInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.SAMLTraitsFromAssertions.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.SAMLConnectorTraitMapping) > 0 {
		for _, e := range m.SAMLConnectorTraitMapping {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.OIDCClaimsToRoles) > 0 {
		for _, e := range m.OIDCClaimsToRoles {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.OIDCClaimsToRolesWarnings != nil {
		l = m.OIDCClaimsToRolesWarnings.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = m.OIDCClaims.Size()
	n += 2 + l + sovTypes(uint64(l))
	if m.OIDCIdentity != nil {
		l = m.OIDCIdentity.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	l = m.OIDCTraitsFromClaims.Size()
	n += 2 + l + sovTypes(uint64(l))
	if len(m.OIDCConnectorTraitMapping) > 0 {
		for _, e := range m.OIDCConnectorTraitMapping {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.GithubClaims != nil {
		l = m.GithubClaims.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.GithubTeamsToLogins) > 0 {
		for _, e := range m.GithubTeamsToLogins {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.GithubTeamsToRoles) > 0 {
		for _, e := range m.GithubTeamsToRoles {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.GithubTokenInfo != nil {
		l = m.GithubTokenInfo.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.AppliedLoginRules) > 0 {
		for _, s := range m.AppliedLoginRules {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GithubTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expires != 0 {
		n += 1 + sovTypes(uint64(m.Expires))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GithubClaims) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.OrganizationToTeams.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.Teams) > 0 {
		for _, s := range m.Teams {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Team)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Logins) > 0 {
		for _, s := range m.Logins {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.KubeGroups) > 0 {
		for _, s := range m.KubeGroups {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.KubeUsers) > 0 {
		for _, s := range m.KubeUsers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamRolesMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Organization)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Team)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrustedClusterV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrustedClusterV2List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TrustedClusters) > 0 {
		for _, e := range m.TrustedClusters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TrustedClusterSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProxyAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ReverseTunnelAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RoleMap) > 0 {
		for _, e := range m.RoleMap {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockSpecV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Target.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expires != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires)
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.CreatedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LockTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MFADevice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.WindowsDesktop)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccessRequest)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CIDR)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkRestrictionsSpecV4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allow) > 0 {
		for _, e := range m.Allow {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Deny) > 0 {
		for _, e := range m.Deny {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkRestrictionsV4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsDesktopServiceV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsDesktopServiceSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TeleportVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ProxyIDs) > 0 {
		for _, s := range m.ProxyIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsDesktopFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsDesktopV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsDesktopSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NonAD {
		n += 2
	}
	if m.ScreenSize != nil {
		l = m.ScreenSize.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Resolution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovTypes(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovTypes(uint64(m.Height))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RegisterUsingTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AdditionalPrincipals) > 0 {
		for _, s := range m.AdditionalPrincipals {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DNSNames) > 0 {
		for _, s := range m.DNSNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PublicTLSKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicSSHKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RemoteAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EC2IdentityDocument)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IDToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expires != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires)
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BotInstanceID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BotGeneration != 0 {
		n += 1 + sovTypes(uint64(m.BotGeneration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecoveryCodesV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecoveryCodesSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for _, e := range m.Codes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecoveryCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HashedCode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IsUsed {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullableSessionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DesktopName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.AttachedData)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Invited) > 0 {
		for _, s := range m.Invited {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.KubernetesCluster)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HostUser)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.HostPolicies) > 0 {
		for _, e := range m.HostPolicies {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.DatabaseName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.AppSessionID)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.DesktopName)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.TargetSubKind)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.InitialCommand) > 0 {
		for _, s := range m.InitialCommand {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerPolicySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RequireSessionJoin) > 0 {
		for _, e := range m.RequireSessionJoin {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Participant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastActive)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UIConfigV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UIConfigSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScrollbackLines != 0 {
		n += 1 + sovTypes(uint64(m.ScrollbackLines))
	}
	l = len(m.ShowResources)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerV1List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Installers) > 0 {
		for _, e := range m.Installers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SortBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsDesc {
		n += 2
	}
	l = len(m.Field)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectionDiagnosticV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectionDiagnosticSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Traces) > 0 {
		for _, e := range m.Traces {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectionDiagnosticTrace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseServiceV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseServiceSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourceMatchers) > 0 {
		for _, e := range m.ResourceMatchers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseResourceMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.AWS.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceMatcherAWS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssumeRoleARN)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterAlert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterAlertSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Severity != 0 {
		n += 1 + sovTypes(uint64(m.Severity))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterAlertsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Severity != 0 {
		n += 1 + sovTypes(uint64(m.Severity))
	}
	l = len(m.AlertID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.WithSuperseded {
		n += 2
	}
	if m.WithAcknowledged {
		n += 2
	}
	if m.WithUntargeted {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AlertAcknowledgement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AlertID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Release) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NotesMD)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ReleaseID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Asset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Arch)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.OS)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SHA256)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AssetSize != 0 {
		n += 1 + sovTypes(uint64(m.AssetSize))
	}
	l = len(m.DisplaySize)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ReleaseIDs) > 0 {
		for _, s := range m.ReleaseIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PublicURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Settings != nil {
		n += m.Settings.Size()
	}
	l = len(m.Generation)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginSpecV1_SlackAccessPlugin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SlackAccessPlugin != nil {
		l = m.SlackAccessPlugin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Opsgenie) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opsgenie != nil {
		l = m.Opsgenie.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Openai) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Openai != nil {
		l = m.Openai.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Okta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Okta != nil {
		l = m.Okta.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Jamf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jamf != nil {
		l = m.Jamf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_PagerDuty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PagerDuty != nil {
		l = m.PagerDuty.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Mattermost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mattermost != nil {
		l = m.Mattermost.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Jira) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Jira != nil {
		l = m.Jira.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Discord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Discord != nil {
		l = m.Discord.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_ServiceNow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServiceNow != nil {
		l = m.ServiceNow.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Gitlab) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gitlab != nil {
		l = m.Gitlab.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_EntraId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntraId != nil {
		l = m.EntraId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSpecV1_Scim) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scim != nil {
		l = m.Scim.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginSlackAccessSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FallbackChannel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginGitlabSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOpsgenieAccessSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Priority)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AlertTags) > 0 {
		for _, s := range m.AlertTags {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.DefaultSchedules) > 0 {
		for _, s := range m.DefaultSchedules {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ApiEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginServiceNowSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ApiEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CloseCode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginPagerDutySettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserEmail)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ApiEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginJiraSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IssueType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOpenAISettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginMattermostSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Team)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ReportToEmail)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginJamfSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JamfSpec != nil {
		l = m.JamfSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrgUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnableUserSync {
		n += 2
	}
	l = len(m.SsoConnectorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SyncSettings != nil {
		l = m.SyncSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaSyncSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SyncUsers {
		n += 2
	}
	l = len(m.SsoConnectorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SyncAccessLists {
		n += 2
	}
	if len(m.DefaultOwners) > 0 {
		for _, s := range m.DefaultOwners {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.GroupFilters) > 0 {
		for _, s := range m.GroupFilters {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AppFilters) > 0 {
		for _, s := range m.AppFilters {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiscordChannels) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChannelIds) > 0 {
		for _, s := range m.ChannelIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginDiscordSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoleToRecipients) > 0 {
		for k, v := range m.RoleToRecipients {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginEntraIDSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SyncSettings != nil {
		l = m.SyncSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AccessGraphSettings != nil {
		l = m.AccessGraphSettings.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginEntraIDSyncSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DefaultOwners) > 0 {
		for _, s := range m.DefaultOwners {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.SsoConnectorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginEntraIDAccessGraphSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AppSsoSettingsCache) > 0 {
		for _, e := range m.AppSsoSettingsCache {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginEntraIDAppSSOSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FederatedSsoV2)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginSCIMSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SamlConnectorName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultRole)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginBootstrapCredentialsV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Credentials != nil {
		n += m.Credentials.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginBootstrapCredentialsV1_Oauth2AuthorizationCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oauth2AuthorizationCode != nil {
		l = m.Oauth2AuthorizationCode.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginBootstrapCredentialsV1_BearerToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerToken != nil {
		l = m.BearerToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginBootstrapCredentialsV1_IdSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdSecret != nil {
		l = m.IdSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginIdSecretCredential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOAuth2AuthorizationCodeCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthorizationCode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RedirectUri)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginStatusV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSyncTime)
	n += 1 + l + sovTypes(uint64(l))
	if m.Details != nil {
		n += m.Details.Size()
	}
	l = len(m.LastRawError)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginStatusV1_Gitlab) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gitlab != nil {
		l = m.Gitlab.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginStatusV1_EntraId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntraId != nil {
		l = m.EntraId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginStatusV1_Okta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Okta != nil {
		l = m.Okta.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginGitlabStatusV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImportedUsers != 0 {
		n += 1 + sovTypes(uint64(m.ImportedUsers))
	}
	if m.ImportedGroups != 0 {
		n += 1 + sovTypes(uint64(m.ImportedGroups))
	}
	if m.ImportedProjects != 0 {
		n += 1 + sovTypes(uint64(m.ImportedProjects))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginEntraIDStatusV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImportedUsers != 0 {
		n += 1 + sovTypes(uint64(m.ImportedUsers))
	}
	if m.ImportedGroups != 0 {
		n += 1 + sovTypes(uint64(m.ImportedGroups))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaStatusV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SsoDetails != nil {
		l = m.SsoDetails.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AppGroupSyncDetails != nil {
		l = m.AppGroupSyncDetails.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UsersSyncDetails != nil {
		l = m.UsersSyncDetails.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ScimDetails != nil {
		l = m.ScimDetails.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AccessListsSyncDetails != nil {
		l = m.AccessListsSyncDetails.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaStatusDetailsSSO) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaStatusDetailsAppGroupSync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.StatusCode != 0 {
		n += 1 + sovTypes(uint64(m.StatusCode))
	}
	if m.LastSuccessful != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastSuccessful)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastFailed != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastFailed)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumAppsSynced != 0 {
		n += 1 + sovTypes(uint64(m.NumAppsSynced))
	}
	if m.NumGroupsSynced != 0 {
		n += 1 + sovTypes(uint64(m.NumGroupsSynced))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaStatusDetailsUsersSync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.StatusCode != 0 {
		n += 1 + sovTypes(uint64(m.StatusCode))
	}
	if m.LastSuccessful != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastSuccessful)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastFailed != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastFailed)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumUsersSynced != 0 {
		n += 1 + sovTypes(uint64(m.NumUsersSynced))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaStatusDetailsSCIM) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginOktaStatusDetailsAccessListsSync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.StatusCode != 0 {
		n += 1 + sovTypes(uint64(m.StatusCode))
	}
	if m.LastSuccessful != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastSuccessful)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastFailed != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.LastFailed)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AppFilters) > 0 {
		for _, s := range m.AppFilters {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NumAppsSynced != 0 {
		n += 1 + sovTypes(uint64(m.NumAppsSynced))
	}
	if len(m.GroupFilters) > 0 {
		for _, s := range m.GroupFilters {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NumGroupsSynced != 0 {
		n += 1 + sovTypes(uint64(m.NumGroupsSynced))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginCredentialsV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Credentials != nil {
		n += m.Credentials.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginCredentialsV1_Oauth2AccessToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Oauth2AccessToken != nil {
		l = m.Oauth2AccessToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginCredentialsV1_BearerToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerToken != nil {
		l = m.BearerToken.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginCredentialsV1_IdSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IdSecret != nil {
		l = m.IdSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginCredentialsV1_StaticCredentialsRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticCredentialsRef != nil {
		l = m.StaticCredentialsRef.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginOAuth2AccessTokenCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginBearerTokenCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginStaticCredentialsRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginListV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Plugins) > 0 {
		for _, e := range m.Plugins {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginStaticCredentialsV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginStaticCredentialsSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Credentials != nil {
		n += m.Credentials.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginStaticCredentialsSpecV1_APIToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.APIToken)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PluginStaticCredentialsSpecV1_BasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicAuth != nil {
		l = m.BasicAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginStaticCredentialsSpecV1_OAuthClientSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OAuthClientSecret != nil {
		l = m.OAuthClientSecret.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PluginStaticCredentialsBasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginStaticCredentialsOAuthClientSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientSecret)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLIdPServiceProviderV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLIdPServiceProviderSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EntityDescriptor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EntityID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ACSURL)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AttributeMapping) > 0 {
		for _, e := range m.AttributeMapping {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Preset)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RelayState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SAMLAttributeMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NameFormat)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdPOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SAML != nil {
		l = m.SAML.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdPSAMLOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled != nil {
		l = m.Enabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResourceV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesResourceSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterMaintenanceConfigV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Nonce != 0 {
		n += 1 + sovTypes(uint64(m.Nonce))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterMaintenanceConfigSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentUpgrades != nil {
		l = m.AgentUpgrades.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentUpgradeWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UTCStartHour != 0 {
		n += 1 + sovTypes(uint64(m.UTCStartHour))
	}
	if len(m.Weekdays) > 0 {
		for _, s := range m.Weekdays {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScheduledAgentUpgradeWindow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Stop)
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentUpgradeSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Windows) > 0 {
		for _, e := range m.Windows {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserGroupV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserGroupSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Applications) > 0 {
		for _, s := range m.Applications {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaImportRuleSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if len(m.Mappings) > 0 {
		for _, e := range m.Mappings {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaImportRuleMappingV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AddLabels) > 0 {
		for k, v := range m.AddLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaImportRuleV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaImportRuleMatchV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AppIDs) > 0 {
		for _, s := range m.AppIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.GroupIDs) > 0 {
		for _, s := range m.GroupIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AppNameRegexes) > 0 {
		for _, s := range m.AppNameRegexes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.GroupNameRegexes) > 0 {
		for _, s := range m.GroupNameRegexes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaAssignmentV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaAssignmentSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CleanupTime)
	n += 1 + l + sovTypes(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastTransition)
	n += 1 + l + sovTypes(uint64(l))
	if m.Finalized {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaAssignmentTargetV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntegrationV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntegrationSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubKindSpec != nil {
		n += m.SubKindSpec.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IntegrationSpecV1_AWSOIDC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AWSOIDC != nil {
		l = m.AWSOIDC.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IntegrationSpecV1_AzureOIDC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureOIDC != nil {
		l = m.AzureOIDC.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSOIDCIntegrationSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoleARN)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IssuerS3URI)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AzureOIDCIntegrationSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TenantID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeadlessAuthentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.MfaDevice != nil {
		l = m.MfaDevice.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientIpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SshPublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TlsPublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchKind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LoadSecrets {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Filter) > 0 {
		for k, v := range m.Filter {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchStatusV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WatchStatusSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for _, e := range m.Kinds {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerInfoSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NewLabels) > 0 {
		for k, v := range m.NewLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JamfSpecV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SyncDelay != 0 {
		n += 1 + sovTypes(uint64(m.SyncDelay))
	}
	l = len(m.ApiEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Inventory) > 0 {
		for _, e := range m.Inventory {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JamfInventoryEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilterRsql)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SyncPeriodPartial != 0 {
		n += 1 + sovTypes(uint64(m.SyncPeriodPartial))
	}
	if m.SyncPeriodFull != 0 {
		n += 1 + sovTypes(uint64(m.SyncPeriodFull))
	}
	l = len(m.OnMissing)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovTypes(uint64(m.PageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageWithHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ResourceHeader.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AWSMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AssumeRole != nil {
		l = m.AssumeRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Tags.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SSM != nil {
		l = m.SSM.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Integration)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.KubeAppDiscovery {
		n += 2
	}
	l = len(m.SetupAccessForARN)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AssumeRole) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoleARN)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallerParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JoinMethod)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.JoinToken)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ScriptName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.InstallTeleport {
		n += 2
	}
	l = len(m.SSHDConfig)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicProxyAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Azure != nil {
		l = m.Azure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnrollMode != 0 {
		n += 1 + sovTypes(uint64(m.EnrollMode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AWSSSM) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DocumentName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AzureInstallerParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AzureMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subscriptions) > 0 {
		for _, s := range m.Subscriptions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResourceGroups) > 0 {
		for _, s := range m.ResourceGroups {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.ResourceTags.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GCPMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Locations) > 0 {
		for _, s := range m.Locations {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Tags.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.ProjectIDs) > 0 {
		for _, s := range m.ProjectIDs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ServiceAccounts) > 0 {
		for _, s := range m.ServiceAccounts {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Labels.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesMatcher) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		for _, s := range m.Types {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Namespaces) > 0 {
		for _, s := range m.Namespaces {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Labels.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OktaOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SyncPeriod != 0 {
		n += 1 + sovTypes(uint64(m.SyncPeriod))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessGraphSync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AWS) > 0 {
		for _, e := range m.AWS {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessGraphAWSSync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AssumeRole != nil {
		l = m.AssumeRole.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Integration)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *KeepAlive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeepAlive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeepAlive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= KeepAlive_KeepAliveType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expires == nil {
				m.Expires = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Started, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriod", wireType)
			}
			m.GracePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriod |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRotated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastRotated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RotationSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RotationSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RotationSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdateClients, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdateServers, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standby", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Standby, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseServerV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseServerV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseServerV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseServerSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseServerSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseServerSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Database == nil {
				m.Database = &DatabaseV3{}
			}
			if err := m.Database.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyIDs = append(m.ProxyIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseV3List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseV3List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseV3List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Databases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Databases = append(m.Databases, &DatabaseV3{})
			if err := m.Databases[len(m.Databases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicLabels == nil {
				m.DynamicLabels = make(map[string]CommandLabelV2)
			}
			var mapkey string
			mapvalue := &CommandLabelV2{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLabelV2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DynamicLabels[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TLS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AD.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MySQL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MySQL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminUser == nil {
				m.AdminUser = &DatabaseAdminUser{}
			}
			if err := m.AdminUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MongoAtlas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MongoAtlas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Oracle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseAdminUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseAdminUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseAdminUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDatabase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultDatabase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuditUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseStatusV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseStatusV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseStatusV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MySQL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MySQL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagedUsers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagedUsers = append(m.ManagedUsers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redshift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Redshift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RDS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElastiCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ElastiCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SecretStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryDB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MemoryDB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDSProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RDSProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedshiftServerless", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedshiftServerless.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeRoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssumeRoleARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenSearch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpenSearch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IAMPolicyStatus", wireType)
			}
			m.IAMPolicyStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IAMPolicyStatus |= IAMPolicyStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionTags == nil {
				m.SessionTags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SessionTags[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentDB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DocumentDB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KMSKeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KMSKeyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Redshift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Redshift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Redshift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RDS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RDS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RDS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IAMAuth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IAMAuth = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RDSProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RDSProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RDSProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomEndpointName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomEndpointName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElastiCache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElastiCache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElastiCache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationGroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicationGroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroupIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroupIDs = append(m.UserGroupIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitEncryptionEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransitEncryptionEnabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryDB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryDB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryDB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACLName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ACLName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSEnabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedshiftServerless) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedshiftServerless: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedshiftServerless: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkgroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkgroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSearch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSearch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSearch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentDB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentDB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentDB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPCloudSQL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPCloudSQL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPCloudSQL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Azure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Azure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Azure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Redis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFlexiServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFlexiServer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureRedis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureRedis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureRedis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusteringPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusteringPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeytabFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeytabFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Krb5File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Krb5File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SPN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LDAPCert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LDAPCert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KDCHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KDCHostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseTLS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseTLS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseTLS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= DatabaseTLSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustSystemCertPool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrustSystemCertPool = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MySQLOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MySQLOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MySQLOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MongoAtlas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MongoAtlas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MongoAtlas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, SystemRole(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastSeen, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlLog = append(m.ControlLog, InstanceControlLogEntry{})
			if err := m.ControlLog[len(m.ControlLog)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUpgrader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUpgrader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUpgraderVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUpgraderVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceControlLogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceControlLogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceControlLogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, SystemRole(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUpgrader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUpgrader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoExtUpgrader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoExtUpgrader = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OlderThanVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OlderThanVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewerThanVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewerThanVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CmdLabels == nil {
				m.CmdLabels = make(map[string]CommandLabelV2)
			}
			var mapkey string
			mapvalue := &CommandLabelV2{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLabelV2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CmdLabels[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseTunnel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseTunnel = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyIDs = append(m.ProxyIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddrs = append(m.PublicAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudMetadata == nil {
				m.CloudMetadata = &CloudMetadata{}
			}
			if err := m.CloudMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Integration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AWS == nil {
				m.AWS = &AWSInfo{}
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppServerV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppServerV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppServerV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppServerSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppServerSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppServerSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &AppV3{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyIDs = append(m.ProxyIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppV3List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppV3List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppV3List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, &AppV3{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicLabels == nil {
				m.DynamicLabels = make(map[string]CommandLabelV2)
			}
			var mapkey string
			mapvalue := &CommandLabelV2{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLabelV2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DynamicLabels[mapkey] = *mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InsecureSkipVerify = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewrite == nil {
				m.Rewrite = &Rewrite{}
			}
			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AWS == nil {
				m.AWS = &AppAWS{}
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloud", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloud = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Integration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppServerOrSAMLIdPServiceProviderV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppServerOrSAMLIdPServiceProviderV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppServerOrSAMLIdPServiceProviderV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppServerV3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &AppServerOrSAMLIdPServiceProviderV1_AppServer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLIdPServiceProvider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SAMLIdPServiceProviderV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &AppServerOrSAMLIdPServiceProviderV1_SAMLIdPServiceProvider{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redirect = append(m.Redirect, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWTClaims", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWTClaims = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandLabelV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandLabelV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandLabelV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppAWS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppAWS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppAWS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSHKeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSHKeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSHKeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = append(m.PrivateKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivateKey == nil {
				m.PrivateKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyType", wireType)
			}
			m.PrivateKeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivateKeyType |= PrivateKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSKeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TLSKeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TLSKeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= PrivateKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JWTKeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JWTKeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JWTKeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = append(m.PrivateKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivateKey == nil {
				m.PrivateKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyType", wireType)
			}
			m.PrivateKeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivateKeyType |= PrivateKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertAuthorityV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertAuthorityV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertAuthorityV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertAuthoritySpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertAuthoritySpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertAuthoritySpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = CertAuthType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleMap = append(m.RoleMap, RoleMapping{})
			if err := m.RoleMap[len(m.RoleMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rotation == nil {
				m.Rotation = &Rotation{}
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningAlg", wireType)
			}
			m.SigningAlg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigningAlg |= CertAuthoritySpecV2_SigningAlgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ActiveKeys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalTrustedKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdditionalTrustedKeys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CAKeySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CAKeySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CAKeySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSH", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSH = append(m.SSH, &SSHKeyPair{})
			if err := m.SSH[len(m.SSH)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLS = append(m.TLS, &TLSKeyPair{})
			if err := m.TLS[len(m.TLS)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWT = append(m.JWT, &JWTKeyPair{})
			if err := m.JWT[len(m.JWT)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Local = append(m.Local, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, SystemRole(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenV2List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenV2List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenV2List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisionTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisionTokens = append(m.ProvisionTokens, &ProvisionTokenV2{})
			if err := m.ProvisionTokens[len(m.ProvisionTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWSAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSRegions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWSRegions = append(m.AWSRegions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWSRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWSARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, SystemRole(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &TokenRule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSIIDTTL", wireType)
			}
			m.AWSIIDTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AWSIIDTTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinMethod = JoinMethod(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SuggestedLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GitHub == nil {
				m.GitHub = &ProvisionTokenSpecV2GitHub{}
			}
			if err := m.GitHub.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CircleCI", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CircleCI == nil {
				m.CircleCI = &ProvisionTokenSpecV2CircleCI{}
			}
			if err := m.CircleCI.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedAgentMatcherLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SuggestedAgentMatcherLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kubernetes == nil {
				m.Kubernetes = &ProvisionTokenSpecV2Kubernetes{}
			}
			if err := m.Kubernetes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Azure == nil {
				m.Azure = &ProvisionTokenSpecV2Azure{}
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitLab", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GitLab == nil {
				m.GitLab = &ProvisionTokenSpecV2GitLab{}
			}
			if err := m.GitLab.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GCP == nil {
				m.GCP = &ProvisionTokenSpecV2GCP{}
			}
			if err := m.GCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spacelift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spacelift == nil {
				m.Spacelift = &ProvisionTokenSpecV2Spacelift{}
			}
			if err := m.Spacelift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TPM == nil {
				m.TPM = &ProvisionTokenSpecV2TPM{}
			}
			if err := m.TPM.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerraformCloud", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TerraformCloud == nil {
				m.TerraformCloud = &ProvisionTokenSpecV2TerraformCloud{}
			}
			if err := m.TerraformCloud.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2TPM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2TPM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2TPM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2TPM_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EKCertAllowedCAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EKCertAllowedCAs = append(m.EKCertAllowedCAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2TPM_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EKPublicHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EKPublicHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EKCertificateSerial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EKCertificateSerial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2GitHub) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2GitHub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2GitHub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2GitHub_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterpriseServerHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterpriseServerHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterpriseSlug", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterpriseSlug = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2GitHub_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repository", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repository = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepositoryOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepositoryOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workflow", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workflow = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2GitLab) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2GitLab: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2GitLab: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2GitLab_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2GitLab_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespacePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespacePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserLogin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserLogin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefProtected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefProtected == nil {
				m.RefProtected = &BoolOption{}
			}
			if err := m.RefProtected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentProtected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvironmentProtected == nil {
				m.EnvironmentProtected = &BoolOption{}
			}
			if err := m.EnvironmentProtected.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CIConfigSHA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CIConfigSHA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CIConfigRefURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CIConfigRefURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentTier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentTier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectVisibility", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectVisibility = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2CircleCI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2CircleCI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2CircleCI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2CircleCI_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2CircleCI_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2Spacelift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2Spacelift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2Spacelift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2Spacelift_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2Spacelift_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpaceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallerType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallerType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2Kubernetes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2Kubernetes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2Kubernetes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2Kubernetes_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = KubernetesJoinType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticJWKS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StaticJWKS == nil {
				m.StaticJWKS = &ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig{}
			}
			if err := m.StaticJWKS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticJWKSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticJWKSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWKS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWKS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2Kubernetes_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2Azure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2Azure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2Azure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2Azure_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2Azure_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroups = append(m.ResourceGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2GCP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2GCP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2GCP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2GCP_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2GCP_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectIDs = append(m.ProjectIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccounts = append(m.ServiceAccounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2TerraformCloud) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2TerraformCloud: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionTokenSpecV2TerraformCloud: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, &ProvisionTokenSpecV2TerraformCloud_Rule{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audience", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audience = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionTokenSpecV2TerraformCloud_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkspaceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkspaceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkspaceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkspaceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunPhase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunPhase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticTokensV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticTokensV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticTokensV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticTokensSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticTokensSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticTokensSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticTokens = append(m.StaticTokens, ProvisionTokenV1{})
			if err := m.StaticTokens[len(m.StaticTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterNameV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterNameV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterNameV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterNameSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterNameSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterNameSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterAuditConfigV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAuditConfigV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAuditConfigV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterAuditConfigSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAuditConfigSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAuditConfigSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditSessionsURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuditSessionsURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditEventsURI", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AuditEventsURI.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableContinuousBackups", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableContinuousBackups = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAutoScaling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableAutoScaling = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMaxCapacity", wireType)
			}
			m.ReadMaxCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadMaxCapacity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMinCapacity", wireType)
			}
			m.ReadMinCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadMinCapacity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTargetValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReadTargetValue = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMaxCapacity", wireType)
			}
			m.WriteMaxCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteMaxCapacity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMinCapacity", wireType)
			}
			m.WriteMinCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteMinCapacity |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTargetValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WriteTargetValue = float64(math.Float64frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionPeriod", wireType)
			}
			m.RetentionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetentionPeriod |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseFIPSEndpoint", wireType)
			}
			m.UseFIPSEndpoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseFIPSEndpoint |= ClusterAuditConfigSpecV2_FIPSEndpointState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterNetworkingConfigV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterNetworkingConfigV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterNetworkingConfigV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterNetworkingConfigSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterNetworkingConfigSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterNetworkingConfigSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIdleTimeout", wireType)
			}
			m.ClientIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientIdleTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAliveInterval", wireType)
			}
			m.KeepAliveInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAliveInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAliveCountMax", wireType)
			}
			m.KeepAliveCountMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAliveCountMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionControlTimeout", wireType)
			}
			m.SessionControlTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionControlTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIdleTimeoutMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIdleTimeoutMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebIdleTimeout", wireType)
			}
			m.WebIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WebIdleTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyListenerMode", wireType)
			}
			m.ProxyListenerMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProxyListenerMode |= ProxyListenerMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingStrategy", wireType)
			}
			m.RoutingStrategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoutingStrategy |= RoutingStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TunnelStrategy == nil {
				m.TunnelStrategy = &TunnelStrategyV1{}
			}
			if err := m.TunnelStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyPingInterval", wireType)
			}
			m.ProxyPingInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProxyPingInterval |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssistCommandExecutionWorkers", wireType)
			}
			m.AssistCommandExecutionWorkers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssistCommandExecutionWorkers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseInsensitiveRouting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CaseInsensitiveRouting = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHDialTimeout", wireType)
			}
			m.SSHDialTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SSHDialTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelStrategyV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelStrategyV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelStrategyV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentMesh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AgentMeshTunnelStrategy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Strategy = &TunnelStrategyV1_AgentMesh{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyPeering", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProxyPeeringTunnelStrategy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Strategy = &TunnelStrategyV1_ProxyPeering{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentMeshTunnelStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentMeshTunnelStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentMeshTunnelStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProxyPeeringTunnelStrategy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProxyPeeringTunnelStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProxyPeeringTunnelStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConnectionCount", wireType)
			}
			m.AgentConnectionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentConnectionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionRecordingConfigV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionRecordingConfigV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionRecordingConfigV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionRecordingConfigSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionRecordingConfigSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionRecordingConfigSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyChecksHostKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProxyChecksHostKeys == nil {
				m.ProxyChecksHostKeys = &BoolOption{}
			}
			if err := m.ProxyChecksHostKeys.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthPreferenceV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthPreferenceV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthPreferenceV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthPreferenceSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthPreferenceSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthPreferenceSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondFactor = github_com_gravitational_teleport_api_constants.SecondFactorType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field U2F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.U2F == nil {
				m.U2F = &U2F{}
			}
			if err := m.U2F.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisconnectExpiredCert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisconnectExpiredCert == nil {
				m.DisconnectExpiredCert = &BoolOption{}
			}
			if err := m.DisconnectExpiredCert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowLocalAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowLocalAuth == nil {
				m.AllowLocalAuth = &BoolOption{}
			}
			if err := m.AllowLocalAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageOfTheDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageOfTheDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockingMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockingMode = github_com_gravitational_teleport_api_constants.LockingMode(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Webauthn == nil {
				m.Webauthn = &Webauthn{}
			}
			if err := m.Webauthn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPasswordless", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowPasswordless == nil {
				m.AllowPasswordless = &BoolOption{}
			}
			if err := m.AllowPasswordless.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireMFAType", wireType)
			}
			m.RequireMFAType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequireMFAType |= RequireMFAType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceTrust", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceTrust == nil {
				m.DeviceTrust = &DeviceTrust{}
			}
			if err := m.DeviceTrust.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IDP == nil {
				m.IDP = &IdPOptions{}
			}
			if err := m.IDP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeadless", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowHeadless == nil {
				m.AllowHeadless = &BoolOption{}
			}
			if err := m.AllowHeadless.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSessionTTL", wireType)
			}
			m.DefaultSessionTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultSessionTTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Okta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Okta == nil {
				m.Okta = &OktaOptions{}
			}
			if err := m.Okta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIVSlot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIVSlot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HardwareKey == nil {
				m.HardwareKey = &HardwareKey{}
			}
			if err := m.HardwareKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureAlgorithmSuite", wireType)
			}
			m.SignatureAlgorithmSuite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureAlgorithmSuite |= SignatureAlgorithmSuite(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *U2F) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: U2F: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: U2F: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Facets = append(m.Facets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceAttestationCAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceAttestationCAs = append(m.DeviceAttestationCAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Webauthn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Webauthn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Webauthn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RPID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationAllowedCAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationAllowedCAs = append(m.AttestationAllowedCAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationDeniedCAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationDeniedCAs = append(m.AttestationDeniedCAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceTrust) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceTrust: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceTrust: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoEnroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoEnroll = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EKCertAllowedCAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EKCertAllowedCAs = append(m.EKCertAllowedCAs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardwareKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardwareKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardwareKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PIVSlot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PIVSlot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumberValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SerialNumberValidation == nil {
				m.SerialNumberValidation = &HardwareKeySerialNumberValidation{}
			}
			if err := m.SerialNumberValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardwareKeySerialNumberValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardwareKeySerialNumberValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardwareKeySerialNumberValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumberTraitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumberTraitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTokenV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTokenV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTokenV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTokenSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTokenSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTokenSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			m.Usage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usage |= UserTokenUsage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTokenSecretsV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTokenSecretsV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTokenSecretsV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTokenSecretsSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTokenSecretsSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTokenSecretsSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OTPKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OTPKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QRCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QRCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessReviewThreshold) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessReviewThreshold: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessReviewThreshold: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approve", wireType)
			}
			m.Approve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Approve |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deny", wireType)
			}
			m.Deny = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deny |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PromotedAccessList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PromotedAccessList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PromotedAccessList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessReview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessReview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessReview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedState", wireType)
			}
			m.ProposedState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposedState |= RequestState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ThresholdIndexes = append(m.ThresholdIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ThresholdIndexes) == 0 {
					m.ThresholdIndexes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ThresholdIndexes = append(m.ThresholdIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdIndexes", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessList == nil {
				m.AccessList = &PromotedAccessList{}
			}
			if err := m.AccessList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssumeStartTime == nil {
				m.AssumeStartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.AssumeStartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessReviewSubmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessReviewSubmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessReviewSubmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Review", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Review.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdIndexSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdIndexSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdIndexSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indexes = append(m.Indexes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indexes) == 0 {
					m.Indexes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indexes = append(m.Indexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdIndexSets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdIndexSets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdIndexSets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sets = append(m.Sets, ThresholdIndexSet{})
			if err := m.Sets[len(m.Sets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RequestState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolveReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResolveAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemAnnotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SystemAnnotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thresholds = append(m.Thresholds, AccessReviewThreshold{})
			if err := m.Thresholds[len(m.Thresholds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleThresholdMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoleThresholdMapping == nil {
				m.RoleThresholdMapping = make(map[string]ThresholdIndexSets)
			}
			var mapkey string
			mapvalue := &ThresholdIndexSets{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ThresholdIndexSets{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoleThresholdMapping[mapkey] = *mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reviews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reviews = append(m.Reviews, AccessReview{})
			if err := m.Reviews[len(m.Reviews)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedReviewers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestedReviewers = append(m.SuggestedReviewers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedResourceIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedResourceIDs = append(m.RequestedResourceIDs, ResourceID{})
			if err := m.RequestedResourceIDs[len(m.RequestedResourceIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginHint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginHint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DryRun = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.MaxDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTTL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.SessionTTL, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessList == nil {
				m.AccessList = &PromotedAccessList{}
			}
			if err := m.AccessList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssumeStartTime == nil {
				m.AssumeStartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.AssumeStartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= RequestState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchKeywords = append(m.SearchKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= AccessRequestScope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestableRoles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestableRoles = append(m.RequestableRoles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedReviewers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestedReviewers = append(m.SuggestedReviewers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicableRolesForResources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicableRolesForResources = append(m.ApplicableRolesForResources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPrompt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestPrompt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireReason", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireReason = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRequest = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessCapabilitiesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessCapabilitiesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessCapabilitiesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestableRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestableRoles = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedReviewers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuggestedReviewers = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceIDs = append(m.ResourceIDs, ResourceID{})
			if err := m.ResourceIDs[len(m.ResourceIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterRequestableRolesByResource", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FilterRequestableRolesByResource = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginDataV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginDataV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginDataV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginDataEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginDataEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginDataEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginDataSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginDataSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginDataSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entries == nil {
				m.Entries = make(map[string]*PluginDataEntry)
			}
			var mapkey string
			var mapvalue *PluginDataEntry
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PluginDataEntry{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entries[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginDataFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginDataFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginDataFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plugin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginDataUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginDataUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginDataUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plugin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Set == nil {
				m.Set = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Set[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expect == nil {
				m.Expect = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Expect[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchKeywords = append(m.SearchKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipSystemRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipSystemRoles = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleV6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleV6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleV6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleSpecV6) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleSpecV6: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleSpecV6: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Allow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deny.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardAgent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForwardAgent = Bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessionTTL", wireType)
			}
			m.MaxSessionTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessionTTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortForwarding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortForwarding == nil {
				m.PortForwarding = &BoolOption{}
			}
			if err := m.PortForwarding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIdleTimeout", wireType)
			}
			m.ClientIdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientIdleTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisconnectExpiredCert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisconnectExpiredCert = Bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BPF", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BPF = append(m.BPF, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermitX11Forwarding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PermitX11Forwarding = Bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnections", wireType)
			}
			m.MaxConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnections |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessions", wireType)
			}
			m.MaxSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestAccess", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestAccess = RequestStrategy(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPrompt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestPrompt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lock = github_com_gravitational_teleport_api_constants.LockingMode(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecordSession == nil {
				m.RecordSession = &RecordSession{}
			}
			if err := m.RecordSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopClipboard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DesktopClipboard == nil {
				m.DesktopClipboard = &BoolOption{}
			}
			if err := m.DesktopClipboard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertExtensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertExtensions = append(m.CertExtensions, &CertExtension{})
			if err := m.CertExtensions[len(m.CertExtensions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxKubernetesConnections", wireType)
			}
			m.MaxKubernetesConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxKubernetesConnections |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopDirectorySharing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DesktopDirectorySharing == nil {
				m.DesktopDirectorySharing = &BoolOption{}
			}
			if err := m.DesktopDirectorySharing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateHostUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateHostUser == nil {
				m.CreateHostUser = &BoolOption{}
			}
			if err := m.CreateHostUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinSourceIP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PinSourceIP = Bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHFileCopy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SSHFileCopy == nil {
				m.SSHFileCopy = &BoolOption{}
			}
			if err := m.SSHFileCopy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireMFAType", wireType)
			}
			m.RequireMFAType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequireMFAType |= RequireMFAType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceTrustMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceTrustMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IDP == nil {
				m.IDP = &IdPOptions{}
			}
			if err := m.IDP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDesktopUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateDesktopUser == nil {
				m.CreateDesktopUser = &BoolOption{}
			}
			if err := m.CreateDesktopUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabaseUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateDatabaseUser == nil {
				m.CreateDatabaseUser = &BoolOption{}
			}
			if err := m.CreateDatabaseUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateHostUserMode", wireType)
			}
			m.CreateHostUserMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateHostUserMode |= CreateHostUserMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatabaseUserMode", wireType)
			}
			m.CreateDatabaseUserMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateDatabaseUserMode |= CreateDatabaseUserMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFAVerificationInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MFAVerificationInterval, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desktop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desktop == nil {
				m.Desktop = &BoolOption{}
			}
			if err := m.Desktop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = github_com_gravitational_teleport_api_constants.SessionRecordingMode(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSH", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSH = github_com_gravitational_teleport_api_constants.SessionRecordingMode(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertExtension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertExtension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertExtension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CertExtensionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= CertExtensionMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logins = append(m.Logins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NodeLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeGroups = append(m.KubeGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &AccessRequestConditions{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeUsers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeUsers = append(m.KubeUsers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AppLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KubernetesLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DatabaseLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseNames = append(m.DatabaseNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseUsers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseUsers = append(m.DatabaseUsers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Impersonate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Impersonate == nil {
				m.Impersonate = &ImpersonateConditions{}
			}
			if err := m.Impersonate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReviewRequests == nil {
				m.ReviewRequests = &AccessReviewConditions{}
			}
			if err := m.ReviewRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSRoleARNs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWSRoleARNs = append(m.AWSRoleARNs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopLogins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowsDesktopLogins = append(m.WindowsDesktopLogins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WindowsDesktopLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireSessionJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequireSessionJoin = append(m.RequireSessionJoin, &SessionRequirePolicy{})
			if err := m.RequireSessionJoin[len(m.RequireSessionJoin)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinSessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinSessions = append(m.JoinSessions, &SessionJoinPolicy{})
			if err := m.JoinSessions[len(m.JoinSessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostGroups = append(m.HostGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostSudoers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostSudoers = append(m.HostSudoers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureIdentities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureIdentities = append(m.AzureIdentities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesResources = append(m.KubernetesResources, KubernetesResource{})
			if err := m.KubernetesResources[len(m.KubernetesResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCPServiceAccounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GCPServiceAccounts = append(m.GCPServiceAccounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseServiceLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DatabaseServiceLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GroupLabels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesktopGroups = append(m.DesktopGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseRoles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseRoles = append(m.DatabaseRoles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseServiceLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseServiceLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowsDesktopLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupLabelsExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupLabelsExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabasePermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabasePermissions = append(m.DatabasePermissions, DatabasePermission{})
			if err := m.DatabasePermissions[len(m.DatabasePermissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPIFFE", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SPIFFE = append(m.SPIFFE, &SPIFFERoleCondition{})
			if err := m.SPIFFE[len(m.SPIFFE)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SPIFFERoleCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SPIFFERoleCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SPIFFERoleCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSSANs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSSANs = append(m.DNSSANs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPSANs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPSANs = append(m.IPSANs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabasePermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabasePermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabasePermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verbs = append(m.Verbs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionRequirePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionRequirePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionRequirePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modes = append(m.Modes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnLeave", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnLeave = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionJoinPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionJoinPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionJoinPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modes = append(m.Modes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimsToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimsToRoles = append(m.ClaimsToRoles, ClaimMapping{})
			if err := m.ClaimsToRoles[len(m.ClaimsToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thresholds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thresholds = append(m.Thresholds, AccessReviewThreshold{})
			if err := m.Thresholds[len(m.Thresholds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedReviewers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestedReviewers = append(m.SuggestedReviewers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchAsRoles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchAsRoles = append(m.SearchAsRoles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			m.MaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDuration |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessReviewConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessReviewConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessReviewConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimsToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimsToRoles = append(m.ClaimsToRoles, ClaimMapping{})
			if err := m.ClaimsToRoles[len(m.ClaimsToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewAsRoles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewAsRoles = append(m.PreviewAsRoles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestAllowedPromotion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessListName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessListName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestAllowedPromotions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Promotions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Promotions = append(m.Promotions, &AccessRequestAllowedPromotion{})
			if err := m.Promotions[len(m.Promotions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claim", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Claim = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraitMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraitMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraitMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trait", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trait = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verbs = append(m.Verbs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImpersonateConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImpersonateConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImpersonateConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Where", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Where = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchKeywords = append(m.SearchKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatusV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatusV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatusV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordState", wireType)
			}
			m.PasswordState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PasswordState |= PasswordState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCIdentities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OIDCIdentities = append(m.OIDCIdentities, ExternalIdentity{})
			if err := m.OIDCIdentities[len(m.OIDCIdentities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLIdentities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SAMLIdentities = append(m.SAMLIdentities, ExternalIdentity{})
			if err := m.SAMLIdentities[len(m.SAMLIdentities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubIdentities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GithubIdentities = append(m.GithubIdentities, ExternalIdentity{})
			if err := m.GithubIdentities[len(m.GithubIdentities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Traits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAuth == nil {
				m.LocalAuth = &LocalAuthSecrets{}
			}
			if err := m.LocalAuth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedDeviceIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedDeviceIDs = append(m.TrustedDeviceIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLSingleLogoutURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SAMLSingleLogoutURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocked = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockedMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LockedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockExpires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LockExpires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatedBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatedBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatedBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &ConnectorRef{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalAuthSecrets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalAuthSecrets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalAuthSecrets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PasswordHash = append(m.PasswordHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PasswordHash == nil {
				m.PasswordHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOTPKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TOTPKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFA", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MFA = append(m.MFA, &MFADevice{})
			if err := m.MFA[len(m.MFA)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Webauthn == nil {
				m.Webauthn = &WebauthnLocalAuth{}
			}
			if err := m.Webauthn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFADevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFADevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFADevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.AddedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUsed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUsed, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TOTPDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Device = &MFADevice_Totp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field U2F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &U2FDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Device = &MFADevice_U2F{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WebauthnDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Device = &MFADevice_Webauthn{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TOTPDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TOTPDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TOTPDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *U2FDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: U2FDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: U2FDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyHandle = append(m.KeyHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyHandle == nil {
				m.KeyHandle = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebauthnDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebauthnDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebauthnDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = append(m.CredentialId[:0], dAtA[iNdEx:postIndex]...)
			if m.CredentialId == nil {
				m.CredentialId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyCbor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyCbor = append(m.PublicKeyCbor[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeyCbor == nil {
				m.PublicKeyCbor = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aaguid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aaguid = append(m.Aaguid[:0], dAtA[iNdEx:postIndex]...)
			if m.Aaguid == nil {
				m.Aaguid = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureCounter", wireType)
			}
			m.SignatureCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureCounter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationObject", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationObject = append(m.AttestationObject[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationObject == nil {
				m.AttestationObject = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidentKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResidentKey = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialRpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialRpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialBackupEligible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CredentialBackupEligible == nil {
				m.CredentialBackupEligible = &types.BoolValue{}
			}
			if err := m.CredentialBackupEligible.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialBackedUp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CredentialBackedUp == nil {
				m.CredentialBackedUp = &types.BoolValue{}
			}
			if err := m.CredentialBackedUp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebauthnLocalAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebauthnLocalAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebauthnLocalAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = append(m.UserID[:0], dAtA[iNdEx:postIndex]...)
			if m.UserID == nil {
				m.UserID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectorRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectorRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectorRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReverseTunnelV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReverseTunnelV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReverseTunnelV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReverseTunnelSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReverseTunnelSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReverseTunnelSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialAddrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DialAddrs = append(m.DialAddrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = TunnelType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelConnectionV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelConnectionV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelConnectionV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelConnectionSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelConnectionSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelConnectionSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastHeartbeat, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = TunnelType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemaphoreKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemaphoreKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemaphoreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemaphoreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcquireSemaphoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcquireSemaphoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcquireSemaphoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemaphoreKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemaphoreKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemaphoreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemaphoreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeases", wireType)
			}
			m.MaxLeases = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeases |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreLease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreLease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreLease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemaphoreKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemaphoreKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemaphoreName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemaphoreName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreLeaseRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreLeaseRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreLeaseRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SemaphoreSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SemaphoreSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SemaphoreSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leases = append(m.Leases, SemaphoreLeaseRef{})
			if err := m.Leases[len(m.Leases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSessionV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSessionV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSessionV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSessionSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSessionSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSessionSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pub", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pub = append(m.Pub[:0], dAtA[iNdEx:postIndex]...)
			if m.Pub == nil {
				m.Pub = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Priv = append(m.Priv[:0], dAtA[iNdEx:postIndex]...)
			if m.Priv == nil {
				m.Priv = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSCert = append(m.TLSCert[:0], dAtA[iNdEx:postIndex]...)
			if m.TLSCert == nil {
				m.TLSCert = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BearerToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerTokenExpires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.BearerTokenExpires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LoginTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdleTimeout", wireType)
			}
			m.IdleTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdleTimeout |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumedAccessRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumedAccessRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SAMLSession == nil {
				m.SAMLSession = &SAMLSessionData{}
			}
			if err := m.SAMLSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceWebToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceWebToken == nil {
				m.DeviceWebToken = &DeviceWebToken{}
			}
			if err := m.DeviceWebToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasDeviceExtensions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasDeviceExtensions = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedDeviceRequirement", wireType)
			}
			m.TrustedDeviceRequirement = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustedDeviceRequirement |= TrustedDeviceRequirement(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSPriv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSPriv = append(m.TLSPriv[:0], dAtA[iNdEx:postIndex]...)
			if m.TLSPriv == nil {
				m.TLSPriv = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceWebToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceWebToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceWebToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSessionFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSessionFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSessionFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLSessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLSessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLSessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ExpireTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameIDFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameIDFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCommonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserCommonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSurname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserSurname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGivenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGivenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScopedAffiliation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserScopedAffiliation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomAttributes = append(m.CustomAttributes, &SAMLAttribute{})
			if err := m.CustomAttributes[len(m.CustomAttributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLAttribute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLAttribute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLAttribute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendlyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FriendlyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &SAMLAttributeValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLAttributeValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLAttributeValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLAttributeValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameID == nil {
				m.NameID = &SAMLNameID{}
			}
			if err := m.NameID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLNameID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLNameID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLNameID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameQualifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameQualifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPNameQualifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SPNameQualifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPProvidedID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SPProvidedID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteClusterV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteClusterV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteClusterV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteClusterStatusV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteClusterStatusV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteClusterStatusV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connection", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connection = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastHeartbeat, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StaticLabels == nil {
				m.StaticLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StaticLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicLabels == nil {
				m.DynamicLabels = make(map[string]CommandLabelV2)
			}
			var mapkey string
			mapvalue := &CommandLabelV2{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLabelV2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DynamicLabels[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesClusterV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesClusterV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesClusterV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesClusterSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesClusterSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesClusterSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicLabels == nil {
				m.DynamicLabels = make(map[string]CommandLabelV2)
			}
			var mapkey string
			mapvalue := &CommandLabelV2{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLabelV2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DynamicLabels[mapkey] = *mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubeconfig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kubeconfig = append(m.Kubeconfig[:0], dAtA[iNdEx:postIndex]...)
			if m.Kubeconfig == nil {
				m.Kubeconfig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubeAzure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubeAzure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubeAzure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubeAWS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubeAWS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubeAWS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubeGCP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubeGCP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubeGCP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesClusterV3List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesClusterV3List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesClusterV3List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesClusters = append(m.KubernetesClusters, &KubernetesClusterV3{})
			if err := m.KubernetesClusters[len(m.KubernetesClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesServerV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesServerV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesServerV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesServerSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesServerSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesServerSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &KubernetesClusterV3{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyIDs = append(m.ProxyIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebTokenV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebTokenV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebTokenV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebTokenSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebTokenSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebTokenSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWebSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWebSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWebSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteWebSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteWebSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteWebSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWebTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWebTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWebTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteWebTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteWebTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteWebTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceWithSecretsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceWithSecretsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceWithSecretsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSecrets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithSecrets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcesWithSecretsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcesWithSecretsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcesWithSecretsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSecrets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithSecrets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceInNamespaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceInNamespaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceInNamespaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcesInNamespaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcesInNamespaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcesInNamespaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCConnectorV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCConnectorV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCConnectorV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCConnectorV3List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCConnectorV3List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCConnectorV3List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OIDCConnectors = append(m.OIDCConnectors, &OIDCConnectorV3{})
			if err := m.OIDCConnectors[len(m.OIDCConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCConnectorSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCConnectorSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCConnectorSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuerURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssuerURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ACR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Display = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = append(m.Scope, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prompt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prompt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimsToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimsToRoles = append(m.ClaimsToRoles, ClaimMapping{})
			if err := m.ClaimsToRoles[len(m.ClaimsToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoogleServiceAccountURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoogleServiceAccountURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoogleServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoogleServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoogleAdminEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoogleAdminEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURLs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedirectURLs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowUnverifiedEmail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowUnverifiedEmail = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsernameClaim", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsernameClaim = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxAge == nil {
				m.MaxAge = &MaxAge{}
			}
			if err := m.MaxAge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRedirectSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRedirectSettings == nil {
				m.ClientRedirectSettings = &SSOClientRedirectSettings{}
			}
			if err := m.ClientRedirectSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxAge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxAge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxAge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSOClientRedirectSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSOClientRedirectSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSOClientRedirectSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedHttpsHostnames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedHttpsHostnames = append(m.AllowedHttpsHostnames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureAllowedCidrRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsecureAllowedCidrRanges = append(m.InsecureAllowedCidrRanges, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OIDCAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDCAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDCAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckUser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckUser = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSRFToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CSRFToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertTTL", wireType)
			}
			m.CertTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertTTL |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWebSession", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateWebSession = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientRedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compatibility", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compatibility = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteToCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteToCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSOTestFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SSOTestFlow = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectorSpec == nil {
				m.ConnectorSpec = &OIDCConnectorSpecV3{}
			}
			if err := m.ConnectorSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttestationStatement == nil {
				m.AttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.AttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLoginIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientLoginIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientUserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshPublicKey = append(m.SshPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SshPublicKey == nil {
				m.SshPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsPublicKey = append(m.TlsPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TlsPublicKey == nil {
				m.TlsPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SshAttestationStatement == nil {
				m.SshAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.SshAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsAttestationStatement == nil {
				m.TlsAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.TlsAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLConnectorV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLConnectorV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLConnectorV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLConnectorV2List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLConnectorV2List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLConnectorV2List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SAMLConnectors = append(m.SAMLConnectors, &SAMLConnectorV2{})
			if err := m.SAMLConnectors[len(m.SAMLConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLConnectorSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLConnectorSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLConnectorSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Display = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionConsumerService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssertionConsumerService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audience", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audience = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderIssuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProviderIssuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityDescriptor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityDescriptor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityDescriptorURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityDescriptorURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributesToRoles = append(m.AttributesToRoles, AttributeMapping{})
			if err := m.AttributesToRoles[len(m.AttributesToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningKeyPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningKeyPair == nil {
				m.SigningKeyPair = &AsymmetricKeyPair{}
			}
			if err := m.SigningKeyPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeyPair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptionKeyPair == nil {
				m.EncryptionKeyPair = &AsymmetricKeyPair{}
			}
			if err := m.EncryptionKeyPair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowIDPInitiated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowIDPInitiated = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRedirectSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRedirectSettings == nil {
				m.ClientRedirectSettings = &SSOClientRedirectSettings{}
			}
			if err := m.ClientRedirectSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleLogoutURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SingleLogoutURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckUser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckUser = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertTTL", wireType)
			}
			m.CertTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertTTL |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSRFToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CSRFToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWebSession", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateWebSession = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientRedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compatibility", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compatibility = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteToCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteToCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSOTestFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SSOTestFlow = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectorSpec == nil {
				m.ConnectorSpec = &SAMLConnectorSpecV2{}
			}
			if err := m.ConnectorSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttestationStatement == nil {
				m.AttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.AttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLoginIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientLoginIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientUserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshPublicKey = append(m.SshPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SshPublicKey == nil {
				m.SshPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsPublicKey = append(m.TlsPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TlsPublicKey == nil {
				m.TlsPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SshAttestationStatement == nil {
				m.SshAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.SshAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsAttestationStatement == nil {
				m.TlsAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.TlsAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsymmetricKeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsymmetricKeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsymmetricKeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubConnectorV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubConnectorV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubConnectorV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubConnectorV3List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubConnectorV3List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubConnectorV3List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubConnectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GithubConnectors = append(m.GithubConnectors, &GithubConnectorV3{})
			if err := m.GithubConnectors[len(m.GithubConnectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubConnectorSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubConnectorSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubConnectorSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamsToLogins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeamsToLogins = append(m.TeamsToLogins, TeamMapping{})
			if err := m.TeamsToLogins[len(m.TeamsToLogins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Display", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Display = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamsToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeamsToRoles = append(m.TeamsToRoles, TeamRolesMapping{})
			if err := m.TeamsToRoles[len(m.TeamsToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIEndpointURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIEndpointURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRedirectSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientRedirectSettings == nil {
				m.ClientRedirectSettings = &SSOClientRedirectSettings{}
			}
			if err := m.ClientRedirectSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSRFToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CSRFToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertTTL", wireType)
			}
			m.CertTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertTTL |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWebSession", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateWebSession = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientRedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compatibility", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Compatibility = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expires == nil {
				m.Expires = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteToCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteToCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSOTestFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SSOTestFlow = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectorSpec == nil {
				m.ConnectorSpec = &GithubConnectorSpecV3{}
			}
			if err := m.ConnectorSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttestationStatement == nil {
				m.AttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.AttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientLoginIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientLoginIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientUserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientUserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshPublicKey = append(m.SshPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SshPublicKey == nil {
				m.SshPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsPublicKey = append(m.TlsPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TlsPublicKey == nil {
				m.TlsPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SshAttestationStatement == nil {
				m.SshAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.SshAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsAttestationStatement == nil {
				m.TlsAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.TlsAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSOWarnings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSOWarnings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSOWarnings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warnings = append(m.Warnings, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logins = append(m.Logins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeGroups = append(m.KubeGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeUsers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeUsers = append(m.KubeUsers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Traits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTTL", wireType)
			}
			m.SessionTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionTTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSODiagnosticInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSODiagnosticInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSODiagnosticInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestFlow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TestFlow = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateUserParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateUserParams == nil {
				m.CreateUserParams = &CreateUserParams{}
			}
			if err := m.CreateUserParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLAttributesToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SAMLAttributesToRoles = append(m.SAMLAttributesToRoles, AttributeMapping{})
			if err := m.SAMLAttributesToRoles[len(m.SAMLAttributesToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLAttributesToRolesWarnings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SAMLAttributesToRolesWarnings == nil {
				m.SAMLAttributesToRolesWarnings = &SSOWarnings{}
			}
			if err := m.SAMLAttributesToRolesWarnings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLAttributeStatements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SAMLAttributeStatements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLAssertionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SAMLAssertionInfo == nil {
				m.SAMLAssertionInfo = &AssertionInfo{}
			}
			if err := m.SAMLAssertionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLTraitsFromAssertions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SAMLTraitsFromAssertions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLConnectorTraitMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SAMLConnectorTraitMapping = append(m.SAMLConnectorTraitMapping, TraitMapping{})
			if err := m.SAMLConnectorTraitMapping[len(m.SAMLConnectorTraitMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCClaimsToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OIDCClaimsToRoles = append(m.OIDCClaimsToRoles, ClaimMapping{})
			if err := m.OIDCClaimsToRoles[len(m.OIDCClaimsToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCClaimsToRolesWarnings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OIDCClaimsToRolesWarnings == nil {
				m.OIDCClaimsToRolesWarnings = &SSOWarnings{}
			}
			if err := m.OIDCClaimsToRolesWarnings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCClaims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OIDCClaims.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OIDCIdentity == nil {
				m.OIDCIdentity = &OIDCIdentity{}
			}
			if err := m.OIDCIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCTraitsFromClaims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OIDCTraitsFromClaims.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDCConnectorTraitMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OIDCConnectorTraitMapping = append(m.OIDCConnectorTraitMapping, TraitMapping{})
			if err := m.OIDCConnectorTraitMapping[len(m.OIDCConnectorTraitMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubClaims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GithubClaims == nil {
				m.GithubClaims = &GithubClaims{}
			}
			if err := m.GithubClaims.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubTeamsToLogins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GithubTeamsToLogins = append(m.GithubTeamsToLogins, TeamMapping{})
			if err := m.GithubTeamsToLogins[len(m.GithubTeamsToLogins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubTeamsToRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GithubTeamsToRoles = append(m.GithubTeamsToRoles, TeamRolesMapping{})
			if err := m.GithubTeamsToRoles[len(m.GithubTeamsToRoles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubTokenInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GithubTokenInfo == nil {
				m.GithubTokenInfo = &GithubTokenInfo{}
			}
			if err := m.GithubTokenInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedLoginRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppliedLoginRules = append(m.AppliedLoginRules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GithubClaims) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GithubClaims: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GithubClaims: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationToTeams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrganizationToTeams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Teams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Teams = append(m.Teams, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Team = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logins = append(m.Logins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeGroups = append(m.KubeGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeUsers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeUsers = append(m.KubeUsers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamRolesMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamRolesMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamRolesMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Organization", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Organization = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Team = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustedClusterV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustedClusterV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustedClusterV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustedClusterV2List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustedClusterV2List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustedClusterV2List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedClusters = append(m.TrustedClusters, &TrustedClusterV2{})
			if err := m.TrustedClusters[len(m.TrustedClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustedClusterSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustedClusterSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustedClusterSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseTunnelAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReverseTunnelAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleMap = append(m.RoleMap, RoleMapping{})
			if err := m.RoleMap[len(m.RoleMap)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockSpecV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockSpecV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockSpecV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expires == nil {
				m.Expires = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFADevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MFADevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowsDesktop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessRequest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessRequest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CIDR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CIDR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRestrictionsSpecV4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkRestrictionsSpecV4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkRestrictionsSpecV4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allow = append(m.Allow, AddressCondition{})
			if err := m.Allow[len(m.Allow)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deny = append(m.Deny, AddressCondition{})
			if err := m.Deny[len(m.Deny)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRestrictionsV4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkRestrictionsV4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkRestrictionsV4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsDesktopServiceV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsDesktopServiceV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsDesktopServiceV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsDesktopServiceSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsDesktopServiceSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsDesktopServiceSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeleportVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeleportVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyIDs = append(m.ProxyIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsDesktopFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsDesktopFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsDesktopFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsDesktopV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsDesktopV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsDesktopV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsDesktopSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsDesktopSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsDesktopSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonAD", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonAD = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScreenSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScreenSize == nil {
				m.ScreenSize = &Resolution{}
			}
			if err := m.ScreenSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resolution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resolution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resolution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterUsingTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterUsingTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterUsingTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = SystemRole(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalPrincipals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalPrincipals = append(m.AdditionalPrincipals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSNames = append(m.DNSNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicTLSKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicTLSKey = append(m.PublicTLSKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicTLSKey == nil {
				m.PublicTLSKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSSHKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicSSHKey = append(m.PublicSSHKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicSSHKey == nil {
				m.PublicSSHKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EC2IdentityDocument", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EC2IdentityDocument = append(m.EC2IdentityDocument[:0], dAtA[iNdEx:postIndex]...)
			if m.EC2IdentityDocument == nil {
				m.EC2IdentityDocument = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expires == nil {
				m.Expires = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotInstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotInstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotGeneration", wireType)
			}
			m.BotGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotGeneration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCodesV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCodesV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCodesV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCodesSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCodesSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCodesSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codes = append(m.Codes, RecoveryCode{})
			if err := m.Codes[len(m.Codes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashedCode", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashedCode = append(m.HashedCode[:0], dAtA[iNdEx:postIndex]...)
			if m.HashedCode == nil {
				m.HashedCode = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUsed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUsed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullableSessionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableSessionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableSessionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SessionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &NullableSessionState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesktopName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= SessionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachedData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachedData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invited", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invited = append(m.Invited, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, Participant{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPolicies = append(m.HostPolicies, &SessionTrackerPolicySet{})
			if err := m.HostPolicies[len(m.HostPolicies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatabaseName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppSessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppSessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesktopName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetSubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetSubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialCommand = append(m.InitialCommand, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerPolicySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerPolicySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerPolicySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireSessionJoin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequireSessionJoin = append(m.RequireSessionJoin, &SessionRequirePolicy{})
			if err := m.RequireSessionJoin[len(m.RequireSessionJoin)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Participant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Participant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Participant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastActive, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UIConfigV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UIConfigV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UIConfigV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UIConfigSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UIConfigSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UIConfigSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollbackLines", wireType)
			}
			m.ScrollbackLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScrollbackLines |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowResources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShowResources = github_com_gravitational_teleport_api_constants.ShowResources(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerV1List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerV1List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerV1List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Installers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Installers = append(m.Installers, &InstallerV1{})
			if err := m.Installers[len(m.Installers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SortBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDesc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDesc = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionDiagnosticV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionDiagnosticV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionDiagnosticV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionDiagnosticSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionDiagnosticSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionDiagnosticSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Traces = append(m.Traces, &ConnectionDiagnosticTrace{})
			if err := m.Traces[len(m.Traces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionDiagnosticTrace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionDiagnosticTrace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionDiagnosticTrace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConnectionDiagnosticTrace_TraceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ConnectionDiagnosticTrace_StatusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseServiceV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseServiceV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseServiceV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseServiceSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseServiceSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseServiceSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMatchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceMatchers = append(m.ResourceMatchers, &DatabaseResourceMatcher{})
			if err := m.ResourceMatchers[len(m.ResourceMatchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseResourceMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseResourceMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseResourceMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &Labels{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceMatcherAWS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceMatcherAWS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceMatcherAWS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeRoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssumeRoleARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterAlert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAlert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAlert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterAlertSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterAlertSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterAlertSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= AlertSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterAlertsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterAlertsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterAlertsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= AlertSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSuperseded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithSuperseded = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithAcknowledged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithAcknowledged = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithUntargeted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithUntargeted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertAcknowledgement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertAcknowledgement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertAcknowledgement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Release) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Release: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Release: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotesMD", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotesMD = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &Asset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Asset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SHA256", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SHA256 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetSize", wireType)
			}
			m.AssetSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplaySize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplaySize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseIDs = append(m.ReleaseIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &PluginCredentialsV1{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlackAccessPlugin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginSlackAccessSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_SlackAccessPlugin{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opsgenie", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginOpsgenieAccessSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Opsgenie{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Openai", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginOpenAISettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Openai{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Okta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginOktaSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Okta{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jamf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginJamfSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Jamf{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PagerDuty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginPagerDutySettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_PagerDuty{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mattermost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginMattermostSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Mattermost{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jira", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginJiraSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Jira{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginDiscordSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Discord{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceNow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginServiceNowSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_ServiceNow{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Generation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gitlab", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginGitlabSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Gitlab{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntraId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginEntraIDSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_EntraId{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scim", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginSCIMSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Settings = &PluginSpecV1_Scim{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginSlackAccessSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginSlackAccessSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginSlackAccessSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FallbackChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginGitlabSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginGitlabSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginGitlabSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOpsgenieAccessSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOpsgenieAccessSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOpsgenieAccessSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Priority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertTags = append(m.AlertTags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSchedules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultSchedules = append(m.DefaultSchedules, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginServiceNowSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginServiceNowSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginServiceNowSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloseCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginPagerDutySettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginPagerDutySettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginPagerDutySettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginJiraSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginJiraSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginJiraSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOpenAISettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOpenAISettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOpenAISettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginMattermostSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginMattermostSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginMattermostSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Team", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Team = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportToEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportToEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginJamfSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginJamfSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginJamfSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JamfSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JamfSpec == nil {
				m.JamfSpec = &JamfSpecV1{}
			}
			if err := m.JamfSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableUserSync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableUserSync = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsoConnectorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SsoConnectorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncSettings == nil {
				m.SyncSettings = &PluginOktaSyncSettings{}
			}
			if err := m.SyncSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaSyncSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaSyncSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaSyncSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncUsers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncUsers = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsoConnectorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SsoConnectorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncAccessLists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncAccessLists = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOwners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultOwners = append(m.DefaultOwners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupFilters = append(m.GroupFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFilters = append(m.AppFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscordChannels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscordChannels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscordChannels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelIds = append(m.ChannelIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginDiscordSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginDiscordSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginDiscordSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleToRecipients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoleToRecipients == nil {
				m.RoleToRecipients = make(map[string]*DiscordChannels)
			}
			var mapkey string
			var mapvalue *DiscordChannels
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DiscordChannels{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RoleToRecipients[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginEntraIDSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginEntraIDSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginEntraIDSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncSettings == nil {
				m.SyncSettings = &PluginEntraIDSyncSettings{}
			}
			if err := m.SyncSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessGraphSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessGraphSettings == nil {
				m.AccessGraphSettings = &PluginEntraIDAccessGraphSettings{}
			}
			if err := m.AccessGraphSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginEntraIDSyncSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginEntraIDSyncSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginEntraIDSyncSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOwners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultOwners = append(m.DefaultOwners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsoConnectorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SsoConnectorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginEntraIDAccessGraphSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginEntraIDAccessGraphSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginEntraIDAccessGraphSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppSsoSettingsCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppSsoSettingsCache = append(m.AppSsoSettingsCache, &PluginEntraIDAppSSOSettings{})
			if err := m.AppSsoSettingsCache[len(m.AppSsoSettingsCache)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginEntraIDAppSSOSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginEntraIDAppSSOSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginEntraIDAppSSOSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederatedSsoV2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederatedSsoV2 = append(m.FederatedSsoV2[:0], dAtA[iNdEx:postIndex]...)
			if m.FederatedSsoV2 == nil {
				m.FederatedSsoV2 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginSCIMSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginSCIMSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginSCIMSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamlConnectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SamlConnectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultRole = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginBootstrapCredentialsV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginBootstrapCredentialsV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginBootstrapCredentialsV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2AuthorizationCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginOAuth2AuthorizationCodeCredentials{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginBootstrapCredentialsV1_Oauth2AuthorizationCode{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginBearerTokenCredentials{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginBootstrapCredentialsV1_BearerToken{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginIdSecretCredential{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginBootstrapCredentialsV1_IdSecret{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginIdSecretCredential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginIdSecretCredential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginIdSecretCredential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOAuth2AuthorizationCodeCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOAuth2AuthorizationCodeCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOAuth2AuthorizationCodeCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizationCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginStatusV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginStatusV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginStatusV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= PluginStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSyncTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastSyncTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gitlab", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginGitlabStatusV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &PluginStatusV1_Gitlab{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntraId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginEntraIDStatusV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &PluginStatusV1_EntraId{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRawError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastRawError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Okta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginOktaStatusV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Details = &PluginStatusV1_Okta{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginGitlabStatusV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginGitlabStatusV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginGitlabStatusV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportedUsers", wireType)
			}
			m.ImportedUsers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImportedUsers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportedGroups", wireType)
			}
			m.ImportedGroups = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImportedGroups |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportedProjects", wireType)
			}
			m.ImportedProjects = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImportedProjects |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginEntraIDStatusV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginEntraIDStatusV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginEntraIDStatusV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportedUsers", wireType)
			}
			m.ImportedUsers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImportedUsers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportedGroups", wireType)
			}
			m.ImportedGroups = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImportedGroups |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaStatusV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaStatusV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaStatusV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsoDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SsoDetails == nil {
				m.SsoDetails = &PluginOktaStatusDetailsSSO{}
			}
			if err := m.SsoDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppGroupSyncDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppGroupSyncDetails == nil {
				m.AppGroupSyncDetails = &PluginOktaStatusDetailsAppGroupSync{}
			}
			if err := m.AppGroupSyncDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsersSyncDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsersSyncDetails == nil {
				m.UsersSyncDetails = &PluginOktaStatusDetailsUsersSync{}
			}
			if err := m.UsersSyncDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScimDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScimDetails == nil {
				m.ScimDetails = &PluginOktaStatusDetailsSCIM{}
			}
			if err := m.ScimDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessListsSyncDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessListsSyncDetails == nil {
				m.AccessListsSyncDetails = &PluginOktaStatusDetailsAccessListsSync{}
			}
			if err := m.AccessListsSyncDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaStatusDetailsSSO) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsSSO: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsSSO: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaStatusDetailsAppGroupSync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsAppGroupSync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsAppGroupSync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= OktaPluginSyncStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessful", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSuccessful == nil {
				m.LastSuccessful = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastSuccessful, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastFailed == nil {
				m.LastFailed = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastFailed, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAppsSynced", wireType)
			}
			m.NumAppsSynced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAppsSynced |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumGroupsSynced", wireType)
			}
			m.NumGroupsSynced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumGroupsSynced |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaStatusDetailsUsersSync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsUsersSync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsUsersSync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= OktaPluginSyncStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessful", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSuccessful == nil {
				m.LastSuccessful = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastSuccessful, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastFailed == nil {
				m.LastFailed = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastFailed, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumUsersSynced", wireType)
			}
			m.NumUsersSynced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumUsersSynced |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaStatusDetailsSCIM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsSCIM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsSCIM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOktaStatusDetailsAccessListsSync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsAccessListsSync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOktaStatusDetailsAccessListsSync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= OktaPluginSyncStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccessful", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSuccessful == nil {
				m.LastSuccessful = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastSuccessful, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastFailed == nil {
				m.LastFailed = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.LastFailed, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFilters = append(m.AppFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAppsSynced", wireType)
			}
			m.NumAppsSynced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAppsSynced |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupFilters = append(m.GroupFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumGroupsSynced", wireType)
			}
			m.NumGroupsSynced = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumGroupsSynced |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginCredentialsV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginCredentialsV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginCredentialsV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oauth2AccessToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginOAuth2AccessTokenCredentials{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginCredentialsV1_Oauth2AccessToken{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginBearerTokenCredentials{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginCredentialsV1_BearerToken{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginIdSecretCredential{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginCredentialsV1_IdSecret{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticCredentialsRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginStaticCredentialsRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginCredentialsV1_StaticCredentialsRef{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginOAuth2AccessTokenCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginOAuth2AccessTokenCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginOAuth2AccessTokenCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginBearerTokenCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginBearerTokenCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginBearerTokenCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginStaticCredentialsRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginStaticCredentialsRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginStaticCredentialsRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginListV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginListV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginListV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plugins = append(m.Plugins, &PluginV1{})
			if err := m.Plugins[len(m.Plugins)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginStaticCredentialsV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginStaticCredentialsV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginStaticCredentialsV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PluginStaticCredentialsSpecV1{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginStaticCredentialsSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginStaticCredentialsSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginStaticCredentialsSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credentials = &PluginStaticCredentialsSpecV1_APIToken{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginStaticCredentialsBasicAuth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginStaticCredentialsSpecV1_BasicAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OAuthClientSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PluginStaticCredentialsOAuthClientSecret{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Credentials = &PluginStaticCredentialsSpecV1_OAuthClientSecret{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginStaticCredentialsBasicAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginStaticCredentialsBasicAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginStaticCredentialsBasicAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginStaticCredentialsOAuthClientSecret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginStaticCredentialsOAuthClientSecret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginStaticCredentialsOAuthClientSecret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLIdPServiceProviderV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLIdPServiceProviderV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLIdPServiceProviderV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLIdPServiceProviderSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLIdPServiceProviderSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLIdPServiceProviderSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityDescriptor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityDescriptor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntityID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACSURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ACSURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeMapping = append(m.AttributeMapping, &SAMLAttributeMapping{})
			if err := m.AttributeMapping[len(m.AttributeMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Preset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SAMLAttributeMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SAMLAttributeMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SAMLAttributeMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdPOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdPOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdPOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAML", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SAML == nil {
				m.SAML = &IdPSAMLOptions{}
			}
			if err := m.SAML.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdPSAMLOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdPSAMLOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdPSAMLOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Enabled == nil {
				m.Enabled = &BoolOption{}
			}
			if err := m.Enabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourceV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesResourceV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesResourceV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourceSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesResourceSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesResourceSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterMaintenanceConfigV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterMaintenanceConfigV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterMaintenanceConfigV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterMaintenanceConfigSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterMaintenanceConfigSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterMaintenanceConfigSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentUpgrades", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AgentUpgrades == nil {
				m.AgentUpgrades = &AgentUpgradeWindow{}
			}
			if err := m.AgentUpgrades.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentUpgradeWindow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentUpgradeWindow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentUpgradeWindow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UTCStartHour", wireType)
			}
			m.UTCStartHour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UTCStartHour |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weekdays", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weekdays = append(m.Weekdays, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduledAgentUpgradeWindow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduledAgentUpgradeWindow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduledAgentUpgradeWindow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Stop, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentUpgradeSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentUpgradeSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentUpgradeSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Windows = append(m.Windows, ScheduledAgentUpgradeWindow{})
			if err := m.Windows[len(m.Windows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserGroupV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserGroupV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserGroupV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserGroupSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserGroupSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserGroupSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applications", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Applications = append(m.Applications, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaImportRuleSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaImportRuleSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaImportRuleSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mappings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mappings = append(m.Mappings, &OktaImportRuleMappingV1{})
			if err := m.Mappings[len(m.Mappings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaImportRuleMappingV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaImportRuleMappingV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaImportRuleMappingV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &OktaImportRuleMatchV1{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddLabels == nil {
				m.AddLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AddLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaImportRuleV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaImportRuleV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaImportRuleV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaImportRuleMatchV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaImportRuleMatchV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaImportRuleMatchV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppIDs = append(m.AppIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupIDs = append(m.GroupIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppNameRegexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppNameRegexes = append(m.AppNameRegexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNameRegexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupNameRegexes = append(m.GroupNameRegexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaAssignmentV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaAssignmentV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaAssignmentV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaAssignmentSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaAssignmentSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaAssignmentSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &OktaAssignmentTargetV1{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanupTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CleanupTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= OktaAssignmentSpecV1_OktaAssignmentStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastTransition, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaAssignmentTargetV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaAssignmentTargetV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaAssignmentTargetV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OktaAssignmentTargetV1_OktaAssignmentTargetType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegrationV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegrationV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegrationV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntegrationSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntegrationSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntegrationSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSOIDC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSOIDCIntegrationSpecV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SubKindSpec = &IntegrationSpecV1_AWSOIDC{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureOIDC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureOIDCIntegrationSpecV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SubKindSpec = &IntegrationSpecV1_AzureOIDC{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSOIDCIntegrationSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSOIDCIntegrationSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSOIDCIntegrationSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuerS3URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssuerS3URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureOIDCIntegrationSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureOIDCIntegrationSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureOIDCIntegrationSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TenantID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeadlessAuthentication) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeadlessAuthentication: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeadlessAuthentication: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= HeadlessAuthenticationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MfaDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MfaDevice == nil {
				m.MfaDevice = &MFADevice{}
			}
			if err := m.MfaDevice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshPublicKey = append(m.SshPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SshPublicKey == nil {
				m.SshPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsPublicKey = append(m.TlsPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TlsPublicKey == nil {
				m.TlsPublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchKind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchKind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchKind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadSecrets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadSecrets = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Filter[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchStatusV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchStatusV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchStatusV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchStatusSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchStatusSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchStatusSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, WatchKind{})
			if err := m.Kinds[len(m.Kinds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerInfoSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerInfoSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerInfoSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewLabels == nil {
				m.NewLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NewLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JamfSpecV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JamfSpecV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JamfSpecV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncDelay", wireType)
			}
			m.SyncDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncDelay |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inventory = append(m.Inventory, &JamfInventoryEntry{})
			if err := m.Inventory[len(m.Inventory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JamfInventoryEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JamfInventoryEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JamfInventoryEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterRsql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterRsql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncPeriodPartial", wireType)
			}
			m.SyncPeriodPartial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncPeriodPartial |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncPeriodFull", wireType)
			}
			m.SyncPeriodFull = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncPeriodFull |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnMissing", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OnMissing = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageWithHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageWithHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageWithHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssumeRole == nil {
				m.AssumeRole = &AssumeRole{}
			}
			if err := m.AssumeRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &InstallerParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSM", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SSM == nil {
				m.SSM = &AWSSSM{}
			}
			if err := m.SSM.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Integration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeAppDiscovery", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KubeAppDiscovery = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetupAccessForARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetupAccessForARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssumeRole) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssumeRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssumeRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallerParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallerParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallerParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinMethod = JoinMethod(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallTeleport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InstallTeleport = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHDConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHDConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicProxyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicProxyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Azure == nil {
				m.Azure = &AzureInstallerParams{}
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnrollMode", wireType)
			}
			m.EnrollMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnrollMode |= InstallParamEnrollMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSSM) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSSM: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSSM: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocumentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureInstallerParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureInstallerParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureInstallerParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroups = append(m.ResourceGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceTags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &InstallerParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectIDs = append(m.ProjectIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccounts = append(m.ServiceAccounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &InstallerParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Types = append(m.Types, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OktaOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OktaOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OktaOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncPeriod", wireType)
			}
			m.SyncPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncPeriod |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessGraphSync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessGraphSync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessGraphSync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWS = append(m.AWS, &AccessGraphAWSSync{})
			if err := m.AWS[len(m.AWS)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessGraphAWSSync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessGraphAWSSync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessGraphAWSSync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeRole", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssumeRole == nil {
				m.AssumeRole = &AssumeRole{}
			}
			if err := m.AssumeRole.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Integration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
