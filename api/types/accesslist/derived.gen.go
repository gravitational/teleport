// Code generated by goderive DO NOT EDIT.

package accesslist

import (
	header "github.com/gravitational/teleport/api/types/header"
	"time"
)

// deriveDeepCopyAccessList recursively copies the contents of src into dst.
func deriveDeepCopyAccessList(dst, src *AccessList) {
	func() {
		field := new(header.ResourceHeader)
		deriveDeepCopy(field, &src.ResourceHeader)
		dst.ResourceHeader = *field
	}()
	func() {
		field := new(Spec)
		deriveDeepCopy_(field, &src.Spec)
		dst.Spec = *field
	}()
	func() {
		field := new(Status)
		deriveDeepCopy_1(field, &src.Status)
		dst.Status = *field
	}()
}

// deriveDeepCopyAccessListMember recursively copies the contents of src into dst.
func deriveDeepCopyAccessListMember(dst, src *AccessListMember) {
	func() {
		field := new(header.ResourceHeader)
		deriveDeepCopy(field, &src.ResourceHeader)
		dst.ResourceHeader = *field
	}()
	func() {
		field := new(AccessListMemberSpec)
		deriveDeepCopy_2(field, &src.Spec)
		dst.Spec = *field
	}()
}

// deriveDeepCopyReview recursively copies the contents of src into dst.
func deriveDeepCopyReview(dst, src *Review) {
	func() {
		field := new(header.ResourceHeader)
		deriveDeepCopy(field, &src.ResourceHeader)
		dst.ResourceHeader = *field
	}()
	func() {
		field := new(ReviewSpec)
		deriveDeepCopy_3(field, &src.Spec)
		dst.Spec = *field
	}()
}

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src *header.ResourceHeader) {
	dst.Kind = src.Kind
	dst.SubKind = src.SubKind
	dst.Version = src.Version
	func() {
		field := new(header.Metadata)
		deriveDeepCopy_4(field, &src.Metadata)
		dst.Metadata = *field
	}()
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src *Spec) {
	dst.Type = src.Type
	dst.Title = src.Title
	dst.Description = src.Description
	if src.Owners == nil {
		dst.Owners = nil
	} else {
		if dst.Owners != nil {
			if len(src.Owners) > len(dst.Owners) {
				if cap(dst.Owners) >= len(src.Owners) {
					dst.Owners = (dst.Owners)[:len(src.Owners)]
				} else {
					dst.Owners = make([]Owner, len(src.Owners))
				}
			} else if len(src.Owners) < len(dst.Owners) {
				dst.Owners = (dst.Owners)[:len(src.Owners)]
			}
		} else {
			dst.Owners = make([]Owner, len(src.Owners))
		}
		copy(dst.Owners, src.Owners)
	}
	func() {
		field := new(Audit)
		deriveDeepCopy_5(field, &src.Audit)
		dst.Audit = *field
	}()
	func() {
		field := new(Requires)
		deriveDeepCopy_6(field, &src.MembershipRequires)
		dst.MembershipRequires = *field
	}()
	func() {
		field := new(Requires)
		deriveDeepCopy_6(field, &src.OwnershipRequires)
		dst.OwnershipRequires = *field
	}()
	func() {
		field := new(Grants)
		deriveDeepCopy_7(field, &src.Grants)
		dst.Grants = *field
	}()
	func() {
		field := new(Grants)
		deriveDeepCopy_7(field, &src.OwnerGrants)
		dst.OwnerGrants = *field
	}()
}

// deriveDeepCopy_1 recursively copies the contents of src into dst.
func deriveDeepCopy_1(dst, src *Status) {
	if src.MemberCount == nil {
		dst.MemberCount = nil
	} else {
		dst.MemberCount = new(uint32)
		*dst.MemberCount = *src.MemberCount
	}
	if src.MemberListCount == nil {
		dst.MemberListCount = nil
	} else {
		dst.MemberListCount = new(uint32)
		*dst.MemberListCount = *src.MemberListCount
	}
	if src.OwnerOf == nil {
		dst.OwnerOf = nil
	} else {
		if dst.OwnerOf != nil {
			if len(src.OwnerOf) > len(dst.OwnerOf) {
				if cap(dst.OwnerOf) >= len(src.OwnerOf) {
					dst.OwnerOf = (dst.OwnerOf)[:len(src.OwnerOf)]
				} else {
					dst.OwnerOf = make([]string, len(src.OwnerOf))
				}
			} else if len(src.OwnerOf) < len(dst.OwnerOf) {
				dst.OwnerOf = (dst.OwnerOf)[:len(src.OwnerOf)]
			}
		} else {
			dst.OwnerOf = make([]string, len(src.OwnerOf))
		}
		copy(dst.OwnerOf, src.OwnerOf)
	}
	if src.MemberOf == nil {
		dst.MemberOf = nil
	} else {
		if dst.MemberOf != nil {
			if len(src.MemberOf) > len(dst.MemberOf) {
				if cap(dst.MemberOf) >= len(src.MemberOf) {
					dst.MemberOf = (dst.MemberOf)[:len(src.MemberOf)]
				} else {
					dst.MemberOf = make([]string, len(src.MemberOf))
				}
			} else if len(src.MemberOf) < len(dst.MemberOf) {
				dst.MemberOf = (dst.MemberOf)[:len(src.MemberOf)]
			}
		} else {
			dst.MemberOf = make([]string, len(src.MemberOf))
		}
		copy(dst.MemberOf, src.MemberOf)
	}
	if src.CurrentUserAssignments == nil {
		dst.CurrentUserAssignments = nil
	} else {
		dst.CurrentUserAssignments = new(CurrentUserAssignments)
		*dst.CurrentUserAssignments = *src.CurrentUserAssignments
	}
}

// deriveDeepCopy_2 recursively copies the contents of src into dst.
func deriveDeepCopy_2(dst, src *AccessListMemberSpec) {
	dst.AccessList = src.AccessList
	dst.Name = src.Name
	dst.Title = src.Title
	func() {
		field := new(time.Time)
		deriveDeepCopy_8(field, &src.Joined)
		dst.Joined = *field
	}()
	func() {
		field := new(time.Time)
		deriveDeepCopy_8(field, &src.Expires)
		dst.Expires = *field
	}()
	dst.Reason = src.Reason
	dst.AddedBy = src.AddedBy
	dst.IneligibleStatus = src.IneligibleStatus
	dst.MembershipKind = src.MembershipKind
}

// deriveDeepCopy_3 recursively copies the contents of src into dst.
func deriveDeepCopy_3(dst, src *ReviewSpec) {
	dst.AccessList = src.AccessList
	if src.Reviewers == nil {
		dst.Reviewers = nil
	} else {
		if dst.Reviewers != nil {
			if len(src.Reviewers) > len(dst.Reviewers) {
				if cap(dst.Reviewers) >= len(src.Reviewers) {
					dst.Reviewers = (dst.Reviewers)[:len(src.Reviewers)]
				} else {
					dst.Reviewers = make([]string, len(src.Reviewers))
				}
			} else if len(src.Reviewers) < len(dst.Reviewers) {
				dst.Reviewers = (dst.Reviewers)[:len(src.Reviewers)]
			}
		} else {
			dst.Reviewers = make([]string, len(src.Reviewers))
		}
		copy(dst.Reviewers, src.Reviewers)
	}
	func() {
		field := new(time.Time)
		deriveDeepCopy_8(field, &src.ReviewDate)
		dst.ReviewDate = *field
	}()
	dst.Notes = src.Notes
	func() {
		field := new(ReviewChanges)
		deriveDeepCopy_9(field, &src.Changes)
		dst.Changes = *field
	}()
}

// deriveDeepCopy_4 recursively copies the contents of src into dst.
func deriveDeepCopy_4(dst, src *header.Metadata) {
	dst.Name = src.Name
	dst.Description = src.Description
	if src.Labels != nil {
		dst.Labels = make(map[string]string, len(src.Labels))
		deriveDeepCopy_10(dst.Labels, src.Labels)
	} else {
		dst.Labels = nil
	}
	func() {
		field := new(time.Time)
		deriveDeepCopy_8(field, &src.Expires)
		dst.Expires = *field
	}()
	dst.Revision = src.Revision
}

// deriveDeepCopy_5 recursively copies the contents of src into dst.
func deriveDeepCopy_5(dst, src *Audit) {
	func() {
		field := new(time.Time)
		deriveDeepCopy_8(field, &src.NextAuditDate)
		dst.NextAuditDate = *field
	}()
	dst.Recurrence = src.Recurrence
	dst.Notifications = src.Notifications
}

// deriveDeepCopy_6 recursively copies the contents of src into dst.
func deriveDeepCopy_6(dst, src *Requires) {
	if src.Roles == nil {
		dst.Roles = nil
	} else {
		if dst.Roles != nil {
			if len(src.Roles) > len(dst.Roles) {
				if cap(dst.Roles) >= len(src.Roles) {
					dst.Roles = (dst.Roles)[:len(src.Roles)]
				} else {
					dst.Roles = make([]string, len(src.Roles))
				}
			} else if len(src.Roles) < len(dst.Roles) {
				dst.Roles = (dst.Roles)[:len(src.Roles)]
			}
		} else {
			dst.Roles = make([]string, len(src.Roles))
		}
		copy(dst.Roles, src.Roles)
	}
	if src.Traits != nil {
		dst.Traits = make(map[string][]string, len(src.Traits))
		deriveDeepCopy_11(dst.Traits, src.Traits)
	} else {
		dst.Traits = nil
	}
}

// deriveDeepCopy_7 recursively copies the contents of src into dst.
func deriveDeepCopy_7(dst, src *Grants) {
	if src.Roles == nil {
		dst.Roles = nil
	} else {
		if dst.Roles != nil {
			if len(src.Roles) > len(dst.Roles) {
				if cap(dst.Roles) >= len(src.Roles) {
					dst.Roles = (dst.Roles)[:len(src.Roles)]
				} else {
					dst.Roles = make([]string, len(src.Roles))
				}
			} else if len(src.Roles) < len(dst.Roles) {
				dst.Roles = (dst.Roles)[:len(src.Roles)]
			}
		} else {
			dst.Roles = make([]string, len(src.Roles))
		}
		copy(dst.Roles, src.Roles)
	}
	if src.Traits != nil {
		dst.Traits = make(map[string][]string, len(src.Traits))
		deriveDeepCopy_11(dst.Traits, src.Traits)
	} else {
		dst.Traits = nil
	}
}

// deriveDeepCopy_8 recursively copies the contents of src into dst.
func deriveDeepCopy_8(dst, src *time.Time) {
	*dst = *src
}

// deriveDeepCopy_9 recursively copies the contents of src into dst.
func deriveDeepCopy_9(dst, src *ReviewChanges) {
	if src.MembershipRequirementsChanged == nil {
		dst.MembershipRequirementsChanged = nil
	} else {
		dst.MembershipRequirementsChanged = new(Requires)
		deriveDeepCopy_6(dst.MembershipRequirementsChanged, src.MembershipRequirementsChanged)
	}
	if src.RemovedMembers == nil {
		dst.RemovedMembers = nil
	} else {
		if dst.RemovedMembers != nil {
			if len(src.RemovedMembers) > len(dst.RemovedMembers) {
				if cap(dst.RemovedMembers) >= len(src.RemovedMembers) {
					dst.RemovedMembers = (dst.RemovedMembers)[:len(src.RemovedMembers)]
				} else {
					dst.RemovedMembers = make([]string, len(src.RemovedMembers))
				}
			} else if len(src.RemovedMembers) < len(dst.RemovedMembers) {
				dst.RemovedMembers = (dst.RemovedMembers)[:len(src.RemovedMembers)]
			}
		} else {
			dst.RemovedMembers = make([]string, len(src.RemovedMembers))
		}
		copy(dst.RemovedMembers, src.RemovedMembers)
	}
	dst.ReviewFrequencyChanged = src.ReviewFrequencyChanged
	dst.ReviewDayOfMonthChanged = src.ReviewDayOfMonthChanged
}

// deriveDeepCopy_10 recursively copies the contents of src into dst.
func deriveDeepCopy_10(dst, src map[string]string) {
	for src_key, src_value := range src {
		dst[src_key] = src_value
	}
}

// deriveDeepCopy_11 recursively copies the contents of src into dst.
func deriveDeepCopy_11(dst, src map[string][]string) {
	for src_key, src_value := range src {
		if src_value == nil {
			dst[src_key] = nil
		}
		if src_value == nil {
			dst[src_key] = nil
		} else {
			if dst[src_key] != nil {
				if len(src_value) > len(dst[src_key]) {
					if cap(dst[src_key]) >= len(src_value) {
						dst[src_key] = (dst[src_key])[:len(src_value)]
					} else {
						dst[src_key] = make([]string, len(src_value))
					}
				} else if len(src_value) < len(dst[src_key]) {
					dst[src_key] = (dst[src_key])[:len(src_value)]
				}
			} else {
				dst[src_key] = make([]string, len(src_value))
			}
			copy(dst[src_key], src_value)
		}
	}
}
