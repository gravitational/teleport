// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/legacy/types/mfa_device.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MFADevice is a multi-factor authentication device, such as a security key or
// an OTP app.
type MFADevice struct {
	// Boilerplate for implementing the Resource interface.
	Kind     string   `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	SubKind  string   `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	Version  string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Metadata Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata"`
	// ID is a UUID of this device.
	Id       string    `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	AddedAt  time.Time `protobuf:"bytes,6,opt,name=added_at,json=addedAt,proto3,stdtime" json:"added_at"`
	LastUsed time.Time `protobuf:"bytes,7,opt,name=last_used,json=lastUsed,proto3,stdtime" json:"last_used"`
	// Types that are valid to be assigned to Device:
	//
	//	*MFADevice_Totp
	//	*MFADevice_U2F
	//	*MFADevice_Webauthn
	//	*MFADevice_Sso
	Device               isMFADevice_Device `protobuf_oneof:"device"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MFADevice) Reset()         { *m = MFADevice{} }
func (m *MFADevice) String() string { return proto.CompactTextString(m) }
func (*MFADevice) ProtoMessage()    {}
func (*MFADevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_aee666f88c27ffea, []int{0}
}
func (m *MFADevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFADevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFADevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFADevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFADevice.Merge(m, src)
}
func (m *MFADevice) XXX_Size() int {
	return m.Size()
}
func (m *MFADevice) XXX_DiscardUnknown() {
	xxx_messageInfo_MFADevice.DiscardUnknown(m)
}

var xxx_messageInfo_MFADevice proto.InternalMessageInfo

type isMFADevice_Device interface {
	isMFADevice_Device()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MFADevice_Totp struct {
	Totp *TOTPDevice `protobuf:"bytes,8,opt,name=totp,proto3,oneof" json:"totp,omitempty"`
}
type MFADevice_U2F struct {
	U2F *U2FDevice `protobuf:"bytes,9,opt,name=u2f,proto3,oneof" json:"u2f,omitempty"`
}
type MFADevice_Webauthn struct {
	Webauthn *WebauthnDevice `protobuf:"bytes,10,opt,name=webauthn,proto3,oneof" json:"webauthn,omitempty"`
}
type MFADevice_Sso struct {
	Sso *SSOMFADevice `protobuf:"bytes,11,opt,name=sso,proto3,oneof" json:"sso,omitempty"`
}

func (*MFADevice_Totp) isMFADevice_Device()     {}
func (*MFADevice_U2F) isMFADevice_Device()      {}
func (*MFADevice_Webauthn) isMFADevice_Device() {}
func (*MFADevice_Sso) isMFADevice_Device()      {}

func (m *MFADevice) GetDevice() isMFADevice_Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *MFADevice) GetTotp() *TOTPDevice {
	if x, ok := m.GetDevice().(*MFADevice_Totp); ok {
		return x.Totp
	}
	return nil
}

func (m *MFADevice) GetU2F() *U2FDevice {
	if x, ok := m.GetDevice().(*MFADevice_U2F); ok {
		return x.U2F
	}
	return nil
}

func (m *MFADevice) GetWebauthn() *WebauthnDevice {
	if x, ok := m.GetDevice().(*MFADevice_Webauthn); ok {
		return x.Webauthn
	}
	return nil
}

func (m *MFADevice) GetSso() *SSOMFADevice {
	if x, ok := m.GetDevice().(*MFADevice_Sso); ok {
		return x.Sso
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MFADevice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MFADevice_Totp)(nil),
		(*MFADevice_U2F)(nil),
		(*MFADevice_Webauthn)(nil),
		(*MFADevice_Sso)(nil),
	}
}

// TOTPDevice holds the TOTP-specific fields of MFADevice.
type TOTPDevice struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TOTPDevice) Reset()         { *m = TOTPDevice{} }
func (m *TOTPDevice) String() string { return proto.CompactTextString(m) }
func (*TOTPDevice) ProtoMessage()    {}
func (*TOTPDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_aee666f88c27ffea, []int{1}
}
func (m *TOTPDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TOTPDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TOTPDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TOTPDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TOTPDevice.Merge(m, src)
}
func (m *TOTPDevice) XXX_Size() int {
	return m.Size()
}
func (m *TOTPDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_TOTPDevice.DiscardUnknown(m)
}

var xxx_messageInfo_TOTPDevice proto.InternalMessageInfo

// U2FDevice holds the U2F-specific fields of MFADevice.
type U2FDevice struct {
	// KeyHandle uniquely identifies a key on a device
	KeyHandle []byte `protobuf:"bytes,1,opt,name=key_handle,json=keyHandle,proto3" json:"key_handle,omitempty"`
	// PubKey is an DER encoded ecdsa public key
	PubKey []byte `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// Counter is the latest seen value of the U2F usage counter.
	Counter              uint32   `protobuf:"varint,3,opt,name=counter,proto3" json:"counter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *U2FDevice) Reset()         { *m = U2FDevice{} }
func (m *U2FDevice) String() string { return proto.CompactTextString(m) }
func (*U2FDevice) ProtoMessage()    {}
func (*U2FDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_aee666f88c27ffea, []int{2}
}
func (m *U2FDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *U2FDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_U2FDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *U2FDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_U2FDevice.Merge(m, src)
}
func (m *U2FDevice) XXX_Size() int {
	return m.Size()
}
func (m *U2FDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_U2FDevice.DiscardUnknown(m)
}

var xxx_messageInfo_U2FDevice proto.InternalMessageInfo

// WebauthnDevice holds Webauthn-specific fields of MFADevice.
type WebauthnDevice struct {
	// Credential ID for the authenticator.
	CredentialId []byte `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// Public key encoded in CBOR format.
	// Webauthn support various key algorithms; CBOR encoding is used to reflect
	// those choices.
	// See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
	// reference.
	PublicKeyCbor []byte `protobuf:"bytes,2,opt,name=public_key_cbor,json=publicKeyCbor,proto3" json:"public_key_cbor,omitempty"`
	// Attestation format used by the authenticator, if any.
	AttestationType string `protobuf:"bytes,3,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type,omitempty"`
	// AAGUID is the globally unique identifier of the authenticator model.
	// Zeroed for U2F devices.
	Aaguid []byte `protobuf:"bytes,4,opt,name=aaguid,proto3" json:"aaguid,omitempty"`
	// Signature counter for login operations.
	// Actual counter values received from the authenticator are expected to be
	// higher than the previously-stored value.
	SignatureCounter uint32 `protobuf:"varint,5,opt,name=signature_counter,json=signatureCounter,proto3" json:"signature_counter,omitempty"`
	// Raw attestation object, as returned by the authentication during
	// registration.
	// Absent for legacy entries (Teleport 8.x).
	AttestationObject []byte `protobuf:"bytes,6,opt,name=attestation_object,json=attestationObject,proto3" json:"attestation_object,omitempty"`
	// True if a resident key was requested during registration.
	// Marks passwordless-capable devices.
	// (Note that resident_key=true represents the server-side / Relying Party
	// view of the registration process; the authenticator alone can determine
	// if a key is truly resident.)
	ResidentKey bool `protobuf:"varint,7,opt,name=resident_key,json=residentKey,proto3" json:"resident_key,omitempty"`
	// Relying Party ID used by the credential.
	// Recorded on registration for new credentials, or on first successful
	// authentication for "old" credentials (created before the field existed).
	// Ideally, this is always the same as the configured RPID.
	// If an RPID change does happen, this helps Teleport detect it and react
	// accordingly.
	CredentialRpId string `protobuf:"bytes,8,opt,name=credential_rp_id,json=credentialRpId,proto3" json:"credential_rp_id,omitempty"`
	// Authenticator Backup Eligibility (BE) bit, recorded during registration or
	// backfill (for older authenticators).
	// https://w3c.github.io/webauthn/#authdata-flags-be
	CredentialBackupEligible *types.BoolValue `protobuf:"bytes,9,opt,name=credential_backup_eligible,json=credentialBackupEligible,proto3" json:"credential_backup_eligible,omitempty"`
	// Authenticator Backup State (BS) bit, recorded during registration or
	// backfill (for older authenticators).
	// https://w3c.github.io/webauthn/#authdata-flags-bs
	CredentialBackedUp   *types.BoolValue `protobuf:"bytes,10,opt,name=credential_backed_up,json=credentialBackedUp,proto3" json:"credential_backed_up,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *WebauthnDevice) Reset()         { *m = WebauthnDevice{} }
func (m *WebauthnDevice) String() string { return proto.CompactTextString(m) }
func (*WebauthnDevice) ProtoMessage()    {}
func (*WebauthnDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_aee666f88c27ffea, []int{3}
}
func (m *WebauthnDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebauthnDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebauthnDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebauthnDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebauthnDevice.Merge(m, src)
}
func (m *WebauthnDevice) XXX_Size() int {
	return m.Size()
}
func (m *WebauthnDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_WebauthnDevice.DiscardUnknown(m)
}

var xxx_messageInfo_WebauthnDevice proto.InternalMessageInfo

// SSOMFADevice contains details of an SSO MFA method.
type SSOMFADevice struct {
	// connector_id is the ID of the SSO connector.
	ConnectorId string `protobuf:"bytes,1,opt,name=connector_id,json=connectorId,proto3" json:"connector_id,omitempty"`
	// connector_type is the type of the SSO connector.
	ConnectorType string `protobuf:"bytes,2,opt,name=connector_type,json=connectorType,proto3" json:"connector_type,omitempty"`
	// display_name is the display name of the SSO connector
	DisplayName          string   `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSOMFADevice) Reset()         { *m = SSOMFADevice{} }
func (m *SSOMFADevice) String() string { return proto.CompactTextString(m) }
func (*SSOMFADevice) ProtoMessage()    {}
func (*SSOMFADevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_aee666f88c27ffea, []int{4}
}
func (m *SSOMFADevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSOMFADevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSOMFADevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSOMFADevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSOMFADevice.Merge(m, src)
}
func (m *SSOMFADevice) XXX_Size() int {
	return m.Size()
}
func (m *SSOMFADevice) XXX_DiscardUnknown() {
	xxx_messageInfo_SSOMFADevice.DiscardUnknown(m)
}

var xxx_messageInfo_SSOMFADevice proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MFADevice)(nil), "types.MFADevice")
	proto.RegisterType((*TOTPDevice)(nil), "types.TOTPDevice")
	proto.RegisterType((*U2FDevice)(nil), "types.U2FDevice")
	proto.RegisterType((*WebauthnDevice)(nil), "types.WebauthnDevice")
	proto.RegisterType((*SSOMFADevice)(nil), "types.SSOMFADevice")
}

func init() {
	proto.RegisterFile("teleport/legacy/types/mfa_device.proto", fileDescriptor_aee666f88c27ffea)
}

var fileDescriptor_aee666f88c27ffea = []byte{
	// 785 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xff, 0x6e, 0x1b, 0x45,
	0x10, 0x8e, 0xe3, 0xc4, 0x3e, 0x8f, 0x9d, 0xc4, 0x59, 0x0a, 0x1c, 0x91, 0x70, 0x5a, 0x53, 0xda,
	0xa0, 0x0a, 0x5b, 0xa4, 0x7f, 0x23, 0x14, 0x17, 0xaa, 0x46, 0xa1, 0x04, 0x5d, 0x1d, 0x40, 0x48,
	0xe8, 0xb4, 0x77, 0x3b, 0xb9, 0x2c, 0x3e, 0xdf, 0xae, 0x6e, 0xf7, 0x52, 0x9d, 0x78, 0x09, 0x1e,
	0x2b, 0x7f, 0x22, 0x1e, 0x80, 0x1f, 0x79, 0x03, 0xde, 0x00, 0xed, 0xde, 0xde, 0xd9, 0x0d, 0x02,
	0x89, 0xff, 0x76, 0xbf, 0xf9, 0x66, 0x66, 0x67, 0xbe, 0x4f, 0x0b, 0x8f, 0x34, 0xa6, 0x28, 0x45,
	0xae, 0xa7, 0x29, 0x26, 0x34, 0x2e, 0xa7, 0xba, 0x94, 0xa8, 0xa6, 0xcb, 0x4b, 0x1a, 0x32, 0xbc,
	0xe6, 0x31, 0x4e, 0x64, 0x2e, 0xb4, 0x20, 0xdb, 0x16, 0x3f, 0xb8, 0x97, 0x88, 0x44, 0x58, 0x64,
	0x6a, 0x4e, 0x55, 0xf0, 0xe0, 0x30, 0x11, 0x22, 0x49, 0x71, 0x6a, 0x6f, 0x51, 0x71, 0x39, 0xd5,
	0x7c, 0x89, 0x4a, 0xd3, 0xa5, 0x74, 0x84, 0xd1, 0x5d, 0xc2, 0xeb, 0x9c, 0x4a, 0x89, 0xb9, 0x72,
	0xf1, 0x87, 0xff, 0xf2, 0x0a, 0xd4, 0x94, 0x51, 0x4d, 0x2b, 0xd6, 0xf8, 0xd7, 0x36, 0xf4, 0x5e,
	0x3e, 0x3f, 0xf9, 0xdc, 0xbe, 0x8b, 0x10, 0xd8, 0x5a, 0xf0, 0x8c, 0xf9, 0xad, 0xfb, 0xad, 0xa3,
	0x5e, 0x60, 0xcf, 0xe4, 0x3d, 0xf0, 0x54, 0x11, 0x85, 0x16, 0xdf, 0xb4, 0x78, 0x57, 0x15, 0xd1,
	0x99, 0x09, 0xf9, 0xd0, 0xbd, 0xc6, 0x5c, 0x71, 0x91, 0xf9, 0xed, 0x2a, 0xe2, 0xae, 0xe4, 0x13,
	0xf0, 0xea, 0x46, 0xfe, 0xd6, 0xfd, 0xd6, 0x51, 0xff, 0x78, 0x6f, 0x62, 0xfb, 0x4f, 0x5e, 0x3a,
	0x78, 0xb6, 0x75, 0xf3, 0xdb, 0xe1, 0x46, 0xd0, 0xd0, 0xc8, 0x2e, 0x6c, 0x72, 0xe6, 0x6f, 0xdb,
	0x3a, 0x9b, 0x9c, 0x91, 0xcf, 0xc0, 0xa3, 0x8c, 0x21, 0x0b, 0xa9, 0xf6, 0x3b, 0xb6, 0xc4, 0xc1,
	0xa4, 0x1a, 0x79, 0x52, 0x8f, 0x3c, 0x99, 0xd7, 0x3b, 0x99, 0x79, 0xa6, 0xda, 0xcf, 0xbf, 0x1f,
	0xb6, 0x82, 0xae, 0xcd, 0x3a, 0xd1, 0xe4, 0x04, 0x7a, 0x29, 0x55, 0x3a, 0x2c, 0x14, 0x32, 0xbf,
	0xfb, 0x3f, 0x2a, 0x78, 0x26, 0xed, 0x42, 0x21, 0x23, 0x8f, 0x61, 0x4b, 0x0b, 0x2d, 0x7d, 0xcf,
	0x66, 0xef, 0xbb, 0x11, 0xe6, 0xe7, 0xf3, 0xaf, 0xab, 0x85, 0xbd, 0xd8, 0x08, 0x2c, 0x81, 0x3c,
	0x84, 0x76, 0x71, 0x7c, 0xe9, 0xf7, 0x2c, 0x6f, 0xe8, 0x78, 0x17, 0xc7, 0xcf, 0x1b, 0x9a, 0x09,
	0x93, 0xa7, 0xe0, 0xbd, 0xc6, 0x88, 0x16, 0xfa, 0x2a, 0xf3, 0xc1, 0x52, 0xdf, 0x76, 0xd4, 0x6f,
	0x1d, 0xdc, 0xf0, 0x1b, 0x22, 0x79, 0x0c, 0x6d, 0xa5, 0x84, 0xdf, 0xb7, 0xfc, 0xb7, 0x1c, 0xff,
	0xd5, 0xab, 0xf3, 0x46, 0x35, 0x53, 0x5d, 0x29, 0x31, 0xf3, 0xa0, 0x53, 0xd9, 0x6b, 0x3c, 0x02,
	0x58, 0xbd, 0x91, 0x0c, 0xa1, 0xbd, 0xc0, 0xd2, 0x69, 0x6a, 0x8e, 0xe3, 0x1f, 0xa0, 0xd7, 0xbc,
	0x8d, 0xbc, 0x0f, 0xb0, 0xc0, 0x32, 0xbc, 0xa2, 0x19, 0x4b, 0xd1, 0xb2, 0x06, 0x41, 0x6f, 0x81,
	0xe5, 0x0b, 0x0b, 0x90, 0x77, 0xa1, 0x2b, 0x8d, 0xfc, 0x58, 0x5a, 0xf5, 0x07, 0x41, 0x47, 0x16,
	0xd1, 0x19, 0x96, 0x46, 0xfc, 0x58, 0x14, 0x99, 0xc6, 0xdc, 0x8a, 0xbf, 0x13, 0xd4, 0xd7, 0xf1,
	0x5f, 0x6d, 0xd8, 0x7d, 0x73, 0x20, 0xf2, 0x01, 0xec, 0xc4, 0x39, 0x32, 0xcc, 0x34, 0xa7, 0x69,
	0xc8, 0x99, 0xeb, 0x33, 0x58, 0x81, 0xa7, 0x8c, 0x3c, 0x82, 0x3d, 0x59, 0x44, 0x29, 0x8f, 0x4d,
	0xb7, 0x30, 0x8e, 0x44, 0xee, 0x5a, 0xee, 0x54, 0xf0, 0x19, 0x96, 0xcf, 0x22, 0x91, 0x93, 0x8f,
	0x60, 0x48, 0xb5, 0x36, 0xb2, 0x69, 0x2e, 0xb2, 0xd0, 0x6c, 0xc4, 0xf9, 0x6f, 0x6f, 0x0d, 0x9f,
	0x97, 0x12, 0xc9, 0x3b, 0xd0, 0xa1, 0x34, 0x29, 0x38, 0xb3, 0x2e, 0x1c, 0x04, 0xee, 0x46, 0x9e,
	0xc0, 0xbe, 0xe2, 0x49, 0x46, 0x75, 0x91, 0x63, 0x58, 0x8f, 0xb1, 0x6d, 0xc7, 0x18, 0x36, 0x81,
	0x67, 0x15, 0x4e, 0x3e, 0x06, 0xb2, 0xde, 0x4f, 0x44, 0x3f, 0x62, 0x5c, 0x79, 0x72, 0x10, 0xec,
	0xaf, 0x45, 0xce, 0x6d, 0x80, 0x3c, 0x80, 0x41, 0x8e, 0x8a, 0x9b, 0xb9, 0xec, 0xda, 0x8c, 0xf5,
	0xbc, 0xa0, 0x5f, 0x63, 0x66, 0x77, 0x47, 0x30, 0x5c, 0x5b, 0x47, 0x2e, 0xcd, 0x46, 0x3c, 0x3b,
	0xc1, 0xee, 0x0a, 0x0f, 0xe4, 0x29, 0x23, 0xdf, 0xc1, 0xc1, 0x1a, 0x33, 0xa2, 0xf1, 0xa2, 0x90,
	0x21, 0xa6, 0x3c, 0xe1, 0x51, 0x8a, 0xce, 0x6f, 0xff, 0x74, 0xf5, 0x4c, 0x88, 0xf4, 0x1b, 0x9a,
	0x16, 0x18, 0xf8, 0xab, 0xec, 0x99, 0x4d, 0xfe, 0xc2, 0xe5, 0x92, 0x2f, 0xe1, 0xde, 0x9d, 0xca,
	0xc8, 0xc2, 0x42, 0x3a, 0x63, 0xfe, 0x57, 0x4d, 0xf2, 0x66, 0x4d, 0x64, 0x17, 0x72, 0xfc, 0x13,
	0x0c, 0xd6, 0x3d, 0x69, 0x96, 0x10, 0x8b, 0x2c, 0xc3, 0x58, 0x8b, 0xbc, 0xd6, 0xbb, 0x17, 0xf4,
	0x1b, 0xec, 0x94, 0x91, 0x0f, 0x61, 0x77, 0x45, 0xb1, 0x22, 0x56, 0xdf, 0xcb, 0x4e, 0x83, 0x5a,
	0x09, 0x1f, 0xc0, 0x80, 0x71, 0x25, 0x53, 0x5a, 0x86, 0x19, 0x5d, 0xd6, 0x4a, 0xf7, 0x1d, 0xf6,
	0x15, 0x5d, 0xe2, 0xec, 0xd3, 0x9b, 0x3f, 0x47, 0x1b, 0x37, 0xb7, 0xa3, 0xd6, 0x2f, 0xb7, 0xa3,
	0xd6, 0x1f, 0xb7, 0xa3, 0xd6, 0xf7, 0x4f, 0x12, 0xae, 0xaf, 0x8a, 0x68, 0x12, 0x8b, 0xe5, 0x34,
	0xc9, 0xe9, 0x35, 0xaf, 0x14, 0xa2, 0xe9, 0xb4, 0xf9, 0x15, 0xa9, 0xe4, 0xd5, 0x97, 0x18, 0x75,
	0xec, 0x8c, 0x4f, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x34, 0x9e, 0x36, 0xb8, 0x05, 0x00,
	0x00,
}

func (m *MFADevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFADevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Device != nil {
		{
			size := m.Device.Size()
			i -= size
			if _, err := m.Device.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastUsed, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUsed):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintMfaDevice(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x3a
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.AddedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.AddedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintMfaDevice(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x32
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMfaDevice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MFADevice_Totp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice_Totp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Totp != nil {
		{
			size, err := m.Totp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfaDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *MFADevice_U2F) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice_U2F) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.U2F != nil {
		{
			size, err := m.U2F.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfaDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *MFADevice_Webauthn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice_Webauthn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfaDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *MFADevice_Sso) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFADevice_Sso) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sso != nil {
		{
			size, err := m.Sso.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfaDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *TOTPDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TOTPDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TOTPDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *U2FDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *U2FDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *U2FDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Counter != 0 {
		i = encodeVarintMfaDevice(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyHandle) > 0 {
		i -= len(m.KeyHandle)
		copy(dAtA[i:], m.KeyHandle)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.KeyHandle)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebauthnDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebauthnDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebauthnDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CredentialBackedUp != nil {
		{
			size, err := m.CredentialBackedUp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfaDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.CredentialBackupEligible != nil {
		{
			size, err := m.CredentialBackupEligible.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfaDevice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CredentialRpId) > 0 {
		i -= len(m.CredentialRpId)
		copy(dAtA[i:], m.CredentialRpId)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.CredentialRpId)))
		i--
		dAtA[i] = 0x42
	}
	if m.ResidentKey {
		i--
		if m.ResidentKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.AttestationObject) > 0 {
		i -= len(m.AttestationObject)
		copy(dAtA[i:], m.AttestationObject)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.AttestationObject)))
		i--
		dAtA[i] = 0x32
	}
	if m.SignatureCounter != 0 {
		i = encodeVarintMfaDevice(dAtA, i, uint64(m.SignatureCounter))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Aaguid) > 0 {
		i -= len(m.Aaguid)
		copy(dAtA[i:], m.Aaguid)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.Aaguid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AttestationType) > 0 {
		i -= len(m.AttestationType)
		copy(dAtA[i:], m.AttestationType)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.AttestationType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PublicKeyCbor) > 0 {
		i -= len(m.PublicKeyCbor)
		copy(dAtA[i:], m.PublicKeyCbor)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.PublicKeyCbor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SSOMFADevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSOMFADevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSOMFADevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ConnectorType) > 0 {
		i -= len(m.ConnectorType)
		copy(dAtA[i:], m.ConnectorType)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.ConnectorType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConnectorId) > 0 {
		i -= len(m.ConnectorId)
		copy(dAtA[i:], m.ConnectorId)
		i = encodeVarintMfaDevice(dAtA, i, uint64(len(m.ConnectorId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMfaDevice(dAtA []byte, offset int, v uint64) int {
	offset -= sovMfaDevice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MFADevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovMfaDevice(uint64(l))
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.AddedAt)
	n += 1 + l + sovMfaDevice(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastUsed)
	n += 1 + l + sovMfaDevice(uint64(l))
	if m.Device != nil {
		n += m.Device.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFADevice_Totp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Totp != nil {
		l = m.Totp.Size()
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	return n
}
func (m *MFADevice_U2F) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.U2F != nil {
		l = m.U2F.Size()
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	return n
}
func (m *MFADevice_Webauthn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	return n
}
func (m *MFADevice_Sso) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sso != nil {
		l = m.Sso.Size()
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	return n
}
func (m *TOTPDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *U2FDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyHandle)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.Counter != 0 {
		n += 1 + sovMfaDevice(uint64(m.Counter))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebauthnDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.PublicKeyCbor)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.AttestationType)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.Aaguid)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.SignatureCounter != 0 {
		n += 1 + sovMfaDevice(uint64(m.SignatureCounter))
	}
	l = len(m.AttestationObject)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.ResidentKey {
		n += 2
	}
	l = len(m.CredentialRpId)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.CredentialBackupEligible != nil {
		l = m.CredentialBackupEligible.Size()
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.CredentialBackedUp != nil {
		l = m.CredentialBackedUp.Size()
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SSOMFADevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConnectorId)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.ConnectorType)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovMfaDevice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMfaDevice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMfaDevice(x uint64) (n int) {
	return sovMfaDevice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MFADevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfaDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFADevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFADevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.AddedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUsed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastUsed, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Totp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TOTPDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Device = &MFADevice_Totp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field U2F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &U2FDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Device = &MFADevice_U2F{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WebauthnDevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Device = &MFADevice_Webauthn{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sso", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSOMFADevice{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Device = &MFADevice_Sso{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfaDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TOTPDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfaDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TOTPDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TOTPDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfaDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *U2FDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfaDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: U2FDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: U2FDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyHandle = append(m.KeyHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyHandle == nil {
				m.KeyHandle = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMfaDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebauthnDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfaDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebauthnDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebauthnDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = append(m.CredentialId[:0], dAtA[iNdEx:postIndex]...)
			if m.CredentialId == nil {
				m.CredentialId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyCbor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyCbor = append(m.PublicKeyCbor[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKeyCbor == nil {
				m.PublicKeyCbor = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aaguid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aaguid = append(m.Aaguid[:0], dAtA[iNdEx:postIndex]...)
			if m.Aaguid == nil {
				m.Aaguid = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureCounter", wireType)
			}
			m.SignatureCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureCounter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationObject", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationObject = append(m.AttestationObject[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationObject == nil {
				m.AttestationObject = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidentKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResidentKey = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialRpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialRpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialBackupEligible", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CredentialBackupEligible == nil {
				m.CredentialBackupEligible = &types.BoolValue{}
			}
			if err := m.CredentialBackupEligible.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialBackedUp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CredentialBackedUp == nil {
				m.CredentialBackedUp = &types.BoolValue{}
			}
			if err := m.CredentialBackedUp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfaDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSOMFADevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfaDevice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSOMFADevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSOMFADevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfaDevice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfaDevice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfaDevice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMfaDevice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMfaDevice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMfaDevice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMfaDevice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMfaDevice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMfaDevice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMfaDevice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMfaDevice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMfaDevice = fmt.Errorf("proto: unexpected end of group")
)
