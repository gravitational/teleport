// Code generated by goderive DO NOT EDIT.

package userloginstate

import (
	header "github.com/gravitational/teleport/api/types/header"
	"time"
)

// deriveTeleportEqualUserLoginState returns whether this and that are equal.
func deriveTeleportEqualUserLoginState(this, that *UserLoginState) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			deriveTeleportEqual(&this.ResourceHeader, &that.ResourceHeader) &&
			deriveTeleportEqual_(&this.Spec, &that.Spec)
}

// deriveDeepCopyUserLoginState recursively copies the contents of src into dst.
func deriveDeepCopyUserLoginState(dst, src *UserLoginState) {
	func() {
		field := new(header.ResourceHeader)
		deriveDeepCopy(field, &src.ResourceHeader)
		dst.ResourceHeader = *field
	}()
	func() {
		field := new(Spec)
		deriveDeepCopy_(field, &src.Spec)
		dst.Spec = *field
	}()
}

// deriveTeleportEqual returns whether this and that are equal.
func deriveTeleportEqual(this, that *header.ResourceHeader) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.Kind == that.Kind &&
			this.SubKind == that.SubKind &&
			this.Version == that.Version &&
			deriveTeleportEqual_1(&this.Metadata, &that.Metadata)
}

// deriveTeleportEqual_ returns whether this and that are equal.
func deriveTeleportEqual_(this, that *Spec) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			deriveTeleportEqual_2(this.OriginalRoles, that.OriginalRoles) &&
			deriveTeleportEqual_3(this.OriginalTraits, that.OriginalTraits) &&
			deriveTeleportEqual_2(this.Roles, that.Roles) &&
			deriveTeleportEqual_3(this.Traits, that.Traits) &&
			this.UserType == that.UserType &&
			deriveTeleportEqual_4(this.GitHubIdentity, that.GitHubIdentity)
}

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src *header.ResourceHeader) {
	dst.Kind = src.Kind
	dst.SubKind = src.SubKind
	dst.Version = src.Version
	func() {
		field := new(header.Metadata)
		deriveDeepCopy_1(field, &src.Metadata)
		dst.Metadata = *field
	}()
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src *Spec) {
	if src.OriginalRoles == nil {
		dst.OriginalRoles = nil
	} else {
		if dst.OriginalRoles != nil {
			if len(src.OriginalRoles) > len(dst.OriginalRoles) {
				if cap(dst.OriginalRoles) >= len(src.OriginalRoles) {
					dst.OriginalRoles = (dst.OriginalRoles)[:len(src.OriginalRoles)]
				} else {
					dst.OriginalRoles = make([]string, len(src.OriginalRoles))
				}
			} else if len(src.OriginalRoles) < len(dst.OriginalRoles) {
				dst.OriginalRoles = (dst.OriginalRoles)[:len(src.OriginalRoles)]
			}
		} else {
			dst.OriginalRoles = make([]string, len(src.OriginalRoles))
		}
		copy(dst.OriginalRoles, src.OriginalRoles)
	}
	if src.OriginalTraits != nil {
		dst.OriginalTraits = make(map[string][]string, len(src.OriginalTraits))
		deriveDeepCopy_2(dst.OriginalTraits, src.OriginalTraits)
	} else {
		dst.OriginalTraits = nil
	}
	if src.Roles == nil {
		dst.Roles = nil
	} else {
		if dst.Roles != nil {
			if len(src.Roles) > len(dst.Roles) {
				if cap(dst.Roles) >= len(src.Roles) {
					dst.Roles = (dst.Roles)[:len(src.Roles)]
				} else {
					dst.Roles = make([]string, len(src.Roles))
				}
			} else if len(src.Roles) < len(dst.Roles) {
				dst.Roles = (dst.Roles)[:len(src.Roles)]
			}
		} else {
			dst.Roles = make([]string, len(src.Roles))
		}
		copy(dst.Roles, src.Roles)
	}
	if src.Traits != nil {
		dst.Traits = make(map[string][]string, len(src.Traits))
		deriveDeepCopy_2(dst.Traits, src.Traits)
	} else {
		dst.Traits = nil
	}
	dst.UserType = src.UserType
	if src.GitHubIdentity == nil {
		dst.GitHubIdentity = nil
	} else {
		dst.GitHubIdentity = new(ExternalIdentity)
		*dst.GitHubIdentity = *src.GitHubIdentity
	}
}

// deriveTeleportEqual_1 returns whether this and that are equal.
func deriveTeleportEqual_1(this, that *header.Metadata) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.Name == that.Name &&
			this.Description == that.Description &&
			deriveTeleportEqual_5(this.Labels, that.Labels) &&
			this.Expires.Equal(that.Expires)
}

// deriveTeleportEqual_2 returns whether this and that are equal.
func deriveTeleportEqual_2(this, that []string) bool {
	if this == nil || that == nil {
		return this == nil && that == nil
	}
	if len(this) != len(that) {
		return false
	}
	for i := 0; i < len(this); i++ {
		if !(this[i] == that[i]) {
			return false
		}
	}
	return true
}

// deriveTeleportEqual_3 returns whether this and that are equal.
func deriveTeleportEqual_3(this, that map[string][]string) bool {
	if this == nil || that == nil {
		return this == nil && that == nil
	}
	if len(this) != len(that) {
		return false
	}
	for k, v := range this {
		thatv, ok := that[k]
		if !ok {
			return false
		}
		if !(deriveTeleportEqual_2(v, thatv)) {
			return false
		}
	}
	return true
}

// deriveTeleportEqual_4 returns whether this and that are equal.
func deriveTeleportEqual_4(this, that *ExternalIdentity) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.UserID == that.UserID &&
			this.Username == that.Username
}

// deriveDeepCopy_1 recursively copies the contents of src into dst.
func deriveDeepCopy_1(dst, src *header.Metadata) {
	dst.Name = src.Name
	dst.Description = src.Description
	if src.Labels != nil {
		dst.Labels = make(map[string]string, len(src.Labels))
		deriveDeepCopy_3(dst.Labels, src.Labels)
	} else {
		dst.Labels = nil
	}
	func() {
		field := new(time.Time)
		deriveDeepCopy_4(field, &src.Expires)
		dst.Expires = *field
	}()
	dst.Revision = src.Revision
}

// deriveDeepCopy_2 recursively copies the contents of src into dst.
func deriveDeepCopy_2(dst, src map[string][]string) {
	for src_key, src_value := range src {
		if src_value == nil {
			dst[src_key] = nil
		}
		if src_value == nil {
			dst[src_key] = nil
		} else {
			if dst[src_key] != nil {
				if len(src_value) > len(dst[src_key]) {
					if cap(dst[src_key]) >= len(src_value) {
						dst[src_key] = (dst[src_key])[:len(src_value)]
					} else {
						dst[src_key] = make([]string, len(src_value))
					}
				} else if len(src_value) < len(dst[src_key]) {
					dst[src_key] = (dst[src_key])[:len(src_value)]
				}
			} else {
				dst[src_key] = make([]string, len(src_value))
			}
			copy(dst[src_key], src_value)
		}
	}
}

// deriveTeleportEqual_5 returns whether this and that are equal.
func deriveTeleportEqual_5(this, that map[string]string) bool {
	if this == nil || that == nil {
		return this == nil && that == nil
	}
	if len(this) != len(that) {
		return false
	}
	for k, v := range this {
		thatv, ok := that[k]
		if !ok {
			return false
		}
		if !(v == thatv) {
			return false
		}
	}
	return true
}

// deriveDeepCopy_3 recursively copies the contents of src into dst.
func deriveDeepCopy_3(dst, src map[string]string) {
	for src_key, src_value := range src {
		dst[src_key] = src_value
	}
}

// deriveDeepCopy_4 recursively copies the contents of src into dst.
func deriveDeepCopy_4(dst, src *time.Time) {
	*dst = *src
}
