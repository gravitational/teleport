// Code generated by goderive DO NOT EDIT.

package userloginstate

import (
	header "github.com/gravitational/teleport/api/types/header"
	"time"
)

// deriveTeleportEqualUserLoginState returns whether this and that are equal.
func deriveTeleportEqualUserLoginState(this, that *UserLoginState) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			deriveTeleportEqual(&this.ResourceHeader, &that.ResourceHeader) &&
			deriveTeleportEqual_(&this.Spec, &that.Spec)
}

// deriveDeepCopyUserLoginState recursively copies the contents of src into dst.
func deriveDeepCopyUserLoginState(dst, src *UserLoginState) {
	func() {
		field := new(header.ResourceHeader)
		deriveDeepCopy(field, &src.ResourceHeader)
		dst.ResourceHeader = *field
	}()
	func() {
		field := new(Spec)
		deriveDeepCopy_(field, &src.Spec)
		dst.Spec = *field
	}()
}

// deriveTeleportEqual returns whether this and that are equal.
func deriveTeleportEqual(this, that *header.ResourceHeader) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.Kind == that.Kind &&
			this.SubKind == that.SubKind &&
			this.Version == that.Version &&
			deriveTeleportEqual_1(&this.Metadata, &that.Metadata)
}

// deriveTeleportEqual_ returns whether this and that are equal.
func deriveTeleportEqual_(this, that *Spec) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			deriveTeleportEqual_2(this.OriginalRoles, that.OriginalRoles) &&
			deriveTeleportEqual_3(this.OriginalTraits, that.OriginalTraits) &&
			deriveTeleportEqual_2(this.Roles, that.Roles) &&
			deriveTeleportEqual_3(this.Traits, that.Traits) &&
			deriveTeleportEqual_2(this.AccessListRoles, that.AccessListRoles) &&
			deriveTeleportEqual_3(this.AccessListTraits, that.AccessListTraits) &&
			this.UserType == that.UserType &&
			deriveTeleportEqual_4(this.GitHubIdentity, that.GitHubIdentity) &&
			deriveTeleportEqual_5(this.SAMLIdentities, that.SAMLIdentities)
}

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src *header.ResourceHeader) {
	dst.Kind = src.Kind
	dst.SubKind = src.SubKind
	dst.Version = src.Version
	func() {
		field := new(header.Metadata)
		deriveDeepCopy_1(field, &src.Metadata)
		dst.Metadata = *field
	}()
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src *Spec) {
	if src.OriginalRoles == nil {
		dst.OriginalRoles = nil
	} else {
		if dst.OriginalRoles != nil {
			if len(src.OriginalRoles) > len(dst.OriginalRoles) {
				if cap(dst.OriginalRoles) >= len(src.OriginalRoles) {
					dst.OriginalRoles = (dst.OriginalRoles)[:len(src.OriginalRoles)]
				} else {
					dst.OriginalRoles = make([]string, len(src.OriginalRoles))
				}
			} else if len(src.OriginalRoles) < len(dst.OriginalRoles) {
				dst.OriginalRoles = (dst.OriginalRoles)[:len(src.OriginalRoles)]
			}
		} else {
			dst.OriginalRoles = make([]string, len(src.OriginalRoles))
		}
		copy(dst.OriginalRoles, src.OriginalRoles)
	}
	if src.OriginalTraits != nil {
		dst.OriginalTraits = make(map[string][]string, len(src.OriginalTraits))
		deriveDeepCopy_2(dst.OriginalTraits, src.OriginalTraits)
	} else {
		dst.OriginalTraits = nil
	}
	if src.Roles == nil {
		dst.Roles = nil
	} else {
		if dst.Roles != nil {
			if len(src.Roles) > len(dst.Roles) {
				if cap(dst.Roles) >= len(src.Roles) {
					dst.Roles = (dst.Roles)[:len(src.Roles)]
				} else {
					dst.Roles = make([]string, len(src.Roles))
				}
			} else if len(src.Roles) < len(dst.Roles) {
				dst.Roles = (dst.Roles)[:len(src.Roles)]
			}
		} else {
			dst.Roles = make([]string, len(src.Roles))
		}
		copy(dst.Roles, src.Roles)
	}
	if src.Traits != nil {
		dst.Traits = make(map[string][]string, len(src.Traits))
		deriveDeepCopy_2(dst.Traits, src.Traits)
	} else {
		dst.Traits = nil
	}
	if src.AccessListRoles == nil {
		dst.AccessListRoles = nil
	} else {
		if dst.AccessListRoles != nil {
			if len(src.AccessListRoles) > len(dst.AccessListRoles) {
				if cap(dst.AccessListRoles) >= len(src.AccessListRoles) {
					dst.AccessListRoles = (dst.AccessListRoles)[:len(src.AccessListRoles)]
				} else {
					dst.AccessListRoles = make([]string, len(src.AccessListRoles))
				}
			} else if len(src.AccessListRoles) < len(dst.AccessListRoles) {
				dst.AccessListRoles = (dst.AccessListRoles)[:len(src.AccessListRoles)]
			}
		} else {
			dst.AccessListRoles = make([]string, len(src.AccessListRoles))
		}
		copy(dst.AccessListRoles, src.AccessListRoles)
	}
	if src.AccessListTraits != nil {
		dst.AccessListTraits = make(map[string][]string, len(src.AccessListTraits))
		deriveDeepCopy_2(dst.AccessListTraits, src.AccessListTraits)
	} else {
		dst.AccessListTraits = nil
	}
	dst.UserType = src.UserType
	if src.GitHubIdentity == nil {
		dst.GitHubIdentity = nil
	} else {
		dst.GitHubIdentity = new(ExternalIdentity)
		deriveDeepCopy_3(dst.GitHubIdentity, src.GitHubIdentity)
	}
	if src.SAMLIdentities == nil {
		dst.SAMLIdentities = nil
	} else {
		if dst.SAMLIdentities != nil {
			if len(src.SAMLIdentities) > len(dst.SAMLIdentities) {
				if cap(dst.SAMLIdentities) >= len(src.SAMLIdentities) {
					dst.SAMLIdentities = (dst.SAMLIdentities)[:len(src.SAMLIdentities)]
				} else {
					dst.SAMLIdentities = make([]ExternalIdentity, len(src.SAMLIdentities))
				}
			} else if len(src.SAMLIdentities) < len(dst.SAMLIdentities) {
				dst.SAMLIdentities = (dst.SAMLIdentities)[:len(src.SAMLIdentities)]
			}
		} else {
			dst.SAMLIdentities = make([]ExternalIdentity, len(src.SAMLIdentities))
		}
		deriveDeepCopy_4(dst.SAMLIdentities, src.SAMLIdentities)
	}
}

// deriveTeleportEqual_1 returns whether this and that are equal.
func deriveTeleportEqual_1(this, that *header.Metadata) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.Name == that.Name &&
			this.Description == that.Description &&
			deriveTeleportEqual_6(this.Labels, that.Labels) &&
			this.Expires.Equal(that.Expires)
}

// deriveTeleportEqual_2 returns whether this and that are equal.
func deriveTeleportEqual_2(this, that []string) bool {
	if this == nil || that == nil {
		return this == nil && that == nil
	}
	if len(this) != len(that) {
		return false
	}
	for i := 0; i < len(this); i++ {
		if !(this[i] == that[i]) {
			return false
		}
	}
	return true
}

// deriveTeleportEqual_3 returns whether this and that are equal.
func deriveTeleportEqual_3(this, that map[string][]string) bool {
	if this == nil || that == nil {
		return this == nil && that == nil
	}
	if len(this) != len(that) {
		return false
	}
	for k, v := range this {
		thatv, ok := that[k]
		if !ok {
			return false
		}
		if !(deriveTeleportEqual_2(v, thatv)) {
			return false
		}
	}
	return true
}

// deriveTeleportEqual_4 returns whether this and that are equal.
func deriveTeleportEqual_4(this, that *ExternalIdentity) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.ConnectorID == that.ConnectorID &&
			this.UserID == that.UserID &&
			this.Username == that.Username &&
			deriveTeleportEqual_2(this.GrantedRoles, that.GrantedRoles) &&
			deriveTeleportEqual_3(this.GrantedTraits, that.GrantedTraits)
}

// deriveTeleportEqual_5 returns whether this and that are equal.
func deriveTeleportEqual_5(this, that []ExternalIdentity) bool {
	if this == nil || that == nil {
		return this == nil && that == nil
	}
	if len(this) != len(that) {
		return false
	}
	for i := 0; i < len(this); i++ {
		if !(deriveTeleportEqual_4(&this[i], &that[i])) {
			return false
		}
	}
	return true
}

// deriveDeepCopy_1 recursively copies the contents of src into dst.
func deriveDeepCopy_1(dst, src *header.Metadata) {
	dst.Name = src.Name
	dst.Description = src.Description
	if src.Labels != nil {
		dst.Labels = make(map[string]string, len(src.Labels))
		deriveDeepCopy_5(dst.Labels, src.Labels)
	} else {
		dst.Labels = nil
	}
	func() {
		field := new(time.Time)
		deriveDeepCopy_6(field, &src.Expires)
		dst.Expires = *field
	}()
	dst.Revision = src.Revision
}

// deriveDeepCopy_2 recursively copies the contents of src into dst.
func deriveDeepCopy_2(dst, src map[string][]string) {
	for src_key, src_value := range src {
		if src_value == nil {
			dst[src_key] = nil
		}
		if src_value == nil {
			dst[src_key] = nil
		} else {
			if dst[src_key] != nil {
				if len(src_value) > len(dst[src_key]) {
					if cap(dst[src_key]) >= len(src_value) {
						dst[src_key] = (dst[src_key])[:len(src_value)]
					} else {
						dst[src_key] = make([]string, len(src_value))
					}
				} else if len(src_value) < len(dst[src_key]) {
					dst[src_key] = (dst[src_key])[:len(src_value)]
				}
			} else {
				dst[src_key] = make([]string, len(src_value))
			}
			copy(dst[src_key], src_value)
		}
	}
}

// deriveDeepCopy_3 recursively copies the contents of src into dst.
func deriveDeepCopy_3(dst, src *ExternalIdentity) {
	dst.ConnectorID = src.ConnectorID
	dst.UserID = src.UserID
	dst.Username = src.Username
	if src.GrantedRoles == nil {
		dst.GrantedRoles = nil
	} else {
		if dst.GrantedRoles != nil {
			if len(src.GrantedRoles) > len(dst.GrantedRoles) {
				if cap(dst.GrantedRoles) >= len(src.GrantedRoles) {
					dst.GrantedRoles = (dst.GrantedRoles)[:len(src.GrantedRoles)]
				} else {
					dst.GrantedRoles = make([]string, len(src.GrantedRoles))
				}
			} else if len(src.GrantedRoles) < len(dst.GrantedRoles) {
				dst.GrantedRoles = (dst.GrantedRoles)[:len(src.GrantedRoles)]
			}
		} else {
			dst.GrantedRoles = make([]string, len(src.GrantedRoles))
		}
		copy(dst.GrantedRoles, src.GrantedRoles)
	}
	if src.GrantedTraits != nil {
		dst.GrantedTraits = make(map[string][]string, len(src.GrantedTraits))
		deriveDeepCopy_2(dst.GrantedTraits, src.GrantedTraits)
	} else {
		dst.GrantedTraits = nil
	}
}

// deriveDeepCopy_4 recursively copies the contents of src into dst.
func deriveDeepCopy_4(dst, src []ExternalIdentity) {
	for src_i, src_value := range src {
		func() {
			field := new(ExternalIdentity)
			deriveDeepCopy_3(field, &src_value)
			dst[src_i] = *field
		}()
	}
}

// deriveTeleportEqual_6 returns whether this and that are equal.
func deriveTeleportEqual_6(this, that map[string]string) bool {
	if this == nil || that == nil {
		return this == nil && that == nil
	}
	if len(this) != len(that) {
		return false
	}
	for k, v := range this {
		thatv, ok := that[k]
		if !ok {
			return false
		}
		if !(v == thatv) {
			return false
		}
	}
	return true
}

// deriveDeepCopy_5 recursively copies the contents of src into dst.
func deriveDeepCopy_5(dst, src map[string]string) {
	for src_key, src_value := range src {
		dst[src_key] = src_value
	}
}

// deriveDeepCopy_6 recursively copies the contents of src into dst.
func deriveDeepCopy_6(dst, src *time.Time) {
	*dst = *src
}
