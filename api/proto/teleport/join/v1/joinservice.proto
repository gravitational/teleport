// Copyright 2025 Gravitational, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package teleport.join.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/gravitational/teleport/api/gen/proto/go/teleport/join/v1;joinv1";

// ClientInit is the first message sent from the client during the join process, it
// holds parameters common to all join methods.
message ClientInit {
  // JoinMethod is the name of the join method that the client is configured to use.
  // This parameter is optional, the client can leave it empty to allow the
  // server to determine the join method based on the provision token named by
  // TokenName, it will be sent to the client in the ServerInit message.
  optional string join_method = 1;
  // TokenName is the name of the join token.
  // This is a secret if using the token join method, otherwise it is a
  // non-secret name of a provision token resource.
  string token_name = 2;
  // SystemRole is the system role requested, e.g. Proxy, Node, Instance, Bot.
  string system_role = 3;
  // ForwardedByProxy will be set to true when the message is forwarded by the
  // Proxy service. When this is set the Auth service must ignore any
  // any credentials authenticating the request, except for the purpose of
  // accepting ProxySuppliedParams.
  bool forwarded_by_proxy = 4;

  // ProxySuppliedParams holds parameters set by the Proxy when nodes join
  // via the proxy address. They must only be trusted if the incoming join
  // request is authenticated as the Proxy.
  message ProxySuppliedParams {
    // RemoteAddr is the remote address of the host requesting a host certificate.
    // It replaces 0.0.0.0 in the list of additional principals.
    string remote_addr = 1;
    // ClientVersion is the Teleport version of the client attempting to join.
    string client_version = 2;
  }
  optional ProxySuppliedParams proxy_supplied_parameters = 5;
}

// PublicKeys holds public keys sent by the client requested subject keys for
// issued certificates.
message PublicKeys {
  // PublicTlsKey is the public key requested for the subject of the x509 certificate.
  // It must be encoded in PKIX, ASN.1 DER form.
  bytes public_tls_key = 1;
  // PublicSshKey is the public key requested for the subject of the SSH certificate.
  // It must be encoded in SSH wire format.
  bytes public_ssh_key = 2;
}

// HostParams holds parameters required for host joining.
message HostParams {
  // PublicKeys holds the host public keys.
  PublicKeys public_keys = 1;
  // HostName is the user-friendly node name for the host. This comes from
  // teleport.nodename in the service configuration and defaults to the
  // hostname. It is encoded as a valid principal in issued certificates.
  string host_name = 2;
  // AdditionalPrincipals is a list of additional principals requested.
  repeated string additional_principals = 3;
  // DnsNames is a list of DNS names requested for inclusion in the x509 certificate.
  repeated string dns_names = 4;
}

// BotParams holds parameters required for bot joining.
message BotParams {
  // PublicKeys holds the bot public keys.
  PublicKeys public_keys = 1;
  // Expires is a desired time of the expiry of the returned certificates.
  optional google.protobuf.Timestamp expires = 2;
}

// ClientParams holds either host or bot join parameters.
message ClientParams {
  oneof payload {
    HostParams host_params = 1;
    BotParams bot_params = 2;
  }
}

// TokenInit is sent by the client in response to the ServerInit message for
// the Token join method.
//
// The Token method join flow is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: TokenInit
// 4. server->client: Result
message TokenInit {
  // ClientParams holds parameters for the specific type of client trying to join.
  ClientParams client_params = 1;
}

// BoundKeypairInit is sent from the client in response to the ServerInit
// message for the bound keypair join method.
// The server is expected to respond with a BoundKeypairChallenge.
//
// The bound keypair method join flow is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: BoundKeypairInit
// 4. server->client: BoundKeypairChallenge
// 5. client->server: BoundKeypairChallengeSolution
//   (optional additional steps if keypair rotation is required)
//   server->client: BoundKeypairRotationRequest
//   client->server: BoundKeypairRotationResponse
//   server->client: BoundKeypairChallenge
//   client->server: BoundKeypairChallengeSolution
// 6. server->client: Result containing BoundKeypairResult
message BoundKeypairInit {
  // ClientParams holds parameters for the specific type of client trying to join.
  ClientParams client_params = 1;
  // If set, attempts to bind a new keypair using an initial join secret.
  // Any value set here will be ignored if a keypair is already bound.
  string initial_join_secret = 2;
  // A document signed by Auth containing join state parameters from the
  // previous join attempt. Not required on initial join; required on all
  // subsequent joins.
  bytes previous_join_state = 3;
}

// BoundKeypairChallenge is a challenge issued by the server that joining
// clients are expected to complete.
// The client is expected to respond with a BoundKeypairChallengeSolution.
message BoundKeypairChallenge {
  // The desired public key corresponding to the private key that should be used
  // to sign this challenge, in SSH authorized keys format.
  bytes public_key = 1;
  // A challenge to sign with the requested public key. During keypair rotation,
  // a second challenge will be provided to verify the new keypair before certs
  // are returned.
  string challenge = 2;
}

// BoundKeypairChallengeSolution is sent from the client in response to the
// BoundKeypairChallenge.
// The server is expected to respond with either a Result or a
// BoundKeypairRotationRequest.
message BoundKeypairChallengeSolution {
  // A solution to a challenge from the server. This generated by signing the
  // challenge as a JWT using the keypair associated with the requested public
  // key.
  bytes solution = 1;
}

// BoundKeypairRotationRequest is sent by the server in response to a
// BoundKeypairChallenge when a keypair rotation is required. It acts like an
// additional challenge, the client is expected to respond with a
// BoundKeypairRotationResponse.
message BoundKeypairRotationRequest {
  // The signature algorithm suite in use by the cluster.
  string signature_algorithm_suite = 1;
}

// BoundKeypairRotationResponse is sent by the client in response to a
// BoundKeypairRotationRequest from the server.
// The server is expected to respond with an additional BoundKeypairChallenge
// for the new key.
message BoundKeypairRotationResponse {
  // The public key to be registered with auth. Clients should expect a
  // subsequent challenge against this public key to be sent. This is encoded in
  // SSH authorized keys format.
  bytes public_key = 1;
}

// BoundKeypairResult holds additional result parameters relevant to the bound
// keypair join method.
message BoundKeypairResult {
  // A signed join state document to be provided on the next join attempt.
  bytes join_state = 2;
  // The public key registered with Auth at the end of the joining ceremony.
  // After a successful keypair rotation, this should reflect the newly
  // registered public key. This is encoded in SSH authorized keys format.
  bytes public_key = 3;
}

// IAMInit is sent from the client in response to the ServerInit message for
// the IAM join method.
//
// The IAM method join flow is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: IAMInit
// 4. server->client: IAMChallenge
// 5. client->server: IAMChallengeSolution
// 6. server->client: Result
message IAMInit {
  // ClientParams holds parameters for the specific type of client trying to join.
  ClientParams client_params = 1;
}

// IAMChallenge is from the server in response to the IAMInit message from the client.
// The client is expected to respond with a IAMChallengeSolution.
message IAMChallenge {
  // Challenge is a a crypto-random string that should be included by the
  // client in the IAMChallengeSolution message.
  string challenge = 1;
}

// IAMChallengeSolution must be sent from the client in response to the
// IAMChallenge message.
message IAMChallengeSolution {
  // STSIdentityRequest is a signed sts:GetCallerIdentity API request used
  // to prove the AWS identity of a joining node. It must include the
  // challenge string as a signed header.
  bytes sts_identity_request = 1;
}

// EC2Init is sent from the client in response to the ServerInit message for
// the EC2 join method.
//
// The EC2 method join flow is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: EC2Init
// 4. server->client: Result
message EC2Init {
  // ClientParams holds parameters for the specific type of client trying to join.
  ClientParams client_params = 1;
  // Document is a signed EC2 Instance Identity Document used to prove the
  // identity of a joining EC2 instance.
  bytes document = 2;
}

// ChallengeSolution holds a solution to a challenge issued by the server.
message ChallengeSolution {
  oneof payload {
    BoundKeypairChallengeSolution bound_keypair_challenge_solution = 1;
    BoundKeypairRotationResponse bound_keypair_rotation_response = 2;
    IAMChallengeSolution iam_challenge_solution = 3;
  }
}

// GivingUp should be sent by clients that fail to complete the join flow so
// that the Auth service can log an informative error message.
message GivingUp {
  // Reason is the reason the client is giving up.
  enum Reason {
    // REASON_UNSPECIFIED is an unspecified reason.
    REASON_UNSPECIFIED = 0;
    // REASON_UNSUPPORTED_JOIN_METHOD means the client does not support the
    // join method sent by the server.
    REASON_UNSUPPORTED_JOIN_METHOD = 1;
    // REASON_UNSUPPORTED_MESSAGE_TYPE means the client can not handle a
    // message type sent by the server.
    REASON_UNSUPPORTED_MESSAGE_TYPE = 2;
    // REASON_CHALLENGE_SOLUTION_FAILED means the client failed to solve a
    // challenge sent by the server.
    REASON_CHALLENGE_SOLUTION_FAILED = 3;
  }
  // Reason is the reason the client is giving up.
  Reason reason = 1;
  // Msg is an error message related to the failure.
  string msg = 2;
}

// JoinRequest is the message type sent from the joining client to the server.
message JoinRequest {
  oneof payload {
    ClientInit client_init = 1;
    TokenInit token_init = 2;
    BoundKeypairInit bound_keypair_init = 3;
    ChallengeSolution solution = 4;
    IAMInit iam_init = 5;
    GivingUp giving_up = 6;
    EC2Init ec2_init = 7;
  }
}

// ServerInit is the first message sent from the server in response to the
// ClientInit message.
message ServerInit {
  // JoinMethod is the name of the selected join method.
  string join_method = 1;
  // SignatureAlgorithmSuite is the name of the signature algorithm suite
  // currently configured for the cluster.
  string signature_algorithm_suite = 2;
}

// Challenge is a challenge message sent from the server that the client must solve.
message Challenge {
  oneof payload {
    BoundKeypairChallenge bound_keypair_challenge = 1;
    BoundKeypairRotationRequest bound_keypair_rotation_request = 2;
    IAMChallenge iam_challenge = 3;
  }
}

// Result is the final message sent from the cluster back to the client, it
// contains the result of the joining process including the assigned host ID
// and issued certificates.
message Result {
  oneof payload {
    HostResult host_result = 1;
    BotResult bot_result = 2;
  }
}

// Certificates holds issued certificates and cluster CAs.
message Certificates {
  // TlsCert is an X.509 certificate encoded in ASN.1 DER form.
  bytes tls_cert = 1;
  // TlsCaCerts is a list of TLS certificate authorities that the client should trust.
  // Each certificate is encoding in ASN.1 DER form.
  repeated bytes tls_ca_certs = 2;
  // SshCert is an SSH certificate encoded in SSH wire format.
  bytes ssh_cert = 3;
  // SshCaKey is a list of SSH certificate authority public keys that the client should trust.
  // Each CA key is encoded in SSH wire format.
  repeated bytes ssh_ca_keys = 4;
}

// HostResult holds results for host joining.
message HostResult {
  // Certificates holds issued certificates and cluster CAs.
  Certificates certificates = 1;
  // HostId is the unique ID assigned to the host.
  string host_id = 2;
}

// HostResult holds results for bot joining.
message BotResult {
  // Certificates holds issued certificates and cluster CAs.
  Certificates certificates = 1;
  // BoundKeypairResult holds extra result parameters relevant to the bound keypair join method.
  optional BoundKeypairResult bound_keypair_result = 2;
}

// JoinResponse is the message type sent from the server to the joining client.
message JoinResponse {
  oneof payload {
    // Init is the initial message sent from the server in response to the
    // ClientInit message. It specifies the join method used by the provision token.
    ServerInit init = 1;
    // Challenge is a challenge issued by the server that the client must solve
    // in order to complete the join flow. The challenge type depends on the join method.
    // Each method may issue zero or more challenges that the client must solve.
    Challenge challenge = 2;
    // Result is the result of the join flow, it is the final message sent from
    // the cluster when the join flow is successful.
    // For the token join method, it is sent immediately in response to the ClientInit request.
    Result result = 3;
  }
}

// JoinService provides methods which allow Teleport nodes, proxies, and other
// services to "join" the Teleport cluster by completing a supported join flow
// in order to receive signed certificates issued by the cluster.
//
// It may be used in multiple cases:
// * Teleport agents joining the cluster on their first start to receive their
//   initial certificates. These requests do not use mTLS and the client
//   authenticates itself using only the join flow and is assigned a new host
//   ID.
// * Teleport agents that need certificates authenticated for an additional
//   system role allowed by a new provision token. These requests must be
//   authenticated with mTLS using their existing certificates so that the
//   existing host ID can be maintained.
// * MachineID bots fetching their initial certificates.
// * MachineID bots refreshing their certificates.
//
// It is implemented on both the Auth and Proxy servers to serve the needs of
// * clients connecting to the proxy address for their initial join when they are
//   unauthenticated and unable to directly dial the auth service.
// * clients connecting to the auth address for their initial join.
// * clients refreshing existing certificates that are able to make an
//   authenticates dial to the auth service via proxy TLS routing.
service JoinService {
  // Join is a bidirectional streaming RPC that implements all join methods.
  // The client does not need to know the join method ahead of time, all it
  // needs is the token name.
  //
  // The client must send an ClientInit message on the JoinRequest stream to
  // initiate the join flow.
  //
  // The server will reply with a ServerInit message, and subsequent messages
  // on the stream will depend on the join method.
  rpc Join(stream JoinRequest) returns (stream JoinResponse);
}
