// Copyright 2025 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

syntax = "proto3";

// This package contains MFA service definitions and messages. Although some messages are similar to those in the legacy
// packages, they are not identical and are not interchangeable because they rely on protojson serialization instead of
// gogoproto.
package teleport.mfa.v2;

import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "teleport/header/v1/metadata.proto";
import "teleport/webauthn/v1/webauthn.proto";

option go_package = "github.com/gravitational/teleport/api/gen/proto/go/teleport/mfa/v2;mfav2";

// MFAService defines the Multi-Factor Authentication (MFA) service. While this service is currently focused on user
// sessions, new MFA related RPCs should be added here instead of the AuthService, to maintain a clear separation of
// concerns instead of further bloating the AuthService.
service MFAService {
  // CreateChallenge creates an MFA challenge that is tied to a user session.
  rpc CreateChallenge(CreateChallengeRequest) returns (CreateChallengeResponse);
  // ValidateChallenge validates the MFA challenge response for a user session and stores the validated response in the
  // backend.
  rpc ValidateChallenge(ValidateChallengeRequest) returns (ValidateChallengeResponse);
  // ReplicateValidatedMFAChallenge replicates a validated MFA challenge to a leaf cluster for retrieval during SSH
  // session establishment. It is a NOOP when used in the root cluster. It is called by the reverse tunnel server when a
  // validated challenge is created for a leaf cluster.
  rpc ReplicateValidatedMFAChallenge(ReplicateValidatedMFAChallengeRequest) returns (ReplicateValidatedMFAChallengeResponse);
  // VerifyValidatedMFAChallenge verifies a previously validated MFA challenge response for a user session. If the
  // challenge does not yet exist, this method will block until the resource appears or until the timeout is reached.
  // The payload is used to verify the challenge is tied to the correct user session. If the verification is successful,
  // the MFA device used for authentication is returned. If the verification fails, an error is returned.
  rpc VerifyValidatedMFAChallenge(VerifyValidatedMFAChallengeRequest) returns (VerifyValidatedMFAChallengeResponse);
}

// SessionIdentifyingPayload contains a value that uniquely identifies a user's session. It must be computed by the
// client from session state and is used to bind MFA challenges to specific sessions.
message SessionIdentifyingPayload {
  oneof payload {
    // session_id is the SSH session hash computed from SSH session state. For example, in Go this would be the value
    // from crypto/ssh#ConnMetadata.SessionID().
    bytes ssh_session_id = 1;
  }
}

// CreateChallengeRequest is the request message for CreateChallenge.
message CreateChallengeRequest {
  // payload is a value that uniquely identifies the user's session. When VerifyValidatedMFAChallenge is called, the
  // server will verify it matches the payload supplied to CreateChallengeRequest.
  SessionIdentifyingPayload payload = 1;
  // target_cluster is the name of the target cluster where the SSH session is being established. If unset, the server
  // assumes the challenge is for the local cluster. This is used to determine where the validated challenge should be
  // replicated to for leaf clusters. It is required when the SSH session is being established in a leaf cluster.
  string target_cluster = 2;
  // sso_client_redirect_url should be supplied if the client supports SSO MFA checks. If unset, the server will only
  // return non-SSO challenges.
  string sso_client_redirect_url = 3;
  // proxy_address_for_sso is the proxy address that the user is using to connect to the Proxy. When using SSO MFA, this
  // address is required to determine which URL to redirect the user to when there are multiple options.
  string proxy_address_for_sso = 4;
}

// CreateChallengeResponse is the response message for CreateChallenge.
message CreateChallengeResponse {
  // name is the unique resource name for the issued challenge generated by the server. This value should be treated as
  // an opaque identifier and used as-is in subsequent API calls.
  string name = 1;
  // mfa_challenge contains the MFA challenge that the user must respond to.
  AuthenticateChallenge mfa_challenge = 2;
}

// ValidateChallengeRequest is the request message for ValidateChallenge.
message ValidateChallengeRequest {
  // name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
  // to tie the validation to the correct challenge.
  string name = 1;
  // mfa_response contains the MFA challenge response provided by the user.
  AuthenticateResponse mfa_response = 2;
}

// ValidateChallengeResponse is the response message for ValidateChallenge.
message ValidateChallengeResponse {}

// ReplicateValidatedMFAChallengeRequest is the request message for ReplicateValidatedMFAChallenge.
message ReplicateValidatedMFAChallengeRequest {
  // name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
  // to tie the upsert to the correct challenge.
  string name = 1;
  // payload is a value that uniquely identifies the user's session. This should match the payload in
  // CreateChallengeRequest.
  SessionIdentifyingPayload payload = 2;
  // device contains information about the user's MFA device used to authenticate.
  Device device = 3;
  // source_cluster is the name of the cluster where the validated challenge originated.
  string source_cluster = 4;
  // target_cluster is the name of the destination cluster where the validated challenge should be replicated to.
  string target_cluster = 5;
}

// ReplicateValidatedMFAChallengeResponse is the response message for ReplicateValidatedMFAChallenge.
message ReplicateValidatedMFAChallengeResponse {
  // replicated_challenge is the validated MFA challenge that was replicated.
  ValidatedMFAChallenge replicated_challenge = 1;
}

// VerifyValidatedMFAChallengeRequest is the request message for VerifyValidatedMFAChallenge.
message VerifyValidatedMFAChallengeRequest {
  // name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
  // to tie the retrieval to the correct challenge.
  string name = 1;
  // payload is a value that uniquely identifies the user's session. The client calling VerifyValidatedMFAChallenge MUST
  // independently compute this value from session state. The server will verify it matches the payload supplied in
  // CreateChallengeRequest to ensure the challenge is tied to the correct session.
  SessionIdentifyingPayload payload = 2;
  // source_cluster is the name of the cluster where the validated challenge originated.
  string source_cluster = 3;
}

// VerifyValidatedMFAChallengeResponse is the response message for VerifyValidatedMFAChallenge.
message VerifyValidatedMFAChallengeResponse {
  // device contains information about the user's MFA device used to authenticate.
  Device device = 1;
}

// AuthenticateChallenge is a challenge for all MFA devices registered for a user.
message AuthenticateChallenge {
  // webauthn_challenge contains a Webauthn credential assertion used for login/authentication ceremonies. Credential
  // assertions hold, among other information, a list of allowed credentials for the ceremony (one for each U2F or
  // Webauthn device registered by the user).
  teleport.webauthn.v1.CredentialAssertion webauthn_challenge = 1;
  // sso_challenge is an SSO MFA challenge. If set, the client can go to the IdP redirect URL to perform an MFA check in
  // the IdP and obtain an MFA token. This token paired with the request id can then be used as MFA verification.
  SSOChallenge sso_challenge = 2;
}

// AuthenticateResponse is a response to AuthenticateChallenge using one of the MFA devices registered for a user.
message AuthenticateResponse {
  oneof response {
    // webauthn is a response to a Webauthn challenge.
    teleport.webauthn.v1.CredentialAssertionResponse webauthn = 1;
    // sso is a response to an SSO challenge.
    SSOChallengeResponse sso = 2;
  }
}

// SSOChallenge contains SSO auth request details to perform an SSO MFA check.
message SSOChallenge {
  // request_id is the ID of an SSO auth request.
  string request_id = 1;
  // redirect_url is an IdP redirect URL to initiate the SSO MFA flow.
  string redirect_url = 2;
  // device is the SSO device corresponding to the challenge.
  SSODevice device = 3;
}

// SSOChallengeResponse is a response to SSOChallenge.
message SSOChallengeResponse {
  // request_id is the ID of an SSO auth request.
  string request_id = 1;
  // token is a secret token used to verify the user's SSO MFA session.
  string token = 2;
}

// ValidatedMFAChallenge represents a validated MFA challenge tied to a user session.
message ValidatedMFAChallenge {
  // The kind of resource represented.
  string kind = 1;
  // Differentiates variations of the same kind. All resources should contain one, even if it is never populated.
  string sub_kind = 2;
  // The version of the resource being represented.
  string version = 3;
  // Common metadata that all resources share.
  teleport.header.v1.Metadata metadata = 4;
  // The validated challenge specification.
  ValidatedMFAChallengeSpec spec = 5;
}

// ValidatedMFAChallengeSpec contains the validated challenge data that is set once during creation and never modified.
message ValidatedMFAChallengeSpec {
  // payload is a value that uniquely identifies the user's session. It is the value that was supplied in
  // CreateChallengeRequest.
  SessionIdentifyingPayload payload = 1;
  // device contains information about the user's MFA device used to authenticate.
  Device device = 2;
  // source_cluster is the name of the cluster where the validated challenge originated.
  string source_cluster = 3;
  // target_cluster is the name of the cluster where the SSH session is being established and this resource is intended
  // for.
  string target_cluster = 4;
}

// Device is a multi-factor authentication device, such as a security key or SSO method.
message Device {
  // Boilerplate for implementing the Resource interface.
  string kind = 1;
  string sub_kind = 2;
  string version = 3;
  teleport.header.v1.Metadata metadata = 4;

  // id is a UUID of this device.
  string id = 5;

  google.protobuf.Timestamp added_at = 6;
  google.protobuf.Timestamp last_used = 7;

  oneof device {
    U2FDevice u2f = 8;
    WebauthnDevice webauthn = 9;
    SSODevice sso = 10;
  }
}

// U2FDevice holds the U2F-specific fields of Device.
message U2FDevice {
  // key_handle uniquely identifies a key on a device
  bytes key_handle = 1;
  // pub_key is a DER encoded ecdsa public key
  bytes pub_key = 2;
  // counter is the latest seen value of the U2F usage counter.
  uint32 counter = 3;
}

// WebauthnDevice holds Webauthn-specific fields of Device.
message WebauthnDevice {
  // credential_id for the authenticator.
  bytes credential_id = 1;
  // public_key_cbor encoded in CBOR format. Webauthn supports various key algorithms; CBOR encoding is used to reflect
  // those choices. See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter reference.
  bytes public_key_cbor = 2;
  // attestation_type used by the authenticator, if any.
  string attestation_type = 3;
  // aaguid is the globally unique identifier of the authenticator model. Zeroed for U2F devices.
  bytes aaguid = 4;
  // signature_counter for login operations. Actual counter values received from the authenticator are expected to be
  // higher than the previously-stored value.
  uint32 signature_counter = 5;
  // attestation_object, as returned by the authentication during registration. Absent for legacy entries (Teleport
  // 8.x).
  bytes attestation_object = 6;
  // resident_key is true if a resident key was requested during registration. Marks passwordless-capable devices. (Note
  // that resident_key=true represents the server-side / Relying Party view of the registration process; the
  // authenticator alone can determine if a key is truly resident.)
  bool resident_key = 7;
  // credential_rp_id used by the credential. Recorded on registration for new credentials, or on first successful
  // authentication for "old" credentials (created before the field existed). Ideally, this is always the same as the
  // configured RPID. If an RPID change does happen, this helps Teleport detect it and react accordingly.
  string credential_rp_id = 8;
  // credential_backup_eligible (Authenticator Backup Eligibility/BE bit), recorded during registration or backfill (for
  // older authenticators). https://w3c.github.io/webauthn/#authdata-flags-be
  google.protobuf.BoolValue credential_backup_eligible = 9;
  // credential_backed_up (Authenticator Backup State/BS bit), recorded during registration or backfill (for older
  // authenticators). https://w3c.github.io/webauthn/#authdata-flags-bs
  google.protobuf.BoolValue credential_backed_up = 10;
}

// SSODevice contains details of an SSO MFA method.
message SSODevice {
  // connector_id is the id of the SSO connector.
  string connector_id = 1;
  // connector_type is the type of the SSO connector.
  string connector_type = 2;
  // display_name is the display name of the SSO connector
  string display_name = 3;
}
