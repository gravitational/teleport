// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package teleport.mfa.v1;

import "gogoproto/gogo.proto";
import "teleport/legacy/types/types.proto";
import "teleport/mfa/v1/challenge.proto";
import "teleport/mfa/v1/validated_challenge.proto";

option go_package = "github.com/gravitational/teleport/api/gen/proto/go/teleport/mfa/v1;mfav1";
option (gogoproto.marshaler_all) = true;
option (gogoproto.unmarshaler_all) = true;

// MFAService defines the Multi-Factor Authentication (MFA) service. While this service is currently focused on user
// sessions, new MFA related RPCs should be added here instead of the AuthService, to maintain a clear separation of
// concerns instead of further bloating the AuthService.
service MFAService {
  // CreateChallenge creates an MFA challenge that is tied to a user session.
  rpc CreateChallenge(CreateChallengeRequest) returns (CreateChallengeResponse);
  // ValidateChallenge validates the MFA challenge response for a user session and stores the validated response in the
  // backend.
  rpc ValidateChallenge(ValidateChallengeRequest) returns (ValidateChallengeResponse);
  // ReplicateValidatedMFAChallenge replicates a validated MFA challenge to a leaf cluster for retrieval during SSH
  // session establishment. It is a NOOP when used in the root cluster. It is called by the reverse tunnel server when a
  // validated challenge is created for a leaf cluster.
  rpc ReplicateValidatedMFAChallenge(ReplicateValidatedMFAChallengeRequest) returns (ReplicateValidatedMFAChallengeResponse);
  // VerifyValidatedMFAChallenge verifies a previously validated MFA challenge response for a user session. If the
  // challenge does not yet exist, this method will block until the resource appears or until the timeout is reached.
  // The payload is used to verify the challenge is tied to the correct user session. If the verification is successful,
  // the MFA device used for authentication is returned. If the verification fails, an error is returned.
  rpc VerifyValidatedMFAChallenge(VerifyValidatedMFAChallengeRequest) returns (VerifyValidatedMFAChallengeResponse);
}

// CreateChallengeRequest is the request message for CreateChallenge.
message CreateChallengeRequest {
  // Value that uniquely identifies the user's session. When VerifyValidatedMFAChallenge is called, the server will
  // verify it matches the payload supplied to CreateChallengeRequest.
  teleport.mfa.v1.SessionIdentifyingPayload payload = 1;
  // Name of the target cluster where the SSH session is being established. If unset, the server assumes the challenge
  // is for the local cluster. Used to determine where the validated challenge should be replicated for leaf clusters.
  // Required when the SSH session is being established in a leaf cluster.
  string target_cluster = 2;
  // SSO client redirect URL, supplied if the client supports SSO MFA checks. If unset, the server will only return
  // non-SSO challenges.
  string sso_client_redirect_url = 3;
  // Proxy address the user is using to connect to the Proxy. Required for SSO MFA to determine which URL to redirect
  // the user to when there are multiple options.
  string proxy_address_for_sso = 4;
}

// CreateChallengeResponse is the response message for CreateChallenge.
message CreateChallengeResponse {
  // Unique resource name for the issued challenge generated by the server. Should be treated as an opaque identifier
  // and used as-is in subsequent API calls.
  string name = 1;
  // MFA challenge that the user must respond to.
  teleport.mfa.v1.AuthenticateChallenge mfa_challenge = 2;
}

// ValidateChallengeRequest is the request message for ValidateChallenge.
message ValidateChallengeRequest {
  // Resource name for the issued challenge. Must match the 'name' returned in CreateChallengeResponse to tie the
  // validation to the correct challenge.
  string name = 1;
  // MFA challenge response provided by the user.
  teleport.mfa.v1.AuthenticateResponse mfa_response = 2;
}

// ValidateChallengeResponse is the response message for ValidateChallenge.
message ValidateChallengeResponse {}

// ReplicateValidatedMFAChallengeRequest is the request message for ReplicateValidatedMFAChallenge.
message ReplicateValidatedMFAChallengeRequest {
  // Resource name for the issued challenge. Must match the 'name' returned in CreateChallengeResponse to tie the upsert
  // to the correct challenge.
  string name = 1;
  // Value that uniquely identifies the user's session. Should match the payload in CreateChallengeRequest.
  SessionIdentifyingPayload payload = 2;
  // Information about the user's MFA device used to authenticate.
  types.MFADevice device = 3;
  // Name of the cluster where the validated challenge originated.
  string source_cluster = 4;
  // Name of the destination cluster where the validated challenge should be replicated to.
  string target_cluster = 5;
}

// ReplicateValidatedMFAChallengeResponse is the response message for ReplicateValidatedMFAChallenge.
message ReplicateValidatedMFAChallengeResponse {
  // Validated MFA challenge that was replicated.
  teleport.mfa.v1.ValidatedMFAChallenge replicated_challenge = 1;
}

// VerifyValidatedMFAChallengeRequest is the request message for VerifyValidatedMFAChallenge.
message VerifyValidatedMFAChallengeRequest {
  // Resource name for the issued challenge. Must match the 'name' returned in CreateChallengeResponse to tie the
  // retrieval to the correct challenge.
  string name = 1;
  // Value that uniquely identifies the user's session. The client calling VerifyValidatedMFAChallenge MUST
  // independently compute this value from session state. The server will verify it matches the payload supplied in
  // CreateChallengeRequest to ensure the challenge is tied to the correct session.
  SessionIdentifyingPayload payload = 2;
  // Name of the cluster where the validated challenge originated.
  string source_cluster = 3;
}

// VerifyValidatedMFAChallengeResponse is the response message for VerifyValidatedMFAChallenge.
message VerifyValidatedMFAChallengeResponse {}
