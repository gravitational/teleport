// Copyright 2023 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

syntax = "proto3";

package teleport.mfa.v1;

import "gogoproto/gogo.proto";
import "teleport/legacy/types/types.proto";
import "teleport/legacy/types/webauthn/webauthn.proto";

option go_package = "github.com/gravitational/teleport/api/gen/proto/go/teleport/mfa/v1;mfav1";
option (gogoproto.marshaler_all) = true;
option (gogoproto.unmarshaler_all) = true;

// ChallengeExtensions contains MFA challenge extensions used by Teleport during MFA authentication.
message ChallengeExtensions {
  // Scope is an authorization scope for this MFA challenge. Required.
  ChallengeScope scope = 1;
  // AllowReuse determines whether the MFA challenge allows reuse. Defaults to CHALLENGE_ALLOW_REUSE_NO.
  //
  // Note that reuse is only permitted for specific actions by the discretion of the server. See the server
  // implementation for details.
  ChallengeAllowReuse allow_reuse = 2;
  // User verification requirement for the challenge.
  //
  // * https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement.
  // * https://pkg.go.dev/github.com/go-webauthn/webauthn/protocol#UserVerificationRequirement.
  //
  // Optional. Empty is equivalent to "discouraged".
  string user_verification_requirement = 3;
}

// ChallengeScope is a scope authorized by an MFA challenge resolution.
enum ChallengeScope {
  // Scope unknown or not specified.
  CHALLENGE_SCOPE_UNSPECIFIED = 0;
  // Standard webauthn login.
  CHALLENGE_SCOPE_LOGIN = 1;
  // Passwordless webauthn login.
  CHALLENGE_SCOPE_PASSWORDLESS_LOGIN = 2;
  // Headless login.
  CHALLENGE_SCOPE_HEADLESS_LOGIN = 3;
  // MFA device management.
  CHALLENGE_SCOPE_MANAGE_DEVICES = 4;
  // Account recovery.
  CHALLENGE_SCOPE_ACCOUNT_RECOVERY = 5;
  // Used for per-session MFA and moderated session presence checks.
  CHALLENGE_SCOPE_USER_SESSION = 6;
  // Used for various administrative actions, such as adding, updating, or deleting administrative resources (users,
  // roles, etc.).
  //
  // Note: this scope should not be used for new MFA capabilities that have more precise scope. Instead, new scopes
  // should be added. This scope may also be split into multiple smaller scopes in the future.
  CHALLENGE_SCOPE_ADMIN_ACTION = 7;
  // Used for changing user's password.
  CHALLENGE_SCOPE_CHANGE_PASSWORD = 8;
}

// ChallengeAllowReuse determines whether an MFA challenge response can be used to authenticate the user more than once
// until the challenge expires.
//
// Reuse is only permitted for specific actions by the discretion of the server. See the server implementation for
// details.
enum ChallengeAllowReuse {
  // Reuse unspecified, treated as CHALLENGE_ALLOW_REUSE_NO.
  CHALLENGE_ALLOW_REUSE_UNSPECIFIED = 0;
  // Reuse is permitted.
  CHALLENGE_ALLOW_REUSE_YES = 1;
  // Reuse is not permitted.
  CHALLENGE_ALLOW_REUSE_NO = 2;
}

// MFAService defines the Multi-Factor Authentication (MFA) service. New MFA related RPCs should be added here instead
// of the AuthService.
service MFAService {
  // CreateChallenge creates an MFA challenge that is tied to a user session.
  rpc CreateChallenge(CreateChallengeRequest) returns (CreateChallengeResponse);
  // ValidateChallenge validates the MFA challenge response for a user session. The client must verify the returned
  // payload matches the expected payload to ensure the response is tied to the correct session.
  rpc ValidateChallenge(ValidateChallengeRequest) returns (ValidateChallengeResponse);
}

// CreateChallengeRequest is the request message for CreateChallenge.
message CreateChallengeRequest {
  // payload is a value that uniquely identifies the user's session. It should be a versioned, encoded blob (e.g.,
  // protobuf, JSON, etc.) computed by the client. The server will store this as ancillary data and return it in
  // ValidateChallengeResponse. It WILL NOT be interpreted by the server. For SSH sessions, this would be the protobuf
  // encoding of teleport.ssh.v1.SessionPayload.
  bytes payload = 1;
  // sso_client_redirect_url should be supplied if the client supports SSO MFA checks. If unset, the server will only
  // return non-SSO challenges.
  string sso_client_redirect_url = 2;
  // proxy_address is the proxy address that the user is using to connect to the Proxy. When using SSO MFA, this address
  // is required to determine which URL to redirect the user to when there are multiple options.
  string proxy_address = 3;
}

// CreateChallengeResponse is the response message for CreateChallenge.
message CreateChallengeResponse {
  // name is the unique resource name for the issued challenge generated by the server. This value should be treated as
  // an opaque identifier and used as-is in subsequent API calls.
  string name = 1;
  // mfa_challenge contains the MFA challenge that the user must respond to.
  AuthenticateChallenge mfa_challenge = 2;
}

// ValidateChallengeRequest is the request message for ValidateChallenge.
message ValidateChallengeRequest {
  // name is the resource name for the issued challenge.
  // This must match the 'name' returned in CreateChallengeResponse to tie the validation to the correct challenge.
  string name = 1;
  // mfa_response contains the MFA challenge response provided by the user.
  AuthenticateResponse mfa_response = 2;
}

// ValidateChallengeResponse is the response message for ValidateChallenge.
message ValidateChallengeResponse {
  // payload is a value that uniquely identifies the user's session. The client calling ValidateChallenge MUST
  // independently compute this value from session state to verify it matches in order to verify the response is tied to
  // the correct user session. For SSH sessions, this would be the protobuf encoding of teleport.ssh.v1.SessionPayload.
  bytes payload = 1;
  // device contains information about the user's MFA device used to authenticate.
  types.MFADevice device = 2;
}

// AuthenticateChallenge is a challenge for all MFA devices registered for a user.
message AuthenticateChallenge {
  // webauthn_challenge contains a Webauthn credential assertion used for login/authentication ceremonies. Credential
  // assertions hold, among other information, a list of allowed credentials for the ceremony (one for each U2F or
  // Webauthn device registered by the user).
  webauthn.CredentialAssertion webauthn_challenge = 1;
  // sso_challenge is an SSO MFA challenge. If set, the client can go to the IdP redirect URL to perform an MFA check in
  // the IdP and obtain an MFA token. This token paired with the request id can then be used as MFA verification.
  SSOChallenge sso_challenge = 2;
}

// AuthenticateResponse is a response to AuthenticateChallenge using one of the MFA devices registered for a user.
message AuthenticateResponse {
  oneof response {
    // webauthn is a response to a Webauthn challenge.
    webauthn.CredentialAssertionResponse webauthn = 1;
    // sso is a response to an SSO challenge.
    SSOChallengeResponse sso = 2;
  }
}

// SSOChallenge contains SSO auth request details to perform an SSO MFA check.
message SSOChallenge {
  // request_id is the ID of an SSO auth request.
  string request_id = 1;
  // redirect_url is an IdP redirect URL to initiate the SSO MFA flow.
  string redirect_url = 2;
  // device is the SSO device corresponding to the challenge.
  types.SSOMFADevice device = 3;
}

// SSOChallengeResponse is a response to SSOChallenge.
message SSOChallengeResponse {
  // request_id is the ID of an SSO auth request.
  string request_id = 1;
  // token is a secret token used to verify the user's SSO MFA session.
  string token = 2;
}
