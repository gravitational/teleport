// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/legacy/client/proto/updaterv2info/updaterv2info.proto

package updaterv2info

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UpdaterStatus int32

const (
	// UPDATER_STATUS_UNSPECIFIED is the zero value.
	UpdaterStatus_UPDATER_STATUS_UNSPECIFIED UpdaterStatus = 0
	// UPDATER_STATUS_OK means that everything looks OK from the agent pov.
	UpdaterStatus_UPDATER_STATUS_OK UpdaterStatus = 1
	// UPDATER_STATUS_DISABLED means that automatic updates seem disabled or paused.
	UpdaterStatus_UPDATER_STATUS_DISABLED UpdaterStatus = 2
	// UPDATER_STATUS_PINNED means that a specific version is pinned.
	UpdaterStatus_UPDATER_STATUS_PINNED UpdaterStatus = 3
	// UPDATER_STATUS_UNREADABLE means that the agent failed to read its update status.
	UpdaterStatus_UPDATER_STATUS_UNREADABLE UpdaterStatus = 4
)

var UpdaterStatus_name = map[int32]string{
	0: "UPDATER_STATUS_UNSPECIFIED",
	1: "UPDATER_STATUS_OK",
	2: "UPDATER_STATUS_DISABLED",
	3: "UPDATER_STATUS_PINNED",
	4: "UPDATER_STATUS_UNREADABLE",
}

var UpdaterStatus_value = map[string]int32{
	"UPDATER_STATUS_UNSPECIFIED": 0,
	"UPDATER_STATUS_OK":          1,
	"UPDATER_STATUS_DISABLED":    2,
	"UPDATER_STATUS_PINNED":      3,
	"UPDATER_STATUS_UNREADABLE":  4,
}

func (x UpdaterStatus) String() string {
	return proto.EnumName(UpdaterStatus_name, int32(x))
}

func (UpdaterStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_713dc40f425b3cc6, []int{0}
}

type UpdaterV2Info struct {
	// UpdateGroup is the update group the agent's updater is part of.
	// The autoupdate_agent_rollout resource controls when different groups update.s
	// Reporting the update group in the Hello allows us to track the update progress per group.
	// See RFD 184 for more details.
	UpdateGroup string `protobuf:"bytes,1,opt,name=UpdateGroup,proto3" json:"UpdateGroup,omitempty"`
	// UpdateUUID is the agent's updater UUID.
	// Each updater has a UUID, this can be used in two cases:
	// - To update individual agents when doing canary updates
	// - To track the lowest non-updated agent to avoid a deadlock when doing a progressive rollout
	UpdateUUID []byte `protobuf:"bytes,2,opt,name=UpdateUUID,proto3" json:"UpdateUUID,omitempty"`
	// UpdaterStatus represents any updater-related status information that the Teleport cluster
	// should be aware of. For example, the fact the updater got disabled, the version pinned,
	// or that the updater seems to not be running.
	UpdaterStatus        UpdaterStatus `protobuf:"varint,3,opt,name=UpdaterStatus,proto3,enum=proto.UpdaterStatus" json:"UpdaterStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdaterV2Info) Reset()         { *m = UpdaterV2Info{} }
func (m *UpdaterV2Info) String() string { return proto.CompactTextString(m) }
func (*UpdaterV2Info) ProtoMessage()    {}
func (*UpdaterV2Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_713dc40f425b3cc6, []int{0}
}
func (m *UpdaterV2Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdaterV2Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdaterV2Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdaterV2Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdaterV2Info.Merge(m, src)
}
func (m *UpdaterV2Info) XXX_Size() int {
	return m.Size()
}
func (m *UpdaterV2Info) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdaterV2Info.DiscardUnknown(m)
}

var xxx_messageInfo_UpdaterV2Info proto.InternalMessageInfo

func (m *UpdaterV2Info) GetUpdateGroup() string {
	if m != nil {
		return m.UpdateGroup
	}
	return ""
}

func (m *UpdaterV2Info) GetUpdateUUID() []byte {
	if m != nil {
		return m.UpdateUUID
	}
	return nil
}

func (m *UpdaterV2Info) GetUpdaterStatus() UpdaterStatus {
	if m != nil {
		return m.UpdaterStatus
	}
	return UpdaterStatus_UPDATER_STATUS_UNSPECIFIED
}

func init() {
	proto.RegisterEnum("proto.UpdaterStatus", UpdaterStatus_name, UpdaterStatus_value)
	proto.RegisterType((*UpdaterV2Info)(nil), "proto.UpdaterV2Info")
}

func init() {
	proto.RegisterFile("teleport/legacy/client/proto/updaterv2info/updaterv2info.proto", fileDescriptor_713dc40f425b3cc6)
}

var fileDescriptor_713dc40f425b3cc6 = []byte{
	// 301 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xb2, 0x2b, 0x49, 0xcd, 0x49,
	0x2d, 0xc8, 0x2f, 0x2a, 0xd1, 0xcf, 0x49, 0x4d, 0x4f, 0x4c, 0xae, 0xd4, 0x4f, 0xce, 0xc9, 0x4c,
	0xcd, 0x2b, 0xd1, 0x2f, 0x28, 0xca, 0x2f, 0xc9, 0xd7, 0x2f, 0x2d, 0x48, 0x49, 0x2c, 0x49, 0x2d,
	0x2a, 0x33, 0xca, 0xcc, 0x4b, 0x43, 0xe3, 0xe9, 0x81, 0x55, 0x08, 0xb1, 0x82, 0x29, 0xa5, 0x5e,
	0x46, 0x2e, 0xde, 0x50, 0x88, 0x74, 0x98, 0x91, 0x67, 0x5e, 0x5a, 0xbe, 0x90, 0x02, 0x17, 0x37,
	0x44, 0xc0, 0xbd, 0x28, 0xbf, 0xb4, 0x40, 0x82, 0x51, 0x81, 0x51, 0x83, 0x33, 0x08, 0x59, 0x48,
	0x48, 0x8e, 0x8b, 0x0b, 0xc2, 0x0d, 0x0d, 0xf5, 0x74, 0x91, 0x60, 0x52, 0x60, 0xd4, 0xe0, 0x09,
	0x42, 0x12, 0x11, 0xb2, 0x82, 0x1b, 0x19, 0x5c, 0x92, 0x58, 0x52, 0x5a, 0x2c, 0xc1, 0xac, 0xc0,
	0xa8, 0xc1, 0x67, 0x24, 0x02, 0xb1, 0x59, 0x0f, 0x45, 0x2e, 0x08, 0x55, 0xa9, 0xd6, 0x5c, 0x46,
	0x34, 0xcd, 0x42, 0x72, 0x5c, 0x52, 0xa1, 0x01, 0x2e, 0x8e, 0x21, 0xae, 0x41, 0xf1, 0xc1, 0x21,
	0x8e, 0x21, 0xa1, 0xc1, 0xf1, 0xa1, 0x7e, 0xc1, 0x01, 0xae, 0xce, 0x9e, 0x6e, 0x9e, 0xae, 0x2e,
	0x02, 0x0c, 0x42, 0xa2, 0x5c, 0x82, 0x68, 0xf2, 0xfe, 0xde, 0x02, 0x8c, 0x42, 0xd2, 0x5c, 0xe2,
	0x68, 0xc2, 0x2e, 0x9e, 0xc1, 0x8e, 0x4e, 0x3e, 0xae, 0x2e, 0x02, 0x4c, 0x42, 0x92, 0x5c, 0xa2,
	0x68, 0x92, 0x01, 0x9e, 0x7e, 0x7e, 0xae, 0x2e, 0x02, 0xcc, 0x42, 0xb2, 0x5c, 0x92, 0x18, 0xd6,
	0x05, 0xb9, 0x3a, 0xba, 0x80, 0xb4, 0x0a, 0xb0, 0x38, 0xf9, 0x9d, 0x78, 0x24, 0xc7, 0x78, 0xe1,
	0x91, 0x1c, 0xe3, 0x83, 0x47, 0x72, 0x8c, 0x51, 0x0e, 0xe9, 0x99, 0x25, 0x19, 0xa5, 0x49, 0x7a,
	0xc9, 0xf9, 0xb9, 0xfa, 0xe9, 0x45, 0x89, 0x65, 0x99, 0x25, 0x89, 0x25, 0x99, 0xf9, 0x79, 0x89,
	0x39, 0xfa, 0xf0, 0xd8, 0x49, 0x2c, 0xc8, 0xc4, 0x13, 0x35, 0x49, 0x6c, 0x60, 0x41, 0x63, 0x40,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x97, 0x6d, 0xa1, 0x5f, 0xcf, 0x01, 0x00, 0x00,
}

func (m *UpdaterV2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdaterV2Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdaterV2Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UpdaterStatus != 0 {
		i = encodeVarintUpdaterv2Info(dAtA, i, uint64(m.UpdaterStatus))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UpdateUUID) > 0 {
		i -= len(m.UpdateUUID)
		copy(dAtA[i:], m.UpdateUUID)
		i = encodeVarintUpdaterv2Info(dAtA, i, uint64(len(m.UpdateUUID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UpdateGroup) > 0 {
		i -= len(m.UpdateGroup)
		copy(dAtA[i:], m.UpdateGroup)
		i = encodeVarintUpdaterv2Info(dAtA, i, uint64(len(m.UpdateGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintUpdaterv2Info(dAtA []byte, offset int, v uint64) int {
	offset -= sovUpdaterv2Info(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UpdaterV2Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UpdateGroup)
	if l > 0 {
		n += 1 + l + sovUpdaterv2Info(uint64(l))
	}
	l = len(m.UpdateUUID)
	if l > 0 {
		n += 1 + l + sovUpdaterv2Info(uint64(l))
	}
	if m.UpdaterStatus != 0 {
		n += 1 + sovUpdaterv2Info(uint64(m.UpdaterStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovUpdaterv2Info(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUpdaterv2Info(x uint64) (n int) {
	return sovUpdaterv2Info(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpdaterV2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUpdaterv2Info
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdaterV2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdaterV2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdaterv2Info
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUpdaterv2Info
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdaterv2Info
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateUUID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdaterv2Info
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUpdaterv2Info
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthUpdaterv2Info
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateUUID = append(m.UpdateUUID[:0], dAtA[iNdEx:postIndex]...)
			if m.UpdateUUID == nil {
				m.UpdateUUID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdaterStatus", wireType)
			}
			m.UpdaterStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUpdaterv2Info
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdaterStatus |= UpdaterStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUpdaterv2Info(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUpdaterv2Info
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUpdaterv2Info(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUpdaterv2Info
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdaterv2Info
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUpdaterv2Info
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUpdaterv2Info
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUpdaterv2Info
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUpdaterv2Info
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUpdaterv2Info        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUpdaterv2Info          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUpdaterv2Info = fmt.Errorf("proto: unexpected end of group")
)
