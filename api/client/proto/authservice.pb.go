// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/legacy/client/proto/authservice.proto

package proto

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	v1 "github.com/gravitational/teleport/api/gen/proto/go/attestation/v1"
	v11 "github.com/gravitational/teleport/api/gen/proto/go/teleport/mfa/v1"
	v12 "github.com/gravitational/teleport/api/gen/proto/go/usageevents/v1"
	github_com_gravitational_teleport_api_types "github.com/gravitational/teleport/api/types"
	types "github.com/gravitational/teleport/api/types"
	events "github.com/gravitational/teleport/api/types/events"
	webauthn "github.com/gravitational/teleport/api/types/webauthn"
	github_com_gravitational_teleport_api_types_wrappers "github.com/gravitational/teleport/api/types/wrappers"
	wrappers "github.com/gravitational/teleport/api/types/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ProductType is the type of product.
type ProductType int32

const (
	ProductType_PRODUCT_TYPE_UNKNOWN ProductType = 0
	// PRODUCT_TYPE_TEAM is Teleport Team product.
	ProductType_PRODUCT_TYPE_TEAM ProductType = 1
	// PRODUCT_TYPE_EUB is Teleport Enterprise Usage Based product.
	ProductType_PRODUCT_TYPE_EUB ProductType = 2
)

var ProductType_name = map[int32]string{
	0: "PRODUCT_TYPE_UNKNOWN",
	1: "PRODUCT_TYPE_TEAM",
	2: "PRODUCT_TYPE_EUB",
}

var ProductType_value = map[string]int32{
	"PRODUCT_TYPE_UNKNOWN": 0,
	"PRODUCT_TYPE_TEAM":    1,
	"PRODUCT_TYPE_EUB":     2,
}

func (x ProductType) String() string {
	return proto.EnumName(ProductType_name, int32(x))
}

func (ProductType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{0}
}

// SupportType if the type of support offered.
type SupportType int32

const (
	SupportType_SUPPORT_TYPE_UNSPECIFIED SupportType = 0
	// SUPPORT_TYPE_FREE is the free tier support
	SupportType_SUPPORT_TYPE_FREE SupportType = 1
	// SUPPORT_TYPE_PREMIUM is the premium tier support
	SupportType_SUPPORT_TYPE_PREMIUM SupportType = 2
)

var SupportType_name = map[int32]string{
	0: "SUPPORT_TYPE_UNSPECIFIED",
	1: "SUPPORT_TYPE_FREE",
	2: "SUPPORT_TYPE_PREMIUM",
}

var SupportType_value = map[string]int32{
	"SUPPORT_TYPE_UNSPECIFIED": 0,
	"SUPPORT_TYPE_FREE":        1,
	"SUPPORT_TYPE_PREMIUM":     2,
}

func (x SupportType) String() string {
	return proto.EnumName(SupportType_name, int32(x))
}

func (SupportType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{1}
}

// DeviceType describes supported MFA device types.
type DeviceType int32

const (
	DeviceType_DEVICE_TYPE_UNSPECIFIED DeviceType = 0
	// TOTP is a Time-based One-Time Password device.
	DeviceType_DEVICE_TYPE_TOTP DeviceType = 1
	// Webauthn is a device compatible with the Web Authentication
	// specification, registered via Webauthn APIs.
	// Supports various kinds of devices: U2F/CTAP1, CTAP2, platform
	// authenticators (Touch ID), etc.
	DeviceType_DEVICE_TYPE_WEBAUTHN DeviceType = 3
)

var DeviceType_name = map[int32]string{
	0: "DEVICE_TYPE_UNSPECIFIED",
	1: "DEVICE_TYPE_TOTP",
	3: "DEVICE_TYPE_WEBAUTHN",
}

var DeviceType_value = map[string]int32{
	"DEVICE_TYPE_UNSPECIFIED": 0,
	"DEVICE_TYPE_TOTP":        1,
	"DEVICE_TYPE_WEBAUTHN":    3,
}

func (x DeviceType) String() string {
	return proto.EnumName(DeviceType_name, int32(x))
}

func (DeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{2}
}

type DeviceUsage int32

const (
	DeviceUsage_DEVICE_USAGE_UNSPECIFIED DeviceUsage = 0
	// Device intended for MFA use, but not for passwordless.
	// Allows both FIDO and FIDO2 devices.
	// Resident keys not required.
	DeviceUsage_DEVICE_USAGE_MFA DeviceUsage = 1
	// Device intended for both MFA and passwordless.
	// Requires a FIDO2 device and takes a resident key slot.
	DeviceUsage_DEVICE_USAGE_PASSWORDLESS DeviceUsage = 2
)

var DeviceUsage_name = map[int32]string{
	0: "DEVICE_USAGE_UNSPECIFIED",
	1: "DEVICE_USAGE_MFA",
	2: "DEVICE_USAGE_PASSWORDLESS",
}

var DeviceUsage_value = map[string]int32{
	"DEVICE_USAGE_UNSPECIFIED":  0,
	"DEVICE_USAGE_MFA":          1,
	"DEVICE_USAGE_PASSWORDLESS": 2,
}

func (x DeviceUsage) String() string {
	return proto.EnumName(DeviceUsage_name, int32(x))
}

func (DeviceUsage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{3}
}

// MFARequired indicates if MFA is required to access a
// resource.
type MFARequired int32

const (
	// Indicates the client/server are either old and don't support
	// checking if MFA is required during the ceremony or that there
	// was a catastrophic error checking RBAC to determine if completing
	// an MFA ceremony will grant access to a resource.
	MFARequired_MFA_REQUIRED_UNSPECIFIED MFARequired = 0
	// Completing an MFA ceremony will grant access to a resource.
	MFARequired_MFA_REQUIRED_YES MFARequired = 1
	// Completing an MFA ceremony will not grant access to a resource.
	MFARequired_MFA_REQUIRED_NO MFARequired = 2
)

var MFARequired_name = map[int32]string{
	0: "MFA_REQUIRED_UNSPECIFIED",
	1: "MFA_REQUIRED_YES",
	2: "MFA_REQUIRED_NO",
}

var MFARequired_value = map[string]int32{
	"MFA_REQUIRED_UNSPECIFIED": 0,
	"MFA_REQUIRED_YES":         1,
	"MFA_REQUIRED_NO":          2,
}

func (x MFARequired) String() string {
	return proto.EnumName(MFARequired_name, int32(x))
}

func (MFARequired) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{4}
}

// Order specifies any ordering of some objects as returned in regards to some aspect
// of said objects which may be trivially ordered such as a timestamp.
type Order int32

const (
	Order_DESCENDING Order = 0
	Order_ASCENDING  Order = 1
)

var Order_name = map[int32]string{
	0: "DESCENDING",
	1: "ASCENDING",
}

var Order_value = map[string]int32{
	"DESCENDING": 0,
	"ASCENDING":  1,
}

func (x Order) String() string {
	return proto.EnumName(Order_name, int32(x))
}

func (Order) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{5}
}

// LabelUpdateKind is the type of service to update labels for.
type LabelUpdateKind int32

const (
	// SSHServer is a label update for an SSH server.
	LabelUpdateKind_SSHServer LabelUpdateKind = 0
	// SSHServerCloudLabels is a label update for an SSH server coming from a
	// cloud provider.
	LabelUpdateKind_SSHServerCloudLabels LabelUpdateKind = 1
)

var LabelUpdateKind_name = map[int32]string{
	0: "SSHServer",
	1: "SSHServerCloudLabels",
}

var LabelUpdateKind_value = map[string]int32{
	"SSHServer":            0,
	"SSHServerCloudLabels": 1,
}

func (x LabelUpdateKind) String() string {
	return proto.EnumName(LabelUpdateKind_name, int32(x))
}

func (LabelUpdateKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{6}
}

// AccessRequestSort determines access request sort index.
type AccessRequestSort int32

const (
	// DEFAULT sorts access requests by their native backend index. this is currently equivalent
	// to sorting by request ID, but that is subject to change.
	AccessRequestSort_DEFAULT AccessRequestSort = 0
	// CREATED sorts access requests by creation time (this is the sort index typically used in
	// user interfaces since most users are looking for recently-created requests).
	AccessRequestSort_CREATED AccessRequestSort = 1
	// STATE sorts access requests by their state (PENDING, APPROVED, etc).
	AccessRequestSort_STATE AccessRequestSort = 2
	// USER sorts access requests by their creator's teleport username
	AccessRequestSort_USER AccessRequestSort = 3
)

var AccessRequestSort_name = map[int32]string{
	0: "DEFAULT",
	1: "CREATED",
	2: "STATE",
	3: "USER",
}

var AccessRequestSort_value = map[string]int32{
	"DEFAULT": 0,
	"CREATED": 1,
	"STATE":   2,
	"USER":    3,
}

func (x AccessRequestSort) String() string {
	return proto.EnumName(AccessRequestSort_name, int32(x))
}

func (AccessRequestSort) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{7}
}

type UserCertsRequest_CertUsage int32

const (
	// All means a request for both SSH and TLS certificates for the
	// overall user session. These certificates are not specific to any SSH
	// node, Kubernetes cluster, database or web app.
	UserCertsRequest_All UserCertsRequest_CertUsage = 0
	// SSH means a request for an SSH certificate for access to a specific
	// SSH node, as specified by NodeName.
	UserCertsRequest_SSH UserCertsRequest_CertUsage = 1
	// Kubernetes means a request for a TLS certificate for access to a
	// specific Kubernetes cluster, as specified by KubernetesCluster.
	UserCertsRequest_Kubernetes UserCertsRequest_CertUsage = 2
	// Database means a request for a TLS certificate for access to a
	// specific database, as specified by RouteToDatabase.
	UserCertsRequest_Database UserCertsRequest_CertUsage = 3
	// App means a request for a TLS certificate for access to a specific
	// web app, as specified by RouteToApp.
	UserCertsRequest_App UserCertsRequest_CertUsage = 4
	// WindowsDesktop means a request for a TLS certificate for access to a specific
	// windows desktop.
	UserCertsRequest_WindowsDesktop UserCertsRequest_CertUsage = 5
)

var UserCertsRequest_CertUsage_name = map[int32]string{
	0: "All",
	1: "SSH",
	2: "Kubernetes",
	3: "Database",
	4: "App",
	5: "WindowsDesktop",
}

var UserCertsRequest_CertUsage_value = map[string]int32{
	"All":            0,
	"SSH":            1,
	"Kubernetes":     2,
	"Database":       3,
	"App":            4,
	"WindowsDesktop": 5,
}

func (x UserCertsRequest_CertUsage) String() string {
	return proto.EnumName(UserCertsRequest_CertUsage_name, int32(x))
}

func (UserCertsRequest_CertUsage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{4, 0}
}

// Requester is the name of the service that sent the request.
type UserCertsRequest_Requester int32

const (
	// UNSPECIFIED is set when the requester in unknown.
	UserCertsRequest_UNSPECIFIED UserCertsRequest_Requester = 0
	// TSH_DB_LOCAL_PROXY_TUNNEL is set when the request was sent by a tsh db local proxy tunnel.
	UserCertsRequest_TSH_DB_LOCAL_PROXY_TUNNEL UserCertsRequest_Requester = 1
	// TSH_KUBE_LOCAL_PROXY is set when the request was sent by a tsh kube local proxy.
	UserCertsRequest_TSH_KUBE_LOCAL_PROXY UserCertsRequest_Requester = 2
	// TSH_KUBE_LOCAL_PROXY_HEADLESS is set when the request was sent by a tsh kube local proxy in headless mode.
	UserCertsRequest_TSH_KUBE_LOCAL_PROXY_HEADLESS UserCertsRequest_Requester = 3
	// TSH_APP_LOCAL_PROXY is set when the request was sent by a tsh app local proxy.
	UserCertsRequest_TSH_APP_LOCAL_PROXY UserCertsRequest_Requester = 4
)

var UserCertsRequest_Requester_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "TSH_DB_LOCAL_PROXY_TUNNEL",
	2: "TSH_KUBE_LOCAL_PROXY",
	3: "TSH_KUBE_LOCAL_PROXY_HEADLESS",
	4: "TSH_APP_LOCAL_PROXY",
}

var UserCertsRequest_Requester_value = map[string]int32{
	"UNSPECIFIED":                   0,
	"TSH_DB_LOCAL_PROXY_TUNNEL":     1,
	"TSH_KUBE_LOCAL_PROXY":          2,
	"TSH_KUBE_LOCAL_PROXY_HEADLESS": 3,
	"TSH_APP_LOCAL_PROXY":           4,
}

func (x UserCertsRequest_Requester) String() string {
	return proto.EnumName(UserCertsRequest_Requester_name, int32(x))
}

func (UserCertsRequest_Requester) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{4, 1}
}

// CertPurpose complements CertUsage by informing Teleport of the intended use
// for the certificates.
type UserCertsRequest_CertPurpose int32

const (
	// Purpose not specified.
	// Interpreted as CERT_PURPOSE_LOGIN_CERTS.
	UserCertsRequest_CERT_PURPOSE_UNSPECIFIED UserCertsRequest_CertPurpose = 0
	// Generate login certificates, both SSH and TLS, as well as CA certs.
	UserCertsRequest_CERT_PURPOSE_LOGIN_CERTS UserCertsRequest_CertPurpose = 1
	// Generate single-user certificates, either SSH or TLS, depending on the
	// specified Usage.
	UserCertsRequest_CERT_PURPOSE_SINGLE_USE_CERTS UserCertsRequest_CertPurpose = 2
)

var UserCertsRequest_CertPurpose_name = map[int32]string{
	0: "CERT_PURPOSE_UNSPECIFIED",
	1: "CERT_PURPOSE_LOGIN_CERTS",
	2: "CERT_PURPOSE_SINGLE_USE_CERTS",
}

var UserCertsRequest_CertPurpose_value = map[string]int32{
	"CERT_PURPOSE_UNSPECIFIED":      0,
	"CERT_PURPOSE_LOGIN_CERTS":      1,
	"CERT_PURPOSE_SINGLE_USE_CERTS": 2,
}

func (x UserCertsRequest_CertPurpose) String() string {
	return proto.EnumName(UserCertsRequest_CertPurpose_name, int32(x))
}

func (UserCertsRequest_CertPurpose) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{4, 2}
}

// Requester is a name of service that sent the request.
type DatabaseCertRequest_Requester int32

const (
	// UNSPECIFIED is set when the requester in unknown.
	DatabaseCertRequest_UNSPECIFIED DatabaseCertRequest_Requester = 0
	// TCTL is set when request was sent by tctl tool.
	DatabaseCertRequest_TCTL DatabaseCertRequest_Requester = 1
)

var DatabaseCertRequest_Requester_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "TCTL",
}

var DatabaseCertRequest_Requester_value = map[string]int32{
	"UNSPECIFIED": 0,
	"TCTL":        1,
}

func (x DatabaseCertRequest_Requester) String() string {
	return proto.EnumName(DatabaseCertRequest_Requester_name, int32(x))
}

func (DatabaseCertRequest_Requester) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{76, 0}
}

// Extensions are the extensions to add to the certificate.
type DatabaseCertRequest_Extensions int32

const (
	// NORMAL is used in all cases except Windows.
	DatabaseCertRequest_NORMAL DatabaseCertRequest_Extensions = 0
	// WINDOWS adds specific required extensions for SQL Server, similar to Desktop Access.
	DatabaseCertRequest_WINDOWS_SMARTCARD DatabaseCertRequest_Extensions = 1
)

var DatabaseCertRequest_Extensions_name = map[int32]string{
	0: "NORMAL",
	1: "WINDOWS_SMARTCARD",
}

var DatabaseCertRequest_Extensions_value = map[string]int32{
	"NORMAL":            0,
	"WINDOWS_SMARTCARD": 1,
}

func (x DatabaseCertRequest_Extensions) String() string {
	return proto.EnumName(DatabaseCertRequest_Extensions_name, int32(x))
}

func (DatabaseCertRequest_Extensions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{76, 1}
}

// Watch specifies watch parameters
type Watch struct {
	// Kinds specifies object kinds to watch
	Kinds                []types.WatchKind `protobuf:"bytes,1,rep,name=Kinds,proto3" json:"kinds,omitempty"`
	AllowPartialSuccess  bool              `protobuf:"varint,2,opt,name=AllowPartialSuccess,proto3" json:"allow_partial_success,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Watch) Reset()         { *m = Watch{} }
func (m *Watch) String() string { return proto.CompactTextString(m) }
func (*Watch) ProtoMessage()    {}
func (*Watch) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{0}
}
func (m *Watch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Watch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Watch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Watch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Watch.Merge(m, src)
}
func (m *Watch) XXX_Size() int {
	return m.Size()
}
func (m *Watch) XXX_DiscardUnknown() {
	xxx_messageInfo_Watch.DiscardUnknown(m)
}

var xxx_messageInfo_Watch proto.InternalMessageInfo

func (m *Watch) GetKinds() []types.WatchKind {
	if m != nil {
		return m.Kinds
	}
	return nil
}

func (m *Watch) GetAllowPartialSuccess() bool {
	if m != nil {
		return m.AllowPartialSuccess
	}
	return false
}

// HostCertsRequest specifies certificate-generation parameters
// for a server.
type HostCertsRequest struct {
	// HostID is a unique ID of the host.
	HostID string `protobuf:"bytes,1,opt,name=HostID,proto3" json:"host_id"`
	// NodeName is a user-friendly host name.
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,proto3" json:"node_name"`
	// Role is a system role assigned to the host.
	Role github_com_gravitational_teleport_api_types.SystemRole `protobuf:"bytes,3,opt,name=Role,proto3,casttype=github.com/gravitational/teleport/api/types.SystemRole" json:"role"`
	// AdditionalPrincipals is a list of additional principals
	// to include in OpenSSH and X509 certificates
	AdditionalPrincipals []string `protobuf:"bytes,4,rep,name=AdditionalPrincipals,proto3" json:"additional_principals,omitempty"`
	// DNSNames is a list of DNS names to include in x509 certificates.
	DNSNames []string `protobuf:"bytes,5,rep,name=DNSNames,proto3" json:"dns_names,omitempty"`
	// PublicTLSKey is a PEM encoded public key, which the auth server will use
	// to create a signed TLS certificate. This field is required.
	PublicTLSKey []byte `protobuf:"bytes,6,opt,name=PublicTLSKey,proto3" json:"public_tls_key"`
	// PublicSSHKey is a SSH encoded public key, which the auth server will use
	// to create a signed SSH certificate. This field is required.
	PublicSSHKey []byte `protobuf:"bytes,7,opt,name=PublicSSHKey,proto3" json:"public_ssh_key"`
	// RemoteAddr is the IP address of the remote host requesting a certificate.
	// RemoteAddr is used to replace 0.0.0.0 in the list of additional principals.
	RemoteAddr string `protobuf:"bytes,8,opt,name=RemoteAddr,proto3" json:"remote_addr"`
	// Rotation allows clients to send the certificate authority rotation state
	// expected by the client so that auth servers can avoid the situation when
	// clients request certs assuming one state and auth servers issue another.
	Rotation *types.Rotation `protobuf:"bytes,9,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// NoCache is argument that only local callers can supply to bypass cache
	NoCache bool `protobuf:"varint,10,opt,name=NoCache,proto3" json:"-"`
	// SystemRoles is a list of system roles held by the host. Most host certs are
	// single-role and only specify the Role field. The SystemRoles field is only
	// currently used on Instance certs, which need to express all roles held by
	// the instance.
	SystemRoles []github_com_gravitational_teleport_api_types.SystemRole `protobuf:"bytes,11,rep,name=SystemRoles,proto3,casttype=github.com/gravitational/teleport/api/types.SystemRole" json:"system_roles,omitempty"`
	// SystemRoleAssertionID is used by agents to prove that they have a given system role when
	// their credentials originate from multiple separate join tokens so that they can be issued
	// an instance certificate that encompasses all of their capabilities. This field will be
	// deprecated once we have a more comprehensive model for join token joining/replacement.
	SystemRoleAssertionID string   `protobuf:"bytes,13,opt,name=SystemRoleAssertionID,proto3" json:"system_role_assertion_id,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *HostCertsRequest) Reset()         { *m = HostCertsRequest{} }
func (m *HostCertsRequest) String() string { return proto.CompactTextString(m) }
func (*HostCertsRequest) ProtoMessage()    {}
func (*HostCertsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{1}
}
func (m *HostCertsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostCertsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HostCertsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HostCertsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostCertsRequest.Merge(m, src)
}
func (m *HostCertsRequest) XXX_Size() int {
	return m.Size()
}
func (m *HostCertsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HostCertsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HostCertsRequest proto.InternalMessageInfo

func (m *HostCertsRequest) GetHostID() string {
	if m != nil {
		return m.HostID
	}
	return ""
}

func (m *HostCertsRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *HostCertsRequest) GetRole() github_com_gravitational_teleport_api_types.SystemRole {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *HostCertsRequest) GetAdditionalPrincipals() []string {
	if m != nil {
		return m.AdditionalPrincipals
	}
	return nil
}

func (m *HostCertsRequest) GetDNSNames() []string {
	if m != nil {
		return m.DNSNames
	}
	return nil
}

func (m *HostCertsRequest) GetPublicTLSKey() []byte {
	if m != nil {
		return m.PublicTLSKey
	}
	return nil
}

func (m *HostCertsRequest) GetPublicSSHKey() []byte {
	if m != nil {
		return m.PublicSSHKey
	}
	return nil
}

func (m *HostCertsRequest) GetRemoteAddr() string {
	if m != nil {
		return m.RemoteAddr
	}
	return ""
}

func (m *HostCertsRequest) GetRotation() *types.Rotation {
	if m != nil {
		return m.Rotation
	}
	return nil
}

func (m *HostCertsRequest) GetNoCache() bool {
	if m != nil {
		return m.NoCache
	}
	return false
}

func (m *HostCertsRequest) GetSystemRoles() []github_com_gravitational_teleport_api_types.SystemRole {
	if m != nil {
		return m.SystemRoles
	}
	return nil
}

func (m *HostCertsRequest) GetSystemRoleAssertionID() string {
	if m != nil {
		return m.SystemRoleAssertionID
	}
	return ""
}

// OpenSSHCertRequest specifies certificate-generation parameters
// for a certificates used to connect to Agentless nodes.
type OpenSSHCertRequest struct {
	// PublicKey is the public key to sign.
	PublicKey []byte `protobuf:"bytes,2,opt,name=PublicKey,proto3" json:"public_key"`
	// TTL is the duration the certificate will be valid for.
	TTL Duration `protobuf:"varint,3,opt,name=TTL,proto3,casttype=Duration" json:"ttl"`
	// Cluster is the Teleport cluster name the target node is connected to.
	Cluster string `protobuf:"bytes,4,opt,name=Cluster,proto3" json:"cluster"`
	// User is the Teleport user the certificate will be generated for.
	User *types.UserV2 `protobuf:"bytes,5,opt,name=User,proto3" json:"user"`
	// Roles are the roles of the Teleport user the certificate will be
	// generated for.
	Roles                []*types.RoleV6 `protobuf:"bytes,6,rep,name=Roles,proto3" json:"roles"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *OpenSSHCertRequest) Reset()         { *m = OpenSSHCertRequest{} }
func (m *OpenSSHCertRequest) String() string { return proto.CompactTextString(m) }
func (*OpenSSHCertRequest) ProtoMessage()    {}
func (*OpenSSHCertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{2}
}
func (m *OpenSSHCertRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSSHCertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSSHCertRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSSHCertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSSHCertRequest.Merge(m, src)
}
func (m *OpenSSHCertRequest) XXX_Size() int {
	return m.Size()
}
func (m *OpenSSHCertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSSHCertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSSHCertRequest proto.InternalMessageInfo

func (m *OpenSSHCertRequest) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *OpenSSHCertRequest) GetTTL() Duration {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *OpenSSHCertRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *OpenSSHCertRequest) GetUser() *types.UserV2 {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *OpenSSHCertRequest) GetRoles() []*types.RoleV6 {
	if m != nil {
		return m.Roles
	}
	return nil
}

// OpenSSHCert is a SSH certificate signed by OpenSSH CA.
type OpenSSHCert struct {
	Cert                 []byte   `protobuf:"bytes,1,opt,name=Cert,proto3" json:"cert"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenSSHCert) Reset()         { *m = OpenSSHCert{} }
func (m *OpenSSHCert) String() string { return proto.CompactTextString(m) }
func (*OpenSSHCert) ProtoMessage()    {}
func (*OpenSSHCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{3}
}
func (m *OpenSSHCert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSSHCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSSHCert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSSHCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSSHCert.Merge(m, src)
}
func (m *OpenSSHCert) XXX_Size() int {
	return m.Size()
}
func (m *OpenSSHCert) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSSHCert.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSSHCert proto.InternalMessageInfo

func (m *OpenSSHCert) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

// UserCertRequest specifies certificate-generation parameters
// for a user.
type UserCertsRequest struct {
	// PublicKey is a public key to be signed.
	//
	// Deprecated: Prefer SSHPublicKey and/or TLSPublicKey.
	PublicKey []byte `protobuf:"bytes,1,opt,name=PublicKey,proto3" json:"public_key"` // Deprecated: Do not use.
	// Username of key owner.
	Username string `protobuf:"bytes,2,opt,name=Username,proto3" json:"username"`
	// Expires is a desired time of the expiry of the certificate, could
	// be adjusted based on the permissions
	Expires time.Time `protobuf:"bytes,3,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// Format encodes the desired SSH Certificate format (either old ssh
	// compatibility
	// format to remove some metadata causing trouble with old SSH servers)
	// or standard SSH cert format with custom extensions
	Format string `protobuf:"bytes,4,opt,name=Format,proto3" json:"format,omitempty"`
	// RouteToCluster is an optional cluster name to add to the certificate,
	// so that requests originating with this certificate will be redirected
	// to this cluster
	RouteToCluster string `protobuf:"bytes,5,opt,name=RouteToCluster,proto3" json:"route_to_cluster,omitempty"`
	// AccessRequests is an optional list of request IDs indicating requests whose
	// escalated privileges should be added to the certificate.
	AccessRequests []string `protobuf:"bytes,6,rep,name=AccessRequests,proto3" json:"access_requests,omitempty"`
	// KubernetesCluster specifies the target kubernetes cluster for TLS
	// identities. This can be empty on older Teleport clients.
	KubernetesCluster string `protobuf:"bytes,7,opt,name=KubernetesCluster,proto3" json:"kubernetes_cluster,omitempty"`
	// RouteToDatabase specifies the target database proxy name to encode into
	// certificate so database client requests are routed appropriately.
	RouteToDatabase RouteToDatabase `protobuf:"bytes,8,opt,name=RouteToDatabase,proto3" json:"route_to_database,omitempty"`
	// NodeName is the name of the SSH node that this user certificate will be
	// scoped to.
	NodeName string `protobuf:"bytes,9,opt,name=NodeName,proto3" json:"node_name,omitempty"`
	// CertUsage limits the resulting user certificate to a single protocol.
	Usage UserCertsRequest_CertUsage `protobuf:"varint,10,opt,name=Usage,proto3,enum=proto.UserCertsRequest_CertUsage" json:"usage,omitempty"`
	// RouteToApp specifies application to issue certificate for.
	RouteToApp RouteToApp `protobuf:"bytes,11,opt,name=RouteToApp,proto3" json:"route_to_app,omitempty"`
	// RoleRequests specify an alternative set of named roles to apply to the
	// certificate, assuming the requestor is allowed to impersonate said roles
	// directly. An empty set of requests returns the user's normal set of
	// roles.
	RoleRequests []string `protobuf:"bytes,12,rep,name=RoleRequests,proto3" json:"role_requests,omitempty"`
	// RouteToWindowsDesktop specifies the target windows desktop name to encode into
	// certificate so windows desktop client requests are routed appropriately.
	RouteToWindowsDesktop RouteToWindowsDesktop `protobuf:"bytes,13,opt,name=RouteToWindowsDesktop,proto3" json:"route_to_windows_desktop,omitempty"`
	// UseRoleRequests is used to ensure a certificate request is intended to
	// use role impersonation, even if the list of role requests is empty.
	UseRoleRequests bool `protobuf:"varint,14,opt,name=UseRoleRequests,proto3" json:"use_role_requests,omitempty"`
	// DropAccessRequests is an optional list of request IDs indicating requests
	// whose escalated privileges should be removed from the certificate.
	// IDs pointing at non-existent requests are ignored.
	//
	// If present, the roles and traits in the generated cert will be based on
	// the state of the user resource on the backend, active requests (not being
	// dropped) and new access requests specified through AccessRequests (if any).
	//
	// This means that technically sending UserCertsRequest with bogus IDs in
	// DropAccessRequests can be used to refresh the role list based on backend
	// state. A better long-term solution would be to add a dedicated field for
	// this to avoid sending bogus IDs.
	DropAccessRequests []string `protobuf:"bytes,15,rep,name=DropAccessRequests,proto3" json:"drop_access_requests,omitempty"`
	// ConnectionDiagnosticID is the ID of the ConnectionDiagnostic resource we should use to add
	// traces as we pass certain checkpoints.
	ConnectionDiagnosticID string `protobuf:"bytes,16,opt,name=ConnectionDiagnosticID,proto3" json:"connection_diagnostic_id,omitempty"`
	// RequesterName identifies who sent the request.
	RequesterName UserCertsRequest_Requester `protobuf:"varint,17,opt,name=RequesterName,proto3,enum=proto.UserCertsRequest_Requester" json:"requester_name"`
	// MFAResponse is a response to a challenge from a user's MFA device.
	// An optional field, that when provided, the response will be validated
	// and the ID of the validated MFA device will be stored in the certificate.
	MFAResponse *MFAAuthenticateResponse `protobuf:"bytes,18,opt,name=MFAResponse,proto3" json:"mfa_response,omitempty"`
	// SSHLogin is the OS Login for the SSH session that the certificate will be used for.
	// This login is used when performing RBAC checks to determine if MFA is required
	// to access the resource.
	SSHLogin string `protobuf:"bytes,19,opt,name=SSHLogin,proto3" json:"SSHLogin,omitempty"`
	// AttestationStatement is an attestation statement for the given public key.
	//
	// Deprecated: prefer SSHPublicKeyAttestationStatement and/or
	// TLSPublicKeyAttestationStatement.
	AttestationStatement *v1.AttestationStatement `protobuf:"bytes,20,opt,name=attestation_statement,json=attestationStatement,proto3" json:"attestation_statement,omitempty"` // Deprecated: Do not use.
	// Purpose is the intended purpose of the certificates.
	Purpose UserCertsRequest_CertPurpose `protobuf:"varint,21,opt,name=Purpose,proto3,enum=proto.UserCertsRequest_CertPurpose" json:"purpose,omitempty"`
	// SSHPublicKey is a public key in SSH authorized_keys format, to be used as
	// the subject for the issued SSH certificate. If omitted, only a TLS cert
	// will be returned.
	SSHPublicKey []byte `protobuf:"bytes,22,opt,name=SSHPublicKey,proto3" json:"ssh_public_key,omitempty"`
	// TLSPublicKey is a public key in PEM-encoded PKCS#1 or PKIX format, to be used as
	// the subject for the issued TLS certificate. If omitted, only an SSH cert
	// will be returned.
	TLSPublicKey []byte `protobuf:"bytes,23,opt,name=TLSPublicKey,proto3" json:"tls_public_key,omitempty"`
	// SSHPublicKeyAttestationStatement is an attestation statement for SSHPublicKey.
	SSHPublicKeyAttestationStatement *v1.AttestationStatement `protobuf:"bytes,25,opt,name=SSHPublicKeyAttestationStatement,proto3" json:"ssh_public_key_attestation_statement,omitempty"`
	// TLSPublicKeyAttestationStatement is an attestation statement for TLSPublicKey.
	TLSPublicKeyAttestationStatement *v1.AttestationStatement `protobuf:"bytes,26,opt,name=TLSPublicKeyAttestationStatement,proto3" json:"tls_public_key_attestation_statement,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}                 `json:"-"`
	XXX_unrecognized                 []byte                   `json:"-"`
	XXX_sizecache                    int32                    `json:"-"`
}

func (m *UserCertsRequest) Reset()         { *m = UserCertsRequest{} }
func (m *UserCertsRequest) String() string { return proto.CompactTextString(m) }
func (*UserCertsRequest) ProtoMessage()    {}
func (*UserCertsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{4}
}
func (m *UserCertsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserCertsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserCertsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserCertsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCertsRequest.Merge(m, src)
}
func (m *UserCertsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UserCertsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCertsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserCertsRequest proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *UserCertsRequest) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *UserCertsRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserCertsRequest) GetExpires() time.Time {
	if m != nil {
		return m.Expires
	}
	return time.Time{}
}

func (m *UserCertsRequest) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *UserCertsRequest) GetRouteToCluster() string {
	if m != nil {
		return m.RouteToCluster
	}
	return ""
}

func (m *UserCertsRequest) GetAccessRequests() []string {
	if m != nil {
		return m.AccessRequests
	}
	return nil
}

func (m *UserCertsRequest) GetKubernetesCluster() string {
	if m != nil {
		return m.KubernetesCluster
	}
	return ""
}

func (m *UserCertsRequest) GetRouteToDatabase() RouteToDatabase {
	if m != nil {
		return m.RouteToDatabase
	}
	return RouteToDatabase{}
}

func (m *UserCertsRequest) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *UserCertsRequest) GetUsage() UserCertsRequest_CertUsage {
	if m != nil {
		return m.Usage
	}
	return UserCertsRequest_All
}

func (m *UserCertsRequest) GetRouteToApp() RouteToApp {
	if m != nil {
		return m.RouteToApp
	}
	return RouteToApp{}
}

func (m *UserCertsRequest) GetRoleRequests() []string {
	if m != nil {
		return m.RoleRequests
	}
	return nil
}

func (m *UserCertsRequest) GetRouteToWindowsDesktop() RouteToWindowsDesktop {
	if m != nil {
		return m.RouteToWindowsDesktop
	}
	return RouteToWindowsDesktop{}
}

func (m *UserCertsRequest) GetUseRoleRequests() bool {
	if m != nil {
		return m.UseRoleRequests
	}
	return false
}

func (m *UserCertsRequest) GetDropAccessRequests() []string {
	if m != nil {
		return m.DropAccessRequests
	}
	return nil
}

func (m *UserCertsRequest) GetConnectionDiagnosticID() string {
	if m != nil {
		return m.ConnectionDiagnosticID
	}
	return ""
}

func (m *UserCertsRequest) GetRequesterName() UserCertsRequest_Requester {
	if m != nil {
		return m.RequesterName
	}
	return UserCertsRequest_UNSPECIFIED
}

func (m *UserCertsRequest) GetMFAResponse() *MFAAuthenticateResponse {
	if m != nil {
		return m.MFAResponse
	}
	return nil
}

func (m *UserCertsRequest) GetSSHLogin() string {
	if m != nil {
		return m.SSHLogin
	}
	return ""
}

// Deprecated: Do not use.
func (m *UserCertsRequest) GetAttestationStatement() *v1.AttestationStatement {
	if m != nil {
		return m.AttestationStatement
	}
	return nil
}

func (m *UserCertsRequest) GetPurpose() UserCertsRequest_CertPurpose {
	if m != nil {
		return m.Purpose
	}
	return UserCertsRequest_CERT_PURPOSE_UNSPECIFIED
}

func (m *UserCertsRequest) GetSSHPublicKey() []byte {
	if m != nil {
		return m.SSHPublicKey
	}
	return nil
}

func (m *UserCertsRequest) GetTLSPublicKey() []byte {
	if m != nil {
		return m.TLSPublicKey
	}
	return nil
}

func (m *UserCertsRequest) GetSSHPublicKeyAttestationStatement() *v1.AttestationStatement {
	if m != nil {
		return m.SSHPublicKeyAttestationStatement
	}
	return nil
}

func (m *UserCertsRequest) GetTLSPublicKeyAttestationStatement() *v1.AttestationStatement {
	if m != nil {
		return m.TLSPublicKeyAttestationStatement
	}
	return nil
}

// RouteToDatabase combines parameters for database service routing information.
type RouteToDatabase struct {
	// ServiceName is the Teleport database proxy service name the cert is for.
	ServiceName string `protobuf:"bytes,1,opt,name=ServiceName,proto3" json:"service_name"`
	// Protocol is the type of the database the cert is for.
	Protocol string `protobuf:"bytes,2,opt,name=Protocol,proto3" json:"protocol"`
	// Username is an optional database username to embed.
	Username string `protobuf:"bytes,3,opt,name=Username,proto3" json:"username,omitempty"`
	// Database is an optional database name to embed.
	Database string `protobuf:"bytes,4,opt,name=Database,proto3" json:"database,omitempty"`
	// Roles is an optional list of database roles to embed.
	Roles                []string `protobuf:"bytes,5,rep,name=Roles,proto3" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteToDatabase) Reset()         { *m = RouteToDatabase{} }
func (m *RouteToDatabase) String() string { return proto.CompactTextString(m) }
func (*RouteToDatabase) ProtoMessage()    {}
func (*RouteToDatabase) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{5}
}
func (m *RouteToDatabase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteToDatabase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteToDatabase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteToDatabase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteToDatabase.Merge(m, src)
}
func (m *RouteToDatabase) XXX_Size() int {
	return m.Size()
}
func (m *RouteToDatabase) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteToDatabase.DiscardUnknown(m)
}

var xxx_messageInfo_RouteToDatabase proto.InternalMessageInfo

func (m *RouteToDatabase) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *RouteToDatabase) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *RouteToDatabase) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *RouteToDatabase) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *RouteToDatabase) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

// RouteToWindowsDesktop combines parameters for windows desktop routing information.
type RouteToWindowsDesktop struct {
	// WindowsDesktop is the Windows Desktop server name to embed.
	WindowsDesktop string `protobuf:"bytes,1,opt,name=WindowsDesktop,proto3" json:"windows_desktop"`
	// Login is the Windows desktop user login to embed.
	Login                string   `protobuf:"bytes,2,opt,name=Login,proto3" json:"login"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteToWindowsDesktop) Reset()         { *m = RouteToWindowsDesktop{} }
func (m *RouteToWindowsDesktop) String() string { return proto.CompactTextString(m) }
func (*RouteToWindowsDesktop) ProtoMessage()    {}
func (*RouteToWindowsDesktop) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{6}
}
func (m *RouteToWindowsDesktop) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteToWindowsDesktop) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteToWindowsDesktop.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteToWindowsDesktop) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteToWindowsDesktop.Merge(m, src)
}
func (m *RouteToWindowsDesktop) XXX_Size() int {
	return m.Size()
}
func (m *RouteToWindowsDesktop) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteToWindowsDesktop.DiscardUnknown(m)
}

var xxx_messageInfo_RouteToWindowsDesktop proto.InternalMessageInfo

func (m *RouteToWindowsDesktop) GetWindowsDesktop() string {
	if m != nil {
		return m.WindowsDesktop
	}
	return ""
}

func (m *RouteToWindowsDesktop) GetLogin() string {
	if m != nil {
		return m.Login
	}
	return ""
}

// RouteToApp contains parameters for application access certificate requests.
type RouteToApp struct {
	// Name is the application name certificate is being requested for.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// SessionID is the ID of the application session.
	// DEPRECATED: Automatically generated by server.
	// TODO (Joerger): DELETE IN v17.0.0
	SessionID string `protobuf:"bytes,2,opt,name=SessionID,proto3" json:"session_id"` // Deprecated: Do not use.
	// PublicAddr is the application public address.
	PublicAddr string `protobuf:"bytes,3,opt,name=PublicAddr,proto3" json:"public_addr"`
	// ClusterName is the cluster where the application resides.
	ClusterName string `protobuf:"bytes,4,opt,name=ClusterName,proto3" json:"cluster_name"`
	// AWSRoleARN is the AWS role to assume when accessing AWS API.
	AWSRoleARN string `protobuf:"bytes,5,opt,name=AWSRoleARN,proto3" json:"aws_role_arn,omitempty"`
	// AzureIdentity is the Azure identity to assume when accessing Azure API.
	AzureIdentity string `protobuf:"bytes,6,opt,name=AzureIdentity,proto3" json:"azure_identity,omitempty"`
	// GCPServiceAccount is the GCP service account to assume when accessing GCP API.
	GCPServiceAccount string `protobuf:"bytes,7,opt,name=GCPServiceAccount,proto3" json:"gcp_service_account,omitempty"`
	// URI is the URI of the app. This is the internal endpoint where the application is running and isn't user-facing.
	URI                  string   `protobuf:"bytes,8,opt,name=URI,proto3" json:"uri,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteToApp) Reset()         { *m = RouteToApp{} }
func (m *RouteToApp) String() string { return proto.CompactTextString(m) }
func (*RouteToApp) ProtoMessage()    {}
func (*RouteToApp) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{7}
}
func (m *RouteToApp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteToApp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteToApp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteToApp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteToApp.Merge(m, src)
}
func (m *RouteToApp) XXX_Size() int {
	return m.Size()
}
func (m *RouteToApp) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteToApp.DiscardUnknown(m)
}

var xxx_messageInfo_RouteToApp proto.InternalMessageInfo

func (m *RouteToApp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Deprecated: Do not use.
func (m *RouteToApp) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func (m *RouteToApp) GetPublicAddr() string {
	if m != nil {
		return m.PublicAddr
	}
	return ""
}

func (m *RouteToApp) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *RouteToApp) GetAWSRoleARN() string {
	if m != nil {
		return m.AWSRoleARN
	}
	return ""
}

func (m *RouteToApp) GetAzureIdentity() string {
	if m != nil {
		return m.AzureIdentity
	}
	return ""
}

func (m *RouteToApp) GetGCPServiceAccount() string {
	if m != nil {
		return m.GCPServiceAccount
	}
	return ""
}

func (m *RouteToApp) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

// GetUserRequest specifies parameters for the GetUser method.
type GetUserRequest struct {
	// Name is the name of the desired user.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// WithSecrets specifies whether to load associated secrets.
	WithSecrets          bool     `protobuf:"varint,2,opt,name=WithSecrets,proto3" json:"with_secrets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserRequest) Reset()         { *m = GetUserRequest{} }
func (m *GetUserRequest) String() string { return proto.CompactTextString(m) }
func (*GetUserRequest) ProtoMessage()    {}
func (*GetUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{8}
}
func (m *GetUserRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserRequest.Merge(m, src)
}
func (m *GetUserRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserRequest proto.InternalMessageInfo

func (m *GetUserRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetUserRequest) GetWithSecrets() bool {
	if m != nil {
		return m.WithSecrets
	}
	return false
}

// GetUsersRequest specifies parameters for the GetUsers method.
type GetUsersRequest struct {
	// WithSecrets specifies whether to load associated secrets.
	WithSecrets          bool     `protobuf:"varint,1,opt,name=WithSecrets,proto3" json:"with_secrets"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUsersRequest) Reset()         { *m = GetUsersRequest{} }
func (m *GetUsersRequest) String() string { return proto.CompactTextString(m) }
func (*GetUsersRequest) ProtoMessage()    {}
func (*GetUsersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{9}
}
func (m *GetUsersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUsersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUsersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUsersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUsersRequest.Merge(m, src)
}
func (m *GetUsersRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUsersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUsersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUsersRequest proto.InternalMessageInfo

func (m *GetUsersRequest) GetWithSecrets() bool {
	if m != nil {
		return m.WithSecrets
	}
	return false
}

// ChangePasswordRequest specifies the parameters for the ChangePassword method.
type ChangePasswordRequest struct {
	User                 string                                `protobuf:"bytes,1,opt,name=User,proto3" json:"name"`
	OldPassword          []byte                                `protobuf:"bytes,2,opt,name=OldPassword,proto3" json:"old_password"`
	NewPassword          []byte                                `protobuf:"bytes,3,opt,name=NewPassword,proto3" json:"new_password"`
	SecondFactorToken    string                                `protobuf:"bytes,4,opt,name=SecondFactorToken,proto3" json:"second_factor_token"`
	Webauthn             *webauthn.CredentialAssertionResponse `protobuf:"bytes,5,opt,name=Webauthn,proto3" json:"webauthn"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ChangePasswordRequest) Reset()         { *m = ChangePasswordRequest{} }
func (m *ChangePasswordRequest) String() string { return proto.CompactTextString(m) }
func (*ChangePasswordRequest) ProtoMessage()    {}
func (*ChangePasswordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{10}
}
func (m *ChangePasswordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePasswordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePasswordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePasswordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePasswordRequest.Merge(m, src)
}
func (m *ChangePasswordRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChangePasswordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePasswordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePasswordRequest proto.InternalMessageInfo

func (m *ChangePasswordRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ChangePasswordRequest) GetOldPassword() []byte {
	if m != nil {
		return m.OldPassword
	}
	return nil
}

func (m *ChangePasswordRequest) GetNewPassword() []byte {
	if m != nil {
		return m.NewPassword
	}
	return nil
}

func (m *ChangePasswordRequest) GetSecondFactorToken() string {
	if m != nil {
		return m.SecondFactorToken
	}
	return ""
}

func (m *ChangePasswordRequest) GetWebauthn() *webauthn.CredentialAssertionResponse {
	if m != nil {
		return m.Webauthn
	}
	return nil
}

// PluginDataSeq is a sequence of plugin data.
type PluginDataSeq struct {
	PluginData           []*types.PluginDataV3 `protobuf:"bytes,1,rep,name=PluginData,proto3" json:"plugin_data"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PluginDataSeq) Reset()         { *m = PluginDataSeq{} }
func (m *PluginDataSeq) String() string { return proto.CompactTextString(m) }
func (*PluginDataSeq) ProtoMessage()    {}
func (*PluginDataSeq) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{11}
}
func (m *PluginDataSeq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginDataSeq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginDataSeq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginDataSeq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginDataSeq.Merge(m, src)
}
func (m *PluginDataSeq) XXX_Size() int {
	return m.Size()
}
func (m *PluginDataSeq) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginDataSeq.DiscardUnknown(m)
}

var xxx_messageInfo_PluginDataSeq proto.InternalMessageInfo

func (m *PluginDataSeq) GetPluginData() []*types.PluginDataV3 {
	if m != nil {
		return m.PluginData
	}
	return nil
}

// RequestStateSetter encodes the parameters necessary to update the
// state of a privilege escalation request.
type RequestStateSetter struct {
	// ID is the request ID being targeted
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"id"`
	// State is the desired state to be set
	State types.RequestState `protobuf:"varint,2,opt,name=State,proto3,enum=types.RequestState" json:"state"`
	// Delegator is an optional indicator of who delegated this
	// state update (used by plugins to indicate which user approved
	// or denied the request).
	Delegator string `protobuf:"bytes,3,opt,name=Delegator,proto3" json:"delegator,omitempty"`
	// Reason is an optional message indicating the reason for the
	// resolution (approval, denail , etc...).
	Reason string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"reason,omitempty"`
	// Annotations are key/value pairs received from plugins during request
	// resolution.  They are currently only used to provide additional logging
	// information.
	Annotations github_com_gravitational_teleport_api_types_wrappers.Traits `protobuf:"bytes,5,opt,name=Annotations,proto3,customtype=github.com/gravitational/teleport/api/types/wrappers.Traits" json:"annotations,omitempty"`
	// Roles, if present, overrides the existing set of roles associated
	// with the access request.
	Roles []string `protobuf:"bytes,6,rep,name=Roles,proto3" json:"roles,omitempty"`
	// AssumeStartTime is the time the requested roles can be assumed.
	AssumeStartTime      *time.Time `protobuf:"bytes,7,opt,name=AssumeStartTime,proto3,stdtime" json:"assume_start_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RequestStateSetter) Reset()         { *m = RequestStateSetter{} }
func (m *RequestStateSetter) String() string { return proto.CompactTextString(m) }
func (*RequestStateSetter) ProtoMessage()    {}
func (*RequestStateSetter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{12}
}
func (m *RequestStateSetter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestStateSetter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestStateSetter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestStateSetter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestStateSetter.Merge(m, src)
}
func (m *RequestStateSetter) XXX_Size() int {
	return m.Size()
}
func (m *RequestStateSetter) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestStateSetter.DiscardUnknown(m)
}

var xxx_messageInfo_RequestStateSetter proto.InternalMessageInfo

func (m *RequestStateSetter) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *RequestStateSetter) GetState() types.RequestState {
	if m != nil {
		return m.State
	}
	return types.RequestState_NONE
}

func (m *RequestStateSetter) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *RequestStateSetter) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RequestStateSetter) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *RequestStateSetter) GetAssumeStartTime() *time.Time {
	if m != nil {
		return m.AssumeStartTime
	}
	return nil
}

// RequestID is the unique identifier of an access request.
type RequestID struct {
	ID                   string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestID) Reset()         { *m = RequestID{} }
func (m *RequestID) String() string { return proto.CompactTextString(m) }
func (*RequestID) ProtoMessage()    {}
func (*RequestID) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{13}
}
func (m *RequestID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestID.Merge(m, src)
}
func (m *RequestID) XXX_Size() int {
	return m.Size()
}
func (m *RequestID) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestID.DiscardUnknown(m)
}

var xxx_messageInfo_RequestID proto.InternalMessageInfo

func (m *RequestID) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// GetResetPasswordTokenRequest is a request to get a reset password token.
type GetResetPasswordTokenRequest struct {
	TokenID              string   `protobuf:"bytes,1,opt,name=TokenID,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetResetPasswordTokenRequest) Reset()         { *m = GetResetPasswordTokenRequest{} }
func (m *GetResetPasswordTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GetResetPasswordTokenRequest) ProtoMessage()    {}
func (*GetResetPasswordTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{14}
}
func (m *GetResetPasswordTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetResetPasswordTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetResetPasswordTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetResetPasswordTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetResetPasswordTokenRequest.Merge(m, src)
}
func (m *GetResetPasswordTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetResetPasswordTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetResetPasswordTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetResetPasswordTokenRequest proto.InternalMessageInfo

func (m *GetResetPasswordTokenRequest) GetTokenID() string {
	if m != nil {
		return m.TokenID
	}
	return ""
}

// CreateResetPasswordTokenRequest is a request to create a reset password token.
type CreateResetPasswordTokenRequest struct {
	// Name is the user name.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Type is a token type.
	Type string `protobuf:"bytes,2,opt,name=Type,proto3" json:"type"`
	// TTL specifies how long the generated token is valid for.
	TTL                  Duration `protobuf:"varint,3,opt,name=TTL,proto3,casttype=Duration" json:"ttl"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateResetPasswordTokenRequest) Reset()         { *m = CreateResetPasswordTokenRequest{} }
func (m *CreateResetPasswordTokenRequest) String() string { return proto.CompactTextString(m) }
func (*CreateResetPasswordTokenRequest) ProtoMessage()    {}
func (*CreateResetPasswordTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{15}
}
func (m *CreateResetPasswordTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateResetPasswordTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateResetPasswordTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateResetPasswordTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateResetPasswordTokenRequest.Merge(m, src)
}
func (m *CreateResetPasswordTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateResetPasswordTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateResetPasswordTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateResetPasswordTokenRequest proto.InternalMessageInfo

func (m *CreateResetPasswordTokenRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateResetPasswordTokenRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CreateResetPasswordTokenRequest) GetTTL() Duration {
	if m != nil {
		return m.TTL
	}
	return 0
}

// RenewableCertsRequest is a request to generate a first set of renewable
// certificates from a bot join token.
type RenewableCertsRequest struct {
	// Token is a bot join token.
	Token string `protobuf:"bytes,1,opt,name=Token,proto3" json:"token"`
	// PublicKey is a public key to be signed.
	PublicKey            []byte   `protobuf:"bytes,2,opt,name=PublicKey,proto3" json:"public_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenewableCertsRequest) Reset()         { *m = RenewableCertsRequest{} }
func (m *RenewableCertsRequest) String() string { return proto.CompactTextString(m) }
func (*RenewableCertsRequest) ProtoMessage()    {}
func (*RenewableCertsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{16}
}
func (m *RenewableCertsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenewableCertsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenewableCertsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenewableCertsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenewableCertsRequest.Merge(m, src)
}
func (m *RenewableCertsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RenewableCertsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RenewableCertsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RenewableCertsRequest proto.InternalMessageInfo

func (m *RenewableCertsRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *RenewableCertsRequest) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// PingRequest is the input value for the Ping method.
type PingRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingRequest) Reset()         { *m = PingRequest{} }
func (m *PingRequest) String() string { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()    {}
func (*PingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{17}
}
func (m *PingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingRequest.Merge(m, src)
}
func (m *PingRequest) XXX_Size() int {
	return m.Size()
}
func (m *PingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PingRequest proto.InternalMessageInfo

// PingResponse contains data about the teleport auth server.
type PingResponse struct {
	// ClusterName is the name of the teleport cluster.
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"cluster_name"`
	// ServerVersion is the version of the auth server.
	ServerVersion string `protobuf:"bytes,2,opt,name=ServerVersion,proto3" json:"server_version"`
	// ServerFeatures are the features supported by the auth server.
	ServerFeatures *Features `protobuf:"bytes,3,opt,name=ServerFeatures,proto3" json:"server_features"`
	// ProxyPublicAddr is the server's public proxy address.
	ProxyPublicAddr string `protobuf:"bytes,4,opt,name=ProxyPublicAddr,proto3" json:"proxy_public_addr"`
	// IsBoring signals whether or not the server was compiled with BoringCrypto.
	IsBoring bool `protobuf:"varint,5,opt,name=IsBoring,proto3" json:"is_boring"`
	// RemoteAddr is the client peer addr as seen from the auth server (used to assist
	// instances in guessing their external IP when none is configured).
	RemoteAddr string `protobuf:"bytes,7,opt,name=RemoteAddr,proto3" json:"remote_addr"`
	// LoadAllCAs signals whether or not tsh should load all CAs when trying
	// to ssh into a node.
	LoadAllCAs           bool     `protobuf:"varint,8,opt,name=LoadAllCAs,proto3" json:"load_all_cas"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingResponse) Reset()         { *m = PingResponse{} }
func (m *PingResponse) String() string { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()    {}
func (*PingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{18}
}
func (m *PingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingResponse.Merge(m, src)
}
func (m *PingResponse) XXX_Size() int {
	return m.Size()
}
func (m *PingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PingResponse proto.InternalMessageInfo

func (m *PingResponse) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *PingResponse) GetServerVersion() string {
	if m != nil {
		return m.ServerVersion
	}
	return ""
}

func (m *PingResponse) GetServerFeatures() *Features {
	if m != nil {
		return m.ServerFeatures
	}
	return nil
}

func (m *PingResponse) GetProxyPublicAddr() string {
	if m != nil {
		return m.ProxyPublicAddr
	}
	return ""
}

func (m *PingResponse) GetIsBoring() bool {
	if m != nil {
		return m.IsBoring
	}
	return false
}

func (m *PingResponse) GetRemoteAddr() string {
	if m != nil {
		return m.RemoteAddr
	}
	return ""
}

func (m *PingResponse) GetLoadAllCAs() bool {
	if m != nil {
		return m.LoadAllCAs
	}
	return false
}

// Features are auth server features.
type Features struct {
	// Kubernetes enables Kubernetes Access product
	// Deprecated remove in v18; leverage entitlements
	Kubernetes bool `protobuf:"varint,1,opt,name=Kubernetes,proto3" json:"kubernetes"`
	// App enables Application Access product
	// Deprecated remove in v18; leverage entitlements
	App bool `protobuf:"varint,2,opt,name=App,proto3" json:"app"`
	// DB enables database access product
	// Deprecated remove in v18; leverage entitlements
	DB bool `protobuf:"varint,3,opt,name=DB,proto3" json:"db"`
	// OIDC enables OIDC connectors
	// Deprecated remove in v18; leverage entitlements
	OIDC bool `protobuf:"varint,4,opt,name=OIDC,proto3" json:"oidc"`
	// SAML enables SAML connectors
	// Deprecated remove in v18; leverage entitlements
	SAML bool `protobuf:"varint,5,opt,name=SAML,proto3" json:"saml"`
	// AccessControls enables FIPS access controls
	AccessControls bool `protobuf:"varint,6,opt,name=AccessControls,proto3" json:"access_controls"`
	// AdvancedAccessWorkflows is currently set to the value of the Cloud AccessRequests entitlement
	AdvancedAccessWorkflows bool `protobuf:"varint,7,opt,name=AdvancedAccessWorkflows,proto3" json:"advanced_access_workflows"`
	// Cloud enables some cloud-related features
	Cloud bool `protobuf:"varint,8,opt,name=Cloud,proto3" json:"cloud"`
	// HSM enables PKCS#11 HSM support
	// Deprecated remove in v18; leverage entitlements
	HSM bool `protobuf:"varint,9,opt,name=HSM,proto3" json:"hsm"`
	// Desktop enables desktop access product
	// Deprecated remove in v18; leverage entitlements
	Desktop bool `protobuf:"varint,10,opt,name=Desktop,proto3" json:"desktop"`
	// RecoveryCodes enables recovery codes
	RecoveryCodes bool `protobuf:"varint,14,opt,name=RecoveryCodes,proto3" json:"recovery_codes"`
	// Plugins enables hosted plugins
	Plugins bool `protobuf:"varint,15,opt,name=Plugins,proto3" json:"plugins"`
	// AutomaticUpgrades enables Automatic Upgrades for the agents/services.
	AutomaticUpgrades bool `protobuf:"varint,16,opt,name=AutomaticUpgrades,proto3" json:"automatic_upgrades"`
	// IsUsageBased enables some usage-based billing features
	IsUsageBased bool `protobuf:"varint,17,opt,name=IsUsageBased,proto3" json:"is_usage_based"`
	// Assist enables the Assistant feature
	// Deprecated remove in v18; leverage entitlements
	Assist bool `protobuf:"varint,18,opt,name=Assist,proto3" json:"assist"`
	// DeviceTrust holds its namesake feature settings.
	// Deprecated remove in v18; leverage entitlements
	DeviceTrust *DeviceTrustFeature `protobuf:"bytes,19,opt,name=DeviceTrust,proto3" json:"device_trust,omitempty"`
	// FeatureHiding enables hiding features from being discoverable for users who don't have the necessary permissions.
	// Deprecated remove in v18; leverage entitlements
	FeatureHiding bool `protobuf:"varint,20,opt,name=FeatureHiding,proto3" json:"feature_hiding,omitempty"`
	// AccessRequests holds its namesake feature settings.
	// Deprecated remove in v18; leverage entitlements
	AccessRequests *AccessRequestsFeature `protobuf:"bytes,21,opt,name=AccessRequests,proto3" json:"access_requests,omitempty"`
	// CustomTheme holds the name of WebUI custom theme.
	CustomTheme string `protobuf:"bytes,22,opt,name=CustomTheme,proto3" json:"custom_theme,omitempty"`
	// IdentityGovernance indicates whether IGS related features are enabled:
	// access list, access request, access monitoring, device trust.
	// Deprecated remove in v18; leverage entitlements
	IdentityGovernance bool `protobuf:"varint,23,opt,name=IdentityGovernance,proto3" json:"identity_governance,omitempty"`
	// AccessGraph enables the usage of access graph.
	// NOTE: this is a legacy flag that is currently used to signal
	// that Access Graph integration is *enabled* on a cluster.
	// *Access* to the feature is gated on the `Policy` flag.
	// TODO(justinas): remove this field once "TAG enabled" status is moved to a resource in the backend.
	AccessGraph bool `protobuf:"varint,24,opt,name=AccessGraph,proto3" json:"access_graph,omitempty"`
	// AccessListFeature holds its namesake feature settings.
	// Deprecated remove in v18; leverage entitlements
	AccessList *AccessListFeature `protobuf:"bytes,25,opt,name=AccessList,proto3" json:"access_list,omitempty"`
	// AccessMonitoringFeature holds its namesake feature settings.
	// Deprecated remove in v18; leverage entitlements for access and AccessMonitoringConfigured for enabled
	AccessMonitoring *AccessMonitoringFeature `protobuf:"bytes,26,opt,name=AccessMonitoring,proto3" json:"access_monitoring,omitempty"`
	// ProductType describes the product being used.
	ProductType ProductType `protobuf:"varint,27,opt,name=ProductType,proto3,enum=proto.ProductType" json:"product_type,omitempty"`
	// Policy enables the Teleport Policy feature set.
	// At the time of writing, this includes Teleport Access Graph (TAG).
	// Deprecated remove in v18; leverage entitlements
	Policy *PolicyFeature `protobuf:"bytes,28,opt,name=Policy,proto3" json:"policy,omitempty"`
	// Questionnaire indicates whether cluster users should get an onboarding questionnaire
	Questionnaire bool `protobuf:"varint,29,opt,name=Questionnaire,proto3" json:"questionnaire,omitempty"`
	// IsStripeManaged indicates if the cluster billing is managed via Stripe
	IsStripeManaged bool `protobuf:"varint,30,opt,name=IsStripeManaged,proto3" json:"is_stripe_managed,omitempty"`
	// ExternalAuditStorage indicates whether the EAS feature is enabled in the cluster.
	// Deprecated remove in v18; leverage entitlements
	ExternalAuditStorage bool `protobuf:"varint,31,opt,name=ExternalAuditStorage,proto3" json:"external_audit_storage,omitempty"`
	// SupportType indicates the type of the customer's support
	SupportType SupportType `protobuf:"varint,32,opt,name=SupportType,proto3,enum=proto.SupportType" json:"support_type,omitempty"`
	// JoinActiveSessions indicates whether joining active sessions via web UI is enabled
	// Deprecated remove in v18; leverage entitlements
	JoinActiveSessions bool `protobuf:"varint,33,opt,name=JoinActiveSessions,proto3" json:"join_active_sessions,omitempty"`
	// MobileDeviceManagement indicates whether endpoint management (like Jamf Plugin) can be used in the cluster
	// Deprecated remove in v18; leverage entitlements
	MobileDeviceManagement bool `protobuf:"varint,34,opt,name=MobileDeviceManagement,proto3" json:"mobile_device_management,omitempty"`
	// entitlements define a customer’s access to a specific features
	Entitlements map[string]*EntitlementInfo `protobuf:"bytes,35,rep,name=entitlements,proto3" json:"entitlements,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AccessMonitoringConfigured contributes to the enablement of access monitoring.
	// NOTE: this flag is used to signal that Access Monitoring is *enabled* on a cluster.
	// *Access* to the feature is gated on the `AccessMonitoring` entitlement.
	AccessMonitoringConfigured bool     `protobuf:"varint,36,opt,name=AccessMonitoringConfigured,proto3" json:"AccessMonitoringConfigured,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *Features) Reset()         { *m = Features{} }
func (m *Features) String() string { return proto.CompactTextString(m) }
func (*Features) ProtoMessage()    {}
func (*Features) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{19}
}
func (m *Features) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Features) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Features.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Features) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Features.Merge(m, src)
}
func (m *Features) XXX_Size() int {
	return m.Size()
}
func (m *Features) XXX_DiscardUnknown() {
	xxx_messageInfo_Features.DiscardUnknown(m)
}

var xxx_messageInfo_Features proto.InternalMessageInfo

func (m *Features) GetKubernetes() bool {
	if m != nil {
		return m.Kubernetes
	}
	return false
}

func (m *Features) GetApp() bool {
	if m != nil {
		return m.App
	}
	return false
}

func (m *Features) GetDB() bool {
	if m != nil {
		return m.DB
	}
	return false
}

func (m *Features) GetOIDC() bool {
	if m != nil {
		return m.OIDC
	}
	return false
}

func (m *Features) GetSAML() bool {
	if m != nil {
		return m.SAML
	}
	return false
}

func (m *Features) GetAccessControls() bool {
	if m != nil {
		return m.AccessControls
	}
	return false
}

func (m *Features) GetAdvancedAccessWorkflows() bool {
	if m != nil {
		return m.AdvancedAccessWorkflows
	}
	return false
}

func (m *Features) GetCloud() bool {
	if m != nil {
		return m.Cloud
	}
	return false
}

func (m *Features) GetHSM() bool {
	if m != nil {
		return m.HSM
	}
	return false
}

func (m *Features) GetDesktop() bool {
	if m != nil {
		return m.Desktop
	}
	return false
}

func (m *Features) GetRecoveryCodes() bool {
	if m != nil {
		return m.RecoveryCodes
	}
	return false
}

func (m *Features) GetPlugins() bool {
	if m != nil {
		return m.Plugins
	}
	return false
}

func (m *Features) GetAutomaticUpgrades() bool {
	if m != nil {
		return m.AutomaticUpgrades
	}
	return false
}

func (m *Features) GetIsUsageBased() bool {
	if m != nil {
		return m.IsUsageBased
	}
	return false
}

func (m *Features) GetAssist() bool {
	if m != nil {
		return m.Assist
	}
	return false
}

func (m *Features) GetDeviceTrust() *DeviceTrustFeature {
	if m != nil {
		return m.DeviceTrust
	}
	return nil
}

func (m *Features) GetFeatureHiding() bool {
	if m != nil {
		return m.FeatureHiding
	}
	return false
}

func (m *Features) GetAccessRequests() *AccessRequestsFeature {
	if m != nil {
		return m.AccessRequests
	}
	return nil
}

func (m *Features) GetCustomTheme() string {
	if m != nil {
		return m.CustomTheme
	}
	return ""
}

func (m *Features) GetIdentityGovernance() bool {
	if m != nil {
		return m.IdentityGovernance
	}
	return false
}

func (m *Features) GetAccessGraph() bool {
	if m != nil {
		return m.AccessGraph
	}
	return false
}

func (m *Features) GetAccessList() *AccessListFeature {
	if m != nil {
		return m.AccessList
	}
	return nil
}

func (m *Features) GetAccessMonitoring() *AccessMonitoringFeature {
	if m != nil {
		return m.AccessMonitoring
	}
	return nil
}

func (m *Features) GetProductType() ProductType {
	if m != nil {
		return m.ProductType
	}
	return ProductType_PRODUCT_TYPE_UNKNOWN
}

func (m *Features) GetPolicy() *PolicyFeature {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *Features) GetQuestionnaire() bool {
	if m != nil {
		return m.Questionnaire
	}
	return false
}

func (m *Features) GetIsStripeManaged() bool {
	if m != nil {
		return m.IsStripeManaged
	}
	return false
}

func (m *Features) GetExternalAuditStorage() bool {
	if m != nil {
		return m.ExternalAuditStorage
	}
	return false
}

func (m *Features) GetSupportType() SupportType {
	if m != nil {
		return m.SupportType
	}
	return SupportType_SUPPORT_TYPE_UNSPECIFIED
}

func (m *Features) GetJoinActiveSessions() bool {
	if m != nil {
		return m.JoinActiveSessions
	}
	return false
}

func (m *Features) GetMobileDeviceManagement() bool {
	if m != nil {
		return m.MobileDeviceManagement
	}
	return false
}

func (m *Features) GetEntitlements() map[string]*EntitlementInfo {
	if m != nil {
		return m.Entitlements
	}
	return nil
}

func (m *Features) GetAccessMonitoringConfigured() bool {
	if m != nil {
		return m.AccessMonitoringConfigured
	}
	return false
}

// EntitlementInfo is the state and limits of a particular entitlement
type EntitlementInfo struct {
	// enabled indicates the feature is 'on' if true
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// limit indicates the allotted amount of use when limited
	Limit                int32    `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EntitlementInfo) Reset()         { *m = EntitlementInfo{} }
func (m *EntitlementInfo) String() string { return proto.CompactTextString(m) }
func (*EntitlementInfo) ProtoMessage()    {}
func (*EntitlementInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{20}
}
func (m *EntitlementInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntitlementInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntitlementInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntitlementInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntitlementInfo.Merge(m, src)
}
func (m *EntitlementInfo) XXX_Size() int {
	return m.Size()
}
func (m *EntitlementInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EntitlementInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EntitlementInfo proto.InternalMessageInfo

func (m *EntitlementInfo) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *EntitlementInfo) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// DeviceTrustFeature holds the Device Trust feature general and usage-based
// settings.
// Limits have no affect if [Features.IdentityGovernance] is enabled.
type DeviceTrustFeature struct {
	// Currently this flag is to gate actions from OSS clusters.
	//
	// Determining support for device trust is currently determined by:
	//   1) Enterprise + [Features.IdentityGovernanceSecurity] == true, new flag
	//   introduced with Enterprise Usage Based (EUB) product.
	//   2) Enterprise + [Features.IsUsageBasedBilling] == false, legacy support
	//   where before EUB, it was unlimited.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Usage-based limit for the number of registered/enrolled devices, at the
	// implementation's discretion.
	DevicesUsageLimit    int32    `protobuf:"varint,2,opt,name=devices_usage_limit,json=devicesUsageLimit,proto3" json:"devices_usage_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceTrustFeature) Reset()         { *m = DeviceTrustFeature{} }
func (m *DeviceTrustFeature) String() string { return proto.CompactTextString(m) }
func (*DeviceTrustFeature) ProtoMessage()    {}
func (*DeviceTrustFeature) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{21}
}
func (m *DeviceTrustFeature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceTrustFeature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceTrustFeature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceTrustFeature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceTrustFeature.Merge(m, src)
}
func (m *DeviceTrustFeature) XXX_Size() int {
	return m.Size()
}
func (m *DeviceTrustFeature) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceTrustFeature.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceTrustFeature proto.InternalMessageInfo

func (m *DeviceTrustFeature) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *DeviceTrustFeature) GetDevicesUsageLimit() int32 {
	if m != nil {
		return m.DevicesUsageLimit
	}
	return 0
}

// AccessRequestsFeature holds the AccessRequest feature general and usage-based
// settings.
// Limits have no affect if [Features.IdentityGovernance] is enabled.
type AccessRequestsFeature struct {
	// Usage-based limit for the number of limit for the number of
	// access requests created in a calendar month.
	MonthlyRequestLimit  int32    `protobuf:"varint,1,opt,name=monthly_request_limit,json=monthlyRequestLimit,proto3" json:"monthly_request_limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessRequestsFeature) Reset()         { *m = AccessRequestsFeature{} }
func (m *AccessRequestsFeature) String() string { return proto.CompactTextString(m) }
func (*AccessRequestsFeature) ProtoMessage()    {}
func (*AccessRequestsFeature) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{22}
}
func (m *AccessRequestsFeature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestsFeature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestsFeature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestsFeature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestsFeature.Merge(m, src)
}
func (m *AccessRequestsFeature) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestsFeature) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestsFeature.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestsFeature proto.InternalMessageInfo

func (m *AccessRequestsFeature) GetMonthlyRequestLimit() int32 {
	if m != nil {
		return m.MonthlyRequestLimit
	}
	return 0
}

// AccessListFeature holds the Access List feature settings.
// Limits have no affect if [Features.IdentityGovernance] is enabled.
type AccessListFeature struct {
	// Limit for the number of access list creatable when feature is
	// not enabled.
	CreateLimit          int32    `protobuf:"varint,1,opt,name=create_limit,json=createLimit,proto3" json:"create_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessListFeature) Reset()         { *m = AccessListFeature{} }
func (m *AccessListFeature) String() string { return proto.CompactTextString(m) }
func (*AccessListFeature) ProtoMessage()    {}
func (*AccessListFeature) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{23}
}
func (m *AccessListFeature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessListFeature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessListFeature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessListFeature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessListFeature.Merge(m, src)
}
func (m *AccessListFeature) XXX_Size() int {
	return m.Size()
}
func (m *AccessListFeature) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessListFeature.DiscardUnknown(m)
}

var xxx_messageInfo_AccessListFeature proto.InternalMessageInfo

func (m *AccessListFeature) GetCreateLimit() int32 {
	if m != nil {
		return m.CreateLimit
	}
	return 0
}

// AccessMonitoringFeature holds the Access Monitoring feature settings.
// Limits have no affect if [Features.IdentityGovernance] is enabled.
type AccessMonitoringFeature struct {
	// True if enabled in the auth service config: [auth_service.access_monitoring.enabled].
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Defines the max number of days to include in an access report.
	MaxReportRangeLimit  int32    `protobuf:"varint,2,opt,name=max_report_range_limit,json=maxReportRangeLimit,proto3" json:"max_report_range_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessMonitoringFeature) Reset()         { *m = AccessMonitoringFeature{} }
func (m *AccessMonitoringFeature) String() string { return proto.CompactTextString(m) }
func (*AccessMonitoringFeature) ProtoMessage()    {}
func (*AccessMonitoringFeature) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{24}
}
func (m *AccessMonitoringFeature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessMonitoringFeature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessMonitoringFeature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessMonitoringFeature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessMonitoringFeature.Merge(m, src)
}
func (m *AccessMonitoringFeature) XXX_Size() int {
	return m.Size()
}
func (m *AccessMonitoringFeature) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessMonitoringFeature.DiscardUnknown(m)
}

var xxx_messageInfo_AccessMonitoringFeature proto.InternalMessageInfo

func (m *AccessMonitoringFeature) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AccessMonitoringFeature) GetMaxReportRangeLimit() int32 {
	if m != nil {
		return m.MaxReportRangeLimit
	}
	return 0
}

// PolicyFeature holds the Teleport Policy feature set settings.
type PolicyFeature struct {
	// True if Teleport Policy is enabled in the license.
	Enabled              bool     `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PolicyFeature) Reset()         { *m = PolicyFeature{} }
func (m *PolicyFeature) String() string { return proto.CompactTextString(m) }
func (*PolicyFeature) ProtoMessage()    {}
func (*PolicyFeature) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{25}
}
func (m *PolicyFeature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyFeature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PolicyFeature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PolicyFeature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyFeature.Merge(m, src)
}
func (m *PolicyFeature) XXX_Size() int {
	return m.Size()
}
func (m *PolicyFeature) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyFeature.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyFeature proto.InternalMessageInfo

func (m *PolicyFeature) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// DeleteUserRequest is the input value for the DeleteUser method.
type DeleteUserRequest struct {
	// Name is the user name to delete.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUserRequest) Reset()         { *m = DeleteUserRequest{} }
func (m *DeleteUserRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteUserRequest) ProtoMessage()    {}
func (*DeleteUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{26}
}
func (m *DeleteUserRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserRequest.Merge(m, src)
}
func (m *DeleteUserRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserRequest proto.InternalMessageInfo

func (m *DeleteUserRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Semaphores is a sequence of Semaphore resources.
type Semaphores struct {
	Semaphores           []*types.SemaphoreV3 `protobuf:"bytes,1,rep,name=Semaphores,proto3" json:"semaphores"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Semaphores) Reset()         { *m = Semaphores{} }
func (m *Semaphores) String() string { return proto.CompactTextString(m) }
func (*Semaphores) ProtoMessage()    {}
func (*Semaphores) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{27}
}
func (m *Semaphores) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Semaphores) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Semaphores.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Semaphores) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Semaphores.Merge(m, src)
}
func (m *Semaphores) XXX_Size() int {
	return m.Size()
}
func (m *Semaphores) XXX_DiscardUnknown() {
	xxx_messageInfo_Semaphores.DiscardUnknown(m)
}

var xxx_messageInfo_Semaphores proto.InternalMessageInfo

func (m *Semaphores) GetSemaphores() []*types.SemaphoreV3 {
	if m != nil {
		return m.Semaphores
	}
	return nil
}

// AuditStreamRequest contains stream request - event or stream control request
type AuditStreamRequest struct {
	// Request is either stream request - create, resume or complete stream
	// or event submitted as a part of the stream
	//
	// Types that are valid to be assigned to Request:
	//	*AuditStreamRequest_CreateStream
	//	*AuditStreamRequest_ResumeStream
	//	*AuditStreamRequest_CompleteStream
	//	*AuditStreamRequest_FlushAndCloseStream
	//	*AuditStreamRequest_Event
	Request              isAuditStreamRequest_Request `protobuf_oneof:"Request"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *AuditStreamRequest) Reset()         { *m = AuditStreamRequest{} }
func (m *AuditStreamRequest) String() string { return proto.CompactTextString(m) }
func (*AuditStreamRequest) ProtoMessage()    {}
func (*AuditStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{28}
}
func (m *AuditStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditStreamRequest.Merge(m, src)
}
func (m *AuditStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuditStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuditStreamRequest proto.InternalMessageInfo

type isAuditStreamRequest_Request interface {
	isAuditStreamRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuditStreamRequest_CreateStream struct {
	CreateStream *CreateStream `protobuf:"bytes,1,opt,name=CreateStream,proto3,oneof" json:"CreateStream,omitempty"`
}
type AuditStreamRequest_ResumeStream struct {
	ResumeStream *ResumeStream `protobuf:"bytes,2,opt,name=ResumeStream,proto3,oneof" json:"ResumeStream,omitempty"`
}
type AuditStreamRequest_CompleteStream struct {
	CompleteStream *CompleteStream `protobuf:"bytes,3,opt,name=CompleteStream,proto3,oneof" json:"CompleteStream,omitempty"`
}
type AuditStreamRequest_FlushAndCloseStream struct {
	FlushAndCloseStream *FlushAndCloseStream `protobuf:"bytes,4,opt,name=FlushAndCloseStream,proto3,oneof" json:"FlushAndCloseStream,omitempty"`
}
type AuditStreamRequest_Event struct {
	Event *events.OneOf `protobuf:"bytes,5,opt,name=Event,proto3,oneof" json:"Event,omitempty"`
}

func (*AuditStreamRequest_CreateStream) isAuditStreamRequest_Request()        {}
func (*AuditStreamRequest_ResumeStream) isAuditStreamRequest_Request()        {}
func (*AuditStreamRequest_CompleteStream) isAuditStreamRequest_Request()      {}
func (*AuditStreamRequest_FlushAndCloseStream) isAuditStreamRequest_Request() {}
func (*AuditStreamRequest_Event) isAuditStreamRequest_Request()               {}

func (m *AuditStreamRequest) GetRequest() isAuditStreamRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *AuditStreamRequest) GetCreateStream() *CreateStream {
	if x, ok := m.GetRequest().(*AuditStreamRequest_CreateStream); ok {
		return x.CreateStream
	}
	return nil
}

func (m *AuditStreamRequest) GetResumeStream() *ResumeStream {
	if x, ok := m.GetRequest().(*AuditStreamRequest_ResumeStream); ok {
		return x.ResumeStream
	}
	return nil
}

func (m *AuditStreamRequest) GetCompleteStream() *CompleteStream {
	if x, ok := m.GetRequest().(*AuditStreamRequest_CompleteStream); ok {
		return x.CompleteStream
	}
	return nil
}

func (m *AuditStreamRequest) GetFlushAndCloseStream() *FlushAndCloseStream {
	if x, ok := m.GetRequest().(*AuditStreamRequest_FlushAndCloseStream); ok {
		return x.FlushAndCloseStream
	}
	return nil
}

func (m *AuditStreamRequest) GetEvent() *events.OneOf {
	if x, ok := m.GetRequest().(*AuditStreamRequest_Event); ok {
		return x.Event
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AuditStreamRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AuditStreamRequest_CreateStream)(nil),
		(*AuditStreamRequest_ResumeStream)(nil),
		(*AuditStreamRequest_CompleteStream)(nil),
		(*AuditStreamRequest_FlushAndCloseStream)(nil),
		(*AuditStreamRequest_Event)(nil),
	}
}

// AuditStreamStatus returns audit stream status
// with corresponding upload ID
type AuditStreamStatus struct {
	// UploadID is upload ID associated with the stream,
	// can be used to resume the stream
	UploadID             string   `protobuf:"bytes,1,opt,name=UploadID,proto3" json:"UploadID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuditStreamStatus) Reset()         { *m = AuditStreamStatus{} }
func (m *AuditStreamStatus) String() string { return proto.CompactTextString(m) }
func (*AuditStreamStatus) ProtoMessage()    {}
func (*AuditStreamStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{29}
}
func (m *AuditStreamStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditStreamStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditStreamStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditStreamStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditStreamStatus.Merge(m, src)
}
func (m *AuditStreamStatus) XXX_Size() int {
	return m.Size()
}
func (m *AuditStreamStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditStreamStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AuditStreamStatus proto.InternalMessageInfo

func (m *AuditStreamStatus) GetUploadID() string {
	if m != nil {
		return m.UploadID
	}
	return ""
}

// CreateStream creates stream for a new session ID
type CreateStream struct {
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"SessionID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateStream) Reset()         { *m = CreateStream{} }
func (m *CreateStream) String() string { return proto.CompactTextString(m) }
func (*CreateStream) ProtoMessage()    {}
func (*CreateStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{30}
}
func (m *CreateStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStream.Merge(m, src)
}
func (m *CreateStream) XXX_Size() int {
	return m.Size()
}
func (m *CreateStream) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStream.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStream proto.InternalMessageInfo

func (m *CreateStream) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// ResumeStream resumes stream that was previously created
type ResumeStream struct {
	// SessionID is a session ID of the stream
	SessionID string `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"SessionID,omitempty"`
	// UploadID is upload ID to resume
	UploadID             string   `protobuf:"bytes,2,opt,name=UploadID,proto3" json:"UploadID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResumeStream) Reset()         { *m = ResumeStream{} }
func (m *ResumeStream) String() string { return proto.CompactTextString(m) }
func (*ResumeStream) ProtoMessage()    {}
func (*ResumeStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{31}
}
func (m *ResumeStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResumeStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResumeStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResumeStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResumeStream.Merge(m, src)
}
func (m *ResumeStream) XXX_Size() int {
	return m.Size()
}
func (m *ResumeStream) XXX_DiscardUnknown() {
	xxx_messageInfo_ResumeStream.DiscardUnknown(m)
}

var xxx_messageInfo_ResumeStream proto.InternalMessageInfo

func (m *ResumeStream) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func (m *ResumeStream) GetUploadID() string {
	if m != nil {
		return m.UploadID
	}
	return ""
}

// CompleteStream completes the stream
// and uploads it to the session server
type CompleteStream struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompleteStream) Reset()         { *m = CompleteStream{} }
func (m *CompleteStream) String() string { return proto.CompactTextString(m) }
func (*CompleteStream) ProtoMessage()    {}
func (*CompleteStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{32}
}
func (m *CompleteStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteStream.Merge(m, src)
}
func (m *CompleteStream) XXX_Size() int {
	return m.Size()
}
func (m *CompleteStream) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteStream.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteStream proto.InternalMessageInfo

// FlushAndCloseStream flushes the stream data and closes the stream
type FlushAndCloseStream struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FlushAndCloseStream) Reset()         { *m = FlushAndCloseStream{} }
func (m *FlushAndCloseStream) String() string { return proto.CompactTextString(m) }
func (*FlushAndCloseStream) ProtoMessage()    {}
func (*FlushAndCloseStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{33}
}
func (m *FlushAndCloseStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlushAndCloseStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlushAndCloseStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlushAndCloseStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlushAndCloseStream.Merge(m, src)
}
func (m *FlushAndCloseStream) XXX_Size() int {
	return m.Size()
}
func (m *FlushAndCloseStream) XXX_DiscardUnknown() {
	xxx_messageInfo_FlushAndCloseStream.DiscardUnknown(m)
}

var xxx_messageInfo_FlushAndCloseStream proto.InternalMessageInfo

// UpsertApplicationServerRequest upserts an app server.
type UpsertApplicationServerRequest struct {
	// Server is an app server resource to register.
	Server               *types.AppServerV3 `protobuf:"bytes,1,opt,name=Server,proto3" json:"server"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *UpsertApplicationServerRequest) Reset()         { *m = UpsertApplicationServerRequest{} }
func (m *UpsertApplicationServerRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertApplicationServerRequest) ProtoMessage()    {}
func (*UpsertApplicationServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{34}
}
func (m *UpsertApplicationServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertApplicationServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertApplicationServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertApplicationServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertApplicationServerRequest.Merge(m, src)
}
func (m *UpsertApplicationServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertApplicationServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertApplicationServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertApplicationServerRequest proto.InternalMessageInfo

func (m *UpsertApplicationServerRequest) GetServer() *types.AppServerV3 {
	if m != nil {
		return m.Server
	}
	return nil
}

// DeleteApplicationServerRequest is a request to delete an app server.
type DeleteApplicationServerRequest struct {
	// Namespace is the app server namespace.
	Namespace string `protobuf:"bytes,1,opt,name=Namespace,proto3" json:"namespace"`
	// HostID is the app server host uuid.
	HostID string `protobuf:"bytes,2,opt,name=HostID,proto3" json:"host_id"`
	// Name is the name of the application to delete.
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteApplicationServerRequest) Reset()         { *m = DeleteApplicationServerRequest{} }
func (m *DeleteApplicationServerRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteApplicationServerRequest) ProtoMessage()    {}
func (*DeleteApplicationServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{35}
}
func (m *DeleteApplicationServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteApplicationServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteApplicationServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteApplicationServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteApplicationServerRequest.Merge(m, src)
}
func (m *DeleteApplicationServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteApplicationServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteApplicationServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteApplicationServerRequest proto.InternalMessageInfo

func (m *DeleteApplicationServerRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DeleteApplicationServerRequest) GetHostID() string {
	if m != nil {
		return m.HostID
	}
	return ""
}

func (m *DeleteApplicationServerRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// DeleteAllApplicationServersRequest are the parameters used to remove all applications.
type DeleteAllApplicationServersRequest struct {
	// Namespace is the app servers namespace.
	Namespace            string   `protobuf:"bytes,1,opt,name=Namespace,proto3" json:"namespace"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAllApplicationServersRequest) Reset()         { *m = DeleteAllApplicationServersRequest{} }
func (m *DeleteAllApplicationServersRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAllApplicationServersRequest) ProtoMessage()    {}
func (*DeleteAllApplicationServersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{36}
}
func (m *DeleteAllApplicationServersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAllApplicationServersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAllApplicationServersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteAllApplicationServersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAllApplicationServersRequest.Merge(m, src)
}
func (m *DeleteAllApplicationServersRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAllApplicationServersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAllApplicationServersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAllApplicationServersRequest proto.InternalMessageInfo

func (m *DeleteAllApplicationServersRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// GenerateAppTokenRequest are the parameters used to request an application
// token.
type GenerateAppTokenRequest struct {
	// Username is the Teleport username.
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	// Roles is a list of Teleport roles assigned to the user.
	Roles []string `protobuf:"bytes,2,rep,name=Roles,proto3" json:"roles"`
	// URI is the URI of the application this token is targeting.
	URI string `protobuf:"bytes,3,opt,name=URI,proto3" json:"uri"`
	// Expires is the time this token expires.
	Expires time.Time `protobuf:"bytes,4,opt,name=Expires,proto3,stdtime" json:"expires"`
	// Traits are the traits assigned to the user within Teleport.
	Traits               map[string]*wrappers.StringValues `protobuf:"bytes,5,rep,name=Traits,proto3" json:"traits" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *GenerateAppTokenRequest) Reset()         { *m = GenerateAppTokenRequest{} }
func (m *GenerateAppTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateAppTokenRequest) ProtoMessage()    {}
func (*GenerateAppTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{37}
}
func (m *GenerateAppTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateAppTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateAppTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateAppTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateAppTokenRequest.Merge(m, src)
}
func (m *GenerateAppTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateAppTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateAppTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateAppTokenRequest proto.InternalMessageInfo

func (m *GenerateAppTokenRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GenerateAppTokenRequest) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *GenerateAppTokenRequest) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *GenerateAppTokenRequest) GetExpires() time.Time {
	if m != nil {
		return m.Expires
	}
	return time.Time{}
}

func (m *GenerateAppTokenRequest) GetTraits() map[string]*wrappers.StringValues {
	if m != nil {
		return m.Traits
	}
	return nil
}

// GenerateAppTokenResponse contains a signed application token.
type GenerateAppTokenResponse struct {
	Token                string   `protobuf:"bytes,1,opt,name=Token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerateAppTokenResponse) Reset()         { *m = GenerateAppTokenResponse{} }
func (m *GenerateAppTokenResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateAppTokenResponse) ProtoMessage()    {}
func (*GenerateAppTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{38}
}
func (m *GenerateAppTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateAppTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateAppTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateAppTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateAppTokenResponse.Merge(m, src)
}
func (m *GenerateAppTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateAppTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateAppTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateAppTokenResponse proto.InternalMessageInfo

func (m *GenerateAppTokenResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// GetAppSessionRequest are the parameters used to request an application web session.
type GetAppSessionRequest struct {
	// SessionID is the ID of the session being requested.
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAppSessionRequest) Reset()         { *m = GetAppSessionRequest{} }
func (m *GetAppSessionRequest) String() string { return proto.CompactTextString(m) }
func (*GetAppSessionRequest) ProtoMessage()    {}
func (*GetAppSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{39}
}
func (m *GetAppSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppSessionRequest.Merge(m, src)
}
func (m *GetAppSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAppSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppSessionRequest proto.InternalMessageInfo

func (m *GetAppSessionRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// GetAppSessionResponse contains the requested application web session.
type GetAppSessionResponse struct {
	// Session is the application web session.
	Session              *types.WebSessionV2 `protobuf:"bytes,1,opt,name=Session,proto3" json:"session"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetAppSessionResponse) Reset()         { *m = GetAppSessionResponse{} }
func (m *GetAppSessionResponse) String() string { return proto.CompactTextString(m) }
func (*GetAppSessionResponse) ProtoMessage()    {}
func (*GetAppSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{40}
}
func (m *GetAppSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppSessionResponse.Merge(m, src)
}
func (m *GetAppSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAppSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppSessionResponse proto.InternalMessageInfo

func (m *GetAppSessionResponse) GetSession() *types.WebSessionV2 {
	if m != nil {
		return m.Session
	}
	return nil
}

// ListAppSessionRequest are the parameters used to request an application web session.
//
// Follows the pagination semantics of
// https://cloud.google.com/apis/design/standard_methods#list.
type ListAppSessionsRequest struct {
	// The maximum number of items to return.
	// The server may impose a different page size at its discretion.
	PageSize int32 `protobuf:"varint,1,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The next_page_token value returned from a previous List request, if any.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Optional username which will filter the returned web sessions
	// to include only those for the given user.
	User                 string   `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAppSessionsRequest) Reset()         { *m = ListAppSessionsRequest{} }
func (m *ListAppSessionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListAppSessionsRequest) ProtoMessage()    {}
func (*ListAppSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{41}
}
func (m *ListAppSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAppSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAppSessionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAppSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAppSessionsRequest.Merge(m, src)
}
func (m *ListAppSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAppSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAppSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAppSessionsRequest proto.InternalMessageInfo

func (m *ListAppSessionsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListAppSessionsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListAppSessionsRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

// ListAppSessionResponse contains the requested application web session.
type ListAppSessionsResponse struct {
	// Sessions for the retrieved page.
	Sessions []*types.WebSessionV2 `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	// Token to retrieve the next page of results, or empty if there are no
	// more results in the list.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAppSessionsResponse) Reset()         { *m = ListAppSessionsResponse{} }
func (m *ListAppSessionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListAppSessionsResponse) ProtoMessage()    {}
func (*ListAppSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{42}
}
func (m *ListAppSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAppSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAppSessionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAppSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAppSessionsResponse.Merge(m, src)
}
func (m *ListAppSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAppSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAppSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAppSessionsResponse proto.InternalMessageInfo

func (m *ListAppSessionsResponse) GetSessions() []*types.WebSessionV2 {
	if m != nil {
		return m.Sessions
	}
	return nil
}

func (m *ListAppSessionsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// GetSnowflakeSessionsResponse contains all the requested Snowflake web sessions.
type GetSnowflakeSessionsResponse struct {
	// Sessions is a list of Snowflake web sessions.
	Sessions             []*types.WebSessionV2 `protobuf:"bytes,1,rep,name=Sessions,proto3" json:"sessions"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GetSnowflakeSessionsResponse) Reset()         { *m = GetSnowflakeSessionsResponse{} }
func (m *GetSnowflakeSessionsResponse) String() string { return proto.CompactTextString(m) }
func (*GetSnowflakeSessionsResponse) ProtoMessage()    {}
func (*GetSnowflakeSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{43}
}
func (m *GetSnowflakeSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSnowflakeSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSnowflakeSessionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSnowflakeSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSnowflakeSessionsResponse.Merge(m, src)
}
func (m *GetSnowflakeSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSnowflakeSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSnowflakeSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSnowflakeSessionsResponse proto.InternalMessageInfo

func (m *GetSnowflakeSessionsResponse) GetSessions() []*types.WebSessionV2 {
	if m != nil {
		return m.Sessions
	}
	return nil
}

// ListSAMLIdPSessionRequest are the parameters used to request a SAML IdP sessions.
//
// Follows the pagination semantics of
// https://cloud.google.com/apis/design/standard_methods#list.
type ListSAMLIdPSessionsRequest struct {
	// The maximum number of items to return.
	// The server may impose a different page size at its discretion.
	PageSize int32 `protobuf:"varint,1,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The next_page_token value returned from a previous List request, if any.
	PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// Optional username which will filter the returned SAML IdP sessions
	// to include only those for the given user.
	User                 string   `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSAMLIdPSessionsRequest) Reset()         { *m = ListSAMLIdPSessionsRequest{} }
func (m *ListSAMLIdPSessionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListSAMLIdPSessionsRequest) ProtoMessage()    {}
func (*ListSAMLIdPSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{44}
}
func (m *ListSAMLIdPSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSAMLIdPSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSAMLIdPSessionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSAMLIdPSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSAMLIdPSessionsRequest.Merge(m, src)
}
func (m *ListSAMLIdPSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListSAMLIdPSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSAMLIdPSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSAMLIdPSessionsRequest proto.InternalMessageInfo

func (m *ListSAMLIdPSessionsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListSAMLIdPSessionsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListSAMLIdPSessionsRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

// ListSAMLIdPSessionsResponse contains all the requested SAML IdP sessions.
type ListSAMLIdPSessionsResponse struct {
	// Sessions for the retrieved page.
	Sessions []*types.WebSessionV2 `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	// Token to retrieve the next page of results, or empty if there are no
	// more results in the list.
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSAMLIdPSessionsResponse) Reset()         { *m = ListSAMLIdPSessionsResponse{} }
func (m *ListSAMLIdPSessionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListSAMLIdPSessionsResponse) ProtoMessage()    {}
func (*ListSAMLIdPSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{45}
}
func (m *ListSAMLIdPSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSAMLIdPSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSAMLIdPSessionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSAMLIdPSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSAMLIdPSessionsResponse.Merge(m, src)
}
func (m *ListSAMLIdPSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListSAMLIdPSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSAMLIdPSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSAMLIdPSessionsResponse proto.InternalMessageInfo

func (m *ListSAMLIdPSessionsResponse) GetSessions() []*types.WebSessionV2 {
	if m != nil {
		return m.Sessions
	}
	return nil
}

func (m *ListSAMLIdPSessionsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// CreateAppSessionRequest contains the parameters to request a application web session.
type CreateAppSessionRequest struct {
	// Username is the name of the user requesting the session.
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	// PublicAddr is the public address the application.
	PublicAddr string `protobuf:"bytes,3,opt,name=PublicAddr,proto3" json:"public_addr"`
	// ClusterName is cluster within which the application is running.
	ClusterName string `protobuf:"bytes,4,opt,name=ClusterName,proto3" json:"cluster_name"`
	// AWSRoleARN is AWS role the user wants to assume.
	AWSRoleARN string `protobuf:"bytes,5,opt,name=AWSRoleARN,proto3" json:"aws_role_arn"`
	// AzureIdentity is Azure identity the user wants to assume.
	AzureIdentity string `protobuf:"bytes,6,opt,name=AzureIdentity,proto3" json:"azure_identity"`
	// GCPServiceAccount is the GCP service account the user wants to assume.
	GCPServiceAccount string `protobuf:"bytes,7,opt,name=GCPServiceAccount,proto3" json:"gcp_service_account"`
	// MFAResponse is a response to a challenge from a user's MFA device.
	// An optional field, that when provided, the response will be validated and
	// the ID of the validated MFA device will be stored in session's certificate.
	MFAResponse *MFAAuthenticateResponse `protobuf:"bytes,8,opt,name=MFAResponse,proto3" json:"mfa_response,omitempty"`
	// AppName is the name of the application.
	AppName string `protobuf:"bytes,9,opt,name=AppName,proto3" json:"app_name"`
	// URI is the URI of the app. This is the internal endpoint where the application is running and isn't user-facing.
	URI string `protobuf:"bytes,10,opt,name=URI,proto3" json:"uri"`
	// ClientAddr is a client (user's) address.
	ClientAddr           string   `protobuf:"bytes,11,opt,name=ClientAddr,proto3" json:"client_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAppSessionRequest) Reset()         { *m = CreateAppSessionRequest{} }
func (m *CreateAppSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CreateAppSessionRequest) ProtoMessage()    {}
func (*CreateAppSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{46}
}
func (m *CreateAppSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAppSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAppSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAppSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAppSessionRequest.Merge(m, src)
}
func (m *CreateAppSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateAppSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAppSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAppSessionRequest proto.InternalMessageInfo

func (m *CreateAppSessionRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CreateAppSessionRequest) GetPublicAddr() string {
	if m != nil {
		return m.PublicAddr
	}
	return ""
}

func (m *CreateAppSessionRequest) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *CreateAppSessionRequest) GetAWSRoleARN() string {
	if m != nil {
		return m.AWSRoleARN
	}
	return ""
}

func (m *CreateAppSessionRequest) GetAzureIdentity() string {
	if m != nil {
		return m.AzureIdentity
	}
	return ""
}

func (m *CreateAppSessionRequest) GetGCPServiceAccount() string {
	if m != nil {
		return m.GCPServiceAccount
	}
	return ""
}

func (m *CreateAppSessionRequest) GetMFAResponse() *MFAAuthenticateResponse {
	if m != nil {
		return m.MFAResponse
	}
	return nil
}

func (m *CreateAppSessionRequest) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *CreateAppSessionRequest) GetURI() string {
	if m != nil {
		return m.URI
	}
	return ""
}

func (m *CreateAppSessionRequest) GetClientAddr() string {
	if m != nil {
		return m.ClientAddr
	}
	return ""
}

// CreateAppSessionResponse contains the requested application web session.
type CreateAppSessionResponse struct {
	// Session is the application web session.
	Session              *types.WebSessionV2 `protobuf:"bytes,1,opt,name=Session,proto3" json:"session"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CreateAppSessionResponse) Reset()         { *m = CreateAppSessionResponse{} }
func (m *CreateAppSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CreateAppSessionResponse) ProtoMessage()    {}
func (*CreateAppSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{47}
}
func (m *CreateAppSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAppSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAppSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAppSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAppSessionResponse.Merge(m, src)
}
func (m *CreateAppSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateAppSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAppSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAppSessionResponse proto.InternalMessageInfo

func (m *CreateAppSessionResponse) GetSession() *types.WebSessionV2 {
	if m != nil {
		return m.Session
	}
	return nil
}

// CreateSnowflakeSessionRequest contains data required to create Snowflake web session.
type CreateSnowflakeSessionRequest struct {
	// Username is the name of the user requesting the session.
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	// SessionToken is the Snowflake server session token.
	SessionToken string `protobuf:"bytes,2,opt,name=SessionToken,proto3" json:"session_token"`
	// TokenTTL is the token validity period.
	TokenTTL             Duration `protobuf:"varint,3,opt,name=TokenTTL,proto3,casttype=Duration" json:"token_ttl"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateSnowflakeSessionRequest) Reset()         { *m = CreateSnowflakeSessionRequest{} }
func (m *CreateSnowflakeSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSnowflakeSessionRequest) ProtoMessage()    {}
func (*CreateSnowflakeSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{48}
}
func (m *CreateSnowflakeSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSnowflakeSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSnowflakeSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSnowflakeSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSnowflakeSessionRequest.Merge(m, src)
}
func (m *CreateSnowflakeSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSnowflakeSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSnowflakeSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSnowflakeSessionRequest proto.InternalMessageInfo

func (m *CreateSnowflakeSessionRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CreateSnowflakeSessionRequest) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *CreateSnowflakeSessionRequest) GetTokenTTL() Duration {
	if m != nil {
		return m.TokenTTL
	}
	return 0
}

// CreateSnowflakeSessionResponse contains Snowflake WebSession.
type CreateSnowflakeSessionResponse struct {
	Session              *types.WebSessionV2 `protobuf:"bytes,1,opt,name=Session,proto3" json:"session"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CreateSnowflakeSessionResponse) Reset()         { *m = CreateSnowflakeSessionResponse{} }
func (m *CreateSnowflakeSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CreateSnowflakeSessionResponse) ProtoMessage()    {}
func (*CreateSnowflakeSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{49}
}
func (m *CreateSnowflakeSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSnowflakeSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSnowflakeSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSnowflakeSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSnowflakeSessionResponse.Merge(m, src)
}
func (m *CreateSnowflakeSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateSnowflakeSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSnowflakeSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSnowflakeSessionResponse proto.InternalMessageInfo

func (m *CreateSnowflakeSessionResponse) GetSession() *types.WebSessionV2 {
	if m != nil {
		return m.Session
	}
	return nil
}

// CreateSAMLIdPSessionRequest contains data required to create a SAML IdP session.
type CreateSAMLIdPSessionRequest struct {
	// SessionID is the identifier for the session.
	SessionID string `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id"`
	// Username is the name of the user requesting the session.
	Username string `protobuf:"bytes,2,opt,name=Username,proto3" json:"username"`
	// SAMLSession is the session data associated with the SAML IdP session.
	SAMLSession          *types.SAMLSessionData `protobuf:"bytes,3,opt,name=SAMLSession,proto3" json:"saml_session"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CreateSAMLIdPSessionRequest) Reset()         { *m = CreateSAMLIdPSessionRequest{} }
func (m *CreateSAMLIdPSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSAMLIdPSessionRequest) ProtoMessage()    {}
func (*CreateSAMLIdPSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{50}
}
func (m *CreateSAMLIdPSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSAMLIdPSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSAMLIdPSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSAMLIdPSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSAMLIdPSessionRequest.Merge(m, src)
}
func (m *CreateSAMLIdPSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSAMLIdPSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSAMLIdPSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSAMLIdPSessionRequest proto.InternalMessageInfo

func (m *CreateSAMLIdPSessionRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func (m *CreateSAMLIdPSessionRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CreateSAMLIdPSessionRequest) GetSAMLSession() *types.SAMLSessionData {
	if m != nil {
		return m.SAMLSession
	}
	return nil
}

// CreateSAMLIdPSessionResponse contains a SAML IdP session.
type CreateSAMLIdPSessionResponse struct {
	Session              *types.WebSessionV2 `protobuf:"bytes,1,opt,name=Session,proto3" json:"session"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CreateSAMLIdPSessionResponse) Reset()         { *m = CreateSAMLIdPSessionResponse{} }
func (m *CreateSAMLIdPSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CreateSAMLIdPSessionResponse) ProtoMessage()    {}
func (*CreateSAMLIdPSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{51}
}
func (m *CreateSAMLIdPSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSAMLIdPSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSAMLIdPSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSAMLIdPSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSAMLIdPSessionResponse.Merge(m, src)
}
func (m *CreateSAMLIdPSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateSAMLIdPSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSAMLIdPSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSAMLIdPSessionResponse proto.InternalMessageInfo

func (m *CreateSAMLIdPSessionResponse) GetSession() *types.WebSessionV2 {
	if m != nil {
		return m.Session
	}
	return nil
}

// GetSnowflakeSessionRequest are the parameters used to request an Snowflake web session.
type GetSnowflakeSessionRequest struct {
	// SessionID is the ID of the session being requested.
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSnowflakeSessionRequest) Reset()         { *m = GetSnowflakeSessionRequest{} }
func (m *GetSnowflakeSessionRequest) String() string { return proto.CompactTextString(m) }
func (*GetSnowflakeSessionRequest) ProtoMessage()    {}
func (*GetSnowflakeSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{52}
}
func (m *GetSnowflakeSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSnowflakeSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSnowflakeSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSnowflakeSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSnowflakeSessionRequest.Merge(m, src)
}
func (m *GetSnowflakeSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSnowflakeSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSnowflakeSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSnowflakeSessionRequest proto.InternalMessageInfo

func (m *GetSnowflakeSessionRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// GetSnowflakeSessionResponse contains the requested Snowflake web session.
type GetSnowflakeSessionResponse struct {
	// Session is the Snowflake web session.
	Session              *types.WebSessionV2 `protobuf:"bytes,1,opt,name=Session,proto3" json:"session"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetSnowflakeSessionResponse) Reset()         { *m = GetSnowflakeSessionResponse{} }
func (m *GetSnowflakeSessionResponse) String() string { return proto.CompactTextString(m) }
func (*GetSnowflakeSessionResponse) ProtoMessage()    {}
func (*GetSnowflakeSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{53}
}
func (m *GetSnowflakeSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSnowflakeSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSnowflakeSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSnowflakeSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSnowflakeSessionResponse.Merge(m, src)
}
func (m *GetSnowflakeSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSnowflakeSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSnowflakeSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSnowflakeSessionResponse proto.InternalMessageInfo

func (m *GetSnowflakeSessionResponse) GetSession() *types.WebSessionV2 {
	if m != nil {
		return m.Session
	}
	return nil
}

// GetSAMLIdPSessionRequest are the parameters used to request a SAML IdP session.
type GetSAMLIdPSessionRequest struct {
	// SessionID is the ID of the session being requested.
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSAMLIdPSessionRequest) Reset()         { *m = GetSAMLIdPSessionRequest{} }
func (m *GetSAMLIdPSessionRequest) String() string { return proto.CompactTextString(m) }
func (*GetSAMLIdPSessionRequest) ProtoMessage()    {}
func (*GetSAMLIdPSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{54}
}
func (m *GetSAMLIdPSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSAMLIdPSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSAMLIdPSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSAMLIdPSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSAMLIdPSessionRequest.Merge(m, src)
}
func (m *GetSAMLIdPSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSAMLIdPSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSAMLIdPSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSAMLIdPSessionRequest proto.InternalMessageInfo

func (m *GetSAMLIdPSessionRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// GetSAMLIdPSessionResponse contains the requested SAML IdP session.
type GetSAMLIdPSessionResponse struct {
	// Session is the SAML IdP web session.
	Session              *types.WebSessionV2 `protobuf:"bytes,1,opt,name=Session,proto3" json:"session"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetSAMLIdPSessionResponse) Reset()         { *m = GetSAMLIdPSessionResponse{} }
func (m *GetSAMLIdPSessionResponse) String() string { return proto.CompactTextString(m) }
func (*GetSAMLIdPSessionResponse) ProtoMessage()    {}
func (*GetSAMLIdPSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{55}
}
func (m *GetSAMLIdPSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSAMLIdPSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSAMLIdPSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSAMLIdPSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSAMLIdPSessionResponse.Merge(m, src)
}
func (m *GetSAMLIdPSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSAMLIdPSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSAMLIdPSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSAMLIdPSessionResponse proto.InternalMessageInfo

func (m *GetSAMLIdPSessionResponse) GetSession() *types.WebSessionV2 {
	if m != nil {
		return m.Session
	}
	return nil
}

// DeleteAppSessionRequest contains the parameters used to remove an application web session.
type DeleteAppSessionRequest struct {
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAppSessionRequest) Reset()         { *m = DeleteAppSessionRequest{} }
func (m *DeleteAppSessionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAppSessionRequest) ProtoMessage()    {}
func (*DeleteAppSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{56}
}
func (m *DeleteAppSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAppSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAppSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteAppSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAppSessionRequest.Merge(m, src)
}
func (m *DeleteAppSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAppSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAppSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAppSessionRequest proto.InternalMessageInfo

func (m *DeleteAppSessionRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// DeleteSnowflakeSessionRequest contains the parameters used to remove a Snowflake web session.
type DeleteSnowflakeSessionRequest struct {
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSnowflakeSessionRequest) Reset()         { *m = DeleteSnowflakeSessionRequest{} }
func (m *DeleteSnowflakeSessionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteSnowflakeSessionRequest) ProtoMessage()    {}
func (*DeleteSnowflakeSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{57}
}
func (m *DeleteSnowflakeSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSnowflakeSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteSnowflakeSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteSnowflakeSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSnowflakeSessionRequest.Merge(m, src)
}
func (m *DeleteSnowflakeSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSnowflakeSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSnowflakeSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSnowflakeSessionRequest proto.InternalMessageInfo

func (m *DeleteSnowflakeSessionRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// DeleteSAMLIdPSessionRequest contains the parameters used to remove a SAML IdP session.
type DeleteSAMLIdPSessionRequest struct {
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSAMLIdPSessionRequest) Reset()         { *m = DeleteSAMLIdPSessionRequest{} }
func (m *DeleteSAMLIdPSessionRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteSAMLIdPSessionRequest) ProtoMessage()    {}
func (*DeleteSAMLIdPSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{58}
}
func (m *DeleteSAMLIdPSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSAMLIdPSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteSAMLIdPSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteSAMLIdPSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSAMLIdPSessionRequest.Merge(m, src)
}
func (m *DeleteSAMLIdPSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSAMLIdPSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSAMLIdPSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSAMLIdPSessionRequest proto.InternalMessageInfo

func (m *DeleteSAMLIdPSessionRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// DeleteUserAppSessionsRequest contains the parameters used to remove the
// user's application web sessions.
type DeleteUserAppSessionsRequest struct {
	Username             string   `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUserAppSessionsRequest) Reset()         { *m = DeleteUserAppSessionsRequest{} }
func (m *DeleteUserAppSessionsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteUserAppSessionsRequest) ProtoMessage()    {}
func (*DeleteUserAppSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{59}
}
func (m *DeleteUserAppSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserAppSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserAppSessionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserAppSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserAppSessionsRequest.Merge(m, src)
}
func (m *DeleteUserAppSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserAppSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserAppSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserAppSessionsRequest proto.InternalMessageInfo

func (m *DeleteUserAppSessionsRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

// DeleteUserAppSessionsRequest contains the parameters used to remove the
// user's SAML IdP sessions.
type DeleteUserSAMLIdPSessionsRequest struct {
	Username             string   `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUserSAMLIdPSessionsRequest) Reset()         { *m = DeleteUserSAMLIdPSessionsRequest{} }
func (m *DeleteUserSAMLIdPSessionsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteUserSAMLIdPSessionsRequest) ProtoMessage()    {}
func (*DeleteUserSAMLIdPSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{60}
}
func (m *DeleteUserSAMLIdPSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserSAMLIdPSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserSAMLIdPSessionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserSAMLIdPSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserSAMLIdPSessionsRequest.Merge(m, src)
}
func (m *DeleteUserSAMLIdPSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserSAMLIdPSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserSAMLIdPSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserSAMLIdPSessionsRequest proto.InternalMessageInfo

func (m *DeleteUserSAMLIdPSessionsRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

// GetWebSessionResponse contains the requested web session.
type GetWebSessionResponse struct {
	// Session is the web session.
	Session              *types.WebSessionV2 `protobuf:"bytes,1,opt,name=Session,proto3" json:"session"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetWebSessionResponse) Reset()         { *m = GetWebSessionResponse{} }
func (m *GetWebSessionResponse) String() string { return proto.CompactTextString(m) }
func (*GetWebSessionResponse) ProtoMessage()    {}
func (*GetWebSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{61}
}
func (m *GetWebSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWebSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWebSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWebSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWebSessionResponse.Merge(m, src)
}
func (m *GetWebSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWebSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWebSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWebSessionResponse proto.InternalMessageInfo

func (m *GetWebSessionResponse) GetSession() *types.WebSessionV2 {
	if m != nil {
		return m.Session
	}
	return nil
}

// GetWebSessionsResponse contains all the requested web sessions.
type GetWebSessionsResponse struct {
	// Sessions is a list of web sessions.
	Sessions             []*types.WebSessionV2 `protobuf:"bytes,1,rep,name=Sessions,proto3" json:"sessions"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *GetWebSessionsResponse) Reset()         { *m = GetWebSessionsResponse{} }
func (m *GetWebSessionsResponse) String() string { return proto.CompactTextString(m) }
func (*GetWebSessionsResponse) ProtoMessage()    {}
func (*GetWebSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{62}
}
func (m *GetWebSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWebSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWebSessionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWebSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWebSessionsResponse.Merge(m, src)
}
func (m *GetWebSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWebSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWebSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWebSessionsResponse proto.InternalMessageInfo

func (m *GetWebSessionsResponse) GetSessions() []*types.WebSessionV2 {
	if m != nil {
		return m.Sessions
	}
	return nil
}

// GetWebTokenResponse contains the requested web token.
type GetWebTokenResponse struct {
	// Token is the web token being requested.
	Token                *types.WebTokenV3 `protobuf:"bytes,1,opt,name=Token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetWebTokenResponse) Reset()         { *m = GetWebTokenResponse{} }
func (m *GetWebTokenResponse) String() string { return proto.CompactTextString(m) }
func (*GetWebTokenResponse) ProtoMessage()    {}
func (*GetWebTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{63}
}
func (m *GetWebTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWebTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWebTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWebTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWebTokenResponse.Merge(m, src)
}
func (m *GetWebTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWebTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWebTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWebTokenResponse proto.InternalMessageInfo

func (m *GetWebTokenResponse) GetToken() *types.WebTokenV3 {
	if m != nil {
		return m.Token
	}
	return nil
}

// GetWebTokensResponse contains all the requested web tokens.
type GetWebTokensResponse struct {
	// Tokens is a list of web tokens.
	Tokens               []*types.WebTokenV3 `protobuf:"bytes,1,rep,name=Tokens,proto3" json:"tokens"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetWebTokensResponse) Reset()         { *m = GetWebTokensResponse{} }
func (m *GetWebTokensResponse) String() string { return proto.CompactTextString(m) }
func (*GetWebTokensResponse) ProtoMessage()    {}
func (*GetWebTokensResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{64}
}
func (m *GetWebTokensResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWebTokensResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWebTokensResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWebTokensResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWebTokensResponse.Merge(m, src)
}
func (m *GetWebTokensResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWebTokensResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWebTokensResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWebTokensResponse proto.InternalMessageInfo

func (m *GetWebTokensResponse) GetTokens() []*types.WebTokenV3 {
	if m != nil {
		return m.Tokens
	}
	return nil
}

// UpsertKubernetesServerRequest are the parameters used to add or update a
// kubernetes server.
type UpsertKubernetesServerRequest struct {
	Server               *types.KubernetesServerV3 `protobuf:"bytes,1,opt,name=Server,proto3" json:"server"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *UpsertKubernetesServerRequest) Reset()         { *m = UpsertKubernetesServerRequest{} }
func (m *UpsertKubernetesServerRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertKubernetesServerRequest) ProtoMessage()    {}
func (*UpsertKubernetesServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{65}
}
func (m *UpsertKubernetesServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertKubernetesServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertKubernetesServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertKubernetesServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertKubernetesServerRequest.Merge(m, src)
}
func (m *UpsertKubernetesServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertKubernetesServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertKubernetesServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertKubernetesServerRequest proto.InternalMessageInfo

func (m *UpsertKubernetesServerRequest) GetServer() *types.KubernetesServerV3 {
	if m != nil {
		return m.Server
	}
	return nil
}

// DeleteKubernetesServerRequest are the parameters used to remove a kubernetes server.
type DeleteKubernetesServerRequest struct {
	// HostID is the kube server host uuid.
	HostID string `protobuf:"bytes,1,opt,name=HostID,proto3" json:"host_id"`
	// Name is the name of the kubernetes service to delete.
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteKubernetesServerRequest) Reset()         { *m = DeleteKubernetesServerRequest{} }
func (m *DeleteKubernetesServerRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteKubernetesServerRequest) ProtoMessage()    {}
func (*DeleteKubernetesServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{66}
}
func (m *DeleteKubernetesServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteKubernetesServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteKubernetesServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteKubernetesServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteKubernetesServerRequest.Merge(m, src)
}
func (m *DeleteKubernetesServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteKubernetesServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteKubernetesServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteKubernetesServerRequest proto.InternalMessageInfo

func (m *DeleteKubernetesServerRequest) GetHostID() string {
	if m != nil {
		return m.HostID
	}
	return ""
}

func (m *DeleteKubernetesServerRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// DeleteAllKubernetesServersRequest are the parameters used to remove all kubernetes servers.
type DeleteAllKubernetesServersRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAllKubernetesServersRequest) Reset()         { *m = DeleteAllKubernetesServersRequest{} }
func (m *DeleteAllKubernetesServersRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAllKubernetesServersRequest) ProtoMessage()    {}
func (*DeleteAllKubernetesServersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{67}
}
func (m *DeleteAllKubernetesServersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAllKubernetesServersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAllKubernetesServersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteAllKubernetesServersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAllKubernetesServersRequest.Merge(m, src)
}
func (m *DeleteAllKubernetesServersRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAllKubernetesServersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAllKubernetesServersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAllKubernetesServersRequest proto.InternalMessageInfo

// UpsertDatabaseServerRequest is a request to register database server.
type UpsertDatabaseServerRequest struct {
	// Server is the database proxy server to register.
	Server               *types.DatabaseServerV3 `protobuf:"bytes,1,opt,name=Server,proto3" json:"server"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *UpsertDatabaseServerRequest) Reset()         { *m = UpsertDatabaseServerRequest{} }
func (m *UpsertDatabaseServerRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertDatabaseServerRequest) ProtoMessage()    {}
func (*UpsertDatabaseServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{68}
}
func (m *UpsertDatabaseServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertDatabaseServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertDatabaseServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertDatabaseServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertDatabaseServerRequest.Merge(m, src)
}
func (m *UpsertDatabaseServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertDatabaseServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertDatabaseServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertDatabaseServerRequest proto.InternalMessageInfo

func (m *UpsertDatabaseServerRequest) GetServer() *types.DatabaseServerV3 {
	if m != nil {
		return m.Server
	}
	return nil
}

// DeleteDatabaseServerRequest is a request to delete a database server.
type DeleteDatabaseServerRequest struct {
	// Namespace is the database server namespace.
	Namespace string `protobuf:"bytes,1,opt,name=Namespace,proto3" json:"namespace"`
	// HostID is the ID of the host database server is running on.
	HostID string `protobuf:"bytes,2,opt,name=HostID,proto3" json:"host_id"`
	// Name is the database server name.
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteDatabaseServerRequest) Reset()         { *m = DeleteDatabaseServerRequest{} }
func (m *DeleteDatabaseServerRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteDatabaseServerRequest) ProtoMessage()    {}
func (*DeleteDatabaseServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{69}
}
func (m *DeleteDatabaseServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteDatabaseServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteDatabaseServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteDatabaseServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDatabaseServerRequest.Merge(m, src)
}
func (m *DeleteDatabaseServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteDatabaseServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDatabaseServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDatabaseServerRequest proto.InternalMessageInfo

func (m *DeleteDatabaseServerRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DeleteDatabaseServerRequest) GetHostID() string {
	if m != nil {
		return m.HostID
	}
	return ""
}

func (m *DeleteDatabaseServerRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// DeleteAllDatabaseServersRequest is a request to delete all database servers.
type DeleteAllDatabaseServersRequest struct {
	// Namespace is the database servers namespace.
	Namespace            string   `protobuf:"bytes,1,opt,name=Namespace,proto3" json:"namespace"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAllDatabaseServersRequest) Reset()         { *m = DeleteAllDatabaseServersRequest{} }
func (m *DeleteAllDatabaseServersRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAllDatabaseServersRequest) ProtoMessage()    {}
func (*DeleteAllDatabaseServersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{70}
}
func (m *DeleteAllDatabaseServersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAllDatabaseServersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAllDatabaseServersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteAllDatabaseServersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAllDatabaseServersRequest.Merge(m, src)
}
func (m *DeleteAllDatabaseServersRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAllDatabaseServersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAllDatabaseServersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAllDatabaseServersRequest proto.InternalMessageInfo

func (m *DeleteAllDatabaseServersRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// DatabaseServiceV1List represents a list of DatabaseService resources.
type DatabaseServiceV1List struct {
	// Services is a list of DatabaseService resources.
	Services             []*types.DatabaseServiceV1 `protobuf:"bytes,1,rep,name=Services,proto3" json:"Services,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *DatabaseServiceV1List) Reset()         { *m = DatabaseServiceV1List{} }
func (m *DatabaseServiceV1List) String() string { return proto.CompactTextString(m) }
func (*DatabaseServiceV1List) ProtoMessage()    {}
func (*DatabaseServiceV1List) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{71}
}
func (m *DatabaseServiceV1List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseServiceV1List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseServiceV1List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseServiceV1List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseServiceV1List.Merge(m, src)
}
func (m *DatabaseServiceV1List) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseServiceV1List) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseServiceV1List.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseServiceV1List proto.InternalMessageInfo

func (m *DatabaseServiceV1List) GetServices() []*types.DatabaseServiceV1 {
	if m != nil {
		return m.Services
	}
	return nil
}

// UpsertDatabaseServiceRequest is a request to register DatabaseService.
type UpsertDatabaseServiceRequest struct {
	// Service is the database service to register.
	Service              *types.DatabaseServiceV1 `protobuf:"bytes,1,opt,name=Service,proto3" json:"service"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *UpsertDatabaseServiceRequest) Reset()         { *m = UpsertDatabaseServiceRequest{} }
func (m *UpsertDatabaseServiceRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertDatabaseServiceRequest) ProtoMessage()    {}
func (*UpsertDatabaseServiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{72}
}
func (m *UpsertDatabaseServiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertDatabaseServiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertDatabaseServiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertDatabaseServiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertDatabaseServiceRequest.Merge(m, src)
}
func (m *UpsertDatabaseServiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertDatabaseServiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertDatabaseServiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertDatabaseServiceRequest proto.InternalMessageInfo

func (m *UpsertDatabaseServiceRequest) GetService() *types.DatabaseServiceV1 {
	if m != nil {
		return m.Service
	}
	return nil
}

// DeleteAllDatabaseServicesRequest is a request to delete all DatabaseServices.
type DeleteAllDatabaseServicesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAllDatabaseServicesRequest) Reset()         { *m = DeleteAllDatabaseServicesRequest{} }
func (m *DeleteAllDatabaseServicesRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAllDatabaseServicesRequest) ProtoMessage()    {}
func (*DeleteAllDatabaseServicesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{73}
}
func (m *DeleteAllDatabaseServicesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAllDatabaseServicesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAllDatabaseServicesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteAllDatabaseServicesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAllDatabaseServicesRequest.Merge(m, src)
}
func (m *DeleteAllDatabaseServicesRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAllDatabaseServicesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAllDatabaseServicesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAllDatabaseServicesRequest proto.InternalMessageInfo

// DatabaseCSRRequest is a request to generate a client certificate used
// by the proxy to authenticate with a remote database service.
type DatabaseCSRRequest struct {
	// CSR is the request to sign.
	CSR []byte `protobuf:"bytes,1,opt,name=CSR,proto3" json:"csr"`
	// ClusterName is the name of the cluster the request is for.
	ClusterName          string   `protobuf:"bytes,2,opt,name=ClusterName,proto3" json:"cluster_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseCSRRequest) Reset()         { *m = DatabaseCSRRequest{} }
func (m *DatabaseCSRRequest) String() string { return proto.CompactTextString(m) }
func (*DatabaseCSRRequest) ProtoMessage()    {}
func (*DatabaseCSRRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{74}
}
func (m *DatabaseCSRRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseCSRRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseCSRRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseCSRRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseCSRRequest.Merge(m, src)
}
func (m *DatabaseCSRRequest) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseCSRRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseCSRRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseCSRRequest proto.InternalMessageInfo

func (m *DatabaseCSRRequest) GetCSR() []byte {
	if m != nil {
		return m.CSR
	}
	return nil
}

func (m *DatabaseCSRRequest) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

// DatabaseCSRResponse contains the signed database certificate.
type DatabaseCSRResponse struct {
	// Cert is the signed certificate.
	Cert []byte `protobuf:"bytes,1,opt,name=Cert,proto3" json:"cert"`
	// CACerts is a list of certificate authorities.
	CACerts              [][]byte `protobuf:"bytes,2,rep,name=CACerts,proto3" json:"ca_certs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseCSRResponse) Reset()         { *m = DatabaseCSRResponse{} }
func (m *DatabaseCSRResponse) String() string { return proto.CompactTextString(m) }
func (*DatabaseCSRResponse) ProtoMessage()    {}
func (*DatabaseCSRResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{75}
}
func (m *DatabaseCSRResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseCSRResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseCSRResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseCSRResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseCSRResponse.Merge(m, src)
}
func (m *DatabaseCSRResponse) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseCSRResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseCSRResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseCSRResponse proto.InternalMessageInfo

func (m *DatabaseCSRResponse) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *DatabaseCSRResponse) GetCACerts() [][]byte {
	if m != nil {
		return m.CACerts
	}
	return nil
}

// DatabaseCertRequest is a request to generate a client certificate used
// by a database service to authenticate with a database instance.
type DatabaseCertRequest struct {
	// CSR is the request to sign.
	CSR []byte `protobuf:"bytes,1,opt,name=CSR,proto3" json:"csr"`
	// ServerName is the SAN to include in the certificate.
	// DEPRECATED: Replaced by ServerNames.
	ServerName string `protobuf:"bytes,2,opt,name=ServerName,proto3" json:"server_name"` // Deprecated: Do not use.
	// TTL is the certificate validity period.
	TTL Duration `protobuf:"varint,3,opt,name=TTL,proto3,casttype=Duration" json:"ttl"`
	// ServerNames are SANs to include in the certificate.
	ServerNames []string `protobuf:"bytes,4,rep,name=ServerNames,proto3" json:"server_names"`
	// RequesterName identifies who sent the request.
	RequesterName DatabaseCertRequest_Requester `protobuf:"varint,5,opt,name=RequesterName,proto3,enum=proto.DatabaseCertRequest_Requester" json:"requester_name"`
	// CertificateExtensions identifies which extensions, if any, should be added to the certificate.
	CertificateExtensions DatabaseCertRequest_Extensions `protobuf:"varint,6,opt,name=CertificateExtensions,proto3,enum=proto.DatabaseCertRequest_Extensions" json:"certificate_extensions"`
	// CRLEndpoint is a certificate revocation list distribution point. Required for Windows smartcard certs.
	CRLEndpoint          string   `protobuf:"bytes,7,opt,name=CRLEndpoint,proto3" json:"crl_endpoint"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseCertRequest) Reset()         { *m = DatabaseCertRequest{} }
func (m *DatabaseCertRequest) String() string { return proto.CompactTextString(m) }
func (*DatabaseCertRequest) ProtoMessage()    {}
func (*DatabaseCertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{76}
}
func (m *DatabaseCertRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseCertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseCertRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseCertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseCertRequest.Merge(m, src)
}
func (m *DatabaseCertRequest) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseCertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseCertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseCertRequest proto.InternalMessageInfo

func (m *DatabaseCertRequest) GetCSR() []byte {
	if m != nil {
		return m.CSR
	}
	return nil
}

// Deprecated: Do not use.
func (m *DatabaseCertRequest) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *DatabaseCertRequest) GetTTL() Duration {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *DatabaseCertRequest) GetServerNames() []string {
	if m != nil {
		return m.ServerNames
	}
	return nil
}

func (m *DatabaseCertRequest) GetRequesterName() DatabaseCertRequest_Requester {
	if m != nil {
		return m.RequesterName
	}
	return DatabaseCertRequest_UNSPECIFIED
}

func (m *DatabaseCertRequest) GetCertificateExtensions() DatabaseCertRequest_Extensions {
	if m != nil {
		return m.CertificateExtensions
	}
	return DatabaseCertRequest_NORMAL
}

func (m *DatabaseCertRequest) GetCRLEndpoint() string {
	if m != nil {
		return m.CRLEndpoint
	}
	return ""
}

// DatabaseCertResponse contains the signed certificate.
type DatabaseCertResponse struct {
	// Cert is the signed certificate.
	Cert []byte `protobuf:"bytes,1,opt,name=Cert,proto3" json:"cert"`
	// CACerts is a list of certificate authorities.
	CACerts              [][]byte `protobuf:"bytes,2,rep,name=CACerts,proto3" json:"ca_certs"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseCertResponse) Reset()         { *m = DatabaseCertResponse{} }
func (m *DatabaseCertResponse) String() string { return proto.CompactTextString(m) }
func (*DatabaseCertResponse) ProtoMessage()    {}
func (*DatabaseCertResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{77}
}
func (m *DatabaseCertResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseCertResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseCertResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseCertResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseCertResponse.Merge(m, src)
}
func (m *DatabaseCertResponse) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseCertResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseCertResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseCertResponse proto.InternalMessageInfo

func (m *DatabaseCertResponse) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *DatabaseCertResponse) GetCACerts() [][]byte {
	if m != nil {
		return m.CACerts
	}
	return nil
}

// SnowflakeJWTRequest contains data required to generate Snowflake JWT used for authorization.
type SnowflakeJWTRequest struct {
	AccountName          string   `protobuf:"bytes,1,opt,name=AccountName,proto3" json:"account_name"`
	UserName             string   `protobuf:"bytes,2,opt,name=UserName,proto3" json:"user_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnowflakeJWTRequest) Reset()         { *m = SnowflakeJWTRequest{} }
func (m *SnowflakeJWTRequest) String() string { return proto.CompactTextString(m) }
func (*SnowflakeJWTRequest) ProtoMessage()    {}
func (*SnowflakeJWTRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{78}
}
func (m *SnowflakeJWTRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnowflakeJWTRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnowflakeJWTRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnowflakeJWTRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnowflakeJWTRequest.Merge(m, src)
}
func (m *SnowflakeJWTRequest) XXX_Size() int {
	return m.Size()
}
func (m *SnowflakeJWTRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SnowflakeJWTRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SnowflakeJWTRequest proto.InternalMessageInfo

func (m *SnowflakeJWTRequest) GetAccountName() string {
	if m != nil {
		return m.AccountName
	}
	return ""
}

func (m *SnowflakeJWTRequest) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

// SnowflakeJWTResponse contains signed JWT that can be used for Snowflake authentication.
type SnowflakeJWTResponse struct {
	Token                string   `protobuf:"bytes,1,opt,name=Token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnowflakeJWTResponse) Reset()         { *m = SnowflakeJWTResponse{} }
func (m *SnowflakeJWTResponse) String() string { return proto.CompactTextString(m) }
func (*SnowflakeJWTResponse) ProtoMessage()    {}
func (*SnowflakeJWTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{79}
}
func (m *SnowflakeJWTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnowflakeJWTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnowflakeJWTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnowflakeJWTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnowflakeJWTResponse.Merge(m, src)
}
func (m *SnowflakeJWTResponse) XXX_Size() int {
	return m.Size()
}
func (m *SnowflakeJWTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SnowflakeJWTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SnowflakeJWTResponse proto.InternalMessageInfo

func (m *SnowflakeJWTResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// GetRoleRequest is a request to query a role.
type GetRoleRequest struct {
	// Name is the name of the role to get.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRoleRequest) Reset()         { *m = GetRoleRequest{} }
func (m *GetRoleRequest) String() string { return proto.CompactTextString(m) }
func (*GetRoleRequest) ProtoMessage()    {}
func (*GetRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{80}
}
func (m *GetRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRoleRequest.Merge(m, src)
}
func (m *GetRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRoleRequest proto.InternalMessageInfo

func (m *GetRoleRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GetRolesResponse is a response to querying for all roles.
type GetRolesResponse struct {
	// Roles is a list of roles.
	Roles                []*types.RoleV6 `protobuf:"bytes,1,rep,name=Roles,proto3" json:"Roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetRolesResponse) Reset()         { *m = GetRolesResponse{} }
func (m *GetRolesResponse) String() string { return proto.CompactTextString(m) }
func (*GetRolesResponse) ProtoMessage()    {}
func (*GetRolesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{81}
}
func (m *GetRolesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRolesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRolesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRolesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRolesResponse.Merge(m, src)
}
func (m *GetRolesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRolesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRolesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRolesResponse proto.InternalMessageInfo

func (m *GetRolesResponse) GetRoles() []*types.RoleV6 {
	if m != nil {
		return m.Roles
	}
	return nil
}

// ListRolesRequest encodes parameters for paginated role lookup.
type ListRolesRequest struct {
	// Limit is the maximum amount of roles per page.
	Limit int32 `protobuf:"varint,1,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// StartKey is used to resume a query in order to enable pagination.
	// If the previous response had LastKey set then this should be
	// set to its value. Otherwise leave empty.
	StartKey string `protobuf:"bytes,2,opt,name=StartKey,proto3" json:"StartKey,omitempty"`
	// Filter matches roles.
	Filter               *types.RoleFilter `protobuf:"bytes,3,opt,name=Filter,proto3" json:"Filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ListRolesRequest) Reset()         { *m = ListRolesRequest{} }
func (m *ListRolesRequest) String() string { return proto.CompactTextString(m) }
func (*ListRolesRequest) ProtoMessage()    {}
func (*ListRolesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{82}
}
func (m *ListRolesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRolesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRolesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRolesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRolesRequest.Merge(m, src)
}
func (m *ListRolesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRolesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRolesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRolesRequest proto.InternalMessageInfo

func (m *ListRolesRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListRolesRequest) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *ListRolesRequest) GetFilter() *types.RoleFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// ListRolesResponse is a page of roles.
type ListRolesResponse struct {
	// Roles is a page of roles.
	Roles []*types.RoleV6 `protobuf:"bytes,1,rep,name=Roles,proto3" json:"Roles,omitempty"`
	// NextKey will serve as the StartKey for the next page of roles.
	NextKey              string   `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"NextKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRolesResponse) Reset()         { *m = ListRolesResponse{} }
func (m *ListRolesResponse) String() string { return proto.CompactTextString(m) }
func (*ListRolesResponse) ProtoMessage()    {}
func (*ListRolesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{83}
}
func (m *ListRolesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRolesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRolesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRolesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRolesResponse.Merge(m, src)
}
func (m *ListRolesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListRolesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRolesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRolesResponse proto.InternalMessageInfo

func (m *ListRolesResponse) GetRoles() []*types.RoleV6 {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *ListRolesResponse) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

// Request for CreateRole.
type CreateRoleRequest struct {
	// Role to be created.
	Role                 *types.RoleV6 `protobuf:"bytes,1,opt,name=Role,proto3" json:"Role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CreateRoleRequest) Reset()         { *m = CreateRoleRequest{} }
func (m *CreateRoleRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRoleRequest) ProtoMessage()    {}
func (*CreateRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{84}
}
func (m *CreateRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRoleRequest.Merge(m, src)
}
func (m *CreateRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRoleRequest proto.InternalMessageInfo

func (m *CreateRoleRequest) GetRole() *types.RoleV6 {
	if m != nil {
		return m.Role
	}
	return nil
}

// Request for UpdateRole.
type UpdateRoleRequest struct {
	// Role to be updated.
	Role                 *types.RoleV6 `protobuf:"bytes,1,opt,name=Role,proto3" json:"Role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateRoleRequest) Reset()         { *m = UpdateRoleRequest{} }
func (m *UpdateRoleRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateRoleRequest) ProtoMessage()    {}
func (*UpdateRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{85}
}
func (m *UpdateRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateRoleRequest.Merge(m, src)
}
func (m *UpdateRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateRoleRequest proto.InternalMessageInfo

func (m *UpdateRoleRequest) GetRole() *types.RoleV6 {
	if m != nil {
		return m.Role
	}
	return nil
}

// Request for UpsertRole.
type UpsertRoleRequest struct {
	// Role to be upserted.
	Role                 *types.RoleV6 `protobuf:"bytes,1,opt,name=Role,proto3" json:"Role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpsertRoleRequest) Reset()         { *m = UpsertRoleRequest{} }
func (m *UpsertRoleRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertRoleRequest) ProtoMessage()    {}
func (*UpsertRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{86}
}
func (m *UpsertRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertRoleRequest.Merge(m, src)
}
func (m *UpsertRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertRoleRequest proto.InternalMessageInfo

func (m *UpsertRoleRequest) GetRole() *types.RoleV6 {
	if m != nil {
		return m.Role
	}
	return nil
}

// DeleteRoleRequest is a request to delete a role.
type DeleteRoleRequest struct {
	// Name is the role name to delete.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRoleRequest) Reset()         { *m = DeleteRoleRequest{} }
func (m *DeleteRoleRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRoleRequest) ProtoMessage()    {}
func (*DeleteRoleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{87}
}
func (m *DeleteRoleRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRoleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRoleRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRoleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRoleRequest.Merge(m, src)
}
func (m *DeleteRoleRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRoleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRoleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRoleRequest proto.InternalMessageInfo

func (m *DeleteRoleRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// MFAAuthenticateChallenge is a challenge for all MFA devices registered for a
// user.
type MFAAuthenticateChallenge struct {
	// TOTP is a challenge for all TOTP devices registered for a user. When
	// this field is set, any TOTP device a user has registered can be used to
	// respond.
	TOTP *TOTPChallenge `protobuf:"bytes,2,opt,name=TOTP,proto3" json:"TOTP,omitempty"`
	// WebauthnChallenge contains a Webauthn credential assertion used for
	// login/authentication ceremonies.
	// Credential assertions hold, among other information, a list of allowed
	// credentials for the ceremony (one for each U2F or Webauthn device
	// registered by the user).
	WebauthnChallenge *webauthn.CredentialAssertion `protobuf:"bytes,3,opt,name=WebauthnChallenge,proto3" json:"WebauthnChallenge,omitempty"`
	// MFRequired indicates whether proceeding with the MFA ceremony will
	// grant access to the resource.
	//
	// If `MFA_REQUIRED_NO` is returned then the server may opt to end ongoing
	// communications, in case of streaming RPCs. It may also return empty
	// challenges for all other fields.
	MFARequired          MFARequired `protobuf:"varint,4,opt,name=MFARequired,proto3,enum=proto.MFARequired" json:"MFARequired,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *MFAAuthenticateChallenge) Reset()         { *m = MFAAuthenticateChallenge{} }
func (m *MFAAuthenticateChallenge) String() string { return proto.CompactTextString(m) }
func (*MFAAuthenticateChallenge) ProtoMessage()    {}
func (*MFAAuthenticateChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{88}
}
func (m *MFAAuthenticateChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFAAuthenticateChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFAAuthenticateChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFAAuthenticateChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFAAuthenticateChallenge.Merge(m, src)
}
func (m *MFAAuthenticateChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MFAAuthenticateChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MFAAuthenticateChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MFAAuthenticateChallenge proto.InternalMessageInfo

func (m *MFAAuthenticateChallenge) GetTOTP() *TOTPChallenge {
	if m != nil {
		return m.TOTP
	}
	return nil
}

func (m *MFAAuthenticateChallenge) GetWebauthnChallenge() *webauthn.CredentialAssertion {
	if m != nil {
		return m.WebauthnChallenge
	}
	return nil
}

func (m *MFAAuthenticateChallenge) GetMFARequired() MFARequired {
	if m != nil {
		return m.MFARequired
	}
	return MFARequired_MFA_REQUIRED_UNSPECIFIED
}

// MFAAuthenticateResponse is a response to MFAAuthenticateChallenge using one
// of the MFA devices registered for a user.
type MFAAuthenticateResponse struct {
	// Types that are valid to be assigned to Response:
	//	*MFAAuthenticateResponse_TOTP
	//	*MFAAuthenticateResponse_Webauthn
	Response             isMFAAuthenticateResponse_Response `protobuf_oneof:"Response"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *MFAAuthenticateResponse) Reset()         { *m = MFAAuthenticateResponse{} }
func (m *MFAAuthenticateResponse) String() string { return proto.CompactTextString(m) }
func (*MFAAuthenticateResponse) ProtoMessage()    {}
func (*MFAAuthenticateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{89}
}
func (m *MFAAuthenticateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFAAuthenticateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFAAuthenticateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFAAuthenticateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFAAuthenticateResponse.Merge(m, src)
}
func (m *MFAAuthenticateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MFAAuthenticateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MFAAuthenticateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MFAAuthenticateResponse proto.InternalMessageInfo

type isMFAAuthenticateResponse_Response interface {
	isMFAAuthenticateResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MFAAuthenticateResponse_TOTP struct {
	TOTP *TOTPResponse `protobuf:"bytes,2,opt,name=TOTP,proto3,oneof" json:"TOTP,omitempty"`
}
type MFAAuthenticateResponse_Webauthn struct {
	Webauthn *webauthn.CredentialAssertionResponse `protobuf:"bytes,3,opt,name=Webauthn,proto3,oneof" json:"Webauthn,omitempty"`
}

func (*MFAAuthenticateResponse_TOTP) isMFAAuthenticateResponse_Response()     {}
func (*MFAAuthenticateResponse_Webauthn) isMFAAuthenticateResponse_Response() {}

func (m *MFAAuthenticateResponse) GetResponse() isMFAAuthenticateResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *MFAAuthenticateResponse) GetTOTP() *TOTPResponse {
	if x, ok := m.GetResponse().(*MFAAuthenticateResponse_TOTP); ok {
		return x.TOTP
	}
	return nil
}

func (m *MFAAuthenticateResponse) GetWebauthn() *webauthn.CredentialAssertionResponse {
	if x, ok := m.GetResponse().(*MFAAuthenticateResponse_Webauthn); ok {
		return x.Webauthn
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MFAAuthenticateResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MFAAuthenticateResponse_TOTP)(nil),
		(*MFAAuthenticateResponse_Webauthn)(nil),
	}
}

// TOTPChallenge is a challenge for all TOTP devices registered for a user.
type TOTPChallenge struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TOTPChallenge) Reset()         { *m = TOTPChallenge{} }
func (m *TOTPChallenge) String() string { return proto.CompactTextString(m) }
func (*TOTPChallenge) ProtoMessage()    {}
func (*TOTPChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{90}
}
func (m *TOTPChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TOTPChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TOTPChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TOTPChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TOTPChallenge.Merge(m, src)
}
func (m *TOTPChallenge) XXX_Size() int {
	return m.Size()
}
func (m *TOTPChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_TOTPChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_TOTPChallenge proto.InternalMessageInfo

// TOTPResponse is a response to TOTPChallenge.
type TOTPResponse struct {
	Code                 string   `protobuf:"bytes,1,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TOTPResponse) Reset()         { *m = TOTPResponse{} }
func (m *TOTPResponse) String() string { return proto.CompactTextString(m) }
func (*TOTPResponse) ProtoMessage()    {}
func (*TOTPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{91}
}
func (m *TOTPResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TOTPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TOTPResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TOTPResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TOTPResponse.Merge(m, src)
}
func (m *TOTPResponse) XXX_Size() int {
	return m.Size()
}
func (m *TOTPResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TOTPResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TOTPResponse proto.InternalMessageInfo

func (m *TOTPResponse) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// MFARegisterChallenge is a challenge for registering a new MFA device.
type MFARegisterChallenge struct {
	// Request depends on the type of the MFA device being registered.
	//
	// Types that are valid to be assigned to Request:
	//	*MFARegisterChallenge_TOTP
	//	*MFARegisterChallenge_Webauthn
	Request              isMFARegisterChallenge_Request `protobuf_oneof:"Request"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *MFARegisterChallenge) Reset()         { *m = MFARegisterChallenge{} }
func (m *MFARegisterChallenge) String() string { return proto.CompactTextString(m) }
func (*MFARegisterChallenge) ProtoMessage()    {}
func (*MFARegisterChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{92}
}
func (m *MFARegisterChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFARegisterChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFARegisterChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFARegisterChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFARegisterChallenge.Merge(m, src)
}
func (m *MFARegisterChallenge) XXX_Size() int {
	return m.Size()
}
func (m *MFARegisterChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_MFARegisterChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_MFARegisterChallenge proto.InternalMessageInfo

type isMFARegisterChallenge_Request interface {
	isMFARegisterChallenge_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MFARegisterChallenge_TOTP struct {
	TOTP *TOTPRegisterChallenge `protobuf:"bytes,2,opt,name=TOTP,proto3,oneof" json:"TOTP,omitempty"`
}
type MFARegisterChallenge_Webauthn struct {
	Webauthn *webauthn.CredentialCreation `protobuf:"bytes,3,opt,name=Webauthn,proto3,oneof" json:"Webauthn,omitempty"`
}

func (*MFARegisterChallenge_TOTP) isMFARegisterChallenge_Request()     {}
func (*MFARegisterChallenge_Webauthn) isMFARegisterChallenge_Request() {}

func (m *MFARegisterChallenge) GetRequest() isMFARegisterChallenge_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *MFARegisterChallenge) GetTOTP() *TOTPRegisterChallenge {
	if x, ok := m.GetRequest().(*MFARegisterChallenge_TOTP); ok {
		return x.TOTP
	}
	return nil
}

func (m *MFARegisterChallenge) GetWebauthn() *webauthn.CredentialCreation {
	if x, ok := m.GetRequest().(*MFARegisterChallenge_Webauthn); ok {
		return x.Webauthn
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MFARegisterChallenge) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MFARegisterChallenge_TOTP)(nil),
		(*MFARegisterChallenge_Webauthn)(nil),
	}
}

// MFARegisterResponse is a response to MFARegisterChallenge.
type MFARegisterResponse struct {
	// Types that are valid to be assigned to Response:
	//	*MFARegisterResponse_TOTP
	//	*MFARegisterResponse_Webauthn
	Response             isMFARegisterResponse_Response `protobuf_oneof:"Response"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *MFARegisterResponse) Reset()         { *m = MFARegisterResponse{} }
func (m *MFARegisterResponse) String() string { return proto.CompactTextString(m) }
func (*MFARegisterResponse) ProtoMessage()    {}
func (*MFARegisterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{93}
}
func (m *MFARegisterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFARegisterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFARegisterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFARegisterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFARegisterResponse.Merge(m, src)
}
func (m *MFARegisterResponse) XXX_Size() int {
	return m.Size()
}
func (m *MFARegisterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MFARegisterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MFARegisterResponse proto.InternalMessageInfo

type isMFARegisterResponse_Response interface {
	isMFARegisterResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MFARegisterResponse_TOTP struct {
	TOTP *TOTPRegisterResponse `protobuf:"bytes,2,opt,name=TOTP,proto3,oneof" json:"TOTP,omitempty"`
}
type MFARegisterResponse_Webauthn struct {
	Webauthn *webauthn.CredentialCreationResponse `protobuf:"bytes,3,opt,name=Webauthn,proto3,oneof" json:"Webauthn,omitempty"`
}

func (*MFARegisterResponse_TOTP) isMFARegisterResponse_Response()     {}
func (*MFARegisterResponse_Webauthn) isMFARegisterResponse_Response() {}

func (m *MFARegisterResponse) GetResponse() isMFARegisterResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *MFARegisterResponse) GetTOTP() *TOTPRegisterResponse {
	if x, ok := m.GetResponse().(*MFARegisterResponse_TOTP); ok {
		return x.TOTP
	}
	return nil
}

func (m *MFARegisterResponse) GetWebauthn() *webauthn.CredentialCreationResponse {
	if x, ok := m.GetResponse().(*MFARegisterResponse_Webauthn); ok {
		return x.Webauthn
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MFARegisterResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MFARegisterResponse_TOTP)(nil),
		(*MFARegisterResponse_Webauthn)(nil),
	}
}

// TOTPRegisterChallenge is a challenge for registering a new TOTP device.
type TOTPRegisterChallenge struct {
	// Secret is a secret shared by client and server to generate codes.
	Secret string `protobuf:"bytes,1,opt,name=Secret,proto3" json:"Secret,omitempty"`
	// Issuer is the name of the Teleport cluster.
	Issuer string `protobuf:"bytes,2,opt,name=Issuer,proto3" json:"Issuer,omitempty"`
	// PeriodSeconds is a period for TOTP code rotation, in seconds.
	PeriodSeconds uint32 `protobuf:"varint,3,opt,name=PeriodSeconds,proto3" json:"PeriodSeconds,omitempty"`
	// Algorithm is the TOTP hashing algorithm.
	Algorithm string `protobuf:"bytes,4,opt,name=Algorithm,proto3" json:"Algorithm,omitempty"`
	// Digits is the number of digits in the TOTP code.
	Digits uint32 `protobuf:"varint,5,opt,name=Digits,proto3" json:"Digits,omitempty"`
	// Account is the account name for this user.
	Account string `protobuf:"bytes,6,opt,name=Account,proto3" json:"Account,omitempty"`
	// QRCode is an optional field for the QR code in PNG format. Used to display a QR code
	// image in the UI.
	QRCode []byte `protobuf:"bytes,7,opt,name=QRCode,proto3" json:"QRCode,omitempty"`
	// ID of the TOTP challenge.
	// Send this back in the TOTPRegisterResponse.
	ID                   string   `protobuf:"bytes,8,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TOTPRegisterChallenge) Reset()         { *m = TOTPRegisterChallenge{} }
func (m *TOTPRegisterChallenge) String() string { return proto.CompactTextString(m) }
func (*TOTPRegisterChallenge) ProtoMessage()    {}
func (*TOTPRegisterChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{94}
}
func (m *TOTPRegisterChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TOTPRegisterChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TOTPRegisterChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TOTPRegisterChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TOTPRegisterChallenge.Merge(m, src)
}
func (m *TOTPRegisterChallenge) XXX_Size() int {
	return m.Size()
}
func (m *TOTPRegisterChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_TOTPRegisterChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_TOTPRegisterChallenge proto.InternalMessageInfo

func (m *TOTPRegisterChallenge) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *TOTPRegisterChallenge) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *TOTPRegisterChallenge) GetPeriodSeconds() uint32 {
	if m != nil {
		return m.PeriodSeconds
	}
	return 0
}

func (m *TOTPRegisterChallenge) GetAlgorithm() string {
	if m != nil {
		return m.Algorithm
	}
	return ""
}

func (m *TOTPRegisterChallenge) GetDigits() uint32 {
	if m != nil {
		return m.Digits
	}
	return 0
}

func (m *TOTPRegisterChallenge) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *TOTPRegisterChallenge) GetQRCode() []byte {
	if m != nil {
		return m.QRCode
	}
	return nil
}

func (m *TOTPRegisterChallenge) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// TOTPRegisterResponse is a response to TOTPRegisterChallenge.
type TOTPRegisterResponse struct {
	Code string `protobuf:"bytes,1,opt,name=Code,proto3" json:"Code,omitempty"`
	// ID of the TOTP challenge, as informed by the TOTPRegisterChallenge.
	ID                   string   `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TOTPRegisterResponse) Reset()         { *m = TOTPRegisterResponse{} }
func (m *TOTPRegisterResponse) String() string { return proto.CompactTextString(m) }
func (*TOTPRegisterResponse) ProtoMessage()    {}
func (*TOTPRegisterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{95}
}
func (m *TOTPRegisterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TOTPRegisterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TOTPRegisterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TOTPRegisterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TOTPRegisterResponse.Merge(m, src)
}
func (m *TOTPRegisterResponse) XXX_Size() int {
	return m.Size()
}
func (m *TOTPRegisterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TOTPRegisterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TOTPRegisterResponse proto.InternalMessageInfo

func (m *TOTPRegisterResponse) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *TOTPRegisterResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// Deprecated: Use [AuthService.AddMFADeviceSync] instead.
type AddMFADeviceRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddMFADeviceRequest) Reset()         { *m = AddMFADeviceRequest{} }
func (m *AddMFADeviceRequest) String() string { return proto.CompactTextString(m) }
func (*AddMFADeviceRequest) ProtoMessage()    {}
func (*AddMFADeviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{96}
}
func (m *AddMFADeviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMFADeviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMFADeviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMFADeviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMFADeviceRequest.Merge(m, src)
}
func (m *AddMFADeviceRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddMFADeviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMFADeviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddMFADeviceRequest proto.InternalMessageInfo

// Deprecated: Use [AuthService.AddMFADeviceSync] instead.
type AddMFADeviceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddMFADeviceResponse) Reset()         { *m = AddMFADeviceResponse{} }
func (m *AddMFADeviceResponse) String() string { return proto.CompactTextString(m) }
func (*AddMFADeviceResponse) ProtoMessage()    {}
func (*AddMFADeviceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{97}
}
func (m *AddMFADeviceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMFADeviceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMFADeviceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMFADeviceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMFADeviceResponse.Merge(m, src)
}
func (m *AddMFADeviceResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddMFADeviceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMFADeviceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddMFADeviceResponse proto.InternalMessageInfo

// Deprecated: Use [AuthService.DeleteMFADeviceSync] instead.
type DeleteMFADeviceRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteMFADeviceRequest) Reset()         { *m = DeleteMFADeviceRequest{} }
func (m *DeleteMFADeviceRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteMFADeviceRequest) ProtoMessage()    {}
func (*DeleteMFADeviceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{98}
}
func (m *DeleteMFADeviceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMFADeviceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMFADeviceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMFADeviceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMFADeviceRequest.Merge(m, src)
}
func (m *DeleteMFADeviceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMFADeviceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMFADeviceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMFADeviceRequest proto.InternalMessageInfo

// Deprecated: Use [AuthService.DeleteMFADeviceSync] instead.
type DeleteMFADeviceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteMFADeviceResponse) Reset()         { *m = DeleteMFADeviceResponse{} }
func (m *DeleteMFADeviceResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteMFADeviceResponse) ProtoMessage()    {}
func (*DeleteMFADeviceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{99}
}
func (m *DeleteMFADeviceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMFADeviceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMFADeviceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMFADeviceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMFADeviceResponse.Merge(m, src)
}
func (m *DeleteMFADeviceResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMFADeviceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMFADeviceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMFADeviceResponse proto.InternalMessageInfo

// DeleteMFADeviceSyncRequest is a request to delete a MFA device (nonstream).
type DeleteMFADeviceSyncRequest struct {
	// TokenID is the ID of a user token that will be used to verify this request.
	//
	// Token types accepted are:
	//   - Recovery approved token that is obtained with RPC VerifyAccountRecovery
	//   - Privilege token that is obtained with RPC CreatePrivilegeToken
	//
	// Authenticated users can delete a device by providing an ExistingMFAResponse
	// instead.
	TokenID string `protobuf:"bytes,1,opt,name=TokenID,proto3" json:"token_id"`
	// DeviceName is the name of the device to delete.
	DeviceName string `protobuf:"bytes,2,opt,name=DeviceName,proto3" json:"device_name"`
	// ExistingMFAResponse is an MFA response from an existing device.
	//
	// May be provided as an alternative to TokenID.
	ExistingMFAResponse  *MFAAuthenticateResponse `protobuf:"bytes,3,opt,name=ExistingMFAResponse,proto3" json:"existing_mfa_response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *DeleteMFADeviceSyncRequest) Reset()         { *m = DeleteMFADeviceSyncRequest{} }
func (m *DeleteMFADeviceSyncRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteMFADeviceSyncRequest) ProtoMessage()    {}
func (*DeleteMFADeviceSyncRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{100}
}
func (m *DeleteMFADeviceSyncRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMFADeviceSyncRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMFADeviceSyncRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMFADeviceSyncRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMFADeviceSyncRequest.Merge(m, src)
}
func (m *DeleteMFADeviceSyncRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMFADeviceSyncRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMFADeviceSyncRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMFADeviceSyncRequest proto.InternalMessageInfo

func (m *DeleteMFADeviceSyncRequest) GetTokenID() string {
	if m != nil {
		return m.TokenID
	}
	return ""
}

func (m *DeleteMFADeviceSyncRequest) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *DeleteMFADeviceSyncRequest) GetExistingMFAResponse() *MFAAuthenticateResponse {
	if m != nil {
		return m.ExistingMFAResponse
	}
	return nil
}

// AddMFADeviceSyncRequest is a request to add a MFA device (nonstream).
type AddMFADeviceSyncRequest struct {
	// TokenID is the ID of a user token that will be used to verify this request.
	//
	// Token types accepted are:
	//  - Privilege token that is obtained with RPC CreatePrivilegeToken
	//
	// An authenticated user can register a new device using only a
	// NewMFAResponse. See [ContextUser].
	TokenID string `protobuf:"bytes,1,opt,name=TokenID,proto3" json:"token_id"`
	// ContextUser allows registering a device for the authenticated user.
	//
	// Default option if no other is provided.
	ContextUser *ContextUser `protobuf:"bytes,5,opt,name=ContextUser,proto3" json:"context_user,omitempty"`
	// NewDeviceName is the name of a new mfa device.
	NewDeviceName string `protobuf:"bytes,2,opt,name=NewDeviceName,proto3" json:"new_device_name,omitempty"`
	// NewMFAResponse is a user's new mfa response to a mfa register challenge.
	NewMFAResponse *MFARegisterResponse `protobuf:"bytes,3,opt,name=NewMFAResponse,proto3" json:"new_mfa_response,omitempty"`
	// DeviceUsage is the requested usage for the device.
	// Defaults to DEVICE_USAGE_MFA.
	DeviceUsage          DeviceUsage `protobuf:"varint,4,opt,name=DeviceUsage,proto3,enum=proto.DeviceUsage" json:"device_usage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AddMFADeviceSyncRequest) Reset()         { *m = AddMFADeviceSyncRequest{} }
func (m *AddMFADeviceSyncRequest) String() string { return proto.CompactTextString(m) }
func (*AddMFADeviceSyncRequest) ProtoMessage()    {}
func (*AddMFADeviceSyncRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{101}
}
func (m *AddMFADeviceSyncRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMFADeviceSyncRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMFADeviceSyncRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMFADeviceSyncRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMFADeviceSyncRequest.Merge(m, src)
}
func (m *AddMFADeviceSyncRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddMFADeviceSyncRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMFADeviceSyncRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddMFADeviceSyncRequest proto.InternalMessageInfo

func (m *AddMFADeviceSyncRequest) GetTokenID() string {
	if m != nil {
		return m.TokenID
	}
	return ""
}

func (m *AddMFADeviceSyncRequest) GetContextUser() *ContextUser {
	if m != nil {
		return m.ContextUser
	}
	return nil
}

func (m *AddMFADeviceSyncRequest) GetNewDeviceName() string {
	if m != nil {
		return m.NewDeviceName
	}
	return ""
}

func (m *AddMFADeviceSyncRequest) GetNewMFAResponse() *MFARegisterResponse {
	if m != nil {
		return m.NewMFAResponse
	}
	return nil
}

func (m *AddMFADeviceSyncRequest) GetDeviceUsage() DeviceUsage {
	if m != nil {
		return m.DeviceUsage
	}
	return DeviceUsage_DEVICE_USAGE_UNSPECIFIED
}

// AddMFADeviceSyncResponse is a response to AddMFADeviceSyncRequest.
type AddMFADeviceSyncResponse struct {
	Device               *types.MFADevice `protobuf:"bytes,1,opt,name=Device,proto3" json:"device"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AddMFADeviceSyncResponse) Reset()         { *m = AddMFADeviceSyncResponse{} }
func (m *AddMFADeviceSyncResponse) String() string { return proto.CompactTextString(m) }
func (*AddMFADeviceSyncResponse) ProtoMessage()    {}
func (*AddMFADeviceSyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{102}
}
func (m *AddMFADeviceSyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMFADeviceSyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMFADeviceSyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMFADeviceSyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMFADeviceSyncResponse.Merge(m, src)
}
func (m *AddMFADeviceSyncResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddMFADeviceSyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMFADeviceSyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddMFADeviceSyncResponse proto.InternalMessageInfo

func (m *AddMFADeviceSyncResponse) GetDevice() *types.MFADevice {
	if m != nil {
		return m.Device
	}
	return nil
}

// GetMFADeviceRequest is a request for MFA devices for the calling user.
type GetMFADevicesRequest struct {
	// TokenID is an optional field for the ID of a user token that will be used to
	// verify this request. Token is only required if an unauthenticated user wants to view their
	// list of devices eg: during account recovery process. An empty field implies the logged in
	// user wants to view their devices.
	// Token types accepted are:
	//  - Recovery approved token that is obtained after successful invocation of RPC
	//  VerifyAccountRecovery
	TokenID              string   `protobuf:"bytes,1,opt,name=TokenID,proto3" json:"token_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMFADevicesRequest) Reset()         { *m = GetMFADevicesRequest{} }
func (m *GetMFADevicesRequest) String() string { return proto.CompactTextString(m) }
func (*GetMFADevicesRequest) ProtoMessage()    {}
func (*GetMFADevicesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{103}
}
func (m *GetMFADevicesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMFADevicesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMFADevicesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMFADevicesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMFADevicesRequest.Merge(m, src)
}
func (m *GetMFADevicesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMFADevicesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMFADevicesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMFADevicesRequest proto.InternalMessageInfo

func (m *GetMFADevicesRequest) GetTokenID() string {
	if m != nil {
		return m.TokenID
	}
	return ""
}

// GetMFADeviceResponse is a response for GetMFADevices RPC.
type GetMFADevicesResponse struct {
	Devices              []*types.MFADevice `protobuf:"bytes,1,rep,name=Devices,proto3" json:"Devices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetMFADevicesResponse) Reset()         { *m = GetMFADevicesResponse{} }
func (m *GetMFADevicesResponse) String() string { return proto.CompactTextString(m) }
func (*GetMFADevicesResponse) ProtoMessage()    {}
func (*GetMFADevicesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{104}
}
func (m *GetMFADevicesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMFADevicesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMFADevicesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMFADevicesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMFADevicesResponse.Merge(m, src)
}
func (m *GetMFADevicesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMFADevicesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMFADevicesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMFADevicesResponse proto.InternalMessageInfo

func (m *GetMFADevicesResponse) GetDevices() []*types.MFADevice {
	if m != nil {
		return m.Devices
	}
	return nil
}

// Deprecated: Use [AuthService.GenerateUserCerts] instead.
type UserSingleUseCertsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserSingleUseCertsRequest) Reset()         { *m = UserSingleUseCertsRequest{} }
func (m *UserSingleUseCertsRequest) String() string { return proto.CompactTextString(m) }
func (*UserSingleUseCertsRequest) ProtoMessage()    {}
func (*UserSingleUseCertsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{105}
}
func (m *UserSingleUseCertsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSingleUseCertsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSingleUseCertsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSingleUseCertsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSingleUseCertsRequest.Merge(m, src)
}
func (m *UserSingleUseCertsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UserSingleUseCertsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSingleUseCertsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserSingleUseCertsRequest proto.InternalMessageInfo

// Deprecated: Use [AuthService.GenerateUserCerts] instead.
type UserSingleUseCertsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserSingleUseCertsResponse) Reset()         { *m = UserSingleUseCertsResponse{} }
func (m *UserSingleUseCertsResponse) String() string { return proto.CompactTextString(m) }
func (*UserSingleUseCertsResponse) ProtoMessage()    {}
func (*UserSingleUseCertsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{106}
}
func (m *UserSingleUseCertsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSingleUseCertsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSingleUseCertsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSingleUseCertsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSingleUseCertsResponse.Merge(m, src)
}
func (m *UserSingleUseCertsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UserSingleUseCertsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSingleUseCertsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserSingleUseCertsResponse proto.InternalMessageInfo

// IsMFARequiredRequest is a request to check whether MFA is required to access
// the Target.
type IsMFARequiredRequest struct {
	// Types that are valid to be assigned to Target:
	//	*IsMFARequiredRequest_KubernetesCluster
	//	*IsMFARequiredRequest_Database
	//	*IsMFARequiredRequest_Node
	//	*IsMFARequiredRequest_WindowsDesktop
	//	*IsMFARequiredRequest_AdminAction
	//	*IsMFARequiredRequest_App
	Target               isIsMFARequiredRequest_Target `protobuf_oneof:"Target"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *IsMFARequiredRequest) Reset()         { *m = IsMFARequiredRequest{} }
func (m *IsMFARequiredRequest) String() string { return proto.CompactTextString(m) }
func (*IsMFARequiredRequest) ProtoMessage()    {}
func (*IsMFARequiredRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{107}
}
func (m *IsMFARequiredRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsMFARequiredRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsMFARequiredRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsMFARequiredRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsMFARequiredRequest.Merge(m, src)
}
func (m *IsMFARequiredRequest) XXX_Size() int {
	return m.Size()
}
func (m *IsMFARequiredRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IsMFARequiredRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IsMFARequiredRequest proto.InternalMessageInfo

type isIsMFARequiredRequest_Target interface {
	isIsMFARequiredRequest_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type IsMFARequiredRequest_KubernetesCluster struct {
	KubernetesCluster string `protobuf:"bytes,1,opt,name=KubernetesCluster,proto3,oneof" json:"KubernetesCluster,omitempty"`
}
type IsMFARequiredRequest_Database struct {
	Database *RouteToDatabase `protobuf:"bytes,2,opt,name=Database,proto3,oneof" json:"Database,omitempty"`
}
type IsMFARequiredRequest_Node struct {
	Node *NodeLogin `protobuf:"bytes,3,opt,name=Node,proto3,oneof" json:"Node,omitempty"`
}
type IsMFARequiredRequest_WindowsDesktop struct {
	WindowsDesktop *RouteToWindowsDesktop `protobuf:"bytes,4,opt,name=WindowsDesktop,proto3,oneof" json:"WindowsDesktop,omitempty"`
}
type IsMFARequiredRequest_AdminAction struct {
	AdminAction *AdminAction `protobuf:"bytes,5,opt,name=AdminAction,proto3,oneof" json:"AdminAction,omitempty"`
}
type IsMFARequiredRequest_App struct {
	App *RouteToApp `protobuf:"bytes,6,opt,name=App,proto3,oneof" json:"App,omitempty"`
}

func (*IsMFARequiredRequest_KubernetesCluster) isIsMFARequiredRequest_Target() {}
func (*IsMFARequiredRequest_Database) isIsMFARequiredRequest_Target()          {}
func (*IsMFARequiredRequest_Node) isIsMFARequiredRequest_Target()              {}
func (*IsMFARequiredRequest_WindowsDesktop) isIsMFARequiredRequest_Target()    {}
func (*IsMFARequiredRequest_AdminAction) isIsMFARequiredRequest_Target()       {}
func (*IsMFARequiredRequest_App) isIsMFARequiredRequest_Target()               {}

func (m *IsMFARequiredRequest) GetTarget() isIsMFARequiredRequest_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *IsMFARequiredRequest) GetKubernetesCluster() string {
	if x, ok := m.GetTarget().(*IsMFARequiredRequest_KubernetesCluster); ok {
		return x.KubernetesCluster
	}
	return ""
}

func (m *IsMFARequiredRequest) GetDatabase() *RouteToDatabase {
	if x, ok := m.GetTarget().(*IsMFARequiredRequest_Database); ok {
		return x.Database
	}
	return nil
}

func (m *IsMFARequiredRequest) GetNode() *NodeLogin {
	if x, ok := m.GetTarget().(*IsMFARequiredRequest_Node); ok {
		return x.Node
	}
	return nil
}

func (m *IsMFARequiredRequest) GetWindowsDesktop() *RouteToWindowsDesktop {
	if x, ok := m.GetTarget().(*IsMFARequiredRequest_WindowsDesktop); ok {
		return x.WindowsDesktop
	}
	return nil
}

func (m *IsMFARequiredRequest) GetAdminAction() *AdminAction {
	if x, ok := m.GetTarget().(*IsMFARequiredRequest_AdminAction); ok {
		return x.AdminAction
	}
	return nil
}

func (m *IsMFARequiredRequest) GetApp() *RouteToApp {
	if x, ok := m.GetTarget().(*IsMFARequiredRequest_App); ok {
		return x.App
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IsMFARequiredRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IsMFARequiredRequest_KubernetesCluster)(nil),
		(*IsMFARequiredRequest_Database)(nil),
		(*IsMFARequiredRequest_Node)(nil),
		(*IsMFARequiredRequest_WindowsDesktop)(nil),
		(*IsMFARequiredRequest_AdminAction)(nil),
		(*IsMFARequiredRequest_App)(nil),
	}
}

// StreamSessionEventsRequest is a request containing needed data to fetch a session recording.
type StreamSessionEventsRequest struct {
	// SessionID is the ID for a given session in an UUIDv4 format.
	SessionID string `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"SessionID,omitempty"`
	// StartIndex is the index of the event to resume the stream after.
	// A StartIndex of 0 creates a new stream.
	StartIndex           int32    `protobuf:"varint,2,opt,name=StartIndex,proto3" json:"StartIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StreamSessionEventsRequest) Reset()         { *m = StreamSessionEventsRequest{} }
func (m *StreamSessionEventsRequest) String() string { return proto.CompactTextString(m) }
func (*StreamSessionEventsRequest) ProtoMessage()    {}
func (*StreamSessionEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{108}
}
func (m *StreamSessionEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamSessionEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamSessionEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamSessionEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamSessionEventsRequest.Merge(m, src)
}
func (m *StreamSessionEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamSessionEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamSessionEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamSessionEventsRequest proto.InternalMessageInfo

func (m *StreamSessionEventsRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func (m *StreamSessionEventsRequest) GetStartIndex() int32 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

// NodeLogin specifies an SSH node and OS login.
type NodeLogin struct {
	// Node can be node's hostname or UUID.
	Node string `protobuf:"bytes,1,opt,name=Node,proto3" json:"Node,omitempty"`
	// Login is the OS login name.
	Login                string   `protobuf:"bytes,2,opt,name=Login,proto3" json:"Login,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeLogin) Reset()         { *m = NodeLogin{} }
func (m *NodeLogin) String() string { return proto.CompactTextString(m) }
func (*NodeLogin) ProtoMessage()    {}
func (*NodeLogin) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{109}
}
func (m *NodeLogin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeLogin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeLogin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeLogin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeLogin.Merge(m, src)
}
func (m *NodeLogin) XXX_Size() int {
	return m.Size()
}
func (m *NodeLogin) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeLogin.DiscardUnknown(m)
}

var xxx_messageInfo_NodeLogin proto.InternalMessageInfo

func (m *NodeLogin) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *NodeLogin) GetLogin() string {
	if m != nil {
		return m.Login
	}
	return ""
}

// AdminAction specifies an admin action.
type AdminAction struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AdminAction) Reset()         { *m = AdminAction{} }
func (m *AdminAction) String() string { return proto.CompactTextString(m) }
func (*AdminAction) ProtoMessage()    {}
func (*AdminAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{110}
}
func (m *AdminAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminAction.Merge(m, src)
}
func (m *AdminAction) XXX_Size() int {
	return m.Size()
}
func (m *AdminAction) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminAction.DiscardUnknown(m)
}

var xxx_messageInfo_AdminAction proto.InternalMessageInfo

// IsMFARequiredResponse is a response for MFA requirement check.
type IsMFARequiredResponse struct {
	// Required is a simplified view over [MFARequired].
	Required bool `protobuf:"varint,1,opt,name=Required,proto3" json:"Required,omitempty"`
	// MFARequired informs whether MFA is required to access the corresponding
	// resource.
	MFARequired          MFARequired `protobuf:"varint,2,opt,name=MFARequired,proto3,enum=proto.MFARequired" json:"MFARequired,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *IsMFARequiredResponse) Reset()         { *m = IsMFARequiredResponse{} }
func (m *IsMFARequiredResponse) String() string { return proto.CompactTextString(m) }
func (*IsMFARequiredResponse) ProtoMessage()    {}
func (*IsMFARequiredResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{111}
}
func (m *IsMFARequiredResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsMFARequiredResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsMFARequiredResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsMFARequiredResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsMFARequiredResponse.Merge(m, src)
}
func (m *IsMFARequiredResponse) XXX_Size() int {
	return m.Size()
}
func (m *IsMFARequiredResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsMFARequiredResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsMFARequiredResponse proto.InternalMessageInfo

func (m *IsMFARequiredResponse) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

func (m *IsMFARequiredResponse) GetMFARequired() MFARequired {
	if m != nil {
		return m.MFARequired
	}
	return MFARequired_MFA_REQUIRED_UNSPECIFIED
}

type GetEventsRequest struct {
	// Namespace, if not set, defaults to 'default'
	Namespace string `protobuf:"bytes,1,opt,name=Namespace,proto3" json:"Namespace,omitempty"`
	// StartDate is the oldest date of returned events
	StartDate time.Time `protobuf:"bytes,2,opt,name=StartDate,proto3,stdtime" json:"StartDate"`
	// EndDate is the newest date of returned events
	EndDate time.Time `protobuf:"bytes,3,opt,name=EndDate,proto3,stdtime" json:"EndDate"`
	// EventTypes is optional, if not set, returns all events
	EventTypes []string `protobuf:"bytes,4,rep,name=EventTypes,proto3" json:"EventTypes,omitempty"`
	// Limit is the maximum amount of events returned
	Limit int32 `protobuf:"varint,5,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// StartKey is used to resume a query in order to enable pagination.
	// If the previous response had LastKey set then this should be
	// set to its value. Otherwise leave empty.
	StartKey string `protobuf:"bytes,6,opt,name=StartKey,proto3" json:"StartKey,omitempty"`
	// Order specifies an ascending or descending order of events.
	// A value of 0 means a descending order and a value of 1 means an ascending order.
	Order                Order    `protobuf:"varint,7,opt,name=Order,proto3,enum=proto.Order" json:"Order,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetEventsRequest) Reset()         { *m = GetEventsRequest{} }
func (m *GetEventsRequest) String() string { return proto.CompactTextString(m) }
func (*GetEventsRequest) ProtoMessage()    {}
func (*GetEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{112}
}
func (m *GetEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEventsRequest.Merge(m, src)
}
func (m *GetEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetEventsRequest proto.InternalMessageInfo

func (m *GetEventsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetEventsRequest) GetStartDate() time.Time {
	if m != nil {
		return m.StartDate
	}
	return time.Time{}
}

func (m *GetEventsRequest) GetEndDate() time.Time {
	if m != nil {
		return m.EndDate
	}
	return time.Time{}
}

func (m *GetEventsRequest) GetEventTypes() []string {
	if m != nil {
		return m.EventTypes
	}
	return nil
}

func (m *GetEventsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetEventsRequest) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *GetEventsRequest) GetOrder() Order {
	if m != nil {
		return m.Order
	}
	return Order_DESCENDING
}

type GetSessionEventsRequest struct {
	// StartDate is the oldest date of returned events
	StartDate time.Time `protobuf:"bytes,1,opt,name=StartDate,proto3,stdtime" json:"StartDate"`
	// EndDate is the newest date of returned events
	EndDate time.Time `protobuf:"bytes,2,opt,name=EndDate,proto3,stdtime" json:"EndDate"`
	// Limit is the maximum amount of events to retrieve.
	Limit int32 `protobuf:"varint,3,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// StartKey is used to resume a query in order to enable pagination.
	// If the previous response had LastKey set then this should be
	// set to its value. Otherwise leave empty.
	StartKey string `protobuf:"bytes,4,opt,name=StartKey,proto3" json:"StartKey,omitempty"`
	// Order specifies an ascending or descending order of events.
	// A value of 0 means a descending order and a value of 1 means an ascending order.
	Order                Order    `protobuf:"varint,5,opt,name=Order,proto3,enum=proto.Order" json:"Order,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSessionEventsRequest) Reset()         { *m = GetSessionEventsRequest{} }
func (m *GetSessionEventsRequest) String() string { return proto.CompactTextString(m) }
func (*GetSessionEventsRequest) ProtoMessage()    {}
func (*GetSessionEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{113}
}
func (m *GetSessionEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSessionEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSessionEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSessionEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSessionEventsRequest.Merge(m, src)
}
func (m *GetSessionEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSessionEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSessionEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSessionEventsRequest proto.InternalMessageInfo

func (m *GetSessionEventsRequest) GetStartDate() time.Time {
	if m != nil {
		return m.StartDate
	}
	return time.Time{}
}

func (m *GetSessionEventsRequest) GetEndDate() time.Time {
	if m != nil {
		return m.EndDate
	}
	return time.Time{}
}

func (m *GetSessionEventsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetSessionEventsRequest) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *GetSessionEventsRequest) GetOrder() Order {
	if m != nil {
		return m.Order
	}
	return Order_DESCENDING
}

type Events struct {
	// Items is a list of typed gRPC formatted audit events.
	Items []*events.OneOf `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	// the key of the last event if the returned set did not contain all events found i.e limit <
	// actual amount. this is the key clients can supply in another API request to continue fetching
	// events from the previous last position
	LastKey              string   `protobuf:"bytes,2,opt,name=LastKey,proto3" json:"LastKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Events) Reset()         { *m = Events{} }
func (m *Events) String() string { return proto.CompactTextString(m) }
func (*Events) ProtoMessage()    {}
func (*Events) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{114}
}
func (m *Events) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Events) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Events.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Events) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Events.Merge(m, src)
}
func (m *Events) XXX_Size() int {
	return m.Size()
}
func (m *Events) XXX_DiscardUnknown() {
	xxx_messageInfo_Events.DiscardUnknown(m)
}

var xxx_messageInfo_Events proto.InternalMessageInfo

func (m *Events) GetItems() []*events.OneOf {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Events) GetLastKey() string {
	if m != nil {
		return m.LastKey
	}
	return ""
}

type GetLocksRequest struct {
	// Targets is a list of targets. Every returned lock must match at least
	// one of the targets.
	Targets []*types.LockTarget `protobuf:"bytes,1,rep,name=Targets,proto3" json:"Targets,omitempty"`
	// InForceOnly specifies whether to return only those locks that are in force.
	InForceOnly          bool     `protobuf:"varint,2,opt,name=InForceOnly,proto3" json:"InForceOnly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLocksRequest) Reset()         { *m = GetLocksRequest{} }
func (m *GetLocksRequest) String() string { return proto.CompactTextString(m) }
func (*GetLocksRequest) ProtoMessage()    {}
func (*GetLocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{115}
}
func (m *GetLocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocksRequest.Merge(m, src)
}
func (m *GetLocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocksRequest proto.InternalMessageInfo

func (m *GetLocksRequest) GetTargets() []*types.LockTarget {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *GetLocksRequest) GetInForceOnly() bool {
	if m != nil {
		return m.InForceOnly
	}
	return false
}

type GetLocksResponse struct {
	// Locks is a list of locks.
	Locks                []*types.LockV2 `protobuf:"bytes,1,rep,name=Locks,proto3" json:"Locks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetLocksResponse) Reset()         { *m = GetLocksResponse{} }
func (m *GetLocksResponse) String() string { return proto.CompactTextString(m) }
func (*GetLocksResponse) ProtoMessage()    {}
func (*GetLocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{116}
}
func (m *GetLocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLocksResponse.Merge(m, src)
}
func (m *GetLocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLocksResponse proto.InternalMessageInfo

func (m *GetLocksResponse) GetLocks() []*types.LockV2 {
	if m != nil {
		return m.Locks
	}
	return nil
}

type GetLockRequest struct {
	// Name is the name of the lock to get.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLockRequest) Reset()         { *m = GetLockRequest{} }
func (m *GetLockRequest) String() string { return proto.CompactTextString(m) }
func (*GetLockRequest) ProtoMessage()    {}
func (*GetLockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{117}
}
func (m *GetLockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLockRequest.Merge(m, src)
}
func (m *GetLockRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLockRequest proto.InternalMessageInfo

func (m *GetLockRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DeleteLockRequest struct {
	// Name is the name of the lock to delete.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteLockRequest) Reset()         { *m = DeleteLockRequest{} }
func (m *DeleteLockRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteLockRequest) ProtoMessage()    {}
func (*DeleteLockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{118}
}
func (m *DeleteLockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteLockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteLockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteLockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteLockRequest.Merge(m, src)
}
func (m *DeleteLockRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteLockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteLockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteLockRequest proto.InternalMessageInfo

func (m *DeleteLockRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ReplaceRemoteLocksRequest struct {
	// ClusterName identifies the cluster from which the locks originate.
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"ClusterName,omitempty"`
	// Locks is a list of new remote locks to store.
	Locks                []*types.LockV2 `protobuf:"bytes,2,rep,name=Locks,proto3" json:"Locks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReplaceRemoteLocksRequest) Reset()         { *m = ReplaceRemoteLocksRequest{} }
func (m *ReplaceRemoteLocksRequest) String() string { return proto.CompactTextString(m) }
func (*ReplaceRemoteLocksRequest) ProtoMessage()    {}
func (*ReplaceRemoteLocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{119}
}
func (m *ReplaceRemoteLocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceRemoteLocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceRemoteLocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceRemoteLocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceRemoteLocksRequest.Merge(m, src)
}
func (m *ReplaceRemoteLocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceRemoteLocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceRemoteLocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceRemoteLocksRequest proto.InternalMessageInfo

func (m *ReplaceRemoteLocksRequest) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *ReplaceRemoteLocksRequest) GetLocks() []*types.LockV2 {
	if m != nil {
		return m.Locks
	}
	return nil
}

// GetWindowsDesktopServicesResponse contains all registered Windows desktop services.
type GetWindowsDesktopServicesResponse struct {
	// Services is a list of Windows desktop services.
	Services             []*types.WindowsDesktopServiceV3 `protobuf:"bytes,1,rep,name=services,proto3" json:"services"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *GetWindowsDesktopServicesResponse) Reset()         { *m = GetWindowsDesktopServicesResponse{} }
func (m *GetWindowsDesktopServicesResponse) String() string { return proto.CompactTextString(m) }
func (*GetWindowsDesktopServicesResponse) ProtoMessage()    {}
func (*GetWindowsDesktopServicesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{120}
}
func (m *GetWindowsDesktopServicesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWindowsDesktopServicesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWindowsDesktopServicesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWindowsDesktopServicesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWindowsDesktopServicesResponse.Merge(m, src)
}
func (m *GetWindowsDesktopServicesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWindowsDesktopServicesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWindowsDesktopServicesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWindowsDesktopServicesResponse proto.InternalMessageInfo

func (m *GetWindowsDesktopServicesResponse) GetServices() []*types.WindowsDesktopServiceV3 {
	if m != nil {
		return m.Services
	}
	return nil
}

// GetWindowsDesktopServiceRequest is a request for a specific Windows Desktop Service.
type GetWindowsDesktopServiceRequest struct {
	// Name is the name of the Windows Desktop Service to be requested.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWindowsDesktopServiceRequest) Reset()         { *m = GetWindowsDesktopServiceRequest{} }
func (m *GetWindowsDesktopServiceRequest) String() string { return proto.CompactTextString(m) }
func (*GetWindowsDesktopServiceRequest) ProtoMessage()    {}
func (*GetWindowsDesktopServiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{121}
}
func (m *GetWindowsDesktopServiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWindowsDesktopServiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWindowsDesktopServiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWindowsDesktopServiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWindowsDesktopServiceRequest.Merge(m, src)
}
func (m *GetWindowsDesktopServiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetWindowsDesktopServiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWindowsDesktopServiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWindowsDesktopServiceRequest proto.InternalMessageInfo

func (m *GetWindowsDesktopServiceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GetWindowsDesktopServiceResponse contains the requested WindowsDesktopService
type GetWindowsDesktopServiceResponse struct {
	// Service is the requested Windows Desktop Service.
	Service              *types.WindowsDesktopServiceV3 `protobuf:"bytes,1,opt,name=service,proto3" json:"service"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *GetWindowsDesktopServiceResponse) Reset()         { *m = GetWindowsDesktopServiceResponse{} }
func (m *GetWindowsDesktopServiceResponse) String() string { return proto.CompactTextString(m) }
func (*GetWindowsDesktopServiceResponse) ProtoMessage()    {}
func (*GetWindowsDesktopServiceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{122}
}
func (m *GetWindowsDesktopServiceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWindowsDesktopServiceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWindowsDesktopServiceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWindowsDesktopServiceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWindowsDesktopServiceResponse.Merge(m, src)
}
func (m *GetWindowsDesktopServiceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWindowsDesktopServiceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWindowsDesktopServiceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWindowsDesktopServiceResponse proto.InternalMessageInfo

func (m *GetWindowsDesktopServiceResponse) GetService() *types.WindowsDesktopServiceV3 {
	if m != nil {
		return m.Service
	}
	return nil
}

// DeleteWindowsDesktopServiceRequest is a request to delete a Windows desktop service.
type DeleteWindowsDesktopServiceRequest struct {
	// Name is the Windows desktop service name.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteWindowsDesktopServiceRequest) Reset()         { *m = DeleteWindowsDesktopServiceRequest{} }
func (m *DeleteWindowsDesktopServiceRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteWindowsDesktopServiceRequest) ProtoMessage()    {}
func (*DeleteWindowsDesktopServiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{123}
}
func (m *DeleteWindowsDesktopServiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteWindowsDesktopServiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteWindowsDesktopServiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteWindowsDesktopServiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteWindowsDesktopServiceRequest.Merge(m, src)
}
func (m *DeleteWindowsDesktopServiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteWindowsDesktopServiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteWindowsDesktopServiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteWindowsDesktopServiceRequest proto.InternalMessageInfo

func (m *DeleteWindowsDesktopServiceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GetWindowsDesktopsResponse contains all registered Windows desktop hosts.
type GetWindowsDesktopsResponse struct {
	// Servers is a list of Windows desktop hosts.
	Desktops             []*types.WindowsDesktopV3 `protobuf:"bytes,1,rep,name=Desktops,proto3" json:"desktops"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *GetWindowsDesktopsResponse) Reset()         { *m = GetWindowsDesktopsResponse{} }
func (m *GetWindowsDesktopsResponse) String() string { return proto.CompactTextString(m) }
func (*GetWindowsDesktopsResponse) ProtoMessage()    {}
func (*GetWindowsDesktopsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{124}
}
func (m *GetWindowsDesktopsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWindowsDesktopsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWindowsDesktopsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWindowsDesktopsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWindowsDesktopsResponse.Merge(m, src)
}
func (m *GetWindowsDesktopsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetWindowsDesktopsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWindowsDesktopsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWindowsDesktopsResponse proto.InternalMessageInfo

func (m *GetWindowsDesktopsResponse) GetDesktops() []*types.WindowsDesktopV3 {
	if m != nil {
		return m.Desktops
	}
	return nil
}

// DeleteWindowsDesktopRequest is a request to delete a Windows
// desktop host. If HostID is not specified, all Windows desktops with
// specified Name will be deleted
type DeleteWindowsDesktopRequest struct {
	// Name is the name of the Windows desktop host.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// HostID is the ID of the Windows Desktop Service reporting the desktop.
	HostID               string   `protobuf:"bytes,2,opt,name=HostID,proto3" json:"host_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteWindowsDesktopRequest) Reset()         { *m = DeleteWindowsDesktopRequest{} }
func (m *DeleteWindowsDesktopRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteWindowsDesktopRequest) ProtoMessage()    {}
func (*DeleteWindowsDesktopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{125}
}
func (m *DeleteWindowsDesktopRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteWindowsDesktopRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteWindowsDesktopRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteWindowsDesktopRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteWindowsDesktopRequest.Merge(m, src)
}
func (m *DeleteWindowsDesktopRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteWindowsDesktopRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteWindowsDesktopRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteWindowsDesktopRequest proto.InternalMessageInfo

func (m *DeleteWindowsDesktopRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteWindowsDesktopRequest) GetHostID() string {
	if m != nil {
		return m.HostID
	}
	return ""
}

// WindowsDesktopCertRequest is a request to generate a client certificate used
// for Windows RDP authentication.
type WindowsDesktopCertRequest struct {
	// CSR is the request to sign in PEM format.
	CSR []byte `protobuf:"bytes,1,opt,name=CSR,proto3" json:"CSR,omitempty"`
	// CRLEndpoint is the address of the CRL for this certificate.
	CRLEndpoint string `protobuf:"bytes,2,opt,name=CRLEndpoint,proto3" json:"CRLEndpoint,omitempty"`
	// TTL is the certificate validity period.
	TTL                  Duration `protobuf:"varint,3,opt,name=TTL,proto3,casttype=Duration" json:"TTL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WindowsDesktopCertRequest) Reset()         { *m = WindowsDesktopCertRequest{} }
func (m *WindowsDesktopCertRequest) String() string { return proto.CompactTextString(m) }
func (*WindowsDesktopCertRequest) ProtoMessage()    {}
func (*WindowsDesktopCertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{126}
}
func (m *WindowsDesktopCertRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsDesktopCertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsDesktopCertRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsDesktopCertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsDesktopCertRequest.Merge(m, src)
}
func (m *WindowsDesktopCertRequest) XXX_Size() int {
	return m.Size()
}
func (m *WindowsDesktopCertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsDesktopCertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsDesktopCertRequest proto.InternalMessageInfo

func (m *WindowsDesktopCertRequest) GetCSR() []byte {
	if m != nil {
		return m.CSR
	}
	return nil
}

func (m *WindowsDesktopCertRequest) GetCRLEndpoint() string {
	if m != nil {
		return m.CRLEndpoint
	}
	return ""
}

func (m *WindowsDesktopCertRequest) GetTTL() Duration {
	if m != nil {
		return m.TTL
	}
	return 0
}

// WindowsDesktopCertResponse contains the signed Windows RDP certificate.
type WindowsDesktopCertResponse struct {
	// Cert is the signed certificate in PEM format.
	Cert                 []byte   `protobuf:"bytes,1,opt,name=Cert,proto3" json:"Cert,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WindowsDesktopCertResponse) Reset()         { *m = WindowsDesktopCertResponse{} }
func (m *WindowsDesktopCertResponse) String() string { return proto.CompactTextString(m) }
func (*WindowsDesktopCertResponse) ProtoMessage()    {}
func (*WindowsDesktopCertResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{127}
}
func (m *WindowsDesktopCertResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WindowsDesktopCertResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WindowsDesktopCertResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WindowsDesktopCertResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WindowsDesktopCertResponse.Merge(m, src)
}
func (m *WindowsDesktopCertResponse) XXX_Size() int {
	return m.Size()
}
func (m *WindowsDesktopCertResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WindowsDesktopCertResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WindowsDesktopCertResponse proto.InternalMessageInfo

func (m *WindowsDesktopCertResponse) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

// Response message for GetDesktopBootstrapScript.
type DesktopBootstrapScriptResponse struct {
	// The PowerShell script content.
	Script               string   `protobuf:"bytes,1,opt,name=Script,proto3" json:"script"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DesktopBootstrapScriptResponse) Reset()         { *m = DesktopBootstrapScriptResponse{} }
func (m *DesktopBootstrapScriptResponse) String() string { return proto.CompactTextString(m) }
func (*DesktopBootstrapScriptResponse) ProtoMessage()    {}
func (*DesktopBootstrapScriptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{128}
}
func (m *DesktopBootstrapScriptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DesktopBootstrapScriptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DesktopBootstrapScriptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DesktopBootstrapScriptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DesktopBootstrapScriptResponse.Merge(m, src)
}
func (m *DesktopBootstrapScriptResponse) XXX_Size() int {
	return m.Size()
}
func (m *DesktopBootstrapScriptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DesktopBootstrapScriptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DesktopBootstrapScriptResponse proto.InternalMessageInfo

func (m *DesktopBootstrapScriptResponse) GetScript() string {
	if m != nil {
		return m.Script
	}
	return ""
}

// ListSAMLIdPServiceProvidersRequest is a request for a paginated list of SAML IdP service providers.
type ListSAMLIdPServiceProvidersRequest struct {
	// Limit is the maximum amount of resources to retrieve.
	Limit int32 `protobuf:"varint,1,opt,name=Limit,proto3" json:"limit,omitempty"`
	// NextKey is the key for the next page of SAML IdP service providers.
	NextKey              string   `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"next_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSAMLIdPServiceProvidersRequest) Reset()         { *m = ListSAMLIdPServiceProvidersRequest{} }
func (m *ListSAMLIdPServiceProvidersRequest) String() string { return proto.CompactTextString(m) }
func (*ListSAMLIdPServiceProvidersRequest) ProtoMessage()    {}
func (*ListSAMLIdPServiceProvidersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{129}
}
func (m *ListSAMLIdPServiceProvidersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSAMLIdPServiceProvidersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSAMLIdPServiceProvidersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSAMLIdPServiceProvidersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSAMLIdPServiceProvidersRequest.Merge(m, src)
}
func (m *ListSAMLIdPServiceProvidersRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListSAMLIdPServiceProvidersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSAMLIdPServiceProvidersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSAMLIdPServiceProvidersRequest proto.InternalMessageInfo

func (m *ListSAMLIdPServiceProvidersRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListSAMLIdPServiceProvidersRequest) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

// ListSAMLIdPServiceProvidersResponse a paginated list of SAML IdP service providers.
type ListSAMLIdPServiceProvidersResponse struct {
	// Servers is a list of SAML IdP service providers.
	ServiceProviders []*types.SAMLIdPServiceProviderV1 `protobuf:"bytes,1,rep,name=ServiceProviders,proto3" json:"service_providers"`
	// NextKey is the key for the next page of SAML IdP service providers.
	NextKey string `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"next_key,omitempty"`
	// TotalCount is the total number of resources available after filter, if any.
	TotalCount           int32    `protobuf:"varint,3,opt,name=TotalCount,proto3" json:"total_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSAMLIdPServiceProvidersResponse) Reset()         { *m = ListSAMLIdPServiceProvidersResponse{} }
func (m *ListSAMLIdPServiceProvidersResponse) String() string { return proto.CompactTextString(m) }
func (*ListSAMLIdPServiceProvidersResponse) ProtoMessage()    {}
func (*ListSAMLIdPServiceProvidersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{130}
}
func (m *ListSAMLIdPServiceProvidersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSAMLIdPServiceProvidersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSAMLIdPServiceProvidersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSAMLIdPServiceProvidersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSAMLIdPServiceProvidersResponse.Merge(m, src)
}
func (m *ListSAMLIdPServiceProvidersResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListSAMLIdPServiceProvidersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSAMLIdPServiceProvidersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSAMLIdPServiceProvidersResponse proto.InternalMessageInfo

func (m *ListSAMLIdPServiceProvidersResponse) GetServiceProviders() []*types.SAMLIdPServiceProviderV1 {
	if m != nil {
		return m.ServiceProviders
	}
	return nil
}

func (m *ListSAMLIdPServiceProvidersResponse) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

func (m *ListSAMLIdPServiceProvidersResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

// GetSAMLIdPServiceProviderRequest is a request for a specific SAML IdP service provider resource.
type GetSAMLIdPServiceProviderRequest struct {
	// Name is the name of the SAML IdP sercice provider to be requested.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSAMLIdPServiceProviderRequest) Reset()         { *m = GetSAMLIdPServiceProviderRequest{} }
func (m *GetSAMLIdPServiceProviderRequest) String() string { return proto.CompactTextString(m) }
func (*GetSAMLIdPServiceProviderRequest) ProtoMessage()    {}
func (*GetSAMLIdPServiceProviderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{131}
}
func (m *GetSAMLIdPServiceProviderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSAMLIdPServiceProviderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSAMLIdPServiceProviderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSAMLIdPServiceProviderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSAMLIdPServiceProviderRequest.Merge(m, src)
}
func (m *GetSAMLIdPServiceProviderRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSAMLIdPServiceProviderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSAMLIdPServiceProviderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSAMLIdPServiceProviderRequest proto.InternalMessageInfo

func (m *GetSAMLIdPServiceProviderRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// DeleteSAMLIdPServiceProviderRequest is a request for deleting a specific SAML IdP service provider resource.
type DeleteSAMLIdPServiceProviderRequest struct {
	// Name is the name of the SAML IdP sercice provider to be deleted.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSAMLIdPServiceProviderRequest) Reset()         { *m = DeleteSAMLIdPServiceProviderRequest{} }
func (m *DeleteSAMLIdPServiceProviderRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteSAMLIdPServiceProviderRequest) ProtoMessage()    {}
func (*DeleteSAMLIdPServiceProviderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{132}
}
func (m *DeleteSAMLIdPServiceProviderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSAMLIdPServiceProviderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteSAMLIdPServiceProviderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteSAMLIdPServiceProviderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSAMLIdPServiceProviderRequest.Merge(m, src)
}
func (m *DeleteSAMLIdPServiceProviderRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSAMLIdPServiceProviderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSAMLIdPServiceProviderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSAMLIdPServiceProviderRequest proto.InternalMessageInfo

func (m *DeleteSAMLIdPServiceProviderRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// ListUserGroupsRequest is a request for a paginated list of user groups.
type ListUserGroupsRequest struct {
	// Limit is the maximum amount of resources to retrieve.
	Limit int32 `protobuf:"varint,1,opt,name=Limit,proto3" json:"limit,omitempty"`
	// NextKey is the key for the next page of user groups.
	NextKey              string   `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"next_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUserGroupsRequest) Reset()         { *m = ListUserGroupsRequest{} }
func (m *ListUserGroupsRequest) String() string { return proto.CompactTextString(m) }
func (*ListUserGroupsRequest) ProtoMessage()    {}
func (*ListUserGroupsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{133}
}
func (m *ListUserGroupsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserGroupsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserGroupsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserGroupsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserGroupsRequest.Merge(m, src)
}
func (m *ListUserGroupsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListUserGroupsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserGroupsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserGroupsRequest proto.InternalMessageInfo

func (m *ListUserGroupsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListUserGroupsRequest) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

// ListUserGroupsResponse a paginated list of user groups.
type ListUserGroupsResponse struct {
	// UserGroups is a list of user groups.
	UserGroups []*types.UserGroupV1 `protobuf:"bytes,1,rep,name=UserGroups,proto3" json:"user_groups"`
	// NextKey is the key for the next page of user groups.
	NextKey string `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"next_key,omitempty"`
	// TotalCount is the total number of resources available after filter, if any.
	TotalCount           int32    `protobuf:"varint,3,opt,name=TotalCount,proto3" json:"total_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUserGroupsResponse) Reset()         { *m = ListUserGroupsResponse{} }
func (m *ListUserGroupsResponse) String() string { return proto.CompactTextString(m) }
func (*ListUserGroupsResponse) ProtoMessage()    {}
func (*ListUserGroupsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{134}
}
func (m *ListUserGroupsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUserGroupsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUserGroupsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUserGroupsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUserGroupsResponse.Merge(m, src)
}
func (m *ListUserGroupsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListUserGroupsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUserGroupsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUserGroupsResponse proto.InternalMessageInfo

func (m *ListUserGroupsResponse) GetUserGroups() []*types.UserGroupV1 {
	if m != nil {
		return m.UserGroups
	}
	return nil
}

func (m *ListUserGroupsResponse) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

func (m *ListUserGroupsResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

// GetUserGroupRequest is a request for a specific user group resource.
type GetUserGroupRequest struct {
	// Name is the name of the user group to be requested.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserGroupRequest) Reset()         { *m = GetUserGroupRequest{} }
func (m *GetUserGroupRequest) String() string { return proto.CompactTextString(m) }
func (*GetUserGroupRequest) ProtoMessage()    {}
func (*GetUserGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{135}
}
func (m *GetUserGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserGroupRequest.Merge(m, src)
}
func (m *GetUserGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUserGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserGroupRequest proto.InternalMessageInfo

func (m *GetUserGroupRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// DeleteUserGroupRequest is a request for deleting a specific user group resource.
type DeleteUserGroupRequest struct {
	// Name is the name of the user group to be deleted.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUserGroupRequest) Reset()         { *m = DeleteUserGroupRequest{} }
func (m *DeleteUserGroupRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteUserGroupRequest) ProtoMessage()    {}
func (*DeleteUserGroupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{136}
}
func (m *DeleteUserGroupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserGroupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserGroupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserGroupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserGroupRequest.Merge(m, src)
}
func (m *DeleteUserGroupRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserGroupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserGroupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserGroupRequest proto.InternalMessageInfo

func (m *DeleteUserGroupRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// CertAuthorityRequest is a request that identifies a Teleport CA.
type CertAuthorityRequest struct {
	// Type is either user or host certificate authority.
	Type                 github_com_gravitational_teleport_api_types.CertAuthType `protobuf:"bytes,1,opt,name=Type,proto3,casttype=github.com/gravitational/teleport/api/types.CertAuthType" json:"Type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *CertAuthorityRequest) Reset()         { *m = CertAuthorityRequest{} }
func (m *CertAuthorityRequest) String() string { return proto.CompactTextString(m) }
func (*CertAuthorityRequest) ProtoMessage()    {}
func (*CertAuthorityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{137}
}
func (m *CertAuthorityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertAuthorityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertAuthorityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertAuthorityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertAuthorityRequest.Merge(m, src)
}
func (m *CertAuthorityRequest) XXX_Size() int {
	return m.Size()
}
func (m *CertAuthorityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CertAuthorityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CertAuthorityRequest proto.InternalMessageInfo

func (m *CertAuthorityRequest) GetType() github_com_gravitational_teleport_api_types.CertAuthType {
	if m != nil {
		return m.Type
	}
	return ""
}

// CRL is the X.509 Certificate Revocation List.
type CRL struct {
	// CRL is the Certificate Revocation List in DER format.
	CRL                  []byte   `protobuf:"bytes,1,opt,name=CRL,proto3" json:"CRL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CRL) Reset()         { *m = CRL{} }
func (m *CRL) String() string { return proto.CompactTextString(m) }
func (*CRL) ProtoMessage()    {}
func (*CRL) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{138}
}
func (m *CRL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CRL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CRL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CRL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CRL.Merge(m, src)
}
func (m *CRL) XXX_Size() int {
	return m.Size()
}
func (m *CRL) XXX_DiscardUnknown() {
	xxx_messageInfo_CRL.DiscardUnknown(m)
}

var xxx_messageInfo_CRL proto.InternalMessageInfo

func (m *CRL) GetCRL() []byte {
	if m != nil {
		return m.CRL
	}
	return nil
}

// ChangeUserAuthenticationRequest defines a request to change a password and if enabled
// also adds a new MFA device from a user reset or from a new user invite. User can also skip
// setting a new password if passwordless is enabled and just provide a new webauthn register
// response.
//
// After a successful request a new web session is created.
//
// Users may also receive new recovery codes if they meet the necessary requirements. If a user
// previously had recovery codes, the previous codes become invalid as it is replaced with newly
// generated ones.
type ChangeUserAuthenticationRequest struct {
	// TokenID is the ID of a reset or invite token.
	// The token allows the user to change their credentials without being logged
	// in.
	TokenID string `protobuf:"bytes,1,opt,name=TokenID,proto3" json:"token_id"`
	// NewPassword is the new password in plain text.
	NewPassword []byte `protobuf:"bytes,2,opt,name=NewPassword,proto3" json:"new_password"`
	// NewMFARegisterResponse is a MFA response to a MFA authentication challenge.
	// This field can be empty which implies that user chose not to add a new device (allowable when
	// cluster settings enable optional second factor), or cluster settings disabled second factor.
	NewMFARegisterResponse *MFARegisterResponse `protobuf:"bytes,3,opt,name=NewMFARegisterResponse,proto3" json:"new_mfa_register_response,omitempty"`
	// NewDeviceName is the name of a new mfa or passwordless device.
	NewDeviceName string `protobuf:"bytes,4,opt,name=NewDeviceName,proto3" json:"new_device_name,omitempty"`
	// LoginIP is an IP that will be embedded in the new client's certificate for web session if successful.
	LoginIP              string   `protobuf:"bytes,5,opt,name=LoginIP,proto3" json:"login_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeUserAuthenticationRequest) Reset()         { *m = ChangeUserAuthenticationRequest{} }
func (m *ChangeUserAuthenticationRequest) String() string { return proto.CompactTextString(m) }
func (*ChangeUserAuthenticationRequest) ProtoMessage()    {}
func (*ChangeUserAuthenticationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{139}
}
func (m *ChangeUserAuthenticationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeUserAuthenticationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeUserAuthenticationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeUserAuthenticationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeUserAuthenticationRequest.Merge(m, src)
}
func (m *ChangeUserAuthenticationRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChangeUserAuthenticationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeUserAuthenticationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeUserAuthenticationRequest proto.InternalMessageInfo

func (m *ChangeUserAuthenticationRequest) GetTokenID() string {
	if m != nil {
		return m.TokenID
	}
	return ""
}

func (m *ChangeUserAuthenticationRequest) GetNewPassword() []byte {
	if m != nil {
		return m.NewPassword
	}
	return nil
}

func (m *ChangeUserAuthenticationRequest) GetNewMFARegisterResponse() *MFARegisterResponse {
	if m != nil {
		return m.NewMFARegisterResponse
	}
	return nil
}

func (m *ChangeUserAuthenticationRequest) GetNewDeviceName() string {
	if m != nil {
		return m.NewDeviceName
	}
	return ""
}

func (m *ChangeUserAuthenticationRequest) GetLoginIP() string {
	if m != nil {
		return m.LoginIP
	}
	return ""
}

// ChangeUserAuthenticationResponse is a response for ChangeUserAuthentication.
type ChangeUserAuthenticationResponse struct {
	// WebSession is a user's web sesssion created from successful changing of password.
	WebSession *types.WebSessionV2 `protobuf:"bytes,1,opt,name=WebSession,proto3" json:"web_session"`
	// Recovery holds user's new recovery related fields. Previous recovery codes become invalid.
	// This field can be empty if a user does not meet the following
	// requirements to receive recovery codes:
	//  - cloud feature is enabled
	//  - username is in valid email format
	Recovery *RecoveryCodes `protobuf:"bytes,2,opt,name=Recovery,proto3" json:"recovery,omitempty"`
	// PrivateKeyPolicyEnabled is a flag that when true means one of the private key policy was
	// set in either through cluster config or through a user's assigned role.
	PrivateKeyPolicyEnabled bool     `protobuf:"varint,3,opt,name=PrivateKeyPolicyEnabled,proto3" json:"private_key_policy_enabled,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *ChangeUserAuthenticationResponse) Reset()         { *m = ChangeUserAuthenticationResponse{} }
func (m *ChangeUserAuthenticationResponse) String() string { return proto.CompactTextString(m) }
func (*ChangeUserAuthenticationResponse) ProtoMessage()    {}
func (*ChangeUserAuthenticationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{140}
}
func (m *ChangeUserAuthenticationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeUserAuthenticationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeUserAuthenticationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeUserAuthenticationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeUserAuthenticationResponse.Merge(m, src)
}
func (m *ChangeUserAuthenticationResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChangeUserAuthenticationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeUserAuthenticationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeUserAuthenticationResponse proto.InternalMessageInfo

func (m *ChangeUserAuthenticationResponse) GetWebSession() *types.WebSessionV2 {
	if m != nil {
		return m.WebSession
	}
	return nil
}

func (m *ChangeUserAuthenticationResponse) GetRecovery() *RecoveryCodes {
	if m != nil {
		return m.Recovery
	}
	return nil
}

func (m *ChangeUserAuthenticationResponse) GetPrivateKeyPolicyEnabled() bool {
	if m != nil {
		return m.PrivateKeyPolicyEnabled
	}
	return false
}

// StartAccountRecoveryRequest defines a request to create a recovery start token for a user who is
// allowed to recover their account. The tokens ID is used as part of a URL that will be emailed to
// the user (not done in this request). Represents step 1 of the account recovery process, next step
// is RPC VerifyAccountRecovery.
type StartAccountRecoveryRequest struct {
	// Username is the requesting user. The username must meet the following requirements to be
	// allowed to recover their account:
	//  - cloud feature is enabled
	//  - username is in valid email format
	Username string `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	// RecoveryCode is one of the user's recovery code in plain text.
	RecoveryCode []byte `protobuf:"bytes,2,opt,name=RecoveryCode,proto3" json:"recovery_code"`
	// RecoverType defines what type of authentication user needs to recover.
	RecoverType          types.UserTokenUsage `protobuf:"varint,3,opt,name=RecoverType,proto3,enum=types.UserTokenUsage" json:"recover_type"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *StartAccountRecoveryRequest) Reset()         { *m = StartAccountRecoveryRequest{} }
func (m *StartAccountRecoveryRequest) String() string { return proto.CompactTextString(m) }
func (*StartAccountRecoveryRequest) ProtoMessage()    {}
func (*StartAccountRecoveryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{141}
}
func (m *StartAccountRecoveryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartAccountRecoveryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartAccountRecoveryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartAccountRecoveryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartAccountRecoveryRequest.Merge(m, src)
}
func (m *StartAccountRecoveryRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartAccountRecoveryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartAccountRecoveryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartAccountRecoveryRequest proto.InternalMessageInfo

func (m *StartAccountRecoveryRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *StartAccountRecoveryRequest) GetRecoveryCode() []byte {
	if m != nil {
		return m.RecoveryCode
	}
	return nil
}

func (m *StartAccountRecoveryRequest) GetRecoverType() types.UserTokenUsage {
	if m != nil {
		return m.RecoverType
	}
	return types.UserTokenUsage_USER_TOKEN_USAGE_UNSPECIFIED
}

// VerifyAccountRecoveryRequest is a request to create a recovery approved token that allows users
// to perform protected actions while not logged in. Represents step 2 of the account recovery
// process after RPC StartAccountRecovery, next step is RPC CompleteAccountRecovery.
type VerifyAccountRecoveryRequest struct {
	// RecoveryStartTokenID is the ID of a recovery start token that's required to verify this
	// request.
	RecoveryStartTokenID string `protobuf:"bytes,1,opt,name=RecoveryStartTokenID,proto3" json:"recovery_start_token_id"`
	// Username is the name of the user that the token belongs to, used to verify that this name
	// is the same as defined in token for use with emails.
	Username string `protobuf:"bytes,2,opt,name=Username,proto3" json:"username"`
	// AuthnCred is the authentication cred that needs to be verified.
	//
	// Types that are valid to be assigned to AuthnCred:
	//	*VerifyAccountRecoveryRequest_Password
	//	*VerifyAccountRecoveryRequest_MFAAuthenticateResponse
	AuthnCred            isVerifyAccountRecoveryRequest_AuthnCred `protobuf_oneof:"AuthnCred"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *VerifyAccountRecoveryRequest) Reset()         { *m = VerifyAccountRecoveryRequest{} }
func (m *VerifyAccountRecoveryRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyAccountRecoveryRequest) ProtoMessage()    {}
func (*VerifyAccountRecoveryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{142}
}
func (m *VerifyAccountRecoveryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyAccountRecoveryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyAccountRecoveryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyAccountRecoveryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyAccountRecoveryRequest.Merge(m, src)
}
func (m *VerifyAccountRecoveryRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyAccountRecoveryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyAccountRecoveryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyAccountRecoveryRequest proto.InternalMessageInfo

type isVerifyAccountRecoveryRequest_AuthnCred interface {
	isVerifyAccountRecoveryRequest_AuthnCred()
	MarshalTo([]byte) (int, error)
	Size() int
}

type VerifyAccountRecoveryRequest_Password struct {
	Password []byte `protobuf:"bytes,3,opt,name=Password,proto3,oneof" json:"password,omitempty"`
}
type VerifyAccountRecoveryRequest_MFAAuthenticateResponse struct {
	MFAAuthenticateResponse *MFAAuthenticateResponse `protobuf:"bytes,4,opt,name=MFAAuthenticateResponse,proto3,oneof" json:"mfa_authenticate_response,omitempty"`
}

func (*VerifyAccountRecoveryRequest_Password) isVerifyAccountRecoveryRequest_AuthnCred() {}
func (*VerifyAccountRecoveryRequest_MFAAuthenticateResponse) isVerifyAccountRecoveryRequest_AuthnCred() {
}

func (m *VerifyAccountRecoveryRequest) GetAuthnCred() isVerifyAccountRecoveryRequest_AuthnCred {
	if m != nil {
		return m.AuthnCred
	}
	return nil
}

func (m *VerifyAccountRecoveryRequest) GetRecoveryStartTokenID() string {
	if m != nil {
		return m.RecoveryStartTokenID
	}
	return ""
}

func (m *VerifyAccountRecoveryRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *VerifyAccountRecoveryRequest) GetPassword() []byte {
	if x, ok := m.GetAuthnCred().(*VerifyAccountRecoveryRequest_Password); ok {
		return x.Password
	}
	return nil
}

func (m *VerifyAccountRecoveryRequest) GetMFAAuthenticateResponse() *MFAAuthenticateResponse {
	if x, ok := m.GetAuthnCred().(*VerifyAccountRecoveryRequest_MFAAuthenticateResponse); ok {
		return x.MFAAuthenticateResponse
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VerifyAccountRecoveryRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VerifyAccountRecoveryRequest_Password)(nil),
		(*VerifyAccountRecoveryRequest_MFAAuthenticateResponse)(nil),
	}
}

// CompleteAccountRecoveryRequest is a request to set either a new password or
// add a new mfa device, allowing the user to regain access to their account with the new
// credentials. Represents the last step in the account recovery process after RPC's
// StartAccountRecovery and VerifyAccountRecovery.
type CompleteAccountRecoveryRequest struct {
	// RecoveryApprovedTokenID is the ID of a recovery approved token that's required to verify this
	// request.
	RecoveryApprovedTokenID string `protobuf:"bytes,1,opt,name=RecoveryApprovedTokenID,proto3" json:"recovery_approved_token_id"`
	// NewDeviceName is the name of a new mfa device.
	// Optional if NewPassword is used.
	NewDeviceName string `protobuf:"bytes,2,opt,name=NewDeviceName,proto3" json:"new_device_name,omitempty"`
	// NewAuthnCred contains the new authentication credential.
	//
	// Types that are valid to be assigned to NewAuthnCred:
	//	*CompleteAccountRecoveryRequest_NewPassword
	//	*CompleteAccountRecoveryRequest_NewMFAResponse
	NewAuthnCred         isCompleteAccountRecoveryRequest_NewAuthnCred `protobuf_oneof:"NewAuthnCred"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *CompleteAccountRecoveryRequest) Reset()         { *m = CompleteAccountRecoveryRequest{} }
func (m *CompleteAccountRecoveryRequest) String() string { return proto.CompactTextString(m) }
func (*CompleteAccountRecoveryRequest) ProtoMessage()    {}
func (*CompleteAccountRecoveryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{143}
}
func (m *CompleteAccountRecoveryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteAccountRecoveryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteAccountRecoveryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteAccountRecoveryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteAccountRecoveryRequest.Merge(m, src)
}
func (m *CompleteAccountRecoveryRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompleteAccountRecoveryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteAccountRecoveryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteAccountRecoveryRequest proto.InternalMessageInfo

type isCompleteAccountRecoveryRequest_NewAuthnCred interface {
	isCompleteAccountRecoveryRequest_NewAuthnCred()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CompleteAccountRecoveryRequest_NewPassword struct {
	NewPassword []byte `protobuf:"bytes,3,opt,name=NewPassword,proto3,oneof" json:"new_password,omitempty"`
}
type CompleteAccountRecoveryRequest_NewMFAResponse struct {
	NewMFAResponse *MFARegisterResponse `protobuf:"bytes,4,opt,name=NewMFAResponse,proto3,oneof" json:"new_mfa_response,omitempty"`
}

func (*CompleteAccountRecoveryRequest_NewPassword) isCompleteAccountRecoveryRequest_NewAuthnCred() {}
func (*CompleteAccountRecoveryRequest_NewMFAResponse) isCompleteAccountRecoveryRequest_NewAuthnCred() {
}

func (m *CompleteAccountRecoveryRequest) GetNewAuthnCred() isCompleteAccountRecoveryRequest_NewAuthnCred {
	if m != nil {
		return m.NewAuthnCred
	}
	return nil
}

func (m *CompleteAccountRecoveryRequest) GetRecoveryApprovedTokenID() string {
	if m != nil {
		return m.RecoveryApprovedTokenID
	}
	return ""
}

func (m *CompleteAccountRecoveryRequest) GetNewDeviceName() string {
	if m != nil {
		return m.NewDeviceName
	}
	return ""
}

func (m *CompleteAccountRecoveryRequest) GetNewPassword() []byte {
	if x, ok := m.GetNewAuthnCred().(*CompleteAccountRecoveryRequest_NewPassword); ok {
		return x.NewPassword
	}
	return nil
}

func (m *CompleteAccountRecoveryRequest) GetNewMFAResponse() *MFARegisterResponse {
	if x, ok := m.GetNewAuthnCred().(*CompleteAccountRecoveryRequest_NewMFAResponse); ok {
		return x.NewMFAResponse
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CompleteAccountRecoveryRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CompleteAccountRecoveryRequest_NewPassword)(nil),
		(*CompleteAccountRecoveryRequest_NewMFAResponse)(nil),
	}
}

// RecoveryCodes describes account recovery fields. Used as a RPC
// response or as part of a RPC response that requires any of these fields.
type RecoveryCodes struct {
	// Codes holds the list of recovery phrase words.
	// Field is only used when new recovery codes are generated and returned to user.
	Codes []string `protobuf:"bytes,1,rep,name=Codes,proto3" json:"codes,omitempty"`
	// Created is the date the recovery codes were created.
	Created              time.Time `protobuf:"bytes,2,opt,name=Created,proto3,stdtime" json:"created"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RecoveryCodes) Reset()         { *m = RecoveryCodes{} }
func (m *RecoveryCodes) String() string { return proto.CompactTextString(m) }
func (*RecoveryCodes) ProtoMessage()    {}
func (*RecoveryCodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{144}
}
func (m *RecoveryCodes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryCodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryCodes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryCodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryCodes.Merge(m, src)
}
func (m *RecoveryCodes) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryCodes) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryCodes.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryCodes proto.InternalMessageInfo

func (m *RecoveryCodes) GetCodes() []string {
	if m != nil {
		return m.Codes
	}
	return nil
}

func (m *RecoveryCodes) GetCreated() time.Time {
	if m != nil {
		return m.Created
	}
	return time.Time{}
}

// CreateAccountRecoveryCodesRequest is a request to create new set of recovery codes for a user,
// replacing and invalidating any previously existing codes. Recovery codes can only be given to
// users who meet the following requirements:
//   - cloud feature is enabled
//   - username is in valid email format
type CreateAccountRecoveryCodesRequest struct {
	// TokenID is the ID of a user token that will be used to verify this request.
	// Token types accepted are:
	//   - Recovery approved token that is obtained with RPC VerifyAccountRecovery
	//   - Privilege token that is obtained with RPC CreatePrivilegeToken
	TokenID              string   `protobuf:"bytes,1,opt,name=TokenID,proto3" json:"token_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAccountRecoveryCodesRequest) Reset()         { *m = CreateAccountRecoveryCodesRequest{} }
func (m *CreateAccountRecoveryCodesRequest) String() string { return proto.CompactTextString(m) }
func (*CreateAccountRecoveryCodesRequest) ProtoMessage()    {}
func (*CreateAccountRecoveryCodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{145}
}
func (m *CreateAccountRecoveryCodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAccountRecoveryCodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAccountRecoveryCodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAccountRecoveryCodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAccountRecoveryCodesRequest.Merge(m, src)
}
func (m *CreateAccountRecoveryCodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateAccountRecoveryCodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAccountRecoveryCodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAccountRecoveryCodesRequest proto.InternalMessageInfo

func (m *CreateAccountRecoveryCodesRequest) GetTokenID() string {
	if m != nil {
		return m.TokenID
	}
	return ""
}

// GetAccountRecoveryTokenRequest is a request to return a user token resource after verifying that
// the token in the request is not expired and is of the recovery kind.
type GetAccountRecoveryTokenRequest struct {
	// RecoveryTokenID is the ID of a recovery token to verify.
	// Recovery tokens are obtained with RPC StartAccountRecovery or VerifyAccountRecovery.
	RecoveryTokenID      string   `protobuf:"bytes,1,opt,name=RecoveryTokenID,proto3" json:"recovery_token_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAccountRecoveryTokenRequest) Reset()         { *m = GetAccountRecoveryTokenRequest{} }
func (m *GetAccountRecoveryTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GetAccountRecoveryTokenRequest) ProtoMessage()    {}
func (*GetAccountRecoveryTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{146}
}
func (m *GetAccountRecoveryTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountRecoveryTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountRecoveryTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountRecoveryTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountRecoveryTokenRequest.Merge(m, src)
}
func (m *GetAccountRecoveryTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountRecoveryTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountRecoveryTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountRecoveryTokenRequest proto.InternalMessageInfo

func (m *GetAccountRecoveryTokenRequest) GetRecoveryTokenID() string {
	if m != nil {
		return m.RecoveryTokenID
	}
	return ""
}

// GetAccountRecoveryCodesRequest is a request to return the user in context their
// recovery codes. This request will not return any secrets (the values of recovery codes).
type GetAccountRecoveryCodesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAccountRecoveryCodesRequest) Reset()         { *m = GetAccountRecoveryCodesRequest{} }
func (m *GetAccountRecoveryCodesRequest) String() string { return proto.CompactTextString(m) }
func (*GetAccountRecoveryCodesRequest) ProtoMessage()    {}
func (*GetAccountRecoveryCodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{147}
}
func (m *GetAccountRecoveryCodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountRecoveryCodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountRecoveryCodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountRecoveryCodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountRecoveryCodesRequest.Merge(m, src)
}
func (m *GetAccountRecoveryCodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountRecoveryCodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountRecoveryCodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountRecoveryCodesRequest proto.InternalMessageInfo

// UserCredentials describes fields for a user's username and password.
type UserCredentials struct {
	Username             string   `protobuf:"bytes,1,opt,name=Username,proto3" json:"username"`
	Password             []byte   `protobuf:"bytes,2,opt,name=Password,proto3" json:"password"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserCredentials) Reset()         { *m = UserCredentials{} }
func (m *UserCredentials) String() string { return proto.CompactTextString(m) }
func (*UserCredentials) ProtoMessage()    {}
func (*UserCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{148}
}
func (m *UserCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCredentials.Merge(m, src)
}
func (m *UserCredentials) XXX_Size() int {
	return m.Size()
}
func (m *UserCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_UserCredentials proto.InternalMessageInfo

func (m *UserCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserCredentials) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

// ContextUser marks requests that rely in the currently authenticated user.
type ContextUser struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContextUser) Reset()         { *m = ContextUser{} }
func (m *ContextUser) String() string { return proto.CompactTextString(m) }
func (*ContextUser) ProtoMessage()    {}
func (*ContextUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{149}
}
func (m *ContextUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContextUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContextUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContextUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContextUser.Merge(m, src)
}
func (m *ContextUser) XXX_Size() int {
	return m.Size()
}
func (m *ContextUser) XXX_DiscardUnknown() {
	xxx_messageInfo_ContextUser.DiscardUnknown(m)
}

var xxx_messageInfo_ContextUser proto.InternalMessageInfo

// Passwordless marks requests for passwordless challenges.
type Passwordless struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Passwordless) Reset()         { *m = Passwordless{} }
func (m *Passwordless) String() string { return proto.CompactTextString(m) }
func (*Passwordless) ProtoMessage()    {}
func (*Passwordless) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{150}
}
func (m *Passwordless) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Passwordless) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Passwordless.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Passwordless) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Passwordless.Merge(m, src)
}
func (m *Passwordless) XXX_Size() int {
	return m.Size()
}
func (m *Passwordless) XXX_DiscardUnknown() {
	xxx_messageInfo_Passwordless.DiscardUnknown(m)
}

var xxx_messageInfo_Passwordless proto.InternalMessageInfo

// CreateAuthenticateChallengeRequest is a request for creating MFA authentication challenges for a
// users mfa devices.
type CreateAuthenticateChallengeRequest struct {
	// Request defines how the request will be verified before creating challenges.
	// An empty Request is equivalent to context_user being set.
	//
	// Types that are valid to be assigned to Request:
	//	*CreateAuthenticateChallengeRequest_UserCredentials
	//	*CreateAuthenticateChallengeRequest_RecoveryStartTokenID
	//	*CreateAuthenticateChallengeRequest_ContextUser
	//	*CreateAuthenticateChallengeRequest_Passwordless
	Request isCreateAuthenticateChallengeRequest_Request `protobuf_oneof:"Request"`
	// MFARequiredCheck, if set, is used to verify if MFA is necessary for the
	// request. It's akin to a call to [AuthService.IsMFARequired].
	//
	// If MFA is not required, then no challenges are issued in the
	// [MFAAuthenticateResponse].
	//
	// MFA verification should run in the cluster that holds the target resource.
	// If you are issuing challenges from the root cluster, but accessing a leaf,
	// call [AuthService.IsMFARequired] in the leaf instead of setting this field.
	MFARequiredCheck *IsMFARequiredRequest `protobuf:"bytes,5,opt,name=MFARequiredCheck,proto3" json:"mfa_required_check,omitempty"`
	// ChallengeExtensions are extensions that will be apply to the issued MFA challenge.
	// ChallengeExtensions only apply to webauthn challenges currently. Required, except
	// for v15 clients and older.
	ChallengeExtensions  *v11.ChallengeExtensions `protobuf:"bytes,6,opt,name=ChallengeExtensions,proto3" json:"challenge_extensions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CreateAuthenticateChallengeRequest) Reset()         { *m = CreateAuthenticateChallengeRequest{} }
func (m *CreateAuthenticateChallengeRequest) String() string { return proto.CompactTextString(m) }
func (*CreateAuthenticateChallengeRequest) ProtoMessage()    {}
func (*CreateAuthenticateChallengeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{151}
}
func (m *CreateAuthenticateChallengeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAuthenticateChallengeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAuthenticateChallengeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateAuthenticateChallengeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAuthenticateChallengeRequest.Merge(m, src)
}
func (m *CreateAuthenticateChallengeRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateAuthenticateChallengeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAuthenticateChallengeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAuthenticateChallengeRequest proto.InternalMessageInfo

type isCreateAuthenticateChallengeRequest_Request interface {
	isCreateAuthenticateChallengeRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateAuthenticateChallengeRequest_UserCredentials struct {
	UserCredentials *UserCredentials `protobuf:"bytes,1,opt,name=UserCredentials,proto3,oneof" json:"user_credentials,omitempty"`
}
type CreateAuthenticateChallengeRequest_RecoveryStartTokenID struct {
	RecoveryStartTokenID string `protobuf:"bytes,2,opt,name=RecoveryStartTokenID,proto3,oneof" json:"recovery_start_token_id,omitempty"`
}
type CreateAuthenticateChallengeRequest_ContextUser struct {
	ContextUser *ContextUser `protobuf:"bytes,3,opt,name=ContextUser,proto3,oneof" json:"context_user,omitempty"`
}
type CreateAuthenticateChallengeRequest_Passwordless struct {
	Passwordless *Passwordless `protobuf:"bytes,4,opt,name=Passwordless,proto3,oneof" json:"passwordless,omitempty"`
}

func (*CreateAuthenticateChallengeRequest_UserCredentials) isCreateAuthenticateChallengeRequest_Request() {
}
func (*CreateAuthenticateChallengeRequest_RecoveryStartTokenID) isCreateAuthenticateChallengeRequest_Request() {
}
func (*CreateAuthenticateChallengeRequest_ContextUser) isCreateAuthenticateChallengeRequest_Request() {
}
func (*CreateAuthenticateChallengeRequest_Passwordless) isCreateAuthenticateChallengeRequest_Request() {
}

func (m *CreateAuthenticateChallengeRequest) GetRequest() isCreateAuthenticateChallengeRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CreateAuthenticateChallengeRequest) GetUserCredentials() *UserCredentials {
	if x, ok := m.GetRequest().(*CreateAuthenticateChallengeRequest_UserCredentials); ok {
		return x.UserCredentials
	}
	return nil
}

func (m *CreateAuthenticateChallengeRequest) GetRecoveryStartTokenID() string {
	if x, ok := m.GetRequest().(*CreateAuthenticateChallengeRequest_RecoveryStartTokenID); ok {
		return x.RecoveryStartTokenID
	}
	return ""
}

func (m *CreateAuthenticateChallengeRequest) GetContextUser() *ContextUser {
	if x, ok := m.GetRequest().(*CreateAuthenticateChallengeRequest_ContextUser); ok {
		return x.ContextUser
	}
	return nil
}

func (m *CreateAuthenticateChallengeRequest) GetPasswordless() *Passwordless {
	if x, ok := m.GetRequest().(*CreateAuthenticateChallengeRequest_Passwordless); ok {
		return x.Passwordless
	}
	return nil
}

func (m *CreateAuthenticateChallengeRequest) GetMFARequiredCheck() *IsMFARequiredRequest {
	if m != nil {
		return m.MFARequiredCheck
	}
	return nil
}

func (m *CreateAuthenticateChallengeRequest) GetChallengeExtensions() *v11.ChallengeExtensions {
	if m != nil {
		return m.ChallengeExtensions
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateAuthenticateChallengeRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateAuthenticateChallengeRequest_UserCredentials)(nil),
		(*CreateAuthenticateChallengeRequest_RecoveryStartTokenID)(nil),
		(*CreateAuthenticateChallengeRequest_ContextUser)(nil),
		(*CreateAuthenticateChallengeRequest_Passwordless)(nil),
	}
}

// CreatePrivilegeTokenRequest defines a request to obtain a privilege token.
// Only logged in users are allowed to obtain privilege tokens after they have successfully
// re-authenticated with their second factor.
type CreatePrivilegeTokenRequest struct {
	// ExistingMFAResponse is a response to a challenge from the user's existing MFA devices.
	// This field can be empty to create a UserTokenTypePrivilegeException token that
	// allows a user to bypass second factor re-authentication eg: allowing a user
	// with no mfa devices to add a device without re-authenticating.
	ExistingMFAResponse  *MFAAuthenticateResponse `protobuf:"bytes,1,opt,name=ExistingMFAResponse,proto3" json:"existing_mfa_response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CreatePrivilegeTokenRequest) Reset()         { *m = CreatePrivilegeTokenRequest{} }
func (m *CreatePrivilegeTokenRequest) String() string { return proto.CompactTextString(m) }
func (*CreatePrivilegeTokenRequest) ProtoMessage()    {}
func (*CreatePrivilegeTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{152}
}
func (m *CreatePrivilegeTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePrivilegeTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePrivilegeTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePrivilegeTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePrivilegeTokenRequest.Merge(m, src)
}
func (m *CreatePrivilegeTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreatePrivilegeTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePrivilegeTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePrivilegeTokenRequest proto.InternalMessageInfo

func (m *CreatePrivilegeTokenRequest) GetExistingMFAResponse() *MFAAuthenticateResponse {
	if m != nil {
		return m.ExistingMFAResponse
	}
	return nil
}

// CreateRegisterChallengeRequest is a request for creating MFA register challenge for a
// new MFA device.
type CreateRegisterChallengeRequest struct {
	// TokenID is the ID of a user token that will be used to verify this request.
	// Either TokenID or ExistingMFAResponse are required.
	//
	// All user token types are accepted except UserTokenTypeRecoveryStart.
	//
	// An authenticated user can create challenges without a token by supplying an
	// ExistingMFAResponse.
	TokenID string `protobuf:"bytes,1,opt,name=TokenID,proto3" json:"token_id"`
	// ExistingMFAResponse is a response to ExistingMFAChallenge auth challenge.
	// Either ExistingMFAResponse or TokenID are required.
	//
	// Note that a user with no devices can create the initial register challenge,
	// in the same manner that they could create a privilege token.
	//
	// See the [AuthService.CreateAuthenticateChallenge] RPC.
	ExistingMFAResponse *MFAAuthenticateResponse `protobuf:"bytes,4,opt,name=ExistingMFAResponse,proto3" json:"ExistingMFAResponse,omitempty"`
	// DeviceType is the type of MFA device to make a register challenge for.
	DeviceType DeviceType `protobuf:"varint,2,opt,name=DeviceType,proto3,enum=proto.DeviceType" json:"device_type"`
	// DeviceUsage is the requested usage for the device.
	// Defaults to DEVICE_USAGE_MFA.
	DeviceUsage          DeviceUsage `protobuf:"varint,3,opt,name=DeviceUsage,proto3,enum=proto.DeviceUsage" json:"device_usage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CreateRegisterChallengeRequest) Reset()         { *m = CreateRegisterChallengeRequest{} }
func (m *CreateRegisterChallengeRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRegisterChallengeRequest) ProtoMessage()    {}
func (*CreateRegisterChallengeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{153}
}
func (m *CreateRegisterChallengeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateRegisterChallengeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateRegisterChallengeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateRegisterChallengeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRegisterChallengeRequest.Merge(m, src)
}
func (m *CreateRegisterChallengeRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateRegisterChallengeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRegisterChallengeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRegisterChallengeRequest proto.InternalMessageInfo

func (m *CreateRegisterChallengeRequest) GetTokenID() string {
	if m != nil {
		return m.TokenID
	}
	return ""
}

func (m *CreateRegisterChallengeRequest) GetExistingMFAResponse() *MFAAuthenticateResponse {
	if m != nil {
		return m.ExistingMFAResponse
	}
	return nil
}

func (m *CreateRegisterChallengeRequest) GetDeviceType() DeviceType {
	if m != nil {
		return m.DeviceType
	}
	return DeviceType_DEVICE_TYPE_UNSPECIFIED
}

func (m *CreateRegisterChallengeRequest) GetDeviceUsage() DeviceUsage {
	if m != nil {
		return m.DeviceUsage
	}
	return DeviceUsage_DEVICE_USAGE_UNSPECIFIED
}

// PaginatedResource represents one of the supported resources.
type PaginatedResource struct {
	// Resource is the resource itself.
	//
	// Types that are valid to be assigned to Resource:
	//	*PaginatedResource_DatabaseServer
	//	*PaginatedResource_AppServer
	//	*PaginatedResource_Node
	//	*PaginatedResource_WindowsDesktop
	//	*PaginatedResource_KubeCluster
	//	*PaginatedResource_KubernetesServer
	//	*PaginatedResource_WindowsDesktopService
	//	*PaginatedResource_DatabaseService
	//	*PaginatedResource_UserGroup
	//	*PaginatedResource_AppServerOrSAMLIdPServiceProvider
	//	*PaginatedResource_SAMLIdPServiceProvider
	Resource isPaginatedResource_Resource `protobuf_oneof:"resource"`
	// Logins allowed for the included resource. Only to be populated for SSH and Desktops.
	Logins []string `protobuf:"bytes,13,rep,name=Logins,proto3" json:"logins,omitempty"`
	// RequiresRequest indicates if a resource requires an access request to access. Only populated with requests
	// that IncludeRequestable.
	RequiresRequest      bool     `protobuf:"varint,14,opt,name=RequiresRequest,proto3" json:"requires_request,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PaginatedResource) Reset()         { *m = PaginatedResource{} }
func (m *PaginatedResource) String() string { return proto.CompactTextString(m) }
func (*PaginatedResource) ProtoMessage()    {}
func (*PaginatedResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{154}
}
func (m *PaginatedResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaginatedResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaginatedResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaginatedResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaginatedResource.Merge(m, src)
}
func (m *PaginatedResource) XXX_Size() int {
	return m.Size()
}
func (m *PaginatedResource) XXX_DiscardUnknown() {
	xxx_messageInfo_PaginatedResource.DiscardUnknown(m)
}

var xxx_messageInfo_PaginatedResource proto.InternalMessageInfo

type isPaginatedResource_Resource interface {
	isPaginatedResource_Resource()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PaginatedResource_DatabaseServer struct {
	DatabaseServer *types.DatabaseServerV3 `protobuf:"bytes,1,opt,name=DatabaseServer,proto3,oneof" json:"DatabaseServer,omitempty"`
}
type PaginatedResource_AppServer struct {
	AppServer *types.AppServerV3 `protobuf:"bytes,2,opt,name=AppServer,proto3,oneof" json:"AppServer,omitempty"`
}
type PaginatedResource_Node struct {
	Node *types.ServerV2 `protobuf:"bytes,3,opt,name=Node,proto3,oneof" json:"node,omitempty"`
}
type PaginatedResource_WindowsDesktop struct {
	WindowsDesktop *types.WindowsDesktopV3 `protobuf:"bytes,5,opt,name=WindowsDesktop,proto3,oneof" json:"windows_desktop,omitempty"`
}
type PaginatedResource_KubeCluster struct {
	KubeCluster *types.KubernetesClusterV3 `protobuf:"bytes,6,opt,name=KubeCluster,proto3,oneof" json:"kube_cluster,omitempty"`
}
type PaginatedResource_KubernetesServer struct {
	KubernetesServer *types.KubernetesServerV3 `protobuf:"bytes,7,opt,name=KubernetesServer,proto3,oneof" json:"kubernetes_server,omitempty"`
}
type PaginatedResource_WindowsDesktopService struct {
	WindowsDesktopService *types.WindowsDesktopServiceV3 `protobuf:"bytes,8,opt,name=WindowsDesktopService,proto3,oneof" json:"windows_desktop_service,omitempty"`
}
type PaginatedResource_DatabaseService struct {
	DatabaseService *types.DatabaseServiceV1 `protobuf:"bytes,9,opt,name=DatabaseService,proto3,oneof" json:"database_service,omitempty"`
}
type PaginatedResource_UserGroup struct {
	UserGroup *types.UserGroupV1 `protobuf:"bytes,10,opt,name=UserGroup,proto3,oneof" json:"user_group,omitempty"`
}
type PaginatedResource_AppServerOrSAMLIdPServiceProvider struct {
	AppServerOrSAMLIdPServiceProvider *types.AppServerOrSAMLIdPServiceProviderV1 `protobuf:"bytes,11,opt,name=AppServerOrSAMLIdPServiceProvider,proto3,oneof" json:"AppServerOrSAMLIdPServiceProvider,omitempty"`
}
type PaginatedResource_SAMLIdPServiceProvider struct {
	SAMLIdPServiceProvider *types.SAMLIdPServiceProviderV1 `protobuf:"bytes,12,opt,name=SAMLIdPServiceProvider,proto3,oneof" json:"saml_idp_service_provider,omitempty"`
}

func (*PaginatedResource_DatabaseServer) isPaginatedResource_Resource()                    {}
func (*PaginatedResource_AppServer) isPaginatedResource_Resource()                         {}
func (*PaginatedResource_Node) isPaginatedResource_Resource()                              {}
func (*PaginatedResource_WindowsDesktop) isPaginatedResource_Resource()                    {}
func (*PaginatedResource_KubeCluster) isPaginatedResource_Resource()                       {}
func (*PaginatedResource_KubernetesServer) isPaginatedResource_Resource()                  {}
func (*PaginatedResource_WindowsDesktopService) isPaginatedResource_Resource()             {}
func (*PaginatedResource_DatabaseService) isPaginatedResource_Resource()                   {}
func (*PaginatedResource_UserGroup) isPaginatedResource_Resource()                         {}
func (*PaginatedResource_AppServerOrSAMLIdPServiceProvider) isPaginatedResource_Resource() {}
func (*PaginatedResource_SAMLIdPServiceProvider) isPaginatedResource_Resource()            {}

func (m *PaginatedResource) GetResource() isPaginatedResource_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *PaginatedResource) GetDatabaseServer() *types.DatabaseServerV3 {
	if x, ok := m.GetResource().(*PaginatedResource_DatabaseServer); ok {
		return x.DatabaseServer
	}
	return nil
}

func (m *PaginatedResource) GetAppServer() *types.AppServerV3 {
	if x, ok := m.GetResource().(*PaginatedResource_AppServer); ok {
		return x.AppServer
	}
	return nil
}

func (m *PaginatedResource) GetNode() *types.ServerV2 {
	if x, ok := m.GetResource().(*PaginatedResource_Node); ok {
		return x.Node
	}
	return nil
}

func (m *PaginatedResource) GetWindowsDesktop() *types.WindowsDesktopV3 {
	if x, ok := m.GetResource().(*PaginatedResource_WindowsDesktop); ok {
		return x.WindowsDesktop
	}
	return nil
}

func (m *PaginatedResource) GetKubeCluster() *types.KubernetesClusterV3 {
	if x, ok := m.GetResource().(*PaginatedResource_KubeCluster); ok {
		return x.KubeCluster
	}
	return nil
}

func (m *PaginatedResource) GetKubernetesServer() *types.KubernetesServerV3 {
	if x, ok := m.GetResource().(*PaginatedResource_KubernetesServer); ok {
		return x.KubernetesServer
	}
	return nil
}

func (m *PaginatedResource) GetWindowsDesktopService() *types.WindowsDesktopServiceV3 {
	if x, ok := m.GetResource().(*PaginatedResource_WindowsDesktopService); ok {
		return x.WindowsDesktopService
	}
	return nil
}

func (m *PaginatedResource) GetDatabaseService() *types.DatabaseServiceV1 {
	if x, ok := m.GetResource().(*PaginatedResource_DatabaseService); ok {
		return x.DatabaseService
	}
	return nil
}

func (m *PaginatedResource) GetUserGroup() *types.UserGroupV1 {
	if x, ok := m.GetResource().(*PaginatedResource_UserGroup); ok {
		return x.UserGroup
	}
	return nil
}

// Deprecated: Do not use.
func (m *PaginatedResource) GetAppServerOrSAMLIdPServiceProvider() *types.AppServerOrSAMLIdPServiceProviderV1 {
	if x, ok := m.GetResource().(*PaginatedResource_AppServerOrSAMLIdPServiceProvider); ok {
		return x.AppServerOrSAMLIdPServiceProvider
	}
	return nil
}

func (m *PaginatedResource) GetSAMLIdPServiceProvider() *types.SAMLIdPServiceProviderV1 {
	if x, ok := m.GetResource().(*PaginatedResource_SAMLIdPServiceProvider); ok {
		return x.SAMLIdPServiceProvider
	}
	return nil
}

func (m *PaginatedResource) GetLogins() []string {
	if m != nil {
		return m.Logins
	}
	return nil
}

func (m *PaginatedResource) GetRequiresRequest() bool {
	if m != nil {
		return m.RequiresRequest
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PaginatedResource) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PaginatedResource_DatabaseServer)(nil),
		(*PaginatedResource_AppServer)(nil),
		(*PaginatedResource_Node)(nil),
		(*PaginatedResource_WindowsDesktop)(nil),
		(*PaginatedResource_KubeCluster)(nil),
		(*PaginatedResource_KubernetesServer)(nil),
		(*PaginatedResource_WindowsDesktopService)(nil),
		(*PaginatedResource_DatabaseService)(nil),
		(*PaginatedResource_UserGroup)(nil),
		(*PaginatedResource_AppServerOrSAMLIdPServiceProvider)(nil),
		(*PaginatedResource_SAMLIdPServiceProvider)(nil),
	}
}

// ListUnifiedResourcesRequest is a request to receive a paginated list of unified resources
type ListUnifiedResourcesRequest struct {
	// Kinds is a list of kinds to match against a resource's kind. This can be used in a
	// unified resource request that can include multiple types.
	Kinds []string `protobuf:"bytes,1,rep,name=Kinds,proto3" json:"kinds,omitempty"`
	// Limit is the maximum amount of resources to retrieve.
	Limit int32 `protobuf:"varint,2,opt,name=Limit,proto3" json:"limit,omitempty"`
	// StartKey is used to start listing resources from a specific spot. It
	// should be set to the previous NextKey value if using pagination, or
	// left empty.
	StartKey string `protobuf:"bytes,3,opt,name=StartKey,proto3" json:"start_key,omitempty"`
	// Labels is a label-based matcher if non-empty.
	Labels map[string]string `protobuf:"bytes,4,rep,name=Labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// PredicateExpression defines boolean conditions that will be matched against the resource.
	PredicateExpression string `protobuf:"bytes,5,opt,name=PredicateExpression,proto3" json:"predicate_expression,omitempty"`
	// SearchKeywords is a list of search keywords to match against resource field values.
	SearchKeywords []string `protobuf:"bytes,6,rep,name=SearchKeywords,proto3" json:"search_keywords,omitempty"`
	// SortBy describes which resource field and which direction to sort by.
	SortBy types.SortBy `protobuf:"bytes,7,opt,name=SortBy,proto3" json:"sort_by,omitempty"`
	// WindowsDesktopFilter specifies windows desktop specific filters.
	WindowsDesktopFilter types.WindowsDesktopFilter `protobuf:"bytes,8,opt,name=WindowsDesktopFilter,proto3" json:"windows_desktop_filter,omitempty"`
	// UseSearchAsRoles indicates that the response should include all resources
	// the caller is able to request access to using search_as_roles
	UseSearchAsRoles bool `protobuf:"varint,9,opt,name=UseSearchAsRoles,proto3" json:"use_search_as_roles,omitempty"`
	// UsePreviewAsRoles indicates that the response should include all resources
	// the caller would be able to access with their preview_as_roles
	UsePreviewAsRoles bool `protobuf:"varint,10,opt,name=UsePreviewAsRoles,proto3" json:"use_preview_as_roles,omitempty"`
	// PinnedOnly indicates that the request will pull only the pinned resources
	// of the requesting user
	PinnedOnly bool `protobuf:"varint,11,opt,name=PinnedOnly,proto3" json:"pinned_only,omitempty"`
	// IncludeLogins indicates that the response should include a users allowed logins
	// for all returned resources.
	IncludeLogins bool `protobuf:"varint,12,opt,name=IncludeLogins,proto3" json:"include_logins,omitempty"`
	// IncludeRequestable indicates that the response should include resources that the user must request access to.
	IncludeRequestable   bool     `protobuf:"varint,14,opt,name=IncludeRequestable,proto3" json:"include_proto,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUnifiedResourcesRequest) Reset()         { *m = ListUnifiedResourcesRequest{} }
func (m *ListUnifiedResourcesRequest) String() string { return proto.CompactTextString(m) }
func (*ListUnifiedResourcesRequest) ProtoMessage()    {}
func (*ListUnifiedResourcesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{155}
}
func (m *ListUnifiedResourcesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUnifiedResourcesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUnifiedResourcesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUnifiedResourcesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUnifiedResourcesRequest.Merge(m, src)
}
func (m *ListUnifiedResourcesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListUnifiedResourcesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUnifiedResourcesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUnifiedResourcesRequest proto.InternalMessageInfo

func (m *ListUnifiedResourcesRequest) GetKinds() []string {
	if m != nil {
		return m.Kinds
	}
	return nil
}

func (m *ListUnifiedResourcesRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListUnifiedResourcesRequest) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *ListUnifiedResourcesRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ListUnifiedResourcesRequest) GetPredicateExpression() string {
	if m != nil {
		return m.PredicateExpression
	}
	return ""
}

func (m *ListUnifiedResourcesRequest) GetSearchKeywords() []string {
	if m != nil {
		return m.SearchKeywords
	}
	return nil
}

func (m *ListUnifiedResourcesRequest) GetSortBy() types.SortBy {
	if m != nil {
		return m.SortBy
	}
	return types.SortBy{}
}

func (m *ListUnifiedResourcesRequest) GetWindowsDesktopFilter() types.WindowsDesktopFilter {
	if m != nil {
		return m.WindowsDesktopFilter
	}
	return types.WindowsDesktopFilter{}
}

func (m *ListUnifiedResourcesRequest) GetUseSearchAsRoles() bool {
	if m != nil {
		return m.UseSearchAsRoles
	}
	return false
}

func (m *ListUnifiedResourcesRequest) GetUsePreviewAsRoles() bool {
	if m != nil {
		return m.UsePreviewAsRoles
	}
	return false
}

func (m *ListUnifiedResourcesRequest) GetPinnedOnly() bool {
	if m != nil {
		return m.PinnedOnly
	}
	return false
}

func (m *ListUnifiedResourcesRequest) GetIncludeLogins() bool {
	if m != nil {
		return m.IncludeLogins
	}
	return false
}

func (m *ListUnifiedResourcesRequest) GetIncludeRequestable() bool {
	if m != nil {
		return m.IncludeRequestable
	}
	return false
}

// ListUnifiedResourceResponse response of ListUnifiedResources.
type ListUnifiedResourcesResponse struct {
	// Resources is a list of resource.
	Resources []*PaginatedResource `protobuf:"bytes,1,rep,name=Resources,proto3" json:"resources,omitempty"`
	// NextKey is the next Key to use as StartKey in a ListResourcesRequest to
	// continue retrieving pages of resource. If NextKey is empty, there are no
	// more pages.
	NextKey              string   `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"next_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListUnifiedResourcesResponse) Reset()         { *m = ListUnifiedResourcesResponse{} }
func (m *ListUnifiedResourcesResponse) String() string { return proto.CompactTextString(m) }
func (*ListUnifiedResourcesResponse) ProtoMessage()    {}
func (*ListUnifiedResourcesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{156}
}
func (m *ListUnifiedResourcesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUnifiedResourcesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUnifiedResourcesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUnifiedResourcesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUnifiedResourcesResponse.Merge(m, src)
}
func (m *ListUnifiedResourcesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListUnifiedResourcesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUnifiedResourcesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListUnifiedResourcesResponse proto.InternalMessageInfo

func (m *ListUnifiedResourcesResponse) GetResources() []*PaginatedResource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ListUnifiedResourcesResponse) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

// ListResourcesRequest defines a request to retrieve resources paginated. Only
// one type of resource can be retrieved per request.
//
// NOTE: There are two paths this request can take:
//  1. ListResources: the more efficient path that retrieves resources by subset
//     at a time defined by field 'Limit'. Does NOT de-duplicate matches.
//  2. listResourcesWithSort: the less efficient path that retrieves all resources
//     upfront by falling back to the traditional GetXXX calls. Used when sorting (SortBy),
//     total count of resources (NeedTotalCount), or ResourceType `KindKubernetesCluster`
//     is requested. Matches are de-duplicated.
type ListResourcesRequest struct {
	// ResourceType is the resource that is going to be retrieved.
	// This only needs to be set explicitly for the `ListResources` rpc.
	ResourceType string `protobuf:"bytes,1,opt,name=ResourceType,proto3" json:"resource_type,omitempty"`
	// Namespace is the namespace of resources.
	Namespace string `protobuf:"bytes,2,opt,name=Namespace,proto3" json:"namespace,omitempty"`
	// Limit is the maximum amount of resources to retrieve.
	Limit int32 `protobuf:"varint,3,opt,name=Limit,proto3" json:"limit,omitempty"`
	// StartKey is used to start listing resources from a specific spot. It
	// should be set to the previous NextKey value if using pagination, or
	// left empty.
	StartKey string `protobuf:"bytes,4,opt,name=StartKey,proto3" json:"start_key,omitempty"`
	// Labels is a label-based matcher if non-empty.
	Labels map[string]string `protobuf:"bytes,5,rep,name=Labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// PredicateExpression defines boolean conditions that will be matched against the resource.
	PredicateExpression string `protobuf:"bytes,6,opt,name=PredicateExpression,proto3" json:"predicate_expression,omitempty"`
	// SearchKeywords is a list of search keywords to match against resource field values.
	SearchKeywords []string `protobuf:"bytes,7,rep,name=SearchKeywords,proto3" json:"search_keywords,omitempty"`
	// SortBy describes which resource field and which direction to sort by.
	SortBy types.SortBy `protobuf:"bytes,8,opt,name=SortBy,proto3" json:"sort_by,omitempty"`
	// NeedTotalCount indicates whether or not the caller also wants the total number of resources
	// after filtering.
	NeedTotalCount bool `protobuf:"varint,9,opt,name=NeedTotalCount,proto3" json:"need_total_count,omitempty"`
	// WindowsDesktopFilter specifies windows desktop specific filters.
	WindowsDesktopFilter types.WindowsDesktopFilter `protobuf:"bytes,10,opt,name=WindowsDesktopFilter,proto3" json:"windows_desktop_filter,omitempty"`
	// UseSearchAsRoles indicates that the response should include all resources
	// the caller is able to request access to using search_as_roles
	UseSearchAsRoles bool `protobuf:"varint,11,opt,name=UseSearchAsRoles,proto3" json:"use_search_as_roles,omitempty"`
	// UsePreviewAsRoles indicates that the response should include all resources
	// the caller would be able to access with their preview_as_roles
	UsePreviewAsRoles bool `protobuf:"varint,12,opt,name=UsePreviewAsRoles,proto3" json:"use_preview_as_roles,omitempty"`
	// IncludeLogins indicates that the response should include a users allowed logins
	// for all returned resources.
	IncludeLogins        bool     `protobuf:"varint,13,opt,name=IncludeLogins,proto3" json:"include_logins,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListResourcesRequest) Reset()         { *m = ListResourcesRequest{} }
func (m *ListResourcesRequest) String() string { return proto.CompactTextString(m) }
func (*ListResourcesRequest) ProtoMessage()    {}
func (*ListResourcesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{157}
}
func (m *ListResourcesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResourcesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResourcesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListResourcesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResourcesRequest.Merge(m, src)
}
func (m *ListResourcesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListResourcesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResourcesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListResourcesRequest proto.InternalMessageInfo

func (m *ListResourcesRequest) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *ListResourcesRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListResourcesRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListResourcesRequest) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *ListResourcesRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ListResourcesRequest) GetPredicateExpression() string {
	if m != nil {
		return m.PredicateExpression
	}
	return ""
}

func (m *ListResourcesRequest) GetSearchKeywords() []string {
	if m != nil {
		return m.SearchKeywords
	}
	return nil
}

func (m *ListResourcesRequest) GetSortBy() types.SortBy {
	if m != nil {
		return m.SortBy
	}
	return types.SortBy{}
}

func (m *ListResourcesRequest) GetNeedTotalCount() bool {
	if m != nil {
		return m.NeedTotalCount
	}
	return false
}

func (m *ListResourcesRequest) GetWindowsDesktopFilter() types.WindowsDesktopFilter {
	if m != nil {
		return m.WindowsDesktopFilter
	}
	return types.WindowsDesktopFilter{}
}

func (m *ListResourcesRequest) GetUseSearchAsRoles() bool {
	if m != nil {
		return m.UseSearchAsRoles
	}
	return false
}

func (m *ListResourcesRequest) GetUsePreviewAsRoles() bool {
	if m != nil {
		return m.UsePreviewAsRoles
	}
	return false
}

func (m *ListResourcesRequest) GetIncludeLogins() bool {
	if m != nil {
		return m.IncludeLogins
	}
	return false
}

// GetSSHTargetsRequest gets all servers that might match an equivalent ssh dial request.
type GetSSHTargetsRequest struct {
	// Host is the target host as would be sent to the proxy during a dial request.
	Host string `protobuf:"bytes,1,opt,name=Host,proto3" json:"Host,omitempty"`
	// Port is the ssh port. This value is optional, and both empty string and "0" are typically
	// treated as meaning that any port should match.
	Port                 string   `protobuf:"bytes,2,opt,name=Port,proto3" json:"Port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSSHTargetsRequest) Reset()         { *m = GetSSHTargetsRequest{} }
func (m *GetSSHTargetsRequest) String() string { return proto.CompactTextString(m) }
func (*GetSSHTargetsRequest) ProtoMessage()    {}
func (*GetSSHTargetsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{158}
}
func (m *GetSSHTargetsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSSHTargetsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSSHTargetsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSSHTargetsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSSHTargetsRequest.Merge(m, src)
}
func (m *GetSSHTargetsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSSHTargetsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSSHTargetsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSSHTargetsRequest proto.InternalMessageInfo

func (m *GetSSHTargetsRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *GetSSHTargetsRequest) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

// GetSSHTargetsResponse holds ssh servers that match an ssh targets request.
type GetSSHTargetsResponse struct {
	// Servers is a list of servers matching the supplied request.
	Servers              []*types.ServerV2 `protobuf:"bytes,1,rep,name=Servers,proto3" json:"Servers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetSSHTargetsResponse) Reset()         { *m = GetSSHTargetsResponse{} }
func (m *GetSSHTargetsResponse) String() string { return proto.CompactTextString(m) }
func (*GetSSHTargetsResponse) ProtoMessage()    {}
func (*GetSSHTargetsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{159}
}
func (m *GetSSHTargetsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSSHTargetsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSSHTargetsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSSHTargetsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSSHTargetsResponse.Merge(m, src)
}
func (m *GetSSHTargetsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSSHTargetsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSSHTargetsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSSHTargetsResponse proto.InternalMessageInfo

func (m *GetSSHTargetsResponse) GetServers() []*types.ServerV2 {
	if m != nil {
		return m.Servers
	}
	return nil
}

// ListResourceResponse response of ListResources.
type ListResourcesResponse struct {
	// Resources is a list of resource.
	Resources []*PaginatedResource `protobuf:"bytes,1,rep,name=Resources,proto3" json:"resources,omitempty"`
	// NextKey is the next Key to use as StartKey in a ListResourcesRequest to
	// continue retrieving pages of resource. If NextKey is empty, there are no
	// more pages.
	NextKey string `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"next_key,omitempty"`
	// TotalCount is the total number of resources available after filter, if any.
	TotalCount           int32    `protobuf:"varint,3,opt,name=TotalCount,proto3" json:"total_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListResourcesResponse) Reset()         { *m = ListResourcesResponse{} }
func (m *ListResourcesResponse) String() string { return proto.CompactTextString(m) }
func (*ListResourcesResponse) ProtoMessage()    {}
func (*ListResourcesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{160}
}
func (m *ListResourcesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListResourcesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListResourcesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListResourcesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListResourcesResponse.Merge(m, src)
}
func (m *ListResourcesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListResourcesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListResourcesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListResourcesResponse proto.InternalMessageInfo

func (m *ListResourcesResponse) GetResources() []*PaginatedResource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *ListResourcesResponse) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

func (m *ListResourcesResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

// CreateSessionTrackerRequest is a request to create a new session.
//
// This is not specific to any session type. Relevant fields should be set for a given session type.
type CreateSessionTrackerRequest struct {
	// SessionTracker is the session tracker to be created.
	SessionTracker       *types.SessionTrackerV1 `protobuf:"bytes,15,opt,name=SessionTracker,proto3" json:"session_tracker,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *CreateSessionTrackerRequest) Reset()         { *m = CreateSessionTrackerRequest{} }
func (m *CreateSessionTrackerRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSessionTrackerRequest) ProtoMessage()    {}
func (*CreateSessionTrackerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{161}
}
func (m *CreateSessionTrackerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSessionTrackerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSessionTrackerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSessionTrackerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSessionTrackerRequest.Merge(m, src)
}
func (m *CreateSessionTrackerRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSessionTrackerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSessionTrackerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSessionTrackerRequest proto.InternalMessageInfo

func (m *CreateSessionTrackerRequest) GetSessionTracker() *types.SessionTrackerV1 {
	if m != nil {
		return m.SessionTracker
	}
	return nil
}

// GetSessionTrackerRequest is a request to fetch a session resource.
type GetSessionTrackerRequest struct {
	// SessionID is unique identifier of this session.
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSessionTrackerRequest) Reset()         { *m = GetSessionTrackerRequest{} }
func (m *GetSessionTrackerRequest) String() string { return proto.CompactTextString(m) }
func (*GetSessionTrackerRequest) ProtoMessage()    {}
func (*GetSessionTrackerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{162}
}
func (m *GetSessionTrackerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSessionTrackerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSessionTrackerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSessionTrackerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSessionTrackerRequest.Merge(m, src)
}
func (m *GetSessionTrackerRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSessionTrackerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSessionTrackerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSessionTrackerRequest proto.InternalMessageInfo

func (m *GetSessionTrackerRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// RemoveSessionTrackerRequest is a request to remove a session.
type RemoveSessionTrackerRequest struct {
	// SessionID is unique identifier of this session.
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveSessionTrackerRequest) Reset()         { *m = RemoveSessionTrackerRequest{} }
func (m *RemoveSessionTrackerRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveSessionTrackerRequest) ProtoMessage()    {}
func (*RemoveSessionTrackerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{163}
}
func (m *RemoveSessionTrackerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveSessionTrackerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveSessionTrackerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveSessionTrackerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveSessionTrackerRequest.Merge(m, src)
}
func (m *RemoveSessionTrackerRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveSessionTrackerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveSessionTrackerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveSessionTrackerRequest proto.InternalMessageInfo

func (m *RemoveSessionTrackerRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

type SessionTrackerUpdateState struct {
	// State is the new state of the session tracker.
	State                types.SessionState `protobuf:"varint,2,opt,name=State,proto3,enum=types.SessionState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SessionTrackerUpdateState) Reset()         { *m = SessionTrackerUpdateState{} }
func (m *SessionTrackerUpdateState) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerUpdateState) ProtoMessage()    {}
func (*SessionTrackerUpdateState) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{164}
}
func (m *SessionTrackerUpdateState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerUpdateState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerUpdateState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerUpdateState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerUpdateState.Merge(m, src)
}
func (m *SessionTrackerUpdateState) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerUpdateState) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerUpdateState.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerUpdateState proto.InternalMessageInfo

func (m *SessionTrackerUpdateState) GetState() types.SessionState {
	if m != nil {
		return m.State
	}
	return types.SessionState_SessionStatePending
}

type SessionTrackerAddParticipant struct {
	// Participant is the participant to be added to the session.
	Participant          *types.Participant `protobuf:"bytes,2,opt,name=Participant,proto3" json:"participant,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SessionTrackerAddParticipant) Reset()         { *m = SessionTrackerAddParticipant{} }
func (m *SessionTrackerAddParticipant) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerAddParticipant) ProtoMessage()    {}
func (*SessionTrackerAddParticipant) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{165}
}
func (m *SessionTrackerAddParticipant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerAddParticipant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerAddParticipant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerAddParticipant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerAddParticipant.Merge(m, src)
}
func (m *SessionTrackerAddParticipant) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerAddParticipant) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerAddParticipant.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerAddParticipant proto.InternalMessageInfo

func (m *SessionTrackerAddParticipant) GetParticipant() *types.Participant {
	if m != nil {
		return m.Participant
	}
	return nil
}

type SessionTrackerRemoveParticipant struct {
	// ParticipantID is unique identifier of the participant.
	ParticipantID        string   `protobuf:"bytes,2,opt,name=ParticipantID,proto3" json:"participant_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionTrackerRemoveParticipant) Reset()         { *m = SessionTrackerRemoveParticipant{} }
func (m *SessionTrackerRemoveParticipant) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerRemoveParticipant) ProtoMessage()    {}
func (*SessionTrackerRemoveParticipant) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{166}
}
func (m *SessionTrackerRemoveParticipant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerRemoveParticipant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerRemoveParticipant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerRemoveParticipant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerRemoveParticipant.Merge(m, src)
}
func (m *SessionTrackerRemoveParticipant) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerRemoveParticipant) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerRemoveParticipant.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerRemoveParticipant proto.InternalMessageInfo

func (m *SessionTrackerRemoveParticipant) GetParticipantID() string {
	if m != nil {
		return m.ParticipantID
	}
	return ""
}

// SessionTrackerUpdateExpiry is used to update the session tracker expiration time.
type SessionTrackerUpdateExpiry struct {
	// Expires is when the session tracker will expire.
	Expires              *time.Time `protobuf:"bytes,1,opt,name=Expires,proto3,stdtime" json:"expires"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SessionTrackerUpdateExpiry) Reset()         { *m = SessionTrackerUpdateExpiry{} }
func (m *SessionTrackerUpdateExpiry) String() string { return proto.CompactTextString(m) }
func (*SessionTrackerUpdateExpiry) ProtoMessage()    {}
func (*SessionTrackerUpdateExpiry) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{167}
}
func (m *SessionTrackerUpdateExpiry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionTrackerUpdateExpiry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionTrackerUpdateExpiry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionTrackerUpdateExpiry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionTrackerUpdateExpiry.Merge(m, src)
}
func (m *SessionTrackerUpdateExpiry) XXX_Size() int {
	return m.Size()
}
func (m *SessionTrackerUpdateExpiry) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionTrackerUpdateExpiry.DiscardUnknown(m)
}

var xxx_messageInfo_SessionTrackerUpdateExpiry proto.InternalMessageInfo

func (m *SessionTrackerUpdateExpiry) GetExpires() *time.Time {
	if m != nil {
		return m.Expires
	}
	return nil
}

// UpdateSessionTrackerRequest is a request to update some state of a session.
type UpdateSessionTrackerRequest struct {
	// SessionID is unique identifier of this session.
	SessionID string `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id,omitempty"`
	// Types that are valid to be assigned to Update:
	//	*UpdateSessionTrackerRequest_UpdateState
	//	*UpdateSessionTrackerRequest_AddParticipant
	//	*UpdateSessionTrackerRequest_RemoveParticipant
	//	*UpdateSessionTrackerRequest_UpdateExpiry
	Update               isUpdateSessionTrackerRequest_Update `protobuf_oneof:"Update"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *UpdateSessionTrackerRequest) Reset()         { *m = UpdateSessionTrackerRequest{} }
func (m *UpdateSessionTrackerRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSessionTrackerRequest) ProtoMessage()    {}
func (*UpdateSessionTrackerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{168}
}
func (m *UpdateSessionTrackerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSessionTrackerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSessionTrackerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSessionTrackerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSessionTrackerRequest.Merge(m, src)
}
func (m *UpdateSessionTrackerRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSessionTrackerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSessionTrackerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSessionTrackerRequest proto.InternalMessageInfo

type isUpdateSessionTrackerRequest_Update interface {
	isUpdateSessionTrackerRequest_Update()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UpdateSessionTrackerRequest_UpdateState struct {
	UpdateState *SessionTrackerUpdateState `protobuf:"bytes,2,opt,name=UpdateState,proto3,oneof" json:"update_state,omitempty"`
}
type UpdateSessionTrackerRequest_AddParticipant struct {
	AddParticipant *SessionTrackerAddParticipant `protobuf:"bytes,3,opt,name=AddParticipant,proto3,oneof" json:"add_participant,omitempty"`
}
type UpdateSessionTrackerRequest_RemoveParticipant struct {
	RemoveParticipant *SessionTrackerRemoveParticipant `protobuf:"bytes,4,opt,name=RemoveParticipant,proto3,oneof" json:"remove_participant,omitempty"`
}
type UpdateSessionTrackerRequest_UpdateExpiry struct {
	UpdateExpiry *SessionTrackerUpdateExpiry `protobuf:"bytes,5,opt,name=UpdateExpiry,proto3,oneof" json:"update_expiry,omitempty"`
}

func (*UpdateSessionTrackerRequest_UpdateState) isUpdateSessionTrackerRequest_Update()       {}
func (*UpdateSessionTrackerRequest_AddParticipant) isUpdateSessionTrackerRequest_Update()    {}
func (*UpdateSessionTrackerRequest_RemoveParticipant) isUpdateSessionTrackerRequest_Update() {}
func (*UpdateSessionTrackerRequest_UpdateExpiry) isUpdateSessionTrackerRequest_Update()      {}

func (m *UpdateSessionTrackerRequest) GetUpdate() isUpdateSessionTrackerRequest_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *UpdateSessionTrackerRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

func (m *UpdateSessionTrackerRequest) GetUpdateState() *SessionTrackerUpdateState {
	if x, ok := m.GetUpdate().(*UpdateSessionTrackerRequest_UpdateState); ok {
		return x.UpdateState
	}
	return nil
}

func (m *UpdateSessionTrackerRequest) GetAddParticipant() *SessionTrackerAddParticipant {
	if x, ok := m.GetUpdate().(*UpdateSessionTrackerRequest_AddParticipant); ok {
		return x.AddParticipant
	}
	return nil
}

func (m *UpdateSessionTrackerRequest) GetRemoveParticipant() *SessionTrackerRemoveParticipant {
	if x, ok := m.GetUpdate().(*UpdateSessionTrackerRequest_RemoveParticipant); ok {
		return x.RemoveParticipant
	}
	return nil
}

func (m *UpdateSessionTrackerRequest) GetUpdateExpiry() *SessionTrackerUpdateExpiry {
	if x, ok := m.GetUpdate().(*UpdateSessionTrackerRequest_UpdateExpiry); ok {
		return x.UpdateExpiry
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UpdateSessionTrackerRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UpdateSessionTrackerRequest_UpdateState)(nil),
		(*UpdateSessionTrackerRequest_AddParticipant)(nil),
		(*UpdateSessionTrackerRequest_RemoveParticipant)(nil),
		(*UpdateSessionTrackerRequest_UpdateExpiry)(nil),
	}
}

// PresenceMFAChallengeRequest is a request for a presence MFA challenge.
type PresenceMFAChallengeRequest struct {
	// SessionID is unique identifier of the session you want to request presence for.
	SessionID            string   `protobuf:"bytes,1,opt,name=SessionID,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PresenceMFAChallengeRequest) Reset()         { *m = PresenceMFAChallengeRequest{} }
func (m *PresenceMFAChallengeRequest) String() string { return proto.CompactTextString(m) }
func (*PresenceMFAChallengeRequest) ProtoMessage()    {}
func (*PresenceMFAChallengeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{169}
}
func (m *PresenceMFAChallengeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PresenceMFAChallengeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PresenceMFAChallengeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PresenceMFAChallengeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PresenceMFAChallengeRequest.Merge(m, src)
}
func (m *PresenceMFAChallengeRequest) XXX_Size() int {
	return m.Size()
}
func (m *PresenceMFAChallengeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PresenceMFAChallengeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PresenceMFAChallengeRequest proto.InternalMessageInfo

func (m *PresenceMFAChallengeRequest) GetSessionID() string {
	if m != nil {
		return m.SessionID
	}
	return ""
}

// PresenceMFAChallengeSend is a presence challenge request or response.
type PresenceMFAChallengeSend struct {
	// Types that are valid to be assigned to Request:
	//	*PresenceMFAChallengeSend_ChallengeRequest
	//	*PresenceMFAChallengeSend_ChallengeResponse
	Request              isPresenceMFAChallengeSend_Request `protobuf_oneof:"Request"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *PresenceMFAChallengeSend) Reset()         { *m = PresenceMFAChallengeSend{} }
func (m *PresenceMFAChallengeSend) String() string { return proto.CompactTextString(m) }
func (*PresenceMFAChallengeSend) ProtoMessage()    {}
func (*PresenceMFAChallengeSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{170}
}
func (m *PresenceMFAChallengeSend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PresenceMFAChallengeSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PresenceMFAChallengeSend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PresenceMFAChallengeSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PresenceMFAChallengeSend.Merge(m, src)
}
func (m *PresenceMFAChallengeSend) XXX_Size() int {
	return m.Size()
}
func (m *PresenceMFAChallengeSend) XXX_DiscardUnknown() {
	xxx_messageInfo_PresenceMFAChallengeSend.DiscardUnknown(m)
}

var xxx_messageInfo_PresenceMFAChallengeSend proto.InternalMessageInfo

type isPresenceMFAChallengeSend_Request interface {
	isPresenceMFAChallengeSend_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PresenceMFAChallengeSend_ChallengeRequest struct {
	ChallengeRequest *PresenceMFAChallengeRequest `protobuf:"bytes,1,opt,name=ChallengeRequest,proto3,oneof" json:"ChallengeRequest,omitempty"`
}
type PresenceMFAChallengeSend_ChallengeResponse struct {
	ChallengeResponse *MFAAuthenticateResponse `protobuf:"bytes,2,opt,name=ChallengeResponse,proto3,oneof" json:"ChallengeResponse,omitempty"`
}

func (*PresenceMFAChallengeSend_ChallengeRequest) isPresenceMFAChallengeSend_Request()  {}
func (*PresenceMFAChallengeSend_ChallengeResponse) isPresenceMFAChallengeSend_Request() {}

func (m *PresenceMFAChallengeSend) GetRequest() isPresenceMFAChallengeSend_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *PresenceMFAChallengeSend) GetChallengeRequest() *PresenceMFAChallengeRequest {
	if x, ok := m.GetRequest().(*PresenceMFAChallengeSend_ChallengeRequest); ok {
		return x.ChallengeRequest
	}
	return nil
}

func (m *PresenceMFAChallengeSend) GetChallengeResponse() *MFAAuthenticateResponse {
	if x, ok := m.GetRequest().(*PresenceMFAChallengeSend_ChallengeResponse); ok {
		return x.ChallengeResponse
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PresenceMFAChallengeSend) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PresenceMFAChallengeSend_ChallengeRequest)(nil),
		(*PresenceMFAChallengeSend_ChallengeResponse)(nil),
	}
}

// GetDomainNameResponse is a response from GetDomainName.
type GetDomainNameResponse struct {
	// DomainName is the local auth domain of the current auth server.
	DomainName           string   `protobuf:"bytes,1,opt,name=DomainName,proto3" json:"domain_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDomainNameResponse) Reset()         { *m = GetDomainNameResponse{} }
func (m *GetDomainNameResponse) String() string { return proto.CompactTextString(m) }
func (*GetDomainNameResponse) ProtoMessage()    {}
func (*GetDomainNameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{171}
}
func (m *GetDomainNameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDomainNameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDomainNameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDomainNameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDomainNameResponse.Merge(m, src)
}
func (m *GetDomainNameResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetDomainNameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDomainNameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetDomainNameResponse proto.InternalMessageInfo

func (m *GetDomainNameResponse) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

// GetClusterCACertResponse is a response from GetClusterCACert.
type GetClusterCACertResponse struct {
	// TLSCA is a PEM-encoded TLS certificate authority.
	TLSCA                []byte   `protobuf:"bytes,1,opt,name=TLSCA,proto3" json:"tls_ca"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetClusterCACertResponse) Reset()         { *m = GetClusterCACertResponse{} }
func (m *GetClusterCACertResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterCACertResponse) ProtoMessage()    {}
func (*GetClusterCACertResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{172}
}
func (m *GetClusterCACertResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterCACertResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterCACertResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterCACertResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterCACertResponse.Merge(m, src)
}
func (m *GetClusterCACertResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterCACertResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterCACertResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterCACertResponse proto.InternalMessageInfo

func (m *GetClusterCACertResponse) GetTLSCA() []byte {
	if m != nil {
		return m.TLSCA
	}
	return nil
}

// GetLicenseResponse is a response from GetLicense
type GetLicenseResponse struct {
	License              []byte   `protobuf:"bytes,1,opt,name=License,proto3" json:"license"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLicenseResponse) Reset()         { *m = GetLicenseResponse{} }
func (m *GetLicenseResponse) String() string { return proto.CompactTextString(m) }
func (*GetLicenseResponse) ProtoMessage()    {}
func (*GetLicenseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{173}
}
func (m *GetLicenseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLicenseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLicenseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLicenseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLicenseResponse.Merge(m, src)
}
func (m *GetLicenseResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLicenseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLicenseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLicenseResponse proto.InternalMessageInfo

func (m *GetLicenseResponse) GetLicense() []byte {
	if m != nil {
		return m.License
	}
	return nil
}

// ListReleasesResponse is a response from ListReleases
type ListReleasesResponse struct {
	Releases             []*types.Release `protobuf:"bytes,1,rep,name=releases,proto3" json:"releases"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListReleasesResponse) Reset()         { *m = ListReleasesResponse{} }
func (m *ListReleasesResponse) String() string { return proto.CompactTextString(m) }
func (*ListReleasesResponse) ProtoMessage()    {}
func (*ListReleasesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{174}
}
func (m *ListReleasesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReleasesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReleasesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReleasesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReleasesResponse.Merge(m, src)
}
func (m *ListReleasesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListReleasesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReleasesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListReleasesResponse proto.InternalMessageInfo

func (m *ListReleasesResponse) GetReleases() []*types.Release {
	if m != nil {
		return m.Releases
	}
	return nil
}

// GetOIDCAuthRequestRequest is a request for GetOIDCAuthRequest.
type GetOIDCAuthRequestRequest struct {
	// StateToken is an oidc auth request state token.
	StateToken           string   `protobuf:"bytes,1,opt,name=StateToken,proto3" json:"state_token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetOIDCAuthRequestRequest) Reset()         { *m = GetOIDCAuthRequestRequest{} }
func (m *GetOIDCAuthRequestRequest) String() string { return proto.CompactTextString(m) }
func (*GetOIDCAuthRequestRequest) ProtoMessage()    {}
func (*GetOIDCAuthRequestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{175}
}
func (m *GetOIDCAuthRequestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetOIDCAuthRequestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetOIDCAuthRequestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetOIDCAuthRequestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOIDCAuthRequestRequest.Merge(m, src)
}
func (m *GetOIDCAuthRequestRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetOIDCAuthRequestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOIDCAuthRequestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetOIDCAuthRequestRequest proto.InternalMessageInfo

func (m *GetOIDCAuthRequestRequest) GetStateToken() string {
	if m != nil {
		return m.StateToken
	}
	return ""
}

// GetSAMLAuthRequestRequest is a request for GetSAMLAuthRequest.
type GetSAMLAuthRequestRequest struct {
	// ID is a saml auth request unique id.
	ID                   string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSAMLAuthRequestRequest) Reset()         { *m = GetSAMLAuthRequestRequest{} }
func (m *GetSAMLAuthRequestRequest) String() string { return proto.CompactTextString(m) }
func (*GetSAMLAuthRequestRequest) ProtoMessage()    {}
func (*GetSAMLAuthRequestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{176}
}
func (m *GetSAMLAuthRequestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSAMLAuthRequestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSAMLAuthRequestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSAMLAuthRequestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSAMLAuthRequestRequest.Merge(m, src)
}
func (m *GetSAMLAuthRequestRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSAMLAuthRequestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSAMLAuthRequestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSAMLAuthRequestRequest proto.InternalMessageInfo

func (m *GetSAMLAuthRequestRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// GetGithubAuthRequestRequest is a request for GetGithubAuthRequest.
type GetGithubAuthRequestRequest struct {
	// StateToken is a github auth request state token.
	StateToken           string   `protobuf:"bytes,1,opt,name=StateToken,proto3" json:"state_token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetGithubAuthRequestRequest) Reset()         { *m = GetGithubAuthRequestRequest{} }
func (m *GetGithubAuthRequestRequest) String() string { return proto.CompactTextString(m) }
func (*GetGithubAuthRequestRequest) ProtoMessage()    {}
func (*GetGithubAuthRequestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{177}
}
func (m *GetGithubAuthRequestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetGithubAuthRequestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetGithubAuthRequestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetGithubAuthRequestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetGithubAuthRequestRequest.Merge(m, src)
}
func (m *GetGithubAuthRequestRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetGithubAuthRequestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetGithubAuthRequestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetGithubAuthRequestRequest proto.InternalMessageInfo

func (m *GetGithubAuthRequestRequest) GetStateToken() string {
	if m != nil {
		return m.StateToken
	}
	return ""
}

// CreateOIDCConnectorRequest is a request for CreateOIDCConnector.
type CreateOIDCConnectorRequest struct {
	// Connector to be created.
	Connector            *types.OIDCConnectorV3 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CreateOIDCConnectorRequest) Reset()         { *m = CreateOIDCConnectorRequest{} }
func (m *CreateOIDCConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*CreateOIDCConnectorRequest) ProtoMessage()    {}
func (*CreateOIDCConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{178}
}
func (m *CreateOIDCConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateOIDCConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateOIDCConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateOIDCConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateOIDCConnectorRequest.Merge(m, src)
}
func (m *CreateOIDCConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateOIDCConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateOIDCConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateOIDCConnectorRequest proto.InternalMessageInfo

func (m *CreateOIDCConnectorRequest) GetConnector() *types.OIDCConnectorV3 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// UpdateOIDCConnectorRequest is a request for UpdateOIDCConnector.
type UpdateOIDCConnectorRequest struct {
	// Connector to be updated.
	Connector            *types.OIDCConnectorV3 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateOIDCConnectorRequest) Reset()         { *m = UpdateOIDCConnectorRequest{} }
func (m *UpdateOIDCConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateOIDCConnectorRequest) ProtoMessage()    {}
func (*UpdateOIDCConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{179}
}
func (m *UpdateOIDCConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateOIDCConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateOIDCConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateOIDCConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOIDCConnectorRequest.Merge(m, src)
}
func (m *UpdateOIDCConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateOIDCConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOIDCConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOIDCConnectorRequest proto.InternalMessageInfo

func (m *UpdateOIDCConnectorRequest) GetConnector() *types.OIDCConnectorV3 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// UpsertOIDCConnectorRequest is a request for UpsertOIDCConnector.
type UpsertOIDCConnectorRequest struct {
	// Connector to be created or updated.
	Connector            *types.OIDCConnectorV3 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpsertOIDCConnectorRequest) Reset()         { *m = UpsertOIDCConnectorRequest{} }
func (m *UpsertOIDCConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertOIDCConnectorRequest) ProtoMessage()    {}
func (*UpsertOIDCConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{180}
}
func (m *UpsertOIDCConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertOIDCConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertOIDCConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertOIDCConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertOIDCConnectorRequest.Merge(m, src)
}
func (m *UpsertOIDCConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertOIDCConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertOIDCConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertOIDCConnectorRequest proto.InternalMessageInfo

func (m *UpsertOIDCConnectorRequest) GetConnector() *types.OIDCConnectorV3 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// CreateSAMLConnectorRequest is a request for CreateSAMLConnector.
type CreateSAMLConnectorRequest struct {
	// Connector to be created.
	Connector            *types.SAMLConnectorV2 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CreateSAMLConnectorRequest) Reset()         { *m = CreateSAMLConnectorRequest{} }
func (m *CreateSAMLConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSAMLConnectorRequest) ProtoMessage()    {}
func (*CreateSAMLConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{181}
}
func (m *CreateSAMLConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSAMLConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSAMLConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSAMLConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSAMLConnectorRequest.Merge(m, src)
}
func (m *CreateSAMLConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSAMLConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSAMLConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSAMLConnectorRequest proto.InternalMessageInfo

func (m *CreateSAMLConnectorRequest) GetConnector() *types.SAMLConnectorV2 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// UpdateSAMLConnectorRequest is a request for UpdateSAMLConnector.
type UpdateSAMLConnectorRequest struct {
	// Connector to be updated.
	Connector            *types.SAMLConnectorV2 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateSAMLConnectorRequest) Reset()         { *m = UpdateSAMLConnectorRequest{} }
func (m *UpdateSAMLConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSAMLConnectorRequest) ProtoMessage()    {}
func (*UpdateSAMLConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{182}
}
func (m *UpdateSAMLConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSAMLConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSAMLConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSAMLConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSAMLConnectorRequest.Merge(m, src)
}
func (m *UpdateSAMLConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSAMLConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSAMLConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSAMLConnectorRequest proto.InternalMessageInfo

func (m *UpdateSAMLConnectorRequest) GetConnector() *types.SAMLConnectorV2 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// UpsertSAMLConnectorRequest is a request for UpsertSAMLConnector.
type UpsertSAMLConnectorRequest struct {
	// Connector to be created or updated.
	Connector            *types.SAMLConnectorV2 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpsertSAMLConnectorRequest) Reset()         { *m = UpsertSAMLConnectorRequest{} }
func (m *UpsertSAMLConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertSAMLConnectorRequest) ProtoMessage()    {}
func (*UpsertSAMLConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{183}
}
func (m *UpsertSAMLConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertSAMLConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertSAMLConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertSAMLConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertSAMLConnectorRequest.Merge(m, src)
}
func (m *UpsertSAMLConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertSAMLConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertSAMLConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertSAMLConnectorRequest proto.InternalMessageInfo

func (m *UpsertSAMLConnectorRequest) GetConnector() *types.SAMLConnectorV2 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// CreateGithubConnectorRequest is a request for CreateGithubConnector.
type CreateGithubConnectorRequest struct {
	// Connector to be created.
	Connector            *types.GithubConnectorV3 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CreateGithubConnectorRequest) Reset()         { *m = CreateGithubConnectorRequest{} }
func (m *CreateGithubConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*CreateGithubConnectorRequest) ProtoMessage()    {}
func (*CreateGithubConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{184}
}
func (m *CreateGithubConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateGithubConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateGithubConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateGithubConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateGithubConnectorRequest.Merge(m, src)
}
func (m *CreateGithubConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateGithubConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateGithubConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateGithubConnectorRequest proto.InternalMessageInfo

func (m *CreateGithubConnectorRequest) GetConnector() *types.GithubConnectorV3 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// UpdateGithubConnectorRequest is a request for UpdateGithubConnector.
type UpdateGithubConnectorRequest struct {
	// Connector to be updated.
	Connector            *types.GithubConnectorV3 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *UpdateGithubConnectorRequest) Reset()         { *m = UpdateGithubConnectorRequest{} }
func (m *UpdateGithubConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateGithubConnectorRequest) ProtoMessage()    {}
func (*UpdateGithubConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{185}
}
func (m *UpdateGithubConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGithubConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGithubConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGithubConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGithubConnectorRequest.Merge(m, src)
}
func (m *UpdateGithubConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGithubConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGithubConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGithubConnectorRequest proto.InternalMessageInfo

func (m *UpdateGithubConnectorRequest) GetConnector() *types.GithubConnectorV3 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// UpsertGithubConnectorRequest is a request for UpsertGithubConnector.
type UpsertGithubConnectorRequest struct {
	// Connector to be created or updated.
	Connector            *types.GithubConnectorV3 `protobuf:"bytes,1,opt,name=Connector,proto3" json:"connector"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *UpsertGithubConnectorRequest) Reset()         { *m = UpsertGithubConnectorRequest{} }
func (m *UpsertGithubConnectorRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertGithubConnectorRequest) ProtoMessage()    {}
func (*UpsertGithubConnectorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{186}
}
func (m *UpsertGithubConnectorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertGithubConnectorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertGithubConnectorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertGithubConnectorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertGithubConnectorRequest.Merge(m, src)
}
func (m *UpsertGithubConnectorRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertGithubConnectorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertGithubConnectorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertGithubConnectorRequest proto.InternalMessageInfo

func (m *UpsertGithubConnectorRequest) GetConnector() *types.GithubConnectorV3 {
	if m != nil {
		return m.Connector
	}
	return nil
}

// GetSSODiagnosticInfoRequest is a request for GetSSODiagnosticInfo.
type GetSSODiagnosticInfoRequest struct {
	// AuthRequestKind is the SSO Auth Request kind (oidc, saml, or github).
	AuthRequestKind string `protobuf:"bytes,1,opt,name=AuthRequestKind,proto3" json:"auth_request_kind"`
	// AuthRequestID is the SSO Auth Request id or state token.
	AuthRequestID        string   `protobuf:"bytes,2,opt,name=AuthRequestID,proto3" json:"auth_request_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSSODiagnosticInfoRequest) Reset()         { *m = GetSSODiagnosticInfoRequest{} }
func (m *GetSSODiagnosticInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetSSODiagnosticInfoRequest) ProtoMessage()    {}
func (*GetSSODiagnosticInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{187}
}
func (m *GetSSODiagnosticInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSSODiagnosticInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSSODiagnosticInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSSODiagnosticInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSSODiagnosticInfoRequest.Merge(m, src)
}
func (m *GetSSODiagnosticInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSSODiagnosticInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSSODiagnosticInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSSODiagnosticInfoRequest proto.InternalMessageInfo

func (m *GetSSODiagnosticInfoRequest) GetAuthRequestKind() string {
	if m != nil {
		return m.AuthRequestKind
	}
	return ""
}

func (m *GetSSODiagnosticInfoRequest) GetAuthRequestID() string {
	if m != nil {
		return m.AuthRequestID
	}
	return ""
}

// SystemRoleAssertion is used by agents to prove that they have a given system role when their
// credentials originate from multiple separate join tokens so that they can be issued an
// instance certificate that encompasses all of their capabilities. This type will be
// deprecated once we have a more comprehensive model for join token joining/replacement.
type SystemRoleAssertion struct {
	// ServerID is the server ID of the instance that the assertion is for. Assertions are
	// only accepted if the calling agent's certificate matches this server id.
	ServerID string `protobuf:"bytes,1,opt,name=ServerID,proto3" json:"server_id,omitempty"`
	// AssertionID is a random UUID that uniquely identifies a set of assertions
	// as originating from the same teleport process.
	AssertionID string `protobuf:"bytes,2,opt,name=AssertionID,proto3" json:"assertion_id,omitempty"`
	// SystemRole is the system role being asserted. Assertions are only accepted if
	// the calling agent's certificate authorizes it for this system role.
	SystemRole           github_com_gravitational_teleport_api_types.SystemRole `protobuf:"bytes,3,opt,name=SystemRole,proto3,casttype=github.com/gravitational/teleport/api/types.SystemRole" json:"system_role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *SystemRoleAssertion) Reset()         { *m = SystemRoleAssertion{} }
func (m *SystemRoleAssertion) String() string { return proto.CompactTextString(m) }
func (*SystemRoleAssertion) ProtoMessage()    {}
func (*SystemRoleAssertion) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{188}
}
func (m *SystemRoleAssertion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemRoleAssertion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemRoleAssertion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SystemRoleAssertion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemRoleAssertion.Merge(m, src)
}
func (m *SystemRoleAssertion) XXX_Size() int {
	return m.Size()
}
func (m *SystemRoleAssertion) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemRoleAssertion.DiscardUnknown(m)
}

var xxx_messageInfo_SystemRoleAssertion proto.InternalMessageInfo

func (m *SystemRoleAssertion) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

func (m *SystemRoleAssertion) GetAssertionID() string {
	if m != nil {
		return m.AssertionID
	}
	return ""
}

func (m *SystemRoleAssertion) GetSystemRole() github_com_gravitational_teleport_api_types.SystemRole {
	if m != nil {
		return m.SystemRole
	}
	return ""
}

// SystemRoleAssertionSet is an aggregate generated as a result of one or more successful
// assertions. This type will be deprecated once we have a more comprehensive model for
// join token joining/replacement.
type SystemRoleAssertionSet struct {
	// ServerID is the server ID of the agent that generated the assertions.
	ServerID string `protobuf:"bytes,1,opt,name=ServerID,proto3" json:"server_id,omitempty"`
	// AssertionID is a random UUID that identified all constituent assertions as originating
	// from the same teleport process.
	AssertionID string `protobuf:"bytes,2,opt,name=AssertionID,proto3" json:"assertion_id,omitempty"`
	// SystemRoles is the set of system roles that the agent has successfully asserted.
	SystemRoles          []github_com_gravitational_teleport_api_types.SystemRole `protobuf:"bytes,3,rep,name=SystemRoles,proto3,casttype=github.com/gravitational/teleport/api/types.SystemRole" json:"system_roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *SystemRoleAssertionSet) Reset()         { *m = SystemRoleAssertionSet{} }
func (m *SystemRoleAssertionSet) String() string { return proto.CompactTextString(m) }
func (*SystemRoleAssertionSet) ProtoMessage()    {}
func (*SystemRoleAssertionSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{189}
}
func (m *SystemRoleAssertionSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemRoleAssertionSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SystemRoleAssertionSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SystemRoleAssertionSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemRoleAssertionSet.Merge(m, src)
}
func (m *SystemRoleAssertionSet) XXX_Size() int {
	return m.Size()
}
func (m *SystemRoleAssertionSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemRoleAssertionSet.DiscardUnknown(m)
}

var xxx_messageInfo_SystemRoleAssertionSet proto.InternalMessageInfo

func (m *SystemRoleAssertionSet) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

func (m *SystemRoleAssertionSet) GetAssertionID() string {
	if m != nil {
		return m.AssertionID
	}
	return ""
}

func (m *SystemRoleAssertionSet) GetSystemRoles() []github_com_gravitational_teleport_api_types.SystemRole {
	if m != nil {
		return m.SystemRoles
	}
	return nil
}

// UpstreamInventoryOneOf is the upstream message for the inventory control stream,
// sent from teleport instances to the auth server.
type UpstreamInventoryOneOf struct {
	// Types that are valid to be assigned to Msg:
	//	*UpstreamInventoryOneOf_Hello
	//	*UpstreamInventoryOneOf_Heartbeat
	//	*UpstreamInventoryOneOf_Pong
	//	*UpstreamInventoryOneOf_AgentMetadata
	//	*UpstreamInventoryOneOf_Goodbye
	Msg                  isUpstreamInventoryOneOf_Msg `protobuf_oneof:"Msg"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *UpstreamInventoryOneOf) Reset()         { *m = UpstreamInventoryOneOf{} }
func (m *UpstreamInventoryOneOf) String() string { return proto.CompactTextString(m) }
func (*UpstreamInventoryOneOf) ProtoMessage()    {}
func (*UpstreamInventoryOneOf) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{190}
}
func (m *UpstreamInventoryOneOf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamInventoryOneOf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpstreamInventoryOneOf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpstreamInventoryOneOf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamInventoryOneOf.Merge(m, src)
}
func (m *UpstreamInventoryOneOf) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamInventoryOneOf) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamInventoryOneOf.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamInventoryOneOf proto.InternalMessageInfo

type isUpstreamInventoryOneOf_Msg interface {
	isUpstreamInventoryOneOf_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UpstreamInventoryOneOf_Hello struct {
	Hello *UpstreamInventoryHello `protobuf:"bytes,1,opt,name=Hello,proto3,oneof" json:"Hello,omitempty"`
}
type UpstreamInventoryOneOf_Heartbeat struct {
	Heartbeat *InventoryHeartbeat `protobuf:"bytes,2,opt,name=Heartbeat,proto3,oneof" json:"Heartbeat,omitempty"`
}
type UpstreamInventoryOneOf_Pong struct {
	Pong *UpstreamInventoryPong `protobuf:"bytes,3,opt,name=Pong,proto3,oneof" json:"Pong,omitempty"`
}
type UpstreamInventoryOneOf_AgentMetadata struct {
	AgentMetadata *UpstreamInventoryAgentMetadata `protobuf:"bytes,4,opt,name=AgentMetadata,proto3,oneof" json:"AgentMetadata,omitempty"`
}
type UpstreamInventoryOneOf_Goodbye struct {
	Goodbye *UpstreamInventoryGoodbye `protobuf:"bytes,5,opt,name=Goodbye,proto3,oneof" json:"Goodbye,omitempty"`
}

func (*UpstreamInventoryOneOf_Hello) isUpstreamInventoryOneOf_Msg()         {}
func (*UpstreamInventoryOneOf_Heartbeat) isUpstreamInventoryOneOf_Msg()     {}
func (*UpstreamInventoryOneOf_Pong) isUpstreamInventoryOneOf_Msg()          {}
func (*UpstreamInventoryOneOf_AgentMetadata) isUpstreamInventoryOneOf_Msg() {}
func (*UpstreamInventoryOneOf_Goodbye) isUpstreamInventoryOneOf_Msg()       {}

func (m *UpstreamInventoryOneOf) GetMsg() isUpstreamInventoryOneOf_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *UpstreamInventoryOneOf) GetHello() *UpstreamInventoryHello {
	if x, ok := m.GetMsg().(*UpstreamInventoryOneOf_Hello); ok {
		return x.Hello
	}
	return nil
}

func (m *UpstreamInventoryOneOf) GetHeartbeat() *InventoryHeartbeat {
	if x, ok := m.GetMsg().(*UpstreamInventoryOneOf_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *UpstreamInventoryOneOf) GetPong() *UpstreamInventoryPong {
	if x, ok := m.GetMsg().(*UpstreamInventoryOneOf_Pong); ok {
		return x.Pong
	}
	return nil
}

func (m *UpstreamInventoryOneOf) GetAgentMetadata() *UpstreamInventoryAgentMetadata {
	if x, ok := m.GetMsg().(*UpstreamInventoryOneOf_AgentMetadata); ok {
		return x.AgentMetadata
	}
	return nil
}

func (m *UpstreamInventoryOneOf) GetGoodbye() *UpstreamInventoryGoodbye {
	if x, ok := m.GetMsg().(*UpstreamInventoryOneOf_Goodbye); ok {
		return x.Goodbye
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UpstreamInventoryOneOf) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UpstreamInventoryOneOf_Hello)(nil),
		(*UpstreamInventoryOneOf_Heartbeat)(nil),
		(*UpstreamInventoryOneOf_Pong)(nil),
		(*UpstreamInventoryOneOf_AgentMetadata)(nil),
		(*UpstreamInventoryOneOf_Goodbye)(nil),
	}
}

// DownstreamInventoryOneOf is the downstream message for the inventory control stream,
// sent from auth servers to teleport instances.
type DownstreamInventoryOneOf struct {
	// Types that are valid to be assigned to Msg:
	//	*DownstreamInventoryOneOf_Hello
	//	*DownstreamInventoryOneOf_Ping
	//	*DownstreamInventoryOneOf_UpdateLabels
	Msg                  isDownstreamInventoryOneOf_Msg `protobuf_oneof:"Msg"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *DownstreamInventoryOneOf) Reset()         { *m = DownstreamInventoryOneOf{} }
func (m *DownstreamInventoryOneOf) String() string { return proto.CompactTextString(m) }
func (*DownstreamInventoryOneOf) ProtoMessage()    {}
func (*DownstreamInventoryOneOf) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{191}
}
func (m *DownstreamInventoryOneOf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownstreamInventoryOneOf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownstreamInventoryOneOf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownstreamInventoryOneOf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownstreamInventoryOneOf.Merge(m, src)
}
func (m *DownstreamInventoryOneOf) XXX_Size() int {
	return m.Size()
}
func (m *DownstreamInventoryOneOf) XXX_DiscardUnknown() {
	xxx_messageInfo_DownstreamInventoryOneOf.DiscardUnknown(m)
}

var xxx_messageInfo_DownstreamInventoryOneOf proto.InternalMessageInfo

type isDownstreamInventoryOneOf_Msg interface {
	isDownstreamInventoryOneOf_Msg()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DownstreamInventoryOneOf_Hello struct {
	Hello *DownstreamInventoryHello `protobuf:"bytes,1,opt,name=Hello,proto3,oneof" json:"Hello,omitempty"`
}
type DownstreamInventoryOneOf_Ping struct {
	Ping *DownstreamInventoryPing `protobuf:"bytes,2,opt,name=Ping,proto3,oneof" json:"Ping,omitempty"`
}
type DownstreamInventoryOneOf_UpdateLabels struct {
	UpdateLabels *DownstreamInventoryUpdateLabels `protobuf:"bytes,3,opt,name=UpdateLabels,proto3,oneof" json:"UpdateLabels,omitempty"`
}

func (*DownstreamInventoryOneOf_Hello) isDownstreamInventoryOneOf_Msg()        {}
func (*DownstreamInventoryOneOf_Ping) isDownstreamInventoryOneOf_Msg()         {}
func (*DownstreamInventoryOneOf_UpdateLabels) isDownstreamInventoryOneOf_Msg() {}

func (m *DownstreamInventoryOneOf) GetMsg() isDownstreamInventoryOneOf_Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *DownstreamInventoryOneOf) GetHello() *DownstreamInventoryHello {
	if x, ok := m.GetMsg().(*DownstreamInventoryOneOf_Hello); ok {
		return x.Hello
	}
	return nil
}

func (m *DownstreamInventoryOneOf) GetPing() *DownstreamInventoryPing {
	if x, ok := m.GetMsg().(*DownstreamInventoryOneOf_Ping); ok {
		return x.Ping
	}
	return nil
}

func (m *DownstreamInventoryOneOf) GetUpdateLabels() *DownstreamInventoryUpdateLabels {
	if x, ok := m.GetMsg().(*DownstreamInventoryOneOf_UpdateLabels); ok {
		return x.UpdateLabels
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DownstreamInventoryOneOf) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DownstreamInventoryOneOf_Hello)(nil),
		(*DownstreamInventoryOneOf_Ping)(nil),
		(*DownstreamInventoryOneOf_UpdateLabels)(nil),
	}
}

// DownstreamInventoryPing is sent down the inventory control stream for testing/debug
// purposes.
type DownstreamInventoryPing struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownstreamInventoryPing) Reset()         { *m = DownstreamInventoryPing{} }
func (m *DownstreamInventoryPing) String() string { return proto.CompactTextString(m) }
func (*DownstreamInventoryPing) ProtoMessage()    {}
func (*DownstreamInventoryPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{192}
}
func (m *DownstreamInventoryPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownstreamInventoryPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownstreamInventoryPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownstreamInventoryPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownstreamInventoryPing.Merge(m, src)
}
func (m *DownstreamInventoryPing) XXX_Size() int {
	return m.Size()
}
func (m *DownstreamInventoryPing) XXX_DiscardUnknown() {
	xxx_messageInfo_DownstreamInventoryPing.DiscardUnknown(m)
}

var xxx_messageInfo_DownstreamInventoryPing proto.InternalMessageInfo

func (m *DownstreamInventoryPing) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// UpstreamInventoryPong is sent up the inventory control stream in response to a downstream
// ping (used for testing/debug purposes).
type UpstreamInventoryPong struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpstreamInventoryPong) Reset()         { *m = UpstreamInventoryPong{} }
func (m *UpstreamInventoryPong) String() string { return proto.CompactTextString(m) }
func (*UpstreamInventoryPong) ProtoMessage()    {}
func (*UpstreamInventoryPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{193}
}
func (m *UpstreamInventoryPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamInventoryPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpstreamInventoryPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpstreamInventoryPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamInventoryPong.Merge(m, src)
}
func (m *UpstreamInventoryPong) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamInventoryPong) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamInventoryPong.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamInventoryPong proto.InternalMessageInfo

func (m *UpstreamInventoryPong) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// UpstreamInventoryHello is the hello message sent up the inventory control stream.
type UpstreamInventoryHello struct {
	// Version advertises the teleport version of the instance.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// ServerID advertises the server ID of the instance.
	ServerID string `protobuf:"bytes,2,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	// Services advertises the currently live services of the instance. note: this is
	// distinct from the SystemRoles associated with a certificate in that a service may
	// hold a system role that is not currently in use if it was granted that role by
	// its auth token. i.e. Services is the subset of SystemRoles that are currently
	// active.
	Services []github_com_gravitational_teleport_api_types.SystemRole `protobuf:"bytes,3,rep,name=Services,proto3,casttype=github.com/gravitational/teleport/api/types.SystemRole" json:"Services,omitempty"`
	// Hostname is the hostname associated with the instance. This value is not required or guaranteed
	// to be unique and its validity is not enforceable (i.e. join tokens do not constrain what an
	// instance can claim its hostname to be). This value exists only to assist users in correlating
	// instance resources with hosts.
	Hostname string `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	// ExternalUpgrader identifies the external upgrader that the instance is configured to
	// export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
	ExternalUpgrader string `protobuf:"bytes,5,opt,name=ExternalUpgrader,proto3" json:"ExternalUpgrader,omitempty"`
	// ExternalUpgraderVersion identifies the external upgrader version. Empty if no upgrader is defined.
	ExternalUpgraderVersion string   `protobuf:"bytes,6,opt,name=ExternalUpgraderVersion,proto3" json:"ExternalUpgraderVersion,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *UpstreamInventoryHello) Reset()         { *m = UpstreamInventoryHello{} }
func (m *UpstreamInventoryHello) String() string { return proto.CompactTextString(m) }
func (*UpstreamInventoryHello) ProtoMessage()    {}
func (*UpstreamInventoryHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{194}
}
func (m *UpstreamInventoryHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamInventoryHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpstreamInventoryHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpstreamInventoryHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamInventoryHello.Merge(m, src)
}
func (m *UpstreamInventoryHello) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamInventoryHello) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamInventoryHello.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamInventoryHello proto.InternalMessageInfo

func (m *UpstreamInventoryHello) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *UpstreamInventoryHello) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

func (m *UpstreamInventoryHello) GetServices() []github_com_gravitational_teleport_api_types.SystemRole {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *UpstreamInventoryHello) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *UpstreamInventoryHello) GetExternalUpgrader() string {
	if m != nil {
		return m.ExternalUpgrader
	}
	return ""
}

func (m *UpstreamInventoryHello) GetExternalUpgraderVersion() string {
	if m != nil {
		return m.ExternalUpgraderVersion
	}
	return ""
}

// UpstreamInventoryAgentMetadata is the message sent up the inventory control stream containing
// metadata about the instance.
type UpstreamInventoryAgentMetadata struct {
	// OS advertises the instance OS ("darwin" or "linux").
	OS string `protobuf:"bytes,1,opt,name=OS,proto3" json:"OS,omitempty"`
	// OSVersion advertises the instance OS version (e.g. "ubuntu 22.04").
	OSVersion string `protobuf:"bytes,2,opt,name=OSVersion,proto3" json:"OSVersion,omitempty"`
	// HostArchitecture advertises the instance host architecture (e.g. "x86_64" or "arm64").
	HostArchitecture string `protobuf:"bytes,3,opt,name=HostArchitecture,proto3" json:"HostArchitecture,omitempty"`
	// GlibcVersion advertises the instance glibc version of linux instances (e.g. "2.35").
	GlibcVersion string `protobuf:"bytes,4,opt,name=GlibcVersion,proto3" json:"GlibcVersion,omitempty"`
	// InstallMethods advertises the install methods used for the instance (e.g. "dockerfile").
	InstallMethods []string `protobuf:"bytes,5,rep,name=InstallMethods,proto3" json:"InstallMethods,omitempty"`
	// ContainerRuntime advertises the container runtime for the instance, if any (e.g. "docker").
	ContainerRuntime string `protobuf:"bytes,6,opt,name=ContainerRuntime,proto3" json:"ContainerRuntime,omitempty"`
	// ContainerOrchestrator advertises the container orchestrator for the instance, if any
	// (e.g. "kubernetes-v1.24.8-eks-ffeb93d").
	ContainerOrchestrator string `protobuf:"bytes,7,opt,name=ContainerOrchestrator,proto3" json:"ContainerOrchestrator,omitempty"`
	// CloudEnvironment advertises the cloud environment for the instance, if any (e.g. "aws").
	CloudEnvironment     string   `protobuf:"bytes,8,opt,name=CloudEnvironment,proto3" json:"CloudEnvironment,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpstreamInventoryAgentMetadata) Reset()         { *m = UpstreamInventoryAgentMetadata{} }
func (m *UpstreamInventoryAgentMetadata) String() string { return proto.CompactTextString(m) }
func (*UpstreamInventoryAgentMetadata) ProtoMessage()    {}
func (*UpstreamInventoryAgentMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{195}
}
func (m *UpstreamInventoryAgentMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamInventoryAgentMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpstreamInventoryAgentMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpstreamInventoryAgentMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamInventoryAgentMetadata.Merge(m, src)
}
func (m *UpstreamInventoryAgentMetadata) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamInventoryAgentMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamInventoryAgentMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamInventoryAgentMetadata proto.InternalMessageInfo

func (m *UpstreamInventoryAgentMetadata) GetOS() string {
	if m != nil {
		return m.OS
	}
	return ""
}

func (m *UpstreamInventoryAgentMetadata) GetOSVersion() string {
	if m != nil {
		return m.OSVersion
	}
	return ""
}

func (m *UpstreamInventoryAgentMetadata) GetHostArchitecture() string {
	if m != nil {
		return m.HostArchitecture
	}
	return ""
}

func (m *UpstreamInventoryAgentMetadata) GetGlibcVersion() string {
	if m != nil {
		return m.GlibcVersion
	}
	return ""
}

func (m *UpstreamInventoryAgentMetadata) GetInstallMethods() []string {
	if m != nil {
		return m.InstallMethods
	}
	return nil
}

func (m *UpstreamInventoryAgentMetadata) GetContainerRuntime() string {
	if m != nil {
		return m.ContainerRuntime
	}
	return ""
}

func (m *UpstreamInventoryAgentMetadata) GetContainerOrchestrator() string {
	if m != nil {
		return m.ContainerOrchestrator
	}
	return ""
}

func (m *UpstreamInventoryAgentMetadata) GetCloudEnvironment() string {
	if m != nil {
		return m.CloudEnvironment
	}
	return ""
}

// DownstreamInventoryHello is the hello message sent down the inventory control stream.
type DownstreamInventoryHello struct {
	// Version advertises the version of the auth server.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// ServerID advertises the server ID of the auth server.
	ServerID string `protobuf:"bytes,2,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	// SupportedCapabilities advertises the supported features of the auth server.
	Capabilities         *DownstreamInventoryHello_SupportedCapabilities `protobuf:"bytes,3,opt,name=Capabilities,proto3" json:"Capabilities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *DownstreamInventoryHello) Reset()         { *m = DownstreamInventoryHello{} }
func (m *DownstreamInventoryHello) String() string { return proto.CompactTextString(m) }
func (*DownstreamInventoryHello) ProtoMessage()    {}
func (*DownstreamInventoryHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{196}
}
func (m *DownstreamInventoryHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownstreamInventoryHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownstreamInventoryHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownstreamInventoryHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownstreamInventoryHello.Merge(m, src)
}
func (m *DownstreamInventoryHello) XXX_Size() int {
	return m.Size()
}
func (m *DownstreamInventoryHello) XXX_DiscardUnknown() {
	xxx_messageInfo_DownstreamInventoryHello.DiscardUnknown(m)
}

var xxx_messageInfo_DownstreamInventoryHello proto.InternalMessageInfo

func (m *DownstreamInventoryHello) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DownstreamInventoryHello) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

func (m *DownstreamInventoryHello) GetCapabilities() *DownstreamInventoryHello_SupportedCapabilities {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// SupportedCapabilities indicate which features of the ICS that
// the connect auth server supports. This allows agents to determine
// how they should interact with the auth server to maintain compatibility.
type DownstreamInventoryHello_SupportedCapabilities struct {
	// ProxyHeartbeats indicates the ICS supports heartbeating proxy servers.
	ProxyHeartbeats bool `protobuf:"varint,1,opt,name=ProxyHeartbeats,proto3" json:"ProxyHeartbeats,omitempty"`
	// ProxyCleanup indicates the ICS supports deleting proxies when UpstreamInventoryGoodbye.DeleteResources is set.
	ProxyCleanup bool `protobuf:"varint,2,opt,name=ProxyCleanup,proto3" json:"ProxyCleanup,omitempty"`
	// ProxyHeartbeats indicates the ICS supports heartbeating proxy servers.
	AuthHeartbeats bool `protobuf:"varint,3,opt,name=AuthHeartbeats,proto3" json:"AuthHeartbeats,omitempty"`
	// ProxyCleanup indicates the ICS supports deleting proxies when UpstreamInventoryGoodbye.DeleteResources is set.
	AuthCleanup bool `protobuf:"varint,4,opt,name=AuthCleanup,proto3" json:"AuthCleanup,omitempty"`
	// NodeHeartbeats indicates the ICS supports heartbeating ssh servers.
	NodeHeartbeats bool `protobuf:"varint,5,opt,name=NodeHeartbeats,proto3" json:"NodeHeartbeats,omitempty"`
	// NodeCleanup indicates the ICS supports deleting nodes when UpstreamInventoryGoodbye.DeleteResources is set.
	NodeCleanup bool `protobuf:"varint,6,opt,name=NodeCleanup,proto3" json:"NodeCleanup,omitempty"`
	// AppHeartbeats indicates the ICS supports heartbeating app servers.
	AppHeartbeats bool `protobuf:"varint,7,opt,name=AppHeartbeats,proto3" json:"AppHeartbeats,omitempty"`
	// AppCleanup indicates the ICS supports deleting apps when UpstreamInventoryGoodbye.DeleteResources is set.
	AppCleanup bool `protobuf:"varint,8,opt,name=AppCleanup,proto3" json:"AppCleanup,omitempty"`
	// DatabaseHeartbeats indicates the ICS supports heartbeating databases.
	DatabaseHeartbeats bool `protobuf:"varint,9,opt,name=DatabaseHeartbeats,proto3" json:"DatabaseHeartbeats,omitempty"`
	// DatabaseCleanup indicates the ICS supports deleting databases when UpstreamInventoryGoodbye.DeleteResources is set.
	DatabaseCleanup bool `protobuf:"varint,10,opt,name=DatabaseCleanup,proto3" json:"DatabaseCleanup,omitempty"`
	// DatabaseServiceHeartbeats indicates the ICS supports heartbeating databse services.
	DatabaseServiceHeartbeats bool `protobuf:"varint,11,opt,name=DatabaseServiceHeartbeats,proto3" json:"DatabaseServiceHeartbeats,omitempty"`
	// DatabaseServiceCleanup indicates the ICS supports deleting database services when UpstreamInventoryGoodbye.DeleteResources is set.
	DatabaseServiceCleanup bool `protobuf:"varint,12,opt,name=DatabaseServiceCleanup,proto3" json:"DatabaseServiceCleanup,omitempty"`
	// WindowsDesktopHeartbeats indicates the ICS supports heartbeating windows desktop servers.
	WindowsDesktopHeartbeats bool `protobuf:"varint,13,opt,name=WindowsDesktopHeartbeats,proto3" json:"WindowsDesktopHeartbeats,omitempty"`
	// WindowsDesktopCleanup indicates the ICS supports deleting windows desktops when UpstreamInventoryGoodbye.DeleteResources is set.
	WindowsDesktopCleanup bool `protobuf:"varint,14,opt,name=WindowsDesktopCleanup,proto3" json:"WindowsDesktopCleanup,omitempty"`
	// WindowsDesktopHeartbeats indicates the ICS supports heartbeating windows desktop services.
	WindowsDesktopServiceHeartbeats bool `protobuf:"varint,15,opt,name=WindowsDesktopServiceHeartbeats,proto3" json:"WindowsDesktopServiceHeartbeats,omitempty"`
	// WindowsDesktopCleanup indicates the ICS supports deleting windows desktop services when UpstreamInventoryGoodbye.DeleteResources is set.
	WindowsDesktopServiceCleanup bool `protobuf:"varint,16,opt,name=WindowsDesktopServiceCleanup,proto3" json:"WindowsDesktopServiceCleanup,omitempty"`
	// KubernetesHeartbeats indicates the ICS supports heartbeating kubernetes clusters.
	KubernetesHeartbeats bool `protobuf:"varint,17,opt,name=KubernetesHeartbeats,proto3" json:"KubernetesHeartbeats,omitempty"`
	// KubernetesCleanup indicates the ICS supports deleting kubernetes clusters when UpstreamInventoryGoodbye.DeleteResources is set.
	KubernetesCleanup    bool     `protobuf:"varint,18,opt,name=KubernetesCleanup,proto3" json:"KubernetesCleanup,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownstreamInventoryHello_SupportedCapabilities) Reset() {
	*m = DownstreamInventoryHello_SupportedCapabilities{}
}
func (m *DownstreamInventoryHello_SupportedCapabilities) String() string {
	return proto.CompactTextString(m)
}
func (*DownstreamInventoryHello_SupportedCapabilities) ProtoMessage() {}
func (*DownstreamInventoryHello_SupportedCapabilities) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{196, 0}
}
func (m *DownstreamInventoryHello_SupportedCapabilities) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownstreamInventoryHello_SupportedCapabilities) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownstreamInventoryHello_SupportedCapabilities.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownstreamInventoryHello_SupportedCapabilities) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownstreamInventoryHello_SupportedCapabilities.Merge(m, src)
}
func (m *DownstreamInventoryHello_SupportedCapabilities) XXX_Size() int {
	return m.Size()
}
func (m *DownstreamInventoryHello_SupportedCapabilities) XXX_DiscardUnknown() {
	xxx_messageInfo_DownstreamInventoryHello_SupportedCapabilities.DiscardUnknown(m)
}

var xxx_messageInfo_DownstreamInventoryHello_SupportedCapabilities proto.InternalMessageInfo

func (m *DownstreamInventoryHello_SupportedCapabilities) GetProxyHeartbeats() bool {
	if m != nil {
		return m.ProxyHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetProxyCleanup() bool {
	if m != nil {
		return m.ProxyCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetAuthHeartbeats() bool {
	if m != nil {
		return m.AuthHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetAuthCleanup() bool {
	if m != nil {
		return m.AuthCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetNodeHeartbeats() bool {
	if m != nil {
		return m.NodeHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetNodeCleanup() bool {
	if m != nil {
		return m.NodeCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetAppHeartbeats() bool {
	if m != nil {
		return m.AppHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetAppCleanup() bool {
	if m != nil {
		return m.AppCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetDatabaseHeartbeats() bool {
	if m != nil {
		return m.DatabaseHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetDatabaseCleanup() bool {
	if m != nil {
		return m.DatabaseCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetDatabaseServiceHeartbeats() bool {
	if m != nil {
		return m.DatabaseServiceHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetDatabaseServiceCleanup() bool {
	if m != nil {
		return m.DatabaseServiceCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetWindowsDesktopHeartbeats() bool {
	if m != nil {
		return m.WindowsDesktopHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetWindowsDesktopCleanup() bool {
	if m != nil {
		return m.WindowsDesktopCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetWindowsDesktopServiceHeartbeats() bool {
	if m != nil {
		return m.WindowsDesktopServiceHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetWindowsDesktopServiceCleanup() bool {
	if m != nil {
		return m.WindowsDesktopServiceCleanup
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetKubernetesHeartbeats() bool {
	if m != nil {
		return m.KubernetesHeartbeats
	}
	return false
}

func (m *DownstreamInventoryHello_SupportedCapabilities) GetKubernetesCleanup() bool {
	if m != nil {
		return m.KubernetesCleanup
	}
	return false
}

// InventoryUpdateLabelsRequest is used to request that a specified instance
// update its labels.
type InventoryUpdateLabelsRequest struct {
	// ServerID advertises the server ID of the instance.
	ServerID string `protobuf:"bytes,1,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	// Kind is the type of service to update labels for.
	Kind LabelUpdateKind `protobuf:"varint,2,opt,name=Kind,proto3,enum=proto.LabelUpdateKind" json:"Kind,omitempty"`
	// Labels is the new set of labels for the instance.
	Labels               map[string]string `protobuf:"bytes,3,rep,name=Labels,proto3" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *InventoryUpdateLabelsRequest) Reset()         { *m = InventoryUpdateLabelsRequest{} }
func (m *InventoryUpdateLabelsRequest) String() string { return proto.CompactTextString(m) }
func (*InventoryUpdateLabelsRequest) ProtoMessage()    {}
func (*InventoryUpdateLabelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{197}
}
func (m *InventoryUpdateLabelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryUpdateLabelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryUpdateLabelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryUpdateLabelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryUpdateLabelsRequest.Merge(m, src)
}
func (m *InventoryUpdateLabelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *InventoryUpdateLabelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryUpdateLabelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryUpdateLabelsRequest proto.InternalMessageInfo

func (m *InventoryUpdateLabelsRequest) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

func (m *InventoryUpdateLabelsRequest) GetKind() LabelUpdateKind {
	if m != nil {
		return m.Kind
	}
	return LabelUpdateKind_SSHServer
}

func (m *InventoryUpdateLabelsRequest) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// DownstreamInventoryUpdateLabels is the message sent down the inventory
// control stream to update the instance's labels.
type DownstreamInventoryUpdateLabels struct {
	// Kind is the type of service to update labels for.
	Kind LabelUpdateKind `protobuf:"varint,1,opt,name=Kind,proto3,enum=proto.LabelUpdateKind" json:"Kind,omitempty"`
	// Labels is the new set of labels for the instance.
	Labels               map[string]string `protobuf:"bytes,2,rep,name=Labels,proto3" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DownstreamInventoryUpdateLabels) Reset()         { *m = DownstreamInventoryUpdateLabels{} }
func (m *DownstreamInventoryUpdateLabels) String() string { return proto.CompactTextString(m) }
func (*DownstreamInventoryUpdateLabels) ProtoMessage()    {}
func (*DownstreamInventoryUpdateLabels) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{198}
}
func (m *DownstreamInventoryUpdateLabels) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownstreamInventoryUpdateLabels) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownstreamInventoryUpdateLabels.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownstreamInventoryUpdateLabels) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownstreamInventoryUpdateLabels.Merge(m, src)
}
func (m *DownstreamInventoryUpdateLabels) XXX_Size() int {
	return m.Size()
}
func (m *DownstreamInventoryUpdateLabels) XXX_DiscardUnknown() {
	xxx_messageInfo_DownstreamInventoryUpdateLabels.DiscardUnknown(m)
}

var xxx_messageInfo_DownstreamInventoryUpdateLabels proto.InternalMessageInfo

func (m *DownstreamInventoryUpdateLabels) GetKind() LabelUpdateKind {
	if m != nil {
		return m.Kind
	}
	return LabelUpdateKind_SSHServer
}

func (m *DownstreamInventoryUpdateLabels) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// InventoryHeartbeat announces information about instance state.
type InventoryHeartbeat struct {
	// SSHServer is a complete ssh server spec to be heartbeated (note: the full spec is heartbeated
	// in the interest of simple conversion from the old logic of heartbeating via UpsertNode, but
	// we should be able to cut down on network usage fairly significantly by moving static values
	// to the hello message and only heartbeating dynamic values here).
	SSHServer *types.ServerV2 `protobuf:"bytes,1,opt,name=SSHServer,proto3" json:"SSHServer,omitempty"`
	// AppServer is a complete app server spec to be heartbeated.
	AppServer *types.AppServerV3 `protobuf:"bytes,2,opt,name=AppServer,proto3" json:"AppServer,omitempty"`
	// DatabaseServer is a complete db server spec to be heartbeated.
	DatabaseServer       *types.DatabaseServerV3 `protobuf:"bytes,3,opt,name=DatabaseServer,proto3" json:"DatabaseServer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *InventoryHeartbeat) Reset()         { *m = InventoryHeartbeat{} }
func (m *InventoryHeartbeat) String() string { return proto.CompactTextString(m) }
func (*InventoryHeartbeat) ProtoMessage()    {}
func (*InventoryHeartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{199}
}
func (m *InventoryHeartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryHeartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryHeartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryHeartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryHeartbeat.Merge(m, src)
}
func (m *InventoryHeartbeat) XXX_Size() int {
	return m.Size()
}
func (m *InventoryHeartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryHeartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryHeartbeat proto.InternalMessageInfo

func (m *InventoryHeartbeat) GetSSHServer() *types.ServerV2 {
	if m != nil {
		return m.SSHServer
	}
	return nil
}

func (m *InventoryHeartbeat) GetAppServer() *types.AppServerV3 {
	if m != nil {
		return m.AppServer
	}
	return nil
}

func (m *InventoryHeartbeat) GetDatabaseServer() *types.DatabaseServerV3 {
	if m != nil {
		return m.DatabaseServer
	}
	return nil
}

// UpstreamInventoryGoodbye informs the upstream service that instance
// is terminating
type UpstreamInventoryGoodbye struct {
	// DeleteResources indicates that any heartbeats received from
	// the instance should be terminated when the stream is closed.
	DeleteResources      bool     `protobuf:"varint,1,opt,name=DeleteResources,proto3" json:"DeleteResources,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpstreamInventoryGoodbye) Reset()         { *m = UpstreamInventoryGoodbye{} }
func (m *UpstreamInventoryGoodbye) String() string { return proto.CompactTextString(m) }
func (*UpstreamInventoryGoodbye) ProtoMessage()    {}
func (*UpstreamInventoryGoodbye) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{200}
}
func (m *UpstreamInventoryGoodbye) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamInventoryGoodbye) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpstreamInventoryGoodbye.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpstreamInventoryGoodbye) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamInventoryGoodbye.Merge(m, src)
}
func (m *UpstreamInventoryGoodbye) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamInventoryGoodbye) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamInventoryGoodbye.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamInventoryGoodbye proto.InternalMessageInfo

func (m *UpstreamInventoryGoodbye) GetDeleteResources() bool {
	if m != nil {
		return m.DeleteResources
	}
	return false
}

// InventoryStatusRequest requests inventory status info.
type InventoryStatusRequest struct {
	// Connected requests summary of the inventory control streams registered with
	// the auth server that handles the request.
	Connected            bool     `protobuf:"varint,1,opt,name=Connected,proto3" json:"Connected,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InventoryStatusRequest) Reset()         { *m = InventoryStatusRequest{} }
func (m *InventoryStatusRequest) String() string { return proto.CompactTextString(m) }
func (*InventoryStatusRequest) ProtoMessage()    {}
func (*InventoryStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{201}
}
func (m *InventoryStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryStatusRequest.Merge(m, src)
}
func (m *InventoryStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *InventoryStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryStatusRequest proto.InternalMessageInfo

func (m *InventoryStatusRequest) GetConnected() bool {
	if m != nil {
		return m.Connected
	}
	return false
}

// InventoryStatusSummary is the status summary returned by the GetInventoryStatus rpc.
type InventoryStatusSummary struct {
	// Connected is a summary of the instances connected to the current auth server.  Only set if
	// the Connected flag in the status request is true.
	Connected []UpstreamInventoryHello `protobuf:"bytes,1,rep,name=Connected,proto3" json:"Connected"`
	// InstanceCount is the total number of instance resources aggregated.
	InstanceCount uint32 `protobuf:"varint,2,opt,name=InstanceCount,proto3" json:"InstanceCount,omitempty"`
	// VersionCounts aggregates unique version counts.
	VersionCounts map[string]uint32 `protobuf:"bytes,3,rep,name=VersionCounts,proto3" json:"VersionCounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// UpgraderCounts aggregates the unique upgrader counts.
	UpgraderCounts map[string]uint32 `protobuf:"bytes,4,rep,name=UpgraderCounts,proto3" json:"UpgraderCounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// ServiceCounts aggregates the number of services.
	ServiceCounts        map[string]uint32 `protobuf:"bytes,5,rep,name=ServiceCounts,proto3" json:"ServiceCounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *InventoryStatusSummary) Reset()         { *m = InventoryStatusSummary{} }
func (m *InventoryStatusSummary) String() string { return proto.CompactTextString(m) }
func (*InventoryStatusSummary) ProtoMessage()    {}
func (*InventoryStatusSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{202}
}
func (m *InventoryStatusSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryStatusSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryStatusSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryStatusSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryStatusSummary.Merge(m, src)
}
func (m *InventoryStatusSummary) XXX_Size() int {
	return m.Size()
}
func (m *InventoryStatusSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryStatusSummary.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryStatusSummary proto.InternalMessageInfo

func (m *InventoryStatusSummary) GetConnected() []UpstreamInventoryHello {
	if m != nil {
		return m.Connected
	}
	return nil
}

func (m *InventoryStatusSummary) GetInstanceCount() uint32 {
	if m != nil {
		return m.InstanceCount
	}
	return 0
}

func (m *InventoryStatusSummary) GetVersionCounts() map[string]uint32 {
	if m != nil {
		return m.VersionCounts
	}
	return nil
}

func (m *InventoryStatusSummary) GetUpgraderCounts() map[string]uint32 {
	if m != nil {
		return m.UpgraderCounts
	}
	return nil
}

func (m *InventoryStatusSummary) GetServiceCounts() map[string]uint32 {
	if m != nil {
		return m.ServiceCounts
	}
	return nil
}

// InventoryConnectedServiceCountsRequest requests inventory connected service counts.
type InventoryConnectedServiceCountsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InventoryConnectedServiceCountsRequest) Reset() {
	*m = InventoryConnectedServiceCountsRequest{}
}
func (m *InventoryConnectedServiceCountsRequest) String() string { return proto.CompactTextString(m) }
func (*InventoryConnectedServiceCountsRequest) ProtoMessage()    {}
func (*InventoryConnectedServiceCountsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{203}
}
func (m *InventoryConnectedServiceCountsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryConnectedServiceCountsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryConnectedServiceCountsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryConnectedServiceCountsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryConnectedServiceCountsRequest.Merge(m, src)
}
func (m *InventoryConnectedServiceCountsRequest) XXX_Size() int {
	return m.Size()
}
func (m *InventoryConnectedServiceCountsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryConnectedServiceCountsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryConnectedServiceCountsRequest proto.InternalMessageInfo

// InventoryConnectedServiceCounts is the connected service counts seen in the inventory.
type InventoryConnectedServiceCounts struct {
	// ServiceCounts is the count of each connected service seen in the inventory.
	ServiceCounts        map[github_com_gravitational_teleport_api_types.SystemRole]uint64 `protobuf:"bytes,1,rep,name=ServiceCounts,proto3,castkey=github.com/gravitational/teleport/api/types.SystemRole" json:"ServiceCounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                          `json:"-"`
	XXX_unrecognized     []byte                                                            `json:"-"`
	XXX_sizecache        int32                                                             `json:"-"`
}

func (m *InventoryConnectedServiceCounts) Reset()         { *m = InventoryConnectedServiceCounts{} }
func (m *InventoryConnectedServiceCounts) String() string { return proto.CompactTextString(m) }
func (*InventoryConnectedServiceCounts) ProtoMessage()    {}
func (*InventoryConnectedServiceCounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{204}
}
func (m *InventoryConnectedServiceCounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryConnectedServiceCounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryConnectedServiceCounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryConnectedServiceCounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryConnectedServiceCounts.Merge(m, src)
}
func (m *InventoryConnectedServiceCounts) XXX_Size() int {
	return m.Size()
}
func (m *InventoryConnectedServiceCounts) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryConnectedServiceCounts.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryConnectedServiceCounts proto.InternalMessageInfo

func (m *InventoryConnectedServiceCounts) GetServiceCounts() map[github_com_gravitational_teleport_api_types.SystemRole]uint64 {
	if m != nil {
		return m.ServiceCounts
	}
	return nil
}

// InventoryPingRequest is used to request that the specified server be sent an inventory ping
// if it has a control stream registered.
type InventoryPingRequest struct {
	// ServerID is the ID of the instance to ping.
	ServerID string `protobuf:"bytes,1,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	// ControlLog forces the ping to use the standard "commit then act" model of control log synchronization
	// for the ping. This significantly increases the amount of time it takes for the ping request to
	// complete, but is useful for testing/debugging control log issues.
	ControlLog           bool     `protobuf:"varint,2,opt,name=ControlLog,proto3" json:"ControlLog,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InventoryPingRequest) Reset()         { *m = InventoryPingRequest{} }
func (m *InventoryPingRequest) String() string { return proto.CompactTextString(m) }
func (*InventoryPingRequest) ProtoMessage()    {}
func (*InventoryPingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{205}
}
func (m *InventoryPingRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryPingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryPingRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryPingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryPingRequest.Merge(m, src)
}
func (m *InventoryPingRequest) XXX_Size() int {
	return m.Size()
}
func (m *InventoryPingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryPingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryPingRequest proto.InternalMessageInfo

func (m *InventoryPingRequest) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

func (m *InventoryPingRequest) GetControlLog() bool {
	if m != nil {
		return m.ControlLog
	}
	return false
}

// InventoryPingResponse returns the result of an inventory ping initiated via an
// inventory ping request.
type InventoryPingResponse struct {
	Duration             time.Duration `protobuf:"varint,1,opt,name=Duration,proto3,casttype=time.Duration" json:"Duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *InventoryPingResponse) Reset()         { *m = InventoryPingResponse{} }
func (m *InventoryPingResponse) String() string { return proto.CompactTextString(m) }
func (*InventoryPingResponse) ProtoMessage()    {}
func (*InventoryPingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{206}
}
func (m *InventoryPingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InventoryPingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InventoryPingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InventoryPingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InventoryPingResponse.Merge(m, src)
}
func (m *InventoryPingResponse) XXX_Size() int {
	return m.Size()
}
func (m *InventoryPingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InventoryPingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InventoryPingResponse proto.InternalMessageInfo

func (m *InventoryPingResponse) GetDuration() time.Duration {
	if m != nil {
		return m.Duration
	}
	return 0
}

// GetClusterAlertsResponse contains the result of a cluster alerts query.
type GetClusterAlertsResponse struct {
	// Alerts is the list of matching alerts.
	Alerts               []types.ClusterAlert `protobuf:"bytes,1,rep,name=Alerts,proto3" json:"Alerts"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GetClusterAlertsResponse) Reset()         { *m = GetClusterAlertsResponse{} }
func (m *GetClusterAlertsResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterAlertsResponse) ProtoMessage()    {}
func (*GetClusterAlertsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{207}
}
func (m *GetClusterAlertsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterAlertsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterAlertsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterAlertsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterAlertsResponse.Merge(m, src)
}
func (m *GetClusterAlertsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetClusterAlertsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterAlertsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterAlertsResponse proto.InternalMessageInfo

func (m *GetClusterAlertsResponse) GetAlerts() []types.ClusterAlert {
	if m != nil {
		return m.Alerts
	}
	return nil
}

// GetAlertAcksRequest returns the currently acknowledged alerts
type GetAlertAcksRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAlertAcksRequest) Reset()         { *m = GetAlertAcksRequest{} }
func (m *GetAlertAcksRequest) String() string { return proto.CompactTextString(m) }
func (*GetAlertAcksRequest) ProtoMessage()    {}
func (*GetAlertAcksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{208}
}
func (m *GetAlertAcksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAlertAcksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAlertAcksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAlertAcksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAlertAcksRequest.Merge(m, src)
}
func (m *GetAlertAcksRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAlertAcksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAlertAcksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAlertAcksRequest proto.InternalMessageInfo

// GetAlertAcksResponse contains the set of active cluster alert
// acknowledgements for this cluster.
type GetAlertAcksResponse struct {
	Acks                 []types.AlertAcknowledgement `protobuf:"bytes,1,rep,name=Acks,proto3" json:"acks"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *GetAlertAcksResponse) Reset()         { *m = GetAlertAcksResponse{} }
func (m *GetAlertAcksResponse) String() string { return proto.CompactTextString(m) }
func (*GetAlertAcksResponse) ProtoMessage()    {}
func (*GetAlertAcksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{209}
}
func (m *GetAlertAcksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAlertAcksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAlertAcksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAlertAcksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAlertAcksResponse.Merge(m, src)
}
func (m *GetAlertAcksResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAlertAcksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAlertAcksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAlertAcksResponse proto.InternalMessageInfo

func (m *GetAlertAcksResponse) GetAcks() []types.AlertAcknowledgement {
	if m != nil {
		return m.Acks
	}
	return nil
}

// ClearAlertAcksRequest specifies alerts acknowledgements to clear.
type ClearAlertAcksRequest struct {
	// AlertID deletes an acknowledgement by ID. Deletes all acknowledgements if
	// the id is '*'.
	AlertID              string   `protobuf:"bytes,1,opt,name=AlertID,proto3" json:"alert_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearAlertAcksRequest) Reset()         { *m = ClearAlertAcksRequest{} }
func (m *ClearAlertAcksRequest) String() string { return proto.CompactTextString(m) }
func (*ClearAlertAcksRequest) ProtoMessage()    {}
func (*ClearAlertAcksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{210}
}
func (m *ClearAlertAcksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearAlertAcksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearAlertAcksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearAlertAcksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearAlertAcksRequest.Merge(m, src)
}
func (m *ClearAlertAcksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearAlertAcksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearAlertAcksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearAlertAcksRequest proto.InternalMessageInfo

func (m *ClearAlertAcksRequest) GetAlertID() string {
	if m != nil {
		return m.AlertID
	}
	return ""
}

// UpsertClusterAlertRequest is used to create a cluster alert.
type UpsertClusterAlertRequest struct {
	// Alert is the alert being created.
	Alert                types.ClusterAlert `protobuf:"bytes,1,opt,name=Alert,proto3" json:"Alert"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *UpsertClusterAlertRequest) Reset()         { *m = UpsertClusterAlertRequest{} }
func (m *UpsertClusterAlertRequest) String() string { return proto.CompactTextString(m) }
func (*UpsertClusterAlertRequest) ProtoMessage()    {}
func (*UpsertClusterAlertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{211}
}
func (m *UpsertClusterAlertRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertClusterAlertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertClusterAlertRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertClusterAlertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertClusterAlertRequest.Merge(m, src)
}
func (m *UpsertClusterAlertRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpsertClusterAlertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertClusterAlertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertClusterAlertRequest proto.InternalMessageInfo

func (m *UpsertClusterAlertRequest) GetAlert() types.ClusterAlert {
	if m != nil {
		return m.Alert
	}
	return types.ClusterAlert{}
}

// GetConnectionDiagnosticRequest is a request to return a connection diagnostic.
type GetConnectionDiagnosticRequest struct {
	// Name is the name of the connection diagnostic.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetConnectionDiagnosticRequest) Reset()         { *m = GetConnectionDiagnosticRequest{} }
func (m *GetConnectionDiagnosticRequest) String() string { return proto.CompactTextString(m) }
func (*GetConnectionDiagnosticRequest) ProtoMessage()    {}
func (*GetConnectionDiagnosticRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{212}
}
func (m *GetConnectionDiagnosticRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetConnectionDiagnosticRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetConnectionDiagnosticRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetConnectionDiagnosticRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetConnectionDiagnosticRequest.Merge(m, src)
}
func (m *GetConnectionDiagnosticRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetConnectionDiagnosticRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetConnectionDiagnosticRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetConnectionDiagnosticRequest proto.InternalMessageInfo

func (m *GetConnectionDiagnosticRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// AppendDiagnosticTraceRequest is a request to append a trace into a DiagnosticConnection.
type AppendDiagnosticTraceRequest struct {
	// Name is the name of the connection diagnostic.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Trace is the ConnectionDiagnosticTrace to append into the DiagnosticConnection.
	Trace                *types.ConnectionDiagnosticTrace `protobuf:"bytes,2,opt,name=Trace,proto3" json:"trace"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *AppendDiagnosticTraceRequest) Reset()         { *m = AppendDiagnosticTraceRequest{} }
func (m *AppendDiagnosticTraceRequest) String() string { return proto.CompactTextString(m) }
func (*AppendDiagnosticTraceRequest) ProtoMessage()    {}
func (*AppendDiagnosticTraceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{213}
}
func (m *AppendDiagnosticTraceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendDiagnosticTraceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendDiagnosticTraceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendDiagnosticTraceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendDiagnosticTraceRequest.Merge(m, src)
}
func (m *AppendDiagnosticTraceRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppendDiagnosticTraceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendDiagnosticTraceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendDiagnosticTraceRequest proto.InternalMessageInfo

func (m *AppendDiagnosticTraceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AppendDiagnosticTraceRequest) GetTrace() *types.ConnectionDiagnosticTrace {
	if m != nil {
		return m.Trace
	}
	return nil
}

// SubmitUsageEventRequest is used to submit an external usage event.
type SubmitUsageEventRequest struct {
	Event                *v12.UsageEventOneOf `protobuf:"bytes,1,opt,name=Event,proto3" json:"event"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SubmitUsageEventRequest) Reset()         { *m = SubmitUsageEventRequest{} }
func (m *SubmitUsageEventRequest) String() string { return proto.CompactTextString(m) }
func (*SubmitUsageEventRequest) ProtoMessage()    {}
func (*SubmitUsageEventRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{214}
}
func (m *SubmitUsageEventRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitUsageEventRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitUsageEventRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitUsageEventRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitUsageEventRequest.Merge(m, src)
}
func (m *SubmitUsageEventRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubmitUsageEventRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitUsageEventRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitUsageEventRequest proto.InternalMessageInfo

func (m *SubmitUsageEventRequest) GetEvent() *v12.UsageEventOneOf {
	if m != nil {
		return m.Event
	}
	return nil
}

// GetLicenseEvent is used to submit an external usage event.
type GetLicenseRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLicenseRequest) Reset()         { *m = GetLicenseRequest{} }
func (m *GetLicenseRequest) String() string { return proto.CompactTextString(m) }
func (*GetLicenseRequest) ProtoMessage()    {}
func (*GetLicenseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{215}
}
func (m *GetLicenseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLicenseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLicenseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLicenseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLicenseRequest.Merge(m, src)
}
func (m *GetLicenseRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLicenseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLicenseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLicenseRequest proto.InternalMessageInfo

// GetLicenseEvent is used to submit an external usage event.
type ListReleasesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListReleasesRequest) Reset()         { *m = ListReleasesRequest{} }
func (m *ListReleasesRequest) String() string { return proto.CompactTextString(m) }
func (*ListReleasesRequest) ProtoMessage()    {}
func (*ListReleasesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{216}
}
func (m *ListReleasesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListReleasesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListReleasesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListReleasesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListReleasesRequest.Merge(m, src)
}
func (m *ListReleasesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListReleasesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListReleasesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListReleasesRequest proto.InternalMessageInfo

// CreateTokenV2Request is used with CreateTokenV2 to create tokens in the
// backend.
type CreateTokenV2Request struct {
	// Types that are valid to be assigned to Token:
	//	*CreateTokenV2Request_V2
	Token                isCreateTokenV2Request_Token `protobuf_oneof:"Token"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *CreateTokenV2Request) Reset()         { *m = CreateTokenV2Request{} }
func (m *CreateTokenV2Request) String() string { return proto.CompactTextString(m) }
func (*CreateTokenV2Request) ProtoMessage()    {}
func (*CreateTokenV2Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{217}
}
func (m *CreateTokenV2Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTokenV2Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTokenV2Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTokenV2Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTokenV2Request.Merge(m, src)
}
func (m *CreateTokenV2Request) XXX_Size() int {
	return m.Size()
}
func (m *CreateTokenV2Request) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTokenV2Request.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTokenV2Request proto.InternalMessageInfo

type isCreateTokenV2Request_Token interface {
	isCreateTokenV2Request_Token()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateTokenV2Request_V2 struct {
	V2 *types.ProvisionTokenV2 `protobuf:"bytes,1,opt,name=V2,proto3,oneof" json:"v2,omitempty"`
}

func (*CreateTokenV2Request_V2) isCreateTokenV2Request_Token() {}

func (m *CreateTokenV2Request) GetToken() isCreateTokenV2Request_Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *CreateTokenV2Request) GetV2() *types.ProvisionTokenV2 {
	if x, ok := m.GetToken().(*CreateTokenV2Request_V2); ok {
		return x.V2
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateTokenV2Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateTokenV2Request_V2)(nil),
	}
}

// UpsertTokenV2Request is used with UpsertTokenV2 to upsert tokens in the
// backend.
type UpsertTokenV2Request struct {
	// Types that are valid to be assigned to Token:
	//	*UpsertTokenV2Request_V2
	Token                isUpsertTokenV2Request_Token `protobuf_oneof:"Token"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *UpsertTokenV2Request) Reset()         { *m = UpsertTokenV2Request{} }
func (m *UpsertTokenV2Request) String() string { return proto.CompactTextString(m) }
func (*UpsertTokenV2Request) ProtoMessage()    {}
func (*UpsertTokenV2Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{218}
}
func (m *UpsertTokenV2Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpsertTokenV2Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpsertTokenV2Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpsertTokenV2Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpsertTokenV2Request.Merge(m, src)
}
func (m *UpsertTokenV2Request) XXX_Size() int {
	return m.Size()
}
func (m *UpsertTokenV2Request) XXX_DiscardUnknown() {
	xxx_messageInfo_UpsertTokenV2Request.DiscardUnknown(m)
}

var xxx_messageInfo_UpsertTokenV2Request proto.InternalMessageInfo

type isUpsertTokenV2Request_Token interface {
	isUpsertTokenV2Request_Token()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UpsertTokenV2Request_V2 struct {
	V2 *types.ProvisionTokenV2 `protobuf:"bytes,1,opt,name=V2,proto3,oneof" json:"v2,omitempty"`
}

func (*UpsertTokenV2Request_V2) isUpsertTokenV2Request_Token() {}

func (m *UpsertTokenV2Request) GetToken() isUpsertTokenV2Request_Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *UpsertTokenV2Request) GetV2() *types.ProvisionTokenV2 {
	if x, ok := m.GetToken().(*UpsertTokenV2Request_V2); ok {
		return x.V2
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UpsertTokenV2Request) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UpsertTokenV2Request_V2)(nil),
	}
}

// Request for GetHeadlessAuthentication.
type GetHeadlessAuthenticationRequest struct {
	// ID is the headless authentication id.
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetHeadlessAuthenticationRequest) Reset()         { *m = GetHeadlessAuthenticationRequest{} }
func (m *GetHeadlessAuthenticationRequest) String() string { return proto.CompactTextString(m) }
func (*GetHeadlessAuthenticationRequest) ProtoMessage()    {}
func (*GetHeadlessAuthenticationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{219}
}
func (m *GetHeadlessAuthenticationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHeadlessAuthenticationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHeadlessAuthenticationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHeadlessAuthenticationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHeadlessAuthenticationRequest.Merge(m, src)
}
func (m *GetHeadlessAuthenticationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetHeadlessAuthenticationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHeadlessAuthenticationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetHeadlessAuthenticationRequest proto.InternalMessageInfo

func (m *GetHeadlessAuthenticationRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Request for UpdateHeadlessAuthenticationState.
type UpdateHeadlessAuthenticationStateRequest struct {
	// ID is the headless authentication id.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// State is the state that the request will be updated to.
	// MFA verification is required if State=APPROVED.
	State types.HeadlessAuthenticationState `protobuf:"varint,2,opt,name=state,proto3,enum=types.HeadlessAuthenticationState" json:"state,omitempty"`
	// MFAResponse is an mfa challenge response used to verify the user.
	// MFA Auth Challenges can be created for a user with the
	// authservice.GenerateAuthenticateChallenge rpc.
	MfaResponse          *MFAAuthenticateResponse `protobuf:"bytes,3,opt,name=mfa_response,json=mfaResponse,proto3" json:"mfa_response,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *UpdateHeadlessAuthenticationStateRequest) Reset() {
	*m = UpdateHeadlessAuthenticationStateRequest{}
}
func (m *UpdateHeadlessAuthenticationStateRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateHeadlessAuthenticationStateRequest) ProtoMessage()    {}
func (*UpdateHeadlessAuthenticationStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{220}
}
func (m *UpdateHeadlessAuthenticationStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateHeadlessAuthenticationStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateHeadlessAuthenticationStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateHeadlessAuthenticationStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateHeadlessAuthenticationStateRequest.Merge(m, src)
}
func (m *UpdateHeadlessAuthenticationStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateHeadlessAuthenticationStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateHeadlessAuthenticationStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateHeadlessAuthenticationStateRequest proto.InternalMessageInfo

func (m *UpdateHeadlessAuthenticationStateRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UpdateHeadlessAuthenticationStateRequest) GetState() types.HeadlessAuthenticationState {
	if m != nil {
		return m.State
	}
	return types.HeadlessAuthenticationState_HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED
}

func (m *UpdateHeadlessAuthenticationStateRequest) GetMfaResponse() *MFAAuthenticateResponse {
	if m != nil {
		return m.MfaResponse
	}
	return nil
}

// ExportUpgradeWindowsRequest encodes parameters for loading the
// upgrader-facing representations of upcoming agent maintenance windows.
type ExportUpgradeWindowsRequest struct {
	// TeleportVersion is the version of the teleport client making the request.
	TeleportVersion string `protobuf:"bytes,1,opt,name=TeleportVersion,proto3" json:"TeleportVersion,omitempty"`
	// UpgraderKind represents the kind of upgrader the schedule is intended for.
	UpgraderKind         string   `protobuf:"bytes,2,opt,name=UpgraderKind,proto3" json:"UpgraderKind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExportUpgradeWindowsRequest) Reset()         { *m = ExportUpgradeWindowsRequest{} }
func (m *ExportUpgradeWindowsRequest) String() string { return proto.CompactTextString(m) }
func (*ExportUpgradeWindowsRequest) ProtoMessage()    {}
func (*ExportUpgradeWindowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{221}
}
func (m *ExportUpgradeWindowsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportUpgradeWindowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportUpgradeWindowsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportUpgradeWindowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportUpgradeWindowsRequest.Merge(m, src)
}
func (m *ExportUpgradeWindowsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExportUpgradeWindowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportUpgradeWindowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExportUpgradeWindowsRequest proto.InternalMessageInfo

func (m *ExportUpgradeWindowsRequest) GetTeleportVersion() string {
	if m != nil {
		return m.TeleportVersion
	}
	return ""
}

func (m *ExportUpgradeWindowsRequest) GetUpgraderKind() string {
	if m != nil {
		return m.UpgraderKind
	}
	return ""
}

// ExportUpgradeWindowsResponse encodes an upgrader-facing representation
// of upcoming agent maintenance windows. Teleport agents periodically export these
// schedules to external upgraders as part of the externally-managed upgrade system.
type ExportUpgradeWindowsResponse struct {
	// CanonicalSchedule is the teleport-facing schedule repr.
	CanonicalSchedule *types.AgentUpgradeSchedule `protobuf:"bytes,1,opt,name=CanonicalSchedule,proto3" json:"CanonicalSchedule,omitempty"`
	// KubeControllerSchedule encodes upcoming upgrade upgrade windows in a format known
	// to the kube upgrade controller. Teleport agents should treat this value as an
	// opaque blob.
	KubeControllerSchedule string `protobuf:"bytes,2,opt,name=KubeControllerSchedule,proto3" json:"KubeControllerSchedule,omitempty"`
	// SystemdUnitSchedule encodes the upcoming upgrade windows in a format known to
	// the teleport-upgrade systemd unit. Teleport agents should treat this value as an
	// opaque blob.
	SystemdUnitSchedule  string   `protobuf:"bytes,3,opt,name=SystemdUnitSchedule,proto3" json:"SystemdUnitSchedule,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExportUpgradeWindowsResponse) Reset()         { *m = ExportUpgradeWindowsResponse{} }
func (m *ExportUpgradeWindowsResponse) String() string { return proto.CompactTextString(m) }
func (*ExportUpgradeWindowsResponse) ProtoMessage()    {}
func (*ExportUpgradeWindowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{222}
}
func (m *ExportUpgradeWindowsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportUpgradeWindowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportUpgradeWindowsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportUpgradeWindowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportUpgradeWindowsResponse.Merge(m, src)
}
func (m *ExportUpgradeWindowsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExportUpgradeWindowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportUpgradeWindowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExportUpgradeWindowsResponse proto.InternalMessageInfo

func (m *ExportUpgradeWindowsResponse) GetCanonicalSchedule() *types.AgentUpgradeSchedule {
	if m != nil {
		return m.CanonicalSchedule
	}
	return nil
}

func (m *ExportUpgradeWindowsResponse) GetKubeControllerSchedule() string {
	if m != nil {
		return m.KubeControllerSchedule
	}
	return ""
}

func (m *ExportUpgradeWindowsResponse) GetSystemdUnitSchedule() string {
	if m != nil {
		return m.SystemdUnitSchedule
	}
	return ""
}

// ListAccessRequestsRequest encodes the parameters for a paginated access request lookup.
type ListAccessRequestsRequest struct {
	// Filter matches access requests.
	Filter *types.AccessRequestFilter `protobuf:"bytes,1,opt,name=Filter,proto3" json:"Filter,omitempty"`
	// Sort determines the sort order of returned access requests.
	Sort AccessRequestSort `protobuf:"varint,2,opt,name=Sort,proto3,enum=proto.AccessRequestSort" json:"Sort,omitempty"`
	// Descending requests descending sort order if true (teleport APIs generally always
	// defaults to ascending sort order since that is the native sort order used in the
	// teleport backend).
	Descending bool `protobuf:"varint,3,opt,name=Descending,proto3" json:"Descending,omitempty"`
	// Limit is the maximum amount of requests per page.
	Limit int32 `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// StartKey is used to resume a query in order to enable pagination.
	// If the previous response had NextKey set then this should be
	// set to its value. Otherwise leave empty.
	StartKey             string   `protobuf:"bytes,5,opt,name=StartKey,proto3" json:"StartKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAccessRequestsRequest) Reset()         { *m = ListAccessRequestsRequest{} }
func (m *ListAccessRequestsRequest) String() string { return proto.CompactTextString(m) }
func (*ListAccessRequestsRequest) ProtoMessage()    {}
func (*ListAccessRequestsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{223}
}
func (m *ListAccessRequestsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAccessRequestsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAccessRequestsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAccessRequestsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAccessRequestsRequest.Merge(m, src)
}
func (m *ListAccessRequestsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAccessRequestsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAccessRequestsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAccessRequestsRequest proto.InternalMessageInfo

func (m *ListAccessRequestsRequest) GetFilter() *types.AccessRequestFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ListAccessRequestsRequest) GetSort() AccessRequestSort {
	if m != nil {
		return m.Sort
	}
	return AccessRequestSort_DEFAULT
}

func (m *ListAccessRequestsRequest) GetDescending() bool {
	if m != nil {
		return m.Descending
	}
	return false
}

func (m *ListAccessRequestsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListAccessRequestsRequest) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

// ListAccessRequestsResponse is a page of access requests.
type ListAccessRequestsResponse struct {
	// AccessRequests is a page of access requests.
	AccessRequests []*types.AccessRequestV3 `protobuf:"bytes,1,rep,name=AccessRequests,proto3" json:"AccessRequests,omitempty"`
	// NextKey will serve as the StartKey for the next page of requests.
	NextKey              string   `protobuf:"bytes,2,opt,name=NextKey,proto3" json:"NextKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAccessRequestsResponse) Reset()         { *m = ListAccessRequestsResponse{} }
func (m *ListAccessRequestsResponse) String() string { return proto.CompactTextString(m) }
func (*ListAccessRequestsResponse) ProtoMessage()    {}
func (*ListAccessRequestsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{224}
}
func (m *ListAccessRequestsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAccessRequestsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAccessRequestsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAccessRequestsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAccessRequestsResponse.Merge(m, src)
}
func (m *ListAccessRequestsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAccessRequestsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAccessRequestsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAccessRequestsResponse proto.InternalMessageInfo

func (m *ListAccessRequestsResponse) GetAccessRequests() []*types.AccessRequestV3 {
	if m != nil {
		return m.AccessRequests
	}
	return nil
}

func (m *ListAccessRequestsResponse) GetNextKey() string {
	if m != nil {
		return m.NextKey
	}
	return ""
}

// AccessRequestAllowedPromotionRequest is the request to AccessRequestAllowedPromotion RPC call.
type AccessRequestAllowedPromotionRequest struct {
	// AccessRequest is the access request to get promotions for.
	AccessRequestID      string   `protobuf:"bytes,1,opt,name=accessRequestID,proto3" json:"accessRequestID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessRequestAllowedPromotionRequest) Reset()         { *m = AccessRequestAllowedPromotionRequest{} }
func (m *AccessRequestAllowedPromotionRequest) String() string { return proto.CompactTextString(m) }
func (*AccessRequestAllowedPromotionRequest) ProtoMessage()    {}
func (*AccessRequestAllowedPromotionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{225}
}
func (m *AccessRequestAllowedPromotionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestAllowedPromotionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestAllowedPromotionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestAllowedPromotionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestAllowedPromotionRequest.Merge(m, src)
}
func (m *AccessRequestAllowedPromotionRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestAllowedPromotionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestAllowedPromotionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestAllowedPromotionRequest proto.InternalMessageInfo

func (m *AccessRequestAllowedPromotionRequest) GetAccessRequestID() string {
	if m != nil {
		return m.AccessRequestID
	}
	return ""
}

// AccessRequestAllowedPromotionResponse is the response to AccessRequestAllowedPromotion RPC call.
type AccessRequestAllowedPromotionResponse struct {
	// allowedPromotions is the list of allowed promotions for the access request.
	AllowedPromotions    *types.AccessRequestAllowedPromotions `protobuf:"bytes,1,opt,name=allowedPromotions,proto3" json:"allowedPromotions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *AccessRequestAllowedPromotionResponse) Reset()         { *m = AccessRequestAllowedPromotionResponse{} }
func (m *AccessRequestAllowedPromotionResponse) String() string { return proto.CompactTextString(m) }
func (*AccessRequestAllowedPromotionResponse) ProtoMessage()    {}
func (*AccessRequestAllowedPromotionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ffcffcda38ae159, []int{226}
}
func (m *AccessRequestAllowedPromotionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessRequestAllowedPromotionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessRequestAllowedPromotionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessRequestAllowedPromotionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRequestAllowedPromotionResponse.Merge(m, src)
}
func (m *AccessRequestAllowedPromotionResponse) XXX_Size() int {
	return m.Size()
}
func (m *AccessRequestAllowedPromotionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRequestAllowedPromotionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRequestAllowedPromotionResponse proto.InternalMessageInfo

func (m *AccessRequestAllowedPromotionResponse) GetAllowedPromotions() *types.AccessRequestAllowedPromotions {
	if m != nil {
		return m.AllowedPromotions
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.ProductType", ProductType_name, ProductType_value)
	proto.RegisterEnum("proto.SupportType", SupportType_name, SupportType_value)
	proto.RegisterEnum("proto.DeviceType", DeviceType_name, DeviceType_value)
	proto.RegisterEnum("proto.DeviceUsage", DeviceUsage_name, DeviceUsage_value)
	proto.RegisterEnum("proto.MFARequired", MFARequired_name, MFARequired_value)
	proto.RegisterEnum("proto.Order", Order_name, Order_value)
	proto.RegisterEnum("proto.LabelUpdateKind", LabelUpdateKind_name, LabelUpdateKind_value)
	proto.RegisterEnum("proto.AccessRequestSort", AccessRequestSort_name, AccessRequestSort_value)
	proto.RegisterEnum("proto.UserCertsRequest_CertUsage", UserCertsRequest_CertUsage_name, UserCertsRequest_CertUsage_value)
	proto.RegisterEnum("proto.UserCertsRequest_Requester", UserCertsRequest_Requester_name, UserCertsRequest_Requester_value)
	proto.RegisterEnum("proto.UserCertsRequest_CertPurpose", UserCertsRequest_CertPurpose_name, UserCertsRequest_CertPurpose_value)
	proto.RegisterEnum("proto.DatabaseCertRequest_Requester", DatabaseCertRequest_Requester_name, DatabaseCertRequest_Requester_value)
	proto.RegisterEnum("proto.DatabaseCertRequest_Extensions", DatabaseCertRequest_Extensions_name, DatabaseCertRequest_Extensions_value)
	proto.RegisterType((*Watch)(nil), "proto.Watch")
	proto.RegisterType((*HostCertsRequest)(nil), "proto.HostCertsRequest")
	proto.RegisterType((*OpenSSHCertRequest)(nil), "proto.OpenSSHCertRequest")
	proto.RegisterType((*OpenSSHCert)(nil), "proto.OpenSSHCert")
	proto.RegisterType((*UserCertsRequest)(nil), "proto.UserCertsRequest")
	proto.RegisterType((*RouteToDatabase)(nil), "proto.RouteToDatabase")
	proto.RegisterType((*RouteToWindowsDesktop)(nil), "proto.RouteToWindowsDesktop")
	proto.RegisterType((*RouteToApp)(nil), "proto.RouteToApp")
	proto.RegisterType((*GetUserRequest)(nil), "proto.GetUserRequest")
	proto.RegisterType((*GetUsersRequest)(nil), "proto.GetUsersRequest")
	proto.RegisterType((*ChangePasswordRequest)(nil), "proto.ChangePasswordRequest")
	proto.RegisterType((*PluginDataSeq)(nil), "proto.PluginDataSeq")
	proto.RegisterType((*RequestStateSetter)(nil), "proto.RequestStateSetter")
	proto.RegisterType((*RequestID)(nil), "proto.RequestID")
	proto.RegisterType((*GetResetPasswordTokenRequest)(nil), "proto.GetResetPasswordTokenRequest")
	proto.RegisterType((*CreateResetPasswordTokenRequest)(nil), "proto.CreateResetPasswordTokenRequest")
	proto.RegisterType((*RenewableCertsRequest)(nil), "proto.RenewableCertsRequest")
	proto.RegisterType((*PingRequest)(nil), "proto.PingRequest")
	proto.RegisterType((*PingResponse)(nil), "proto.PingResponse")
	proto.RegisterType((*Features)(nil), "proto.Features")
	proto.RegisterMapType((map[string]*EntitlementInfo)(nil), "proto.Features.EntitlementsEntry")
	proto.RegisterType((*EntitlementInfo)(nil), "proto.EntitlementInfo")
	proto.RegisterType((*DeviceTrustFeature)(nil), "proto.DeviceTrustFeature")
	proto.RegisterType((*AccessRequestsFeature)(nil), "proto.AccessRequestsFeature")
	proto.RegisterType((*AccessListFeature)(nil), "proto.AccessListFeature")
	proto.RegisterType((*AccessMonitoringFeature)(nil), "proto.AccessMonitoringFeature")
	proto.RegisterType((*PolicyFeature)(nil), "proto.PolicyFeature")
	proto.RegisterType((*DeleteUserRequest)(nil), "proto.DeleteUserRequest")
	proto.RegisterType((*Semaphores)(nil), "proto.Semaphores")
	proto.RegisterType((*AuditStreamRequest)(nil), "proto.AuditStreamRequest")
	proto.RegisterType((*AuditStreamStatus)(nil), "proto.AuditStreamStatus")
	proto.RegisterType((*CreateStream)(nil), "proto.CreateStream")
	proto.RegisterType((*ResumeStream)(nil), "proto.ResumeStream")
	proto.RegisterType((*CompleteStream)(nil), "proto.CompleteStream")
	proto.RegisterType((*FlushAndCloseStream)(nil), "proto.FlushAndCloseStream")
	proto.RegisterType((*UpsertApplicationServerRequest)(nil), "proto.UpsertApplicationServerRequest")
	proto.RegisterType((*DeleteApplicationServerRequest)(nil), "proto.DeleteApplicationServerRequest")
	proto.RegisterType((*DeleteAllApplicationServersRequest)(nil), "proto.DeleteAllApplicationServersRequest")
	proto.RegisterType((*GenerateAppTokenRequest)(nil), "proto.GenerateAppTokenRequest")
	proto.RegisterMapType((map[string]*wrappers.StringValues)(nil), "proto.GenerateAppTokenRequest.TraitsEntry")
	proto.RegisterType((*GenerateAppTokenResponse)(nil), "proto.GenerateAppTokenResponse")
	proto.RegisterType((*GetAppSessionRequest)(nil), "proto.GetAppSessionRequest")
	proto.RegisterType((*GetAppSessionResponse)(nil), "proto.GetAppSessionResponse")
	proto.RegisterType((*ListAppSessionsRequest)(nil), "proto.ListAppSessionsRequest")
	proto.RegisterType((*ListAppSessionsResponse)(nil), "proto.ListAppSessionsResponse")
	proto.RegisterType((*GetSnowflakeSessionsResponse)(nil), "proto.GetSnowflakeSessionsResponse")
	proto.RegisterType((*ListSAMLIdPSessionsRequest)(nil), "proto.ListSAMLIdPSessionsRequest")
	proto.RegisterType((*ListSAMLIdPSessionsResponse)(nil), "proto.ListSAMLIdPSessionsResponse")
	proto.RegisterType((*CreateAppSessionRequest)(nil), "proto.CreateAppSessionRequest")
	proto.RegisterType((*CreateAppSessionResponse)(nil), "proto.CreateAppSessionResponse")
	proto.RegisterType((*CreateSnowflakeSessionRequest)(nil), "proto.CreateSnowflakeSessionRequest")
	proto.RegisterType((*CreateSnowflakeSessionResponse)(nil), "proto.CreateSnowflakeSessionResponse")
	proto.RegisterType((*CreateSAMLIdPSessionRequest)(nil), "proto.CreateSAMLIdPSessionRequest")
	proto.RegisterType((*CreateSAMLIdPSessionResponse)(nil), "proto.CreateSAMLIdPSessionResponse")
	proto.RegisterType((*GetSnowflakeSessionRequest)(nil), "proto.GetSnowflakeSessionRequest")
	proto.RegisterType((*GetSnowflakeSessionResponse)(nil), "proto.GetSnowflakeSessionResponse")
	proto.RegisterType((*GetSAMLIdPSessionRequest)(nil), "proto.GetSAMLIdPSessionRequest")
	proto.RegisterType((*GetSAMLIdPSessionResponse)(nil), "proto.GetSAMLIdPSessionResponse")
	proto.RegisterType((*DeleteAppSessionRequest)(nil), "proto.DeleteAppSessionRequest")
	proto.RegisterType((*DeleteSnowflakeSessionRequest)(nil), "proto.DeleteSnowflakeSessionRequest")
	proto.RegisterType((*DeleteSAMLIdPSessionRequest)(nil), "proto.DeleteSAMLIdPSessionRequest")
	proto.RegisterType((*DeleteUserAppSessionsRequest)(nil), "proto.DeleteUserAppSessionsRequest")
	proto.RegisterType((*DeleteUserSAMLIdPSessionsRequest)(nil), "proto.DeleteUserSAMLIdPSessionsRequest")
	proto.RegisterType((*GetWebSessionResponse)(nil), "proto.GetWebSessionResponse")
	proto.RegisterType((*GetWebSessionsResponse)(nil), "proto.GetWebSessionsResponse")
	proto.RegisterType((*GetWebTokenResponse)(nil), "proto.GetWebTokenResponse")
	proto.RegisterType((*GetWebTokensResponse)(nil), "proto.GetWebTokensResponse")
	proto.RegisterType((*UpsertKubernetesServerRequest)(nil), "proto.UpsertKubernetesServerRequest")
	proto.RegisterType((*DeleteKubernetesServerRequest)(nil), "proto.DeleteKubernetesServerRequest")
	proto.RegisterType((*DeleteAllKubernetesServersRequest)(nil), "proto.DeleteAllKubernetesServersRequest")
	proto.RegisterType((*UpsertDatabaseServerRequest)(nil), "proto.UpsertDatabaseServerRequest")
	proto.RegisterType((*DeleteDatabaseServerRequest)(nil), "proto.DeleteDatabaseServerRequest")
	proto.RegisterType((*DeleteAllDatabaseServersRequest)(nil), "proto.DeleteAllDatabaseServersRequest")
	proto.RegisterType((*DatabaseServiceV1List)(nil), "proto.DatabaseServiceV1List")
	proto.RegisterType((*UpsertDatabaseServiceRequest)(nil), "proto.UpsertDatabaseServiceRequest")
	proto.RegisterType((*DeleteAllDatabaseServicesRequest)(nil), "proto.DeleteAllDatabaseServicesRequest")
	proto.RegisterType((*DatabaseCSRRequest)(nil), "proto.DatabaseCSRRequest")
	proto.RegisterType((*DatabaseCSRResponse)(nil), "proto.DatabaseCSRResponse")
	proto.RegisterType((*DatabaseCertRequest)(nil), "proto.DatabaseCertRequest")
	proto.RegisterType((*DatabaseCertResponse)(nil), "proto.DatabaseCertResponse")
	proto.RegisterType((*SnowflakeJWTRequest)(nil), "proto.SnowflakeJWTRequest")
	proto.RegisterType((*SnowflakeJWTResponse)(nil), "proto.SnowflakeJWTResponse")
	proto.RegisterType((*GetRoleRequest)(nil), "proto.GetRoleRequest")
	proto.RegisterType((*GetRolesResponse)(nil), "proto.GetRolesResponse")
	proto.RegisterType((*ListRolesRequest)(nil), "proto.ListRolesRequest")
	proto.RegisterType((*ListRolesResponse)(nil), "proto.ListRolesResponse")
	proto.RegisterType((*CreateRoleRequest)(nil), "proto.CreateRoleRequest")
	proto.RegisterType((*UpdateRoleRequest)(nil), "proto.UpdateRoleRequest")
	proto.RegisterType((*UpsertRoleRequest)(nil), "proto.UpsertRoleRequest")
	proto.RegisterType((*DeleteRoleRequest)(nil), "proto.DeleteRoleRequest")
	proto.RegisterType((*MFAAuthenticateChallenge)(nil), "proto.MFAAuthenticateChallenge")
	proto.RegisterType((*MFAAuthenticateResponse)(nil), "proto.MFAAuthenticateResponse")
	proto.RegisterType((*TOTPChallenge)(nil), "proto.TOTPChallenge")
	proto.RegisterType((*TOTPResponse)(nil), "proto.TOTPResponse")
	proto.RegisterType((*MFARegisterChallenge)(nil), "proto.MFARegisterChallenge")
	proto.RegisterType((*MFARegisterResponse)(nil), "proto.MFARegisterResponse")
	proto.RegisterType((*TOTPRegisterChallenge)(nil), "proto.TOTPRegisterChallenge")
	proto.RegisterType((*TOTPRegisterResponse)(nil), "proto.TOTPRegisterResponse")
	proto.RegisterType((*AddMFADeviceRequest)(nil), "proto.AddMFADeviceRequest")
	proto.RegisterType((*AddMFADeviceResponse)(nil), "proto.AddMFADeviceResponse")
	proto.RegisterType((*DeleteMFADeviceRequest)(nil), "proto.DeleteMFADeviceRequest")
	proto.RegisterType((*DeleteMFADeviceResponse)(nil), "proto.DeleteMFADeviceResponse")
	proto.RegisterType((*DeleteMFADeviceSyncRequest)(nil), "proto.DeleteMFADeviceSyncRequest")
	proto.RegisterType((*AddMFADeviceSyncRequest)(nil), "proto.AddMFADeviceSyncRequest")
	proto.RegisterType((*AddMFADeviceSyncResponse)(nil), "proto.AddMFADeviceSyncResponse")
	proto.RegisterType((*GetMFADevicesRequest)(nil), "proto.GetMFADevicesRequest")
	proto.RegisterType((*GetMFADevicesResponse)(nil), "proto.GetMFADevicesResponse")
	proto.RegisterType((*UserSingleUseCertsRequest)(nil), "proto.UserSingleUseCertsRequest")
	proto.RegisterType((*UserSingleUseCertsResponse)(nil), "proto.UserSingleUseCertsResponse")
	proto.RegisterType((*IsMFARequiredRequest)(nil), "proto.IsMFARequiredRequest")
	proto.RegisterType((*StreamSessionEventsRequest)(nil), "proto.StreamSessionEventsRequest")
	proto.RegisterType((*NodeLogin)(nil), "proto.NodeLogin")
	proto.RegisterType((*AdminAction)(nil), "proto.AdminAction")
	proto.RegisterType((*IsMFARequiredResponse)(nil), "proto.IsMFARequiredResponse")
	proto.RegisterType((*GetEventsRequest)(nil), "proto.GetEventsRequest")
	proto.RegisterType((*GetSessionEventsRequest)(nil), "proto.GetSessionEventsRequest")
	proto.RegisterType((*Events)(nil), "proto.Events")
	proto.RegisterType((*GetLocksRequest)(nil), "proto.GetLocksRequest")
	proto.RegisterType((*GetLocksResponse)(nil), "proto.GetLocksResponse")
	proto.RegisterType((*GetLockRequest)(nil), "proto.GetLockRequest")
	proto.RegisterType((*DeleteLockRequest)(nil), "proto.DeleteLockRequest")
	proto.RegisterType((*ReplaceRemoteLocksRequest)(nil), "proto.ReplaceRemoteLocksRequest")
	proto.RegisterType((*GetWindowsDesktopServicesResponse)(nil), "proto.GetWindowsDesktopServicesResponse")
	proto.RegisterType((*GetWindowsDesktopServiceRequest)(nil), "proto.GetWindowsDesktopServiceRequest")
	proto.RegisterType((*GetWindowsDesktopServiceResponse)(nil), "proto.GetWindowsDesktopServiceResponse")
	proto.RegisterType((*DeleteWindowsDesktopServiceRequest)(nil), "proto.DeleteWindowsDesktopServiceRequest")
	proto.RegisterType((*GetWindowsDesktopsResponse)(nil), "proto.GetWindowsDesktopsResponse")
	proto.RegisterType((*DeleteWindowsDesktopRequest)(nil), "proto.DeleteWindowsDesktopRequest")
	proto.RegisterType((*WindowsDesktopCertRequest)(nil), "proto.WindowsDesktopCertRequest")
	proto.RegisterType((*WindowsDesktopCertResponse)(nil), "proto.WindowsDesktopCertResponse")
	proto.RegisterType((*DesktopBootstrapScriptResponse)(nil), "proto.DesktopBootstrapScriptResponse")
	proto.RegisterType((*ListSAMLIdPServiceProvidersRequest)(nil), "proto.ListSAMLIdPServiceProvidersRequest")
	proto.RegisterType((*ListSAMLIdPServiceProvidersResponse)(nil), "proto.ListSAMLIdPServiceProvidersResponse")
	proto.RegisterType((*GetSAMLIdPServiceProviderRequest)(nil), "proto.GetSAMLIdPServiceProviderRequest")
	proto.RegisterType((*DeleteSAMLIdPServiceProviderRequest)(nil), "proto.DeleteSAMLIdPServiceProviderRequest")
	proto.RegisterType((*ListUserGroupsRequest)(nil), "proto.ListUserGroupsRequest")
	proto.RegisterType((*ListUserGroupsResponse)(nil), "proto.ListUserGroupsResponse")
	proto.RegisterType((*GetUserGroupRequest)(nil), "proto.GetUserGroupRequest")
	proto.RegisterType((*DeleteUserGroupRequest)(nil), "proto.DeleteUserGroupRequest")
	proto.RegisterType((*CertAuthorityRequest)(nil), "proto.CertAuthorityRequest")
	proto.RegisterType((*CRL)(nil), "proto.CRL")
	proto.RegisterType((*ChangeUserAuthenticationRequest)(nil), "proto.ChangeUserAuthenticationRequest")
	proto.RegisterType((*ChangeUserAuthenticationResponse)(nil), "proto.ChangeUserAuthenticationResponse")
	proto.RegisterType((*StartAccountRecoveryRequest)(nil), "proto.StartAccountRecoveryRequest")
	proto.RegisterType((*VerifyAccountRecoveryRequest)(nil), "proto.VerifyAccountRecoveryRequest")
	proto.RegisterType((*CompleteAccountRecoveryRequest)(nil), "proto.CompleteAccountRecoveryRequest")
	proto.RegisterType((*RecoveryCodes)(nil), "proto.RecoveryCodes")
	proto.RegisterType((*CreateAccountRecoveryCodesRequest)(nil), "proto.CreateAccountRecoveryCodesRequest")
	proto.RegisterType((*GetAccountRecoveryTokenRequest)(nil), "proto.GetAccountRecoveryTokenRequest")
	proto.RegisterType((*GetAccountRecoveryCodesRequest)(nil), "proto.GetAccountRecoveryCodesRequest")
	proto.RegisterType((*UserCredentials)(nil), "proto.UserCredentials")
	proto.RegisterType((*ContextUser)(nil), "proto.ContextUser")
	proto.RegisterType((*Passwordless)(nil), "proto.Passwordless")
	proto.RegisterType((*CreateAuthenticateChallengeRequest)(nil), "proto.CreateAuthenticateChallengeRequest")
	proto.RegisterType((*CreatePrivilegeTokenRequest)(nil), "proto.CreatePrivilegeTokenRequest")
	proto.RegisterType((*CreateRegisterChallengeRequest)(nil), "proto.CreateRegisterChallengeRequest")
	proto.RegisterType((*PaginatedResource)(nil), "proto.PaginatedResource")
	proto.RegisterType((*ListUnifiedResourcesRequest)(nil), "proto.ListUnifiedResourcesRequest")
	proto.RegisterMapType((map[string]string)(nil), "proto.ListUnifiedResourcesRequest.LabelsEntry")
	proto.RegisterType((*ListUnifiedResourcesResponse)(nil), "proto.ListUnifiedResourcesResponse")
	proto.RegisterType((*ListResourcesRequest)(nil), "proto.ListResourcesRequest")
	proto.RegisterMapType((map[string]string)(nil), "proto.ListResourcesRequest.LabelsEntry")
	proto.RegisterType((*GetSSHTargetsRequest)(nil), "proto.GetSSHTargetsRequest")
	proto.RegisterType((*GetSSHTargetsResponse)(nil), "proto.GetSSHTargetsResponse")
	proto.RegisterType((*ListResourcesResponse)(nil), "proto.ListResourcesResponse")
	proto.RegisterType((*CreateSessionTrackerRequest)(nil), "proto.CreateSessionTrackerRequest")
	proto.RegisterType((*GetSessionTrackerRequest)(nil), "proto.GetSessionTrackerRequest")
	proto.RegisterType((*RemoveSessionTrackerRequest)(nil), "proto.RemoveSessionTrackerRequest")
	proto.RegisterType((*SessionTrackerUpdateState)(nil), "proto.SessionTrackerUpdateState")
	proto.RegisterType((*SessionTrackerAddParticipant)(nil), "proto.SessionTrackerAddParticipant")
	proto.RegisterType((*SessionTrackerRemoveParticipant)(nil), "proto.SessionTrackerRemoveParticipant")
	proto.RegisterType((*SessionTrackerUpdateExpiry)(nil), "proto.SessionTrackerUpdateExpiry")
	proto.RegisterType((*UpdateSessionTrackerRequest)(nil), "proto.UpdateSessionTrackerRequest")
	proto.RegisterType((*PresenceMFAChallengeRequest)(nil), "proto.PresenceMFAChallengeRequest")
	proto.RegisterType((*PresenceMFAChallengeSend)(nil), "proto.PresenceMFAChallengeSend")
	proto.RegisterType((*GetDomainNameResponse)(nil), "proto.GetDomainNameResponse")
	proto.RegisterType((*GetClusterCACertResponse)(nil), "proto.GetClusterCACertResponse")
	proto.RegisterType((*GetLicenseResponse)(nil), "proto.GetLicenseResponse")
	proto.RegisterType((*ListReleasesResponse)(nil), "proto.ListReleasesResponse")
	proto.RegisterType((*GetOIDCAuthRequestRequest)(nil), "proto.GetOIDCAuthRequestRequest")
	proto.RegisterType((*GetSAMLAuthRequestRequest)(nil), "proto.GetSAMLAuthRequestRequest")
	proto.RegisterType((*GetGithubAuthRequestRequest)(nil), "proto.GetGithubAuthRequestRequest")
	proto.RegisterType((*CreateOIDCConnectorRequest)(nil), "proto.CreateOIDCConnectorRequest")
	proto.RegisterType((*UpdateOIDCConnectorRequest)(nil), "proto.UpdateOIDCConnectorRequest")
	proto.RegisterType((*UpsertOIDCConnectorRequest)(nil), "proto.UpsertOIDCConnectorRequest")
	proto.RegisterType((*CreateSAMLConnectorRequest)(nil), "proto.CreateSAMLConnectorRequest")
	proto.RegisterType((*UpdateSAMLConnectorRequest)(nil), "proto.UpdateSAMLConnectorRequest")
	proto.RegisterType((*UpsertSAMLConnectorRequest)(nil), "proto.UpsertSAMLConnectorRequest")
	proto.RegisterType((*CreateGithubConnectorRequest)(nil), "proto.CreateGithubConnectorRequest")
	proto.RegisterType((*UpdateGithubConnectorRequest)(nil), "proto.UpdateGithubConnectorRequest")
	proto.RegisterType((*UpsertGithubConnectorRequest)(nil), "proto.UpsertGithubConnectorRequest")
	proto.RegisterType((*GetSSODiagnosticInfoRequest)(nil), "proto.GetSSODiagnosticInfoRequest")
	proto.RegisterType((*SystemRoleAssertion)(nil), "proto.SystemRoleAssertion")
	proto.RegisterType((*SystemRoleAssertionSet)(nil), "proto.SystemRoleAssertionSet")
	proto.RegisterType((*UpstreamInventoryOneOf)(nil), "proto.UpstreamInventoryOneOf")
	proto.RegisterType((*DownstreamInventoryOneOf)(nil), "proto.DownstreamInventoryOneOf")
	proto.RegisterType((*DownstreamInventoryPing)(nil), "proto.DownstreamInventoryPing")
	proto.RegisterType((*UpstreamInventoryPong)(nil), "proto.UpstreamInventoryPong")
	proto.RegisterType((*UpstreamInventoryHello)(nil), "proto.UpstreamInventoryHello")
	proto.RegisterType((*UpstreamInventoryAgentMetadata)(nil), "proto.UpstreamInventoryAgentMetadata")
	proto.RegisterType((*DownstreamInventoryHello)(nil), "proto.DownstreamInventoryHello")
	proto.RegisterType((*DownstreamInventoryHello_SupportedCapabilities)(nil), "proto.DownstreamInventoryHello.SupportedCapabilities")
	proto.RegisterType((*InventoryUpdateLabelsRequest)(nil), "proto.InventoryUpdateLabelsRequest")
	proto.RegisterMapType((map[string]string)(nil), "proto.InventoryUpdateLabelsRequest.LabelsEntry")
	proto.RegisterType((*DownstreamInventoryUpdateLabels)(nil), "proto.DownstreamInventoryUpdateLabels")
	proto.RegisterMapType((map[string]string)(nil), "proto.DownstreamInventoryUpdateLabels.LabelsEntry")
	proto.RegisterType((*InventoryHeartbeat)(nil), "proto.InventoryHeartbeat")
	proto.RegisterType((*UpstreamInventoryGoodbye)(nil), "proto.UpstreamInventoryGoodbye")
	proto.RegisterType((*InventoryStatusRequest)(nil), "proto.InventoryStatusRequest")
	proto.RegisterType((*InventoryStatusSummary)(nil), "proto.InventoryStatusSummary")
	proto.RegisterMapType((map[string]uint32)(nil), "proto.InventoryStatusSummary.ServiceCountsEntry")
	proto.RegisterMapType((map[string]uint32)(nil), "proto.InventoryStatusSummary.UpgraderCountsEntry")
	proto.RegisterMapType((map[string]uint32)(nil), "proto.InventoryStatusSummary.VersionCountsEntry")
	proto.RegisterType((*InventoryConnectedServiceCountsRequest)(nil), "proto.InventoryConnectedServiceCountsRequest")
	proto.RegisterType((*InventoryConnectedServiceCounts)(nil), "proto.InventoryConnectedServiceCounts")
	proto.RegisterMapType((map[github_com_gravitational_teleport_api_types.SystemRole]uint64)(nil), "proto.InventoryConnectedServiceCounts.ServiceCountsEntry")
	proto.RegisterType((*InventoryPingRequest)(nil), "proto.InventoryPingRequest")
	proto.RegisterType((*InventoryPingResponse)(nil), "proto.InventoryPingResponse")
	proto.RegisterType((*GetClusterAlertsResponse)(nil), "proto.GetClusterAlertsResponse")
	proto.RegisterType((*GetAlertAcksRequest)(nil), "proto.GetAlertAcksRequest")
	proto.RegisterType((*GetAlertAcksResponse)(nil), "proto.GetAlertAcksResponse")
	proto.RegisterType((*ClearAlertAcksRequest)(nil), "proto.ClearAlertAcksRequest")
	proto.RegisterType((*UpsertClusterAlertRequest)(nil), "proto.UpsertClusterAlertRequest")
	proto.RegisterType((*GetConnectionDiagnosticRequest)(nil), "proto.GetConnectionDiagnosticRequest")
	proto.RegisterType((*AppendDiagnosticTraceRequest)(nil), "proto.AppendDiagnosticTraceRequest")
	proto.RegisterType((*SubmitUsageEventRequest)(nil), "proto.SubmitUsageEventRequest")
	proto.RegisterType((*GetLicenseRequest)(nil), "proto.GetLicenseRequest")
	proto.RegisterType((*ListReleasesRequest)(nil), "proto.ListReleasesRequest")
	proto.RegisterType((*CreateTokenV2Request)(nil), "proto.CreateTokenV2Request")
	proto.RegisterType((*UpsertTokenV2Request)(nil), "proto.UpsertTokenV2Request")
	proto.RegisterType((*GetHeadlessAuthenticationRequest)(nil), "proto.GetHeadlessAuthenticationRequest")
	proto.RegisterType((*UpdateHeadlessAuthenticationStateRequest)(nil), "proto.UpdateHeadlessAuthenticationStateRequest")
	proto.RegisterType((*ExportUpgradeWindowsRequest)(nil), "proto.ExportUpgradeWindowsRequest")
	proto.RegisterType((*ExportUpgradeWindowsResponse)(nil), "proto.ExportUpgradeWindowsResponse")
	proto.RegisterType((*ListAccessRequestsRequest)(nil), "proto.ListAccessRequestsRequest")
	proto.RegisterType((*ListAccessRequestsResponse)(nil), "proto.ListAccessRequestsResponse")
	proto.RegisterType((*AccessRequestAllowedPromotionRequest)(nil), "proto.AccessRequestAllowedPromotionRequest")
	proto.RegisterType((*AccessRequestAllowedPromotionResponse)(nil), "proto.AccessRequestAllowedPromotionResponse")
}

func init() {
	proto.RegisterFile("teleport/legacy/client/proto/authservice.proto", fileDescriptor_0ffcffcda38ae159)
}

var fileDescriptor_0ffcffcda38ae159 = []byte{
	// 14867 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0xbd, 0x5b, 0x6c, 0x5c, 0x4b,
	0x76, 0x18, 0xca, 0x6e, 0xbe, 0x17, 0x1f, 0x6a, 0x15, 0x49, 0xb1, 0x45, 0x3d, 0x5a, 0xda, 0x3a,
	0x0f, 0x1d, 0xcd, 0x19, 0x3d, 0x78, 0x1e, 0x73, 0x5e, 0x73, 0xce, 0x69, 0x3e, 0x24, 0x52, 0xe2,
	0xeb, 0xec, 0x26, 0xa9, 0xf3, 0xf2, 0xf4, 0x6c, 0x76, 0x97, 0xc8, 0x6d, 0x35, 0xf7, 0xee, 0xd9,
	0x7b, 0xb7, 0x74, 0x34, 0xbe, 0xf6, 0x85, 0xc7, 0x09, 0xe2, 0x9f, 0x24, 0x36, 0x10, 0x07, 0x0e,
	0xfc, 0xe1, 0x04, 0x48, 0x80, 0x20, 0x40, 0x02, 0xff, 0x38, 0xfe, 0x49, 0x3e, 0x82, 0x7c, 0x64,
	0x62, 0xc0, 0x48, 0x02, 0xdb, 0x3f, 0xf9, 0xa0, 0x93, 0x01, 0xf2, 0x43, 0x24, 0x1f, 0x46, 0x90,
	0x00, 0x19, 0xc0, 0x40, 0x50, 0xab, 0x1e, 0xbb, 0x6a, 0x3f, 0xba, 0x49, 0x49, 0x67, 0x9c, 0x1f,
	0x89, 0xbd, 0x6a, 0xad, 0x55, 0x55, 0xab, 0x6a, 0x57, 0xad, 0x5a, 0xb5, 0x6a, 0x2d, 0xb8, 0x19,
	0xd1, 0x16, 0x6d, 0xfb, 0x41, 0x74, 0xab, 0x45, 0xf7, 0x9d, 0xc6, 0xb3, 0x5b, 0x8d, 0x96, 0x4b,
	0xbd, 0xe8, 0x56, 0x3b, 0xf0, 0x23, 0xff, 0x96, 0xd3, 0x89, 0x0e, 0x42, 0x1a, 0x3c, 0x71, 0x1b,
	0xf4, 0x26, 0x42, 0xc8, 0x20, 0xfe, 0x37, 0x37, 0xbd, 0xef, 0xef, 0xfb, 0x1c, 0x87, 0xfd, 0xc5,
	0x0b, 0xe7, 0x2e, 0xec, 0xfb, 0xfe, 0x7e, 0x8b, 0x72, 0xe2, 0xbd, 0xce, 0xa3, 0x5b, 0xf4, 0xb0,
	0x1d, 0x3d, 0x13, 0x85, 0x95, 0x64, 0x61, 0xe4, 0x1e, 0xd2, 0x30, 0x72, 0x0e, 0xdb, 0x02, 0xe1,
	0x0d, 0xd5, 0x14, 0x27, 0x8a, 0x58, 0x49, 0xe4, 0xfa, 0xde, 0xad, 0x27, 0x77, 0xf4, 0x9f, 0x02,
	0xf5, 0x7a, 0xd7, 0x56, 0x37, 0x68, 0x10, 0x85, 0x27, 0xc2, 0xa4, 0x4f, 0xa8, 0x17, 0xa5, 0xaa,
	0x17, 0x98, 0xd1, 0xb3, 0x36, 0x0d, 0x39, 0x8a, 0xfc, 0x4f, 0xa0, 0x5e, 0xcd, 0x46, 0xc5, 0x7f,
	0x05, 0xca, 0x77, 0xb3, 0x51, 0x9e, 0xd2, 0x3d, 0x26, 0x53, 0x4f, 0xfd, 0xd1, 0x03, 0x3d, 0x70,
	0xda, 0x6d, 0x1a, 0xc4, 0x7f, 0x08, 0xf4, 0xf3, 0x0a, 0xfd, 0xf0, 0x91, 0xc3, 0x44, 0x74, 0xf8,
	0xc8, 0x49, 0x75, 0xa3, 0x13, 0x3a, 0xfb, 0x54, 0x34, 0xff, 0xc9, 0x1d, 0xfd, 0x27, 0x47, 0xb5,
	0x7e, 0xbf, 0x00, 0x83, 0x0f, 0x9d, 0xa8, 0x71, 0x40, 0x3e, 0x81, 0xc1, 0x07, 0xae, 0xd7, 0x0c,
	0xcb, 0x85, 0x2b, 0xfd, 0xd7, 0xc7, 0xe6, 0x4b, 0x37, 0x79, 0x57, 0xb0, 0x90, 0x15, 0x2c, 0xcc,
	0xfe, 0xf4, 0xa8, 0xd2, 0x77, 0x7c, 0x54, 0x39, 0xf3, 0x98, 0xa1, 0xbd, 0xe9, 0x1f, 0xba, 0x11,
	0x8e, 0xad, 0xcd, 0xe9, 0xc8, 0x0e, 0x4c, 0x55, 0x5b, 0x2d, 0xff, 0xe9, 0x96, 0x13, 0x44, 0xae,
	0xd3, 0xaa, 0x75, 0x1a, 0x0d, 0x1a, 0x86, 0xe5, 0xe2, 0x95, 0xc2, 0xf5, 0x91, 0x85, 0x6b, 0xc7,
	0x47, 0x95, 0x8a, 0xc3, 0x8a, 0xeb, 0x6d, 0x5e, 0x5e, 0x0f, 0x39, 0x82, 0xc6, 0x28, 0x8b, 0xde,
	0xfa, 0xe3, 0x21, 0x28, 0xad, 0xf8, 0x61, 0xb4, 0xc8, 0x46, 0xd4, 0xa6, 0x3f, 0xea, 0xd0, 0x30,
	0x22, 0xd7, 0x60, 0x88, 0xc1, 0x56, 0x97, 0xca, 0x85, 0x2b, 0x85, 0xeb, 0xa3, 0x0b, 0x63, 0xc7,
	0x47, 0x95, 0xe1, 0x03, 0x3f, 0x8c, 0xea, 0x6e, 0xd3, 0x16, 0x45, 0xe4, 0x0d, 0x18, 0xd9, 0xf0,
	0x9b, 0x74, 0xc3, 0x39, 0xa4, 0xd8, 0x8a, 0xd1, 0x85, 0x89, 0xe3, 0xa3, 0xca, 0xa8, 0xe7, 0x37,
	0x69, 0xdd, 0x73, 0x0e, 0xa9, 0xad, 0x8a, 0xc9, 0x2e, 0x0c, 0xd8, 0x7e, 0x8b, 0x96, 0xfb, 0x11,
	0x6d, 0xe1, 0xf8, 0xa8, 0x32, 0x10, 0xf8, 0x2d, 0xfa, 0xf3, 0xa3, 0xca, 0xbb, 0xfb, 0x6e, 0x74,
	0xd0, 0xd9, 0xbb, 0xd9, 0xf0, 0x0f, 0x6f, 0xed, 0x07, 0xce, 0x13, 0x97, 0x4f, 0x42, 0xa7, 0x75,
	0x2b, 0x9e, 0xaa, 0x6d, 0x57, 0x8c, 0x7b, 0xed, 0x59, 0x18, 0xd1, 0x43, 0xc6, 0xc9, 0x46, 0x7e,
	0xe4, 0x21, 0x4c, 0x57, 0x9b, 0x4d, 0x97, 0x53, 0x6c, 0x05, 0xae, 0xd7, 0x70, 0xdb, 0x4e, 0x2b,
	0x2c, 0x0f, 0x5c, 0xe9, 0xbf, 0x3e, 0x2a, 0x84, 0xa2, 0xca, 0xeb, 0x6d, 0x85, 0xa0, 0x09, 0x25,
	0x93, 0x01, 0x79, 0x0b, 0x46, 0x96, 0x36, 0x6a, 0xac, 0xed, 0x61, 0x79, 0x10, 0x99, 0xcd, 0x1e,
	0x1f, 0x55, 0xa6, 0x9a, 0x5e, 0x88, 0x5d, 0xd3, 0x19, 0x28, 0x44, 0xf2, 0x2e, 0x8c, 0x6f, 0x75,
	0xf6, 0x5a, 0x6e, 0x63, 0x7b, 0xad, 0xf6, 0x80, 0x3e, 0x2b, 0x0f, 0x5d, 0x29, 0x5c, 0x1f, 0x5f,
	0x20, 0xc7, 0x47, 0x95, 0xc9, 0x36, 0xc2, 0xeb, 0x51, 0x2b, 0xac, 0x3f, 0xa6, 0xcf, 0x6c, 0x03,
	0x2f, 0xa6, 0xab, 0xd5, 0x56, 0x18, 0xdd, 0x70, 0x8a, 0x2e, 0x0c, 0x0f, 0x74, 0x3a, 0x8e, 0x47,
	0x6e, 0x01, 0xd8, 0xf4, 0xd0, 0x8f, 0x68, 0xb5, 0xd9, 0x0c, 0xca, 0x23, 0x28, 0xdb, 0x33, 0xc7,
	0x47, 0x95, 0xb1, 0x00, 0xa1, 0x75, 0xa7, 0xd9, 0x0c, 0x6c, 0x0d, 0x85, 0x2c, 0xc2, 0x88, 0xed,
	0x73, 0x01, 0x97, 0x47, 0xaf, 0x14, 0xae, 0x8f, 0xcd, 0x9f, 0x11, 0xd3, 0x50, 0x82, 0x17, 0xce,
	0x1d, 0x1f, 0x55, 0x48, 0x20, 0x7e, 0xe9, 0xbd, 0x94, 0x18, 0xa4, 0x02, 0xc3, 0x1b, 0xfe, 0xa2,
	0xd3, 0x38, 0xa0, 0x65, 0xc0, 0xb9, 0x37, 0x78, 0x7c, 0x54, 0x29, 0x7c, 0xd7, 0x96, 0x50, 0xf2,
	0x04, 0xc6, 0xe2, 0x81, 0x0a, 0xcb, 0x63, 0x28, 0xbe, 0xed, 0xe3, 0xa3, 0xca, 0xb9, 0x10, 0xc1,
	0x75, 0x36, 0xf4, 0x9a, 0x04, 0x5f, 0x60, 0x16, 0xe8, 0x15, 0x91, 0xaf, 0x61, 0x26, 0xfe, 0x59,
	0x0d, 0x43, 0x1a, 0x30, 0x1e, 0xab, 0x4b, 0xe5, 0x09, 0x94, 0xcc, 0x6b, 0xc7, 0x47, 0x15, 0x4b,
	0x6b, 0x41, 0xdd, 0x91, 0x28, 0x75, 0xb7, 0xa9, 0xf5, 0x34, 0x9b, 0xc9, 0xfd, 0x81, 0x91, 0xf1,
	0xd2, 0x84, 0x7d, 0x69, 0xc7, 0x0b, 0x23, 0x67, 0xaf, 0x45, 0x33, 0x91, 0xac, 0xbf, 0x2a, 0x00,
	0xd9, 0x6c, 0x53, 0xaf, 0x56, 0x5b, 0x61, 0xdf, 0x93, 0xfc, 0x9c, 0xde, 0x84, 0x51, 0x3e, 0x70,
	0x6c, 0x74, 0x8b, 0x38, 0xba, 0x93, 0xc7, 0x47, 0x15, 0x10, 0xa3, 0xcb, 0x46, 0x36, 0x46, 0x20,
	0xaf, 0x42, 0xff, 0xf6, 0xf6, 0x1a, 0x7e, 0x2b, 0xfd, 0x0b, 0x53, 0xc7, 0x47, 0x95, 0xfe, 0x28,
	0x6a, 0xfd, 0xfc, 0xa8, 0x32, 0xb2, 0xd4, 0x09, 0x50, 0x2c, 0x36, 0x2b, 0x27, 0xaf, 0xc2, 0xf0,
	0x62, 0xab, 0x13, 0x46, 0x34, 0x28, 0x0f, 0xc4, 0x1f, 0x69, 0x83, 0x83, 0x6c, 0x59, 0x46, 0xbe,
	0x03, 0x03, 0x3b, 0x21, 0x0d, 0xca, 0x83, 0x38, 0xde, 0x13, 0x62, 0xbc, 0x19, 0x68, 0x77, 0x7e,
	0x61, 0x84, 0x7d, 0x89, 0x9d, 0x90, 0x06, 0x36, 0x22, 0x91, 0x9b, 0x30, 0xc8, 0x07, 0x6d, 0x08,
	0x17, 0xa9, 0x09, 0x35, 0x3b, 0x5a, 0x74, 0xf7, 0xdd, 0x85, 0xd1, 0xe3, 0xa3, 0xca, 0x20, 0x0e,
	0x9e, 0xcd, 0xd1, 0xee, 0x0f, 0x8c, 0x14, 0x4a, 0x45, 0x7b, 0x84, 0xd1, 0xb2, 0xcf, 0xc2, 0xfa,
	0x0e, 0x8c, 0x69, 0xdd, 0x27, 0x17, 0x61, 0x80, 0xfd, 0x8f, 0x8b, 0xc8, 0x38, 0xaf, 0x8c, 0x6d,
	0x1c, 0x36, 0x42, 0xad, 0x7f, 0x38, 0x05, 0x25, 0x46, 0x69, 0xac, 0x3c, 0x37, 0x75, 0x51, 0x71,
	0xba, 0x92, 0x29, 0xaa, 0x72, 0x41, 0x17, 0xd6, 0x75, 0x50, 0xb5, 0x8b, 0x45, 0x68, 0xfc, 0xf8,
	0xa8, 0x32, 0xd2, 0x11, 0xb0, 0xb8, 0x6d, 0xa4, 0x06, 0xc3, 0xcb, 0xdf, 0xb4, 0xdd, 0x80, 0x86,
	0x28, 0xda, 0xb1, 0xf9, 0xb9, 0x9b, 0x7c, 0xbb, 0xbc, 0x29, 0xb7, 0xcb, 0x9b, 0xdb, 0x72, 0xbb,
	0x5c, 0xb8, 0x24, 0x16, 0xe3, 0xb3, 0x94, 0x93, 0xc4, 0xf3, 0xe3, 0xb7, 0xfe, 0xa2, 0x52, 0xb0,
	0x25, 0x27, 0xf2, 0x26, 0x0c, 0xdd, 0xf5, 0x83, 0x43, 0x27, 0x12, 0x63, 0x30, 0x7d, 0x7c, 0x54,
	0x29, 0x3d, 0x42, 0x88, 0x36, 0xa5, 0x04, 0x0e, 0xb9, 0x0b, 0x93, 0xb6, 0xdf, 0x89, 0xe8, 0xb6,
	0x2f, 0x47, 0x6e, 0x10, 0xa9, 0x2e, 0x1f, 0x1f, 0x55, 0xe6, 0x02, 0x56, 0x52, 0x8f, 0xfc, 0xba,
	0x18, 0x42, 0x8d, 0x3e, 0x41, 0x45, 0x96, 0x61, 0xb2, 0x8a, 0xab, 0xb7, 0x90, 0x1a, 0x1f, 0xaf,
	0xd1, 0x85, 0x4b, 0xc7, 0x47, 0x95, 0xf3, 0x0e, 0x96, 0xd4, 0x03, 0x51, 0xa4, 0xb3, 0x31, 0x89,
	0xc8, 0x06, 0x9c, 0x7d, 0xd0, 0xd9, 0xa3, 0x81, 0x47, 0x23, 0x1a, 0xca, 0x16, 0x0d, 0x63, 0x8b,
	0xae, 0x1c, 0x1f, 0x55, 0x2e, 0x3e, 0x56, 0x85, 0x19, 0x6d, 0x4a, 0x93, 0x12, 0x0a, 0x67, 0x44,
	0x43, 0x97, 0x9c, 0xc8, 0xd9, 0x73, 0x42, 0x8a, 0x8b, 0xd2, 0xd8, 0xfc, 0x39, 0x2e, 0xe2, 0x9b,
	0x89, 0xd2, 0x85, 0x6b, 0x42, 0xca, 0x17, 0x54, 0xdf, 0x9b, 0xa2, 0x48, 0xab, 0x28, 0xc9, 0x93,
	0xad, 0xcd, 0x6a, 0xdf, 0x19, 0xc5, 0xd6, 0xe2, 0xda, 0xac, 0xf6, 0x1d, 0x7d, 0xd5, 0x52, 0x3b,
	0xd0, 0x1a, 0x0c, 0xee, 0xb0, 0xdd, 0x19, 0xd7, 0xac, 0xc9, 0xf9, 0xab, 0xa2, 0x45, 0xc9, 0xf9,
	0x77, 0x93, 0xfd, 0x40, 0x44, 0xfc, 0xf2, 0xce, 0xe0, 0x8e, 0xae, 0xef, 0xc5, 0x58, 0x46, 0x3e,
	0x03, 0x10, 0xad, 0xaa, 0xb6, 0xdb, 0xe5, 0x31, 0xec, 0xe4, 0x59, 0xb3, 0x93, 0xd5, 0x76, 0x7b,
	0xe1, 0xb2, 0xe8, 0xdf, 0x39, 0xd5, 0x3f, 0xa7, 0xdd, 0xd6, 0xb8, 0x69, 0x4c, 0xc8, 0x27, 0x30,
	0x8e, 0x4b, 0x9a, 0x1c, 0xd1, 0x71, 0x1c, 0xd1, 0x0b, 0xc7, 0x47, 0x95, 0x59, 0x5c, 0xad, 0x32,
	0xc6, 0xd3, 0x20, 0x20, 0xbf, 0x06, 0x33, 0x82, 0xdd, 0x43, 0xd7, 0x6b, 0xfa, 0x4f, 0xc3, 0x25,
	0x1a, 0x3e, 0x8e, 0xfc, 0x36, 0x2e, 0x7f, 0x63, 0xf3, 0x17, 0xcd, 0xe6, 0x99, 0x38, 0x0b, 0x37,
	0x44, 0x4b, 0x2d, 0xd5, 0xd2, 0xa7, 0x1c, 0xa1, 0xde, 0xe4, 0x18, 0xfa, 0x02, 0x99, 0xc9, 0x82,
	0xac, 0xc2, 0x99, 0x9d, 0x90, 0x1a, 0x7d, 0x98, 0xc4, 0xfd, 0xa1, 0xc2, 0x46, 0xb8, 0x13, 0xd2,
	0x7a, 0x5e, 0x3f, 0x92, 0x74, 0xc4, 0x06, 0xb2, 0x14, 0xf8, 0xed, 0xc4, 0x1c, 0x3f, 0x83, 0x12,
	0xb1, 0x8e, 0x8f, 0x2a, 0x97, 0x9b, 0x81, 0xdf, 0xae, 0xe7, 0x4f, 0xf4, 0x0c, 0x6a, 0xf2, 0x03,
	0x38, 0xb7, 0xe8, 0x7b, 0x1e, 0x6d, 0xb0, 0x15, 0x74, 0xc9, 0x75, 0xf6, 0x3d, 0x3f, 0x8c, 0xdc,
	0xc6, 0xea, 0x52, 0xb9, 0x14, 0x6f, 0x0f, 0x0d, 0x85, 0x51, 0x6f, 0x2a, 0x14, 0x73, 0x7b, 0xc8,
	0xe1, 0x42, 0xbe, 0x82, 0x09, 0x51, 0x17, 0x0d, 0x70, 0x6a, 0x9e, 0xed, 0x3e, 0xd1, 0x14, 0x32,
	0xdf, 0xe8, 0x03, 0xf9, 0x93, 0xab, 0x4e, 0x26, 0x2f, 0xf2, 0x35, 0x8c, 0xad, 0xdf, 0xad, 0xda,
	0x34, 0x6c, 0xfb, 0x5e, 0x48, 0xcb, 0x04, 0x47, 0xf4, 0xb2, 0x60, 0xbd, 0x7e, 0xb7, 0x5a, 0xed,
	0x44, 0x07, 0xd4, 0x8b, 0xdc, 0x86, 0x13, 0x51, 0x89, 0xb5, 0x30, 0xc7, 0x66, 0xde, 0xe1, 0x23,
	0xa7, 0x1e, 0x08, 0x88, 0xd6, 0x0b, 0x9d, 0x1d, 0x99, 0x83, 0x91, 0x5a, 0x6d, 0x65, 0xcd, 0xdf,
	0x77, 0xbd, 0xf2, 0x14, 0x13, 0x86, 0xad, 0x7e, 0x93, 0x47, 0x30, 0xa3, 0x9d, 0x0d, 0xea, 0xec,
	0x7f, 0x7a, 0x48, 0xbd, 0xa8, 0x3c, 0x8d, 0x6d, 0xf8, 0xae, 0x3a, 0xdc, 0xdc, 0xd4, 0x8f, 0x10,
	0x4f, 0xee, 0xdc, 0xac, 0xc6, 0x3f, 0x6b, 0x92, 0x68, 0xa1, 0x58, 0x2e, 0xd8, 0xd3, 0x4e, 0x46,
	0x09, 0xd9, 0x86, 0xe1, 0xad, 0x4e, 0xd0, 0xf6, 0x43, 0x5a, 0x9e, 0x41, 0xc1, 0x5d, 0xeb, 0xf6,
	0x85, 0x0a, 0xd4, 0x85, 0x19, 0xb6, 0x44, 0xb7, 0xf9, 0x0f, 0xad, 0x77, 0x92, 0x15, 0xf9, 0x14,
	0xc6, 0x6b, 0xb5, 0x95, 0x78, 0x43, 0x39, 0x87, 0x1b, 0xca, 0xc5, 0xe3, 0xa3, 0x4a, 0x99, 0xa9,
	0x54, 0xf1, 0xa6, 0xa2, 0x7f, 0x55, 0x3a, 0x05, 0xe3, 0xb0, 0xbd, 0x56, 0x8b, 0x39, 0xcc, 0xc6,
	0x1c, 0x98, 0x32, 0x97, 0xcd, 0x41, 0xa7, 0x20, 0xff, 0xbc, 0x00, 0x57, 0x74, 0x96, 0x59, 0x82,
	0x29, 0x9f, 0x7f, 0x1e, 0x69, 0xce, 0x1f, 0x1f, 0x55, 0x6e, 0x9a, 0xfd, 0xa8, 0x67, 0x0e, 0x96,
	0xd6, 0xb6, 0x9e, 0x4d, 0xc1, 0xf6, 0xea, 0x1d, 0xc8, 0x6c, 0xef, 0xdc, 0x73, 0xb7, 0xd7, 0x94,
	0x5a, 0xef, 0xf6, 0xf6, 0x6a, 0x8a, 0xf5, 0x39, 0x8c, 0xaa, 0x45, 0x9b, 0x0c, 0x43, 0x7f, 0xb5,
	0xd5, 0x2a, 0xf5, 0xb1, 0x3f, 0x6a, 0xb5, 0x95, 0x52, 0x81, 0x4c, 0x02, 0xc4, 0x3b, 0x55, 0xa9,
	0x48, 0xc6, 0x61, 0x44, 0xee, 0x24, 0xa5, 0x7e, 0xc4, 0x6f, 0xb7, 0x4b, 0x03, 0x84, 0xc0, 0xa4,
	0xb9, 0x9e, 0x95, 0x06, 0xad, 0xdf, 0x2e, 0xc0, 0xa8, 0xfa, 0x0e, 0xc9, 0x19, 0x18, 0xdb, 0xd9,
	0xa8, 0x6d, 0x2d, 0x2f, 0xae, 0xde, 0x5d, 0x5d, 0x5e, 0x2a, 0xf5, 0x91, 0x4b, 0x70, 0x7e, 0xbb,
	0xb6, 0x52, 0x5f, 0x5a, 0xa8, 0xaf, 0x6d, 0x2e, 0x56, 0xd7, 0xea, 0x5b, 0xf6, 0xe6, 0xe7, 0x5f,
	0xd4, 0xb7, 0x77, 0x36, 0x36, 0x96, 0xd7, 0x4a, 0x05, 0x52, 0x86, 0x69, 0x56, 0xfc, 0x60, 0x67,
	0x61, 0x59, 0x47, 0x28, 0x15, 0xc9, 0x55, 0xb8, 0x94, 0x55, 0x52, 0x5f, 0x59, 0xae, 0x2e, 0xad,
	0x2d, 0xd7, 0x6a, 0xa5, 0x7e, 0x32, 0x0b, 0x53, 0x0c, 0xa5, 0xba, 0xb5, 0x65, 0xd0, 0x0e, 0x58,
	0x2d, 0x18, 0xd3, 0x3e, 0x00, 0x72, 0x11, 0xca, 0x8b, 0xcb, 0xf6, 0x76, 0x7d, 0x6b, 0xc7, 0xde,
	0xda, 0xac, 0x2d, 0xd7, 0xcd, 0x16, 0x26, 0x4b, 0xd7, 0x36, 0xef, 0xad, 0x6e, 0xd4, 0x19, 0xa8,
	0x56, 0x2a, 0xb0, 0x66, 0x18, 0xa5, 0xb5, 0xd5, 0x8d, 0x7b, 0x6b, 0xcb, 0xf5, 0x9d, 0xda, 0xb2,
	0x40, 0x29, 0x5a, 0x3f, 0x29, 0xa6, 0xb6, 0x74, 0x32, 0x0f, 0x63, 0x35, 0x6e, 0xaf, 0xc0, 0x65,
	0x8e, 0x1f, 0x10, 0x99, 0x8e, 0x36, 0x2e, 0xcc, 0x18, 0x7c, 0x05, 0xd3, 0x91, 0x98, 0x96, 0xb6,
	0xc5, 0xbe, 0xe6, 0x86, 0xdf, 0xd2, 0xb5, 0xb4, 0xb6, 0x80, 0xd9, 0xaa, 0x94, 0xcc, 0x6b, 0xfa,
	0x1c, 0x3f, 0x2d, 0xe2, 0x89, 0x44, 0xea, 0x73, 0xfa, 0xde, 0xae, 0x34, 0xbb, 0xf9, 0x78, 0x48,
	0x85, 0x1a, 0x86, 0x34, 0x19, 0xba, 0x84, 0xc2, 0x23, 0x6f, 0x48, 0x4d, 0x97, 0x9f, 0xee, 0x70,
	0xb3, 0x4f, 0x9c, 0x4b, 0x84, 0x92, 0x6b, 0x75, 0x72, 0x36, 0x56, 0xf2, 0x61, 0x72, 0xce, 0x08,
	0x61, 0x20, 0xb3, 0xc4, 0xfe, 0x69, 0x27, 0x50, 0x49, 0x05, 0x06, 0xf9, 0x8a, 0xcb, 0xe5, 0x81,
	0xba, 0x75, 0x8b, 0x01, 0x6c, 0x0e, 0xb7, 0xfe, 0xb0, 0x5f, 0x57, 0x32, 0x98, 0x2e, 0xad, 0xc9,
	0x1b, 0x75, 0x69, 0x94, 0x33, 0x42, 0x99, 0xda, 0x5c, 0xa3, 0x61, 0xc8, 0xcf, 0x3b, 0x45, 0x35,
	0x24, 0x10, 0x72, 0x60, 0xdd, 0x6d, 0x32, 0xb5, 0x59, 0xa1, 0xb0, 0xa3, 0x23, 0xff, 0xaa, 0xf0,
	0xe8, 0xd8, 0x1f, 0x1f, 0x1d, 0xc5, 0xa7, 0xc9, 0x8f, 0x8e, 0x31, 0x0a, 0x1b, 0x75, 0xa1, 0xe6,
	0x61, 0x2b, 0x06, 0xe2, 0x51, 0x17, 0xaa, 0xa1, 0x18, 0x75, 0x0d, 0x89, 0x7c, 0x00, 0x50, 0x7d,
	0x58, 0xc3, 0x33, 0x92, 0xbd, 0x21, 0x54, 0x5d, 0xdc, 0x94, 0x9c, 0xa7, 0xa1, 0x38, 0x82, 0x05,
	0xfa, 0x19, 0x53, 0xc3, 0x26, 0x0b, 0x30, 0x51, 0xfd, 0x71, 0x27, 0xa0, 0xab, 0x4d, 0xb6, 0xaf,
	0x45, 0xfc, 0x30, 0x3d, 0xca, 0x17, 0x5e, 0x87, 0x15, 0xd4, 0x5d, 0x51, 0xa2, 0x31, 0x30, 0x49,
	0xc8, 0x26, 0x9c, 0xbd, 0xb7, 0xb8, 0x25, 0xe6, 0x61, 0xb5, 0xd1, 0xf0, 0x3b, 0x5e, 0x24, 0xf4,
	0xdb, 0xab, 0xc7, 0x47, 0x95, 0x4b, 0xfb, 0x8d, 0x76, 0x5d, 0xce, 0x59, 0x87, 0x17, 0xeb, 0x0a,
	0x6e, 0x8a, 0x96, 0x5c, 0x83, 0xfe, 0x1d, 0x7b, 0x55, 0x9c, 0xb4, 0xcf, 0x1e, 0x1f, 0x55, 0x26,
	0x3a, 0x81, 0xab, 0x91, 0xb0, 0x52, 0xab, 0x05, 0x93, 0xf7, 0x68, 0xc4, 0x26, 0xa7, 0x3c, 0xd3,
	0x74, 0x1f, 0xba, 0x8f, 0x60, 0xec, 0xa1, 0x1b, 0x1d, 0xd4, 0x68, 0x23, 0xa0, 0x91, 0xb4, 0xe7,
	0xa0, 0x98, 0x9e, 0xba, 0xd1, 0x41, 0x3d, 0xe4, 0x70, 0x7d, 0xef, 0xd6, 0xd0, 0xad, 0x65, 0x38,
	0x23, 0x6a, 0x53, 0x47, 0xa8, 0x79, 0x93, 0x61, 0x01, 0x19, 0xe2, 0x50, 0xe9, 0x0c, 0x4d, 0x36,
	0x7f, 0x58, 0x84, 0x99, 0xc5, 0x03, 0xc7, 0xdb, 0xa7, 0x5b, 0x4e, 0x18, 0x3e, 0xf5, 0x83, 0xa6,
	0xd6, 0x78, 0x3c, 0x3f, 0xa6, 0x1a, 0x8f, 0x07, 0xc6, 0x79, 0x18, 0xdb, 0x6c, 0x35, 0x25, 0x8d,
	0x38, 0xdb, 0x62, 0x5d, 0x7e, 0xab, 0x59, 0x6f, 0x4b, 0x5e, 0x3a, 0x12, 0xa3, 0xd9, 0xa0, 0x4f,
	0x15, 0x4d, 0x7f, 0x4c, 0xe3, 0xd1, 0xa7, 0x1a, 0x8d, 0x86, 0x44, 0x96, 0xe1, 0x6c, 0x8d, 0x36,
	0x7c, 0xaf, 0x79, 0xd7, 0x69, 0x44, 0x7e, 0xb0, 0xed, 0x3f, 0xa6, 0x9e, 0x98, 0x84, 0xa8, 0xfc,
	0x87, 0x58, 0x58, 0x7f, 0x84, 0xa5, 0xf5, 0x88, 0x15, 0xdb, 0x69, 0x0a, 0xb2, 0x09, 0x23, 0x0f,
	0x85, 0x55, 0x50, 0x1c, 0x88, 0x5f, 0xbd, 0xa9, 0xcc, 0x84, 0x8b, 0x01, 0xc5, 0x99, 0xe3, 0xb4,
	0xd4, 0x91, 0x5e, 0xe9, 0x52, 0xb8, 0x5c, 0x49, 0x4c, 0x5b, 0x31, 0xb1, 0x76, 0x60, 0x62, 0xab,
	0xd5, 0xd9, 0x77, 0x3d, 0xb6, 0xb0, 0xd4, 0xe8, 0x8f, 0xc8, 0x12, 0x40, 0x0c, 0x10, 0xb6, 0xbe,
	0x29, 0x71, 0x8c, 0x8e, 0x0b, 0x76, 0xdf, 0x12, 0x5f, 0x1b, 0x42, 0xf0, 0xd4, 0x63, 0x6b, 0x74,
	0xd6, 0xff, 0xe9, 0x07, 0x22, 0x06, 0x00, 0x37, 0xba, 0x1a, 0x8d, 0xd8, 0x16, 0x74, 0x0e, 0x8a,
	0xca, 0x24, 0x37, 0x74, 0x7c, 0x54, 0x29, 0xba, 0x4d, 0xbb, 0xb8, 0xba, 0x44, 0xde, 0x86, 0x41,
	0x44, 0x43, 0xf9, 0x4f, 0xaa, 0xfa, 0x74, 0x0e, 0x7c, 0x81, 0xc1, 0x1d, 0xd6, 0xe6, 0xc8, 0xe4,
	0x1d, 0x18, 0x5d, 0xa2, 0x2d, 0xba, 0xef, 0x44, 0xbe, 0x5c, 0x02, 0xb8, 0x91, 0x4b, 0x02, 0xb5,
	0x39, 0x17, 0x63, 0xb2, 0x23, 0xaf, 0x4d, 0x9d, 0xd0, 0xf7, 0xf4, 0x23, 0x6f, 0x80, 0x10, 0xfd,
	0xc8, 0xcb, 0x71, 0xc8, 0xef, 0x14, 0x60, 0xac, 0xea, 0x79, 0xc2, 0x78, 0x14, 0x0a, 0xa9, 0xcf,
	0xdc, 0x54, 0xd6, 0xd6, 0x35, 0x67, 0x8f, 0xb6, 0x76, 0x9d, 0x56, 0x87, 0x86, 0x0b, 0x5f, 0xb3,
	0x53, 0xc8, 0x7f, 0x3e, 0xaa, 0x7c, 0x78, 0x0a, 0x73, 0x50, 0x6c, 0xb7, 0xdd, 0x0e, 0x1c, 0x37,
	0x0a, 0x8f, 0x8f, 0x2a, 0x33, 0x4e, 0x5c, 0xa1, 0xfe, 0xdd, 0x68, 0xed, 0x88, 0xd7, 0xff, 0xa1,
	0x5e, 0xeb, 0x3f, 0x39, 0x84, 0x33, 0xd5, 0x30, 0xec, 0x1c, 0xd2, 0x5a, 0xe4, 0x04, 0xd1, 0xb6,
	0x7b, 0x48, 0x71, 0x11, 0xe9, 0x6e, 0x40, 0x78, 0xfd, 0xa7, 0x47, 0x95, 0x02, 0x3b, 0xf8, 0x38,
	0x48, 0xca, 0x74, 0x9b, 0x20, 0xaa, 0x47, 0xae, 0xbe, 0x85, 0xa1, 0x29, 0x21, 0xc9, 0xdb, 0xba,
	0xa6, 0x94, 0x8e, 0xd5, 0xa5, 0xbc, 0x11, 0xb7, 0x16, 0xe1, 0xe2, 0x3d, 0x1a, 0xd9, 0x34, 0xa4,
	0x91, 0xfc, 0x46, 0x70, 0x86, 0xc7, 0x06, 0xdc, 0x61, 0xfc, 0xad, 0x88, 0x71, 0xf8, 0xf9, 0x77,
	0x21, 0x4b, 0xac, 0xbf, 0x51, 0x80, 0xca, 0x62, 0x40, 0xf9, 0x99, 0x21, 0x87, 0x51, 0xf7, 0xb5,
	0xeb, 0x22, 0x0c, 0x6c, 0x3f, 0x6b, 0x4b, 0xcb, 0x0b, 0x96, 0xb2, 0x41, 0xb1, 0x11, 0x7a, 0x42,
	0x43, 0x96, 0xf5, 0x08, 0x66, 0x6c, 0xea, 0xd1, 0xa7, 0xce, 0x5e, 0x8b, 0x1a, 0xb6, 0xa0, 0x0a,
	0x0c, 0xf2, 0x0f, 0x3d, 0xd5, 0x05, 0x0e, 0x3f, 0x9d, 0x5d, 0xcd, 0x9a, 0x80, 0xb1, 0x2d, 0xd7,
	0xdb, 0x17, 0xdc, 0xad, 0x3f, 0xe8, 0x87, 0x71, 0xfe, 0x5b, 0x1c, 0x83, 0x12, 0x5b, 0x5c, 0xe1,
	0x24, 0x5b, 0xdc, 0x7b, 0x30, 0xc1, 0xf6, 0x08, 0x1a, 0xec, 0xd2, 0x80, 0x6d, 0xad, 0x42, 0x12,
	0x78, 0xa4, 0x0b, 0xb1, 0xa0, 0xfe, 0x84, 0x97, 0xd8, 0x26, 0x22, 0x59, 0x83, 0x49, 0x0e, 0xb8,
	0x4b, 0x9d, 0xa8, 0x13, 0x5b, 0xa5, 0xce, 0x88, 0x73, 0x8f, 0x04, 0xf3, 0xa9, 0x29, 0x78, 0x3d,
	0x12, 0x40, 0x3b, 0x41, 0x4b, 0x3e, 0x81, 0x33, 0x5b, 0x81, 0xff, 0xcd, 0x33, 0x6d, 0x53, 0xe7,
	0x5f, 0x27, 0x3f, 0x21, 0xb1, 0xa2, 0xba, 0xbe, 0xb5, 0x27, 0xb1, 0xc9, 0x1b, 0x30, 0xb2, 0x1a,
	0x2e, 0xf8, 0x81, 0xeb, 0xed, 0xe3, 0x37, 0x3a, 0xc2, 0x8d, 0xf9, 0x6e, 0x58, 0xdf, 0x43, 0xa0,
	0xad, 0x8a, 0x13, 0x66, 0xe7, 0xe1, 0xde, 0x66, 0xe7, 0xdb, 0x00, 0x6b, 0xbe, 0xd3, 0xac, 0xb6,
	0x5a, 0x8b, 0xd5, 0x10, 0x77, 0x4f, 0xb1, 0x1f, 0xb5, 0x7c, 0xa7, 0x59, 0x77, 0x5a, 0xad, 0x7a,
	0xc3, 0x09, 0x6d, 0x0d, 0xe7, 0xfe, 0xc0, 0xc8, 0x50, 0x69, 0xd8, 0x3e, 0xb3, 0xe6, 0x36, 0xa8,
	0x17, 0xd2, 0x87, 0x4e, 0xe0, 0xb9, 0xde, 0x7e, 0x68, 0xfd, 0x8b, 0xb3, 0x30, 0xa2, 0xba, 0x7c,
	0x53, 0x57, 0xec, 0xc5, 0x2e, 0x87, 0xa3, 0x1f, 0x9b, 0xad, 0x6c, 0x0d, 0x83, 0x9c, 0x47, 0x55,
	0x5f, 0xec, 0xaf, 0xc3, 0x6c, 0x36, 0x3a, 0xed, 0xb6, 0xcd, 0x60, 0xec, 0x2b, 0x5b, 0x5a, 0x40,
	0xf9, 0x8f, 0xf0, 0xaf, 0xac, 0xb9, 0x67, 0x17, 0x97, 0x16, 0xd8, 0xf4, 0xde, 0x5c, 0x5d, 0x5a,
	0x44, 0x51, 0x8e, 0xf0, 0xe9, 0xed, 0xbb, 0xcd, 0x86, 0x8d, 0x50, 0x56, 0x5a, 0xab, 0xae, 0xaf,
	0x09, 0x71, 0x61, 0x69, 0xe8, 0x1c, 0xb6, 0x6c, 0x84, 0x32, 0xe5, 0x90, 0x5b, 0x20, 0x16, 0x7d,
	0x2f, 0x0a, 0xfc, 0x56, 0x88, 0x1a, 0xcc, 0x08, 0x1f, 0x4e, 0x61, 0xba, 0x68, 0x88, 0x22, 0x3b,
	0x81, 0x4a, 0x1e, 0xc2, 0x6c, 0xb5, 0xf9, 0xc4, 0xf1, 0x1a, 0xb4, 0xc9, 0x4b, 0x1e, 0xfa, 0xc1,
	0xe3, 0x47, 0x2d, 0xff, 0x69, 0x88, 0xf2, 0x1e, 0x11, 0x96, 0x3e, 0x81, 0x22, 0x2d, 0x21, 0x4f,
	0x25, 0x92, 0x9d, 0x47, 0xcd, 0x3e, 0xa9, 0xc5, 0x96, 0xdf, 0x69, 0x8a, 0x51, 0xc0, 0x4f, 0xaa,
	0xc1, 0x00, 0x36, 0x87, 0x33, 0x29, 0xad, 0xd4, 0xd6, 0xd1, 0xae, 0x26, 0xa4, 0x74, 0x10, 0x1e,
	0xda, 0x0c, 0x46, 0x5e, 0x85, 0x61, 0xa9, 0xe7, 0x72, 0xc3, 0x3f, 0x1a, 0x9c, 0xa5, 0x7e, 0x2b,
	0xcb, 0xd8, 0x27, 0x61, 0xd3, 0x86, 0xff, 0x84, 0x06, 0xcf, 0x16, 0xfd, 0x26, 0x95, 0x56, 0x20,
	0x61, 0xe5, 0xe0, 0x05, 0xf5, 0x06, 0x2b, 0xb1, 0x4d, 0x44, 0x56, 0x01, 0xdf, 0x03, 0xc3, 0xf2,
	0x99, 0xb8, 0x02, 0xbe, 0x47, 0x86, 0xb6, 0x2c, 0x23, 0x4b, 0x70, 0xb6, 0xda, 0x89, 0xfc, 0x43,
	0x27, 0x72, 0x1b, 0x3b, 0xed, 0xfd, 0xc0, 0x61, 0x95, 0x94, 0x90, 0x00, 0xf5, 0x7e, 0x47, 0x16,
	0xd6, 0x3b, 0xa2, 0xd4, 0x4e, 0x13, 0x90, 0x77, 0x61, 0x7c, 0x35, 0xe4, 0x96, 0x3e, 0x27, 0xa4,
	0x4d, 0x34, 0xd7, 0x88, 0x56, 0xba, 0x61, 0x1d, 0xed, 0x7e, 0x75, 0x76, 0x52, 0x68, 0xda, 0x06,
	0x1e, 0xb1, 0x60, 0xa8, 0x1a, 0x86, 0x6e, 0x18, 0xa1, 0x15, 0x66, 0x64, 0x01, 0x8e, 0x8f, 0x2a,
	0x43, 0x0e, 0x42, 0x6c, 0x51, 0x42, 0x1e, 0xc2, 0xd8, 0x12, 0x65, 0x8a, 0xe3, 0x76, 0xd0, 0x09,
	0x23, 0xb4, 0xa9, 0x8c, 0xcd, 0x9f, 0x17, 0x1f, 0xb6, 0x56, 0x22, 0xe6, 0x32, 0xd7, 0xf6, 0x9a,
	0x08, 0xaf, 0x47, 0xac, 0x40, 0xdf, 0xb5, 0x34, 0x7c, 0xa6, 0x15, 0x0b, 0x9a, 0x15, 0xb7, 0xc9,
	0x3e, 0xd5, 0x69, 0x6c, 0x03, 0x6a, 0xc5, 0x62, 0x6d, 0xa8, 0x1f, 0x60, 0x89, 0xae, 0x15, 0x1b,
	0x24, 0xa4, 0x91, 0x32, 0x1e, 0xcf, 0x18, 0x06, 0x42, 0xb3, 0x50, 0x36, 0xf1, 0x94, 0xa6, 0xe5,
	0x8f, 0x60, 0x6c, 0xb1, 0x13, 0x46, 0xfe, 0xe1, 0xf6, 0x01, 0x3d, 0xa4, 0x68, 0x77, 0x11, 0xba,
	0x7f, 0x03, 0xc1, 0xf5, 0x88, 0xc1, 0xf5, 0x6e, 0x6a, 0xe8, 0xe4, 0x33, 0x20, 0x52, 0x89, 0xbf,
	0xc7, 0xe6, 0x87, 0xc7, 0xe6, 0x32, 0x9a, 0x5e, 0x46, 0xb8, 0xe6, 0x2e, 0x75, 0xff, 0xfa, 0xbe,
	0x2a, 0xd6, 0xcd, 0x7f, 0x69, 0x62, 0xd6, 0x20, 0xde, 0xc4, 0x7b, 0x81, 0xd3, 0x3e, 0x28, 0x97,
	0x63, 0x2d, 0x5b, 0x74, 0x6a, 0x9f, 0xc1, 0x0d, 0x6d, 0x21, 0x46, 0x27, 0x35, 0x00, 0xfe, 0x73,
	0x8d, 0x0d, 0x3c, 0x37, 0xd6, 0x94, 0x0d, 0x79, 0xb1, 0x02, 0x29, 0xab, 0xf3, 0xa8, 0x83, 0x70,
	0xb6, 0x2d, 0xd7, 0x18, 0x4d, 0x8d, 0x0d, 0x79, 0x0c, 0x25, 0xfe, 0x6b, 0xdd, 0xf7, 0xdc, 0x88,
	0x2f, 0xbd, 0x73, 0x86, 0x65, 0x2f, 0x59, 0x2c, 0x2b, 0x40, 0x8b, 0xaa, 0xa8, 0xe0, 0x50, 0x95,
	0x6a, 0xd5, 0xa4, 0x18, 0x93, 0x2d, 0x18, 0xdb, 0x0a, 0xfc, 0x66, 0xa7, 0x11, 0xe1, 0x86, 0x7d,
	0x01, 0x15, 0x45, 0x22, 0xea, 0xd1, 0x4a, 0xb8, 0x4c, 0xda, 0x1c, 0x50, 0x67, 0x9b, 0xb9, 0x2e,
	0x13, 0x0d, 0x91, 0x2c, 0xc0, 0xd0, 0x96, 0xdf, 0x72, 0x1b, 0xcf, 0xca, 0x17, 0xb1, 0xd1, 0xd3,
	0x92, 0x19, 0x02, 0x65, 0x53, 0x51, 0x3b, 0x6c, 0x23, 0x48, 0xd7, 0x0e, 0x39, 0x12, 0xa9, 0xc2,
	0xc4, 0x67, 0x6c, 0xc2, 0xb8, 0xbe, 0xe7, 0x39, 0x6e, 0x40, 0xcb, 0x97, 0x70, 0x5c, 0xd0, 0xea,
	0xfd, 0x23, 0xbd, 0x40, 0x9f, 0xce, 0x06, 0x05, 0x59, 0x85, 0x33, 0xab, 0x61, 0x2d, 0x0a, 0xdc,
	0x36, 0x5d, 0x77, 0x3c, 0x67, 0x9f, 0x36, 0xcb, 0x97, 0x63, 0xb3, 0xb3, 0x1b, 0xd6, 0x43, 0x2c,
	0xab, 0x1f, 0xf2, 0x42, 0xdd, 0xec, 0x9c, 0xa0, 0x23, 0x9f, 0xc3, 0xf4, 0xf2, 0x37, 0x11, 0x9b,
	0x31, 0xad, 0x6a, 0xa7, 0xe9, 0x46, 0xb5, 0xc8, 0x0f, 0x9c, 0x7d, 0x5a, 0xae, 0x20, 0xbf, 0x57,
	0x8e, 0x8f, 0x2a, 0x57, 0xa8, 0x28, 0xaf, 0x3b, 0x0c, 0xa1, 0x1e, 0x72, 0x0c, 0xfd, 0x3a, 0x39,
	0x8b, 0x03, 0x93, 0x7e, 0xad, 0xd3, 0x66, 0x8a, 0x2b, 0x4a, 0xff, 0x8a, 0x21, 0x7d, 0xad, 0x84,
	0x4b, 0x3f, 0xe4, 0x80, 0x94, 0xf4, 0x35, 0x44, 0x62, 0x03, 0xb9, 0xef, 0xbb, 0x5e, 0xb5, 0x11,
	0xb9, 0x4f, 0xa8, 0x38, 0xd7, 0x87, 0xe5, 0xab, 0xd8, 0x52, 0x34, 0x91, 0xff, 0xb2, 0xef, 0x7a,
	0x75, 0x07, 0x8b, 0xeb, 0xc2, 0x0a, 0x60, 0x98, 0xc8, 0xd3, 0xd4, 0xe4, 0x07, 0x70, 0x6e, 0xdd,
	0xdf, 0x73, 0x5b, 0x94, 0x2f, 0x39, 0x5c, 0x2c, 0x68, 0xee, 0xb3, 0x90, 0x2f, 0x9a, 0xc8, 0x0f,
	0x11, 0xa3, 0x2e, 0x56, 0xab, 0x43, 0x85, 0xa3, 0x9b, 0xc8, 0xb3, 0xb9, 0x90, 0x65, 0x18, 0xc7,
	0xef, 0xb2, 0x85, 0x3f, 0xc3, 0xf2, 0x35, 0x3c, 0x1d, 0x5d, 0x4d, 0x28, 0x3c, 0x37, 0x97, 0x35,
	0x9c, 0x65, 0x2f, 0x0a, 0x9e, 0xd9, 0x06, 0x19, 0xf9, 0x18, 0xe6, 0x92, 0xd3, 0x7b, 0xd1, 0xf7,
	0x1e, 0xb9, 0xfb, 0x9d, 0x80, 0x36, 0xcb, 0xaf, 0xb0, 0xa6, 0xda, 0x5d, 0x30, 0xe6, 0x1e, 0xc2,
	0xd9, 0x54, 0x15, 0xa4, 0x04, 0xfd, 0x8f, 0xc5, 0x8d, 0xe3, 0xa8, 0xcd, 0xfe, 0x24, 0x6f, 0xc2,
	0xe0, 0x13, 0x76, 0x2c, 0x41, 0x8d, 0x21, 0xbe, 0xc3, 0xd2, 0x48, 0x57, 0xbd, 0x47, 0xbe, 0xcd,
	0x91, 0x3e, 0x28, 0xbe, 0x57, 0xb8, 0x3f, 0x30, 0x32, 0x56, 0x1a, 0xe7, 0x17, 0xc5, 0xf7, 0x07,
	0x46, 0x26, 0x4a, 0x93, 0x56, 0x15, 0xce, 0x24, 0xf0, 0x49, 0x19, 0x86, 0xa9, 0xc7, 0x54, 0xdd,
	0x26, 0xd7, 0x59, 0x6c, 0xf9, 0x93, 0x4c, 0xc3, 0x60, 0xcb, 0x3d, 0x74, 0x23, 0xac, 0x70, 0xd0,
	0xe6, 0x3f, 0xac, 0xdf, 0x2d, 0x00, 0x49, 0x6f, 0x19, 0xe4, 0x56, 0x82, 0x0d, 0x57, 0xf4, 0x04,
	0x48, 0x37, 0x85, 0x4b, 0xee, 0x9f, 0xc1, 0x14, 0x1f, 0x33, 0xb9, 0xb9, 0x69, 0x75, 0xf1, 0x45,
	0x35, 0xa3, 0x58, 0x37, 0x87, 0x88, 0x62, 0xdc, 0x0a, 0xd7, 0xb0, 0x69, 0x1d, 0x98, 0xc9, 0xdc,
	0x2c, 0xc8, 0x3a, 0xcc, 0x1c, 0xfa, 0x5e, 0x74, 0xd0, 0x7a, 0x26, 0xf7, 0x0a, 0x51, 0x5b, 0x01,
	0x6b, 0xc3, 0xf5, 0x31, 0x13, 0xc1, 0x9e, 0x12, 0x60, 0xc1, 0x11, 0xeb, 0xb9, 0x3f, 0x30, 0x52,
	0x2c, 0xf5, 0xab, 0x9e, 0x58, 0x36, 0x9c, 0x4d, 0xad, 0xb9, 0xe4, 0xfb, 0x30, 0xde, 0xc0, 0xa3,
	0x8c, 0x51, 0x13, 0xdf, 0x71, 0x34, 0xb8, 0xfe, 0x39, 0x71, 0x38, 0xef, 0xca, 0x3f, 0x29, 0xc0,
	0x6c, 0xce, 0x6a, 0x7b, 0x7a, 0x51, 0x7f, 0x01, 0xe7, 0x0e, 0x9d, 0x6f, 0xea, 0x01, 0x9e, 0x54,
	0xeb, 0x81, 0xe3, 0x25, 0xa4, 0x8d, 0x2b, 0x49, 0x36, 0x86, 0xee, 0xad, 0x73, 0xe8, 0x7c, 0x63,
	0x23, 0x82, 0xcd, 0xca, 0x79, 0x3b, 0x3f, 0x85, 0x09, 0x63, 0x7d, 0x3d, 0x75, 0xe3, 0xac, 0x3b,
	0x70, 0x96, 0x9d, 0xe5, 0x23, 0x7a, 0x62, 0x0b, 0x95, 0xb5, 0x05, 0x50, 0xa3, 0x87, 0x4e, 0xfb,
	0xc0, 0x67, 0x7a, 0xf7, 0x82, 0xfe, 0x4b, 0x58, 0x38, 0x88, 0xb0, 0x38, 0xa8, 0x82, 0xdd, 0xb7,
	0xb8, 0x2e, 0x1e, 0x2a, 0x4c, 0x5b, 0xa3, 0xb2, 0xfe, 0xa4, 0x08, 0x44, 0x2c, 0x90, 0x01, 0x75,
	0x0e, 0x65, 0x33, 0xde, 0x87, 0x71, 0x7e, 0x1e, 0xe5, 0x60, 0x6c, 0xce, 0xd8, 0xfc, 0x94, 0xf8,
	0xf2, 0xf4, 0xa2, 0x95, 0x3e, 0xdb, 0x40, 0x65, 0xa4, 0x36, 0xe5, 0x07, 0x69, 0x24, 0x2d, 0x1a,
	0xa4, 0x7a, 0x11, 0x23, 0xd5, 0x7f, 0x93, 0x4f, 0x60, 0x72, 0xd1, 0x3f, 0x6c, 0x33, 0x99, 0x08,
	0xe2, 0x7e, 0x61, 0xa4, 0x10, 0xf5, 0x1a, 0x85, 0x2b, 0x7d, 0x76, 0x02, 0x9d, 0x6c, 0xc0, 0xd4,
	0xdd, 0x56, 0x27, 0x3c, 0xa8, 0x7a, 0xcd, 0xc5, 0x96, 0x1f, 0x4a, 0x2e, 0x03, 0xc2, 0x48, 0x20,
	0x96, 0xb7, 0x34, 0xc6, 0x4a, 0x9f, 0x9d, 0x45, 0x48, 0x5e, 0x85, 0xc1, 0xe5, 0x27, 0x6c, 0xd9,
	0x95, 0x3e, 0x1b, 0xc2, 0xa5, 0x6c, 0xd3, 0xa3, 0x9b, 0x8f, 0x56, 0xfa, 0x6c, 0x5e, 0xba, 0x30,
	0x0a, 0xc3, 0xf2, 0x2c, 0x7b, 0x8b, 0xa9, 0xc4, 0x4a, 0x9c, 0xb5, 0xc8, 0x89, 0x3a, 0x21, 0x99,
	0x83, 0x91, 0x9d, 0x36, 0x3b, 0x62, 0x49, 0x23, 0x80, 0xad, 0x7e, 0x5b, 0x6f, 0x9a, 0x92, 0x26,
	0x17, 0x75, 0xfb, 0x31, 0x47, 0x8e, 0x01, 0xd6, 0x8a, 0x29, 0xdc, 0xee, 0xd8, 0x46, 0xbd, 0xc5,
	0x44, 0xbd, 0xa5, 0xa4, 0xac, 0xad, 0x99, 0x4c, 0xe1, 0x59, 0x9f, 0xc3, 0xe5, 0x9d, 0x76, 0x48,
	0x83, 0xa8, 0xda, 0x6e, 0xb7, 0xdc, 0x06, 0xbf, 0xf3, 0xc1, 0x33, 0xaf, 0x9c, 0x2c, 0xef, 0xc2,
	0x10, 0x07, 0x88, 0x69, 0x22, 0xe7, 0x60, 0xb5, 0xdd, 0x16, 0x27, 0xed, 0xb7, 0xb8, 0x72, 0xce,
	0xcf, 0xce, 0xb6, 0xc0, 0xb6, 0x7e, 0xab, 0x00, 0x97, 0xf9, 0x17, 0x90, 0xcb, 0xfa, 0x3b, 0x30,
	0x8a, 0x1e, 0x5d, 0x6d, 0xa7, 0x21, 0xbf, 0x09, 0xee, 0xda, 0x26, 0x81, 0x76, 0x5c, 0xae, 0xf9,
	0xca, 0x15, 0xf3, 0x7d, 0xe5, 0xe4, 0x07, 0xd6, 0x9f, 0xf9, 0x81, 0x7d, 0x06, 0x96, 0x68, 0x51,
	0xab, 0x95, 0x6a, 0x54, 0xf8, 0x3c, 0xad, 0xb2, 0xfe, 0x47, 0x11, 0x66, 0xef, 0x51, 0x8f, 0x06,
	0x0e, 0xf6, 0xd3, 0xb0, 0xe9, 0xe8, 0x3e, 0x33, 0x85, 0xae, 0x3e, 0x33, 0x15, 0x69, 0x25, 0x2b,
	0xa2, 0x95, 0x2c, 0xe5, 0x00, 0xc4, 0x8e, 0x8b, 0x3b, 0xf6, 0xaa, 0xe8, 0x16, 0x1e, 0x17, 0x3b,
	0x81, 0x8b, 0x76, 0x70, 0xb2, 0x1a, 0xfb, 0xdb, 0x0c, 0xf4, 0x34, 0x97, 0x4d, 0x09, 0xff, 0x83,
	0x61, 0xe1, 0x6f, 0x63, 0x7a, 0xd9, 0x6c, 0xc0, 0x10, 0x37, 0xee, 0xe1, 0x6d, 0xcd, 0xd8, 0xfc,
	0x0d, 0xf1, 0x4d, 0xe5, 0x74, 0x50, 0x58, 0x02, 0x71, 0x63, 0xe7, 0x53, 0x20, 0x42, 0x80, 0x2d,
	0xb8, 0xcc, 0x7d, 0x06, 0x63, 0x1a, 0xca, 0x49, 0xf6, 0x7e, 0x65, 0x64, 0x64, 0x1a, 0xa3, 0xb7,
	0xcf, 0xed, 0x95, 0xda, 0xde, 0x6f, 0x7d, 0x08, 0xe5, 0x74, 0x6b, 0x84, 0x61, 0xa9, 0x97, 0x1d,
	0xcb, 0x5a, 0x82, 0xe9, 0x7b, 0x34, 0xc2, 0x89, 0x8b, 0x1f, 0x91, 0xe6, 0x37, 0x96, 0xf8, 0xce,
	0xe4, 0xaa, 0x2a, 0x6f, 0x75, 0xf4, 0xaf, 0xb4, 0x06, 0x33, 0x09, 0x2e, 0xa2, 0xfe, 0x0f, 0x60,
	0x58, 0x80, 0xd4, 0x8a, 0x2a, 0x9c, 0x4f, 0xe9, 0x9e, 0x28, 0xd8, 0x9d, 0xe7, 0xf3, 0x56, 0x70,
	0xb6, 0x25, 0x81, 0x75, 0x00, 0xe7, 0xd8, 0x36, 0x1b, 0x73, 0x55, 0xd3, 0xf1, 0x02, 0x8c, 0xb6,
	0x99, 0xa2, 0x10, 0xba, 0x3f, 0xe6, 0xd3, 0x68, 0xd0, 0x1e, 0x61, 0x80, 0x9a, 0xfb, 0x63, 0x4a,
	0x2e, 0x01, 0x60, 0x21, 0x76, 0x53, 0xac, 0x02, 0x88, 0xce, 0x0d, 0x77, 0x04, 0xd0, 0xeb, 0x8c,
	0xcf, 0x1b, 0x1b, 0xff, 0xb6, 0x02, 0x98, 0x4d, 0xd5, 0x24, 0x3a, 0x70, 0x0b, 0x46, 0xa4, 0x0a,
	0x9b, 0x30, 0xa9, 0xeb, 0x3d, 0xb0, 0x15, 0x12, 0x79, 0x0d, 0xce, 0x78, 0xf4, 0x9b, 0xa8, 0x9e,
	0x6a, 0xc3, 0x04, 0x03, 0x6f, 0xc9, 0x76, 0x58, 0xbf, 0x84, 0x66, 0xd4, 0x9a, 0xe7, 0x3f, 0x7d,
	0xd4, 0x72, 0x1e, 0xd3, 0x54, 0xc5, 0xdf, 0x87, 0x91, 0x5a, 0xef, 0x8a, 0xf9, 0xe7, 0x23, 0x2b,
	0xb7, 0x15, 0x89, 0xd5, 0x82, 0x39, 0xd6, 0xa5, 0x5a, 0x75, 0x7d, 0x6d, 0xb5, 0xb9, 0xf5, 0x6d,
	0x0b, 0xf0, 0x09, 0x5c, 0xc8, 0xac, 0xed, 0xdb, 0x16, 0xe2, 0xbf, 0x1e, 0x80, 0x59, 0xbe, 0x99,
	0xa4, 0x67, 0xf0, 0xc9, 0x97, 0x9a, 0x5f, 0xc8, 0x8d, 0xe4, 0xed, 0x8c, 0x1b, 0x49, 0x24, 0xd1,
	0x6f, 0x24, 0x8d, 0x7b, 0xc8, 0xf7, 0xb2, 0xef, 0x21, 0xd1, 0x4e, 0x64, 0xde, 0x43, 0x26, 0x6f,
	0x1f, 0x97, 0xf3, 0x6f, 0x1f, 0xf1, 0x9a, 0x25, 0xe3, 0xf6, 0x31, 0xeb, 0xce, 0x31, 0xe1, 0xfa,
	0x33, 0xf2, 0x72, 0x5d, 0x7f, 0x5e, 0x83, 0xe1, 0x6a, 0xbb, 0xad, 0xb9, 0xd2, 0xe1, 0xf0, 0x38,
	0xed, 0x36, 0x17, 0x9e, 0x2c, 0x94, 0xeb, 0x3c, 0x64, 0xac, 0xf3, 0xef, 0x03, 0x2c, 0xa2, 0xc3,
	0x3f, 0x0e, 0xdc, 0x18, 0x62, 0xa0, 0x86, 0xcf, 0x9f, 0x01, 0xe0, 0xc0, 0xe9, 0x16, 0x90, 0x18,
	0x99, 0x2b, 0xf6, 0xd6, 0x2e, 0x94, 0xd3, 0xd3, 0xe7, 0x25, 0x2c, 0x5d, 0x7f, 0x54, 0x80, 0x4b,
	0x42, 0xc9, 0x49, 0x7c, 0xe0, 0xa7, 0x9f, 0x9d, 0xef, 0xc0, 0xb8, 0xa0, 0xdd, 0x8e, 0x3f, 0x04,
	0x7e, 0x05, 0x2c, 0x17, 0x63, 0xbe, 0xa2, 0x1b, 0x68, 0xe4, 0x1d, 0x18, 0xc1, 0x3f, 0xe2, 0x6b,
	0x10, 0x26, 0x99, 0x51, 0x44, 0xad, 0x27, 0x2f, 0x43, 0x14, 0xaa, 0xf5, 0x35, 0x5c, 0xce, 0x6b,
	0xf8, 0x4b, 0x90, 0xcb, 0xbf, 0x29, 0xc0, 0x05, 0xc1, 0xde, 0x58, 0x2a, 0x9e, 0x6b, 0xd7, 0x39,
	0x85, 0x03, 0xee, 0x7d, 0x18, 0x63, 0x15, 0xca, 0x76, 0xf7, 0x8b, 0xad, 0x55, 0x9c, 0x1c, 0xe2,
	0x92, 0x25, 0x27, 0x72, 0x84, 0x43, 0x89, 0x73, 0xd8, 0x92, 0xc6, 0x0b, 0x5b, 0x27, 0xb6, 0xbe,
	0x84, 0x8b, 0xd9, 0x5d, 0x78, 0x09, 0xf2, 0xb9, 0x0f, 0x73, 0x19, 0x9b, 0xc2, 0xf3, 0xed, 0xc9,
	0x5f, 0xc0, 0x85, 0x4c, 0x5e, 0x2f, 0xa1, 0x99, 0x2b, 0x4c, 0xe3, 0x88, 0x5e, 0xc2, 0x10, 0x5a,
	0x0f, 0xe1, 0x7c, 0x06, 0xa7, 0x97, 0xd0, 0xc4, 0x7b, 0x30, 0xab, 0x34, 0xed, 0x17, 0x6a, 0xe1,
	0x3a, 0x5c, 0xe2, 0x8c, 0x5e, 0xce, 0xa8, 0x3c, 0x80, 0x0b, 0x82, 0xdd, 0x4b, 0x90, 0xde, 0x0a,
	0x5c, 0x8c, 0x0f, 0xd4, 0x19, 0x7a, 0xd2, 0x89, 0x17, 0x19, 0x6b, 0x0d, 0xae, 0xc4, 0x9c, 0x72,
	0x94, 0x86, 0x93, 0x73, 0xe3, 0xea, 0x60, 0x3c, 0x4a, 0x2f, 0x65, 0x44, 0x1f, 0xc2, 0x39, 0x83,
	0xe9, 0x4b, 0x53, 0x95, 0x56, 0x61, 0x8a, 0x33, 0x36, 0x55, 0xe7, 0x79, 0x5d, 0x75, 0x1e, 0x9b,
	0x3f, 0x1b, 0xb3, 0x44, 0xf0, 0xee, 0x5b, 0x19, 0xda, 0xf4, 0x3a, 0x6a, 0xd3, 0x12, 0x25, 0x6e,
	0xe1, 0x3b, 0x30, 0xc4, 0x21, 0xa2, 0x7d, 0x19, 0xcc, 0xf8, 0x61, 0x81, 0x93, 0x09, 0x64, 0xeb,
	0x07, 0x70, 0x89, 0x9f, 0x44, 0xe3, 0xbb, 0x44, 0xf3, 0xb4, 0xf8, 0xfd, 0xc4, 0x41, 0xf4, 0xbc,
	0xe0, 0x9b, 0xc4, 0xcf, 0x39, 0x8f, 0xee, 0xc9, 0xb9, 0x9d, 0xc7, 0xff, 0x44, 0x8f, 0xb1, 0xe4,
	0x01, 0xb3, 0x98, 0x79, 0xc0, 0xbc, 0x06, 0x57, 0xd5, 0x01, 0x33, 0x59, 0x8d, 0x9c, 0x5a, 0xd6,
	0x97, 0x70, 0x81, 0x77, 0x54, 0x3a, 0xc9, 0x99, 0xcd, 0xf8, 0x30, 0xd1, 0xcd, 0x59, 0xd1, 0x4d,
	0x13, 0x3b, 0xa7, 0x93, 0x7f, 0xbb, 0x20, 0x3f, 0xb9, 0x6c, 0xe6, 0xbf, 0xe8, 0x13, 0xf7, 0x06,
	0x54, 0x94, 0x40, 0xcc, 0x16, 0x3d, 0xdf, 0x71, 0x7b, 0x1d, 0x66, 0x74, 0x36, 0x6e, 0x83, 0xee,
	0xde, 0xc1, 0x4b, 0x9e, 0xb7, 0xd9, 0x67, 0x81, 0x00, 0x39, 0xed, 0xca, 0x19, 0x72, 0x43, 0x7c,
	0x5b, 0x61, 0x5a, 0x75, 0xb8, 0x98, 0x1e, 0x0a, 0xb7, 0x21, 0x3d, 0xe4, 0xc9, 0x27, 0xec, 0x13,
	0x46, 0x88, 0x18, 0x8c, 0x5c, 0xa6, 0xf2, 0x3b, 0xe6, 0xe4, 0x92, 0xca, 0xb2, 0xe4, 0x52, 0x93,
	0xe8, 0x3f, 0xab, 0x5d, 0xce, 0x87, 0x5f, 0x05, 0x22, 0x8b, 0x16, 0x6b, 0xb6, 0xac, 0xfa, 0x3c,
	0xf4, 0x2f, 0xd6, 0x6c, 0xf1, 0x34, 0x07, 0x35, 0xc1, 0x46, 0x18, 0xd8, 0x0c, 0x96, 0xd4, 0xc8,
	0x8b, 0x27, 0xd0, 0xc8, 0xef, 0x0f, 0x8c, 0xf4, 0x97, 0x06, 0x6c, 0x52, 0x73, 0xf7, 0xbd, 0x87,
	0x6e, 0x74, 0xa0, 0x2a, 0xac, 0x5a, 0x5f, 0xc1, 0x94, 0x51, 0xbd, 0xf8, 0x8a, 0xbb, 0xbe, 0x29,
	0x62, 0xfa, 0xec, 0x62, 0x15, 0x9d, 0x48, 0xd0, 0x64, 0x31, 0xce, 0xd7, 0x9b, 0x86, 0x53, 0xc7,
	0x07, 0xab, 0xb6, 0x2c, 0xb4, 0xfe, 0xf1, 0x80, 0xc6, 0x5d, 0x7b, 0xa9, 0xd5, 0xa5, 0x77, 0x77,
	0x00, 0xf8, 0x0c, 0xd1, 0x3a, 0xc7, 0x14, 0xc0, 0x31, 0xe1, 0x9b, 0xc1, 0x97, 0x64, 0x5b, 0x43,
	0x3a, 0xe9, 0x4b, 0x2e, 0xe1, 0x51, 0xcb, 0x89, 0xe4, 0xe3, 0x45, 0xe5, 0x51, 0x2b, 0x58, 0x87,
	0xb6, 0x8e, 0x44, 0x7e, 0x90, 0x7c, 0x6e, 0x30, 0x88, 0x77, 0x4a, 0xaf, 0xc8, 0x4b, 0xe6, 0x74,
	0xdf, 0x4e, 0xf7, 0xe2, 0xe0, 0x29, 0xcc, 0x30, 0x5a, 0xf7, 0x11, 0x1e, 0x2c, 0x96, 0xbf, 0x89,
	0xa8, 0xc7, 0xd7, 0xf6, 0x21, 0xac, 0xe7, 0xd5, 0x2e, 0xf5, 0xc4, 0xc8, 0xc2, 0xfe, 0x1e, 0xf3,
	0xa9, 0x53, 0x55, 0x66, 0x67, 0xf3, 0xc7, 0x49, 0x64, 0xaf, 0x2d, 0x7b, 0xcd, 0xb6, 0xef, 0xaa,
	0x03, 0x13, 0x9f, 0x44, 0x41, 0xab, 0x4e, 0x05, 0xdc, 0xd6, 0x91, 0xac, 0xd7, 0xba, 0xfa, 0x69,
	0x8f, 0xc0, 0xc0, 0xf6, 0xe2, 0xf6, 0x5a, 0xa9, 0x60, 0xdd, 0x02, 0xd0, 0x6a, 0x02, 0x18, 0xda,
	0xd8, 0xb4, 0xd7, 0xab, 0x6b, 0xa5, 0x3e, 0x32, 0x03, 0x67, 0x1f, 0xae, 0x6e, 0x2c, 0x6d, 0x3e,
	0xac, 0xd5, 0x6b, 0xeb, 0x55, 0x7b, 0x7b, 0xb1, 0x6a, 0x2f, 0x95, 0x0a, 0xd6, 0xd7, 0x30, 0x6d,
	0xf6, 0xf0, 0xa5, 0x4e, 0xc2, 0x08, 0xa6, 0x94, 0x3e, 0x73, 0xff, 0xe1, 0xb6, 0xe6, 0xbf, 0x29,
	0x0e, 0x7f, 0x49, 0x3f, 0x24, 0x71, 0x4c, 0x14, 0x9f, 0x91, 0x86, 0x44, 0xde, 0xe0, 0x6a, 0x41,
	0xf2, 0x2d, 0x2e, 0x53, 0x0b, 0xea, 0xb1, 0x5e, 0x80, 0x4b, 0xdf, 0xf7, 0x60, 0xda, 0xac, 0xf5,
	0xa4, 0x56, 0xaa, 0x57, 0xd0, 0xb1, 0x55, 0x7b, 0xa8, 0x43, 0x88, 0x7e, 0x6d, 0x20, 0x56, 0xd6,
	0xef, 0x41, 0x49, 0x60, 0xc5, 0x3b, 0xef, 0x35, 0x69, 0x46, 0x2c, 0x64, 0x3c, 0x2b, 0x94, 0x6e,
	0xd6, 0x3e, 0x94, 0xd8, 0x8a, 0x29, 0x28, 0x79, 0x05, 0xd3, 0x30, 0xb8, 0x16, 0x5f, 0xe7, 0xd8,
	0xfc, 0x07, 0xbe, 0x57, 0x89, 0x9c, 0x20, 0x92, 0x5e, 0x5f, 0xa3, 0xb6, 0xfa, 0x4d, 0xde, 0x80,
	0xa1, 0xbb, 0x6e, 0x2b, 0x12, 0xa6, 0x91, 0x78, 0x93, 0x67, 0x6c, 0x79, 0x81, 0x2d, 0x10, 0x2c,
	0x1b, 0xce, 0x6a, 0x15, 0x9e, 0xa2, 0xa9, 0xa4, 0x0c, 0xc3, 0x1b, 0xf4, 0x1b, 0xad, 0x7e, 0xf9,
	0xd3, 0x7a, 0x17, 0xce, 0x0a, 0x8f, 0x3a, 0x4d, 0x4c, 0x57, 0xc5, 0xeb, 0xe7, 0x82, 0xf1, 0x04,
	0x53, 0xb0, 0xc4, 0x22, 0x46, 0xb7, 0xd3, 0x6e, 0x3e, 0x27, 0x1d, 0xdb, 0x28, 0x4e, 0x49, 0xf7,
	0xba, 0xbc, 0x05, 0xea, 0x35, 0x9c, 0x7f, 0x52, 0x80, 0x72, 0xc2, 0xca, 0xb0, 0x78, 0xe0, 0xb4,
	0x5a, 0xd4, 0xdb, 0xa7, 0xe4, 0x3a, 0x0c, 0x6c, 0x6f, 0x6e, 0x6f, 0x09, 0x2b, 0xa9, 0x74, 0x00,
	0x60, 0x20, 0x85, 0x63, 0x23, 0x06, 0x79, 0x00, 0x67, 0xa5, 0xcf, 0xac, 0x2a, 0x12, 0x23, 0x74,
	0xa9, 0xbb, 0x07, 0x6e, 0x9a, 0x8e, 0xbc, 0x2d, 0x4c, 0x22, 0x3f, 0xea, 0xb8, 0x01, 0x6d, 0xa2,
	0xe5, 0x27, 0xbe, 0x4d, 0xd7, 0x4a, 0x6c, 0x1d, 0x8d, 0xbf, 0x55, 0xb5, 0x7e, 0xa7, 0x00, 0xb3,
	0x39, 0x56, 0x13, 0xf2, 0x86, 0xd1, 0x9d, 0x29, 0xad, 0x3b, 0x12, 0x65, 0xa5, 0x4f, 0xf4, 0x67,
	0x51, 0x73, 0x24, 0xee, 0x3f, 0x85, 0x23, 0xf1, 0x4a, 0x5f, 0xec, 0x3c, 0xbc, 0x00, 0x30, 0x22,
	0xe1, 0xd6, 0x19, 0x98, 0x30, 0xe4, 0x66, 0x59, 0x30, 0xae, 0xd7, 0xcc, 0x06, 0x67, 0xd1, 0x6f,
	0xaa, 0xc1, 0x61, 0x7f, 0x5b, 0xbf, 0x5d, 0x80, 0x69, 0xec, 0xe2, 0xbe, 0xcb, 0x96, 0xbe, 0x58,
	0x42, 0xf3, 0x46, 0x4f, 0x2e, 0x1a, 0x3d, 0x49, 0xe0, 0xaa, 0x2e, 0x7d, 0x90, 0xea, 0xd2, 0xc5,
	0xac, 0x2e, 0xe1, 0xf4, 0x76, 0x7d, 0xcf, 0xe8, 0x89, 0x76, 0x15, 0xf5, 0xbb, 0x05, 0x98, 0xd2,
	0xda, 0xa4, 0xda, 0x7f, 0xc7, 0x68, 0xd2, 0x85, 0x8c, 0x26, 0xa5, 0x84, 0xbc, 0x90, 0x6a, 0xd1,
	0x2b, 0xdd, 0x5a, 0xd4, 0x53, 0xc6, 0xff, 0xad, 0x00, 0x33, 0x99, 0x32, 0x20, 0xe7, 0x98, 0x6e,
	0xdb, 0x08, 0x68, 0x24, 0xc4, 0x2b, 0x7e, 0x31, 0xf8, 0x6a, 0x18, 0x76, 0x68, 0x20, 0xbe, 0x73,
	0xf1, 0x8b, 0xbc, 0x02, 0x13, 0x5b, 0x34, 0x70, 0xfd, 0x26, 0x77, 0x31, 0xe7, 0xbe, 0x9b, 0x13,
	0xb6, 0x09, 0x24, 0x17, 0x61, 0xb4, 0xda, 0xda, 0xf7, 0x03, 0x37, 0x3a, 0xe0, 0xb7, 0x81, 0xa3,
	0x76, 0x0c, 0x60, 0xbc, 0x97, 0xdc, 0x7d, 0x7e, 0xa9, 0xc1, 0x88, 0xc5, 0x2f, 0xb6, 0xb8, 0x48,
	0x6b, 0xe1, 0x10, 0x5f, 0x5c, 0xa4, 0x29, 0xf0, 0x1c, 0x0c, 0x7d, 0x66, 0xe3, 0x24, 0xc0, 0x08,
	0x01, 0xb6, 0xf8, 0x45, 0x26, 0xd1, 0x49, 0x18, 0x5f, 0x25, 0xa0, 0x73, 0xf0, 0x07, 0x30, 0x9d,
	0x25, 0xd7, 0xac, 0x29, 0x24, 0x68, 0x8b, 0x8a, 0xf6, 0x4b, 0x98, 0xaa, 0x36, 0x9b, 0xeb, 0x77,
	0xab, 0xdc, 0xe7, 0x40, 0x8c, 0x2a, 0xff, 0x78, 0xb8, 0xbd, 0x4e, 0xa8, 0x6c, 0x03, 0xab, 0x9e,
	0x1b, 0xd9, 0x53, 0xcb, 0xdf, 0xb8, 0x61, 0xe4, 0x7a, 0xfb, 0x9a, 0x51, 0xd1, 0x3e, 0xb7, 0x41,
	0x9f, 0x66, 0x4c, 0x01, 0xb6, 0x9b, 0x9a, 0xbc, 0x39, 0x3c, 0x83, 0xf9, 0xb4, 0xc6, 0x36, 0x5e,
	0x4a, 0x66, 0x4d, 0xbe, 0x71, 0x41, 0x7f, 0xb5, 0xf1, 0xd8, 0xfa, 0x1e, 0x9c, 0xe3, 0x4b, 0x5a,
	0xb7, 0xc6, 0x8b, 0x66, 0xeb, 0x36, 0x50, 0xeb, 0x3d, 0x69, 0xa5, 0xe8, 0xda, 0x32, 0x7b, 0xdc,
	0x68, 0x0b, 0x56, 0xf9, 0xdf, 0x0b, 0x30, 0x97, 0x20, 0xad, 0x3d, 0xf3, 0x1a, 0x72, 0x3d, 0x7d,
	0x2d, 0xe9, 0x84, 0x8d, 0x7a, 0x00, 0x37, 0xfe, 0xb9, 0x4d, 0xe5, 0x87, 0x4d, 0x6e, 0x01, 0x70,
	0x62, 0x6d, 0xfb, 0x46, 0xd3, 0xb7, 0x70, 0xb2, 0xc1, 0x0d, 0x5c, 0x43, 0x21, 0x1d, 0xc8, 0x92,
	0xbb, 0xf8, 0x46, 0x7a, 0xd9, 0x86, 0x31, 0x2a, 0x06, 0x15, 0xe4, 0xf5, 0x1c, 0x23, 0x71, 0x16,
	0x7f, 0xeb, 0xef, 0xf4, 0xc3, 0xac, 0x3e, 0x80, 0xcf, 0xd3, 0xd7, 0x2d, 0x18, 0x5b, 0xf4, 0xbd,
	0x88, 0x7e, 0x13, 0x69, 0x51, 0x09, 0x88, 0xba, 0x69, 0x57, 0x25, 0x42, 0x75, 0xe4, 0x80, 0x3a,
	0xd3, 0x63, 0x0c, 0x67, 0xc1, 0x18, 0x91, 0x2c, 0xc2, 0xc4, 0x06, 0x7d, 0x9a, 0x12, 0x20, 0x3a,
	0x2c, 0x7a, 0xf4, 0x69, 0x5d, 0x13, 0xa2, 0xee, 0x45, 0x66, 0xd0, 0x90, 0x3d, 0x98, 0x94, 0x93,
	0xcb, 0x10, 0xe6, 0x9c, 0xbe, 0xab, 0x98, 0xd3, 0x99, 0xbf, 0xda, 0x67, 0x35, 0xe4, 0xc8, 0x30,
	0xc1, 0x91, 0x75, 0x9d, 0xd7, 0xc8, 0x1f, 0xa2, 0x9b, 0xdb, 0x96, 0x56, 0x62, 0xb8, 0x83, 0x26,
	0x1f, 0xa0, 0xeb, 0x2c, 0xac, 0x2d, 0x28, 0xa7, 0xc7, 0x43, 0xd4, 0xf6, 0x36, 0x0c, 0x71, 0xa8,
	0x50, 0x03, 0x64, 0xc0, 0x19, 0x85, 0xcd, 0xcf, 0xe9, 0xbc, 0x1a, 0x5b, 0xe0, 0x5a, 0x2b, 0x68,
	0x3b, 0x51, 0x38, 0x4a, 0x11, 0xbb, 0x9d, 0x1c, 0x5e, 0xf4, 0xb4, 0x95, 0xc3, 0xab, 0xfb, 0x99,
	0xc8, 0xc7, 0x05, 0x8b, 0x68, 0x7e, 0xd2, 0x39, 0x89, 0x86, 0xdd, 0x80, 0x61, 0x01, 0x4a, 0x84,
	0xc2, 0x89, 0x3f, 0x3f, 0x89, 0x60, 0x7d, 0x00, 0xe7, 0xd1, 0x16, 0xe6, 0x7a, 0xfb, 0x2d, 0xba,
	0x13, 0x1a, 0xcf, 0x03, 0x7a, 0x7d, 0xd6, 0x1f, 0xc1, 0x5c, 0x16, 0x6d, 0xcf, 0x2f, 0x9b, 0x07,
	0xa7, 0xf8, 0xf3, 0x22, 0x4c, 0xaf, 0x86, 0xba, 0x32, 0xa1, 0x02, 0x54, 0x64, 0x04, 0x4d, 0x40,
	0x99, 0xac, 0xf4, 0x65, 0x05, 0x45, 0x78, 0x5b, 0x7b, 0x9c, 0x58, 0xec, 0x16, 0x0d, 0x81, 0x6d,
	0x5b, 0xea, 0x79, 0xe2, 0x6b, 0x30, 0xb0, 0xc1, 0x96, 0xea, 0x7e, 0x31, 0x76, 0x9c, 0x82, 0x81,
	0xf0, 0x71, 0x20, 0xdb, 0x22, 0xd9, 0x0f, 0x72, 0x37, 0xf5, 0x04, 0x71, 0xa0, 0xf7, 0x6b, 0xff,
	0x95, 0xbe, 0xd4, 0x6b, 0xc4, 0x77, 0x61, 0xac, 0xda, 0x3c, 0xe4, 0x1e, 0x81, 0xbe, 0x97, 0xf8,
	0x2c, 0xb5, 0x92, 0x95, 0x3e, 0x5b, 0x47, 0x64, 0x27, 0xdc, 0x6a, 0xbb, 0x8d, 0x1b, 0x55, 0x56,
	0x04, 0x84, 0x95, 0x3e, 0x74, 0xb0, 0x5f, 0x18, 0x81, 0xa1, 0x6d, 0x27, 0xd8, 0xa7, 0x91, 0xf5,
	0x25, 0xcc, 0x09, 0x27, 0x15, 0x6e, 0xf9, 0x43, 0x57, 0x96, 0x30, 0xf6, 0x43, 0xea, 0xe6, 0x58,
	0x72, 0x19, 0x00, 0xf5, 0xfc, 0x55, 0xaf, 0x49, 0xbf, 0x11, 0x5e, 0x72, 0x1a, 0xc4, 0x7a, 0x07,
	0x46, 0x95, 0x84, 0x50, 0x99, 0xd5, 0x36, 0x3b, 0x94, 0xd6, 0xb4, 0xf1, 0xe6, 0x52, 0x3e, 0xb4,
	0x3c, 0x6f, 0xf4, 0x5d, 0xc4, 0x34, 0xe1, 0xda, 0xaf, 0x0b, 0x33, 0x89, 0x49, 0x10, 0x3f, 0x99,
	0x57, 0xfa, 0x27, 0x77, 0xe3, 0x53, 0xbf, 0x93, 0xea, 0x69, 0xf1, 0x44, 0xea, 0xa9, 0xf5, 0xcf,
	0x8a, 0x78, 0x70, 0x4a, 0xc9, 0x23, 0x61, 0x83, 0xd2, 0xed, 0x60, 0x0b, 0x30, 0x8a, 0xbd, 0x5f,
	0x92, 0x4f, 0xbf, 0xba, 0xfb, 0x58, 0x8c, 0xfc, 0xf4, 0xa8, 0xd2, 0x87, 0x8e, 0x15, 0x31, 0x19,
	0xf9, 0x18, 0x86, 0x97, 0xbd, 0x26, 0x72, 0xe8, 0x3f, 0x05, 0x07, 0x49, 0xc4, 0xc6, 0x04, 0x9b,
	0xbc, 0xcd, 0x3e, 0x61, 0x6e, 0xba, 0xb0, 0x35, 0x48, 0x7c, 0x82, 0x1b, 0xcc, 0x3b, 0xc1, 0x0d,
	0x25, 0x4e, 0x70, 0x16, 0x0c, 0x6e, 0x06, 0x4d, 0x11, 0x89, 0x64, 0x72, 0x7e, 0x5c, 0x08, 0x0e,
	0x61, 0x36, 0x2f, 0xb2, 0xfe, 0x67, 0x01, 0x66, 0xef, 0xd1, 0x28, 0x73, 0x0e, 0x19, 0x52, 0x29,
	0xbc, 0xb0, 0x54, 0x8a, 0xcf, 0x23, 0x15, 0xd5, 0xeb, 0xfe, 0xbc, 0x5e, 0x0f, 0xe4, 0xf5, 0x7a,
	0x30, 0xbf, 0xd7, 0xf7, 0x60, 0x88, 0x77, 0x95, 0x9d, 0x52, 0x57, 0x23, 0x7a, 0x18, 0x9f, 0x52,
	0x75, 0x0f, 0x31, 0x9b, 0x97, 0x31, 0x45, 0x72, 0xcd, 0x09, 0xf5, 0x53, 0xaa, 0xf8, 0x69, 0xfd,
	0x10, 0x1f, 0x8d, 0xae, 0xf9, 0x8d, 0xc7, 0x9a, 0xb5, 0x73, 0x98, 0x7f, 0xa1, 0x49, 0xeb, 0x38,
	0xc3, 0xe2, 0x25, 0xb6, 0xc4, 0x20, 0x57, 0x60, 0x6c, 0xd5, 0xbb, 0xeb, 0x07, 0x0d, 0xba, 0xe9,
	0xb5, 0x38, 0xf7, 0x11, 0x5b, 0x07, 0x09, 0x2b, 0x80, 0xa8, 0x21, 0x3e, 0x5a, 0x23, 0x20, 0x71,
	0xb4, 0x66, 0xb0, 0xdd, 0x79, 0x9b, 0x97, 0x09, 0x23, 0x03, 0xfb, 0xbb, 0xdb, 0xa9, 0x54, 0x1d,
	0x5f, 0x7b, 0x21, 0xee, 0xc1, 0x79, 0x9b, 0xb6, 0x5b, 0x0e, 0xd3, 0xe9, 0x0e, 0x7d, 0x8e, 0xaf,
	0xfa, 0x7c, 0x25, 0xe3, 0xc1, 0x97, 0xe9, 0x2f, 0xa0, 0x9a, 0x5c, 0xec, 0xd2, 0xe4, 0x43, 0xb8,
	0x7a, 0x8f, 0x46, 0xe6, 0x82, 0x1a, 0xdb, 0x52, 0x45, 0xe7, 0x57, 0x60, 0x24, 0x34, 0xed, 0xc0,
	0x97, 0xe5, 0xf5, 0x43, 0x16, 0xe1, 0xee, 0x5b, 0xf2, 0xa6, 0x44, 0xf0, 0x51, 0x7f, 0x59, 0x9f,
	0x40, 0x25, 0xaf, 0xba, 0x93, 0xb9, 0x73, 0xba, 0x70, 0x25, 0x9f, 0x81, 0x68, 0xee, 0x32, 0x48,
	0x9b, 0xb1, 0xf8, 0x84, 0x7a, 0xb5, 0xd6, 0x34, 0x33, 0x8b, 0x3f, 0xac, 0x05, 0xe9, 0xd8, 0xf6,
	0x02, 0xcd, 0xad, 0xe3, 0x75, 0xac, 0xc9, 0x20, 0x96, 0x6b, 0x15, 0x46, 0x24, 0x4c, 0xc8, 0x75,
	0x36, 0xb3, 0xa5, 0x52, 0xa0, 0x4d, 0xc9, 0x40, 0x91, 0x59, 0x3f, 0x94, 0x57, 0x13, 0x26, 0xc5,
	0xc9, 0x5e, 0x40, 0x9e, 0xe4, 0x2e, 0xc2, 0xf2, 0xe1, 0xbc, 0xc9, 0x5b, 0x37, 0x39, 0x97, 0x34,
	0x93, 0x33, 0xb7, 0x34, 0x5f, 0x31, 0x4d, 0xa0, 0x45, 0x31, 0x2f, 0x63, 0x10, 0xb9, 0xac, 0x1b,
	0x96, 0xc7, 0xd3, 0x4f, 0x2a, 0x6f, 0xc3, 0x5c, 0x56, 0x85, 0xda, 0x39, 0x50, 0x59, 0x2f, 0x85,
	0xbe, 0xb3, 0x04, 0x97, 0x65, 0x2c, 0x20, 0xdf, 0x8f, 0xc2, 0x28, 0x70, 0xda, 0xb5, 0x46, 0xe0,
	0xb6, 0x63, 0x2a, 0x0b, 0x86, 0x38, 0x44, 0x48, 0x82, 0x5f, 0xf3, 0x70, 0x1c, 0x51, 0x62, 0xfd,
	0x7a, 0x01, 0x2c, 0xc3, 0x07, 0x09, 0xc7, 0x79, 0x2b, 0xf0, 0x9f, 0xb8, 0x4d, 0xed, 0x6a, 0xe5,
	0x0d, 0xc3, 0xac, 0xc7, 0x9f, 0xc4, 0x25, 0xdd, 0x9f, 0xc5, 0x9a, 0x79, 0x3b, 0x61, 0x6a, 0xe3,
	0x8a, 0x27, 0xfa, 0x25, 0x99, 0x41, 0x57, 0x94, 0x09, 0xee, 0x7f, 0x17, 0xe0, 0x5a, 0xd7, 0x36,
	0x88, 0xfe, 0xec, 0x41, 0x29, 0x59, 0x26, 0x66, 0x50, 0x45, 0xf3, 0x49, 0x48, 0x73, 0xd8, 0xbd,
	0xc3, 0x7d, 0xac, 0xa5, 0xef, 0x4e, 0x5b, 0x71, 0x4e, 0xf1, 0x3b, 0x7d, 0xeb, 0xc9, 0xfb, 0x00,
	0xdb, 0x7e, 0xe4, 0xb4, 0x16, 0xd1, 0x00, 0xd0, 0x1f, 0xfb, 0xcb, 0x47, 0x0c, 0x5a, 0x4f, 0x06,
	0x29, 0xd0, 0x90, 0xad, 0x4f, 0xf1, 0xbb, 0xce, 0x6e, 0xf4, 0xc9, 0x3e, 0xb5, 0x45, 0xb8, 0x96,
	0xb8, 0x17, 0x7f, 0x0e, 0x26, 0x11, 0xcc, 0x30, 0xf1, 0x33, 0xdd, 0xfb, 0x5e, 0xe0, 0x77, 0xda,
	0xbf, 0x98, 0x51, 0xff, 0xe3, 0x02, 0x77, 0x54, 0xd4, 0xab, 0x15, 0x03, 0xbd, 0x08, 0x10, 0x43,
	0x13, 0x0e, 0xeb, 0xaa, 0x60, 0xf7, 0x0e, 0x3f, 0x72, 0xa3, 0xc5, 0x7c, 0x9f, 0x33, 0xd0, 0xc8,
	0x7e, 0xb1, 0x23, 0xf9, 0x16, 0x5e, 0x86, 0xab, 0xda, 0x4f, 0x26, 0xf7, 0x77, 0xa5, 0xfd, 0xe3,
	0x94, 0x74, 0x07, 0x30, 0xcd, 0x56, 0x80, 0x6a, 0x27, 0x3a, 0xf0, 0x03, 0x37, 0x92, 0x4f, 0x2f,
	0xc8, 0x96, 0x78, 0xdb, 0xcd, 0xa9, 0x3e, 0xfa, 0xf9, 0x51, 0xe5, 0xbd, 0xd3, 0x44, 0x69, 0x94,
	0x3c, 0xb7, 0xd5, 0x7b, 0x70, 0x6b, 0x16, 0xfa, 0x17, 0xed, 0x35, 0x5c, 0xf0, 0xec, 0x35, 0xb5,
	0xe0, 0xd9, 0x6b, 0xd6, 0x5f, 0x16, 0xa1, 0xc2, 0xa3, 0x4f, 0xa0, 0x0f, 0x45, 0x6c, 0xb5, 0xd0,
	0x9c, 0x32, 0x4e, 0x6a, 0x60, 0x48, 0x44, 0x97, 0x28, 0x9e, 0x24, 0xba, 0xc4, 0xaf, 0x40, 0x8e,
	0xc9, 0xea, 0x04, 0x56, 0x80, 0xd7, 0x8f, 0x8f, 0x2a, 0xd7, 0x62, 0x2b, 0x00, 0x2f, 0xcd, 0x32,
	0x07, 0xe4, 0x54, 0x91, 0xb6, 0x5f, 0x0c, 0x3c, 0x87, 0xfd, 0xe2, 0x36, 0x0c, 0xe3, 0x61, 0x66,
	0x75, 0x4b, 0x78, 0x35, 0xe2, 0xf4, 0xc4, 0x78, 0x32, 0x75, 0x57, 0x0f, 0xde, 0x26, 0xd1, 0xac,
	0xbf, 0x5f, 0x84, 0x2b, 0xf9, 0x32, 0x17, 0x6d, 0x5b, 0x02, 0x88, 0xbd, 0x37, 0xba, 0x79, 0x8b,
	0xe0, 0xb7, 0xf3, 0x94, 0xee, 0x29, 0x6f, 0x2d, 0x8d, 0x8e, 0xe9, 0x3e, 0xf2, 0xa1, 0x6f, 0xe2,
	0xaa, 0xc0, 0x78, 0xff, 0x2b, 0x62, 0x8f, 0x0a, 0x90, 0x11, 0x7b, 0x54, 0xc0, 0xc8, 0x1e, 0xcc,
	0x6e, 0x05, 0xee, 0x13, 0x27, 0xa2, 0x0f, 0xe8, 0x33, 0xfe, 0x10, 0x66, 0x59, 0xbc, 0x7e, 0xe1,
	0xaf, 0xb7, 0xaf, 0x1f, 0x1f, 0x55, 0x5e, 0x69, 0x73, 0x14, 0x8c, 0x2f, 0xc5, 0x9f, 0x1e, 0xd6,
	0xd3, 0x0f, 0x62, 0xf2, 0x18, 0x59, 0xff, 0xbe, 0x00, 0x17, 0x50, 0x2d, 0x17, 0x66, 0x57, 0x59,
	0xf9, 0x73, 0x39, 0x0d, 0xea, 0x1d, 0x14, 0x73, 0x11, 0x9d, 0x06, 0x8d, 0x87, 0xd0, 0xb6, 0x81,
	0x46, 0x56, 0x61, 0x4c, 0xfc, 0xc6, 0xef, 0xaf, 0x1f, 0x0f, 0x04, 0x33, 0xda, 0x82, 0x85, 0x53,
	0x9d, 0x9b, 0x8a, 0x70, 0x62, 0x0b, 0x66, 0xf8, 0x5e, 0xd0, 0xd6, 0x69, 0xad, 0x9f, 0x15, 0xe1,
	0xe2, 0x2e, 0x0d, 0xdc, 0x47, 0xcf, 0x72, 0x3a, 0xb3, 0x09, 0xd3, 0x12, 0xc4, 0x23, 0x50, 0x18,
	0x9f, 0x18, 0x8f, 0x3e, 0x28, 0x9b, 0x2a, 0x42, 0x58, 0xc8, 0x2f, 0x2e, 0x93, 0xf0, 0x14, 0xee,
	0x80, 0x6f, 0xc3, 0x48, 0x22, 0x06, 0x0c, 0x8e, 0xbf, 0xfc, 0x42, 0xe3, 0xa1, 0x5a, 0xe9, 0xb3,
	0x15, 0x26, 0xf9, 0x8d, 0xfc, 0xfb, 0x1b, 0x61, 0xfa, 0xe8, 0x65, 0xff, 0xc4, 0x0f, 0x96, 0x7d,
	0xac, 0x8e, 0x56, 0x9a, 0xf1, 0xc1, 0xae, 0xf4, 0xd9, 0x79, 0x35, 0x2d, 0x8c, 0xc1, 0x68, 0x15,
	0xef, 0xa4, 0xd8, 0xc9, 0xfd, 0x7f, 0x15, 0xe1, 0xb2, 0x7c, 0xd4, 0x92, 0x23, 0xe6, 0xcf, 0x61,
	0x56, 0x82, 0xaa, 0x6d, 0xa6, 0x30, 0xd0, 0xa6, 0x29, 0x69, 0x1e, 0x01, 0x54, 0x4a, 0xda, 0x11,
	0x38, 0xb1, 0xb0, 0xf3, 0xc8, 0x5f, 0x8e, 0xf5, 0xf3, 0xe3, 0xac, 0x88, 0x3c, 0x68, 0x85, 0xd4,
	0xd7, 0x4c, 0x43, 0x34, 0xc6, 0xfa, 0xd9, 0x4c, 0x59, 0x4f, 0x07, 0x5e, 0xd4, 0x7a, 0xba, 0xd2,
	0x97, 0xb4, 0x9f, 0x2e, 0x4c, 0xc2, 0xf8, 0x06, 0x7d, 0x1a, 0xcb, 0xfd, 0x6f, 0x16, 0x12, 0x91,
	0x06, 0x98, 0x86, 0xc1, 0x43, 0x0e, 0x14, 0xe2, 0xa0, 0x2e, 0x18, 0x69, 0x40, 0xd7, 0x30, 0x38,
	0xea, 0x2a, 0x0c, 0xf3, 0x8b, 0xda, 0xe6, 0x09, 0x4e, 0xf8, 0xea, 0x75, 0x0a, 0x7f, 0x32, 0xd8,
	0xe4, 0x87, 0x7d, 0x41, 0x6f, 0x3d, 0x80, 0xab, 0xc2, 0x7f, 0xd9, 0x1c, 0x7c, 0xac, 0xe8, 0x94,
	0xdb, 0x97, 0xe5, 0xc0, 0xe5, 0x7b, 0x34, 0xb9, 0xf4, 0x18, 0xaf, 0x77, 0x3e, 0x81, 0x33, 0x06,
	0x5c, 0x71, 0x44, 0xad, 0x54, 0xcd, 0x21, 0xc5, 0x3a, 0x89, 0x6d, 0x5d, 0xc9, 0xaa, 0x42, 0x6f,
	0xac, 0x45, 0x31, 0x94, 0x67, 0x10, 0x5f, 0xb1, 0x85, 0xa7, 0x58, 0xf5, 0xae, 0x6b, 0xdf, 0x35,
	0x5f, 0xf1, 0x78, 0xac, 0x37, 0xb9, 0xf3, 0xaa, 0x52, 0x6b, 0xc2, 0xb8, 0x0b, 0xb0, 0x26, 0x61,
	0x5c, 0x16, 0xb5, 0x68, 0x18, 0x5a, 0x3f, 0x19, 0x04, 0x4b, 0x08, 0x36, 0xeb, 0xf6, 0x59, 0xca,
	0x63, 0x2f, 0xd5, 0x58, 0xb1, 0x51, 0x9d, 0xd3, 0x23, 0x48, 0xc6, 0xa5, 0x7c, 0xe6, 0xa1, 0x9e,
	0xd7, 0x88, 0xa1, 0xc6, 0xcc, 0x4b, 0xf5, 0xfe, 0xab, 0x9c, 0x65, 0x92, 0x7f, 0x6c, 0xaf, 0x1e,
	0x1f, 0x55, 0xae, 0xe6, 0x2c, 0x93, 0x06, 0xdf, 0xec, 0x25, 0xd3, 0x36, 0xaf, 0x44, 0xfa, 0x9f,
	0xe7, 0x4a, 0x84, 0x7d, 0x91, 0xfa, 0xa5, 0xc8, 0x8e, 0x29, 0x4b, 0xf1, 0x3d, 0xca, 0x2b, 0x6d,
	0xbd, 0x48, 0x3c, 0xf8, 0xd7, 0x20, 0x06, 0x57, 0x83, 0x0d, 0x71, 0xa1, 0xa4, 0xd9, 0x2c, 0x17,
	0x0f, 0x68, 0xe3, 0xb1, 0xb0, 0x15, 0xcb, 0x0b, 0xdd, 0x2c, 0x9b, 0x39, 0x8f, 0x26, 0xcc, 0xbf,
	0x73, 0x5e, 0x50, 0x6f, 0x30, 0x52, 0x3d, 0x60, 0x41, 0x92, 0x2d, 0xf9, 0x31, 0x4c, 0xa9, 0xa1,
	0x4e, 0xb8, 0x1f, 0x8d, 0xcd, 0xbf, 0x12, 0x07, 0x9e, 0x3c, 0x7c, 0xe4, 0xdc, 0x7c, 0x72, 0xe7,
	0x66, 0x06, 0x2e, 0x7f, 0x07, 0xdf, 0x90, 0x05, 0x9a, 0xef, 0x91, 0x7e, 0xd1, 0x95, 0x45, 0xa8,
	0x5d, 0x67, 0xff, 0x3d, 0xe5, 0x2c, 0xcf, 0xf4, 0x05, 0xb7, 0x45, 0xc5, 0xab, 0x17, 0x39, 0xfb,
	0x72, 0xae, 0xe2, 0x0a, 0xdf, 0xf2, 0x55, 0xdc, 0x1f, 0x14, 0xe5, 0x13, 0x81, 0xf4, 0x6d, 0xe8,
	0xa9, 0x6f, 0xe4, 0x32, 0x7b, 0x70, 0xa2, 0xcd, 0x34, 0xb3, 0x71, 0x64, 0x41, 0xde, 0x67, 0xaa,
	0xd8, 0x50, 0x93, 0xea, 0x6e, 0x20, 0x2e, 0x30, 0xae, 0x38, 0x51, 0x75, 0xd1, 0xa8, 0x92, 0x97,
	0x65, 0xfd, 0x2f, 0x7e, 0x59, 0xf6, 0xaf, 0x46, 0xe1, 0xec, 0x96, 0xb3, 0xef, 0x7a, 0x6c, 0xd1,
	0xb6, 0x69, 0xe8, 0x77, 0x82, 0x06, 0x25, 0x55, 0x98, 0x34, 0xfd, 0x3f, 0x7b, 0x78, 0xb7, 0xb2,
	0x7d, 0xc9, 0x84, 0x91, 0x79, 0x18, 0x55, 0x6f, 0x4e, 0xc5, 0x66, 0x92, 0xf1, 0x16, 0x75, 0xa5,
	0xcf, 0x8e, 0xd1, 0xc8, 0xfb, 0xc6, 0xfd, 0xce, 0x19, 0xf5, 0x7c, 0x1a, 0x71, 0xe7, 0xb9, 0x83,
	0x9e, 0xe7, 0x37, 0xcd, 0x0d, 0x91, 0x5f, 0x62, 0xfc, 0x30, 0x75, 0xe5, 0x33, 0x68, 0xb4, 0x38,
	0x65, 0xf7, 0x42, 0x5d, 0x20, 0x37, 0x9c, 0x73, 0xc6, 0x65, 0xd0, 0x97, 0x30, 0xf6, 0xa0, 0xb3,
	0x47, 0xe5, 0xe5, 0xd6, 0x90, 0xd8, 0x1f, 0x93, 0x5e, 0xcd, 0xa2, 0x7c, 0xf7, 0x2d, 0x3e, 0x06,
	0x8f, 0x3b, 0x7b, 0x34, 0x1d, 0x27, 0x9c, 0x2d, 0x4c, 0x1a, 0x33, 0x72, 0x00, 0xa5, 0xa4, 0x03,
	0xb2, 0x88, 0xa6, 0xd6, 0xc5, 0x6d, 0x1a, 0x43, 0x79, 0x68, 0xd1, 0xc8, 0xb9, 0x5b, 0xa4, 0x51,
	0x49, 0x8a, 0x2b, 0xf9, 0x55, 0x98, 0xc9, 0xb4, 0x3a, 0xaa, 0x27, 0x54, 0xdd, 0x0d, 0x9a, 0xb8,
	0xa8, 0x27, 0xa4, 0x26, 0xdf, 0x6b, 0x19, 0x35, 0x67, 0xd7, 0x42, 0x9a, 0x70, 0x26, 0xe1, 0x58,
	0x2b, 0x52, 0x2e, 0xe4, 0xbb, 0xea, 0xe2, 0xc6, 0x24, 0xa3, 0x96, 0x66, 0xd6, 0x95, 0x64, 0x49,
	0xd6, 0x60, 0x54, 0x1d, 0xf7, 0xf1, 0x75, 0x56, 0xb6, 0x69, 0xa3, 0x7c, 0x7c, 0x54, 0x99, 0x8e,
	0x4d, 0x1b, 0x06, 0xcf, 0x98, 0x01, 0xf9, 0x35, 0xb8, 0xaa, 0xa6, 0xe8, 0x66, 0x90, 0x6d, 0x04,
	0x12, 0xd1, 0xce, 0x6f, 0x24, 0x67, 0x78, 0x1e, 0xfe, 0xee, 0x9d, 0x85, 0x62, 0xb9, 0xb0, 0xd2,
	0x67, 0xf7, 0x66, 0x4d, 0x7e, 0x52, 0x80, 0x73, 0x39, 0xb5, 0x8e, 0x63, 0xad, 0x3d, 0x2d, 0x73,
	0xa8, 0xdc, 0xe3, 0xb3, 0x21, 0xb7, 0x19, 0x3f, 0xaf, 0x93, 0x26, 0x3a, 0xa3, 0xdf, 0x39, 0x35,
	0x91, 0x37, 0x61, 0x08, 0xcf, 0xc8, 0x61, 0x79, 0x02, 0xb5, 0x48, 0x8c, 0x60, 0x83, 0x27, 0x69,
	0x7d, 0xdf, 0x10, 0x38, 0x64, 0x85, 0x69, 0x63, 0xb8, 0x6f, 0x49, 0xed, 0x49, 0xc4, 0xbb, 0x12,
	0x1a, 0x3d, 0x2f, 0x92, 0x51, 0x2e, 0x8c, 0xb0, 0xf6, 0x26, 0xd9, 0x02, 0xc0, 0x48, 0x20, 0x56,
	0xa5, 0xfb, 0x03, 0x23, 0x03, 0xa5, 0x41, 0xfe, 0xe1, 0x48, 0x8f, 0xed, 0xdf, 0x1c, 0xe1, 0xcf,
	0x3b, 0x77, 0x3c, 0xf7, 0x91, 0x1b, 0x2f, 0x60, 0xba, 0x75, 0x2d, 0xce, 0x2f, 0x23, 0x74, 0xdf,
	0x9c, 0x4c, 0x32, 0xca, 0x10, 0x57, 0xec, 0x69, 0x88, 0x7b, 0x4b, 0xbb, 0xb2, 0xd2, 0x42, 0x44,
	0x72, 0x1d, 0xc7, 0x34, 0x7c, 0xc5, 0x77, 0x59, 0x5f, 0xc3, 0x10, 0x46, 0x75, 0xe4, 0xf7, 0x81,
	0x63, 0xf3, 0x37, 0xc5, 0xb2, 0xdd, 0xa5, 0xf9, 0x3c, 0x0c, 0xa4, 0x78, 0xb2, 0xcd, 0x25, 0x8e,
	0x00, 0x43, 0xe2, 0x08, 0x21, 0xdb, 0x30, 0xb5, 0x15, 0xd0, 0xa6, 0xf0, 0x1b, 0x6e, 0x07, 0xc2,
	0x38, 0xc1, 0xcd, 0x1e, 0xb8, 0xe5, 0xb7, 0x65, 0x71, 0x9d, 0xaa, 0x72, 0x7d, 0x43, 0xcd, 0x20,
	0x27, 0xcb, 0x30, 0x59, 0xa3, 0x4e, 0xd0, 0x38, 0x78, 0x40, 0x9f, 0x31, 0x75, 0xc7, 0x48, 0xa9,
	0x10, 0x62, 0x09, 0xeb, 0x2f, 0x16, 0xe9, 0x3e, 0x1e, 0x26, 0x11, 0xf9, 0x14, 0x86, 0x6a, 0x7e,
	0x10, 0x2d, 0x3c, 0x13, 0x8b, 0x9a, 0xbc, 0x31, 0xe2, 0xc0, 0x85, 0xf3, 0x32, 0xad, 0x44, 0xe8,
	0x07, 0x51, 0x7d, 0xcf, 0x08, 0x89, 0xc4, 0x51, 0xc8, 0x33, 0x98, 0x36, 0x17, 0x14, 0xe1, 0xce,
	0x3a, 0x22, 0xd4, 0xac, 0xac, 0x55, 0x8b, 0xa3, 0x2c, 0x5c, 0x17, 0xdc, 0xaf, 0x24, 0x97, 0xad,
	0x47, 0x58, 0xae, 0x47, 0x29, 0xca, 0xa2, 0x27, 0xeb, 0x98, 0x8f, 0x83, 0xf7, 0xa8, 0x1a, 0x72,
	0x37, 0xd8, 0xd1, 0x38, 0xe8, 0x56, 0x07, 0x17, 0x25, 0x94, 0x84, 0x13, 0x26, 0x93, 0xb8, 0xd8,
	0x29, 0x52, 0xb2, 0x05, 0x67, 0x77, 0x42, 0xba, 0x15, 0xd0, 0x27, 0x2e, 0x7d, 0x2a, 0xf9, 0x41,
	0x1c, 0xa1, 0x88, 0xf1, 0x6b, 0xf3, 0xd2, 0x2c, 0x86, 0x69, 0x62, 0xf2, 0x3e, 0xc0, 0x96, 0xeb,
	0x79, 0xb4, 0x89, 0xd7, 0x8e, 0x63, 0xc8, 0x0a, 0x4d, 0xaa, 0x6d, 0x84, 0xd6, 0x7d, 0xaf, 0xa5,
	0x8b, 0x54, 0x43, 0x26, 0x0b, 0x30, 0xb1, 0xea, 0x35, 0x5a, 0x1d, 0xe1, 0x1e, 0x10, 0xe2, 0x82,
	0x22, 0x22, 0xa7, 0xb9, 0xbc, 0xa0, 0x9e, 0xfa, 0xc8, 0x4d, 0x12, 0xf2, 0x00, 0x88, 0x00, 0x88,
	0x59, 0xeb, 0xec, 0xb5, 0xa8, 0xf8, 0xdc, 0xd1, 0x54, 0x22, 0x19, 0xe1, 0x74, 0x37, 0x02, 0x92,
	0xa5, 0xc8, 0xe6, 0xde, 0x87, 0x31, 0x6d, 0xce, 0x67, 0xc4, 0x20, 0x98, 0xd6, 0x63, 0x10, 0x8c,
	0xea, 0xb1, 0x06, 0xfe, 0x51, 0x01, 0x2e, 0x66, 0x7f, 0x4b, 0x42, 0x01, 0xdb, 0x84, 0x51, 0x05,
	0x54, 0xaf, 0x4e, 0xa4, 0xea, 0x9f, 0xd0, 0x80, 0xf8, 0x07, 0x2d, 0x57, 0x1e, 0xbd, 0xf7, 0x31,
	0x8f, 0xe7, 0xb0, 0xc7, 0xff, 0xad, 0x11, 0x98, 0x46, 0xef, 0xea, 0xe4, 0x3a, 0xf5, 0x09, 0xc6,
	0x12, 0x41, 0x98, 0x66, 0x5e, 0x16, 0x96, 0x26, 0x0e, 0x4f, 0x06, 0xbe, 0x32, 0x08, 0xc8, 0x3b,
	0xba, 0x4f, 0x44, 0x51, 0xcb, 0xff, 0x21, 0x81, 0x7a, 0x17, 0x62, 0x67, 0x89, 0x37, 0x8c, 0x2b,
	0xf9, 0x13, 0x2f, 0x7a, 0x03, 0x27, 0x5d, 0xf4, 0x76, 0xd4, 0xa2, 0xc7, 0x63, 0x54, 0xbc, 0xae,
	0x2d, 0x7a, 0x2f, 0x7f, 0xb5, 0x1b, 0x7a, 0xd9, 0xab, 0xdd, 0xf0, 0x8b, 0xad, 0x76, 0x23, 0xcf,
	0xb9, 0xda, 0xdd, 0x85, 0xc9, 0x0d, 0x4a, 0x9b, 0xda, 0x45, 0xc9, 0x68, 0xbc, 0x7b, 0x7a, 0x14,
	0x4d, 0x60, 0x59, 0xb7, 0x25, 0x09, 0xaa, 0xdc, 0x55, 0x13, 0xfe, 0x7a, 0x56, 0xcd, 0xb1, 0x97,
	0xbc, 0x6a, 0x8e, 0xbf, 0xc8, 0xaa, 0x99, 0x5a, 0xfa, 0x26, 0x4e, 0xbd, 0xf4, 0xbd, 0xc8, 0x6a,
	0xf5, 0x31, 0xba, 0x14, 0xd6, 0x6a, 0x2b, 0xc2, 0x7b, 0x44, 0x73, 0xd7, 0x58, 0xf1, 0x43, 0xe9,
	0x71, 0x8d, 0x7f, 0x33, 0xd8, 0x96, 0x1f, 0xc8, 0x2b, 0x6f, 0xfc, 0xdb, 0x5a, 0x40, 0x47, 0x42,
	0x9d, 0x5e, 0xb9, 0xeb, 0x0f, 0x8b, 0x27, 0x7b, 0x62, 0x8d, 0x4b, 0x1e, 0xa3, 0x6c, 0x59, 0x6e,
	0xfd, 0x79, 0x81, 0x5f, 0x4a, 0xfe, 0xbf, 0xb8, 0x54, 0xbe, 0xc8, 0x45, 0xe1, 0x6f, 0xc4, 0x4f,
	0xf9, 0x45, 0xd8, 0x81, 0xc0, 0x69, 0x3c, 0x8e, 0x6f, 0x6a, 0x7f, 0xc0, 0xbe, 0x73, 0xbd, 0x00,
	0x03, 0xab, 0xc6, 0x67, 0x45, 0xb3, 0x70, 0xf7, 0x8e, 0x5c, 0x00, 0x44, 0x44, 0x03, 0x0e, 0x36,
	0x17, 0x00, 0x9d, 0x00, 0x7d, 0xe5, 0xce, 0x58, 0x36, 0x7f, 0x89, 0x9e, 0xd9, 0x82, 0x77, 0xd3,
	0x6f, 0xa9, 0xf1, 0x30, 0x12, 0xbf, 0xa5, 0xd6, 0xc5, 0x18, 0xbf, 0xaa, 0xde, 0x81, 0x0b, 0x36,
	0x3d, 0xf4, 0x9f, 0xd0, 0x97, 0xcb, 0xf6, 0x2b, 0x38, 0x6f, 0x32, 0xe4, 0xaf, 0x6e, 0x78, 0x40,
	0xf4, 0x8f, 0xb3, 0xc3, 0xa8, 0x0b, 0x02, 0x1e, 0x46, 0x9d, 0x47, 0x63, 0x66, 0x7f, 0xea, 0xfb,
	0x06, 0x96, 0x59, 0x3e, 0x5c, 0x34, 0x99, 0x57, 0x9b, 0x4d, 0xcc, 0xb6, 0xd8, 0x70, 0xdb, 0x8e,
	0x17, 0x91, 0x4d, 0x18, 0xd3, 0x7e, 0x26, 0x4c, 0x05, 0x5a, 0x89, 0xd0, 0x69, 0x62, 0x80, 0x11,
	0x82, 0x33, 0x06, 0x5b, 0x14, 0x2a, 0x49, 0xf1, 0x30, 0x91, 0xe9, 0x75, 0x2e, 0xc0, 0x84, 0xf6,
	0x53, 0x99, 0x2c, 0xf1, 0xe3, 0xd7, 0x6a, 0x30, 0x05, 0x66, 0x92, 0x58, 0x0d, 0x98, 0xcb, 0x12,
	0x1a, 0x46, 0x67, 0x7a, 0x46, 0x96, 0xe3, 0x38, 0x4f, 0xbd, 0xbd, 0xed, 0xce, 0xe4, 0xc5, 0x78,
	0xb2, 0xfe, 0xee, 0x00, 0x5c, 0x10, 0x83, 0xf1, 0x32, 0x47, 0x9c, 0xfc, 0x10, 0xc6, 0xb4, 0x31,
	0x16, 0x42, 0xbf, 0x22, 0x43, 0x6f, 0xe6, 0xcd, 0x05, 0x6e, 0xd2, 0xe8, 0x20, 0xa0, 0x9e, 0x18,
	0xee, 0x95, 0x3e, 0x5b, 0x67, 0x49, 0x5a, 0x30, 0x69, 0x0e, 0xb4, 0xb0, 0xea, 0x5c, 0xcb, 0xac,
	0xc4, 0x44, 0x95, 0x81, 0x9c, 0x9b, 0xf5, 0xcc, 0xe1, 0x5e, 0xe9, 0xb3, 0x13, 0xbc, 0xc9, 0x37,
	0x70, 0x36, 0x35, 0xca, 0xc2, 0x58, 0xf7, 0x5a, 0x66, 0x85, 0x29, 0x6c, 0x6e, 0x8e, 0x0d, 0x10,
	0x9c, 0x5b, 0x6d, 0xba, 0x12, 0xd2, 0x84, 0x71, 0x7d, 0xe0, 0x85, 0xd9, 0xe9, 0x6a, 0x17, 0x51,
	0x72, 0x44, 0xae, 0xdc, 0x09, 0x59, 0xe2, 0xd8, 0x3f, 0x33, 0x4d, 0xcc, 0x06, 0xf2, 0x08, 0x0c,
	0xf1, 0xdf, 0x6c, 0x09, 0xd8, 0x0a, 0x68, 0x48, 0xbd, 0x06, 0x35, 0x1c, 0xb4, 0x5f, 0x70, 0x09,
	0xf8, 0x77, 0x05, 0x28, 0x67, 0xf1, 0xad, 0x51, 0xaf, 0x49, 0xb6, 0xa0, 0x94, 0xac, 0x48, 0xcc,
	0x6a, 0x4b, 0xc5, 0xca, 0xcd, 0x6d, 0xd2, 0x4a, 0x9f, 0x9d, 0xa2, 0x26, 0x1b, 0x70, 0x56, 0x83,
	0x09, 0xe3, 0x6a, 0xf1, 0x24, 0xc6, 0x55, 0x36, 0x0a, 0x29, 0x52, 0xdd, 0x36, 0xbd, 0x82, 0x3b,
	0xe3, 0x92, 0x7f, 0xe8, 0xb8, 0x1e, 0x53, 0x74, 0xb5, 0x50, 0x4f, 0x10, 0x43, 0x85, 0x6c, 0xb8,
	0xb5, 0x15, 0xa1, 0xf2, 0x41, 0x89, 0x42, 0xb1, 0x3e, 0xc2, 0x15, 0x5c, 0xd8, 0xe8, 0xf8, 0xf3,
	0x54, 0xc5, 0xec, 0x0a, 0x0c, 0x6e, 0xaf, 0xd5, 0x16, 0xab, 0xe2, 0xb1, 0x2b, 0x0f, 0x91, 0xd0,
	0x0a, 0xeb, 0x0d, 0xc7, 0xe6, 0x05, 0xd6, 0x87, 0x40, 0xee, 0xd1, 0x48, 0x04, 0x6b, 0x57, 0x74,
	0xaf, 0xc2, 0xb0, 0x00, 0x09, 0x4a, 0x74, 0x8d, 0x6b, 0x09, 0x2c, 0x59, 0x66, 0x6d, 0xc9, 0x73,
	0x42, 0x8b, 0x3a, 0xa1, 0xb6, 0x31, 0xbf, 0x07, 0x23, 0x81, 0x80, 0x89, 0x7d, 0x79, 0x52, 0xa5,
	0xb5, 0x40, 0x30, 0xb7, 0x67, 0x4b, 0x1c, 0x5b, 0xfd, 0x65, 0xad, 0x61, 0x38, 0x93, 0xcd, 0xd5,
	0xa5, 0x45, 0x26, 0x55, 0x21, 0x2c, 0x39, 0x1c, 0xb7, 0xd0, 0x87, 0x3c, 0xa2, 0xfa, 0x53, 0x57,
	0x14, 0x0d, 0x7e, 0xe4, 0x22, 0x88, 0x8f, 0x86, 0x62, 0xbd, 0xa5, 0x82, 0xa3, 0x64, 0x70, 0xcb,
	0x4b, 0xcf, 0xb0, 0x81, 0x61, 0x5f, 0xee, 0xa1, 0xbb, 0xcc, 0xcb, 0x68, 0x84, 0x03, 0x73, 0x7c,
	0x9b, 0x67, 0xbd, 0x12, 0x09, 0xe8, 0x7c, 0xb5, 0x34, 0x2e, 0xc2, 0xa8, 0x82, 0xa9, 0xbb, 0x2f,
	0x2e, 0x2b, 0x03, 0x7f, 0xf7, 0x2d, 0xfe, 0x2a, 0xb8, 0xa1, 0x18, 0xc4, 0x74, 0xac, 0x0a, 0xfe,
	0xdd, 0x7d, 0xcb, 0x55, 0x84, 0x34, 0x88, 0xbe, 0xd5, 0x2a, 0xe2, 0xb8, 0x40, 0xa7, 0xa9, 0xc2,
	0xc0, 0xdf, 0x9d, 0x3f, 0x89, 0xa0, 0xbe, 0xe5, 0x2a, 0x98, 0xa0, 0xbe, 0xbd, 0x2a, 0xa8, 0x0c,
	0xa0, 0xc4, 0x27, 0x69, 0xaa, 0x92, 0xe5, 0x74, 0x25, 0xd2, 0x70, 0x9d, 0xa0, 0xe8, 0x3a, 0x1e,
	0x14, 0x2e, 0x72, 0x61, 0xfd, 0x02, 0xaa, 0x61, 0x02, 0xfb, 0x76, 0xab, 0xf9, 0x07, 0x05, 0x1e,
	0xce, 0xa9, 0xb6, 0xa9, 0xa5, 0x7e, 0xf4, 0x1e, 0xf9, 0xda, 0xd5, 0xbc, 0xf6, 0xb5, 0x3f, 0x70,
	0xbd, 0xa6, 0x7e, 0x35, 0xef, 0x74, 0xa2, 0x03, 0x15, 0xee, 0xf8, 0xb1, 0xeb, 0x35, 0xed, 0x24,
	0x36, 0x79, 0x1f, 0x26, 0x34, 0x90, 0xd2, 0xd6, 0x78, 0xce, 0x08, 0x9d, 0xdc, 0x6d, 0xda, 0x26,
	0xa6, 0xf5, 0x57, 0x05, 0x98, 0xca, 0x48, 0x4a, 0x8c, 0xc6, 0x0c, 0x3c, 0x05, 0xa9, 0x85, 0x4a,
	0x24, 0x4c, 0xc2, 0xc8, 0x12, 0xc6, 0x26, 0xa9, 0x10, 0x31, 0x5a, 0xbe, 0x96, 0x40, 0xb9, 0xa8,
	0xa5, 0xee, 0xca, 0x4e, 0x9a, 0xac, 0xa3, 0x93, 0x10, 0x20, 0x6e, 0x89, 0x30, 0x1b, 0xd7, 0x98,
	0x4a, 0xab, 0x65, 0x5f, 0x7e, 0x29, 0xe9, 0x9f, 0xb5, 0x6a, 0xac, 0xdf, 0x28, 0xc2, 0xb9, 0x8c,
	0xfe, 0xd7, 0x68, 0xf4, 0xd7, 0x21, 0x82, 0x44, 0x0e, 0xec, 0xfe, 0x5f, 0x50, 0x0e, 0x6c, 0xeb,
	0x3f, 0x15, 0xe1, 0xdc, 0x4e, 0x3b, 0xc4, 0x17, 0x56, 0xab, 0xde, 0x13, 0xea, 0x45, 0x7e, 0xf0,
	0x0c, 0x5f, 0x85, 0x90, 0x77, 0x60, 0x70, 0x85, 0xb6, 0x5a, 0xbe, 0x98, 0xff, 0x97, 0xa4, 0x77,
	0x44, 0x12, 0x1b, 0x91, 0x56, 0xfa, 0x6c, 0x8e, 0x4d, 0xde, 0x87, 0xd1, 0x15, 0xea, 0x04, 0xd1,
	0x1e, 0x75, 0xe4, 0x91, 0x45, 0x66, 0xb2, 0xd0, 0x48, 0x04, 0xc2, 0x4a, 0x9f, 0x1d, 0x63, 0x93,
	0x79, 0x76, 0x9a, 0xf7, 0xf6, 0xd5, 0x6b, 0xf2, 0x9c, 0x0a, 0x19, 0xce, 0x4a, 0x9f, 0x8d, 0xb8,
	0x64, 0x1d, 0x26, 0xaa, 0xfb, 0xd4, 0x8b, 0xd6, 0x69, 0xe4, 0x34, 0x9d, 0xc8, 0x11, 0xaa, 0xed,
	0xab, 0x79, 0xc4, 0x06, 0xf2, 0x4a, 0x9f, 0x6d, 0x52, 0x93, 0x0f, 0x61, 0xf8, 0x9e, 0xef, 0x37,
	0xf7, 0x9e, 0x51, 0xa1, 0xae, 0x56, 0xf2, 0x18, 0x09, 0xb4, 0x95, 0x3e, 0x5b, 0x52, 0x2c, 0x0c,
	0x42, 0xff, 0x7a, 0xb8, 0x6f, 0x1d, 0x15, 0xa0, 0xbc, 0xe4, 0x3f, 0xf5, 0x32, 0xa5, 0xfa, 0x3d,
	0x53, 0xaa, 0x92, 0x7d, 0x06, 0x7e, 0x42, 0xae, 0x6f, 0xc3, 0xc0, 0x96, 0xeb, 0xed, 0x27, 0x54,
	0xc1, 0x0c, 0x3a, 0x86, 0x85, 0xe2, 0x71, 0xbd, 0x7d, 0xb2, 0x26, 0x75, 0x70, 0x61, 0x6b, 0xec,
	0x37, 0x14, 0xff, 0x0c, 0x6a, 0x1d, 0x3b, 0xd6, 0xb5, 0xf9, 0x6f, 0xd9, 0xc1, 0x37, 0x60, 0x36,
	0xa7, 0x5e, 0xf1, 0x3c, 0x9c, 0xf5, 0x6d, 0x00, 0x15, 0x9b, 0xd7, 0x61, 0x26, 0x73, 0xfc, 0x52,
	0x88, 0xff, 0x34, 0x6b, 0x22, 0xf2, 0x9e, 0x97, 0x61, 0x58, 0x66, 0x4b, 0xe2, 0xb6, 0x1f, 0xf9,
	0x13, 0x1f, 0x48, 0xc9, 0x0f, 0x55, 0x06, 0xf6, 0x90, 0xdf, 0xe3, 0xae, 0x16, 0x48, 0x89, 0x7f,
	0x4e, 0x1f, 0xbc, 0xc0, 0x47, 0xa3, 0x78, 0xb1, 0x3a, 0x57, 0xfc, 0x30, 0xf2, 0x94, 0xe7, 0xad,
	0xad, 0x7e, 0x93, 0x1b, 0x50, 0x92, 0xe9, 0x1c, 0x44, 0xde, 0x18, 0x91, 0xb1, 0xdb, 0x4e, 0xc1,
	0xc9, 0x7b, 0x30, 0x9b, 0x84, 0xc9, 0x5e, 0xf2, 0x17, 0x6e, 0x79, 0xc5, 0xd6, 0x9f, 0x15, 0x31,
	0xd6, 0x75, 0x97, 0x79, 0xcd, 0xa4, 0xbb, 0x59, 0x13, 0xd2, 0x2a, 0x6e, 0xd6, 0xc8, 0x45, 0x18,
	0xdd, 0xac, 0x19, 0x29, 0xa7, 0xec, 0x18, 0xc0, 0x9a, 0xcd, 0xba, 0x50, 0x0d, 0x1a, 0x07, 0x6e,
	0x44, 0x1b, 0x51, 0x27, 0x10, 0xab, 0xb0, 0x9d, 0x82, 0x13, 0x0b, 0xc6, 0xef, 0xb5, 0xdc, 0xbd,
	0x86, 0x64, 0xc6, 0x45, 0x60, 0xc0, 0xc8, 0x6b, 0x30, 0xb9, 0xea, 0x85, 0x91, 0xd3, 0x6a, 0xad,
	0xd3, 0xe8, 0xc0, 0x6f, 0x8a, 0xa4, 0x99, 0x76, 0x02, 0xca, 0xea, 0x5d, 0xf4, 0xbd, 0xc8, 0x71,
	0x3d, 0x1a, 0xd8, 0x1d, 0x2f, 0x72, 0x0f, 0xa9, 0xe8, 0x7b, 0x0a, 0x4e, 0xde, 0x86, 0x19, 0x05,
	0xdb, 0x0c, 0x1a, 0x07, 0x34, 0x8c, 0x02, 0x4c, 0x44, 0x87, 0x01, 0x7f, 0xec, 0xec, 0x42, 0xac,
	0xa1, 0xe5, 0x77, 0x9a, 0xcb, 0xde, 0x13, 0x37, 0xf0, 0x3d, 0xcc, 0x4d, 0x31, 0x22, 0x6a, 0x48,
	0xc0, 0xad, 0xdf, 0x1f, 0xc9, 0xfc, 0x6c, 0x5f, 0x64, 0x0e, 0x7e, 0x01, 0xe3, 0x8b, 0x4e, 0xdb,
	0xd9, 0x73, 0x5b, 0x6e, 0xe4, 0xaa, 0x8c, 0x5d, 0xef, 0xf4, 0xf8, 0xe6, 0x65, 0x82, 0x0f, 0xda,
	0xd4, 0x89, 0x6d, 0x83, 0xd5, 0xdc, 0x5f, 0x0e, 0xc1, 0x4c, 0x26, 0x1e, 0xb9, 0x2e, 0x52, 0x7b,
	0xa9, 0x75, 0x55, 0x24, 0xbb, 0xb2, 0x93, 0x60, 0x36, 0x96, 0x08, 0x5a, 0x6c, 0x51, 0xc7, 0xeb,
	0x88, 0x54, 0x57, 0xb6, 0x01, 0x63, 0x63, 0xc9, 0xf4, 0x06, 0x8d, 0x19, 0x3a, 0x4e, 0xdb, 0x09,
	0x28, 0xb9, 0x02, 0x63, 0x0c, 0x22, 0x59, 0x0d, 0xf0, 0x27, 0x7e, 0x1a, 0x88, 0x71, 0xda, 0xf0,
	0x9b, 0x54, 0xe3, 0x34, 0xc8, 0x39, 0x99, 0x50, 0xc6, 0x89, 0x41, 0x24, 0xa7, 0x21, 0xce, 0x49,
	0x03, 0x91, 0x57, 0x60, 0xa2, 0xda, 0x6e, 0x6b, 0x8c, 0x30, 0xc7, 0x95, 0x6d, 0x02, 0xc9, 0x65,
	0x80, 0x6a, 0xbb, 0x2d, 0xd9, 0x60, 0xfe, 0x2a, 0x5b, 0x83, 0x90, 0x9b, 0x71, 0xb8, 0x32, 0x8d,
	0x15, 0x5e, 0x27, 0xd8, 0x19, 0x25, 0x4c, 0xae, 0x2a, 0xb6, 0x93, 0x60, 0x0a, 0x5c, 0xae, 0x09,
	0x30, 0xf9, 0x08, 0xce, 0x27, 0xfc, 0x2e, 0xb4, 0x0a, 0xd0, 0xd4, 0x6f, 0xe7, 0x23, 0x90, 0x77,
	0xe1, 0x5c, 0xa2, 0x50, 0x56, 0x87, 0x56, 0x7d, 0x3b, 0xa7, 0x94, 0x7c, 0x00, 0xe5, 0xc4, 0xb3,
	0xed, 0xb8, 0x52, 0xb4, 0xe0, 0xdb, 0xb9, 0xe5, 0xec, 0xeb, 0x4a, 0xbc, 0xff, 0x12, 0x55, 0xe2,
	0x65, 0xa5, 0x9d, 0x5d, 0x48, 0x56, 0xa0, 0x92, 0xe9, 0xcb, 0xa2, 0x55, 0x8c, 0x79, 0xb9, 0xec,
	0x5e, 0x68, 0x64, 0x01, 0x2e, 0x66, 0xa2, 0xc8, 0x66, 0x60, 0xb6, 0x2e, 0xbb, 0x2b, 0x0e, 0x99,
	0x87, 0xe9, 0xd8, 0xa7, 0x47, 0x6b, 0x02, 0x26, 0xea, 0xb2, 0x33, 0xcb, 0xc8, 0x9b, 0xe6, 0xe3,
	0x7c, 0x5e, 0x19, 0xe6, 0xe9, 0xb2, 0xd3, 0x05, 0xd6, 0x71, 0x01, 0x2e, 0x66, 0x6e, 0x94, 0x52,
	0x9f, 0x9f, 0x4b, 0x2a, 0x8e, 0xda, 0x5a, 0x70, 0x03, 0x06, 0x50, 0xc1, 0xe7, 0xb6, 0x62, 0xe9,
	0x6b, 0x8a, 0xf4, 0x9c, 0x15, 0x2b, 0xb5, 0x11, 0x87, 0xdc, 0x53, 0x77, 0x83, 0xfd, 0x68, 0xc9,
	0xb8, 0x95, 0x54, 0xa0, 0x32, 0x2a, 0xd7, 0xef, 0x08, 0xe5, 0x6d, 0xe0, 0x8b, 0x5c, 0xc3, 0xfc,
	0x59, 0x01, 0x2a, 0x3d, 0xf4, 0x03, 0xd5, 0xa7, 0xc2, 0x09, 0xfa, 0x74, 0x5f, 0xf5, 0x89, 0xbf,
	0x8d, 0x9d, 0x3f, 0x99, 0x0e, 0xf2, 0xb2, 0xbb, 0xf5, 0x2f, 0x0b, 0x40, 0xd2, 0x7a, 0x28, 0xf9,
	0x2e, 0x8c, 0xd6, 0x6a, 0x2b, 0x86, 0x47, 0x5f, 0xea, 0x76, 0x28, 0xc6, 0x20, 0xb7, 0x4f, 0xe4,
	0xc2, 0xa7, 0x3b, 0xf0, 0x7d, 0x92, 0xf2, 0x1b, 0xec, 0xef, 0xea, 0x37, 0x98, 0xf4, 0x1a, 0xb4,
	0x96, 0xa0, 0x9c, 0xa7, 0x83, 0xe2, 0xd2, 0xc4, 0xa3, 0x73, 0x69, 0x57, 0x53, 0x7c, 0x69, 0x32,
	0xc1, 0xd6, 0xbb, 0x70, 0x4e, 0x51, 0xf3, 0xb4, 0x1f, 0x5a, 0xe8, 0x00, 0x71, 0x70, 0x55, 0x21,
	0x0a, 0x62, 0x80, 0xf5, 0xa7, 0x03, 0x29, 0xc2, 0x5a, 0xe7, 0xf0, 0xd0, 0x09, 0x9e, 0x91, 0xaa,
	0x49, 0xd8, 0xdf, 0xf3, 0xac, 0xb0, 0x30, 0xf0, 0xd3, 0xa3, 0x4a, 0x9f, 0xc6, 0x9d, 0x2d, 0xe8,
	0xa8, 0x1a, 0x78, 0x0d, 0xca, 0x2f, 0xb5, 0x8a, 0x3c, 0x3c, 0x92, 0x01, 0x24, 0xbb, 0x30, 0x21,
	0x36, 0x5d, 0xfc, 0x2d, 0x3f, 0x8e, 0xdb, 0xc9, 0x8f, 0xc3, 0x68, 0xde, 0x4d, 0x83, 0x84, 0x4f,
	0x23, 0x93, 0x0d, 0xf9, 0x02, 0x26, 0xa5, 0x8a, 0x25, 0x18, 0x73, 0x37, 0xa4, 0x3b, 0xdd, 0x19,
	0x9b, 0x34, 0x9c, 0x73, 0x82, 0x11, 0x6b, 0xb2, 0x5c, 0xa5, 0x38, 0xe7, 0xc1, 0x93, 0x34, 0xd9,
	0x20, 0x11, 0x4d, 0x36, 0x60, 0x73, 0x9f, 0x02, 0x49, 0xf7, 0xab, 0xd7, 0x77, 0x30, 0xa1, 0x7d,
	0x07, 0x73, 0x55, 0x98, 0xca, 0xe8, 0xc0, 0xa9, 0x58, 0x7c, 0x0a, 0x24, 0xdd, 0xd2, 0xd3, 0x70,
	0xb0, 0xae, 0xc3, 0x6b, 0x4a, 0x04, 0x6a, 0x36, 0x18, 0x3c, 0xa5, 0xe9, 0xfa, 0xd7, 0x8b, 0x50,
	0xe9, 0x81, 0x4a, 0x7e, 0xaf, 0x90, 0x94, 0x36, 0x9f, 0x8d, 0xef, 0x27, 0xa5, 0x9d, 0x4d, 0x9f,
	0x21, 0xf6, 0x85, 0x0f, 0x7e, 0xf2, 0x17, 0xcf, 0x7d, 0x64, 0x48, 0x0f, 0xd9, 0xe9, 0xa5, 0x35,
	0xa0, 0x4b, 0xcb, 0x86, 0x69, 0xe3, 0xb0, 0x75, 0x92, 0x5d, 0xe7, 0x32, 0x80, 0x48, 0x12, 0xba,
	0xe6, 0xef, 0x0b, 0x05, 0x4f, 0x83, 0x58, 0x77, 0x61, 0x26, 0xc1, 0x53, 0x98, 0xd3, 0xbf, 0x0b,
	0xea, 0x89, 0x38, 0x32, 0xed, 0x5f, 0x38, 0xfb, 0xf3, 0xa3, 0xca, 0x04, 0xd3, 0xc5, 0x6f, 0xc6,
	0x11, 0xe8, 0xe5, 0x5f, 0xd6, 0xba, 0x7e, 0x21, 0x50, 0x6d, 0xe9, 0xa1, 0x73, 0xc8, 0x1d, 0x18,
	0xe2, 0x90, 0x44, 0x9c, 0x67, 0x1d, 0x5b, 0xac, 0x09, 0x02, 0xd1, 0x9a, 0xc1, 0x07, 0xad, 0xf8,
	0xa3, 0x1a, 0x07, 0x60, 0xb0, 0x76, 0x78, 0xde, 0x93, 0x18, 0xac, 0x62, 0x49, 0x0f, 0x54, 0xe3,
	0x40, 0x11, 0xd2, 0x7b, 0x43, 0xe2, 0x79, 0xfe, 0xd3, 0x16, 0x6d, 0xf2, 0x9c, 0x72, 0x0b, 0xe3,
	0xc2, 0x7b, 0x63, 0xc0, 0x61, 0x0c, 0x90, 0xcc, 0xfa, 0x04, 0x66, 0xd8, 0x16, 0x1f, 0x24, 0xeb,
	0xc3, 0x6c, 0x07, 0x0c, 0x66, 0xba, 0xc4, 0x3b, 0x0c, 0x84, 0x2e, 0xf1, 0xa2, 0xd0, 0x5a, 0x83,
	0xf3, 0xdc, 0x9c, 0xa8, 0x77, 0x29, 0x36, 0xde, 0x0f, 0xe2, 0xef, 0xc4, 0x73, 0xc8, 0x8c, 0xde,
	0x73, 0x3c, 0xeb, 0x63, 0x7c, 0x6f, 0x23, 0x26, 0xa9, 0xeb, 0x7b, 0xb1, 0xed, 0xf0, 0x64, 0x0f,
	0x74, 0xff, 0x7f, 0xb8, 0x58, 0x6d, 0xb7, 0xa9, 0xd7, 0x8c, 0x09, 0xb7, 0x03, 0xe7, 0x84, 0xe1,
	0x13, 0x48, 0x15, 0x06, 0x11, 0x5b, 0xdd, 0x7c, 0x8a, 0xe6, 0x66, 0x34, 0x07, 0xf1, 0x44, 0xe0,
	0x4f, 0xac, 0x80, 0x53, 0x5a, 0x4d, 0x98, 0xad, 0x75, 0xf6, 0x0e, 0xdd, 0x08, 0x1d, 0xe9, 0x31,
	0x04, 0x89, 0xac, 0x7b, 0x55, 0xa6, 0xaa, 0xe2, 0xc2, 0xb8, 0x1e, 0xbf, 0xcb, 0x40, 0x5f, 0x7c,
	0x11, 0x96, 0xe4, 0xc9, 0x9d, 0x9b, 0x31, 0x29, 0xda, 0x4d, 0x78, 0x2d, 0x58, 0x2c, 0xd2, 0x59,
	0x59, 0x53, 0x70, 0x56, 0xbf, 0x45, 0xe2, 0x33, 0x64, 0x06, 0xa6, 0xcc, 0xdb, 0x21, 0x0e, 0xfe,
	0x1a, 0xa6, 0xb9, 0xf5, 0x9a, 0x07, 0xee, 0x9e, 0x8f, 0x63, 0x54, 0x17, 0x77, 0xe7, 0x13, 0x1e,
	0xfc, 0xe8, 0xd8, 0xab, 0x52, 0x32, 0xec, 0xce, 0xf3, 0x37, 0x93, 0x4f, 0xe6, 0x8d, 0x3b, 0xc8,
	0xe2, 0xee, 0xfc, 0xc2, 0xb0, 0x08, 0x80, 0xca, 0xb8, 0xf3, 0xe1, 0xff, 0x56, 0xb8, 0xcf, 0xe3,
	0x33, 0xfd, 0x15, 0xea, 0xe0, 0x93, 0x9a, 0xec, 0xc7, 0xce, 0x93, 0x50, 0x74, 0x9b, 0xf2, 0xbc,
	0xef, 0x36, 0xad, 0x3f, 0x2a, 0xc0, 0x75, 0xae, 0x45, 0x65, 0xd3, 0xe1, 0x55, 0x51, 0x0e, 0x31,
	0x79, 0x0f, 0x78, 0xde, 0x77, 0xa1, 0xaa, 0x5a, 0xa2, 0xe5, 0xdd, 0x38, 0x71, 0x02, 0x52, 0x85,
	0x71, 0xfd, 0x51, 0xca, 0xc9, 0x02, 0xcc, 0xd9, 0x63, 0x87, 0x8f, 0x1c, 0xf5, 0x50, 0xe5, 0x31,
	0x5c, 0x58, 0xfe, 0x86, 0x4d, 0x08, 0xb1, 0x3b, 0x09, 0x95, 0x3f, 0x7e, 0x4c, 0x7b, 0x66, 0x5b,
	0xcc, 0x18, 0xf3, 0x3c, 0x9e, 0x04, 0xb3, 0xc3, 0xad, 0xdc, 0xe0, 0x94, 0xde, 0x3d, 0x6a, 0x1b,
	0x30, 0xeb, 0x4f, 0x0b, 0x70, 0x31, 0xbb, 0x36, 0xb1, 0xb0, 0xac, 0xc2, 0xd9, 0x45, 0xc7, 0xf3,
	0x3d, 0xb7, 0xe1, 0xb4, 0x6a, 0x8d, 0x03, 0xda, 0xec, 0xa8, 0x30, 0xa9, 0x6a, 0x95, 0xd9, 0xa7,
	0x9e, 0x24, 0x97, 0x28, 0x76, 0x9a, 0x8a, 0x1d, 0xeb, 0xf0, 0x5d, 0x03, 0x5f, 0x7b, 0x5b, 0x34,
	0x50, 0xfc, 0x78, 0xcb, 0x72, 0x4a, 0xc9, 0x6d, 0x69, 0xa6, 0x6f, 0xee, 0x78, 0x6e, 0xa4, 0x88,
	0xb8, 0x7d, 0x26, 0xab, 0xc8, 0xfa, 0x0f, 0x05, 0x38, 0x8f, 0x99, 0x91, 0x8c, 0x5c, 0x8b, 0x71,
	0xb4, 0x60, 0x19, 0xf0, 0xb6, 0x60, 0xbc, 0xd3, 0x30, 0xb0, 0xcd, 0xc8, 0xb7, 0xe4, 0x4d, 0x18,
	0xa8, 0x49, 0x37, 0xab, 0xc9, 0x44, 0x22, 0x5b, 0x41, 0xc1, 0xca, 0x6d, 0xc4, 0x62, 0x7b, 0xce,
	0x12, 0x0d, 0x1b, 0xd4, 0xc3, 0x8c, 0xc3, 0xdc, 0x5c, 0xa0, 0x41, 0xe2, 0x60, 0x47, 0x03, 0x79,
	0xc1, 0x8e, 0x06, 0xcd, 0x60, 0x47, 0xd6, 0x13, 0x9e, 0x17, 0x29, 0xd9, 0x21, 0x31, 0x48, 0x1f,
	0xa7, 0x12, 0x14, 0xf3, 0x7d, 0xe0, 0x5c, 0x56, 0xcf, 0x98, 0x66, 0x9d, 0xc8, 0x3d, 0x9c, 0x1f,
	0x9d, 0x77, 0x0b, 0x5e, 0x31, 0x70, 0xab, 0xad, 0x96, 0xff, 0x94, 0x36, 0xb7, 0x02, 0xff, 0xd0,
	0x8f, 0x8c, 0xbc, 0x30, 0x22, 0x43, 0x77, 0x7c, 0x11, 0x23, 0x66, 0x65, 0x02, 0x6c, 0xfd, 0x7f,
	0xf0, 0x6a, 0x0f, 0x8e, 0xa2, 0x53, 0x35, 0x38, 0xeb, 0x24, 0xca, 0xa4, 0xbf, 0xcc, 0xab, 0x59,
	0xfd, 0x4a, 0x32, 0x0a, 0xed, 0x34, 0xfd, 0x8d, 0x6d, 0x23, 0xa9, 0x2f, 0x29, 0xc3, 0xf4, 0x96,
	0xbd, 0xb9, 0xb4, 0xb3, 0xb8, 0x5d, 0xdf, 0xfe, 0x62, 0x6b, 0xb9, 0xbe, 0xb3, 0xf1, 0x60, 0x63,
	0xf3, 0xe1, 0x06, 0x0f, 0x6f, 0x6d, 0x94, 0x6c, 0x2f, 0x57, 0xd7, 0x4b, 0x05, 0x32, 0x0d, 0x25,
	0x03, 0xbc, 0xbc, 0xb3, 0x50, 0x2a, 0xde, 0xf8, 0xda, 0x48, 0x56, 0x4b, 0x2e, 0x42, 0xb9, 0xb6,
	0xb3, 0xb5, 0xb5, 0x69, 0x2b, 0xae, 0x7a, 0x70, 0xed, 0x19, 0x38, 0x6b, 0x94, 0xde, 0xb5, 0x97,
	0x97, 0x4b, 0x05, 0xd6, 0x14, 0x03, 0xbc, 0x65, 0x2f, 0xaf, 0xaf, 0xee, 0xac, 0x97, 0x8a, 0x37,
	0xea, 0xfa, 0xe3, 0x30, 0x72, 0x01, 0x66, 0x97, 0x96, 0x77, 0x57, 0x17, 0x97, 0xb3, 0x78, 0x4f,
	0x43, 0x49, 0x2f, 0xdc, 0xde, 0xdc, 0xde, 0xe2, 0xac, 0x75, 0xe8, 0xc3, 0xe5, 0x85, 0xea, 0xce,
	0xf6, 0xca, 0x46, 0xa9, 0xdf, 0x1a, 0x18, 0x29, 0x96, 0x8a, 0x37, 0x7e, 0x68, 0xbc, 0x1c, 0x63,
	0xcd, 0x17, 0xe8, 0x3b, 0xb5, 0xea, 0xbd, 0xfc, 0x2a, 0x78, 0xe9, 0xfa, 0xdd, 0x6a, 0xa9, 0x40,
	0x2e, 0xc1, 0x79, 0x03, 0xba, 0x55, 0xad, 0xd5, 0x1e, 0x6e, 0xda, 0x4b, 0x6b, 0xcb, 0xb5, 0x5a,
	0xa9, 0x78, 0x63, 0xd7, 0x08, 0xf0, 0xc6, 0x6a, 0x58, 0xbf, 0x5b, 0xad, 0xdb, 0xcb, 0x9f, 0xed,
	0xac, 0xda, 0xcb, 0x4b, 0xe9, 0x1a, 0x8c, 0xd2, 0x2f, 0x96, 0x6b, 0xa5, 0x02, 0x99, 0x82, 0x33,
	0x06, 0x74, 0x63, 0xb3, 0x54, 0xbc, 0xf1, 0x9a, 0x88, 0x01, 0x46, 0x26, 0x01, 0x96, 0x96, 0x6b,
	0x8b, 0xcb, 0x1b, 0x4b, 0xab, 0x1b, 0xf7, 0x4a, 0x7d, 0x64, 0x02, 0x46, 0xab, 0xea, 0x67, 0xe1,
	0xc6, 0x07, 0x70, 0x26, 0x71, 0x26, 0x67, 0x18, 0xea, 0x34, 0x5b, 0xea, 0x43, 0xf1, 0xcb, 0x9f,
	0x68, 0x18, 0xe5, 0xc7, 0xeb, 0x52, 0xe1, 0xc6, 0x82, 0x4c, 0x9e, 0xaa, 0x7d, 0xe7, 0x64, 0x0c,
	0x86, 0x97, 0x96, 0xef, 0x56, 0x77, 0xd6, 0xb6, 0x4b, 0x7d, 0xec, 0xc7, 0xa2, 0xbd, 0x5c, 0xdd,
	0x5e, 0x5e, 0x2a, 0x15, 0xc8, 0x28, 0x0c, 0xd6, 0xb6, 0xab, 0xdb, 0xcb, 0xa5, 0x22, 0x19, 0x81,
	0x81, 0x9d, 0xda, 0xb2, 0x5d, 0xea, 0x9f, 0xff, 0xb7, 0xbf, 0x57, 0xe0, 0xd6, 0x41, 0xf9, 0x0a,
	0xe9, 0x6b, 0xed, 0x30, 0x29, 0x96, 0x3c, 0x91, 0x29, 0x32, 0xf7, 0xe4, 0x88, 0x5a, 0xc0, 0x5c,
	0x97, 0xeb, 0x12, 0x44, 0xb8, 0x5e, 0xb8, 0x5d, 0x20, 0x36, 0xba, 0x97, 0x24, 0xce, 0x56, 0x8a,
	0x73, 0xf6, 0xf1, 0x77, 0xee, 0x52, 0xd7, 0x23, 0x19, 0xf9, 0x15, 0xb0, 0x74, 0x9e, 0x39, 0x27,
	0x90, 0xef, 0x9e, 0xec, 0xa4, 0x21, 0xeb, 0x7c, 0xed, 0x64, 0xe8, 0xe4, 0x3e, 0x4c, 0x30, 0xdd,
	0x5c, 0xa1, 0x91, 0x0b, 0x49, 0x42, 0xed, 0x38, 0x30, 0x77, 0x31, 0xbb, 0x50, 0x25, 0x73, 0x19,
	0xc7, 0x8e, 0xf0, 0x83, 0x75, 0x48, 0x64, 0x9c, 0x08, 0x09, 0xe1, 0x2b, 0xfe, 0xdc, 0xd9, 0x04,
	0x78, 0xf7, 0xce, 0xed, 0x02, 0xa9, 0x61, 0x90, 0x36, 0x43, 0xc9, 0x27, 0xf2, 0x59, 0x5c, 0x5a,
	0xfb, 0xe7, 0xad, 0xa9, 0xa8, 0xd4, 0x8b, 0x39, 0xa7, 0x83, 0x0d, 0x20, 0x69, 0xdd, 0x99, 0x5c,
	0x89, 0xe7, 0x41, 0xb6, 0x5a, 0x3d, 0x77, 0x2e, 0xe5, 0x35, 0xb8, 0xcc, 0xb4, 0x27, 0xb2, 0x0c,
	0x93, 0xe2, 0x11, 0xb8, 0xd0, 0xe6, 0x49, 0xb7, 0xf3, 0x40, 0x2e, 0x9b, 0x7b, 0x28, 0x27, 0x75,
	0x22, 0x20, 0x73, 0x71, 0x3f, 0x92, 0xc7, 0x84, 0xb9, 0x0b, 0x99, 0x65, 0xa2, 0x7f, 0x77, 0x61,
	0xd2, 0x3c, 0x5c, 0x10, 0x39, 0x40, 0x99, 0x67, 0x8e, 0xdc, 0x06, 0xd5, 0x61, 0x76, 0xdd, 0x71,
	0xf1, 0x92, 0x43, 0xf8, 0xa6, 0x49, 0xcf, 0x32, 0x52, 0xe9, 0xe2, 0x6a, 0x56, 0xa3, 0x5e, 0x53,
	0x0d, 0x42, 0x5e, 0x60, 0x76, 0xfc, 0x6c, 0x6a, 0x52, 0x47, 0x36, 0x3d, 0xf3, 0x88, 0x65, 0xa6,
	0xd3, 0xcd, 0x72, 0xb6, 0x9c, 0xcb, 0xf3, 0x0f, 0x26, 0xeb, 0xa8, 0xa4, 0x27, 0x38, 0x6a, 0x73,
	0xe2, 0xd4, 0xec, 0xca, 0x18, 0x8a, 0x40, 0x4b, 0x43, 0x2e, 0x0a, 0x43, 0x92, 0x23, 0xb8, 0x5c,
	0x66, 0xb7, 0x0b, 0xe4, 0x6b, 0xfc, 0xaa, 0x33, 0xd9, 0x3d, 0x74, 0xa3, 0x03, 0xa1, 0xfd, 0x5c,
	0xc8, 0x64, 0x20, 0x3e, 0x94, 0x2e, 0xdc, 0x6d, 0x98, 0xce, 0x72, 0x49, 0x56, 0x02, 0xed, 0xe2,
	0xaf, 0x9c, 0x3b, 0x0b, 0x6c, 0x76, 0xd4, 0x68, 0xe6, 0x0f, 0x52, 0x17, 0x8f, 0xd8, 0x5c, 0x9e,
	0x1f, 0xc1, 0x24, 0x9b, 0x25, 0x0f, 0x28, 0x6d, 0x57, 0x5b, 0xee, 0x13, 0x1a, 0x12, 0x19, 0x61,
	0x57, 0x81, 0xf2, 0x68, 0xaf, 0x17, 0xc8, 0x77, 0x60, 0xec, 0xa1, 0x13, 0x35, 0x0e, 0x44, 0xa4,
	0x49, 0x19, 0x88, 0x12, 0x61, 0x73, 0xf2, 0x17, 0x16, 0xde, 0x2e, 0x90, 0xef, 0xc3, 0xf0, 0x3d,
	0x1a, 0xe1, 0xb3, 0xe4, 0xab, 0xca, 0x3b, 0x8f, 0xdb, 0x26, 0x57, 0x3d, 0xf5, 0xf6, 0x46, 0x36,
	0x38, 0x69, 0x81, 0x25, 0xb7, 0x00, 0xf8, 0x82, 0x80, 0x1c, 0x92, 0xc5, 0x73, 0xa9, 0x66, 0x93,
	0x7b, 0x4c, 0x79, 0x68, 0xd1, 0x88, 0x9e, 0xb4, 0xca, 0x3c, 0x19, 0xad, 0xc1, 0xa4, 0xca, 0x7f,
	0xb3, 0x81, 0x01, 0x41, 0xac, 0x04, 0xb3, 0xf0, 0x14, 0xdc, 0x3e, 0x60, 0x5f, 0x05, 0x4f, 0xfe,
	0x8a, 0x91, 0x23, 0x70, 0x25, 0x9d, 0xd5, 0xc3, 0x4f, 0xe8, 0x4b, 0xa8, 0x14, 0x22, 0x47, 0xd3,
	0x68, 0x57, 0xfc, 0x30, 0x32, 0x69, 0x15, 0x24, 0x9b, 0xf6, 0x97, 0x61, 0x4e, 0xaf, 0xd7, 0x0c,
	0x75, 0x1c, 0xaf, 0xb9, 0x79, 0x11, 0x94, 0xe7, 0xae, 0x76, 0xc1, 0x10, 0xe7, 0xb7, 0xfe, 0xdf,
	0x2c, 0x16, 0x70, 0x39, 0x59, 0x82, 0x29, 0x59, 0xd7, 0x66, 0x9b, 0x7a, 0xb5, 0xda, 0x0a, 0xe6,
	0x3a, 0x91, 0xbe, 0x20, 0x1a, 0x4c, 0x72, 0x27, 0xe9, 0x22, 0xb6, 0xf5, 0x19, 0x11, 0x22, 0x48,
	0xb7, 0xb8, 0x11, 0xf1, 0xd6, 0x97, 0x19, 0x83, 0xf7, 0x01, 0x37, 0x2a, 0x19, 0xca, 0xff, 0xee,
	0x3c, 0xe9, 0x72, 0x00, 0x9a, 0xcb, 0x39, 0x42, 0xdc, 0x2e, 0x90, 0x2f, 0x80, 0xa4, 0x8f, 0x24,
	0x4a, 0x84, 0xb9, 0xc7, 0x2f, 0x25, 0xc2, 0x2e, 0xe7, 0x99, 0x65, 0x98, 0x52, 0xf1, 0x61, 0xe2,
	0x72, 0x92, 0xd3, 0x96, 0x2e, 0x3b, 0xd8, 0x4c, 0x06, 0x9b, 0xdd, 0xf9, 0x2e, 0x8c, 0x32, 0xe1,
	0xe4, 0x13, 0x98, 0x12, 0x73, 0xdf, 0x68, 0x4f, 0x49, 0x2d, 0x63, 0xe2, 0x70, 0x93, 0xdb, 0x92,
	0xfb, 0x30, 0x53, 0x4b, 0x08, 0x9e, 0x7b, 0xc2, 0x9f, 0x37, 0x59, 0x20, 0xb0, 0x46, 0x23, 0x2e,
	0xf9, 0x6c, 0x5e, 0x0f, 0x80, 0x70, 0xdb, 0x92, 0x64, 0xf7, 0xc4, 0xa5, 0x4f, 0xc9, 0xa5, 0x44,
	0xd3, 0x19, 0x10, 0xd1, 0x70, 0x1d, 0xcc, 0xed, 0xd9, 0x36, 0xcf, 0x80, 0x8c, 0x50, 0xe3, 0x0e,
	0xfd, 0x8a, 0x41, 0x60, 0x5c, 0xc3, 0x8b, 0x71, 0x3c, 0x9f, 0x8b, 0x41, 0x7e, 0x0d, 0xe3, 0xbb,
	0x76, 0x3f, 0x9d, 0x91, 0xef, 0x64, 0x1d, 0xa2, 0x73, 0xce, 0x97, 0x73, 0x6f, 0x9e, 0x0c, 0x59,
	0x9d, 0x87, 0x27, 0xee, 0xd1, 0x68, 0xab, 0xd5, 0xd9, 0x77, 0x31, 0x37, 0x26, 0x51, 0xb6, 0x27,
	0x05, 0x12, 0xd3, 0x5b, 0x86, 0x55, 0x8b, 0x0b, 0x6a, 0xf4, 0x47, 0x64, 0x15, 0x4a, 0x7c, 0x1b,
	0xd1, 0x58, 0x5c, 0x4a, 0xb1, 0x10, 0x28, 0x4e, 0xe0, 0x1c, 0x86, 0xb9, 0xa3, 0x75, 0x8b, 0x3b,
	0x2d, 0x11, 0xf9, 0x69, 0xeb, 0x7a, 0xea, 0x94, 0x01, 0x53, 0x31, 0xef, 0xd9, 0x88, 0xd8, 0x34,
	0xa4, 0x91, 0x0c, 0x24, 0xc3, 0x33, 0xa3, 0x5e, 0x8b, 0x75, 0x86, 0x74, 0x69, 0xbc, 0x82, 0x24,
	0x82, 0x9e, 0xed, 0xbe, 0x45, 0x54, 0xb6, 0xd8, 0x0c, 0xa6, 0xaf, 0x19, 0xaa, 0xcd, 0xe9, 0xf8,
	0xbe, 0x8d, 0x5b, 0x19, 0x06, 0xcf, 0x99, 0x89, 0xdb, 0xc6, 0x7e, 0x4b, 0xaa, 0x09, 0x8d, 0x6a,
	0x77, 0x1e, 0x57, 0x46, 0xb6, 0xd7, 0x32, 0x4d, 0xb8, 0x13, 0x04, 0xd4, 0xe3, 0xc4, 0x79, 0x6a,
	0x4b, 0x16, 0xf5, 0xc7, 0xb8, 0x82, 0x69, 0xd4, 0xfc, 0xc1, 0x5e, 0x2f, 0x16, 0x3c, 0x93, 0xcf,
	0xed, 0x02, 0x79, 0x0f, 0x46, 0x44, 0x1b, 0x19, 0x91, 0xd1, 0xe8, 0xb0, 0x4b, 0xab, 0x91, 0x12,
	0xb8, 0x90, 0xb0, 0xcd, 0x26, 0x4e, 0xde, 0xe8, 0xf3, 0x36, 0xbf, 0xc7, 0xf6, 0xec, 0xe6, 0xf3,
	0x50, 0x2e, 0xca, 0xcd, 0x1b, 0x29, 0xcb, 0x2a, 0x96, 0x8b, 0x04, 0xf5, 0xd8, 0x65, 0x39, 0x13,
	0xa6, 0x7e, 0x63, 0xd4, 0x42, 0x15, 0x7c, 0x4c, 0xa9, 0xdf, 0x06, 0xb8, 0xd7, 0x96, 0xbd, 0x0a,
	0xa5, 0x6a, 0x03, 0x37, 0x94, 0x1a, 0x3d, 0x74, 0xda, 0x07, 0x7e, 0x40, 0xd5, 0xd9, 0x27, 0x59,
	0x20, 0x79, 0xcd, 0x28, 0x05, 0x45, 0x14, 0xac, 0x51, 0x07, 0x43, 0x3b, 0xcf, 0x2a, 0x0d, 0x25,
	0x51, 0x94, 0x4d, 0xd1, 0xe5, 0xac, 0x33, 0xbd, 0xc8, 0x4e, 0x67, 0xad, 0x17, 0x63, 0xf3, 0x01,
	0x2e, 0x18, 0x0a, 0x39, 0x54, 0x3b, 0x84, 0x02, 0xa9, 0x53, 0xa1, 0x7c, 0xbb, 0xa3, 0x50, 0xab,
	0xf2, 0xea, 0x39, 0x16, 0x4b, 0x1e, 0x75, 0x5e, 0xf5, 0xdf, 0x83, 0xc9, 0x65, 0xb6, 0xa0, 0x77,
	0x9a, 0x2e, 0x0f, 0x67, 0x4f, 0xcc, 0xf8, 0xe4, 0xb9, 0x84, 0x2b, 0x32, 0x79, 0x16, 0x92, 0x0a,
	0x0b, 0x82, 0xdc, 0x53, 0x34, 0x98, 0x1c, 0x8f, 0x69, 0xc9, 0x56, 0x64, 0x14, 0xc0, 0x13, 0xbe,
	0x30, 0x19, 0xcc, 0x72, 0xc5, 0xb2, 0xda, 0x6e, 0xb7, 0xa4, 0x65, 0x9b, 0x5f, 0xdc, 0xbf, 0x6a,
	0x9c, 0x44, 0x53, 0xe5, 0x92, 0x77, 0x5a, 0xf7, 0xfc, 0x5c, 0x4b, 0x66, 0x9b, 0xc3, 0x33, 0xa7,
	0xbc, 0xd7, 0x5c, 0x54, 0x01, 0xa8, 0xab, 0xad, 0x56, 0x8a, 0x38, 0x24, 0x6f, 0x98, 0xdc, 0xb3,
	0x70, 0x7a, 0xd5, 0x80, 0x27, 0x7d, 0xae, 0xbc, 0x55, 0xdb, 0x6d, 0xbe, 0x58, 0x5e, 0x56, 0x0b,
	0x86, 0x59, 0x90, 0x3e, 0xe9, 0x27, 0xcb, 0xc5, 0xda, 0x7e, 0x1f, 0xa7, 0x59, 0x9c, 0xf1, 0x96,
	0xe8, 0xe7, 0xe6, 0x64, 0xc2, 0x5f, 0xa5, 0xcb, 0x25, 0x0a, 0xd5, 0x3e, 0x71, 0x26, 0x91, 0xfc,
	0x5f, 0x19, 0x78, 0x12, 0x70, 0xc9, 0xef, 0x72, 0x5e, 0xb1, 0x32, 0xb8, 0x96, 0x92, 0x59, 0xc5,
	0x55, 0x97, 0x73, 0xb2, 0xd5, 0xab, 0x2e, 0xe7, 0xa6, 0x23, 0xbf, 0x0f, 0xa5, 0x64, 0x42, 0x63,
	0xc5, 0x34, 0x27, 0xd3, 0x71, 0xee, 0x98, 0xdc, 0x85, 0x69, 0x7d, 0x44, 0x55, 0xbf, 0xf3, 0x56,
	0xff, 0x3c, 0x3e, 0xdb, 0x30, 0x93, 0x99, 0x7f, 0x58, 0x6d, 0xb1, 0xdd, 0xb2, 0x13, 0xe7, 0x72,
	0xa5, 0x70, 0x2e, 0x3b, 0x05, 0x39, 0x79, 0xc5, 0xb4, 0x1f, 0x64, 0x27, 0x64, 0x9e, 0x7b, 0xb5,
	0x07, 0x96, 0x10, 0xe8, 0xd7, 0xb8, 0x03, 0xa6, 0xea, 0xb8, 0xaa, 0x59, 0x14, 0x72, 0x2a, 0xb0,
	0xba, 0xa1, 0xa8, 0x39, 0x30, 0x9d, 0x51, 0x9c, 0x2f, 0xe2, 0x6b, 0xf9, 0x3c, 0xe3, 0x89, 0xb5,
	0x2b, 0xe3, 0x2c, 0xe7, 0x4a, 0xa6, 0x6b, 0xaa, 0xea, 0x2e, 0x47, 0xd2, 0x39, 0x35, 0x1f, 0x4e,
	0xde, 0xe4, 0x3c, 0x6e, 0x4d, 0x65, 0xfd, 0x31, 0xf2, 0x48, 0x27, 0xad, 0x3f, 0x59, 0xf9, 0xaf,
	0x95, 0x18, 0xba, 0x65, 0x58, 0xe7, 0xbb, 0xf1, 0x57, 0xdc, 0x1c, 0x64, 0x56, 0xa1, 0x9b, 0x83,
	0x32, 0xf9, 0x5f, 0xc9, 0x47, 0xd0, 0x99, 0x3b, 0xfc, 0xee, 0x37, 0x91, 0x08, 0x9b, 0xe8, 0x27,
	0xae, 0xec, 0x24, 0xd9, 0x6a, 0x6e, 0x64, 0xa2, 0xe8, 0x55, 0x3c, 0x94, 0xdf, 0x60, 0x8e, 0x94,
	0xba, 0x64, 0x09, 0xef, 0xae, 0xa6, 0x6c, 0x42, 0x39, 0x1e, 0xcc, 0x44, 0x07, 0x4e, 0x39, 0x94,
	0x52, 0x18, 0xe7, 0x73, 0x73, 0x83, 0x93, 0xd7, 0x53, 0x5f, 0x7a, 0x8e, 0x60, 0xba, 0x56, 0xc1,
	0xd7, 0x73, 0x2d, 0x6e, 0xf3, 0x85, 0xd8, 0x16, 0xac, 0xa7, 0x11, 0x4f, 0xad, 0xe7, 0x19, 0x39,
	0xc6, 0xef, 0xa1, 0x5e, 0xac, 0xe5, 0x09, 0xcf, 0xed, 0xf5, 0xa5, 0x2c, 0x3e, 0x61, 0x7a, 0xc5,
	0xd5, 0xda, 0x25, 0xf5, 0xb4, 0x64, 0xc1, 0x69, 0x56, 0xdc, 0x93, 0x34, 0x2d, 0x8f, 0xcf, 0x12,
	0x8c, 0x69, 0x09, 0xc6, 0xc9, 0x79, 0x43, 0x4c, 0xc6, 0x1e, 0x3a, 0x67, 0x74, 0xce, 0xdc, 0x3e,
	0x17, 0xd1, 0x22, 0xad, 0xd2, 0x94, 0xe7, 0xb6, 0xe2, 0x42, 0x9a, 0x87, 0x61, 0x8d, 0x56, 0x52,
	0xe0, 0xad, 0xb9, 0x98, 0x14, 0x8e, 0xd1, 0xa0, 0xfc, 0x2e, 0x11, 0x5d, 0x34, 0x3d, 0x9a, 0x94,
	0xaf, 0xbf, 0x4e, 0x89, 0x2c, 0xa6, 0x98, 0x6c, 0x45, 0xc6, 0xfc, 0x3b, 0xa7, 0x4c, 0x6b, 0x1a,
	0xb4, 0x8b, 0xa5, 0x63, 0x0b, 0x9f, 0x8e, 0x64, 0x64, 0x5c, 0x57, 0x2b, 0x6c, 0xd7, 0x84, 0xec,
	0x19, 0xba, 0x9b, 0x5a, 0xb3, 0x73, 0x39, 0x76, 0x4d, 0xc1, 0x9e, 0xdb, 0xd2, 0x1f, 0x68, 0x6b,
	0x76, 0x2a, 0xaf, 0x3a, 0xb9, 0x9e, 0x54, 0xdc, 0xf2, 0x52, 0xaf, 0x77, 0xd9, 0x13, 0xa6, 0xb3,
	0x52, 0xb2, 0x6b, 0xe6, 0xe1, 0xdc, 0x7c, 0xed, 0x19, 0x52, 0xb0, 0xe5, 0xfc, 0xcf, 0xe1, 0xd6,
	0x25, 0x41, 0x7b, 0x6e, 0x0b, 0xbf, 0xd4, 0x16, 0xba, 0x44, 0x22, 0x75, 0x75, 0x1c, 0xef, 0x91,
	0x69, 0x3d, 0x97, 0xf7, 0x06, 0x3e, 0x36, 0x4a, 0x67, 0x41, 0x57, 0x9a, 0x4d, 0xb7, 0x1c, 0xe9,
	0x99, 0xd6, 0xe3, 0x99, 0x74, 0x17, 0x19, 0xbf, 0x73, 0x09, 0xdb, 0x6f, 0xaf, 0x86, 0x7d, 0x2d,
	0x17, 0xe3, 0x8c, 0xec, 0xe9, 0x89, 0xc5, 0x38, 0x3f, 0xbf, 0x7a, 0x97, 0x63, 0xd0, 0x99, 0x9a,
	0xbb, 0xef, 0x69, 0xc9, 0xcf, 0xd5, 0x21, 0x28, 0x9d, 0x8f, 0x5d, 0x2d, 0x31, 0x59, 0xb9, 0xd2,
	0x37, 0x99, 0xfe, 0xc3, 0xb5, 0x77, 0x3d, 0x8d, 0x35, 0x99, 0xcb, 0xcf, 0xde, 0xad, 0x96, 0x9b,
	0xcc, 0xbc, 0xd7, 0x1a, 0x43, 0x3d, 0x87, 0xb4, 0x62, 0x98, 0x91, 0xce, 0x5a, 0x31, 0xcc, 0x4c,
	0x3a, 0x7d, 0x0b, 0xad, 0x2e, 0xb6, 0xdf, 0xa2, 0xba, 0xd5, 0x45, 0x4b, 0x4a, 0x9c, 0x30, 0x7a,
	0x90, 0x0f, 0xd1, 0xe4, 0xd1, 0xdd, 0x4e, 0x32, 0x6b, 0x72, 0xd2, 0x3d, 0x4b, 0x46, 0x55, 0xc6,
	0x67, 0x65, 0x63, 0x4f, 0x26, 0x9d, 0x9e, 0x2b, 0xa7, 0x0b, 0x04, 0xfd, 0x3b, 0xd2, 0x6a, 0x82,
	0x0d, 0x2e, 0x9b, 0xd6, 0xa6, 0xfc, 0x36, 0xbf, 0x23, 0x4d, 0x26, 0x06, 0x59, 0x2a, 0xdf, 0x73,
	0x92, 0xec, 0x7b, 0x30, 0x1e, 0xe7, 0x76, 0xde, 0x9d, 0xd7, 0x08, 0x13, 0x09, 0x9f, 0x93, 0x84,
	0xef, 0xc9, 0x6b, 0x15, 0xac, 0xcf, 0x2c, 0xec, 0xae, 0x02, 0x7c, 0x2c, 0x4d, 0x34, 0x46, 0x4b,
	0x53, 0x99, 0xa2, 0xbb, 0xac, 0xdc, 0xe3, 0x7a, 0x42, 0x4a, 0x35, 0x2f, 0x32, 0x52, 0xca, 0xaa,
	0x79, 0x91, 0x95, 0x12, 0x36, 0xbe, 0x76, 0xf8, 0x42, 0xda, 0x23, 0x62, 0xa6, 0x97, 0x8c, 0x66,
	0xa5, 0xf8, 0x5e, 0xce, 0x2b, 0x4e, 0xb2, 0xae, 0x41, 0x29, 0x99, 0x3d, 0x53, 0x1d, 0xe6, 0x72,
	0xd2, 0x9c, 0xaa, 0x13, 0x62, 0x6e, 0xda, 0xcd, 0x2d, 0x69, 0x5c, 0x37, 0xf9, 0x5e, 0xcd, 0x6e,
	0x94, 0xce, 0x3a, 0xdf, 0xda, 0x3e, 0x61, 0x24, 0xd2, 0xd4, 0x8f, 0xd9, 0xa9, 0x44, 0x9d, 0xba,
	0x5a, 0x96, 0x91, 0x7b, 0xd3, 0x95, 0xe1, 0xa2, 0xb2, 0xf3, 0x79, 0xbf, 0x61, 0x9e, 0x7f, 0xbb,
	0x44, 0x5d, 0xef, 0x79, 0x05, 0x4d, 0x7e, 0x09, 0x66, 0x73, 0x02, 0x54, 0x93, 0x57, 0x13, 0x66,
	0xda, 0xec, 0x00, 0xd6, 0x6a, 0x82, 0x64, 0x66, 0xb8, 0x5e, 0x47, 0xdf, 0x05, 0x23, 0x30, 0x44,
	0xea, 0x3e, 0xf0, 0xa1, 0x1b, 0x1d, 0xf0, 0x44, 0xce, 0xda, 0x9a, 0x9b, 0x19, 0x51, 0x82, 0xd4,
	0xf0, 0x20, 0x63, 0x40, 0x33, 0xae, 0x04, 0x33, 0x18, 0xce, 0x65, 0x33, 0x64, 0x6b, 0x07, 0x9b,
	0x0b, 0x19, 0x51, 0x3b, 0xd4, 0x5c, 0xc8, 0x8f, 0xe8, 0x91, 0xdb, 0xcc, 0x2d, 0xa9, 0x60, 0x65,
	0x73, 0xcc, 0x0f, 0xe0, 0x91, 0xcb, 0xf1, 0x3e, 0xe3, 0x98, 0x8a, 0xc9, 0x41, 0x72, 0xd0, 0xbb,
	0xaf, 0x1e, 0xb6, 0xdc, 0xaf, 0x4d, 0xaa, 0x79, 0xad, 0x7d, 0x79, 0xd1, 0x3f, 0x72, 0xdb, 0xb7,
	0x2c, 0xbf, 0xa7, 0xec, 0xf6, 0x9d, 0x74, 0xc7, 0x56, 0x97, 0x67, 0x89, 0xb0, 0x30, 0x46, 0x47,
	0x35, 0xf8, 0x5c, 0x0e, 0x9c, 0x6c, 0xa0, 0x33, 0x52, 0x12, 0xaa, 0x9d, 0x68, 0xb3, 0xe3, 0xce,
	0xe4, 0xf2, 0xe3, 0xf3, 0xd8, 0x88, 0xdb, 0x71, 0x9a, 0x79, 0x9c, 0x08, 0xf8, 0x21, 0xe6, 0xb1,
	0x01, 0x3d, 0xdd, 0x3c, 0x4e, 0x30, 0x34, 0xe7, 0x71, 0xb2, 0x99, 0x49, 0x33, 0x41, 0xee, 0xa8,
	0x26, 0x9b, 0xa9, 0xe6, 0x71, 0x36, 0xc7, 0xfc, 0xf8, 0x2a, 0xb9, 0x1c, 0xd5, 0x3c, 0x36, 0x39,
	0xe6, 0xa0, 0x9f, 0x70, 0x1e, 0x27, 0x2b, 0x31, 0xe7, 0xf1, 0xa9, 0xda, 0xa7, 0xe6, 0x71, 0x76,
	0xfb, 0x4e, 0x3d, 0x8f, 0x13, 0x01, 0x89, 0x8c, 0x8e, 0x66, 0xcd, 0xe3, 0x24, 0x3e, 0x9f, 0xc7,
	0x49, 0x68, 0xc2, 0x32, 0xd3, 0x65, 0x1e, 0x27, 0x29, 0x3f, 0x43, 0x7e, 0x89, 0x60, 0x2a, 0x27,
	0x99, 0xc9, 0xb9, 0x71, 0x58, 0xc8, 0x43, 0xb4, 0x0d, 0x26, 0xe0, 0x27, 0x9b, 0xcd, 0x17, 0xf3,
	0x98, 0xe2, 0x7c, 0xde, 0x95, 0x42, 0x4c, 0x36, 0xd7, 0x34, 0x7c, 0x65, 0xc7, 0x92, 0xe9, 0xd2,
	0xe0, 0x5d, 0x36, 0x6f, 0x9a, 0x5d, 0xf8, 0x76, 0x0b, 0x85, 0xd3, 0x85, 0xaf, 0x3a, 0x07, 0x25,
	0xf9, 0xe6, 0x92, 0x74, 0x9f, 0xdf, 0x9f, 0xcb, 0xdb, 0x91, 0x24, 0xdd, 0x7c, 0xe2, 0x64, 0x75,
	0xea, 0x96, 0xaa, 0x13, 0x56, 0xb2, 0xa5, 0xa7, 0x9d, 0xe7, 0xeb, 0x52, 0x7b, 0x48, 0xc5, 0xd0,
	0x4a, 0x74, 0x5a, 0x9f, 0xeb, 0xb9, 0x25, 0x64, 0x1b, 0x0d, 0xc1, 0x69, 0xb8, 0x66, 0x44, 0xce,
	0x0b, 0xd6, 0xd5, 0x93, 0x6b, 0x2a, 0x1a, 0x90, 0xce, 0x35, 0x2f, 0x54, 0x90, 0xe2, 0x9a, 0xa6,
	0xfe, 0x04, 0x4d, 0x67, 0xe2, 0xc5, 0x97, 0xf7, 0xc8, 0xcf, 0x3f, 0xe7, 0x4c, 0x19, 0x0e, 0x53,
	0x0c, 0x17, 0xfd, 0xd4, 0x3e, 0x12, 0xd7, 0x7f, 0x12, 0x98, 0x2b, 0xfc, 0x2c, 0x7a, 0xf2, 0x09,
	0x94, 0xc4, 0xf2, 0x16, 0x33, 0xc8, 0x42, 0xcc, 0x1d, 0xba, 0x05, 0x69, 0xb1, 0x3b, 0x41, 0x0b,
	0x4e, 0x62, 0xa9, 0x3b, 0x89, 0x24, 0xf2, 0xcd, 0x5a, 0x6c, 0x3b, 0xdc, 0x0e, 0x3a, 0x61, 0x44,
	0x9b, 0x69, 0x73, 0x94, 0xd9, 0x18, 0xe9, 0x56, 0x61, 0xa2, 0xef, 0xce, 0x93, 0x55, 0x5c, 0xdb,
	0x4c, 0x70, 0x37, 0x7b, 0x5d, 0x36, 0x1b, 0x5c, 0x7a, 0x56, 0xd4, 0xd3, 0x22, 0xb3, 0x4d, 0x79,
	0x75, 0xe7, 0x37, 0x4a, 0x89, 0xe8, 0x84, 0xbd, 0xcb, 0x13, 0x11, 0x3f, 0x50, 0x73, 0xdb, 0x61,
	0x2f, 0xc9, 0x24, 0x1f, 0x3b, 0x91, 0x4f, 0x61, 0x54, 0x12, 0xf7, 0x16, 0x48, 0x92, 0x1a, 0x05,
	0xb2, 0x04, 0x13, 0xc6, 0x4b, 0x2e, 0x75, 0xba, 0xc9, 0x7a, 0xdf, 0xd5, 0x65, 0x9c, 0x27, 0x8c,
	0x17, 0x5b, 0x8a, 0x4b, 0xd6, 0x3b, 0xae, 0x5c, 0x2e, 0xdf, 0x87, 0x31, 0x21, 0xd2, 0xae, 0xd2,
	0xc8, 0x37, 0xd6, 0xcd, 0x68, 0x5e, 0xd1, 0x9d, 0xa6, 0x1b, 0x2d, 0xfa, 0xde, 0x23, 0x77, 0xbf,
	0xa7, 0x60, 0xd2, 0x24, 0xbb, 0xf3, 0xe4, 0x2b, 0x4c, 0x7b, 0x2c, 0x93, 0x51, 0xd3, 0xe8, 0xa9,
	0x1f, 0x3c, 0x76, 0xbd, 0xfd, 0x1e, 0x2c, 0xaf, 0x98, 0x2c, 0x93, 0x74, 0xd2, 0xf1, 0xe4, 0x2b,
	0x98, 0xab, 0xe5, 0x33, 0xef, 0xc9, 0xa4, 0xfb, 0xf6, 0x52, 0x83, 0x8b, 0xe8, 0x7a, 0x73, 0xda,
	0xb6, 0x77, 0x65, 0xfa, 0x05, 0x0f, 0xc3, 0x28, 0x0d, 0xfd, 0x0d, 0x3f, 0x68, 0xf6, 0xe6, 0x58,
	0x31, 0x9d, 0x79, 0x13, 0x64, 0x52, 0x18, 0x5f, 0xc0, 0xf9, 0x5a, 0x2e, 0xeb, 0x5e, 0x2c, 0x7a,
	0x69, 0x92, 0x17, 0x50, 0x14, 0xa7, 0x6c, 0x77, 0x57, 0x9e, 0xab, 0xb8, 0xa6, 0xb1, 0x7d, 0x68,
	0x2b, 0xa0, 0x8f, 0x68, 0x80, 0x2e, 0xe3, 0xbd, 0x9c, 0xa5, 0x4d, 0x74, 0xd9, 0xf3, 0x55, 0x38,
	0x5b, 0x4b, 0xb1, 0xca, 0x23, 0xe9, 0x75, 0x79, 0x34, 0x85, 0x3d, 0x3d, 0x61, 0xbb, 0x7a, 0xb8,
	0x18, 0x8d, 0xdd, 0xa3, 0xd1, 0xce, 0x6a, 0x0f, 0x29, 0xc9, 0x37, 0x0d, 0x12, 0x71, 0xf7, 0x0e,
	0xa3, 0xac, 0x69, 0x94, 0x69, 0x8c, 0xdc, 0x8f, 0xf7, 0x53, 0x79, 0x91, 0xd2, 0xb3, 0xda, 0x3c,
	0x0e, 0x6f, 0xe1, 0x5a, 0x28, 0xdc, 0xa6, 0x35, 0x13, 0x24, 0x87, 0xc4, 0xa6, 0x3a, 0xcd, 0x83,
	0x3a, 0x24, 0x55, 0x7e, 0xfc, 0xe3, 0xd3, 0x43, 0xc0, 0x2e, 0xa7, 0xdc, 0xe9, 0xbb, 0xb2, 0xe0,
	0x26, 0xd4, 0x35, 0xbf, 0xf1, 0x58, 0x37, 0xa1, 0x6a, 0x89, 0xf1, 0xe7, 0xcc, 0xb4, 0xf5, 0x62,
	0xc5, 0xc7, 0xdc, 0xf5, 0xba, 0xd7, 0x98, 0x9e, 0x1a, 0x5f, 0x37, 0xa1, 0x9a, 0x49, 0xfc, 0xdf,
	0x92, 0xb6, 0x45, 0xac, 0xd0, 0xe4, 0x9c, 0x2b, 0x1a, 0x65, 0x56, 0x44, 0x22, 0xd3, 0xac, 0xa8,
	0x37, 0x34, 0xff, 0x22, 0x80, 0xa4, 0xb3, 0xf8, 0xab, 0xc3, 0x4a, 0x6e, 0x82, 0xff, 0x2e, 0xce,
	0x5f, 0x53, 0xc2, 0x65, 0xc8, 0x10, 0xbc, 0x0a, 0x65, 0x9c, 0x2e, 0x8b, 0x45, 0xa9, 0x7b, 0x32,
	0xdd, 0x2e, 0x90, 0x0d, 0x38, 0x77, 0x8f, 0x46, 0x62, 0x8d, 0xb3, 0x69, 0x18, 0x05, 0x6e, 0x23,
	0xea, 0x7a, 0xab, 0x28, 0xcf, 0x26, 0x19, 0x34, 0xbb, 0x6f, 0x33, 0x7e, 0xb5, 0x6c, 0x7e, 0x5d,
	0xe9, 0xba, 0xf8, 0xd7, 0x8a, 0xab, 0x8a, 0xd3, 0x34, 0x31, 0x7f, 0x8a, 0x0f, 0x73, 0xf7, 0x9d,
	0x7c, 0xd2, 0x52, 0x1c, 0x36, 0x45, 0x9c, 0xb6, 0x6e, 0xc2, 0x10, 0x27, 0xca, 0xdd, 0x50, 0xc7,
	0x75, 0x1a, 0x72, 0x07, 0x46, 0x95, 0xff, 0x0d, 0x31, 0x8a, 0x72, 0xdb, 0x75, 0x07, 0x46, 0xf9,
	0xd1, 0xea, 0xe4, 0x24, 0x1f, 0xc2, 0xa8, 0x72, 0xd8, 0x39, 0xf5, 0x4e, 0xff, 0x09, 0x4c, 0xe8,
	0xae, 0x3b, 0xa7, 0x17, 0xe4, 0xf7, 0xf1, 0xee, 0x57, 0x5e, 0xb1, 0xe4, 0xd3, 0xcf, 0x24, 0xa2,
	0xc9, 0x08, 0x91, 0xf2, 0x05, 0x52, 0x02, 0x73, 0x9b, 0x7f, 0x36, 0x45, 0x4d, 0x3e, 0x94, 0xaf,
	0xa9, 0x14, 0x71, 0x1a, 0xa9, 0x8b, 0xcc, 0x26, 0xb9, 0x98, 0x9f, 0x87, 0x58, 0x2d, 0xb0, 0x3d,
	0x9b, 0x7d, 0x92, 0x3b, 0xea, 0xde, 0xa2, 0xcb, 0xe3, 0xb2, 0x89, 0x5a, 0x5a, 0x2a, 0x8b, 0x5d,
	0x3e, 0xa3, 0xcb, 0xf9, 0x89, 0xef, 0x70, 0x30, 0xee, 0xe3, 0x29, 0x30, 0x55, 0x9a, 0xdb, 0xbd,
	0x2e, 0x89, 0xf4, 0xe2, 0x63, 0x6f, 0x9a, 0x5d, 0x17, 0xb2, 0x6e, 0xa7, 0x68, 0xf1, 0x46, 0xf4,
	0xa5, 0xb0, 0x5b, 0x95, 0x1e, 0x90, 0x27, 0xef, 0x6c, 0x7e, 0xcb, 0x2e, 0x64, 0xdc, 0x8a, 0xf7,
	0x1c, 0x8b, 0x3c, 0x76, 0xbf, 0x84, 0xda, 0x61, 0x66, 0x38, 0xb1, 0x7c, 0x66, 0xd7, 0x35, 0xc7,
	0x8a, 0x4c, 0x4a, 0xb5, 0xe9, 0x3d, 0xc6, 0x67, 0x6a, 0xd9, 0x79, 0xfe, 0x5e, 0xeb, 0xc1, 0x45,
	0x4a, 0xe2, 0xf5, 0x9e, 0x78, 0xea, 0x8e, 0xf5, 0x02, 0xdf, 0x61, 0xb3, 0xeb, 0xeb, 0x91, 0xb7,
	0x30, 0xe3, 0xda, 0x5b, 0xb9, 0x97, 0x66, 0x33, 0x34, 0xdd, 0x4b, 0xbb, 0xf6, 0x21, 0x4f, 0xfc,
	0x9f, 0x41, 0x25, 0xf6, 0x1e, 0x39, 0xdd, 0x20, 0xe4, 0x7b, 0x35, 0x92, 0x94, 0xa4, 0x42, 0xd2,
	0x2d, 0x91, 0xcf, 0xdc, 0xd5, 0x3c, 0x09, 0x87, 0x9a, 0x5b, 0x92, 0xf0, 0x8a, 0x4b, 0x64, 0xbc,
	0xcc, 0xcb, 0x9d, 0xd9, 0xc5, 0x0e, 0x2b, 0xde, 0xed, 0xbd, 0x14, 0x46, 0xe9, 0xd1, 0x3e, 0x3d,
	0x23, 0xe5, 0xdc, 0x91, 0x60, 0x64, 0x75, 0x19, 0xde, 0xde, 0x57, 0x8f, 0xe5, 0x9c, 0x71, 0x3d,
	0xfd, 0x80, 0x3a, 0xf1, 0x5b, 0xb5, 0x44, 0xf4, 0x41, 0xfd, 0x7d, 0x70, 0xba, 0x28, 0xf9, 0xd0,
	0x2a, 0x0b, 0x43, 0x79, 0x54, 0x95, 0x65, 0x15, 0x0c, 0xce, 0x8e, 0x22, 0x7e, 0xe0, 0x46, 0xcf,
	0x16, 0xed, 0xb5, 0xd8, 0xac, 0xa0, 0x17, 0x48, 0xde, 0x20, 0x0b, 0xed, 0x35, 0xf2, 0x25, 0x2e,
	0x25, 0x82, 0xfd, 0x82, 0xef, 0x47, 0x61, 0x14, 0x38, 0xed, 0x5a, 0x23, 0x70, 0xdb, 0x51, 0x6e,
	0xa7, 0x63, 0x07, 0xf0, 0x2c, 0x32, 0xcd, 0x1f, 0x55, 0x44, 0xa7, 0xcf, 0x8a, 0xbe, 0xa3, 0xde,
	0xe4, 0x64, 0x15, 0x76, 0x39, 0xb9, 0xd4, 0x64, 0x3c, 0xfa, 0x97, 0xc9, 0xb4, 0x0e, 0xb3, 0x39,
	0x31, 0x8b, 0xd4, 0xed, 0x6d, 0xf7, 0x98, 0x46, 0x73, 0xdd, 0x2b, 0x26, 0x5f, 0xc1, 0x4c, 0x66,
	0x50, 0x23, 0x65, 0x81, 0xee, 0x16, 0xf2, 0xa8, 0x17, 0xf3, 0xc7, 0x50, 0xe6, 0xaf, 0x41, 0xd0,
	0xe9, 0xd9, 0x88, 0x6f, 0x13, 0xbf, 0x11, 0xca, 0x41, 0x48, 0xae, 0xd7, 0xf9, 0x78, 0xea, 0xc1,
	0xfb, 0x34, 0x06, 0x36, 0x49, 0x24, 0x54, 0x57, 0x1f, 0x5e, 0x56, 0x61, 0xb7, 0x87, 0x48, 0x5b,
	0x30, 0xb3, 0x4b, 0x03, 0xf7, 0xd1, 0xb3, 0x24, 0x43, 0x29, 0x99, 0xcc, 0xd2, 0x6e, 0x1c, 0x3f,
	0x87, 0xd9, 0x45, 0xff, 0xb0, 0x2d, 0x9e, 0xfc, 0x19, 0x3c, 0xd5, 0x55, 0x7c, 0x76, 0x79, 0x6f,
	0x47, 0xa8, 0xb9, 0xfc, 0xd4, 0xf7, 0xca, 0xff, 0xad, 0x67, 0x76, 0x7c, 0xf5, 0x70, 0xcd, 0xa4,
	0xdf, 0xc6, 0x49, 0x98, 0x95, 0x0b, 0x5f, 0x9f, 0x84, 0x5d, 0x72, 0xe5, 0xe7, 0x3c, 0x20, 0x9b,
	0xcd, 0x49, 0x7f, 0xdf, 0x85, 0xeb, 0x09, 0x5a, 0xbb, 0x21, 0xf7, 0x16, 0x33, 0x51, 0x78, 0xc2,
	0xe3, 0x3a, 0x33, 0x8b, 0x78, 0x66, 0x3b, 0xb5, 0xc8, 0x0e, 0xad, 0x56, 0x17, 0x15, 0x8b, 0xe8,
	0xa1, 0x1d, 0x18, 0x26, 0x1a, 0xf1, 0x27, 0x74, 0xda, 0x6e, 0xab, 0x75, 0x8a, 0x18, 0x95, 0xda,
	0x0f, 0x60, 0xbc, 0xa6, 0x57, 0x9e, 0x51, 0x49, 0xee, 0xa4, 0x50, 0x4f, 0x88, 0x7a, 0xb7, 0xbd,
	0x8b, 0x23, 0xa9, 0xda, 0x78, 0x4e, 0xd4, 0x8b, 0x5c, 0xd7, 0x19, 0x23, 0xeb, 0x9b, 0xda, 0x05,
	0xb2, 0x92, 0x32, 0x2a, 0xd7, 0x99, 0xec, 0x44, 0x71, 0x75, 0x9e, 0xa7, 0x26, 0x99, 0x73, 0x93,
	0x58, 0xbd, 0x93, 0xdb, 0x2a, 0x87, 0xfa, 0xae, 0x49, 0x3b, 0xb9, 0x9f, 0x4f, 0x9c, 0xe7, 0x4e,
	0xf7, 0xf3, 0x49, 0x65, 0xcf, 0xd3, 0xfd, 0x7c, 0x32, 0x52, 0xe3, 0x2d, 0x23, 0xaf, 0x38, 0xc1,
	0x4f, 0x17, 0x63, 0x84, 0x62, 0x93, 0x91, 0x47, 0xe8, 0x81, 0x1e, 0x20, 0x84, 0xa7, 0x05, 0xea,
	0x62, 0x6b, 0x4d, 0x06, 0x06, 0x49, 0xe4, 0x11, 0xba, 0x0b, 0x25, 0x9e, 0x21, 0x21, 0x8e, 0xa9,
	0x18, 0xfb, 0x0d, 0xa6, 0x13, 0x37, 0x74, 0x19, 0xd4, 0x52, 0x32, 0x1a, 0x9d, 0x32, 0x99, 0xe5,
	0x84, 0xa9, 0xeb, 0x32, 0x55, 0x21, 0x8e, 0x39, 0xa7, 0x0c, 0x53, 0xa9, 0x30, 0x74, 0x73, 0xe7,
	0x33, 0x4a, 0x94, 0x4a, 0x39, 0xae, 0x47, 0xa8, 0x53, 0x5d, 0xca, 0x08, 0x5b, 0x37, 0x77, 0x21,
	0xb3, 0x4c, 0x30, 0x8a, 0x78, 0x7e, 0xe7, 0xec, 0xac, 0xd4, 0xf1, 0x2b, 0xb0, 0x2e, 0x38, 0xb2,
	0x9a, 0x1b, 0x27, 0x41, 0x15, 0xb5, 0x52, 0x95, 0xde, 0x28, 0x23, 0x15, 0xf6, 0xeb, 0x19, 0x0f,
	0x35, 0x0c, 0x8c, 0xd8, 0x1b, 0xac, 0x7b, 0x5e, 0x6e, 0xf2, 0x50, 0xa6, 0x9b, 0xc9, 0xa9, 0xa9,
	0x17, 0x83, 0xdc, 0x11, 0x7c, 0x28, 0x13, 0xcc, 0xbc, 0x6c, 0xc6, 0x7b, 0x70, 0x31, 0xf1, 0xfa,
	0xc3, 0x64, 0x7c, 0x23, 0xfb, 0x89, 0x48, 0xa6, 0x78, 0xf2, 0x75, 0xf6, 0x2b, 0xe9, 0x57, 0x22,
	0x89, 0x71, 0x3f, 0xed, 0x9a, 0xb7, 0x0e, 0x93, 0xb8, 0xcc, 0xc8, 0xa4, 0xee, 0x71, 0x7c, 0x1a,
	0x13, 0x9c, 0x0c, 0x94, 0x94, 0x2c, 0x55, 0x2e, 0xb3, 0xe3, 0xe2, 0x45, 0x31, 0x4f, 0x11, 0x3f,
	0x67, 0x3e, 0x33, 0x46, 0x60, 0xd6, 0x2e, 0x26, 0x32, 0xcf, 0x93, 0xef, 0xc3, 0x99, 0xf8, 0xa1,
	0x31, 0x67, 0x91, 0x81, 0xd6, 0xc5, 0x50, 0x76, 0x26, 0x7e, 0x6d, 0x7c, 0x7a, 0xf2, 0x15, 0xb9,
	0x15, 0xc5, 0xe4, 0x97, 0x52, 0x6f, 0x65, 0x8c, 0x3e, 0x9c, 0x64, 0x47, 0xd2, 0x64, 0x7b, 0xda,
	0xd1, 0x69, 0xe0, 0xe7, 0x96, 0x1d, 0x7a, 0x51, 0xff, 0xdc, 0xba, 0x86, 0x87, 0x54, 0xea, 0x6f,
	0x0e, 0x9f, 0x75, 0xb8, 0x86, 0xe1, 0x5a, 0xb6, 0x78, 0x80, 0xbe, 0x6c, 0xac, 0xfc, 0xb6, 0x27,
	0x83, 0xbc, 0xb4, 0xe0, 0x6a, 0xcf, 0xd8, 0x93, 0xe4, 0x96, 0xe1, 0xe2, 0xd2, 0x3b, 0x4a, 0x65,
	0x97, 0x93, 0xc7, 0x74, 0x56, 0x08, 0x47, 0xb5, 0xcf, 0x76, 0x89, 0x26, 0xa9, 0xf6, 0xd9, 0xae,
	0x31, 0x20, 0x3f, 0xc7, 0x1c, 0x4e, 0x62, 0x8f, 0xc2, 0x10, 0x4c, 0xd4, 0xe3, 0x41, 0xa9, 0xbb,
	0x5e, 0xfb, 0x5c, 0x35, 0x2f, 0x45, 0x53, 0x84, 0x78, 0xa6, 0xb9, 0x2c, 0x4e, 0x62, 0x79, 0xcc,
	0x7b, 0x33, 0xe9, 0xe2, 0x5a, 0x7d, 0x99, 0x4f, 0xc0, 0x53, 0xb7, 0x3c, 0x07, 0xbe, 0xb0, 0xf4,
	0xd3, 0xff, 0x7a, 0xb9, 0xf0, 0xd3, 0x9f, 0x5d, 0x2e, 0xfc, 0xc7, 0x9f, 0x5d, 0x2e, 0xfc, 0x97,
	0x9f, 0x5d, 0x2e, 0x7c, 0x39, 0x7f, 0xb2, 0xd0, 0xc8, 0x8d, 0x96, 0x4b, 0xbd, 0xe8, 0x16, 0x67,
	0x37, 0x84, 0xff, 0xbd, 0xf5, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xbe, 0x51, 0xad, 0xe6, 0xe6,
	0xe8, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthServiceClient interface {
	// InventoryControlStream is the per-instance stream used to advertise teleport instance
	// presence/version/etc to the auth server.
	InventoryControlStream(ctx context.Context, opts ...grpc.CallOption) (AuthService_InventoryControlStreamClient, error)
	// GetInventoryStatus gets information about current instance inventory.
	GetInventoryStatus(ctx context.Context, in *InventoryStatusRequest, opts ...grpc.CallOption) (*InventoryStatusSummary, error)
	// GetInventoryConnectedServiceCounts returns the counts of each connected service seen in the inventory.
	GetInventoryConnectedServiceCounts(ctx context.Context, in *InventoryConnectedServiceCountsRequest, opts ...grpc.CallOption) (*InventoryConnectedServiceCounts, error)
	// PingInventory attempts to trigger a downstream inventory ping (used in testing/debug).
	PingInventory(ctx context.Context, in *InventoryPingRequest, opts ...grpc.CallOption) (*InventoryPingResponse, error)
	// GetInstances streams all instances matching the specified filter.
	GetInstances(ctx context.Context, in *types.InstanceFilter, opts ...grpc.CallOption) (AuthService_GetInstancesClient, error)
	// GetClusterAlerts loads cluster-level alert messages.
	GetClusterAlerts(ctx context.Context, in *types.GetClusterAlertsRequest, opts ...grpc.CallOption) (*GetClusterAlertsResponse, error)
	// UpsertClusterAlert creates a cluster alert.
	UpsertClusterAlert(ctx context.Context, in *UpsertClusterAlertRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateAlertAck marks a cluster alert as acknowledged.
	CreateAlertAck(ctx context.Context, in *types.AlertAcknowledgement, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetAlertAcks gets active alert ackowledgements.
	GetAlertAcks(ctx context.Context, in *GetAlertAcksRequest, opts ...grpc.CallOption) (*GetAlertAcksResponse, error)
	// ClearAlertAcks clears alert acknowledgments.
	ClearAlertAcks(ctx context.Context, in *ClearAlertAcksRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// MaintainSessionPresence establishes a channel used to continously verify the presence for a
	// session.
	MaintainSessionPresence(ctx context.Context, opts ...grpc.CallOption) (AuthService_MaintainSessionPresenceClient, error)
	// CreateSessionTracker creates a new session tracker resource.
	CreateSessionTracker(ctx context.Context, in *CreateSessionTrackerRequest, opts ...grpc.CallOption) (*types.SessionTrackerV1, error)
	// GetSessionTracker fetches a session tracker resource.
	GetSessionTracker(ctx context.Context, in *GetSessionTrackerRequest, opts ...grpc.CallOption) (*types.SessionTrackerV1, error)
	// GetActiveSessionTrackers returns a list of active sessions.
	GetActiveSessionTrackers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_GetActiveSessionTrackersClient, error)
	// GetActiveSessionTrackersWithFilter returns a list of active sessions filtered by a filter.
	GetActiveSessionTrackersWithFilter(ctx context.Context, in *types.SessionTrackerFilter, opts ...grpc.CallOption) (AuthService_GetActiveSessionTrackersWithFilterClient, error)
	// RemoveSessionTracker removes a session tracker resource.
	RemoveSessionTracker(ctx context.Context, in *RemoveSessionTrackerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateSessionTracker updates some state of a session tracker.
	UpdateSessionTracker(ctx context.Context, in *UpdateSessionTrackerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SendKeepAlives allows node to send a stream of keep alive requests
	SendKeepAlives(ctx context.Context, opts ...grpc.CallOption) (AuthService_SendKeepAlivesClient, error)
	// WatchEvents returns a new stream of cluster events
	WatchEvents(ctx context.Context, in *Watch, opts ...grpc.CallOption) (AuthService_WatchEventsClient, error)
	// GetNode retrieves a node described by the given request.
	GetNode(ctx context.Context, in *types.ResourceInNamespaceRequest, opts ...grpc.CallOption) (*types.ServerV2, error)
	// UpsertNode upserts a node in a backend.
	UpsertNode(ctx context.Context, in *types.ServerV2, opts ...grpc.CallOption) (*types.KeepAlive, error)
	// DeleteNode deletes an existing node in a backend described by the given request.
	DeleteNode(ctx context.Context, in *types.ResourceInNamespaceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllNodes deletes all nodes.
	DeleteAllNodes(ctx context.Context, in *types.ResourcesInNamespaceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GenerateUserCerts generates a set of user certificates.
	GenerateUserCerts(ctx context.Context, in *UserCertsRequest, opts ...grpc.CallOption) (*Certs, error)
	// GenerateHostCerts generates a set of host certificates.
	GenerateHostCerts(ctx context.Context, in *HostCertsRequest, opts ...grpc.CallOption) (*Certs, error)
	// Deprecated: Superseded by GenerateUserCerts.
	GenerateUserSingleUseCerts(ctx context.Context, opts ...grpc.CallOption) (AuthService_GenerateUserSingleUseCertsClient, error)
	// GenerateOpenSSHCert signs a SSH certificate that can be used
	// to connect to Agentless nodes.
	GenerateOpenSSHCert(ctx context.Context, in *OpenSSHCertRequest, opts ...grpc.CallOption) (*OpenSSHCert, error)
	// IsMFARequired checks whether MFA is required to access the specified
	// target.
	IsMFARequired(ctx context.Context, in *IsMFARequiredRequest, opts ...grpc.CallOption) (*IsMFARequiredResponse, error)
	// GetAccessRequestsV2 gets all pending access requests.
	GetAccessRequestsV2(ctx context.Context, in *types.AccessRequestFilter, opts ...grpc.CallOption) (AuthService_GetAccessRequestsV2Client, error)
	// ListAccessRequests gets access requests with pagination and sorting.
	ListAccessRequests(ctx context.Context, in *ListAccessRequestsRequest, opts ...grpc.CallOption) (*ListAccessRequestsResponse, error)
	// CreateAccessRequest creates a new access request.
	// Deprecated: use CreateAccessRequestV2 instead.
	// DELETE IN v15.0.0.
	CreateAccessRequest(ctx context.Context, in *types.AccessRequestV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateAccessRequestV2 creates a new access request.
	CreateAccessRequestV2(ctx context.Context, in *types.AccessRequestV3, opts ...grpc.CallOption) (*types.AccessRequestV3, error)
	// DeleteAccessRequest deletes an access request.
	DeleteAccessRequest(ctx context.Context, in *RequestID, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SetAccessRequestState sets the state of an access request.
	SetAccessRequestState(ctx context.Context, in *RequestStateSetter, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SubmitAccessReview applies a review to a request and returns the post-application state.
	SubmitAccessReview(ctx context.Context, in *types.AccessReviewSubmission, opts ...grpc.CallOption) (*types.AccessRequestV3, error)
	// GetAccessCapabilities requests the access capabilities of a user.
	GetAccessCapabilities(ctx context.Context, in *types.AccessCapabilitiesRequest, opts ...grpc.CallOption) (*types.AccessCapabilities, error)
	// GetAccessRequestAllowedPromotions returns a list of allowed promotions from an access request to an access list.
	GetAccessRequestAllowedPromotions(ctx context.Context, in *AccessRequestAllowedPromotionRequest, opts ...grpc.CallOption) (*AccessRequestAllowedPromotionResponse, error)
	// GetPluginData gets all plugin data matching the supplied filter.
	GetPluginData(ctx context.Context, in *types.PluginDataFilter, opts ...grpc.CallOption) (*PluginDataSeq, error)
	// UpdatePluginData updates a plugin's resource-specific datastore.
	UpdatePluginData(ctx context.Context, in *types.PluginDataUpdateParams, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Ping gets basic info about the auth server. This method is intended
	// to mimic the behavior of the proxy's Ping method, and may be used by
	// clients for verification or configuration on startup.
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	// GetResetPasswordToken returns a reset password token.
	GetResetPasswordToken(ctx context.Context, in *GetResetPasswordTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error)
	// CreateResetPasswordToken resets users current password and second factors and creates a reset
	// password token.
	//
	// Only local users may be reset.
	CreateResetPasswordToken(ctx context.Context, in *CreateResetPasswordTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error)
	// GetUser gets a user resource by name.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*types.UserV2, error)
	// GetCurrentUser returns current user as seen by the server.
	// Useful especially in the context of remote clusters which perform role and trait mapping.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	GetCurrentUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.UserV2, error)
	// GetCurrentUserRoles returns current user's roles.
	GetCurrentUserRoles(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_GetCurrentUserRolesClient, error)
	// GetUsers gets all current user resources.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	GetUsers(ctx context.Context, in *GetUsersRequest, opts ...grpc.CallOption) (AuthService_GetUsersClient, error)
	// CreateUser inserts a new user entry to a backend.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	CreateUser(ctx context.Context, in *types.UserV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateUser updates an existing user in a backend.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	UpdateUser(ctx context.Context, in *types.UserV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteUser deletes an existing user in a backend by username.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ChangePassword allows a user to change their own password.
	//
	// Only local users may change their password.
	ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// AcquireSemaphore acquires lease with requested resources from semaphore.
	AcquireSemaphore(ctx context.Context, in *types.AcquireSemaphoreRequest, opts ...grpc.CallOption) (*types.SemaphoreLease, error)
	// KeepAliveSemaphoreLease updates semaphore lease.
	KeepAliveSemaphoreLease(ctx context.Context, in *types.SemaphoreLease, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CancelSemaphoreLease cancels semaphore lease early.
	CancelSemaphoreLease(ctx context.Context, in *types.SemaphoreLease, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetSemaphores returns a list of all semaphores matching the supplied filter.
	GetSemaphores(ctx context.Context, in *types.SemaphoreFilter, opts ...grpc.CallOption) (*Semaphores, error)
	// DeleteSemaphore deletes a semaphore matching the supplied filter.
	DeleteSemaphore(ctx context.Context, in *types.SemaphoreFilter, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// EmitAuditEvent emits audit event
	EmitAuditEvent(ctx context.Context, in *events.OneOf, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateAuditStream creates or resumes audit events streams
	CreateAuditStream(ctx context.Context, opts ...grpc.CallOption) (AuthService_CreateAuditStreamClient, error)
	// UpsertApplicationServer adds an application server.
	UpsertApplicationServer(ctx context.Context, in *UpsertApplicationServerRequest, opts ...grpc.CallOption) (*types.KeepAlive, error)
	// DeleteApplicationServer removes an application server.
	DeleteApplicationServer(ctx context.Context, in *DeleteApplicationServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllApplicationServers removes all application servers.
	DeleteAllApplicationServers(ctx context.Context, in *DeleteAllApplicationServersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GenerateAppToken will generate a JWT token for application access.
	GenerateAppToken(ctx context.Context, in *GenerateAppTokenRequest, opts ...grpc.CallOption) (*GenerateAppTokenResponse, error)
	// GetAppSession gets an application web session.
	GetAppSession(ctx context.Context, in *GetAppSessionRequest, opts ...grpc.CallOption) (*GetAppSessionResponse, error)
	// ListAppSessions gets all application web sessions.
	ListAppSessions(ctx context.Context, in *ListAppSessionsRequest, opts ...grpc.CallOption) (*ListAppSessionsResponse, error)
	// CreateAppSession creates an application web session. Application web
	// sessions represent a browser session the client holds.
	CreateAppSession(ctx context.Context, in *CreateAppSessionRequest, opts ...grpc.CallOption) (*CreateAppSessionResponse, error)
	// DeleteAppSession removes an application web session.
	DeleteAppSession(ctx context.Context, in *DeleteAppSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllAppSessions removes all application web sessions.
	DeleteAllAppSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteUserAppSessions deletes all user’s application sessions.
	DeleteUserAppSessions(ctx context.Context, in *DeleteUserAppSessionsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateSnowflakeSession creates web session with sub kind Snowflake used by Database access
	// Snowflake integration.
	CreateSnowflakeSession(ctx context.Context, in *CreateSnowflakeSessionRequest, opts ...grpc.CallOption) (*CreateSnowflakeSessionResponse, error)
	// GetSnowflakeSession returns a web session with sub kind Snowflake.
	GetSnowflakeSession(ctx context.Context, in *GetSnowflakeSessionRequest, opts ...grpc.CallOption) (*GetSnowflakeSessionResponse, error)
	// GetSnowflakeSessions gets all Snowflake web sessions.
	GetSnowflakeSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetSnowflakeSessionsResponse, error)
	// DeleteSnowflakeSession removes a Snowflake web session.
	DeleteSnowflakeSession(ctx context.Context, in *DeleteSnowflakeSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllSnowflakeSessions removes all Snowflake web sessions.
	DeleteAllSnowflakeSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateSAMLIdPSession creates web session with sub kind saml_idp used by the SAML IdP.
	CreateSAMLIdPSession(ctx context.Context, in *CreateSAMLIdPSessionRequest, opts ...grpc.CallOption) (*CreateSAMLIdPSessionResponse, error)
	// GetSAMLIdPSession returns a SAML IdP session with sub kind saml_idp.
	GetSAMLIdPSession(ctx context.Context, in *GetSAMLIdPSessionRequest, opts ...grpc.CallOption) (*GetSAMLIdPSessionResponse, error)
	// ListSAMLIdPSessions gets all SAML IdP sessions.
	ListSAMLIdPSessions(ctx context.Context, in *ListSAMLIdPSessionsRequest, opts ...grpc.CallOption) (*ListSAMLIdPSessionsResponse, error)
	// DeleteSAMLIdPSession removes a SAML IdP session.
	DeleteSAMLIdPSession(ctx context.Context, in *DeleteSAMLIdPSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllSAMLIdPSessions removes all SAML IdP sessions.
	DeleteAllSAMLIdPSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteUserSAMLIdPSessions deletes all user’s SAML IdP sessions.
	DeleteUserSAMLIdPSessions(ctx context.Context, in *DeleteUserSAMLIdPSessionsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetWebSession gets a web session.
	GetWebSession(ctx context.Context, in *types.GetWebSessionRequest, opts ...grpc.CallOption) (*GetWebSessionResponse, error)
	// GetWebSessions gets all web sessions.
	GetWebSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetWebSessionsResponse, error)
	// DeleteWebSession deletes a web session.
	DeleteWebSession(ctx context.Context, in *types.DeleteWebSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllWebSessions deletes all web sessions.
	DeleteAllWebSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetWebToken gets a web token.
	GetWebToken(ctx context.Context, in *types.GetWebTokenRequest, opts ...grpc.CallOption) (*GetWebTokenResponse, error)
	// GetWebTokens gets all web tokens.
	GetWebTokens(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetWebTokensResponse, error)
	// DeleteWebToken deletes a web token.
	DeleteWebToken(ctx context.Context, in *types.DeleteWebTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllWebTokens deletes all web tokens.
	DeleteAllWebTokens(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateRemoteCluster updates remote cluster
	UpdateRemoteCluster(ctx context.Context, in *types.RemoteClusterV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertKubernetesServer adds or updates a kubernetes server.
	UpsertKubernetesServer(ctx context.Context, in *UpsertKubernetesServerRequest, opts ...grpc.CallOption) (*types.KeepAlive, error)
	// DeleteKubernetesServer removes a kubernetes server.
	DeleteKubernetesServer(ctx context.Context, in *DeleteKubernetesServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllKubernetesServers removes all kubernetes servers.
	DeleteAllKubernetesServers(ctx context.Context, in *DeleteAllKubernetesServersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertDatabaseServer registers a new database proxy server.
	UpsertDatabaseServer(ctx context.Context, in *UpsertDatabaseServerRequest, opts ...grpc.CallOption) (*types.KeepAlive, error)
	// DeleteDatabaseServer removes the specified database proxy server.
	DeleteDatabaseServer(ctx context.Context, in *DeleteDatabaseServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllDatabaseServers removes all registered database proxy servers.
	DeleteAllDatabaseServers(ctx context.Context, in *DeleteAllDatabaseServersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertDatabaseService registers a new DatabaseService.
	UpsertDatabaseService(ctx context.Context, in *UpsertDatabaseServiceRequest, opts ...grpc.CallOption) (*types.KeepAlive, error)
	// DeleteDatabaseService removes the specified DatabaseService.
	DeleteDatabaseService(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllDatabaseServices removes all registered DatabaseServices.
	// If there's an error deleting the resources, there's no guarantee of a rollback.
	// A subset of resources might be deleted while others still exist.
	DeleteAllDatabaseServices(ctx context.Context, in *DeleteAllDatabaseServicesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SignDatabaseCSR generates client certificate used by proxy to
	// authenticate with a remote database service.
	SignDatabaseCSR(ctx context.Context, in *DatabaseCSRRequest, opts ...grpc.CallOption) (*DatabaseCSRResponse, error)
	// GenerateDatabaseCert generates client certificate used by a database
	// service to authenticate with the database instance.
	GenerateDatabaseCert(ctx context.Context, in *DatabaseCertRequest, opts ...grpc.CallOption) (*DatabaseCertResponse, error)
	/// GenerateSnowflakeJWT generates JWT in the format required by Snowflake.
	GenerateSnowflakeJWT(ctx context.Context, in *SnowflakeJWTRequest, opts ...grpc.CallOption) (*SnowflakeJWTResponse, error)
	// GetRole retrieves a role described by the given request.
	GetRole(ctx context.Context, in *GetRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error)
	// GetRole retrieves all roles.
	//
	// DELETE IN 17.0
	GetRoles(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetRolesResponse, error)
	// ListRoles is a paginated role getter.
	ListRoles(ctx context.Context, in *ListRolesRequest, opts ...grpc.CallOption) (*ListRolesResponse, error)
	// CreateRole creates a new role.
	CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error)
	// UpdateRole updates an existing role.
	UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error)
	// UpsertRoleV2 creates or overwrites an existing role.
	UpsertRoleV2(ctx context.Context, in *UpsertRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error)
	// UpsertRole upserts a role in a backend.
	//
	// Deprecated: use UpsertRoleV2 instead.
	UpsertRole(ctx context.Context, in *types.RoleV6, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteRole deletes an existing role in a backend described by the given request.
	DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// AddMFADevice adds an MFA device for the user calling this RPC.
	//
	// The RPC is streaming both ways and the message sequence is:
	// (-> means client-to-server, <- means server-to-client)
	// -> Init
	// <- ExistingMFAChallenge
	// -> ExistingMFAResponse
	// <- NewMFARegisterChallenge
	// -> NewMFARegisterResponse
	// <- Ack
	//
	// Deprecated: Use [AddMFADeviceSync] instead.
	AddMFADevice(ctx context.Context, opts ...grpc.CallOption) (AuthService_AddMFADeviceClient, error)
	// DeleteMFADevice deletes an MFA device for the user calling this RPC.
	//
	// The RPC is streaming both ways and the message sequence is:
	// (-> means client-to-server, <- means server-to-client)
	// -> Init
	// <- MFAChallenge
	// -> MFAResponse
	// <- Ack
	//
	// Deprecated: Use [DeleteMFADeviceSync] instead.
	DeleteMFADevice(ctx context.Context, opts ...grpc.CallOption) (AuthService_DeleteMFADeviceClient, error)
	// AddMFADeviceSync adds a new MFA device.
	//
	// A typical MFA registration sequence calls the following RPCs:
	//
	// 1. CreateAuthenticateChallenge (necessary for registration challenge)
	// 2. (optional) CreatePrivilegeToken
	// 3. CreateRegisterChallenge (uses authn challenge and optionally a token)
	// 4. AddMFADeviceSync
	AddMFADeviceSync(ctx context.Context, in *AddMFADeviceSyncRequest, opts ...grpc.CallOption) (*AddMFADeviceSyncResponse, error)
	// DeleteMFADeviceSync deletes a users MFA device (nonstream).
	//
	// A typical MFA deletion sequence calls the following RPCs:
	//
	// 1. (optional) CreateAuthenticateChallenge
	//    (may be skipped depending on the token used, but is usually called
	//    regardless)
	// 2. (optional) CreatePrivilegeToken
	// 3. DeleteMFADeviceSync (using either authn challenge or token)
	DeleteMFADeviceSync(ctx context.Context, in *DeleteMFADeviceSyncRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetMFADevices returns all MFA devices registered for the user calling
	// this RPC.
	GetMFADevices(ctx context.Context, in *GetMFADevicesRequest, opts ...grpc.CallOption) (*GetMFADevicesResponse, error)
	// CreateAuthenticateChallenge creates and returns MFA challenges for a users registered MFA
	// devices.
	CreateAuthenticateChallenge(ctx context.Context, in *CreateAuthenticateChallengeRequest, opts ...grpc.CallOption) (*MFAAuthenticateChallenge, error)
	// CreateRegisterChallenge creates and returns MFA register challenge for a new MFA device.
	CreateRegisterChallenge(ctx context.Context, in *CreateRegisterChallengeRequest, opts ...grpc.CallOption) (*MFARegisterChallenge, error)
	// GetOIDCConnector gets an OIDC connector resource by name.
	GetOIDCConnector(ctx context.Context, in *types.ResourceWithSecretsRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error)
	// GetOIDCConnectors gets all current OIDC connector resources.
	GetOIDCConnectors(ctx context.Context, in *types.ResourcesWithSecretsRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3List, error)
	// UpsertOIDCConnector creates a new OIDC connector in the backend.
	CreateOIDCConnector(ctx context.Context, in *CreateOIDCConnectorRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error)
	// UpsertOIDCConnector updates an existing OIDC connector in the backend.
	UpdateOIDCConnector(ctx context.Context, in *UpdateOIDCConnectorRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error)
	// UpsertOIDCConnector upserts an OIDC connector in a backend.
	//
	// Deprecated: Use UpsertOIDCConnectorV2 instead.
	UpsertOIDCConnector(ctx context.Context, in *types.OIDCConnectorV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertOIDCConnectorV2 upserts an OIDC connector in the backend.
	UpsertOIDCConnectorV2(ctx context.Context, in *UpsertOIDCConnectorRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error)
	// DeleteOIDCConnector deletes an existing OIDC connector in a backend by name.
	DeleteOIDCConnector(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateOIDCAuthRequest creates OIDCAuthRequest.
	CreateOIDCAuthRequest(ctx context.Context, in *types.OIDCAuthRequest, opts ...grpc.CallOption) (*types.OIDCAuthRequest, error)
	// GetOIDCAuthRequest returns OIDC auth request if found.
	GetOIDCAuthRequest(ctx context.Context, in *GetOIDCAuthRequestRequest, opts ...grpc.CallOption) (*types.OIDCAuthRequest, error)
	// GetSAMLConnector gets a SAML connector resource by name.
	GetSAMLConnector(ctx context.Context, in *types.ResourceWithSecretsRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error)
	// GetSAMLConnectors gets all current SAML connector resources.
	GetSAMLConnectors(ctx context.Context, in *types.ResourcesWithSecretsRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2List, error)
	// CreateSAMLConnector creates a new SAML connector in the backend.
	CreateSAMLConnector(ctx context.Context, in *CreateSAMLConnectorRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error)
	// UpdateSAMLConnector updates an existing SAML connector in the backend.
	UpdateSAMLConnector(ctx context.Context, in *UpdateSAMLConnectorRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error)
	// UpsertSAMLConnector upserts a SAML connector in a backend.
	//
	// Deprecated: Use UpsertSAMLConnectorV2 instead.
	UpsertSAMLConnector(ctx context.Context, in *types.SAMLConnectorV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertSAMLConnectorV2 upserts a SAML connector in a backend.
	UpsertSAMLConnectorV2(ctx context.Context, in *UpsertSAMLConnectorRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error)
	// DeleteSAMLConnector deletes an existing SAML connector in a backend by name.
	DeleteSAMLConnector(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateSAMLAuthRequest creates SAMLAuthRequest.
	CreateSAMLAuthRequest(ctx context.Context, in *types.SAMLAuthRequest, opts ...grpc.CallOption) (*types.SAMLAuthRequest, error)
	// GetSAMLAuthRequest returns SAML auth request if found.
	GetSAMLAuthRequest(ctx context.Context, in *GetSAMLAuthRequestRequest, opts ...grpc.CallOption) (*types.SAMLAuthRequest, error)
	// GetGithubConnector gets a Github connector resource by name.
	GetGithubConnector(ctx context.Context, in *types.ResourceWithSecretsRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error)
	// GetGithubConnectors gets all current Github connector resources.
	GetGithubConnectors(ctx context.Context, in *types.ResourcesWithSecretsRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3List, error)
	// CreateGithubConnector creates a new Github connector in the backend.
	CreateGithubConnector(ctx context.Context, in *CreateGithubConnectorRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error)
	// UpdateGithubConnector updates an existing Github connector in the backend.
	UpdateGithubConnector(ctx context.Context, in *UpdateGithubConnectorRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error)
	// UpsertGithubConnector upserts a Github connector in a backend.
	//
	// Deprecated: Use UpsertGithubConnectorV2 instead.
	UpsertGithubConnector(ctx context.Context, in *types.GithubConnectorV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertGithubConnectorV2 upserts a Github connector in a backend.
	UpsertGithubConnectorV2(ctx context.Context, in *UpsertGithubConnectorRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error)
	// DeleteGithubConnector deletes an existing Github connector in a backend by name.
	DeleteGithubConnector(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateGithubAuthRequest creates GithubAuthRequest.
	CreateGithubAuthRequest(ctx context.Context, in *types.GithubAuthRequest, opts ...grpc.CallOption) (*types.GithubAuthRequest, error)
	// GetGithubAuthRequest returns Github auth request if found.
	GetGithubAuthRequest(ctx context.Context, in *GetGithubAuthRequestRequest, opts ...grpc.CallOption) (*types.GithubAuthRequest, error)
	// GetSSODiagnosticInfo returns SSO diagnostic info records.
	GetSSODiagnosticInfo(ctx context.Context, in *GetSSODiagnosticInfoRequest, opts ...grpc.CallOption) (*types.SSODiagnosticInfo, error)
	// GetServerInfos returns a stream of ServerInfos.
	GetServerInfos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_GetServerInfosClient, error)
	// GetServerInfo returns a ServerInfo by name.
	GetServerInfo(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.ServerInfoV1, error)
	// UpsertServerInfo upserts a ServerInfo.
	UpsertServerInfo(ctx context.Context, in *types.ServerInfoV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteServerInfo deletes a ServerInfo by name.
	DeleteServerInfo(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllServerInfos deletes all ServerInfos.
	DeleteAllServerInfos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetTrustedCluster gets a Trusted Cluster resource by name.
	GetTrustedCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.TrustedClusterV2, error)
	// GetTrustedClusters gets all current Trusted Cluster resources.
	GetTrustedClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.TrustedClusterV2List, error)
	// UpsertTrustedCluster upserts a Trusted Cluster in a backend.
	UpsertTrustedCluster(ctx context.Context, in *types.TrustedClusterV2, opts ...grpc.CallOption) (*types.TrustedClusterV2, error)
	// DeleteTrustedCluster deletes an existing Trusted Cluster in a backend by name.
	DeleteTrustedCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetToken retrieves a token described by the given request.
	GetToken(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.ProvisionTokenV2, error)
	// GetToken retrieves all tokens.
	GetTokens(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ProvisionTokenV2List, error)
	// CreateTokenV2 creates a token in a backend.
	CreateTokenV2(ctx context.Context, in *CreateTokenV2Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertTokenV2 upserts a token in a backend.
	UpsertTokenV2(ctx context.Context, in *UpsertTokenV2Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteToken deletes an existing token in a backend described by the given request.
	DeleteToken(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetClusterAuditConfig gets cluster audit configuration.
	GetClusterAuditConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ClusterAuditConfigV2, error)
	// GetClusterNetworkingConfig gets cluster networking configuration.
	// Deprecated: Use clusterconfigv1.Service.GetClusterNetworkingConfig instead.
	GetClusterNetworkingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ClusterNetworkingConfigV2, error)
	// SetClusterNetworkingConfig sets cluster networking configuration.
	// Deprecated: Use clusterconfigv1.Service.Update/UpsertClusterNetworkingConfig instead.
	SetClusterNetworkingConfig(ctx context.Context, in *types.ClusterNetworkingConfigV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ResetClusterNetworkingConfig resets cluster networking configuration to defaults.
	// Deprecated: Use clusterconfigv1.Service.ResetClusterNetworkingConfig instead.
	ResetClusterNetworkingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetSessionRecordingConfig gets session recording configuration.
	// Deprecated: Use clusterconfigv1.Service.GetSessionRecordingConfig instead.
	GetSessionRecordingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.SessionRecordingConfigV2, error)
	// SetSessionRecordingConfig sets session recording configuration.
	// Deprecated: Use clusterconfigv1.Service.Upsert/UpdateSessionRecordingConfig instead.
	SetSessionRecordingConfig(ctx context.Context, in *types.SessionRecordingConfigV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ResetSessionRecordingConfig resets session recording configuration to defaults.
	// Deprecated: Use clusterconfigv1.Service.ResetSessionRecordingConfig instead.
	ResetSessionRecordingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetAuthPreference gets cluster auth preference.
	// Deprecated: Use clusterconfigv1.Service.GetAuthPreference instead.
	GetAuthPreference(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.AuthPreferenceV2, error)
	// SetAuthPreference sets cluster auth preference.
	// Deprecated: Use clusterconfigv1.Service.Create/Update/UpsertAuthPreference instead.
	SetAuthPreference(ctx context.Context, in *types.AuthPreferenceV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ResetAuthPreference resets cluster auth preference to defaults.
	// Deprecated: Use clusterconfigv1.Service.ResetAuthPreference instead.
	ResetAuthPreference(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetUIConfig gets the configuration for the UI served by the proxy service
	GetUIConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.UIConfigV1, error)
	// SetUIConfig sets the configuration for the UI served by the proxy service
	SetUIConfig(ctx context.Context, in *types.UIConfigV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteUIConfig deletes the custom configuration for the UI served by the proxy service
	DeleteUIConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetEvents gets events from the audit log.
	GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (*Events, error)
	// GetSessionEvents gets completed session events from the audit log.
	GetSessionEvents(ctx context.Context, in *GetSessionEventsRequest, opts ...grpc.CallOption) (*Events, error)
	// GetLock gets a lock by name.
	GetLock(ctx context.Context, in *GetLockRequest, opts ...grpc.CallOption) (*types.LockV2, error)
	// GetLocks gets all/in-force locks that match at least one of the targets when specified.
	GetLocks(ctx context.Context, in *GetLocksRequest, opts ...grpc.CallOption) (*GetLocksResponse, error)
	// UpsertLock upserts a lock.
	UpsertLock(ctx context.Context, in *types.LockV2, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteLock deletes a lock.
	DeleteLock(ctx context.Context, in *DeleteLockRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ReplaceRemoteLocks replaces the set of locks associated with a remote cluster.
	ReplaceRemoteLocks(ctx context.Context, in *ReplaceRemoteLocksRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// StreamSessionEvents streams audit events from a given session recording.
	StreamSessionEvents(ctx context.Context, in *StreamSessionEventsRequest, opts ...grpc.CallOption) (AuthService_StreamSessionEventsClient, error)
	// GetNetworkRestrictions retrieves all the network restrictions (allow/deny lists).
	GetNetworkRestrictions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.NetworkRestrictionsV4, error)
	// SetNetworkRestrictions updates the network restrictions.
	SetNetworkRestrictions(ctx context.Context, in *types.NetworkRestrictionsV4, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteNetworkRestrictions delete the network restrictions.
	DeleteNetworkRestrictions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetApps returns all registered applications.
	GetApps(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.AppV3List, error)
	// GetApp returns an application by name.
	GetApp(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.AppV3, error)
	// CreateApp creates a new application resource.
	CreateApp(ctx context.Context, in *types.AppV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateApp updates existing application resource.
	UpdateApp(ctx context.Context, in *types.AppV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteApp removes specified application resource.
	DeleteApp(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllApps removes all application resources.
	DeleteAllApps(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetDatabases returns all registered databases.
	GetDatabases(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.DatabaseV3List, error)
	// GetDatabase returns a database by name.
	GetDatabase(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.DatabaseV3, error)
	// CreateDatabase creates a new database resource.
	CreateDatabase(ctx context.Context, in *types.DatabaseV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateDatabase updates existing database resource.
	UpdateDatabase(ctx context.Context, in *types.DatabaseV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteDatabase removes specified database resource.
	DeleteDatabase(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllDatabases removes all database resources.
	DeleteAllDatabases(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetKubernetesClusters returns all registered kubernetes clusters.
	GetKubernetesClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.KubernetesClusterV3List, error)
	// GetKubernetesCluster returns a kubernetes cluster by name.
	GetKubernetesCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.KubernetesClusterV3, error)
	// CreateKubernetesCluster creates a new kubernetes cluster resource.
	CreateKubernetesCluster(ctx context.Context, in *types.KubernetesClusterV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateKubernetesCluster updates existing kubernetes cluster resource.
	UpdateKubernetesCluster(ctx context.Context, in *types.KubernetesClusterV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteKubernetesCluster removes specified kubernetes cluster resource.
	DeleteKubernetesCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllKubernetesClusters removes all kubernetes cluster resources.
	DeleteAllKubernetesClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetWindowsDesktopServices returns all registered Windows desktop services.
	GetWindowsDesktopServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetWindowsDesktopServicesResponse, error)
	// GetWindowsDesktopService gets a Windows desktop service by name.
	GetWindowsDesktopService(ctx context.Context, in *GetWindowsDesktopServiceRequest, opts ...grpc.CallOption) (*GetWindowsDesktopServiceResponse, error)
	// UpsertWindowsDesktopService registers a new Windows desktop service.
	UpsertWindowsDesktopService(ctx context.Context, in *types.WindowsDesktopServiceV3, opts ...grpc.CallOption) (*types.KeepAlive, error)
	// DeleteWindowsDesktopService removes the specified Windows desktop service.
	DeleteWindowsDesktopService(ctx context.Context, in *DeleteWindowsDesktopServiceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllWindowsDesktopServices removes all registered Windows desktop services.
	DeleteAllWindowsDesktopServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetWindowsDesktops returns all registered Windows desktop hosts matching the supplied filter.
	GetWindowsDesktops(ctx context.Context, in *types.WindowsDesktopFilter, opts ...grpc.CallOption) (*GetWindowsDesktopsResponse, error)
	// CreateWindowsDesktop registers a new Windows desktop host.
	CreateWindowsDesktop(ctx context.Context, in *types.WindowsDesktopV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateWindowsDesktop updates an existing Windows desktop host.
	UpdateWindowsDesktop(ctx context.Context, in *types.WindowsDesktopV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpsertWindowsDesktop updates a Windows desktop host, creating it if it doesn't exist.
	UpsertWindowsDesktop(ctx context.Context, in *types.WindowsDesktopV3, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteWindowsDesktop removes the specified Windows desktop host.
	// Unlike GetWindowsDesktops, this call will delete at-most 1 desktop.
	// To delete all desktops, use DeleteAllWindowsDesktops.
	DeleteWindowsDesktop(ctx context.Context, in *DeleteWindowsDesktopRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllWindowsDesktops removes all registered Windows desktop hosts.
	DeleteAllWindowsDesktops(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GenerateWindowsDesktopCert generates client smartcard certificate used
	// by an RDP client to authenticate with Windows.
	GenerateWindowsDesktopCert(ctx context.Context, in *WindowsDesktopCertRequest, opts ...grpc.CallOption) (*WindowsDesktopCertResponse, error)
	// GenerateCertAuthorityCRL creates an empty CRL for the specified CA.
	GenerateCertAuthorityCRL(ctx context.Context, in *CertAuthorityRequest, opts ...grpc.CallOption) (*CRL, error)
	// GetDesktopBootstrapScript returns a PowerShell script to bootstrap Active Directory.
	GetDesktopBootstrapScript(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DesktopBootstrapScriptResponse, error)
	// CreateConnectionDiagnostic creates a new connection diagnostic.
	CreateConnectionDiagnostic(ctx context.Context, in *types.ConnectionDiagnosticV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateConnectionDiagnostic updates a connection diagnostic.
	UpdateConnectionDiagnostic(ctx context.Context, in *types.ConnectionDiagnosticV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetConnectionDiagnostic reads a connection diagnostic.
	GetConnectionDiagnostic(ctx context.Context, in *GetConnectionDiagnosticRequest, opts ...grpc.CallOption) (*types.ConnectionDiagnosticV1, error)
	// AppendDiagnosticTrace appends a Trace to the ConnectionDiagnostic.
	AppendDiagnosticTrace(ctx context.Context, in *AppendDiagnosticTraceRequest, opts ...grpc.CallOption) (*types.ConnectionDiagnosticV1, error)
	// ChangeUserAuthentication allows a user to change their password and if enabled,
	// also adds a new MFA device. After successful invocation, a new web session is created as well
	// as a new set of recovery codes (if user meets the requirements to receive them), invalidating
	// any existing codes the user previously had.
	//
	// Only local users may be targeted by this RPC.
	ChangeUserAuthentication(ctx context.Context, in *ChangeUserAuthenticationRequest, opts ...grpc.CallOption) (*ChangeUserAuthenticationResponse, error)
	// StartAccountRecovery (exclusive to cloud users) is the first out of two step user
	// verification needed to allow a user to recover their account. The first form of verification
	// is a user's username and a recovery code. After successful verification, a recovery start
	// token is created for the user which its ID will be used as part of a URL that will be emailed
	// to the user (not done in this request). The user will be able to finish their second form of
	// verification by clicking on this URL and following the prompts.
	//
	// If a valid user fails to provide correct recovery code for MaxAccountRecoveryAttempts,
	// user account gets temporarily locked from further recovery attempts and from logging in.
	//
	// Start tokens last RecoveryStartTokenTTL.
	//
	// Only local users may perform account recovery
	StartAccountRecovery(ctx context.Context, in *StartAccountRecoveryRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error)
	// VerifyAccountRecovery (exclusive to cloud users) is the second step of the two step
	// verification needed to allow a user to recover their account, after RPC StartAccountRecovery.
	// The second form of verification is a user's password or their second factor (depending on
	// what authentication they needed to recover). After successful verification, a recovery
	// approved token is created which allows a user to request protected actions while not logged
	// in e.g: setting a new password or a mfa device, viewing their MFA devices, deleting their MFA
	// devices, and generating new recovery codes.
	//
	// The recovery start token to verify this request becomes deleted before
	// creating a recovery approved token, which invalidates the recovery link users received
	// to finish their verification.
	//
	// If user fails to verify themselves for MaxAccountRecoveryAttempts
	// (combined attempts with RPC StartAccountRecovery), users account will be temporarily locked
	// from logging in. If users still have unused recovery codes left, they still have
	// opportunities to recover their account. To allow this, users recovery attempts are also
	// deleted along with all user tokens which will force the user to restart the recovery process
	// from step 1 (RPC StartAccountRecovery).
	//
	// Recovery approved tokens last RecoveryApprovedTokenTTL.
	VerifyAccountRecovery(ctx context.Context, in *VerifyAccountRecoveryRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error)
	// CompleteAccountRecovery (exclusive to cloud users) is the last step in account
	// recovery, after RPC's StartAccountRecovery and VerifyAccountRecovery. This step sets a new
	// password or adds a new mfa device, allowing the user to regain access to their account with
	// the new credentials. When the new authentication is successfully set, any user lock is
	// removed so the user can login immediately afterwards.
	CompleteAccountRecovery(ctx context.Context, in *CompleteAccountRecoveryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateAccountRecoveryCodes (exclusive to cloud users) creates new set of recovery codes for a
	// user, replacing and invalidating any previously owned codes. Users can only get recovery
	// codes if their username is in a valid email format.
	CreateAccountRecoveryCodes(ctx context.Context, in *CreateAccountRecoveryCodesRequest, opts ...grpc.CallOption) (*RecoveryCodes, error)
	// GetAccountRecoveryToken (exclusive to cloud users) returns a user token resource after
	// verifying that the token requested has not expired and is of the correct recovery kind.
	// Besides checking for validity of a token ID, it is also used to get basic information from
	// the token e.g: username, state of recovery (started or approved) and the type of recovery
	// requested (password or second factor).
	GetAccountRecoveryToken(ctx context.Context, in *GetAccountRecoveryTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error)
	// GetAccountRecoveryCodes (exclusive to cloud users) is a request to return the user in context
	// their recovery codes. This request will not return any secrets (the values of recovery
	// codes), but instead returns non-sensitive data eg. when the recovery codes were created.
	GetAccountRecoveryCodes(ctx context.Context, in *GetAccountRecoveryCodesRequest, opts ...grpc.CallOption) (*RecoveryCodes, error)
	// CreatePrivilegeToken returns a new privilege token after a logged in user successfully
	// re-authenticates with their second factor device. Privilege token lasts PrivilegeTokenTTL and
	// is used to gain access to privileged actions eg: deleting/adding a MFA device.
	CreatePrivilegeToken(ctx context.Context, in *CreatePrivilegeTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error)
	// GetInstaller retrieves the installer script resource
	GetInstaller(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.InstallerV1, error)
	// GetInstallers retrieves all of installer script resources.
	GetInstallers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.InstallerV1List, error)
	// SetInstaller sets the installer script resource
	SetInstaller(ctx context.Context, in *types.InstallerV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteInstaller removes the specified installer script resource
	DeleteInstaller(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllInstallers removes all installer script resources
	DeleteAllInstallers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListResources retrieves a paginated list of resources.
	ListResources(ctx context.Context, in *ListResourcesRequest, opts ...grpc.CallOption) (*ListResourcesResponse, error)
	// ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
	ListUnifiedResources(ctx context.Context, in *ListUnifiedResourcesRequest, opts ...grpc.CallOption) (*ListUnifiedResourcesResponse, error)
	// GetSSHTargets gets all servers that would match an equivalent ssh dial request. Note that this method
	// returns all resources directly accessible to the user *and* all resources available via 'SearchAsRoles',
	// which is what we want when handling things like ambiguous host errors and resource-based access requests,
	// but may result in confusing behavior if it is used outside of those contexts.
	GetSSHTargets(ctx context.Context, in *GetSSHTargetsRequest, opts ...grpc.CallOption) (*GetSSHTargetsResponse, error)
	// GetDomainName returns local auth domain of the current auth server
	GetDomainName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetDomainNameResponse, error)
	// GetClusterCACert returns the PEM-encoded TLS certs for the local cluster
	// without signing keys. If the cluster has multiple TLS certs, they will
	// all be appended.
	GetClusterCACert(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetClusterCACertResponse, error)
	// AssertSystemRole is used by agents to prove that they have a given system role when their
	// credentials originate from multiple separate join tokens so that they can be issued an instance
	// certificate that encompasses all of their capabilities. This method will be deprecated once we
	// have a more comprehensive model for join token joining/replacement.
	AssertSystemRole(ctx context.Context, in *SystemRoleAssertion, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SubmitUsageEvent submits an external usage event.
	SubmitUsageEvent(ctx context.Context, in *SubmitUsageEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetLicense returns the license used to start the auth server.
	GetLicense(ctx context.Context, in *GetLicenseRequest, opts ...grpc.CallOption) (*GetLicenseResponse, error)
	// ListReleases returns a list of Teleport Enterprise releases.
	ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (*ListReleasesResponse, error)
	// ListSAMLIdPServiceProviders returns a paginated list of SAML IdP service provider resources.
	ListSAMLIdPServiceProviders(ctx context.Context, in *ListSAMLIdPServiceProvidersRequest, opts ...grpc.CallOption) (*ListSAMLIdPServiceProvidersResponse, error)
	// GetSAMLIdPServiceProvider returns the specified SAML IdP service provider resources.
	GetSAMLIdPServiceProvider(ctx context.Context, in *GetSAMLIdPServiceProviderRequest, opts ...grpc.CallOption) (*types.SAMLIdPServiceProviderV1, error)
	// CreateSAMLIdPServiceProvider creates a new SAML IdP service provider resource.
	CreateSAMLIdPServiceProvider(ctx context.Context, in *types.SAMLIdPServiceProviderV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateSAMLIdPServiceProvider updates an existing SAML IdP service provider resource.
	UpdateSAMLIdPServiceProvider(ctx context.Context, in *types.SAMLIdPServiceProviderV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteSAMLIdPServiceProvider removes the specified SAML IdP service provider resource.
	DeleteSAMLIdPServiceProvider(ctx context.Context, in *DeleteSAMLIdPServiceProviderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllSAMLIdPServiceProviders removes all SAML IdP service providers.
	DeleteAllSAMLIdPServiceProviders(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListUserGroups returns a paginated list of user group resources.
	ListUserGroups(ctx context.Context, in *ListUserGroupsRequest, opts ...grpc.CallOption) (*ListUserGroupsResponse, error)
	// GetUserGroup returns the specified user group resource.
	GetUserGroup(ctx context.Context, in *GetUserGroupRequest, opts ...grpc.CallOption) (*types.UserGroupV1, error)
	// CreateUserGroup creates a new user group resource.
	CreateUserGroup(ctx context.Context, in *types.UserGroupV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UpdateUserGroup updates an existing user group resource.
	UpdateUserGroup(ctx context.Context, in *types.UserGroupV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteUserGroup removes the specified user group resource.
	DeleteUserGroup(ctx context.Context, in *DeleteUserGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAllUserGroups removes all user groups.
	DeleteAllUserGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetHeadlessAuthentication is a request to retrieve a headless authentication from the backend.
	GetHeadlessAuthentication(ctx context.Context, in *GetHeadlessAuthenticationRequest, opts ...grpc.CallOption) (*types.HeadlessAuthentication, error)
	// WatchPendingHeadlessAuthentications watches the backend for pending headless authentication requests for the user.
	WatchPendingHeadlessAuthentications(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_WatchPendingHeadlessAuthenticationsClient, error)
	// UpdateHeadlessAuthenticationState is a request to update a headless authentication's state.
	UpdateHeadlessAuthenticationState(ctx context.Context, in *UpdateHeadlessAuthenticationStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ExportUpgradeWindows is used to load derived maintenance window values for agents that
	// need to export schedules to external upgraders.
	ExportUpgradeWindows(ctx context.Context, in *ExportUpgradeWindowsRequest, opts ...grpc.CallOption) (*ExportUpgradeWindowsResponse, error)
	// GetClusterMaintenanceConfig gets the current maintenance window config singleton.
	GetClusterMaintenanceConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ClusterMaintenanceConfigV1, error)
	// UpdateClusterMaintenanceConfig updates the current maintenance window config singleton.
	UpdateClusterMaintenanceConfig(ctx context.Context, in *types.ClusterMaintenanceConfigV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteClusterMaintenanceConfig deletes the current maintenance window config singleton.
	DeleteClusterMaintenanceConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type authServiceClient struct {
	cc *grpc.ClientConn
}

func NewAuthServiceClient(cc *grpc.ClientConn) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) InventoryControlStream(ctx context.Context, opts ...grpc.CallOption) (AuthService_InventoryControlStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[0], "/proto.AuthService/InventoryControlStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceInventoryControlStreamClient{stream}
	return x, nil
}

type AuthService_InventoryControlStreamClient interface {
	Send(*UpstreamInventoryOneOf) error
	Recv() (*DownstreamInventoryOneOf, error)
	grpc.ClientStream
}

type authServiceInventoryControlStreamClient struct {
	grpc.ClientStream
}

func (x *authServiceInventoryControlStreamClient) Send(m *UpstreamInventoryOneOf) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authServiceInventoryControlStreamClient) Recv() (*DownstreamInventoryOneOf, error) {
	m := new(DownstreamInventoryOneOf)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) GetInventoryStatus(ctx context.Context, in *InventoryStatusRequest, opts ...grpc.CallOption) (*InventoryStatusSummary, error) {
	out := new(InventoryStatusSummary)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetInventoryStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetInventoryConnectedServiceCounts(ctx context.Context, in *InventoryConnectedServiceCountsRequest, opts ...grpc.CallOption) (*InventoryConnectedServiceCounts, error) {
	out := new(InventoryConnectedServiceCounts)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetInventoryConnectedServiceCounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) PingInventory(ctx context.Context, in *InventoryPingRequest, opts ...grpc.CallOption) (*InventoryPingResponse, error) {
	out := new(InventoryPingResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/PingInventory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetInstances(ctx context.Context, in *types.InstanceFilter, opts ...grpc.CallOption) (AuthService_GetInstancesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[1], "/proto.AuthService/GetInstances", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGetInstancesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_GetInstancesClient interface {
	Recv() (*types.InstanceV1, error)
	grpc.ClientStream
}

type authServiceGetInstancesClient struct {
	grpc.ClientStream
}

func (x *authServiceGetInstancesClient) Recv() (*types.InstanceV1, error) {
	m := new(types.InstanceV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) GetClusterAlerts(ctx context.Context, in *types.GetClusterAlertsRequest, opts ...grpc.CallOption) (*GetClusterAlertsResponse, error) {
	out := new(GetClusterAlertsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetClusterAlerts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertClusterAlert(ctx context.Context, in *UpsertClusterAlertRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertClusterAlert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAlertAck(ctx context.Context, in *types.AlertAcknowledgement, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateAlertAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetAlertAcks(ctx context.Context, in *GetAlertAcksRequest, opts ...grpc.CallOption) (*GetAlertAcksResponse, error) {
	out := new(GetAlertAcksResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetAlertAcks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ClearAlertAcks(ctx context.Context, in *ClearAlertAcksRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ClearAlertAcks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) MaintainSessionPresence(ctx context.Context, opts ...grpc.CallOption) (AuthService_MaintainSessionPresenceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[2], "/proto.AuthService/MaintainSessionPresence", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceMaintainSessionPresenceClient{stream}
	return x, nil
}

type AuthService_MaintainSessionPresenceClient interface {
	Send(*PresenceMFAChallengeSend) error
	Recv() (*MFAAuthenticateChallenge, error)
	grpc.ClientStream
}

type authServiceMaintainSessionPresenceClient struct {
	grpc.ClientStream
}

func (x *authServiceMaintainSessionPresenceClient) Send(m *PresenceMFAChallengeSend) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authServiceMaintainSessionPresenceClient) Recv() (*MFAAuthenticateChallenge, error) {
	m := new(MFAAuthenticateChallenge)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) CreateSessionTracker(ctx context.Context, in *CreateSessionTrackerRequest, opts ...grpc.CallOption) (*types.SessionTrackerV1, error) {
	out := new(types.SessionTrackerV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateSessionTracker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSessionTracker(ctx context.Context, in *GetSessionTrackerRequest, opts ...grpc.CallOption) (*types.SessionTrackerV1, error) {
	out := new(types.SessionTrackerV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSessionTracker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetActiveSessionTrackers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_GetActiveSessionTrackersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[3], "/proto.AuthService/GetActiveSessionTrackers", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGetActiveSessionTrackersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_GetActiveSessionTrackersClient interface {
	Recv() (*types.SessionTrackerV1, error)
	grpc.ClientStream
}

type authServiceGetActiveSessionTrackersClient struct {
	grpc.ClientStream
}

func (x *authServiceGetActiveSessionTrackersClient) Recv() (*types.SessionTrackerV1, error) {
	m := new(types.SessionTrackerV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) GetActiveSessionTrackersWithFilter(ctx context.Context, in *types.SessionTrackerFilter, opts ...grpc.CallOption) (AuthService_GetActiveSessionTrackersWithFilterClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[4], "/proto.AuthService/GetActiveSessionTrackersWithFilter", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGetActiveSessionTrackersWithFilterClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_GetActiveSessionTrackersWithFilterClient interface {
	Recv() (*types.SessionTrackerV1, error)
	grpc.ClientStream
}

type authServiceGetActiveSessionTrackersWithFilterClient struct {
	grpc.ClientStream
}

func (x *authServiceGetActiveSessionTrackersWithFilterClient) Recv() (*types.SessionTrackerV1, error) {
	m := new(types.SessionTrackerV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) RemoveSessionTracker(ctx context.Context, in *RemoveSessionTrackerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/RemoveSessionTracker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateSessionTracker(ctx context.Context, in *UpdateSessionTrackerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateSessionTracker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SendKeepAlives(ctx context.Context, opts ...grpc.CallOption) (AuthService_SendKeepAlivesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[5], "/proto.AuthService/SendKeepAlives", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceSendKeepAlivesClient{stream}
	return x, nil
}

type AuthService_SendKeepAlivesClient interface {
	Send(*types.KeepAlive) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type authServiceSendKeepAlivesClient struct {
	grpc.ClientStream
}

func (x *authServiceSendKeepAlivesClient) Send(m *types.KeepAlive) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authServiceSendKeepAlivesClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) WatchEvents(ctx context.Context, in *Watch, opts ...grpc.CallOption) (AuthService_WatchEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[6], "/proto.AuthService/WatchEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceWatchEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_WatchEventsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type authServiceWatchEventsClient struct {
	grpc.ClientStream
}

func (x *authServiceWatchEventsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) GetNode(ctx context.Context, in *types.ResourceInNamespaceRequest, opts ...grpc.CallOption) (*types.ServerV2, error) {
	out := new(types.ServerV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertNode(ctx context.Context, in *types.ServerV2, opts ...grpc.CallOption) (*types.KeepAlive, error) {
	out := new(types.KeepAlive)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteNode(ctx context.Context, in *types.ResourceInNamespaceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllNodes(ctx context.Context, in *types.ResourcesInNamespaceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GenerateUserCerts(ctx context.Context, in *UserCertsRequest, opts ...grpc.CallOption) (*Certs, error) {
	out := new(Certs)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateUserCerts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GenerateHostCerts(ctx context.Context, in *HostCertsRequest, opts ...grpc.CallOption) (*Certs, error) {
	out := new(Certs)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateHostCerts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GenerateUserSingleUseCerts(ctx context.Context, opts ...grpc.CallOption) (AuthService_GenerateUserSingleUseCertsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[7], "/proto.AuthService/GenerateUserSingleUseCerts", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGenerateUserSingleUseCertsClient{stream}
	return x, nil
}

type AuthService_GenerateUserSingleUseCertsClient interface {
	Send(*UserSingleUseCertsRequest) error
	Recv() (*UserSingleUseCertsResponse, error)
	grpc.ClientStream
}

type authServiceGenerateUserSingleUseCertsClient struct {
	grpc.ClientStream
}

func (x *authServiceGenerateUserSingleUseCertsClient) Send(m *UserSingleUseCertsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authServiceGenerateUserSingleUseCertsClient) Recv() (*UserSingleUseCertsResponse, error) {
	m := new(UserSingleUseCertsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) GenerateOpenSSHCert(ctx context.Context, in *OpenSSHCertRequest, opts ...grpc.CallOption) (*OpenSSHCert, error) {
	out := new(OpenSSHCert)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateOpenSSHCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) IsMFARequired(ctx context.Context, in *IsMFARequiredRequest, opts ...grpc.CallOption) (*IsMFARequiredResponse, error) {
	out := new(IsMFARequiredResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/IsMFARequired", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetAccessRequestsV2(ctx context.Context, in *types.AccessRequestFilter, opts ...grpc.CallOption) (AuthService_GetAccessRequestsV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[8], "/proto.AuthService/GetAccessRequestsV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGetAccessRequestsV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_GetAccessRequestsV2Client interface {
	Recv() (*types.AccessRequestV3, error)
	grpc.ClientStream
}

type authServiceGetAccessRequestsV2Client struct {
	grpc.ClientStream
}

func (x *authServiceGetAccessRequestsV2Client) Recv() (*types.AccessRequestV3, error) {
	m := new(types.AccessRequestV3)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) ListAccessRequests(ctx context.Context, in *ListAccessRequestsRequest, opts ...grpc.CallOption) (*ListAccessRequestsResponse, error) {
	out := new(ListAccessRequestsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListAccessRequests", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAccessRequest(ctx context.Context, in *types.AccessRequestV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateAccessRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAccessRequestV2(ctx context.Context, in *types.AccessRequestV3, opts ...grpc.CallOption) (*types.AccessRequestV3, error) {
	out := new(types.AccessRequestV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateAccessRequestV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAccessRequest(ctx context.Context, in *RequestID, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAccessRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SetAccessRequestState(ctx context.Context, in *RequestStateSetter, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SetAccessRequestState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SubmitAccessReview(ctx context.Context, in *types.AccessReviewSubmission, opts ...grpc.CallOption) (*types.AccessRequestV3, error) {
	out := new(types.AccessRequestV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SubmitAccessReview", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetAccessCapabilities(ctx context.Context, in *types.AccessCapabilitiesRequest, opts ...grpc.CallOption) (*types.AccessCapabilities, error) {
	out := new(types.AccessCapabilities)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetAccessCapabilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetAccessRequestAllowedPromotions(ctx context.Context, in *AccessRequestAllowedPromotionRequest, opts ...grpc.CallOption) (*AccessRequestAllowedPromotionResponse, error) {
	out := new(AccessRequestAllowedPromotionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetAccessRequestAllowedPromotions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetPluginData(ctx context.Context, in *types.PluginDataFilter, opts ...grpc.CallOption) (*PluginDataSeq, error) {
	out := new(PluginDataSeq)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetPluginData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdatePluginData(ctx context.Context, in *types.PluginDataUpdateParams, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdatePluginData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetResetPasswordToken(ctx context.Context, in *GetResetPasswordTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error) {
	out := new(types.UserTokenV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetResetPasswordToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateResetPasswordToken(ctx context.Context, in *CreateResetPasswordTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error) {
	out := new(types.UserTokenV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateResetPasswordToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*types.UserV2, error) {
	out := new(types.UserV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GetCurrentUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.UserV2, error) {
	out := new(types.UserV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetCurrentUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetCurrentUserRoles(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_GetCurrentUserRolesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[9], "/proto.AuthService/GetCurrentUserRoles", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGetCurrentUserRolesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_GetCurrentUserRolesClient interface {
	Recv() (*types.RoleV6, error)
	grpc.ClientStream
}

type authServiceGetCurrentUserRolesClient struct {
	grpc.ClientStream
}

func (x *authServiceGetCurrentUserRolesClient) Recv() (*types.RoleV6, error) {
	m := new(types.RoleV6)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GetUsers(ctx context.Context, in *GetUsersRequest, opts ...grpc.CallOption) (AuthService_GetUsersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[10], "/proto.AuthService/GetUsers", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGetUsersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_GetUsersClient interface {
	Recv() (*types.UserV2, error)
	grpc.ClientStream
}

type authServiceGetUsersClient struct {
	grpc.ClientStream
}

func (x *authServiceGetUsersClient) Recv() (*types.UserV2, error) {
	m := new(types.UserV2)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) CreateUser(ctx context.Context, in *types.UserV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) UpdateUser(ctx context.Context, in *types.UserV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ChangePassword(ctx context.Context, in *ChangePasswordRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ChangePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) AcquireSemaphore(ctx context.Context, in *types.AcquireSemaphoreRequest, opts ...grpc.CallOption) (*types.SemaphoreLease, error) {
	out := new(types.SemaphoreLease)
	err := c.cc.Invoke(ctx, "/proto.AuthService/AcquireSemaphore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) KeepAliveSemaphoreLease(ctx context.Context, in *types.SemaphoreLease, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/KeepAliveSemaphoreLease", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CancelSemaphoreLease(ctx context.Context, in *types.SemaphoreLease, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CancelSemaphoreLease", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSemaphores(ctx context.Context, in *types.SemaphoreFilter, opts ...grpc.CallOption) (*Semaphores, error) {
	out := new(Semaphores)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSemaphores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteSemaphore(ctx context.Context, in *types.SemaphoreFilter, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteSemaphore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) EmitAuditEvent(ctx context.Context, in *events.OneOf, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/EmitAuditEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAuditStream(ctx context.Context, opts ...grpc.CallOption) (AuthService_CreateAuditStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[11], "/proto.AuthService/CreateAuditStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceCreateAuditStreamClient{stream}
	return x, nil
}

type AuthService_CreateAuditStreamClient interface {
	Send(*AuditStreamRequest) error
	Recv() (*events.StreamStatus, error)
	grpc.ClientStream
}

type authServiceCreateAuditStreamClient struct {
	grpc.ClientStream
}

func (x *authServiceCreateAuditStreamClient) Send(m *AuditStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authServiceCreateAuditStreamClient) Recv() (*events.StreamStatus, error) {
	m := new(events.StreamStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) UpsertApplicationServer(ctx context.Context, in *UpsertApplicationServerRequest, opts ...grpc.CallOption) (*types.KeepAlive, error) {
	out := new(types.KeepAlive)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertApplicationServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteApplicationServer(ctx context.Context, in *DeleteApplicationServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteApplicationServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllApplicationServers(ctx context.Context, in *DeleteAllApplicationServersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllApplicationServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GenerateAppToken(ctx context.Context, in *GenerateAppTokenRequest, opts ...grpc.CallOption) (*GenerateAppTokenResponse, error) {
	out := new(GenerateAppTokenResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateAppToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetAppSession(ctx context.Context, in *GetAppSessionRequest, opts ...grpc.CallOption) (*GetAppSessionResponse, error) {
	out := new(GetAppSessionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetAppSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListAppSessions(ctx context.Context, in *ListAppSessionsRequest, opts ...grpc.CallOption) (*ListAppSessionsResponse, error) {
	out := new(ListAppSessionsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListAppSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAppSession(ctx context.Context, in *CreateAppSessionRequest, opts ...grpc.CallOption) (*CreateAppSessionResponse, error) {
	out := new(CreateAppSessionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateAppSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAppSession(ctx context.Context, in *DeleteAppSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAppSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllAppSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllAppSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteUserAppSessions(ctx context.Context, in *DeleteUserAppSessionsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteUserAppSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateSnowflakeSession(ctx context.Context, in *CreateSnowflakeSessionRequest, opts ...grpc.CallOption) (*CreateSnowflakeSessionResponse, error) {
	out := new(CreateSnowflakeSessionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateSnowflakeSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSnowflakeSession(ctx context.Context, in *GetSnowflakeSessionRequest, opts ...grpc.CallOption) (*GetSnowflakeSessionResponse, error) {
	out := new(GetSnowflakeSessionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSnowflakeSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSnowflakeSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetSnowflakeSessionsResponse, error) {
	out := new(GetSnowflakeSessionsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSnowflakeSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteSnowflakeSession(ctx context.Context, in *DeleteSnowflakeSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteSnowflakeSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllSnowflakeSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllSnowflakeSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) CreateSAMLIdPSession(ctx context.Context, in *CreateSAMLIdPSessionRequest, opts ...grpc.CallOption) (*CreateSAMLIdPSessionResponse, error) {
	out := new(CreateSAMLIdPSessionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateSAMLIdPSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GetSAMLIdPSession(ctx context.Context, in *GetSAMLIdPSessionRequest, opts ...grpc.CallOption) (*GetSAMLIdPSessionResponse, error) {
	out := new(GetSAMLIdPSessionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSAMLIdPSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) ListSAMLIdPSessions(ctx context.Context, in *ListSAMLIdPSessionsRequest, opts ...grpc.CallOption) (*ListSAMLIdPSessionsResponse, error) {
	out := new(ListSAMLIdPSessionsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListSAMLIdPSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) DeleteSAMLIdPSession(ctx context.Context, in *DeleteSAMLIdPSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteSAMLIdPSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) DeleteAllSAMLIdPSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllSAMLIdPSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) DeleteUserSAMLIdPSessions(ctx context.Context, in *DeleteUserSAMLIdPSessionsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteUserSAMLIdPSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetWebSession(ctx context.Context, in *types.GetWebSessionRequest, opts ...grpc.CallOption) (*GetWebSessionResponse, error) {
	out := new(GetWebSessionResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetWebSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetWebSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetWebSessionsResponse, error) {
	out := new(GetWebSessionsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetWebSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteWebSession(ctx context.Context, in *types.DeleteWebSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteWebSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllWebSessions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllWebSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetWebToken(ctx context.Context, in *types.GetWebTokenRequest, opts ...grpc.CallOption) (*GetWebTokenResponse, error) {
	out := new(GetWebTokenResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetWebToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetWebTokens(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetWebTokensResponse, error) {
	out := new(GetWebTokensResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetWebTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteWebToken(ctx context.Context, in *types.DeleteWebTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteWebToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllWebTokens(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllWebTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateRemoteCluster(ctx context.Context, in *types.RemoteClusterV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateRemoteCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertKubernetesServer(ctx context.Context, in *UpsertKubernetesServerRequest, opts ...grpc.CallOption) (*types.KeepAlive, error) {
	out := new(types.KeepAlive)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertKubernetesServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteKubernetesServer(ctx context.Context, in *DeleteKubernetesServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteKubernetesServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllKubernetesServers(ctx context.Context, in *DeleteAllKubernetesServersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllKubernetesServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertDatabaseServer(ctx context.Context, in *UpsertDatabaseServerRequest, opts ...grpc.CallOption) (*types.KeepAlive, error) {
	out := new(types.KeepAlive)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertDatabaseServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteDatabaseServer(ctx context.Context, in *DeleteDatabaseServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteDatabaseServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllDatabaseServers(ctx context.Context, in *DeleteAllDatabaseServersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllDatabaseServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertDatabaseService(ctx context.Context, in *UpsertDatabaseServiceRequest, opts ...grpc.CallOption) (*types.KeepAlive, error) {
	out := new(types.KeepAlive)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertDatabaseService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteDatabaseService(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteDatabaseService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllDatabaseServices(ctx context.Context, in *DeleteAllDatabaseServicesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllDatabaseServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SignDatabaseCSR(ctx context.Context, in *DatabaseCSRRequest, opts ...grpc.CallOption) (*DatabaseCSRResponse, error) {
	out := new(DatabaseCSRResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SignDatabaseCSR", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GenerateDatabaseCert(ctx context.Context, in *DatabaseCertRequest, opts ...grpc.CallOption) (*DatabaseCertResponse, error) {
	out := new(DatabaseCertResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateDatabaseCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GenerateSnowflakeJWT(ctx context.Context, in *SnowflakeJWTRequest, opts ...grpc.CallOption) (*SnowflakeJWTResponse, error) {
	out := new(SnowflakeJWTResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateSnowflakeJWT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetRole(ctx context.Context, in *GetRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error) {
	out := new(types.RoleV6)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetRoles(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetRolesResponse, error) {
	out := new(GetRolesResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListRoles(ctx context.Context, in *ListRolesRequest, opts ...grpc.CallOption) (*ListRolesResponse, error) {
	out := new(ListRolesResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error) {
	out := new(types.RoleV6)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error) {
	out := new(types.RoleV6)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertRoleV2(ctx context.Context, in *UpsertRoleRequest, opts ...grpc.CallOption) (*types.RoleV6, error) {
	out := new(types.RoleV6)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertRoleV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) UpsertRole(ctx context.Context, in *types.RoleV6, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) AddMFADevice(ctx context.Context, opts ...grpc.CallOption) (AuthService_AddMFADeviceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[12], "/proto.AuthService/AddMFADevice", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceAddMFADeviceClient{stream}
	return x, nil
}

type AuthService_AddMFADeviceClient interface {
	Send(*AddMFADeviceRequest) error
	Recv() (*AddMFADeviceResponse, error)
	grpc.ClientStream
}

type authServiceAddMFADeviceClient struct {
	grpc.ClientStream
}

func (x *authServiceAddMFADeviceClient) Send(m *AddMFADeviceRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authServiceAddMFADeviceClient) Recv() (*AddMFADeviceResponse, error) {
	m := new(AddMFADeviceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) DeleteMFADevice(ctx context.Context, opts ...grpc.CallOption) (AuthService_DeleteMFADeviceClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[13], "/proto.AuthService/DeleteMFADevice", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceDeleteMFADeviceClient{stream}
	return x, nil
}

type AuthService_DeleteMFADeviceClient interface {
	Send(*DeleteMFADeviceRequest) error
	Recv() (*DeleteMFADeviceResponse, error)
	grpc.ClientStream
}

type authServiceDeleteMFADeviceClient struct {
	grpc.ClientStream
}

func (x *authServiceDeleteMFADeviceClient) Send(m *DeleteMFADeviceRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *authServiceDeleteMFADeviceClient) Recv() (*DeleteMFADeviceResponse, error) {
	m := new(DeleteMFADeviceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) AddMFADeviceSync(ctx context.Context, in *AddMFADeviceSyncRequest, opts ...grpc.CallOption) (*AddMFADeviceSyncResponse, error) {
	out := new(AddMFADeviceSyncResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/AddMFADeviceSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteMFADeviceSync(ctx context.Context, in *DeleteMFADeviceSyncRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteMFADeviceSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetMFADevices(ctx context.Context, in *GetMFADevicesRequest, opts ...grpc.CallOption) (*GetMFADevicesResponse, error) {
	out := new(GetMFADevicesResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetMFADevices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAuthenticateChallenge(ctx context.Context, in *CreateAuthenticateChallengeRequest, opts ...grpc.CallOption) (*MFAAuthenticateChallenge, error) {
	out := new(MFAAuthenticateChallenge)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateAuthenticateChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateRegisterChallenge(ctx context.Context, in *CreateRegisterChallengeRequest, opts ...grpc.CallOption) (*MFARegisterChallenge, error) {
	out := new(MFARegisterChallenge)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateRegisterChallenge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetOIDCConnector(ctx context.Context, in *types.ResourceWithSecretsRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error) {
	out := new(types.OIDCConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetOIDCConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetOIDCConnectors(ctx context.Context, in *types.ResourcesWithSecretsRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3List, error) {
	out := new(types.OIDCConnectorV3List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetOIDCConnectors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateOIDCConnector(ctx context.Context, in *CreateOIDCConnectorRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error) {
	out := new(types.OIDCConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateOIDCConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateOIDCConnector(ctx context.Context, in *UpdateOIDCConnectorRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error) {
	out := new(types.OIDCConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateOIDCConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) UpsertOIDCConnector(ctx context.Context, in *types.OIDCConnectorV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertOIDCConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertOIDCConnectorV2(ctx context.Context, in *UpsertOIDCConnectorRequest, opts ...grpc.CallOption) (*types.OIDCConnectorV3, error) {
	out := new(types.OIDCConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertOIDCConnectorV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteOIDCConnector(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteOIDCConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateOIDCAuthRequest(ctx context.Context, in *types.OIDCAuthRequest, opts ...grpc.CallOption) (*types.OIDCAuthRequest, error) {
	out := new(types.OIDCAuthRequest)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateOIDCAuthRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetOIDCAuthRequest(ctx context.Context, in *GetOIDCAuthRequestRequest, opts ...grpc.CallOption) (*types.OIDCAuthRequest, error) {
	out := new(types.OIDCAuthRequest)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetOIDCAuthRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSAMLConnector(ctx context.Context, in *types.ResourceWithSecretsRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error) {
	out := new(types.SAMLConnectorV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSAMLConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSAMLConnectors(ctx context.Context, in *types.ResourcesWithSecretsRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2List, error) {
	out := new(types.SAMLConnectorV2List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSAMLConnectors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateSAMLConnector(ctx context.Context, in *CreateSAMLConnectorRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error) {
	out := new(types.SAMLConnectorV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateSAMLConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateSAMLConnector(ctx context.Context, in *UpdateSAMLConnectorRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error) {
	out := new(types.SAMLConnectorV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateSAMLConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) UpsertSAMLConnector(ctx context.Context, in *types.SAMLConnectorV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertSAMLConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertSAMLConnectorV2(ctx context.Context, in *UpsertSAMLConnectorRequest, opts ...grpc.CallOption) (*types.SAMLConnectorV2, error) {
	out := new(types.SAMLConnectorV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertSAMLConnectorV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteSAMLConnector(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteSAMLConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateSAMLAuthRequest(ctx context.Context, in *types.SAMLAuthRequest, opts ...grpc.CallOption) (*types.SAMLAuthRequest, error) {
	out := new(types.SAMLAuthRequest)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateSAMLAuthRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSAMLAuthRequest(ctx context.Context, in *GetSAMLAuthRequestRequest, opts ...grpc.CallOption) (*types.SAMLAuthRequest, error) {
	out := new(types.SAMLAuthRequest)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSAMLAuthRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetGithubConnector(ctx context.Context, in *types.ResourceWithSecretsRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error) {
	out := new(types.GithubConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetGithubConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetGithubConnectors(ctx context.Context, in *types.ResourcesWithSecretsRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3List, error) {
	out := new(types.GithubConnectorV3List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetGithubConnectors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateGithubConnector(ctx context.Context, in *CreateGithubConnectorRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error) {
	out := new(types.GithubConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateGithubConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateGithubConnector(ctx context.Context, in *UpdateGithubConnectorRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error) {
	out := new(types.GithubConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateGithubConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) UpsertGithubConnector(ctx context.Context, in *types.GithubConnectorV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertGithubConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertGithubConnectorV2(ctx context.Context, in *UpsertGithubConnectorRequest, opts ...grpc.CallOption) (*types.GithubConnectorV3, error) {
	out := new(types.GithubConnectorV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertGithubConnectorV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteGithubConnector(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteGithubConnector", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateGithubAuthRequest(ctx context.Context, in *types.GithubAuthRequest, opts ...grpc.CallOption) (*types.GithubAuthRequest, error) {
	out := new(types.GithubAuthRequest)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateGithubAuthRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetGithubAuthRequest(ctx context.Context, in *GetGithubAuthRequestRequest, opts ...grpc.CallOption) (*types.GithubAuthRequest, error) {
	out := new(types.GithubAuthRequest)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetGithubAuthRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSSODiagnosticInfo(ctx context.Context, in *GetSSODiagnosticInfoRequest, opts ...grpc.CallOption) (*types.SSODiagnosticInfo, error) {
	out := new(types.SSODiagnosticInfo)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSSODiagnosticInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetServerInfos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_GetServerInfosClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[14], "/proto.AuthService/GetServerInfos", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceGetServerInfosClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_GetServerInfosClient interface {
	Recv() (*types.ServerInfoV1, error)
	grpc.ClientStream
}

type authServiceGetServerInfosClient struct {
	grpc.ClientStream
}

func (x *authServiceGetServerInfosClient) Recv() (*types.ServerInfoV1, error) {
	m := new(types.ServerInfoV1)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) GetServerInfo(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.ServerInfoV1, error) {
	out := new(types.ServerInfoV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetServerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertServerInfo(ctx context.Context, in *types.ServerInfoV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertServerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteServerInfo(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteServerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllServerInfos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllServerInfos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetTrustedCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.TrustedClusterV2, error) {
	out := new(types.TrustedClusterV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetTrustedCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetTrustedClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.TrustedClusterV2List, error) {
	out := new(types.TrustedClusterV2List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetTrustedClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertTrustedCluster(ctx context.Context, in *types.TrustedClusterV2, opts ...grpc.CallOption) (*types.TrustedClusterV2, error) {
	out := new(types.TrustedClusterV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertTrustedCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteTrustedCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteTrustedCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetToken(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.ProvisionTokenV2, error) {
	out := new(types.ProvisionTokenV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetTokens(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ProvisionTokenV2List, error) {
	out := new(types.ProvisionTokenV2List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateTokenV2(ctx context.Context, in *CreateTokenV2Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateTokenV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertTokenV2(ctx context.Context, in *UpsertTokenV2Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertTokenV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteToken(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetClusterAuditConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ClusterAuditConfigV2, error) {
	out := new(types.ClusterAuditConfigV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetClusterAuditConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GetClusterNetworkingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ClusterNetworkingConfigV2, error) {
	out := new(types.ClusterNetworkingConfigV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetClusterNetworkingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) SetClusterNetworkingConfig(ctx context.Context, in *types.ClusterNetworkingConfigV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SetClusterNetworkingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) ResetClusterNetworkingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ResetClusterNetworkingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GetSessionRecordingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.SessionRecordingConfigV2, error) {
	out := new(types.SessionRecordingConfigV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSessionRecordingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) SetSessionRecordingConfig(ctx context.Context, in *types.SessionRecordingConfigV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SetSessionRecordingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) ResetSessionRecordingConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ResetSessionRecordingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) GetAuthPreference(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.AuthPreferenceV2, error) {
	out := new(types.AuthPreferenceV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetAuthPreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) SetAuthPreference(ctx context.Context, in *types.AuthPreferenceV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SetAuthPreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *authServiceClient) ResetAuthPreference(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ResetAuthPreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetUIConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.UIConfigV1, error) {
	out := new(types.UIConfigV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetUIConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SetUIConfig(ctx context.Context, in *types.UIConfigV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SetUIConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteUIConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteUIConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetEvents(ctx context.Context, in *GetEventsRequest, opts ...grpc.CallOption) (*Events, error) {
	out := new(Events)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSessionEvents(ctx context.Context, in *GetSessionEventsRequest, opts ...grpc.CallOption) (*Events, error) {
	out := new(Events)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSessionEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetLock(ctx context.Context, in *GetLockRequest, opts ...grpc.CallOption) (*types.LockV2, error) {
	out := new(types.LockV2)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetLocks(ctx context.Context, in *GetLocksRequest, opts ...grpc.CallOption) (*GetLocksResponse, error) {
	out := new(GetLocksResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertLock(ctx context.Context, in *types.LockV2, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteLock(ctx context.Context, in *DeleteLockRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ReplaceRemoteLocks(ctx context.Context, in *ReplaceRemoteLocksRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ReplaceRemoteLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) StreamSessionEvents(ctx context.Context, in *StreamSessionEventsRequest, opts ...grpc.CallOption) (AuthService_StreamSessionEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[15], "/proto.AuthService/StreamSessionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceStreamSessionEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_StreamSessionEventsClient interface {
	Recv() (*events.OneOf, error)
	grpc.ClientStream
}

type authServiceStreamSessionEventsClient struct {
	grpc.ClientStream
}

func (x *authServiceStreamSessionEventsClient) Recv() (*events.OneOf, error) {
	m := new(events.OneOf)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) GetNetworkRestrictions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.NetworkRestrictionsV4, error) {
	out := new(types.NetworkRestrictionsV4)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetNetworkRestrictions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SetNetworkRestrictions(ctx context.Context, in *types.NetworkRestrictionsV4, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SetNetworkRestrictions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteNetworkRestrictions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteNetworkRestrictions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetApps(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.AppV3List, error) {
	out := new(types.AppV3List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetApps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetApp(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.AppV3, error) {
	out := new(types.AppV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateApp(ctx context.Context, in *types.AppV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateApp(ctx context.Context, in *types.AppV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteApp(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllApps(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllApps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetDatabases(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.DatabaseV3List, error) {
	out := new(types.DatabaseV3List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetDatabases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetDatabase(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.DatabaseV3, error) {
	out := new(types.DatabaseV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateDatabase(ctx context.Context, in *types.DatabaseV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateDatabase(ctx context.Context, in *types.DatabaseV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteDatabase(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllDatabases(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllDatabases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetKubernetesClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.KubernetesClusterV3List, error) {
	out := new(types.KubernetesClusterV3List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetKubernetesClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetKubernetesCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.KubernetesClusterV3, error) {
	out := new(types.KubernetesClusterV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetKubernetesCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateKubernetesCluster(ctx context.Context, in *types.KubernetesClusterV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateKubernetesCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateKubernetesCluster(ctx context.Context, in *types.KubernetesClusterV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateKubernetesCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteKubernetesCluster(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteKubernetesCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllKubernetesClusters(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllKubernetesClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetWindowsDesktopServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetWindowsDesktopServicesResponse, error) {
	out := new(GetWindowsDesktopServicesResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetWindowsDesktopServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetWindowsDesktopService(ctx context.Context, in *GetWindowsDesktopServiceRequest, opts ...grpc.CallOption) (*GetWindowsDesktopServiceResponse, error) {
	out := new(GetWindowsDesktopServiceResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetWindowsDesktopService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertWindowsDesktopService(ctx context.Context, in *types.WindowsDesktopServiceV3, opts ...grpc.CallOption) (*types.KeepAlive, error) {
	out := new(types.KeepAlive)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertWindowsDesktopService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteWindowsDesktopService(ctx context.Context, in *DeleteWindowsDesktopServiceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteWindowsDesktopService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllWindowsDesktopServices(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllWindowsDesktopServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetWindowsDesktops(ctx context.Context, in *types.WindowsDesktopFilter, opts ...grpc.CallOption) (*GetWindowsDesktopsResponse, error) {
	out := new(GetWindowsDesktopsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetWindowsDesktops", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateWindowsDesktop(ctx context.Context, in *types.WindowsDesktopV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateWindowsDesktop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateWindowsDesktop(ctx context.Context, in *types.WindowsDesktopV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateWindowsDesktop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpsertWindowsDesktop(ctx context.Context, in *types.WindowsDesktopV3, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpsertWindowsDesktop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteWindowsDesktop(ctx context.Context, in *DeleteWindowsDesktopRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteWindowsDesktop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllWindowsDesktops(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllWindowsDesktops", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GenerateWindowsDesktopCert(ctx context.Context, in *WindowsDesktopCertRequest, opts ...grpc.CallOption) (*WindowsDesktopCertResponse, error) {
	out := new(WindowsDesktopCertResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateWindowsDesktopCert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GenerateCertAuthorityCRL(ctx context.Context, in *CertAuthorityRequest, opts ...grpc.CallOption) (*CRL, error) {
	out := new(CRL)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GenerateCertAuthorityCRL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetDesktopBootstrapScript(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DesktopBootstrapScriptResponse, error) {
	out := new(DesktopBootstrapScriptResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetDesktopBootstrapScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateConnectionDiagnostic(ctx context.Context, in *types.ConnectionDiagnosticV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateConnectionDiagnostic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateConnectionDiagnostic(ctx context.Context, in *types.ConnectionDiagnosticV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateConnectionDiagnostic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetConnectionDiagnostic(ctx context.Context, in *GetConnectionDiagnosticRequest, opts ...grpc.CallOption) (*types.ConnectionDiagnosticV1, error) {
	out := new(types.ConnectionDiagnosticV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetConnectionDiagnostic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) AppendDiagnosticTrace(ctx context.Context, in *AppendDiagnosticTraceRequest, opts ...grpc.CallOption) (*types.ConnectionDiagnosticV1, error) {
	out := new(types.ConnectionDiagnosticV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/AppendDiagnosticTrace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ChangeUserAuthentication(ctx context.Context, in *ChangeUserAuthenticationRequest, opts ...grpc.CallOption) (*ChangeUserAuthenticationResponse, error) {
	out := new(ChangeUserAuthenticationResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ChangeUserAuthentication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) StartAccountRecovery(ctx context.Context, in *StartAccountRecoveryRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error) {
	out := new(types.UserTokenV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/StartAccountRecovery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) VerifyAccountRecovery(ctx context.Context, in *VerifyAccountRecoveryRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error) {
	out := new(types.UserTokenV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/VerifyAccountRecovery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CompleteAccountRecovery(ctx context.Context, in *CompleteAccountRecoveryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CompleteAccountRecovery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateAccountRecoveryCodes(ctx context.Context, in *CreateAccountRecoveryCodesRequest, opts ...grpc.CallOption) (*RecoveryCodes, error) {
	out := new(RecoveryCodes)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateAccountRecoveryCodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetAccountRecoveryToken(ctx context.Context, in *GetAccountRecoveryTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error) {
	out := new(types.UserTokenV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetAccountRecoveryToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetAccountRecoveryCodes(ctx context.Context, in *GetAccountRecoveryCodesRequest, opts ...grpc.CallOption) (*RecoveryCodes, error) {
	out := new(RecoveryCodes)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetAccountRecoveryCodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreatePrivilegeToken(ctx context.Context, in *CreatePrivilegeTokenRequest, opts ...grpc.CallOption) (*types.UserTokenV3, error) {
	out := new(types.UserTokenV3)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreatePrivilegeToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetInstaller(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*types.InstallerV1, error) {
	out := new(types.InstallerV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetInstaller", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetInstallers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.InstallerV1List, error) {
	out := new(types.InstallerV1List)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetInstallers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SetInstaller(ctx context.Context, in *types.InstallerV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SetInstaller", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteInstaller(ctx context.Context, in *types.ResourceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteInstaller", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllInstallers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllInstallers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListResources(ctx context.Context, in *ListResourcesRequest, opts ...grpc.CallOption) (*ListResourcesResponse, error) {
	out := new(ListResourcesResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListUnifiedResources(ctx context.Context, in *ListUnifiedResourcesRequest, opts ...grpc.CallOption) (*ListUnifiedResourcesResponse, error) {
	out := new(ListUnifiedResourcesResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListUnifiedResources", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSSHTargets(ctx context.Context, in *GetSSHTargetsRequest, opts ...grpc.CallOption) (*GetSSHTargetsResponse, error) {
	out := new(GetSSHTargetsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSSHTargets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetDomainName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetDomainNameResponse, error) {
	out := new(GetDomainNameResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetDomainName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetClusterCACert(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetClusterCACertResponse, error) {
	out := new(GetClusterCACertResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetClusterCACert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) AssertSystemRole(ctx context.Context, in *SystemRoleAssertion, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/AssertSystemRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) SubmitUsageEvent(ctx context.Context, in *SubmitUsageEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/SubmitUsageEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetLicense(ctx context.Context, in *GetLicenseRequest, opts ...grpc.CallOption) (*GetLicenseResponse, error) {
	out := new(GetLicenseResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetLicense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (*ListReleasesResponse, error) {
	out := new(ListReleasesResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListReleases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListSAMLIdPServiceProviders(ctx context.Context, in *ListSAMLIdPServiceProvidersRequest, opts ...grpc.CallOption) (*ListSAMLIdPServiceProvidersResponse, error) {
	out := new(ListSAMLIdPServiceProvidersResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListSAMLIdPServiceProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetSAMLIdPServiceProvider(ctx context.Context, in *GetSAMLIdPServiceProviderRequest, opts ...grpc.CallOption) (*types.SAMLIdPServiceProviderV1, error) {
	out := new(types.SAMLIdPServiceProviderV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetSAMLIdPServiceProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateSAMLIdPServiceProvider(ctx context.Context, in *types.SAMLIdPServiceProviderV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateSAMLIdPServiceProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateSAMLIdPServiceProvider(ctx context.Context, in *types.SAMLIdPServiceProviderV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateSAMLIdPServiceProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteSAMLIdPServiceProvider(ctx context.Context, in *DeleteSAMLIdPServiceProviderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteSAMLIdPServiceProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllSAMLIdPServiceProviders(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllSAMLIdPServiceProviders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ListUserGroups(ctx context.Context, in *ListUserGroupsRequest, opts ...grpc.CallOption) (*ListUserGroupsResponse, error) {
	out := new(ListUserGroupsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ListUserGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetUserGroup(ctx context.Context, in *GetUserGroupRequest, opts ...grpc.CallOption) (*types.UserGroupV1, error) {
	out := new(types.UserGroupV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetUserGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) CreateUserGroup(ctx context.Context, in *types.UserGroupV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/CreateUserGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateUserGroup(ctx context.Context, in *types.UserGroupV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateUserGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteUserGroup(ctx context.Context, in *DeleteUserGroupRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteUserGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteAllUserGroups(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteAllUserGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetHeadlessAuthentication(ctx context.Context, in *GetHeadlessAuthenticationRequest, opts ...grpc.CallOption) (*types.HeadlessAuthentication, error) {
	out := new(types.HeadlessAuthentication)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetHeadlessAuthentication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) WatchPendingHeadlessAuthentications(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (AuthService_WatchPendingHeadlessAuthenticationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_AuthService_serviceDesc.Streams[16], "/proto.AuthService/WatchPendingHeadlessAuthentications", opts...)
	if err != nil {
		return nil, err
	}
	x := &authServiceWatchPendingHeadlessAuthenticationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AuthService_WatchPendingHeadlessAuthenticationsClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type authServiceWatchPendingHeadlessAuthenticationsClient struct {
	grpc.ClientStream
}

func (x *authServiceWatchPendingHeadlessAuthenticationsClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *authServiceClient) UpdateHeadlessAuthenticationState(ctx context.Context, in *UpdateHeadlessAuthenticationStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateHeadlessAuthenticationState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ExportUpgradeWindows(ctx context.Context, in *ExportUpgradeWindowsRequest, opts ...grpc.CallOption) (*ExportUpgradeWindowsResponse, error) {
	out := new(ExportUpgradeWindowsResponse)
	err := c.cc.Invoke(ctx, "/proto.AuthService/ExportUpgradeWindows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetClusterMaintenanceConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*types.ClusterMaintenanceConfigV1, error) {
	out := new(types.ClusterMaintenanceConfigV1)
	err := c.cc.Invoke(ctx, "/proto.AuthService/GetClusterMaintenanceConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) UpdateClusterMaintenanceConfig(ctx context.Context, in *types.ClusterMaintenanceConfigV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/UpdateClusterMaintenanceConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) DeleteClusterMaintenanceConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/proto.AuthService/DeleteClusterMaintenanceConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
type AuthServiceServer interface {
	// InventoryControlStream is the per-instance stream used to advertise teleport instance
	// presence/version/etc to the auth server.
	InventoryControlStream(AuthService_InventoryControlStreamServer) error
	// GetInventoryStatus gets information about current instance inventory.
	GetInventoryStatus(context.Context, *InventoryStatusRequest) (*InventoryStatusSummary, error)
	// GetInventoryConnectedServiceCounts returns the counts of each connected service seen in the inventory.
	GetInventoryConnectedServiceCounts(context.Context, *InventoryConnectedServiceCountsRequest) (*InventoryConnectedServiceCounts, error)
	// PingInventory attempts to trigger a downstream inventory ping (used in testing/debug).
	PingInventory(context.Context, *InventoryPingRequest) (*InventoryPingResponse, error)
	// GetInstances streams all instances matching the specified filter.
	GetInstances(*types.InstanceFilter, AuthService_GetInstancesServer) error
	// GetClusterAlerts loads cluster-level alert messages.
	GetClusterAlerts(context.Context, *types.GetClusterAlertsRequest) (*GetClusterAlertsResponse, error)
	// UpsertClusterAlert creates a cluster alert.
	UpsertClusterAlert(context.Context, *UpsertClusterAlertRequest) (*emptypb.Empty, error)
	// CreateAlertAck marks a cluster alert as acknowledged.
	CreateAlertAck(context.Context, *types.AlertAcknowledgement) (*emptypb.Empty, error)
	// GetAlertAcks gets active alert ackowledgements.
	GetAlertAcks(context.Context, *GetAlertAcksRequest) (*GetAlertAcksResponse, error)
	// ClearAlertAcks clears alert acknowledgments.
	ClearAlertAcks(context.Context, *ClearAlertAcksRequest) (*emptypb.Empty, error)
	// MaintainSessionPresence establishes a channel used to continously verify the presence for a
	// session.
	MaintainSessionPresence(AuthService_MaintainSessionPresenceServer) error
	// CreateSessionTracker creates a new session tracker resource.
	CreateSessionTracker(context.Context, *CreateSessionTrackerRequest) (*types.SessionTrackerV1, error)
	// GetSessionTracker fetches a session tracker resource.
	GetSessionTracker(context.Context, *GetSessionTrackerRequest) (*types.SessionTrackerV1, error)
	// GetActiveSessionTrackers returns a list of active sessions.
	GetActiveSessionTrackers(*emptypb.Empty, AuthService_GetActiveSessionTrackersServer) error
	// GetActiveSessionTrackersWithFilter returns a list of active sessions filtered by a filter.
	GetActiveSessionTrackersWithFilter(*types.SessionTrackerFilter, AuthService_GetActiveSessionTrackersWithFilterServer) error
	// RemoveSessionTracker removes a session tracker resource.
	RemoveSessionTracker(context.Context, *RemoveSessionTrackerRequest) (*emptypb.Empty, error)
	// UpdateSessionTracker updates some state of a session tracker.
	UpdateSessionTracker(context.Context, *UpdateSessionTrackerRequest) (*emptypb.Empty, error)
	// SendKeepAlives allows node to send a stream of keep alive requests
	SendKeepAlives(AuthService_SendKeepAlivesServer) error
	// WatchEvents returns a new stream of cluster events
	WatchEvents(*Watch, AuthService_WatchEventsServer) error
	// GetNode retrieves a node described by the given request.
	GetNode(context.Context, *types.ResourceInNamespaceRequest) (*types.ServerV2, error)
	// UpsertNode upserts a node in a backend.
	UpsertNode(context.Context, *types.ServerV2) (*types.KeepAlive, error)
	// DeleteNode deletes an existing node in a backend described by the given request.
	DeleteNode(context.Context, *types.ResourceInNamespaceRequest) (*emptypb.Empty, error)
	// DeleteAllNodes deletes all nodes.
	DeleteAllNodes(context.Context, *types.ResourcesInNamespaceRequest) (*emptypb.Empty, error)
	// GenerateUserCerts generates a set of user certificates.
	GenerateUserCerts(context.Context, *UserCertsRequest) (*Certs, error)
	// GenerateHostCerts generates a set of host certificates.
	GenerateHostCerts(context.Context, *HostCertsRequest) (*Certs, error)
	// Deprecated: Superseded by GenerateUserCerts.
	GenerateUserSingleUseCerts(AuthService_GenerateUserSingleUseCertsServer) error
	// GenerateOpenSSHCert signs a SSH certificate that can be used
	// to connect to Agentless nodes.
	GenerateOpenSSHCert(context.Context, *OpenSSHCertRequest) (*OpenSSHCert, error)
	// IsMFARequired checks whether MFA is required to access the specified
	// target.
	IsMFARequired(context.Context, *IsMFARequiredRequest) (*IsMFARequiredResponse, error)
	// GetAccessRequestsV2 gets all pending access requests.
	GetAccessRequestsV2(*types.AccessRequestFilter, AuthService_GetAccessRequestsV2Server) error
	// ListAccessRequests gets access requests with pagination and sorting.
	ListAccessRequests(context.Context, *ListAccessRequestsRequest) (*ListAccessRequestsResponse, error)
	// CreateAccessRequest creates a new access request.
	// Deprecated: use CreateAccessRequestV2 instead.
	// DELETE IN v15.0.0.
	CreateAccessRequest(context.Context, *types.AccessRequestV3) (*emptypb.Empty, error)
	// CreateAccessRequestV2 creates a new access request.
	CreateAccessRequestV2(context.Context, *types.AccessRequestV3) (*types.AccessRequestV3, error)
	// DeleteAccessRequest deletes an access request.
	DeleteAccessRequest(context.Context, *RequestID) (*emptypb.Empty, error)
	// SetAccessRequestState sets the state of an access request.
	SetAccessRequestState(context.Context, *RequestStateSetter) (*emptypb.Empty, error)
	// SubmitAccessReview applies a review to a request and returns the post-application state.
	SubmitAccessReview(context.Context, *types.AccessReviewSubmission) (*types.AccessRequestV3, error)
	// GetAccessCapabilities requests the access capabilities of a user.
	GetAccessCapabilities(context.Context, *types.AccessCapabilitiesRequest) (*types.AccessCapabilities, error)
	// GetAccessRequestAllowedPromotions returns a list of allowed promotions from an access request to an access list.
	GetAccessRequestAllowedPromotions(context.Context, *AccessRequestAllowedPromotionRequest) (*AccessRequestAllowedPromotionResponse, error)
	// GetPluginData gets all plugin data matching the supplied filter.
	GetPluginData(context.Context, *types.PluginDataFilter) (*PluginDataSeq, error)
	// UpdatePluginData updates a plugin's resource-specific datastore.
	UpdatePluginData(context.Context, *types.PluginDataUpdateParams) (*emptypb.Empty, error)
	// Ping gets basic info about the auth server. This method is intended
	// to mimic the behavior of the proxy's Ping method, and may be used by
	// clients for verification or configuration on startup.
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	// GetResetPasswordToken returns a reset password token.
	GetResetPasswordToken(context.Context, *GetResetPasswordTokenRequest) (*types.UserTokenV3, error)
	// CreateResetPasswordToken resets users current password and second factors and creates a reset
	// password token.
	//
	// Only local users may be reset.
	CreateResetPasswordToken(context.Context, *CreateResetPasswordTokenRequest) (*types.UserTokenV3, error)
	// GetUser gets a user resource by name.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	GetUser(context.Context, *GetUserRequest) (*types.UserV2, error)
	// GetCurrentUser returns current user as seen by the server.
	// Useful especially in the context of remote clusters which perform role and trait mapping.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	GetCurrentUser(context.Context, *emptypb.Empty) (*types.UserV2, error)
	// GetCurrentUserRoles returns current user's roles.
	GetCurrentUserRoles(*emptypb.Empty, AuthService_GetCurrentUserRolesServer) error
	// GetUsers gets all current user resources.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	GetUsers(*GetUsersRequest, AuthService_GetUsersServer) error
	// CreateUser inserts a new user entry to a backend.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	CreateUser(context.Context, *types.UserV2) (*emptypb.Empty, error)
	// UpdateUser updates an existing user in a backend.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	UpdateUser(context.Context, *types.UserV2) (*emptypb.Empty, error)
	// DeleteUser deletes an existing user in a backend by username.
	//
	// Deprecated: Use [teleport.users.v1.UsersService] instead.
	DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error)
	// ChangePassword allows a user to change their own password.
	//
	// Only local users may change their password.
	ChangePassword(context.Context, *ChangePasswordRequest) (*emptypb.Empty, error)
	// AcquireSemaphore acquires lease with requested resources from semaphore.
	AcquireSemaphore(context.Context, *types.AcquireSemaphoreRequest) (*types.SemaphoreLease, error)
	// KeepAliveSemaphoreLease updates semaphore lease.
	KeepAliveSemaphoreLease(context.Context, *types.SemaphoreLease) (*emptypb.Empty, error)
	// CancelSemaphoreLease cancels semaphore lease early.
	CancelSemaphoreLease(context.Context, *types.SemaphoreLease) (*emptypb.Empty, error)
	// GetSemaphores returns a list of all semaphores matching the supplied filter.
	GetSemaphores(context.Context, *types.SemaphoreFilter) (*Semaphores, error)
	// DeleteSemaphore deletes a semaphore matching the supplied filter.
	DeleteSemaphore(context.Context, *types.SemaphoreFilter) (*emptypb.Empty, error)
	// EmitAuditEvent emits audit event
	EmitAuditEvent(context.Context, *events.OneOf) (*emptypb.Empty, error)
	// CreateAuditStream creates or resumes audit events streams
	CreateAuditStream(AuthService_CreateAuditStreamServer) error
	// UpsertApplicationServer adds an application server.
	UpsertApplicationServer(context.Context, *UpsertApplicationServerRequest) (*types.KeepAlive, error)
	// DeleteApplicationServer removes an application server.
	DeleteApplicationServer(context.Context, *DeleteApplicationServerRequest) (*emptypb.Empty, error)
	// DeleteAllApplicationServers removes all application servers.
	DeleteAllApplicationServers(context.Context, *DeleteAllApplicationServersRequest) (*emptypb.Empty, error)
	// GenerateAppToken will generate a JWT token for application access.
	GenerateAppToken(context.Context, *GenerateAppTokenRequest) (*GenerateAppTokenResponse, error)
	// GetAppSession gets an application web session.
	GetAppSession(context.Context, *GetAppSessionRequest) (*GetAppSessionResponse, error)
	// ListAppSessions gets all application web sessions.
	ListAppSessions(context.Context, *ListAppSessionsRequest) (*ListAppSessionsResponse, error)
	// CreateAppSession creates an application web session. Application web
	// sessions represent a browser session the client holds.
	CreateAppSession(context.Context, *CreateAppSessionRequest) (*CreateAppSessionResponse, error)
	// DeleteAppSession removes an application web session.
	DeleteAppSession(context.Context, *DeleteAppSessionRequest) (*emptypb.Empty, error)
	// DeleteAllAppSessions removes all application web sessions.
	DeleteAllAppSessions(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// DeleteUserAppSessions deletes all user’s application sessions.
	DeleteUserAppSessions(context.Context, *DeleteUserAppSessionsRequest) (*emptypb.Empty, error)
	// CreateSnowflakeSession creates web session with sub kind Snowflake used by Database access
	// Snowflake integration.
	CreateSnowflakeSession(context.Context, *CreateSnowflakeSessionRequest) (*CreateSnowflakeSessionResponse, error)
	// GetSnowflakeSession returns a web session with sub kind Snowflake.
	GetSnowflakeSession(context.Context, *GetSnowflakeSessionRequest) (*GetSnowflakeSessionResponse, error)
	// GetSnowflakeSessions gets all Snowflake web sessions.
	GetSnowflakeSessions(context.Context, *emptypb.Empty) (*GetSnowflakeSessionsResponse, error)
	// DeleteSnowflakeSession removes a Snowflake web session.
	DeleteSnowflakeSession(context.Context, *DeleteSnowflakeSessionRequest) (*emptypb.Empty, error)
	// DeleteAllSnowflakeSessions removes all Snowflake web sessions.
	DeleteAllSnowflakeSessions(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// CreateSAMLIdPSession creates web session with sub kind saml_idp used by the SAML IdP.
	CreateSAMLIdPSession(context.Context, *CreateSAMLIdPSessionRequest) (*CreateSAMLIdPSessionResponse, error)
	// GetSAMLIdPSession returns a SAML IdP session with sub kind saml_idp.
	GetSAMLIdPSession(context.Context, *GetSAMLIdPSessionRequest) (*GetSAMLIdPSessionResponse, error)
	// ListSAMLIdPSessions gets all SAML IdP sessions.
	ListSAMLIdPSessions(context.Context, *ListSAMLIdPSessionsRequest) (*ListSAMLIdPSessionsResponse, error)
	// DeleteSAMLIdPSession removes a SAML IdP session.
	DeleteSAMLIdPSession(context.Context, *DeleteSAMLIdPSessionRequest) (*emptypb.Empty, error)
	// DeleteAllSAMLIdPSessions removes all SAML IdP sessions.
	DeleteAllSAMLIdPSessions(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// DeleteUserSAMLIdPSessions deletes all user’s SAML IdP sessions.
	DeleteUserSAMLIdPSessions(context.Context, *DeleteUserSAMLIdPSessionsRequest) (*emptypb.Empty, error)
	// GetWebSession gets a web session.
	GetWebSession(context.Context, *types.GetWebSessionRequest) (*GetWebSessionResponse, error)
	// GetWebSessions gets all web sessions.
	GetWebSessions(context.Context, *emptypb.Empty) (*GetWebSessionsResponse, error)
	// DeleteWebSession deletes a web session.
	DeleteWebSession(context.Context, *types.DeleteWebSessionRequest) (*emptypb.Empty, error)
	// DeleteAllWebSessions deletes all web sessions.
	DeleteAllWebSessions(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetWebToken gets a web token.
	GetWebToken(context.Context, *types.GetWebTokenRequest) (*GetWebTokenResponse, error)
	// GetWebTokens gets all web tokens.
	GetWebTokens(context.Context, *emptypb.Empty) (*GetWebTokensResponse, error)
	// DeleteWebToken deletes a web token.
	DeleteWebToken(context.Context, *types.DeleteWebTokenRequest) (*emptypb.Empty, error)
	// DeleteAllWebTokens deletes all web tokens.
	DeleteAllWebTokens(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// UpdateRemoteCluster updates remote cluster
	UpdateRemoteCluster(context.Context, *types.RemoteClusterV3) (*emptypb.Empty, error)
	// UpsertKubernetesServer adds or updates a kubernetes server.
	UpsertKubernetesServer(context.Context, *UpsertKubernetesServerRequest) (*types.KeepAlive, error)
	// DeleteKubernetesServer removes a kubernetes server.
	DeleteKubernetesServer(context.Context, *DeleteKubernetesServerRequest) (*emptypb.Empty, error)
	// DeleteAllKubernetesServers removes all kubernetes servers.
	DeleteAllKubernetesServers(context.Context, *DeleteAllKubernetesServersRequest) (*emptypb.Empty, error)
	// UpsertDatabaseServer registers a new database proxy server.
	UpsertDatabaseServer(context.Context, *UpsertDatabaseServerRequest) (*types.KeepAlive, error)
	// DeleteDatabaseServer removes the specified database proxy server.
	DeleteDatabaseServer(context.Context, *DeleteDatabaseServerRequest) (*emptypb.Empty, error)
	// DeleteAllDatabaseServers removes all registered database proxy servers.
	DeleteAllDatabaseServers(context.Context, *DeleteAllDatabaseServersRequest) (*emptypb.Empty, error)
	// UpsertDatabaseService registers a new DatabaseService.
	UpsertDatabaseService(context.Context, *UpsertDatabaseServiceRequest) (*types.KeepAlive, error)
	// DeleteDatabaseService removes the specified DatabaseService.
	DeleteDatabaseService(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// DeleteAllDatabaseServices removes all registered DatabaseServices.
	// If there's an error deleting the resources, there's no guarantee of a rollback.
	// A subset of resources might be deleted while others still exist.
	DeleteAllDatabaseServices(context.Context, *DeleteAllDatabaseServicesRequest) (*emptypb.Empty, error)
	// SignDatabaseCSR generates client certificate used by proxy to
	// authenticate with a remote database service.
	SignDatabaseCSR(context.Context, *DatabaseCSRRequest) (*DatabaseCSRResponse, error)
	// GenerateDatabaseCert generates client certificate used by a database
	// service to authenticate with the database instance.
	GenerateDatabaseCert(context.Context, *DatabaseCertRequest) (*DatabaseCertResponse, error)
	/// GenerateSnowflakeJWT generates JWT in the format required by Snowflake.
	GenerateSnowflakeJWT(context.Context, *SnowflakeJWTRequest) (*SnowflakeJWTResponse, error)
	// GetRole retrieves a role described by the given request.
	GetRole(context.Context, *GetRoleRequest) (*types.RoleV6, error)
	// GetRole retrieves all roles.
	//
	// DELETE IN 17.0
	GetRoles(context.Context, *emptypb.Empty) (*GetRolesResponse, error)
	// ListRoles is a paginated role getter.
	ListRoles(context.Context, *ListRolesRequest) (*ListRolesResponse, error)
	// CreateRole creates a new role.
	CreateRole(context.Context, *CreateRoleRequest) (*types.RoleV6, error)
	// UpdateRole updates an existing role.
	UpdateRole(context.Context, *UpdateRoleRequest) (*types.RoleV6, error)
	// UpsertRoleV2 creates or overwrites an existing role.
	UpsertRoleV2(context.Context, *UpsertRoleRequest) (*types.RoleV6, error)
	// UpsertRole upserts a role in a backend.
	//
	// Deprecated: use UpsertRoleV2 instead.
	UpsertRole(context.Context, *types.RoleV6) (*emptypb.Empty, error)
	// DeleteRole deletes an existing role in a backend described by the given request.
	DeleteRole(context.Context, *DeleteRoleRequest) (*emptypb.Empty, error)
	// AddMFADevice adds an MFA device for the user calling this RPC.
	//
	// The RPC is streaming both ways and the message sequence is:
	// (-> means client-to-server, <- means server-to-client)
	// -> Init
	// <- ExistingMFAChallenge
	// -> ExistingMFAResponse
	// <- NewMFARegisterChallenge
	// -> NewMFARegisterResponse
	// <- Ack
	//
	// Deprecated: Use [AddMFADeviceSync] instead.
	AddMFADevice(AuthService_AddMFADeviceServer) error
	// DeleteMFADevice deletes an MFA device for the user calling this RPC.
	//
	// The RPC is streaming both ways and the message sequence is:
	// (-> means client-to-server, <- means server-to-client)
	// -> Init
	// <- MFAChallenge
	// -> MFAResponse
	// <- Ack
	//
	// Deprecated: Use [DeleteMFADeviceSync] instead.
	DeleteMFADevice(AuthService_DeleteMFADeviceServer) error
	// AddMFADeviceSync adds a new MFA device.
	//
	// A typical MFA registration sequence calls the following RPCs:
	//
	// 1. CreateAuthenticateChallenge (necessary for registration challenge)
	// 2. (optional) CreatePrivilegeToken
	// 3. CreateRegisterChallenge (uses authn challenge and optionally a token)
	// 4. AddMFADeviceSync
	AddMFADeviceSync(context.Context, *AddMFADeviceSyncRequest) (*AddMFADeviceSyncResponse, error)
	// DeleteMFADeviceSync deletes a users MFA device (nonstream).
	//
	// A typical MFA deletion sequence calls the following RPCs:
	//
	// 1. (optional) CreateAuthenticateChallenge
	//    (may be skipped depending on the token used, but is usually called
	//    regardless)
	// 2. (optional) CreatePrivilegeToken
	// 3. DeleteMFADeviceSync (using either authn challenge or token)
	DeleteMFADeviceSync(context.Context, *DeleteMFADeviceSyncRequest) (*emptypb.Empty, error)
	// GetMFADevices returns all MFA devices registered for the user calling
	// this RPC.
	GetMFADevices(context.Context, *GetMFADevicesRequest) (*GetMFADevicesResponse, error)
	// CreateAuthenticateChallenge creates and returns MFA challenges for a users registered MFA
	// devices.
	CreateAuthenticateChallenge(context.Context, *CreateAuthenticateChallengeRequest) (*MFAAuthenticateChallenge, error)
	// CreateRegisterChallenge creates and returns MFA register challenge for a new MFA device.
	CreateRegisterChallenge(context.Context, *CreateRegisterChallengeRequest) (*MFARegisterChallenge, error)
	// GetOIDCConnector gets an OIDC connector resource by name.
	GetOIDCConnector(context.Context, *types.ResourceWithSecretsRequest) (*types.OIDCConnectorV3, error)
	// GetOIDCConnectors gets all current OIDC connector resources.
	GetOIDCConnectors(context.Context, *types.ResourcesWithSecretsRequest) (*types.OIDCConnectorV3List, error)
	// UpsertOIDCConnector creates a new OIDC connector in the backend.
	CreateOIDCConnector(context.Context, *CreateOIDCConnectorRequest) (*types.OIDCConnectorV3, error)
	// UpsertOIDCConnector updates an existing OIDC connector in the backend.
	UpdateOIDCConnector(context.Context, *UpdateOIDCConnectorRequest) (*types.OIDCConnectorV3, error)
	// UpsertOIDCConnector upserts an OIDC connector in a backend.
	//
	// Deprecated: Use UpsertOIDCConnectorV2 instead.
	UpsertOIDCConnector(context.Context, *types.OIDCConnectorV3) (*emptypb.Empty, error)
	// UpsertOIDCConnectorV2 upserts an OIDC connector in the backend.
	UpsertOIDCConnectorV2(context.Context, *UpsertOIDCConnectorRequest) (*types.OIDCConnectorV3, error)
	// DeleteOIDCConnector deletes an existing OIDC connector in a backend by name.
	DeleteOIDCConnector(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// CreateOIDCAuthRequest creates OIDCAuthRequest.
	CreateOIDCAuthRequest(context.Context, *types.OIDCAuthRequest) (*types.OIDCAuthRequest, error)
	// GetOIDCAuthRequest returns OIDC auth request if found.
	GetOIDCAuthRequest(context.Context, *GetOIDCAuthRequestRequest) (*types.OIDCAuthRequest, error)
	// GetSAMLConnector gets a SAML connector resource by name.
	GetSAMLConnector(context.Context, *types.ResourceWithSecretsRequest) (*types.SAMLConnectorV2, error)
	// GetSAMLConnectors gets all current SAML connector resources.
	GetSAMLConnectors(context.Context, *types.ResourcesWithSecretsRequest) (*types.SAMLConnectorV2List, error)
	// CreateSAMLConnector creates a new SAML connector in the backend.
	CreateSAMLConnector(context.Context, *CreateSAMLConnectorRequest) (*types.SAMLConnectorV2, error)
	// UpdateSAMLConnector updates an existing SAML connector in the backend.
	UpdateSAMLConnector(context.Context, *UpdateSAMLConnectorRequest) (*types.SAMLConnectorV2, error)
	// UpsertSAMLConnector upserts a SAML connector in a backend.
	//
	// Deprecated: Use UpsertSAMLConnectorV2 instead.
	UpsertSAMLConnector(context.Context, *types.SAMLConnectorV2) (*emptypb.Empty, error)
	// UpsertSAMLConnectorV2 upserts a SAML connector in a backend.
	UpsertSAMLConnectorV2(context.Context, *UpsertSAMLConnectorRequest) (*types.SAMLConnectorV2, error)
	// DeleteSAMLConnector deletes an existing SAML connector in a backend by name.
	DeleteSAMLConnector(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// CreateSAMLAuthRequest creates SAMLAuthRequest.
	CreateSAMLAuthRequest(context.Context, *types.SAMLAuthRequest) (*types.SAMLAuthRequest, error)
	// GetSAMLAuthRequest returns SAML auth request if found.
	GetSAMLAuthRequest(context.Context, *GetSAMLAuthRequestRequest) (*types.SAMLAuthRequest, error)
	// GetGithubConnector gets a Github connector resource by name.
	GetGithubConnector(context.Context, *types.ResourceWithSecretsRequest) (*types.GithubConnectorV3, error)
	// GetGithubConnectors gets all current Github connector resources.
	GetGithubConnectors(context.Context, *types.ResourcesWithSecretsRequest) (*types.GithubConnectorV3List, error)
	// CreateGithubConnector creates a new Github connector in the backend.
	CreateGithubConnector(context.Context, *CreateGithubConnectorRequest) (*types.GithubConnectorV3, error)
	// UpdateGithubConnector updates an existing Github connector in the backend.
	UpdateGithubConnector(context.Context, *UpdateGithubConnectorRequest) (*types.GithubConnectorV3, error)
	// UpsertGithubConnector upserts a Github connector in a backend.
	//
	// Deprecated: Use UpsertGithubConnectorV2 instead.
	UpsertGithubConnector(context.Context, *types.GithubConnectorV3) (*emptypb.Empty, error)
	// UpsertGithubConnectorV2 upserts a Github connector in a backend.
	UpsertGithubConnectorV2(context.Context, *UpsertGithubConnectorRequest) (*types.GithubConnectorV3, error)
	// DeleteGithubConnector deletes an existing Github connector in a backend by name.
	DeleteGithubConnector(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// CreateGithubAuthRequest creates GithubAuthRequest.
	CreateGithubAuthRequest(context.Context, *types.GithubAuthRequest) (*types.GithubAuthRequest, error)
	// GetGithubAuthRequest returns Github auth request if found.
	GetGithubAuthRequest(context.Context, *GetGithubAuthRequestRequest) (*types.GithubAuthRequest, error)
	// GetSSODiagnosticInfo returns SSO diagnostic info records.
	GetSSODiagnosticInfo(context.Context, *GetSSODiagnosticInfoRequest) (*types.SSODiagnosticInfo, error)
	// GetServerInfos returns a stream of ServerInfos.
	GetServerInfos(*emptypb.Empty, AuthService_GetServerInfosServer) error
	// GetServerInfo returns a ServerInfo by name.
	GetServerInfo(context.Context, *types.ResourceRequest) (*types.ServerInfoV1, error)
	// UpsertServerInfo upserts a ServerInfo.
	UpsertServerInfo(context.Context, *types.ServerInfoV1) (*emptypb.Empty, error)
	// DeleteServerInfo deletes a ServerInfo by name.
	DeleteServerInfo(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// DeleteAllServerInfos deletes all ServerInfos.
	DeleteAllServerInfos(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetTrustedCluster gets a Trusted Cluster resource by name.
	GetTrustedCluster(context.Context, *types.ResourceRequest) (*types.TrustedClusterV2, error)
	// GetTrustedClusters gets all current Trusted Cluster resources.
	GetTrustedClusters(context.Context, *emptypb.Empty) (*types.TrustedClusterV2List, error)
	// UpsertTrustedCluster upserts a Trusted Cluster in a backend.
	UpsertTrustedCluster(context.Context, *types.TrustedClusterV2) (*types.TrustedClusterV2, error)
	// DeleteTrustedCluster deletes an existing Trusted Cluster in a backend by name.
	DeleteTrustedCluster(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// GetToken retrieves a token described by the given request.
	GetToken(context.Context, *types.ResourceRequest) (*types.ProvisionTokenV2, error)
	// GetToken retrieves all tokens.
	GetTokens(context.Context, *emptypb.Empty) (*types.ProvisionTokenV2List, error)
	// CreateTokenV2 creates a token in a backend.
	CreateTokenV2(context.Context, *CreateTokenV2Request) (*emptypb.Empty, error)
	// UpsertTokenV2 upserts a token in a backend.
	UpsertTokenV2(context.Context, *UpsertTokenV2Request) (*emptypb.Empty, error)
	// DeleteToken deletes an existing token in a backend described by the given request.
	DeleteToken(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// GetClusterAuditConfig gets cluster audit configuration.
	GetClusterAuditConfig(context.Context, *emptypb.Empty) (*types.ClusterAuditConfigV2, error)
	// GetClusterNetworkingConfig gets cluster networking configuration.
	// Deprecated: Use clusterconfigv1.Service.GetClusterNetworkingConfig instead.
	GetClusterNetworkingConfig(context.Context, *emptypb.Empty) (*types.ClusterNetworkingConfigV2, error)
	// SetClusterNetworkingConfig sets cluster networking configuration.
	// Deprecated: Use clusterconfigv1.Service.Update/UpsertClusterNetworkingConfig instead.
	SetClusterNetworkingConfig(context.Context, *types.ClusterNetworkingConfigV2) (*emptypb.Empty, error)
	// ResetClusterNetworkingConfig resets cluster networking configuration to defaults.
	// Deprecated: Use clusterconfigv1.Service.ResetClusterNetworkingConfig instead.
	ResetClusterNetworkingConfig(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetSessionRecordingConfig gets session recording configuration.
	// Deprecated: Use clusterconfigv1.Service.GetSessionRecordingConfig instead.
	GetSessionRecordingConfig(context.Context, *emptypb.Empty) (*types.SessionRecordingConfigV2, error)
	// SetSessionRecordingConfig sets session recording configuration.
	// Deprecated: Use clusterconfigv1.Service.Upsert/UpdateSessionRecordingConfig instead.
	SetSessionRecordingConfig(context.Context, *types.SessionRecordingConfigV2) (*emptypb.Empty, error)
	// ResetSessionRecordingConfig resets session recording configuration to defaults.
	// Deprecated: Use clusterconfigv1.Service.ResetSessionRecordingConfig instead.
	ResetSessionRecordingConfig(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetAuthPreference gets cluster auth preference.
	// Deprecated: Use clusterconfigv1.Service.GetAuthPreference instead.
	GetAuthPreference(context.Context, *emptypb.Empty) (*types.AuthPreferenceV2, error)
	// SetAuthPreference sets cluster auth preference.
	// Deprecated: Use clusterconfigv1.Service.Create/Update/UpsertAuthPreference instead.
	SetAuthPreference(context.Context, *types.AuthPreferenceV2) (*emptypb.Empty, error)
	// ResetAuthPreference resets cluster auth preference to defaults.
	// Deprecated: Use clusterconfigv1.Service.ResetAuthPreference instead.
	ResetAuthPreference(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetUIConfig gets the configuration for the UI served by the proxy service
	GetUIConfig(context.Context, *emptypb.Empty) (*types.UIConfigV1, error)
	// SetUIConfig sets the configuration for the UI served by the proxy service
	SetUIConfig(context.Context, *types.UIConfigV1) (*emptypb.Empty, error)
	// DeleteUIConfig deletes the custom configuration for the UI served by the proxy service
	DeleteUIConfig(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetEvents gets events from the audit log.
	GetEvents(context.Context, *GetEventsRequest) (*Events, error)
	// GetSessionEvents gets completed session events from the audit log.
	GetSessionEvents(context.Context, *GetSessionEventsRequest) (*Events, error)
	// GetLock gets a lock by name.
	GetLock(context.Context, *GetLockRequest) (*types.LockV2, error)
	// GetLocks gets all/in-force locks that match at least one of the targets when specified.
	GetLocks(context.Context, *GetLocksRequest) (*GetLocksResponse, error)
	// UpsertLock upserts a lock.
	UpsertLock(context.Context, *types.LockV2) (*emptypb.Empty, error)
	// DeleteLock deletes a lock.
	DeleteLock(context.Context, *DeleteLockRequest) (*emptypb.Empty, error)
	// ReplaceRemoteLocks replaces the set of locks associated with a remote cluster.
	ReplaceRemoteLocks(context.Context, *ReplaceRemoteLocksRequest) (*emptypb.Empty, error)
	// StreamSessionEvents streams audit events from a given session recording.
	StreamSessionEvents(*StreamSessionEventsRequest, AuthService_StreamSessionEventsServer) error
	// GetNetworkRestrictions retrieves all the network restrictions (allow/deny lists).
	GetNetworkRestrictions(context.Context, *emptypb.Empty) (*types.NetworkRestrictionsV4, error)
	// SetNetworkRestrictions updates the network restrictions.
	SetNetworkRestrictions(context.Context, *types.NetworkRestrictionsV4) (*emptypb.Empty, error)
	// DeleteNetworkRestrictions delete the network restrictions.
	DeleteNetworkRestrictions(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetApps returns all registered applications.
	GetApps(context.Context, *emptypb.Empty) (*types.AppV3List, error)
	// GetApp returns an application by name.
	GetApp(context.Context, *types.ResourceRequest) (*types.AppV3, error)
	// CreateApp creates a new application resource.
	CreateApp(context.Context, *types.AppV3) (*emptypb.Empty, error)
	// UpdateApp updates existing application resource.
	UpdateApp(context.Context, *types.AppV3) (*emptypb.Empty, error)
	// DeleteApp removes specified application resource.
	DeleteApp(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// DeleteAllApps removes all application resources.
	DeleteAllApps(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetDatabases returns all registered databases.
	GetDatabases(context.Context, *emptypb.Empty) (*types.DatabaseV3List, error)
	// GetDatabase returns a database by name.
	GetDatabase(context.Context, *types.ResourceRequest) (*types.DatabaseV3, error)
	// CreateDatabase creates a new database resource.
	CreateDatabase(context.Context, *types.DatabaseV3) (*emptypb.Empty, error)
	// UpdateDatabase updates existing database resource.
	UpdateDatabase(context.Context, *types.DatabaseV3) (*emptypb.Empty, error)
	// DeleteDatabase removes specified database resource.
	DeleteDatabase(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// DeleteAllDatabases removes all database resources.
	DeleteAllDatabases(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetKubernetesClusters returns all registered kubernetes clusters.
	GetKubernetesClusters(context.Context, *emptypb.Empty) (*types.KubernetesClusterV3List, error)
	// GetKubernetesCluster returns a kubernetes cluster by name.
	GetKubernetesCluster(context.Context, *types.ResourceRequest) (*types.KubernetesClusterV3, error)
	// CreateKubernetesCluster creates a new kubernetes cluster resource.
	CreateKubernetesCluster(context.Context, *types.KubernetesClusterV3) (*emptypb.Empty, error)
	// UpdateKubernetesCluster updates existing kubernetes cluster resource.
	UpdateKubernetesCluster(context.Context, *types.KubernetesClusterV3) (*emptypb.Empty, error)
	// DeleteKubernetesCluster removes specified kubernetes cluster resource.
	DeleteKubernetesCluster(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// DeleteAllKubernetesClusters removes all kubernetes cluster resources.
	DeleteAllKubernetesClusters(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetWindowsDesktopServices returns all registered Windows desktop services.
	GetWindowsDesktopServices(context.Context, *emptypb.Empty) (*GetWindowsDesktopServicesResponse, error)
	// GetWindowsDesktopService gets a Windows desktop service by name.
	GetWindowsDesktopService(context.Context, *GetWindowsDesktopServiceRequest) (*GetWindowsDesktopServiceResponse, error)
	// UpsertWindowsDesktopService registers a new Windows desktop service.
	UpsertWindowsDesktopService(context.Context, *types.WindowsDesktopServiceV3) (*types.KeepAlive, error)
	// DeleteWindowsDesktopService removes the specified Windows desktop service.
	DeleteWindowsDesktopService(context.Context, *DeleteWindowsDesktopServiceRequest) (*emptypb.Empty, error)
	// DeleteAllWindowsDesktopServices removes all registered Windows desktop services.
	DeleteAllWindowsDesktopServices(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetWindowsDesktops returns all registered Windows desktop hosts matching the supplied filter.
	GetWindowsDesktops(context.Context, *types.WindowsDesktopFilter) (*GetWindowsDesktopsResponse, error)
	// CreateWindowsDesktop registers a new Windows desktop host.
	CreateWindowsDesktop(context.Context, *types.WindowsDesktopV3) (*emptypb.Empty, error)
	// UpdateWindowsDesktop updates an existing Windows desktop host.
	UpdateWindowsDesktop(context.Context, *types.WindowsDesktopV3) (*emptypb.Empty, error)
	// UpsertWindowsDesktop updates a Windows desktop host, creating it if it doesn't exist.
	UpsertWindowsDesktop(context.Context, *types.WindowsDesktopV3) (*emptypb.Empty, error)
	// DeleteWindowsDesktop removes the specified Windows desktop host.
	// Unlike GetWindowsDesktops, this call will delete at-most 1 desktop.
	// To delete all desktops, use DeleteAllWindowsDesktops.
	DeleteWindowsDesktop(context.Context, *DeleteWindowsDesktopRequest) (*emptypb.Empty, error)
	// DeleteAllWindowsDesktops removes all registered Windows desktop hosts.
	DeleteAllWindowsDesktops(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GenerateWindowsDesktopCert generates client smartcard certificate used
	// by an RDP client to authenticate with Windows.
	GenerateWindowsDesktopCert(context.Context, *WindowsDesktopCertRequest) (*WindowsDesktopCertResponse, error)
	// GenerateCertAuthorityCRL creates an empty CRL for the specified CA.
	GenerateCertAuthorityCRL(context.Context, *CertAuthorityRequest) (*CRL, error)
	// GetDesktopBootstrapScript returns a PowerShell script to bootstrap Active Directory.
	GetDesktopBootstrapScript(context.Context, *emptypb.Empty) (*DesktopBootstrapScriptResponse, error)
	// CreateConnectionDiagnostic creates a new connection diagnostic.
	CreateConnectionDiagnostic(context.Context, *types.ConnectionDiagnosticV1) (*emptypb.Empty, error)
	// UpdateConnectionDiagnostic updates a connection diagnostic.
	UpdateConnectionDiagnostic(context.Context, *types.ConnectionDiagnosticV1) (*emptypb.Empty, error)
	// GetConnectionDiagnostic reads a connection diagnostic.
	GetConnectionDiagnostic(context.Context, *GetConnectionDiagnosticRequest) (*types.ConnectionDiagnosticV1, error)
	// AppendDiagnosticTrace appends a Trace to the ConnectionDiagnostic.
	AppendDiagnosticTrace(context.Context, *AppendDiagnosticTraceRequest) (*types.ConnectionDiagnosticV1, error)
	// ChangeUserAuthentication allows a user to change their password and if enabled,
	// also adds a new MFA device. After successful invocation, a new web session is created as well
	// as a new set of recovery codes (if user meets the requirements to receive them), invalidating
	// any existing codes the user previously had.
	//
	// Only local users may be targeted by this RPC.
	ChangeUserAuthentication(context.Context, *ChangeUserAuthenticationRequest) (*ChangeUserAuthenticationResponse, error)
	// StartAccountRecovery (exclusive to cloud users) is the first out of two step user
	// verification needed to allow a user to recover their account. The first form of verification
	// is a user's username and a recovery code. After successful verification, a recovery start
	// token is created for the user which its ID will be used as part of a URL that will be emailed
	// to the user (not done in this request). The user will be able to finish their second form of
	// verification by clicking on this URL and following the prompts.
	//
	// If a valid user fails to provide correct recovery code for MaxAccountRecoveryAttempts,
	// user account gets temporarily locked from further recovery attempts and from logging in.
	//
	// Start tokens last RecoveryStartTokenTTL.
	//
	// Only local users may perform account recovery
	StartAccountRecovery(context.Context, *StartAccountRecoveryRequest) (*types.UserTokenV3, error)
	// VerifyAccountRecovery (exclusive to cloud users) is the second step of the two step
	// verification needed to allow a user to recover their account, after RPC StartAccountRecovery.
	// The second form of verification is a user's password or their second factor (depending on
	// what authentication they needed to recover). After successful verification, a recovery
	// approved token is created which allows a user to request protected actions while not logged
	// in e.g: setting a new password or a mfa device, viewing their MFA devices, deleting their MFA
	// devices, and generating new recovery codes.
	//
	// The recovery start token to verify this request becomes deleted before
	// creating a recovery approved token, which invalidates the recovery link users received
	// to finish their verification.
	//
	// If user fails to verify themselves for MaxAccountRecoveryAttempts
	// (combined attempts with RPC StartAccountRecovery), users account will be temporarily locked
	// from logging in. If users still have unused recovery codes left, they still have
	// opportunities to recover their account. To allow this, users recovery attempts are also
	// deleted along with all user tokens which will force the user to restart the recovery process
	// from step 1 (RPC StartAccountRecovery).
	//
	// Recovery approved tokens last RecoveryApprovedTokenTTL.
	VerifyAccountRecovery(context.Context, *VerifyAccountRecoveryRequest) (*types.UserTokenV3, error)
	// CompleteAccountRecovery (exclusive to cloud users) is the last step in account
	// recovery, after RPC's StartAccountRecovery and VerifyAccountRecovery. This step sets a new
	// password or adds a new mfa device, allowing the user to regain access to their account with
	// the new credentials. When the new authentication is successfully set, any user lock is
	// removed so the user can login immediately afterwards.
	CompleteAccountRecovery(context.Context, *CompleteAccountRecoveryRequest) (*emptypb.Empty, error)
	// CreateAccountRecoveryCodes (exclusive to cloud users) creates new set of recovery codes for a
	// user, replacing and invalidating any previously owned codes. Users can only get recovery
	// codes if their username is in a valid email format.
	CreateAccountRecoveryCodes(context.Context, *CreateAccountRecoveryCodesRequest) (*RecoveryCodes, error)
	// GetAccountRecoveryToken (exclusive to cloud users) returns a user token resource after
	// verifying that the token requested has not expired and is of the correct recovery kind.
	// Besides checking for validity of a token ID, it is also used to get basic information from
	// the token e.g: username, state of recovery (started or approved) and the type of recovery
	// requested (password or second factor).
	GetAccountRecoveryToken(context.Context, *GetAccountRecoveryTokenRequest) (*types.UserTokenV3, error)
	// GetAccountRecoveryCodes (exclusive to cloud users) is a request to return the user in context
	// their recovery codes. This request will not return any secrets (the values of recovery
	// codes), but instead returns non-sensitive data eg. when the recovery codes were created.
	GetAccountRecoveryCodes(context.Context, *GetAccountRecoveryCodesRequest) (*RecoveryCodes, error)
	// CreatePrivilegeToken returns a new privilege token after a logged in user successfully
	// re-authenticates with their second factor device. Privilege token lasts PrivilegeTokenTTL and
	// is used to gain access to privileged actions eg: deleting/adding a MFA device.
	CreatePrivilegeToken(context.Context, *CreatePrivilegeTokenRequest) (*types.UserTokenV3, error)
	// GetInstaller retrieves the installer script resource
	GetInstaller(context.Context, *types.ResourceRequest) (*types.InstallerV1, error)
	// GetInstallers retrieves all of installer script resources.
	GetInstallers(context.Context, *emptypb.Empty) (*types.InstallerV1List, error)
	// SetInstaller sets the installer script resource
	SetInstaller(context.Context, *types.InstallerV1) (*emptypb.Empty, error)
	// DeleteInstaller removes the specified installer script resource
	DeleteInstaller(context.Context, *types.ResourceRequest) (*emptypb.Empty, error)
	// DeleteAllInstallers removes all installer script resources
	DeleteAllInstallers(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// ListResources retrieves a paginated list of resources.
	ListResources(context.Context, *ListResourcesRequest) (*ListResourcesResponse, error)
	// ListUnifiedResources retrieves a paginated list of all resource types displayable in the UI.
	ListUnifiedResources(context.Context, *ListUnifiedResourcesRequest) (*ListUnifiedResourcesResponse, error)
	// GetSSHTargets gets all servers that would match an equivalent ssh dial request. Note that this method
	// returns all resources directly accessible to the user *and* all resources available via 'SearchAsRoles',
	// which is what we want when handling things like ambiguous host errors and resource-based access requests,
	// but may result in confusing behavior if it is used outside of those contexts.
	GetSSHTargets(context.Context, *GetSSHTargetsRequest) (*GetSSHTargetsResponse, error)
	// GetDomainName returns local auth domain of the current auth server
	GetDomainName(context.Context, *emptypb.Empty) (*GetDomainNameResponse, error)
	// GetClusterCACert returns the PEM-encoded TLS certs for the local cluster
	// without signing keys. If the cluster has multiple TLS certs, they will
	// all be appended.
	GetClusterCACert(context.Context, *emptypb.Empty) (*GetClusterCACertResponse, error)
	// AssertSystemRole is used by agents to prove that they have a given system role when their
	// credentials originate from multiple separate join tokens so that they can be issued an instance
	// certificate that encompasses all of their capabilities. This method will be deprecated once we
	// have a more comprehensive model for join token joining/replacement.
	AssertSystemRole(context.Context, *SystemRoleAssertion) (*emptypb.Empty, error)
	// SubmitUsageEvent submits an external usage event.
	SubmitUsageEvent(context.Context, *SubmitUsageEventRequest) (*emptypb.Empty, error)
	// GetLicense returns the license used to start the auth server.
	GetLicense(context.Context, *GetLicenseRequest) (*GetLicenseResponse, error)
	// ListReleases returns a list of Teleport Enterprise releases.
	ListReleases(context.Context, *ListReleasesRequest) (*ListReleasesResponse, error)
	// ListSAMLIdPServiceProviders returns a paginated list of SAML IdP service provider resources.
	ListSAMLIdPServiceProviders(context.Context, *ListSAMLIdPServiceProvidersRequest) (*ListSAMLIdPServiceProvidersResponse, error)
	// GetSAMLIdPServiceProvider returns the specified SAML IdP service provider resources.
	GetSAMLIdPServiceProvider(context.Context, *GetSAMLIdPServiceProviderRequest) (*types.SAMLIdPServiceProviderV1, error)
	// CreateSAMLIdPServiceProvider creates a new SAML IdP service provider resource.
	CreateSAMLIdPServiceProvider(context.Context, *types.SAMLIdPServiceProviderV1) (*emptypb.Empty, error)
	// UpdateSAMLIdPServiceProvider updates an existing SAML IdP service provider resource.
	UpdateSAMLIdPServiceProvider(context.Context, *types.SAMLIdPServiceProviderV1) (*emptypb.Empty, error)
	// DeleteSAMLIdPServiceProvider removes the specified SAML IdP service provider resource.
	DeleteSAMLIdPServiceProvider(context.Context, *DeleteSAMLIdPServiceProviderRequest) (*emptypb.Empty, error)
	// DeleteAllSAMLIdPServiceProviders removes all SAML IdP service providers.
	DeleteAllSAMLIdPServiceProviders(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// ListUserGroups returns a paginated list of user group resources.
	ListUserGroups(context.Context, *ListUserGroupsRequest) (*ListUserGroupsResponse, error)
	// GetUserGroup returns the specified user group resource.
	GetUserGroup(context.Context, *GetUserGroupRequest) (*types.UserGroupV1, error)
	// CreateUserGroup creates a new user group resource.
	CreateUserGroup(context.Context, *types.UserGroupV1) (*emptypb.Empty, error)
	// UpdateUserGroup updates an existing user group resource.
	UpdateUserGroup(context.Context, *types.UserGroupV1) (*emptypb.Empty, error)
	// DeleteUserGroup removes the specified user group resource.
	DeleteUserGroup(context.Context, *DeleteUserGroupRequest) (*emptypb.Empty, error)
	// DeleteAllUserGroups removes all user groups.
	DeleteAllUserGroups(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// GetHeadlessAuthentication is a request to retrieve a headless authentication from the backend.
	GetHeadlessAuthentication(context.Context, *GetHeadlessAuthenticationRequest) (*types.HeadlessAuthentication, error)
	// WatchPendingHeadlessAuthentications watches the backend for pending headless authentication requests for the user.
	WatchPendingHeadlessAuthentications(*emptypb.Empty, AuthService_WatchPendingHeadlessAuthenticationsServer) error
	// UpdateHeadlessAuthenticationState is a request to update a headless authentication's state.
	UpdateHeadlessAuthenticationState(context.Context, *UpdateHeadlessAuthenticationStateRequest) (*emptypb.Empty, error)
	// ExportUpgradeWindows is used to load derived maintenance window values for agents that
	// need to export schedules to external upgraders.
	ExportUpgradeWindows(context.Context, *ExportUpgradeWindowsRequest) (*ExportUpgradeWindowsResponse, error)
	// GetClusterMaintenanceConfig gets the current maintenance window config singleton.
	GetClusterMaintenanceConfig(context.Context, *emptypb.Empty) (*types.ClusterMaintenanceConfigV1, error)
	// UpdateClusterMaintenanceConfig updates the current maintenance window config singleton.
	UpdateClusterMaintenanceConfig(context.Context, *types.ClusterMaintenanceConfigV1) (*emptypb.Empty, error)
	// DeleteClusterMaintenanceConfig deletes the current maintenance window config singleton.
	DeleteClusterMaintenanceConfig(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
}

// UnimplementedAuthServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (*UnimplementedAuthServiceServer) InventoryControlStream(srv AuthService_InventoryControlStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InventoryControlStream not implemented")
}
func (*UnimplementedAuthServiceServer) GetInventoryStatus(ctx context.Context, req *InventoryStatusRequest) (*InventoryStatusSummary, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInventoryStatus not implemented")
}
func (*UnimplementedAuthServiceServer) GetInventoryConnectedServiceCounts(ctx context.Context, req *InventoryConnectedServiceCountsRequest) (*InventoryConnectedServiceCounts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInventoryConnectedServiceCounts not implemented")
}
func (*UnimplementedAuthServiceServer) PingInventory(ctx context.Context, req *InventoryPingRequest) (*InventoryPingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingInventory not implemented")
}
func (*UnimplementedAuthServiceServer) GetInstances(req *types.InstanceFilter, srv AuthService_GetInstancesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetInstances not implemented")
}
func (*UnimplementedAuthServiceServer) GetClusterAlerts(ctx context.Context, req *types.GetClusterAlertsRequest) (*GetClusterAlertsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterAlerts not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertClusterAlert(ctx context.Context, req *UpsertClusterAlertRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertClusterAlert not implemented")
}
func (*UnimplementedAuthServiceServer) CreateAlertAck(ctx context.Context, req *types.AlertAcknowledgement) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAlertAck not implemented")
}
func (*UnimplementedAuthServiceServer) GetAlertAcks(ctx context.Context, req *GetAlertAcksRequest) (*GetAlertAcksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAlertAcks not implemented")
}
func (*UnimplementedAuthServiceServer) ClearAlertAcks(ctx context.Context, req *ClearAlertAcksRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearAlertAcks not implemented")
}
func (*UnimplementedAuthServiceServer) MaintainSessionPresence(srv AuthService_MaintainSessionPresenceServer) error {
	return status.Errorf(codes.Unimplemented, "method MaintainSessionPresence not implemented")
}
func (*UnimplementedAuthServiceServer) CreateSessionTracker(ctx context.Context, req *CreateSessionTrackerRequest) (*types.SessionTrackerV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSessionTracker not implemented")
}
func (*UnimplementedAuthServiceServer) GetSessionTracker(ctx context.Context, req *GetSessionTrackerRequest) (*types.SessionTrackerV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessionTracker not implemented")
}
func (*UnimplementedAuthServiceServer) GetActiveSessionTrackers(req *emptypb.Empty, srv AuthService_GetActiveSessionTrackersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetActiveSessionTrackers not implemented")
}
func (*UnimplementedAuthServiceServer) GetActiveSessionTrackersWithFilter(req *types.SessionTrackerFilter, srv AuthService_GetActiveSessionTrackersWithFilterServer) error {
	return status.Errorf(codes.Unimplemented, "method GetActiveSessionTrackersWithFilter not implemented")
}
func (*UnimplementedAuthServiceServer) RemoveSessionTracker(ctx context.Context, req *RemoveSessionTrackerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSessionTracker not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateSessionTracker(ctx context.Context, req *UpdateSessionTrackerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSessionTracker not implemented")
}
func (*UnimplementedAuthServiceServer) SendKeepAlives(srv AuthService_SendKeepAlivesServer) error {
	return status.Errorf(codes.Unimplemented, "method SendKeepAlives not implemented")
}
func (*UnimplementedAuthServiceServer) WatchEvents(req *Watch, srv AuthService_WatchEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchEvents not implemented")
}
func (*UnimplementedAuthServiceServer) GetNode(ctx context.Context, req *types.ResourceInNamespaceRequest) (*types.ServerV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertNode(ctx context.Context, req *types.ServerV2) (*types.KeepAlive, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertNode not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteNode(ctx context.Context, req *types.ResourceInNamespaceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllNodes(ctx context.Context, req *types.ResourcesInNamespaceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllNodes not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateUserCerts(ctx context.Context, req *UserCertsRequest) (*Certs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateUserCerts not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateHostCerts(ctx context.Context, req *HostCertsRequest) (*Certs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateHostCerts not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateUserSingleUseCerts(srv AuthService_GenerateUserSingleUseCertsServer) error {
	return status.Errorf(codes.Unimplemented, "method GenerateUserSingleUseCerts not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateOpenSSHCert(ctx context.Context, req *OpenSSHCertRequest) (*OpenSSHCert, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateOpenSSHCert not implemented")
}
func (*UnimplementedAuthServiceServer) IsMFARequired(ctx context.Context, req *IsMFARequiredRequest) (*IsMFARequiredResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsMFARequired not implemented")
}
func (*UnimplementedAuthServiceServer) GetAccessRequestsV2(req *types.AccessRequestFilter, srv AuthService_GetAccessRequestsV2Server) error {
	return status.Errorf(codes.Unimplemented, "method GetAccessRequestsV2 not implemented")
}
func (*UnimplementedAuthServiceServer) ListAccessRequests(ctx context.Context, req *ListAccessRequestsRequest) (*ListAccessRequestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAccessRequests not implemented")
}
func (*UnimplementedAuthServiceServer) CreateAccessRequest(ctx context.Context, req *types.AccessRequestV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccessRequest not implemented")
}
func (*UnimplementedAuthServiceServer) CreateAccessRequestV2(ctx context.Context, req *types.AccessRequestV3) (*types.AccessRequestV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccessRequestV2 not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAccessRequest(ctx context.Context, req *RequestID) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccessRequest not implemented")
}
func (*UnimplementedAuthServiceServer) SetAccessRequestState(ctx context.Context, req *RequestStateSetter) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAccessRequestState not implemented")
}
func (*UnimplementedAuthServiceServer) SubmitAccessReview(ctx context.Context, req *types.AccessReviewSubmission) (*types.AccessRequestV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAccessReview not implemented")
}
func (*UnimplementedAuthServiceServer) GetAccessCapabilities(ctx context.Context, req *types.AccessCapabilitiesRequest) (*types.AccessCapabilities, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessCapabilities not implemented")
}
func (*UnimplementedAuthServiceServer) GetAccessRequestAllowedPromotions(ctx context.Context, req *AccessRequestAllowedPromotionRequest) (*AccessRequestAllowedPromotionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessRequestAllowedPromotions not implemented")
}
func (*UnimplementedAuthServiceServer) GetPluginData(ctx context.Context, req *types.PluginDataFilter) (*PluginDataSeq, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginData not implemented")
}
func (*UnimplementedAuthServiceServer) UpdatePluginData(ctx context.Context, req *types.PluginDataUpdateParams) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePluginData not implemented")
}
func (*UnimplementedAuthServiceServer) Ping(ctx context.Context, req *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedAuthServiceServer) GetResetPasswordToken(ctx context.Context, req *GetResetPasswordTokenRequest) (*types.UserTokenV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResetPasswordToken not implemented")
}
func (*UnimplementedAuthServiceServer) CreateResetPasswordToken(ctx context.Context, req *CreateResetPasswordTokenRequest) (*types.UserTokenV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateResetPasswordToken not implemented")
}
func (*UnimplementedAuthServiceServer) GetUser(ctx context.Context, req *GetUserRequest) (*types.UserV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (*UnimplementedAuthServiceServer) GetCurrentUser(ctx context.Context, req *emptypb.Empty) (*types.UserV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentUser not implemented")
}
func (*UnimplementedAuthServiceServer) GetCurrentUserRoles(req *emptypb.Empty, srv AuthService_GetCurrentUserRolesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetCurrentUserRoles not implemented")
}
func (*UnimplementedAuthServiceServer) GetUsers(req *GetUsersRequest, srv AuthService_GetUsersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (*UnimplementedAuthServiceServer) CreateUser(ctx context.Context, req *types.UserV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateUser(ctx context.Context, req *types.UserV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteUser(ctx context.Context, req *DeleteUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (*UnimplementedAuthServiceServer) ChangePassword(ctx context.Context, req *ChangePasswordRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (*UnimplementedAuthServiceServer) AcquireSemaphore(ctx context.Context, req *types.AcquireSemaphoreRequest) (*types.SemaphoreLease, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcquireSemaphore not implemented")
}
func (*UnimplementedAuthServiceServer) KeepAliveSemaphoreLease(ctx context.Context, req *types.SemaphoreLease) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeepAliveSemaphoreLease not implemented")
}
func (*UnimplementedAuthServiceServer) CancelSemaphoreLease(ctx context.Context, req *types.SemaphoreLease) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSemaphoreLease not implemented")
}
func (*UnimplementedAuthServiceServer) GetSemaphores(ctx context.Context, req *types.SemaphoreFilter) (*Semaphores, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSemaphores not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteSemaphore(ctx context.Context, req *types.SemaphoreFilter) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSemaphore not implemented")
}
func (*UnimplementedAuthServiceServer) EmitAuditEvent(ctx context.Context, req *events.OneOf) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmitAuditEvent not implemented")
}
func (*UnimplementedAuthServiceServer) CreateAuditStream(srv AuthService_CreateAuditStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateAuditStream not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertApplicationServer(ctx context.Context, req *UpsertApplicationServerRequest) (*types.KeepAlive, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertApplicationServer not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteApplicationServer(ctx context.Context, req *DeleteApplicationServerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApplicationServer not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllApplicationServers(ctx context.Context, req *DeleteAllApplicationServersRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllApplicationServers not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateAppToken(ctx context.Context, req *GenerateAppTokenRequest) (*GenerateAppTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateAppToken not implemented")
}
func (*UnimplementedAuthServiceServer) GetAppSession(ctx context.Context, req *GetAppSessionRequest) (*GetAppSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppSession not implemented")
}
func (*UnimplementedAuthServiceServer) ListAppSessions(ctx context.Context, req *ListAppSessionsRequest) (*ListAppSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAppSessions not implemented")
}
func (*UnimplementedAuthServiceServer) CreateAppSession(ctx context.Context, req *CreateAppSessionRequest) (*CreateAppSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAppSession not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAppSession(ctx context.Context, req *DeleteAppSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAppSession not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllAppSessions(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllAppSessions not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteUserAppSessions(ctx context.Context, req *DeleteUserAppSessionsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserAppSessions not implemented")
}
func (*UnimplementedAuthServiceServer) CreateSnowflakeSession(ctx context.Context, req *CreateSnowflakeSessionRequest) (*CreateSnowflakeSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSnowflakeSession not implemented")
}
func (*UnimplementedAuthServiceServer) GetSnowflakeSession(ctx context.Context, req *GetSnowflakeSessionRequest) (*GetSnowflakeSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSnowflakeSession not implemented")
}
func (*UnimplementedAuthServiceServer) GetSnowflakeSessions(ctx context.Context, req *emptypb.Empty) (*GetSnowflakeSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSnowflakeSessions not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteSnowflakeSession(ctx context.Context, req *DeleteSnowflakeSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSnowflakeSession not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllSnowflakeSessions(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllSnowflakeSessions not implemented")
}
func (*UnimplementedAuthServiceServer) CreateSAMLIdPSession(ctx context.Context, req *CreateSAMLIdPSessionRequest) (*CreateSAMLIdPSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSAMLIdPSession not implemented")
}
func (*UnimplementedAuthServiceServer) GetSAMLIdPSession(ctx context.Context, req *GetSAMLIdPSessionRequest) (*GetSAMLIdPSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSAMLIdPSession not implemented")
}
func (*UnimplementedAuthServiceServer) ListSAMLIdPSessions(ctx context.Context, req *ListSAMLIdPSessionsRequest) (*ListSAMLIdPSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSAMLIdPSessions not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteSAMLIdPSession(ctx context.Context, req *DeleteSAMLIdPSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSAMLIdPSession not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllSAMLIdPSessions(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllSAMLIdPSessions not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteUserSAMLIdPSessions(ctx context.Context, req *DeleteUserSAMLIdPSessionsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserSAMLIdPSessions not implemented")
}
func (*UnimplementedAuthServiceServer) GetWebSession(ctx context.Context, req *types.GetWebSessionRequest) (*GetWebSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWebSession not implemented")
}
func (*UnimplementedAuthServiceServer) GetWebSessions(ctx context.Context, req *emptypb.Empty) (*GetWebSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWebSessions not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteWebSession(ctx context.Context, req *types.DeleteWebSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebSession not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllWebSessions(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllWebSessions not implemented")
}
func (*UnimplementedAuthServiceServer) GetWebToken(ctx context.Context, req *types.GetWebTokenRequest) (*GetWebTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWebToken not implemented")
}
func (*UnimplementedAuthServiceServer) GetWebTokens(ctx context.Context, req *emptypb.Empty) (*GetWebTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWebTokens not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteWebToken(ctx context.Context, req *types.DeleteWebTokenRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWebToken not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllWebTokens(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllWebTokens not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateRemoteCluster(ctx context.Context, req *types.RemoteClusterV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRemoteCluster not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertKubernetesServer(ctx context.Context, req *UpsertKubernetesServerRequest) (*types.KeepAlive, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertKubernetesServer not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteKubernetesServer(ctx context.Context, req *DeleteKubernetesServerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKubernetesServer not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllKubernetesServers(ctx context.Context, req *DeleteAllKubernetesServersRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllKubernetesServers not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertDatabaseServer(ctx context.Context, req *UpsertDatabaseServerRequest) (*types.KeepAlive, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertDatabaseServer not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteDatabaseServer(ctx context.Context, req *DeleteDatabaseServerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDatabaseServer not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllDatabaseServers(ctx context.Context, req *DeleteAllDatabaseServersRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllDatabaseServers not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertDatabaseService(ctx context.Context, req *UpsertDatabaseServiceRequest) (*types.KeepAlive, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertDatabaseService not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteDatabaseService(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDatabaseService not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllDatabaseServices(ctx context.Context, req *DeleteAllDatabaseServicesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllDatabaseServices not implemented")
}
func (*UnimplementedAuthServiceServer) SignDatabaseCSR(ctx context.Context, req *DatabaseCSRRequest) (*DatabaseCSRResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignDatabaseCSR not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateDatabaseCert(ctx context.Context, req *DatabaseCertRequest) (*DatabaseCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateDatabaseCert not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateSnowflakeJWT(ctx context.Context, req *SnowflakeJWTRequest) (*SnowflakeJWTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateSnowflakeJWT not implemented")
}
func (*UnimplementedAuthServiceServer) GetRole(ctx context.Context, req *GetRoleRequest) (*types.RoleV6, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (*UnimplementedAuthServiceServer) GetRoles(ctx context.Context, req *emptypb.Empty) (*GetRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoles not implemented")
}
func (*UnimplementedAuthServiceServer) ListRoles(ctx context.Context, req *ListRolesRequest) (*ListRolesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRoles not implemented")
}
func (*UnimplementedAuthServiceServer) CreateRole(ctx context.Context, req *CreateRoleRequest) (*types.RoleV6, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateRole(ctx context.Context, req *UpdateRoleRequest) (*types.RoleV6, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertRoleV2(ctx context.Context, req *UpsertRoleRequest) (*types.RoleV6, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertRoleV2 not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertRole(ctx context.Context, req *types.RoleV6) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertRole not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteRole(ctx context.Context, req *DeleteRoleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (*UnimplementedAuthServiceServer) AddMFADevice(srv AuthService_AddMFADeviceServer) error {
	return status.Errorf(codes.Unimplemented, "method AddMFADevice not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteMFADevice(srv AuthService_DeleteMFADeviceServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteMFADevice not implemented")
}
func (*UnimplementedAuthServiceServer) AddMFADeviceSync(ctx context.Context, req *AddMFADeviceSyncRequest) (*AddMFADeviceSyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMFADeviceSync not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteMFADeviceSync(ctx context.Context, req *DeleteMFADeviceSyncRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMFADeviceSync not implemented")
}
func (*UnimplementedAuthServiceServer) GetMFADevices(ctx context.Context, req *GetMFADevicesRequest) (*GetMFADevicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMFADevices not implemented")
}
func (*UnimplementedAuthServiceServer) CreateAuthenticateChallenge(ctx context.Context, req *CreateAuthenticateChallengeRequest) (*MFAAuthenticateChallenge, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthenticateChallenge not implemented")
}
func (*UnimplementedAuthServiceServer) CreateRegisterChallenge(ctx context.Context, req *CreateRegisterChallengeRequest) (*MFARegisterChallenge, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRegisterChallenge not implemented")
}
func (*UnimplementedAuthServiceServer) GetOIDCConnector(ctx context.Context, req *types.ResourceWithSecretsRequest) (*types.OIDCConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOIDCConnector not implemented")
}
func (*UnimplementedAuthServiceServer) GetOIDCConnectors(ctx context.Context, req *types.ResourcesWithSecretsRequest) (*types.OIDCConnectorV3List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOIDCConnectors not implemented")
}
func (*UnimplementedAuthServiceServer) CreateOIDCConnector(ctx context.Context, req *CreateOIDCConnectorRequest) (*types.OIDCConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOIDCConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateOIDCConnector(ctx context.Context, req *UpdateOIDCConnectorRequest) (*types.OIDCConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOIDCConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertOIDCConnector(ctx context.Context, req *types.OIDCConnectorV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertOIDCConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertOIDCConnectorV2(ctx context.Context, req *UpsertOIDCConnectorRequest) (*types.OIDCConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertOIDCConnectorV2 not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteOIDCConnector(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOIDCConnector not implemented")
}
func (*UnimplementedAuthServiceServer) CreateOIDCAuthRequest(ctx context.Context, req *types.OIDCAuthRequest) (*types.OIDCAuthRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOIDCAuthRequest not implemented")
}
func (*UnimplementedAuthServiceServer) GetOIDCAuthRequest(ctx context.Context, req *GetOIDCAuthRequestRequest) (*types.OIDCAuthRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOIDCAuthRequest not implemented")
}
func (*UnimplementedAuthServiceServer) GetSAMLConnector(ctx context.Context, req *types.ResourceWithSecretsRequest) (*types.SAMLConnectorV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSAMLConnector not implemented")
}
func (*UnimplementedAuthServiceServer) GetSAMLConnectors(ctx context.Context, req *types.ResourcesWithSecretsRequest) (*types.SAMLConnectorV2List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSAMLConnectors not implemented")
}
func (*UnimplementedAuthServiceServer) CreateSAMLConnector(ctx context.Context, req *CreateSAMLConnectorRequest) (*types.SAMLConnectorV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSAMLConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateSAMLConnector(ctx context.Context, req *UpdateSAMLConnectorRequest) (*types.SAMLConnectorV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSAMLConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertSAMLConnector(ctx context.Context, req *types.SAMLConnectorV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertSAMLConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertSAMLConnectorV2(ctx context.Context, req *UpsertSAMLConnectorRequest) (*types.SAMLConnectorV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertSAMLConnectorV2 not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteSAMLConnector(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSAMLConnector not implemented")
}
func (*UnimplementedAuthServiceServer) CreateSAMLAuthRequest(ctx context.Context, req *types.SAMLAuthRequest) (*types.SAMLAuthRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSAMLAuthRequest not implemented")
}
func (*UnimplementedAuthServiceServer) GetSAMLAuthRequest(ctx context.Context, req *GetSAMLAuthRequestRequest) (*types.SAMLAuthRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSAMLAuthRequest not implemented")
}
func (*UnimplementedAuthServiceServer) GetGithubConnector(ctx context.Context, req *types.ResourceWithSecretsRequest) (*types.GithubConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGithubConnector not implemented")
}
func (*UnimplementedAuthServiceServer) GetGithubConnectors(ctx context.Context, req *types.ResourcesWithSecretsRequest) (*types.GithubConnectorV3List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGithubConnectors not implemented")
}
func (*UnimplementedAuthServiceServer) CreateGithubConnector(ctx context.Context, req *CreateGithubConnectorRequest) (*types.GithubConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGithubConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateGithubConnector(ctx context.Context, req *UpdateGithubConnectorRequest) (*types.GithubConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGithubConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertGithubConnector(ctx context.Context, req *types.GithubConnectorV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertGithubConnector not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertGithubConnectorV2(ctx context.Context, req *UpsertGithubConnectorRequest) (*types.GithubConnectorV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertGithubConnectorV2 not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteGithubConnector(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGithubConnector not implemented")
}
func (*UnimplementedAuthServiceServer) CreateGithubAuthRequest(ctx context.Context, req *types.GithubAuthRequest) (*types.GithubAuthRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGithubAuthRequest not implemented")
}
func (*UnimplementedAuthServiceServer) GetGithubAuthRequest(ctx context.Context, req *GetGithubAuthRequestRequest) (*types.GithubAuthRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGithubAuthRequest not implemented")
}
func (*UnimplementedAuthServiceServer) GetSSODiagnosticInfo(ctx context.Context, req *GetSSODiagnosticInfoRequest) (*types.SSODiagnosticInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSSODiagnosticInfo not implemented")
}
func (*UnimplementedAuthServiceServer) GetServerInfos(req *emptypb.Empty, srv AuthService_GetServerInfosServer) error {
	return status.Errorf(codes.Unimplemented, "method GetServerInfos not implemented")
}
func (*UnimplementedAuthServiceServer) GetServerInfo(ctx context.Context, req *types.ResourceRequest) (*types.ServerInfoV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerInfo not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertServerInfo(ctx context.Context, req *types.ServerInfoV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertServerInfo not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteServerInfo(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteServerInfo not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllServerInfos(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllServerInfos not implemented")
}
func (*UnimplementedAuthServiceServer) GetTrustedCluster(ctx context.Context, req *types.ResourceRequest) (*types.TrustedClusterV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrustedCluster not implemented")
}
func (*UnimplementedAuthServiceServer) GetTrustedClusters(ctx context.Context, req *emptypb.Empty) (*types.TrustedClusterV2List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrustedClusters not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertTrustedCluster(ctx context.Context, req *types.TrustedClusterV2) (*types.TrustedClusterV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertTrustedCluster not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteTrustedCluster(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTrustedCluster not implemented")
}
func (*UnimplementedAuthServiceServer) GetToken(ctx context.Context, req *types.ResourceRequest) (*types.ProvisionTokenV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToken not implemented")
}
func (*UnimplementedAuthServiceServer) GetTokens(ctx context.Context, req *emptypb.Empty) (*types.ProvisionTokenV2List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokens not implemented")
}
func (*UnimplementedAuthServiceServer) CreateTokenV2(ctx context.Context, req *CreateTokenV2Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTokenV2 not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertTokenV2(ctx context.Context, req *UpsertTokenV2Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertTokenV2 not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteToken(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteToken not implemented")
}
func (*UnimplementedAuthServiceServer) GetClusterAuditConfig(ctx context.Context, req *emptypb.Empty) (*types.ClusterAuditConfigV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterAuditConfig not implemented")
}
func (*UnimplementedAuthServiceServer) GetClusterNetworkingConfig(ctx context.Context, req *emptypb.Empty) (*types.ClusterNetworkingConfigV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterNetworkingConfig not implemented")
}
func (*UnimplementedAuthServiceServer) SetClusterNetworkingConfig(ctx context.Context, req *types.ClusterNetworkingConfigV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetClusterNetworkingConfig not implemented")
}
func (*UnimplementedAuthServiceServer) ResetClusterNetworkingConfig(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetClusterNetworkingConfig not implemented")
}
func (*UnimplementedAuthServiceServer) GetSessionRecordingConfig(ctx context.Context, req *emptypb.Empty) (*types.SessionRecordingConfigV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessionRecordingConfig not implemented")
}
func (*UnimplementedAuthServiceServer) SetSessionRecordingConfig(ctx context.Context, req *types.SessionRecordingConfigV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSessionRecordingConfig not implemented")
}
func (*UnimplementedAuthServiceServer) ResetSessionRecordingConfig(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetSessionRecordingConfig not implemented")
}
func (*UnimplementedAuthServiceServer) GetAuthPreference(ctx context.Context, req *emptypb.Empty) (*types.AuthPreferenceV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthPreference not implemented")
}
func (*UnimplementedAuthServiceServer) SetAuthPreference(ctx context.Context, req *types.AuthPreferenceV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAuthPreference not implemented")
}
func (*UnimplementedAuthServiceServer) ResetAuthPreference(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetAuthPreference not implemented")
}
func (*UnimplementedAuthServiceServer) GetUIConfig(ctx context.Context, req *emptypb.Empty) (*types.UIConfigV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUIConfig not implemented")
}
func (*UnimplementedAuthServiceServer) SetUIConfig(ctx context.Context, req *types.UIConfigV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUIConfig not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteUIConfig(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUIConfig not implemented")
}
func (*UnimplementedAuthServiceServer) GetEvents(ctx context.Context, req *GetEventsRequest) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEvents not implemented")
}
func (*UnimplementedAuthServiceServer) GetSessionEvents(ctx context.Context, req *GetSessionEventsRequest) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessionEvents not implemented")
}
func (*UnimplementedAuthServiceServer) GetLock(ctx context.Context, req *GetLockRequest) (*types.LockV2, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLock not implemented")
}
func (*UnimplementedAuthServiceServer) GetLocks(ctx context.Context, req *GetLocksRequest) (*GetLocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocks not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertLock(ctx context.Context, req *types.LockV2) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertLock not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteLock(ctx context.Context, req *DeleteLockRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLock not implemented")
}
func (*UnimplementedAuthServiceServer) ReplaceRemoteLocks(ctx context.Context, req *ReplaceRemoteLocksRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplaceRemoteLocks not implemented")
}
func (*UnimplementedAuthServiceServer) StreamSessionEvents(req *StreamSessionEventsRequest, srv AuthService_StreamSessionEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSessionEvents not implemented")
}
func (*UnimplementedAuthServiceServer) GetNetworkRestrictions(ctx context.Context, req *emptypb.Empty) (*types.NetworkRestrictionsV4, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNetworkRestrictions not implemented")
}
func (*UnimplementedAuthServiceServer) SetNetworkRestrictions(ctx context.Context, req *types.NetworkRestrictionsV4) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNetworkRestrictions not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteNetworkRestrictions(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNetworkRestrictions not implemented")
}
func (*UnimplementedAuthServiceServer) GetApps(ctx context.Context, req *emptypb.Empty) (*types.AppV3List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApps not implemented")
}
func (*UnimplementedAuthServiceServer) GetApp(ctx context.Context, req *types.ResourceRequest) (*types.AppV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApp not implemented")
}
func (*UnimplementedAuthServiceServer) CreateApp(ctx context.Context, req *types.AppV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApp not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateApp(ctx context.Context, req *types.AppV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApp not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteApp(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApp not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllApps(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllApps not implemented")
}
func (*UnimplementedAuthServiceServer) GetDatabases(ctx context.Context, req *emptypb.Empty) (*types.DatabaseV3List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDatabases not implemented")
}
func (*UnimplementedAuthServiceServer) GetDatabase(ctx context.Context, req *types.ResourceRequest) (*types.DatabaseV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDatabase not implemented")
}
func (*UnimplementedAuthServiceServer) CreateDatabase(ctx context.Context, req *types.DatabaseV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDatabase not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateDatabase(ctx context.Context, req *types.DatabaseV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDatabase not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteDatabase(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDatabase not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllDatabases(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllDatabases not implemented")
}
func (*UnimplementedAuthServiceServer) GetKubernetesClusters(ctx context.Context, req *emptypb.Empty) (*types.KubernetesClusterV3List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKubernetesClusters not implemented")
}
func (*UnimplementedAuthServiceServer) GetKubernetesCluster(ctx context.Context, req *types.ResourceRequest) (*types.KubernetesClusterV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKubernetesCluster not implemented")
}
func (*UnimplementedAuthServiceServer) CreateKubernetesCluster(ctx context.Context, req *types.KubernetesClusterV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKubernetesCluster not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateKubernetesCluster(ctx context.Context, req *types.KubernetesClusterV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKubernetesCluster not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteKubernetesCluster(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKubernetesCluster not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllKubernetesClusters(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllKubernetesClusters not implemented")
}
func (*UnimplementedAuthServiceServer) GetWindowsDesktopServices(ctx context.Context, req *emptypb.Empty) (*GetWindowsDesktopServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWindowsDesktopServices not implemented")
}
func (*UnimplementedAuthServiceServer) GetWindowsDesktopService(ctx context.Context, req *GetWindowsDesktopServiceRequest) (*GetWindowsDesktopServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWindowsDesktopService not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertWindowsDesktopService(ctx context.Context, req *types.WindowsDesktopServiceV3) (*types.KeepAlive, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertWindowsDesktopService not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteWindowsDesktopService(ctx context.Context, req *DeleteWindowsDesktopServiceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWindowsDesktopService not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllWindowsDesktopServices(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllWindowsDesktopServices not implemented")
}
func (*UnimplementedAuthServiceServer) GetWindowsDesktops(ctx context.Context, req *types.WindowsDesktopFilter) (*GetWindowsDesktopsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWindowsDesktops not implemented")
}
func (*UnimplementedAuthServiceServer) CreateWindowsDesktop(ctx context.Context, req *types.WindowsDesktopV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWindowsDesktop not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateWindowsDesktop(ctx context.Context, req *types.WindowsDesktopV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWindowsDesktop not implemented")
}
func (*UnimplementedAuthServiceServer) UpsertWindowsDesktop(ctx context.Context, req *types.WindowsDesktopV3) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertWindowsDesktop not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteWindowsDesktop(ctx context.Context, req *DeleteWindowsDesktopRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWindowsDesktop not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllWindowsDesktops(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllWindowsDesktops not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateWindowsDesktopCert(ctx context.Context, req *WindowsDesktopCertRequest) (*WindowsDesktopCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateWindowsDesktopCert not implemented")
}
func (*UnimplementedAuthServiceServer) GenerateCertAuthorityCRL(ctx context.Context, req *CertAuthorityRequest) (*CRL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCertAuthorityCRL not implemented")
}
func (*UnimplementedAuthServiceServer) GetDesktopBootstrapScript(ctx context.Context, req *emptypb.Empty) (*DesktopBootstrapScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDesktopBootstrapScript not implemented")
}
func (*UnimplementedAuthServiceServer) CreateConnectionDiagnostic(ctx context.Context, req *types.ConnectionDiagnosticV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConnectionDiagnostic not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateConnectionDiagnostic(ctx context.Context, req *types.ConnectionDiagnosticV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConnectionDiagnostic not implemented")
}
func (*UnimplementedAuthServiceServer) GetConnectionDiagnostic(ctx context.Context, req *GetConnectionDiagnosticRequest) (*types.ConnectionDiagnosticV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectionDiagnostic not implemented")
}
func (*UnimplementedAuthServiceServer) AppendDiagnosticTrace(ctx context.Context, req *AppendDiagnosticTraceRequest) (*types.ConnectionDiagnosticV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendDiagnosticTrace not implemented")
}
func (*UnimplementedAuthServiceServer) ChangeUserAuthentication(ctx context.Context, req *ChangeUserAuthenticationRequest) (*ChangeUserAuthenticationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeUserAuthentication not implemented")
}
func (*UnimplementedAuthServiceServer) StartAccountRecovery(ctx context.Context, req *StartAccountRecoveryRequest) (*types.UserTokenV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAccountRecovery not implemented")
}
func (*UnimplementedAuthServiceServer) VerifyAccountRecovery(ctx context.Context, req *VerifyAccountRecoveryRequest) (*types.UserTokenV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyAccountRecovery not implemented")
}
func (*UnimplementedAuthServiceServer) CompleteAccountRecovery(ctx context.Context, req *CompleteAccountRecoveryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteAccountRecovery not implemented")
}
func (*UnimplementedAuthServiceServer) CreateAccountRecoveryCodes(ctx context.Context, req *CreateAccountRecoveryCodesRequest) (*RecoveryCodes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccountRecoveryCodes not implemented")
}
func (*UnimplementedAuthServiceServer) GetAccountRecoveryToken(ctx context.Context, req *GetAccountRecoveryTokenRequest) (*types.UserTokenV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountRecoveryToken not implemented")
}
func (*UnimplementedAuthServiceServer) GetAccountRecoveryCodes(ctx context.Context, req *GetAccountRecoveryCodesRequest) (*RecoveryCodes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountRecoveryCodes not implemented")
}
func (*UnimplementedAuthServiceServer) CreatePrivilegeToken(ctx context.Context, req *CreatePrivilegeTokenRequest) (*types.UserTokenV3, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePrivilegeToken not implemented")
}
func (*UnimplementedAuthServiceServer) GetInstaller(ctx context.Context, req *types.ResourceRequest) (*types.InstallerV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstaller not implemented")
}
func (*UnimplementedAuthServiceServer) GetInstallers(ctx context.Context, req *emptypb.Empty) (*types.InstallerV1List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstallers not implemented")
}
func (*UnimplementedAuthServiceServer) SetInstaller(ctx context.Context, req *types.InstallerV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInstaller not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteInstaller(ctx context.Context, req *types.ResourceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInstaller not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllInstallers(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllInstallers not implemented")
}
func (*UnimplementedAuthServiceServer) ListResources(ctx context.Context, req *ListResourcesRequest) (*ListResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListResources not implemented")
}
func (*UnimplementedAuthServiceServer) ListUnifiedResources(ctx context.Context, req *ListUnifiedResourcesRequest) (*ListUnifiedResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUnifiedResources not implemented")
}
func (*UnimplementedAuthServiceServer) GetSSHTargets(ctx context.Context, req *GetSSHTargetsRequest) (*GetSSHTargetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSSHTargets not implemented")
}
func (*UnimplementedAuthServiceServer) GetDomainName(ctx context.Context, req *emptypb.Empty) (*GetDomainNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDomainName not implemented")
}
func (*UnimplementedAuthServiceServer) GetClusterCACert(ctx context.Context, req *emptypb.Empty) (*GetClusterCACertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterCACert not implemented")
}
func (*UnimplementedAuthServiceServer) AssertSystemRole(ctx context.Context, req *SystemRoleAssertion) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssertSystemRole not implemented")
}
func (*UnimplementedAuthServiceServer) SubmitUsageEvent(ctx context.Context, req *SubmitUsageEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitUsageEvent not implemented")
}
func (*UnimplementedAuthServiceServer) GetLicense(ctx context.Context, req *GetLicenseRequest) (*GetLicenseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLicense not implemented")
}
func (*UnimplementedAuthServiceServer) ListReleases(ctx context.Context, req *ListReleasesRequest) (*ListReleasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReleases not implemented")
}
func (*UnimplementedAuthServiceServer) ListSAMLIdPServiceProviders(ctx context.Context, req *ListSAMLIdPServiceProvidersRequest) (*ListSAMLIdPServiceProvidersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSAMLIdPServiceProviders not implemented")
}
func (*UnimplementedAuthServiceServer) GetSAMLIdPServiceProvider(ctx context.Context, req *GetSAMLIdPServiceProviderRequest) (*types.SAMLIdPServiceProviderV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSAMLIdPServiceProvider not implemented")
}
func (*UnimplementedAuthServiceServer) CreateSAMLIdPServiceProvider(ctx context.Context, req *types.SAMLIdPServiceProviderV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSAMLIdPServiceProvider not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateSAMLIdPServiceProvider(ctx context.Context, req *types.SAMLIdPServiceProviderV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSAMLIdPServiceProvider not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteSAMLIdPServiceProvider(ctx context.Context, req *DeleteSAMLIdPServiceProviderRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSAMLIdPServiceProvider not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllSAMLIdPServiceProviders(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllSAMLIdPServiceProviders not implemented")
}
func (*UnimplementedAuthServiceServer) ListUserGroups(ctx context.Context, req *ListUserGroupsRequest) (*ListUserGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserGroups not implemented")
}
func (*UnimplementedAuthServiceServer) GetUserGroup(ctx context.Context, req *GetUserGroupRequest) (*types.UserGroupV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserGroup not implemented")
}
func (*UnimplementedAuthServiceServer) CreateUserGroup(ctx context.Context, req *types.UserGroupV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserGroup not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateUserGroup(ctx context.Context, req *types.UserGroupV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserGroup not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteUserGroup(ctx context.Context, req *DeleteUserGroupRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserGroup not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteAllUserGroups(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllUserGroups not implemented")
}
func (*UnimplementedAuthServiceServer) GetHeadlessAuthentication(ctx context.Context, req *GetHeadlessAuthenticationRequest) (*types.HeadlessAuthentication, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHeadlessAuthentication not implemented")
}
func (*UnimplementedAuthServiceServer) WatchPendingHeadlessAuthentications(req *emptypb.Empty, srv AuthService_WatchPendingHeadlessAuthenticationsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchPendingHeadlessAuthentications not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateHeadlessAuthenticationState(ctx context.Context, req *UpdateHeadlessAuthenticationStateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHeadlessAuthenticationState not implemented")
}
func (*UnimplementedAuthServiceServer) ExportUpgradeWindows(ctx context.Context, req *ExportUpgradeWindowsRequest) (*ExportUpgradeWindowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportUpgradeWindows not implemented")
}
func (*UnimplementedAuthServiceServer) GetClusterMaintenanceConfig(ctx context.Context, req *emptypb.Empty) (*types.ClusterMaintenanceConfigV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterMaintenanceConfig not implemented")
}
func (*UnimplementedAuthServiceServer) UpdateClusterMaintenanceConfig(ctx context.Context, req *types.ClusterMaintenanceConfigV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateClusterMaintenanceConfig not implemented")
}
func (*UnimplementedAuthServiceServer) DeleteClusterMaintenanceConfig(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteClusterMaintenanceConfig not implemented")
}

func RegisterAuthServiceServer(s *grpc.Server, srv AuthServiceServer) {
	s.RegisterService(&_AuthService_serviceDesc, srv)
}

func _AuthService_InventoryControlStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthServiceServer).InventoryControlStream(&authServiceInventoryControlStreamServer{stream})
}

type AuthService_InventoryControlStreamServer interface {
	Send(*DownstreamInventoryOneOf) error
	Recv() (*UpstreamInventoryOneOf, error)
	grpc.ServerStream
}

type authServiceInventoryControlStreamServer struct {
	grpc.ServerStream
}

func (x *authServiceInventoryControlStreamServer) Send(m *DownstreamInventoryOneOf) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authServiceInventoryControlStreamServer) Recv() (*UpstreamInventoryOneOf, error) {
	m := new(UpstreamInventoryOneOf)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthService_GetInventoryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InventoryStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetInventoryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetInventoryStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetInventoryStatus(ctx, req.(*InventoryStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetInventoryConnectedServiceCounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InventoryConnectedServiceCountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetInventoryConnectedServiceCounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetInventoryConnectedServiceCounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetInventoryConnectedServiceCounts(ctx, req.(*InventoryConnectedServiceCountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_PingInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InventoryPingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).PingInventory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/PingInventory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).PingInventory(ctx, req.(*InventoryPingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetInstances_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.InstanceFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).GetInstances(m, &authServiceGetInstancesServer{stream})
}

type AuthService_GetInstancesServer interface {
	Send(*types.InstanceV1) error
	grpc.ServerStream
}

type authServiceGetInstancesServer struct {
	grpc.ServerStream
}

func (x *authServiceGetInstancesServer) Send(m *types.InstanceV1) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_GetClusterAlerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.GetClusterAlertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetClusterAlerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetClusterAlerts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetClusterAlerts(ctx, req.(*types.GetClusterAlertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertClusterAlert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertClusterAlertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertClusterAlert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertClusterAlert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertClusterAlert(ctx, req.(*UpsertClusterAlertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAlertAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AlertAcknowledgement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateAlertAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateAlertAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateAlertAck(ctx, req.(*types.AlertAcknowledgement))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAlertAcks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAlertAcksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAlertAcks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetAlertAcks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAlertAcks(ctx, req.(*GetAlertAcksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ClearAlertAcks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearAlertAcksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ClearAlertAcks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ClearAlertAcks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ClearAlertAcks(ctx, req.(*ClearAlertAcksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_MaintainSessionPresence_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthServiceServer).MaintainSessionPresence(&authServiceMaintainSessionPresenceServer{stream})
}

type AuthService_MaintainSessionPresenceServer interface {
	Send(*MFAAuthenticateChallenge) error
	Recv() (*PresenceMFAChallengeSend, error)
	grpc.ServerStream
}

type authServiceMaintainSessionPresenceServer struct {
	grpc.ServerStream
}

func (x *authServiceMaintainSessionPresenceServer) Send(m *MFAAuthenticateChallenge) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authServiceMaintainSessionPresenceServer) Recv() (*PresenceMFAChallengeSend, error) {
	m := new(PresenceMFAChallengeSend)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthService_CreateSessionTracker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionTrackerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateSessionTracker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateSessionTracker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateSessionTracker(ctx, req.(*CreateSessionTrackerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSessionTracker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionTrackerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSessionTracker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSessionTracker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSessionTracker(ctx, req.(*GetSessionTrackerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetActiveSessionTrackers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).GetActiveSessionTrackers(m, &authServiceGetActiveSessionTrackersServer{stream})
}

type AuthService_GetActiveSessionTrackersServer interface {
	Send(*types.SessionTrackerV1) error
	grpc.ServerStream
}

type authServiceGetActiveSessionTrackersServer struct {
	grpc.ServerStream
}

func (x *authServiceGetActiveSessionTrackersServer) Send(m *types.SessionTrackerV1) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_GetActiveSessionTrackersWithFilter_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.SessionTrackerFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).GetActiveSessionTrackersWithFilter(m, &authServiceGetActiveSessionTrackersWithFilterServer{stream})
}

type AuthService_GetActiveSessionTrackersWithFilterServer interface {
	Send(*types.SessionTrackerV1) error
	grpc.ServerStream
}

type authServiceGetActiveSessionTrackersWithFilterServer struct {
	grpc.ServerStream
}

func (x *authServiceGetActiveSessionTrackersWithFilterServer) Send(m *types.SessionTrackerV1) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_RemoveSessionTracker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveSessionTrackerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RemoveSessionTracker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/RemoveSessionTracker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RemoveSessionTracker(ctx, req.(*RemoveSessionTrackerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateSessionTracker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSessionTrackerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateSessionTracker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateSessionTracker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateSessionTracker(ctx, req.(*UpdateSessionTrackerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SendKeepAlives_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthServiceServer).SendKeepAlives(&authServiceSendKeepAlivesServer{stream})
}

type AuthService_SendKeepAlivesServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*types.KeepAlive, error)
	grpc.ServerStream
}

type authServiceSendKeepAlivesServer struct {
	grpc.ServerStream
}

func (x *authServiceSendKeepAlivesServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authServiceSendKeepAlivesServer) Recv() (*types.KeepAlive, error) {
	m := new(types.KeepAlive)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthService_WatchEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Watch)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).WatchEvents(m, &authServiceWatchEventsServer{stream})
}

type AuthService_WatchEventsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type authServiceWatchEventsServer struct {
	grpc.ServerStream
}

func (x *authServiceWatchEventsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceInNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetNode(ctx, req.(*types.ResourceInNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ServerV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertNode(ctx, req.(*types.ServerV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceInNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteNode(ctx, req.(*types.ResourceInNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourcesInNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllNodes(ctx, req.(*types.ResourcesInNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateUserCerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateUserCerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateUserCerts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateUserCerts(ctx, req.(*UserCertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateHostCerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostCertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateHostCerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateHostCerts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateHostCerts(ctx, req.(*HostCertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateUserSingleUseCerts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthServiceServer).GenerateUserSingleUseCerts(&authServiceGenerateUserSingleUseCertsServer{stream})
}

type AuthService_GenerateUserSingleUseCertsServer interface {
	Send(*UserSingleUseCertsResponse) error
	Recv() (*UserSingleUseCertsRequest, error)
	grpc.ServerStream
}

type authServiceGenerateUserSingleUseCertsServer struct {
	grpc.ServerStream
}

func (x *authServiceGenerateUserSingleUseCertsServer) Send(m *UserSingleUseCertsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authServiceGenerateUserSingleUseCertsServer) Recv() (*UserSingleUseCertsRequest, error) {
	m := new(UserSingleUseCertsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthService_GenerateOpenSSHCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSSHCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateOpenSSHCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateOpenSSHCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateOpenSSHCert(ctx, req.(*OpenSSHCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_IsMFARequired_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsMFARequiredRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).IsMFARequired(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/IsMFARequired",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).IsMFARequired(ctx, req.(*IsMFARequiredRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAccessRequestsV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.AccessRequestFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).GetAccessRequestsV2(m, &authServiceGetAccessRequestsV2Server{stream})
}

type AuthService_GetAccessRequestsV2Server interface {
	Send(*types.AccessRequestV3) error
	grpc.ServerStream
}

type authServiceGetAccessRequestsV2Server struct {
	grpc.ServerStream
}

func (x *authServiceGetAccessRequestsV2Server) Send(m *types.AccessRequestV3) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_ListAccessRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccessRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListAccessRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListAccessRequests",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListAccessRequests(ctx, req.(*ListAccessRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAccessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AccessRequestV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateAccessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateAccessRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateAccessRequest(ctx, req.(*types.AccessRequestV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAccessRequestV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AccessRequestV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateAccessRequestV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateAccessRequestV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateAccessRequestV2(ctx, req.(*types.AccessRequestV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAccessRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAccessRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAccessRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAccessRequest(ctx, req.(*RequestID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetAccessRequestState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestStateSetter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetAccessRequestState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SetAccessRequestState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetAccessRequestState(ctx, req.(*RequestStateSetter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SubmitAccessReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AccessReviewSubmission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SubmitAccessReview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SubmitAccessReview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SubmitAccessReview(ctx, req.(*types.AccessReviewSubmission))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAccessCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AccessCapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAccessCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetAccessCapabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAccessCapabilities(ctx, req.(*types.AccessCapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAccessRequestAllowedPromotions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequestAllowedPromotionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAccessRequestAllowedPromotions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetAccessRequestAllowedPromotions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAccessRequestAllowedPromotions(ctx, req.(*AccessRequestAllowedPromotionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetPluginData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.PluginDataFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetPluginData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetPluginData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetPluginData(ctx, req.(*types.PluginDataFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdatePluginData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.PluginDataUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdatePluginData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdatePluginData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdatePluginData(ctx, req.(*types.PluginDataUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetResetPasswordToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResetPasswordTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetResetPasswordToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetResetPasswordToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetResetPasswordToken(ctx, req.(*GetResetPasswordTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateResetPasswordToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateResetPasswordTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateResetPasswordToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateResetPasswordToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateResetPasswordToken(ctx, req.(*CreateResetPasswordTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetCurrentUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetCurrentUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetCurrentUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetCurrentUser(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetCurrentUserRoles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).GetCurrentUserRoles(m, &authServiceGetCurrentUserRolesServer{stream})
}

type AuthService_GetCurrentUserRolesServer interface {
	Send(*types.RoleV6) error
	grpc.ServerStream
}

type authServiceGetCurrentUserRolesServer struct {
	grpc.ServerStream
}

func (x *authServiceGetCurrentUserRolesServer) Send(m *types.RoleV6) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_GetUsers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUsersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).GetUsers(m, &authServiceGetUsersServer{stream})
}

type AuthService_GetUsersServer interface {
	Send(*types.UserV2) error
	grpc.ServerStream
}

type authServiceGetUsersServer struct {
	grpc.ServerStream
}

func (x *authServiceGetUsersServer) Send(m *types.UserV2) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.UserV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateUser(ctx, req.(*types.UserV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.UserV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateUser(ctx, req.(*types.UserV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ChangePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ChangePassword(ctx, req.(*ChangePasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_AcquireSemaphore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AcquireSemaphoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AcquireSemaphore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/AcquireSemaphore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AcquireSemaphore(ctx, req.(*types.AcquireSemaphoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_KeepAliveSemaphoreLease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SemaphoreLease)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).KeepAliveSemaphoreLease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/KeepAliveSemaphoreLease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).KeepAliveSemaphoreLease(ctx, req.(*types.SemaphoreLease))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CancelSemaphoreLease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SemaphoreLease)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CancelSemaphoreLease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CancelSemaphoreLease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CancelSemaphoreLease(ctx, req.(*types.SemaphoreLease))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSemaphores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SemaphoreFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSemaphores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSemaphores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSemaphores(ctx, req.(*types.SemaphoreFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteSemaphore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SemaphoreFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteSemaphore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteSemaphore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteSemaphore(ctx, req.(*types.SemaphoreFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_EmitAuditEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(events.OneOf)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).EmitAuditEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/EmitAuditEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).EmitAuditEvent(ctx, req.(*events.OneOf))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAuditStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthServiceServer).CreateAuditStream(&authServiceCreateAuditStreamServer{stream})
}

type AuthService_CreateAuditStreamServer interface {
	Send(*events.StreamStatus) error
	Recv() (*AuditStreamRequest, error)
	grpc.ServerStream
}

type authServiceCreateAuditStreamServer struct {
	grpc.ServerStream
}

func (x *authServiceCreateAuditStreamServer) Send(m *events.StreamStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authServiceCreateAuditStreamServer) Recv() (*AuditStreamRequest, error) {
	m := new(AuditStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthService_UpsertApplicationServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertApplicationServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertApplicationServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertApplicationServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertApplicationServer(ctx, req.(*UpsertApplicationServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteApplicationServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteApplicationServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteApplicationServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteApplicationServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteApplicationServer(ctx, req.(*DeleteApplicationServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllApplicationServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllApplicationServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllApplicationServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllApplicationServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllApplicationServers(ctx, req.(*DeleteAllApplicationServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateAppToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateAppTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateAppToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateAppToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateAppToken(ctx, req.(*GenerateAppTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAppSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAppSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetAppSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAppSession(ctx, req.(*GetAppSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListAppSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAppSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListAppSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListAppSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListAppSessions(ctx, req.(*ListAppSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAppSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAppSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateAppSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateAppSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateAppSession(ctx, req.(*CreateAppSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAppSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAppSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAppSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAppSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAppSession(ctx, req.(*DeleteAppSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllAppSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllAppSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllAppSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllAppSessions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteUserAppSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserAppSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteUserAppSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteUserAppSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteUserAppSessions(ctx, req.(*DeleteUserAppSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateSnowflakeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnowflakeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateSnowflakeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateSnowflakeSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateSnowflakeSession(ctx, req.(*CreateSnowflakeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSnowflakeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSnowflakeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSnowflakeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSnowflakeSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSnowflakeSession(ctx, req.(*GetSnowflakeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSnowflakeSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSnowflakeSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSnowflakeSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSnowflakeSessions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteSnowflakeSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSnowflakeSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteSnowflakeSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteSnowflakeSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteSnowflakeSession(ctx, req.(*DeleteSnowflakeSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllSnowflakeSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllSnowflakeSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllSnowflakeSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllSnowflakeSessions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateSAMLIdPSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSAMLIdPSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateSAMLIdPSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateSAMLIdPSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateSAMLIdPSession(ctx, req.(*CreateSAMLIdPSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSAMLIdPSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSAMLIdPSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSAMLIdPSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSAMLIdPSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSAMLIdPSession(ctx, req.(*GetSAMLIdPSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListSAMLIdPSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSAMLIdPSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListSAMLIdPSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListSAMLIdPSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListSAMLIdPSessions(ctx, req.(*ListSAMLIdPSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteSAMLIdPSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSAMLIdPSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteSAMLIdPSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteSAMLIdPSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteSAMLIdPSession(ctx, req.(*DeleteSAMLIdPSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllSAMLIdPSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllSAMLIdPSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllSAMLIdPSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllSAMLIdPSessions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteUserSAMLIdPSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserSAMLIdPSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteUserSAMLIdPSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteUserSAMLIdPSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteUserSAMLIdPSessions(ctx, req.(*DeleteUserSAMLIdPSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetWebSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.GetWebSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetWebSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetWebSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetWebSession(ctx, req.(*types.GetWebSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetWebSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetWebSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetWebSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetWebSessions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteWebSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.DeleteWebSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteWebSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteWebSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteWebSession(ctx, req.(*types.DeleteWebSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllWebSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllWebSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllWebSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllWebSessions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetWebToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.GetWebTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetWebToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetWebToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetWebToken(ctx, req.(*types.GetWebTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetWebTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetWebTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetWebTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetWebTokens(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteWebToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.DeleteWebTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteWebToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteWebToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteWebToken(ctx, req.(*types.DeleteWebTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllWebTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllWebTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllWebTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllWebTokens(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateRemoteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.RemoteClusterV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateRemoteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateRemoteCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateRemoteCluster(ctx, req.(*types.RemoteClusterV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertKubernetesServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertKubernetesServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertKubernetesServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertKubernetesServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertKubernetesServer(ctx, req.(*UpsertKubernetesServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteKubernetesServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKubernetesServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteKubernetesServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteKubernetesServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteKubernetesServer(ctx, req.(*DeleteKubernetesServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllKubernetesServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllKubernetesServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllKubernetesServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllKubernetesServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllKubernetesServers(ctx, req.(*DeleteAllKubernetesServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertDatabaseServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertDatabaseServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertDatabaseServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertDatabaseServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertDatabaseServer(ctx, req.(*UpsertDatabaseServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteDatabaseServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDatabaseServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteDatabaseServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteDatabaseServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteDatabaseServer(ctx, req.(*DeleteDatabaseServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllDatabaseServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllDatabaseServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllDatabaseServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllDatabaseServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllDatabaseServers(ctx, req.(*DeleteAllDatabaseServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertDatabaseService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertDatabaseServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertDatabaseService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertDatabaseService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertDatabaseService(ctx, req.(*UpsertDatabaseServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteDatabaseService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteDatabaseService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteDatabaseService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteDatabaseService(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllDatabaseServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllDatabaseServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllDatabaseServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllDatabaseServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllDatabaseServices(ctx, req.(*DeleteAllDatabaseServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SignDatabaseCSR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseCSRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SignDatabaseCSR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SignDatabaseCSR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SignDatabaseCSR(ctx, req.(*DatabaseCSRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateDatabaseCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateDatabaseCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateDatabaseCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateDatabaseCert(ctx, req.(*DatabaseCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateSnowflakeJWT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SnowflakeJWTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateSnowflakeJWT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateSnowflakeJWT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateSnowflakeJWT(ctx, req.(*SnowflakeJWTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetRole(ctx, req.(*GetRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetRoles(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRolesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListRoles(ctx, req.(*ListRolesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateRole(ctx, req.(*CreateRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateRole(ctx, req.(*UpdateRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertRoleV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertRoleV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertRoleV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertRoleV2(ctx, req.(*UpsertRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.RoleV6)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertRole(ctx, req.(*types.RoleV6))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteRole(ctx, req.(*DeleteRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_AddMFADevice_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthServiceServer).AddMFADevice(&authServiceAddMFADeviceServer{stream})
}

type AuthService_AddMFADeviceServer interface {
	Send(*AddMFADeviceResponse) error
	Recv() (*AddMFADeviceRequest, error)
	grpc.ServerStream
}

type authServiceAddMFADeviceServer struct {
	grpc.ServerStream
}

func (x *authServiceAddMFADeviceServer) Send(m *AddMFADeviceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authServiceAddMFADeviceServer) Recv() (*AddMFADeviceRequest, error) {
	m := new(AddMFADeviceRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthService_DeleteMFADevice_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AuthServiceServer).DeleteMFADevice(&authServiceDeleteMFADeviceServer{stream})
}

type AuthService_DeleteMFADeviceServer interface {
	Send(*DeleteMFADeviceResponse) error
	Recv() (*DeleteMFADeviceRequest, error)
	grpc.ServerStream
}

type authServiceDeleteMFADeviceServer struct {
	grpc.ServerStream
}

func (x *authServiceDeleteMFADeviceServer) Send(m *DeleteMFADeviceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *authServiceDeleteMFADeviceServer) Recv() (*DeleteMFADeviceRequest, error) {
	m := new(DeleteMFADeviceRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AuthService_AddMFADeviceSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMFADeviceSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AddMFADeviceSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/AddMFADeviceSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AddMFADeviceSync(ctx, req.(*AddMFADeviceSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteMFADeviceSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMFADeviceSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteMFADeviceSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteMFADeviceSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteMFADeviceSync(ctx, req.(*DeleteMFADeviceSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetMFADevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMFADevicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetMFADevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetMFADevices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetMFADevices(ctx, req.(*GetMFADevicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAuthenticateChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAuthenticateChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateAuthenticateChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateAuthenticateChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateAuthenticateChallenge(ctx, req.(*CreateAuthenticateChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateRegisterChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRegisterChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateRegisterChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateRegisterChallenge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateRegisterChallenge(ctx, req.(*CreateRegisterChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetOIDCConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceWithSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetOIDCConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetOIDCConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetOIDCConnector(ctx, req.(*types.ResourceWithSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetOIDCConnectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourcesWithSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetOIDCConnectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetOIDCConnectors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetOIDCConnectors(ctx, req.(*types.ResourcesWithSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateOIDCConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOIDCConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateOIDCConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateOIDCConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateOIDCConnector(ctx, req.(*CreateOIDCConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateOIDCConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOIDCConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateOIDCConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateOIDCConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateOIDCConnector(ctx, req.(*UpdateOIDCConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertOIDCConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.OIDCConnectorV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertOIDCConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertOIDCConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertOIDCConnector(ctx, req.(*types.OIDCConnectorV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertOIDCConnectorV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertOIDCConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertOIDCConnectorV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertOIDCConnectorV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertOIDCConnectorV2(ctx, req.(*UpsertOIDCConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteOIDCConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteOIDCConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteOIDCConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteOIDCConnector(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateOIDCAuthRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.OIDCAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateOIDCAuthRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateOIDCAuthRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateOIDCAuthRequest(ctx, req.(*types.OIDCAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetOIDCAuthRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOIDCAuthRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetOIDCAuthRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetOIDCAuthRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetOIDCAuthRequest(ctx, req.(*GetOIDCAuthRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSAMLConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceWithSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSAMLConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSAMLConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSAMLConnector(ctx, req.(*types.ResourceWithSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSAMLConnectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourcesWithSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSAMLConnectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSAMLConnectors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSAMLConnectors(ctx, req.(*types.ResourcesWithSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateSAMLConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSAMLConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateSAMLConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateSAMLConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateSAMLConnector(ctx, req.(*CreateSAMLConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateSAMLConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSAMLConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateSAMLConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateSAMLConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateSAMLConnector(ctx, req.(*UpdateSAMLConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertSAMLConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SAMLConnectorV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertSAMLConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertSAMLConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertSAMLConnector(ctx, req.(*types.SAMLConnectorV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertSAMLConnectorV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertSAMLConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertSAMLConnectorV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertSAMLConnectorV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertSAMLConnectorV2(ctx, req.(*UpsertSAMLConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteSAMLConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteSAMLConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteSAMLConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteSAMLConnector(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateSAMLAuthRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SAMLAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateSAMLAuthRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateSAMLAuthRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateSAMLAuthRequest(ctx, req.(*types.SAMLAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSAMLAuthRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSAMLAuthRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSAMLAuthRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSAMLAuthRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSAMLAuthRequest(ctx, req.(*GetSAMLAuthRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetGithubConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceWithSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetGithubConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetGithubConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetGithubConnector(ctx, req.(*types.ResourceWithSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetGithubConnectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourcesWithSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetGithubConnectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetGithubConnectors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetGithubConnectors(ctx, req.(*types.ResourcesWithSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateGithubConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGithubConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateGithubConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateGithubConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateGithubConnector(ctx, req.(*CreateGithubConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateGithubConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGithubConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateGithubConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateGithubConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateGithubConnector(ctx, req.(*UpdateGithubConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertGithubConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.GithubConnectorV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertGithubConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertGithubConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertGithubConnector(ctx, req.(*types.GithubConnectorV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertGithubConnectorV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertGithubConnectorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertGithubConnectorV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertGithubConnectorV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertGithubConnectorV2(ctx, req.(*UpsertGithubConnectorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteGithubConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteGithubConnector(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteGithubConnector",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteGithubConnector(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateGithubAuthRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.GithubAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateGithubAuthRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateGithubAuthRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateGithubAuthRequest(ctx, req.(*types.GithubAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetGithubAuthRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGithubAuthRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetGithubAuthRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetGithubAuthRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetGithubAuthRequest(ctx, req.(*GetGithubAuthRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSSODiagnosticInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSSODiagnosticInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSSODiagnosticInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSSODiagnosticInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSSODiagnosticInfo(ctx, req.(*GetSSODiagnosticInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetServerInfos_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).GetServerInfos(m, &authServiceGetServerInfosServer{stream})
}

type AuthService_GetServerInfosServer interface {
	Send(*types.ServerInfoV1) error
	grpc.ServerStream
}

type authServiceGetServerInfosServer struct {
	grpc.ServerStream
}

func (x *authServiceGetServerInfosServer) Send(m *types.ServerInfoV1) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_GetServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetServerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetServerInfo(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ServerInfoV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertServerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertServerInfo(ctx, req.(*types.ServerInfoV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteServerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteServerInfo(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllServerInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllServerInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllServerInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllServerInfos(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetTrustedCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetTrustedCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetTrustedCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetTrustedCluster(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetTrustedClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetTrustedClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetTrustedClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetTrustedClusters(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertTrustedCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.TrustedClusterV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertTrustedCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertTrustedCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertTrustedCluster(ctx, req.(*types.TrustedClusterV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteTrustedCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteTrustedCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteTrustedCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteTrustedCluster(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetToken(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetTokens(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateTokenV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTokenV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateTokenV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateTokenV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateTokenV2(ctx, req.(*CreateTokenV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertTokenV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertTokenV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertTokenV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertTokenV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertTokenV2(ctx, req.(*UpsertTokenV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteToken(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetClusterAuditConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetClusterAuditConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetClusterAuditConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetClusterAuditConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetClusterNetworkingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetClusterNetworkingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetClusterNetworkingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetClusterNetworkingConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetClusterNetworkingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ClusterNetworkingConfigV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetClusterNetworkingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SetClusterNetworkingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetClusterNetworkingConfig(ctx, req.(*types.ClusterNetworkingConfigV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ResetClusterNetworkingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ResetClusterNetworkingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ResetClusterNetworkingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ResetClusterNetworkingConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSessionRecordingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSessionRecordingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSessionRecordingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSessionRecordingConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetSessionRecordingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SessionRecordingConfigV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetSessionRecordingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SetSessionRecordingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetSessionRecordingConfig(ctx, req.(*types.SessionRecordingConfigV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ResetSessionRecordingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ResetSessionRecordingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ResetSessionRecordingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ResetSessionRecordingConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAuthPreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAuthPreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetAuthPreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAuthPreference(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetAuthPreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AuthPreferenceV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetAuthPreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SetAuthPreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetAuthPreference(ctx, req.(*types.AuthPreferenceV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ResetAuthPreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ResetAuthPreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ResetAuthPreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ResetAuthPreference(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetUIConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetUIConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetUIConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetUIConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetUIConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.UIConfigV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetUIConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SetUIConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetUIConfig(ctx, req.(*types.UIConfigV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteUIConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteUIConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteUIConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteUIConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetEvents(ctx, req.(*GetEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSessionEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSessionEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSessionEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSessionEvents(ctx, req.(*GetSessionEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetLock(ctx, req.(*GetLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetLocks(ctx, req.(*GetLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.LockV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertLock(ctx, req.(*types.LockV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteLock(ctx, req.(*DeleteLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ReplaceRemoteLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplaceRemoteLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ReplaceRemoteLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ReplaceRemoteLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ReplaceRemoteLocks(ctx, req.(*ReplaceRemoteLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_StreamSessionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamSessionEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).StreamSessionEvents(m, &authServiceStreamSessionEventsServer{stream})
}

type AuthService_StreamSessionEventsServer interface {
	Send(*events.OneOf) error
	grpc.ServerStream
}

type authServiceStreamSessionEventsServer struct {
	grpc.ServerStream
}

func (x *authServiceStreamSessionEventsServer) Send(m *events.OneOf) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_GetNetworkRestrictions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetNetworkRestrictions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetNetworkRestrictions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetNetworkRestrictions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetNetworkRestrictions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.NetworkRestrictionsV4)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetNetworkRestrictions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SetNetworkRestrictions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetNetworkRestrictions(ctx, req.(*types.NetworkRestrictionsV4))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteNetworkRestrictions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteNetworkRestrictions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteNetworkRestrictions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteNetworkRestrictions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetApps(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetApp(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AppV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateApp(ctx, req.(*types.AppV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.AppV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateApp(ctx, req.(*types.AppV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteApp(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllApps(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetDatabases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetDatabases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetDatabases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetDatabases(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetDatabase(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.DatabaseV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateDatabase(ctx, req.(*types.DatabaseV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.DatabaseV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateDatabase(ctx, req.(*types.DatabaseV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteDatabase(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllDatabases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllDatabases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllDatabases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllDatabases(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetKubernetesClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetKubernetesClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetKubernetesClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetKubernetesClusters(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetKubernetesCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetKubernetesCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetKubernetesCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetKubernetesCluster(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateKubernetesCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.KubernetesClusterV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateKubernetesCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateKubernetesCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateKubernetesCluster(ctx, req.(*types.KubernetesClusterV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateKubernetesCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.KubernetesClusterV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateKubernetesCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateKubernetesCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateKubernetesCluster(ctx, req.(*types.KubernetesClusterV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteKubernetesCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteKubernetesCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteKubernetesCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteKubernetesCluster(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllKubernetesClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllKubernetesClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllKubernetesClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllKubernetesClusters(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetWindowsDesktopServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetWindowsDesktopServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetWindowsDesktopServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetWindowsDesktopServices(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetWindowsDesktopService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWindowsDesktopServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetWindowsDesktopService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetWindowsDesktopService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetWindowsDesktopService(ctx, req.(*GetWindowsDesktopServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertWindowsDesktopService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.WindowsDesktopServiceV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertWindowsDesktopService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertWindowsDesktopService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertWindowsDesktopService(ctx, req.(*types.WindowsDesktopServiceV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteWindowsDesktopService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWindowsDesktopServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteWindowsDesktopService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteWindowsDesktopService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteWindowsDesktopService(ctx, req.(*DeleteWindowsDesktopServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllWindowsDesktopServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllWindowsDesktopServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllWindowsDesktopServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllWindowsDesktopServices(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetWindowsDesktops_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.WindowsDesktopFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetWindowsDesktops(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetWindowsDesktops",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetWindowsDesktops(ctx, req.(*types.WindowsDesktopFilter))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateWindowsDesktop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.WindowsDesktopV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateWindowsDesktop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateWindowsDesktop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateWindowsDesktop(ctx, req.(*types.WindowsDesktopV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateWindowsDesktop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.WindowsDesktopV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateWindowsDesktop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateWindowsDesktop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateWindowsDesktop(ctx, req.(*types.WindowsDesktopV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpsertWindowsDesktop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.WindowsDesktopV3)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpsertWindowsDesktop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpsertWindowsDesktop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpsertWindowsDesktop(ctx, req.(*types.WindowsDesktopV3))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteWindowsDesktop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWindowsDesktopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteWindowsDesktop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteWindowsDesktop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteWindowsDesktop(ctx, req.(*DeleteWindowsDesktopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllWindowsDesktops_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllWindowsDesktops(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllWindowsDesktops",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllWindowsDesktops(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateWindowsDesktopCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WindowsDesktopCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateWindowsDesktopCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateWindowsDesktopCert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateWindowsDesktopCert(ctx, req.(*WindowsDesktopCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GenerateCertAuthorityCRL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GenerateCertAuthorityCRL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GenerateCertAuthorityCRL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GenerateCertAuthorityCRL(ctx, req.(*CertAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetDesktopBootstrapScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetDesktopBootstrapScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetDesktopBootstrapScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetDesktopBootstrapScript(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateConnectionDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ConnectionDiagnosticV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateConnectionDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateConnectionDiagnostic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateConnectionDiagnostic(ctx, req.(*types.ConnectionDiagnosticV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateConnectionDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ConnectionDiagnosticV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateConnectionDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateConnectionDiagnostic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateConnectionDiagnostic(ctx, req.(*types.ConnectionDiagnosticV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetConnectionDiagnostic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectionDiagnosticRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetConnectionDiagnostic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetConnectionDiagnostic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetConnectionDiagnostic(ctx, req.(*GetConnectionDiagnosticRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_AppendDiagnosticTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendDiagnosticTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AppendDiagnosticTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/AppendDiagnosticTrace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AppendDiagnosticTrace(ctx, req.(*AppendDiagnosticTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ChangeUserAuthentication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeUserAuthenticationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ChangeUserAuthentication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ChangeUserAuthentication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ChangeUserAuthentication(ctx, req.(*ChangeUserAuthenticationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_StartAccountRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAccountRecoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).StartAccountRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/StartAccountRecovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).StartAccountRecovery(ctx, req.(*StartAccountRecoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_VerifyAccountRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyAccountRecoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).VerifyAccountRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/VerifyAccountRecovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).VerifyAccountRecovery(ctx, req.(*VerifyAccountRecoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CompleteAccountRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteAccountRecoveryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CompleteAccountRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CompleteAccountRecovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CompleteAccountRecovery(ctx, req.(*CompleteAccountRecoveryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateAccountRecoveryCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountRecoveryCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateAccountRecoveryCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateAccountRecoveryCodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateAccountRecoveryCodes(ctx, req.(*CreateAccountRecoveryCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAccountRecoveryToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountRecoveryTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAccountRecoveryToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetAccountRecoveryToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAccountRecoveryToken(ctx, req.(*GetAccountRecoveryTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetAccountRecoveryCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountRecoveryCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetAccountRecoveryCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetAccountRecoveryCodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetAccountRecoveryCodes(ctx, req.(*GetAccountRecoveryCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreatePrivilegeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePrivilegeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreatePrivilegeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreatePrivilegeToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreatePrivilegeToken(ctx, req.(*CreatePrivilegeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetInstaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetInstaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetInstaller",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetInstaller(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetInstallers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetInstallers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetInstallers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetInstallers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SetInstaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.InstallerV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SetInstaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SetInstaller",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SetInstaller(ctx, req.(*types.InstallerV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteInstaller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteInstaller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteInstaller",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteInstaller(ctx, req.(*types.ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllInstallers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllInstallers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllInstallers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllInstallers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListResources(ctx, req.(*ListResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListUnifiedResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUnifiedResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListUnifiedResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListUnifiedResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListUnifiedResources(ctx, req.(*ListUnifiedResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSSHTargets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSSHTargetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSSHTargets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSSHTargets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSSHTargets(ctx, req.(*GetSSHTargetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetDomainName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetDomainName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetDomainName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetDomainName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetClusterCACert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetClusterCACert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetClusterCACert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetClusterCACert(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_AssertSystemRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemRoleAssertion)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AssertSystemRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/AssertSystemRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AssertSystemRole(ctx, req.(*SystemRoleAssertion))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_SubmitUsageEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitUsageEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).SubmitUsageEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/SubmitUsageEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).SubmitUsageEvent(ctx, req.(*SubmitUsageEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetLicense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetLicense(ctx, req.(*GetLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListReleases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReleasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListReleases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListReleases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListReleases(ctx, req.(*ListReleasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListSAMLIdPServiceProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSAMLIdPServiceProvidersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListSAMLIdPServiceProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListSAMLIdPServiceProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListSAMLIdPServiceProviders(ctx, req.(*ListSAMLIdPServiceProvidersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetSAMLIdPServiceProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSAMLIdPServiceProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetSAMLIdPServiceProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetSAMLIdPServiceProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetSAMLIdPServiceProvider(ctx, req.(*GetSAMLIdPServiceProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateSAMLIdPServiceProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SAMLIdPServiceProviderV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateSAMLIdPServiceProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateSAMLIdPServiceProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateSAMLIdPServiceProvider(ctx, req.(*types.SAMLIdPServiceProviderV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateSAMLIdPServiceProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SAMLIdPServiceProviderV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateSAMLIdPServiceProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateSAMLIdPServiceProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateSAMLIdPServiceProvider(ctx, req.(*types.SAMLIdPServiceProviderV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteSAMLIdPServiceProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSAMLIdPServiceProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteSAMLIdPServiceProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteSAMLIdPServiceProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteSAMLIdPServiceProvider(ctx, req.(*DeleteSAMLIdPServiceProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllSAMLIdPServiceProviders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllSAMLIdPServiceProviders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllSAMLIdPServiceProviders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllSAMLIdPServiceProviders(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ListUserGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ListUserGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ListUserGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ListUserGroups(ctx, req.(*ListUserGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetUserGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetUserGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetUserGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetUserGroup(ctx, req.(*GetUserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_CreateUserGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.UserGroupV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).CreateUserGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/CreateUserGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).CreateUserGroup(ctx, req.(*types.UserGroupV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateUserGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.UserGroupV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateUserGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateUserGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateUserGroup(ctx, req.(*types.UserGroupV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteUserGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteUserGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteUserGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteUserGroup(ctx, req.(*DeleteUserGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteAllUserGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteAllUserGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteAllUserGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteAllUserGroups(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetHeadlessAuthentication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHeadlessAuthenticationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetHeadlessAuthentication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetHeadlessAuthentication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetHeadlessAuthentication(ctx, req.(*GetHeadlessAuthenticationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_WatchPendingHeadlessAuthentications_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AuthServiceServer).WatchPendingHeadlessAuthentications(m, &authServiceWatchPendingHeadlessAuthenticationsServer{stream})
}

type AuthService_WatchPendingHeadlessAuthenticationsServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type authServiceWatchPendingHeadlessAuthenticationsServer struct {
	grpc.ServerStream
}

func (x *authServiceWatchPendingHeadlessAuthenticationsServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

func _AuthService_UpdateHeadlessAuthenticationState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHeadlessAuthenticationStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateHeadlessAuthenticationState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateHeadlessAuthenticationState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateHeadlessAuthenticationState(ctx, req.(*UpdateHeadlessAuthenticationStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ExportUpgradeWindows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportUpgradeWindowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ExportUpgradeWindows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/ExportUpgradeWindows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ExportUpgradeWindows(ctx, req.(*ExportUpgradeWindowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetClusterMaintenanceConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetClusterMaintenanceConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/GetClusterMaintenanceConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetClusterMaintenanceConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_UpdateClusterMaintenanceConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.ClusterMaintenanceConfigV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).UpdateClusterMaintenanceConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/UpdateClusterMaintenanceConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).UpdateClusterMaintenanceConfig(ctx, req.(*types.ClusterMaintenanceConfigV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_DeleteClusterMaintenanceConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).DeleteClusterMaintenanceConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.AuthService/DeleteClusterMaintenanceConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).DeleteClusterMaintenanceConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInventoryStatus",
			Handler:    _AuthService_GetInventoryStatus_Handler,
		},
		{
			MethodName: "GetInventoryConnectedServiceCounts",
			Handler:    _AuthService_GetInventoryConnectedServiceCounts_Handler,
		},
		{
			MethodName: "PingInventory",
			Handler:    _AuthService_PingInventory_Handler,
		},
		{
			MethodName: "GetClusterAlerts",
			Handler:    _AuthService_GetClusterAlerts_Handler,
		},
		{
			MethodName: "UpsertClusterAlert",
			Handler:    _AuthService_UpsertClusterAlert_Handler,
		},
		{
			MethodName: "CreateAlertAck",
			Handler:    _AuthService_CreateAlertAck_Handler,
		},
		{
			MethodName: "GetAlertAcks",
			Handler:    _AuthService_GetAlertAcks_Handler,
		},
		{
			MethodName: "ClearAlertAcks",
			Handler:    _AuthService_ClearAlertAcks_Handler,
		},
		{
			MethodName: "CreateSessionTracker",
			Handler:    _AuthService_CreateSessionTracker_Handler,
		},
		{
			MethodName: "GetSessionTracker",
			Handler:    _AuthService_GetSessionTracker_Handler,
		},
		{
			MethodName: "RemoveSessionTracker",
			Handler:    _AuthService_RemoveSessionTracker_Handler,
		},
		{
			MethodName: "UpdateSessionTracker",
			Handler:    _AuthService_UpdateSessionTracker_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _AuthService_GetNode_Handler,
		},
		{
			MethodName: "UpsertNode",
			Handler:    _AuthService_UpsertNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _AuthService_DeleteNode_Handler,
		},
		{
			MethodName: "DeleteAllNodes",
			Handler:    _AuthService_DeleteAllNodes_Handler,
		},
		{
			MethodName: "GenerateUserCerts",
			Handler:    _AuthService_GenerateUserCerts_Handler,
		},
		{
			MethodName: "GenerateHostCerts",
			Handler:    _AuthService_GenerateHostCerts_Handler,
		},
		{
			MethodName: "GenerateOpenSSHCert",
			Handler:    _AuthService_GenerateOpenSSHCert_Handler,
		},
		{
			MethodName: "IsMFARequired",
			Handler:    _AuthService_IsMFARequired_Handler,
		},
		{
			MethodName: "ListAccessRequests",
			Handler:    _AuthService_ListAccessRequests_Handler,
		},
		{
			MethodName: "CreateAccessRequest",
			Handler:    _AuthService_CreateAccessRequest_Handler,
		},
		{
			MethodName: "CreateAccessRequestV2",
			Handler:    _AuthService_CreateAccessRequestV2_Handler,
		},
		{
			MethodName: "DeleteAccessRequest",
			Handler:    _AuthService_DeleteAccessRequest_Handler,
		},
		{
			MethodName: "SetAccessRequestState",
			Handler:    _AuthService_SetAccessRequestState_Handler,
		},
		{
			MethodName: "SubmitAccessReview",
			Handler:    _AuthService_SubmitAccessReview_Handler,
		},
		{
			MethodName: "GetAccessCapabilities",
			Handler:    _AuthService_GetAccessCapabilities_Handler,
		},
		{
			MethodName: "GetAccessRequestAllowedPromotions",
			Handler:    _AuthService_GetAccessRequestAllowedPromotions_Handler,
		},
		{
			MethodName: "GetPluginData",
			Handler:    _AuthService_GetPluginData_Handler,
		},
		{
			MethodName: "UpdatePluginData",
			Handler:    _AuthService_UpdatePluginData_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _AuthService_Ping_Handler,
		},
		{
			MethodName: "GetResetPasswordToken",
			Handler:    _AuthService_GetResetPasswordToken_Handler,
		},
		{
			MethodName: "CreateResetPasswordToken",
			Handler:    _AuthService_CreateResetPasswordToken_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _AuthService_GetUser_Handler,
		},
		{
			MethodName: "GetCurrentUser",
			Handler:    _AuthService_GetCurrentUser_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _AuthService_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _AuthService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _AuthService_DeleteUser_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _AuthService_ChangePassword_Handler,
		},
		{
			MethodName: "AcquireSemaphore",
			Handler:    _AuthService_AcquireSemaphore_Handler,
		},
		{
			MethodName: "KeepAliveSemaphoreLease",
			Handler:    _AuthService_KeepAliveSemaphoreLease_Handler,
		},
		{
			MethodName: "CancelSemaphoreLease",
			Handler:    _AuthService_CancelSemaphoreLease_Handler,
		},
		{
			MethodName: "GetSemaphores",
			Handler:    _AuthService_GetSemaphores_Handler,
		},
		{
			MethodName: "DeleteSemaphore",
			Handler:    _AuthService_DeleteSemaphore_Handler,
		},
		{
			MethodName: "EmitAuditEvent",
			Handler:    _AuthService_EmitAuditEvent_Handler,
		},
		{
			MethodName: "UpsertApplicationServer",
			Handler:    _AuthService_UpsertApplicationServer_Handler,
		},
		{
			MethodName: "DeleteApplicationServer",
			Handler:    _AuthService_DeleteApplicationServer_Handler,
		},
		{
			MethodName: "DeleteAllApplicationServers",
			Handler:    _AuthService_DeleteAllApplicationServers_Handler,
		},
		{
			MethodName: "GenerateAppToken",
			Handler:    _AuthService_GenerateAppToken_Handler,
		},
		{
			MethodName: "GetAppSession",
			Handler:    _AuthService_GetAppSession_Handler,
		},
		{
			MethodName: "ListAppSessions",
			Handler:    _AuthService_ListAppSessions_Handler,
		},
		{
			MethodName: "CreateAppSession",
			Handler:    _AuthService_CreateAppSession_Handler,
		},
		{
			MethodName: "DeleteAppSession",
			Handler:    _AuthService_DeleteAppSession_Handler,
		},
		{
			MethodName: "DeleteAllAppSessions",
			Handler:    _AuthService_DeleteAllAppSessions_Handler,
		},
		{
			MethodName: "DeleteUserAppSessions",
			Handler:    _AuthService_DeleteUserAppSessions_Handler,
		},
		{
			MethodName: "CreateSnowflakeSession",
			Handler:    _AuthService_CreateSnowflakeSession_Handler,
		},
		{
			MethodName: "GetSnowflakeSession",
			Handler:    _AuthService_GetSnowflakeSession_Handler,
		},
		{
			MethodName: "GetSnowflakeSessions",
			Handler:    _AuthService_GetSnowflakeSessions_Handler,
		},
		{
			MethodName: "DeleteSnowflakeSession",
			Handler:    _AuthService_DeleteSnowflakeSession_Handler,
		},
		{
			MethodName: "DeleteAllSnowflakeSessions",
			Handler:    _AuthService_DeleteAllSnowflakeSessions_Handler,
		},
		{
			MethodName: "CreateSAMLIdPSession",
			Handler:    _AuthService_CreateSAMLIdPSession_Handler,
		},
		{
			MethodName: "GetSAMLIdPSession",
			Handler:    _AuthService_GetSAMLIdPSession_Handler,
		},
		{
			MethodName: "ListSAMLIdPSessions",
			Handler:    _AuthService_ListSAMLIdPSessions_Handler,
		},
		{
			MethodName: "DeleteSAMLIdPSession",
			Handler:    _AuthService_DeleteSAMLIdPSession_Handler,
		},
		{
			MethodName: "DeleteAllSAMLIdPSessions",
			Handler:    _AuthService_DeleteAllSAMLIdPSessions_Handler,
		},
		{
			MethodName: "DeleteUserSAMLIdPSessions",
			Handler:    _AuthService_DeleteUserSAMLIdPSessions_Handler,
		},
		{
			MethodName: "GetWebSession",
			Handler:    _AuthService_GetWebSession_Handler,
		},
		{
			MethodName: "GetWebSessions",
			Handler:    _AuthService_GetWebSessions_Handler,
		},
		{
			MethodName: "DeleteWebSession",
			Handler:    _AuthService_DeleteWebSession_Handler,
		},
		{
			MethodName: "DeleteAllWebSessions",
			Handler:    _AuthService_DeleteAllWebSessions_Handler,
		},
		{
			MethodName: "GetWebToken",
			Handler:    _AuthService_GetWebToken_Handler,
		},
		{
			MethodName: "GetWebTokens",
			Handler:    _AuthService_GetWebTokens_Handler,
		},
		{
			MethodName: "DeleteWebToken",
			Handler:    _AuthService_DeleteWebToken_Handler,
		},
		{
			MethodName: "DeleteAllWebTokens",
			Handler:    _AuthService_DeleteAllWebTokens_Handler,
		},
		{
			MethodName: "UpdateRemoteCluster",
			Handler:    _AuthService_UpdateRemoteCluster_Handler,
		},
		{
			MethodName: "UpsertKubernetesServer",
			Handler:    _AuthService_UpsertKubernetesServer_Handler,
		},
		{
			MethodName: "DeleteKubernetesServer",
			Handler:    _AuthService_DeleteKubernetesServer_Handler,
		},
		{
			MethodName: "DeleteAllKubernetesServers",
			Handler:    _AuthService_DeleteAllKubernetesServers_Handler,
		},
		{
			MethodName: "UpsertDatabaseServer",
			Handler:    _AuthService_UpsertDatabaseServer_Handler,
		},
		{
			MethodName: "DeleteDatabaseServer",
			Handler:    _AuthService_DeleteDatabaseServer_Handler,
		},
		{
			MethodName: "DeleteAllDatabaseServers",
			Handler:    _AuthService_DeleteAllDatabaseServers_Handler,
		},
		{
			MethodName: "UpsertDatabaseService",
			Handler:    _AuthService_UpsertDatabaseService_Handler,
		},
		{
			MethodName: "DeleteDatabaseService",
			Handler:    _AuthService_DeleteDatabaseService_Handler,
		},
		{
			MethodName: "DeleteAllDatabaseServices",
			Handler:    _AuthService_DeleteAllDatabaseServices_Handler,
		},
		{
			MethodName: "SignDatabaseCSR",
			Handler:    _AuthService_SignDatabaseCSR_Handler,
		},
		{
			MethodName: "GenerateDatabaseCert",
			Handler:    _AuthService_GenerateDatabaseCert_Handler,
		},
		{
			MethodName: "GenerateSnowflakeJWT",
			Handler:    _AuthService_GenerateSnowflakeJWT_Handler,
		},
		{
			MethodName: "GetRole",
			Handler:    _AuthService_GetRole_Handler,
		},
		{
			MethodName: "GetRoles",
			Handler:    _AuthService_GetRoles_Handler,
		},
		{
			MethodName: "ListRoles",
			Handler:    _AuthService_ListRoles_Handler,
		},
		{
			MethodName: "CreateRole",
			Handler:    _AuthService_CreateRole_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _AuthService_UpdateRole_Handler,
		},
		{
			MethodName: "UpsertRoleV2",
			Handler:    _AuthService_UpsertRoleV2_Handler,
		},
		{
			MethodName: "UpsertRole",
			Handler:    _AuthService_UpsertRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _AuthService_DeleteRole_Handler,
		},
		{
			MethodName: "AddMFADeviceSync",
			Handler:    _AuthService_AddMFADeviceSync_Handler,
		},
		{
			MethodName: "DeleteMFADeviceSync",
			Handler:    _AuthService_DeleteMFADeviceSync_Handler,
		},
		{
			MethodName: "GetMFADevices",
			Handler:    _AuthService_GetMFADevices_Handler,
		},
		{
			MethodName: "CreateAuthenticateChallenge",
			Handler:    _AuthService_CreateAuthenticateChallenge_Handler,
		},
		{
			MethodName: "CreateRegisterChallenge",
			Handler:    _AuthService_CreateRegisterChallenge_Handler,
		},
		{
			MethodName: "GetOIDCConnector",
			Handler:    _AuthService_GetOIDCConnector_Handler,
		},
		{
			MethodName: "GetOIDCConnectors",
			Handler:    _AuthService_GetOIDCConnectors_Handler,
		},
		{
			MethodName: "CreateOIDCConnector",
			Handler:    _AuthService_CreateOIDCConnector_Handler,
		},
		{
			MethodName: "UpdateOIDCConnector",
			Handler:    _AuthService_UpdateOIDCConnector_Handler,
		},
		{
			MethodName: "UpsertOIDCConnector",
			Handler:    _AuthService_UpsertOIDCConnector_Handler,
		},
		{
			MethodName: "UpsertOIDCConnectorV2",
			Handler:    _AuthService_UpsertOIDCConnectorV2_Handler,
		},
		{
			MethodName: "DeleteOIDCConnector",
			Handler:    _AuthService_DeleteOIDCConnector_Handler,
		},
		{
			MethodName: "CreateOIDCAuthRequest",
			Handler:    _AuthService_CreateOIDCAuthRequest_Handler,
		},
		{
			MethodName: "GetOIDCAuthRequest",
			Handler:    _AuthService_GetOIDCAuthRequest_Handler,
		},
		{
			MethodName: "GetSAMLConnector",
			Handler:    _AuthService_GetSAMLConnector_Handler,
		},
		{
			MethodName: "GetSAMLConnectors",
			Handler:    _AuthService_GetSAMLConnectors_Handler,
		},
		{
			MethodName: "CreateSAMLConnector",
			Handler:    _AuthService_CreateSAMLConnector_Handler,
		},
		{
			MethodName: "UpdateSAMLConnector",
			Handler:    _AuthService_UpdateSAMLConnector_Handler,
		},
		{
			MethodName: "UpsertSAMLConnector",
			Handler:    _AuthService_UpsertSAMLConnector_Handler,
		},
		{
			MethodName: "UpsertSAMLConnectorV2",
			Handler:    _AuthService_UpsertSAMLConnectorV2_Handler,
		},
		{
			MethodName: "DeleteSAMLConnector",
			Handler:    _AuthService_DeleteSAMLConnector_Handler,
		},
		{
			MethodName: "CreateSAMLAuthRequest",
			Handler:    _AuthService_CreateSAMLAuthRequest_Handler,
		},
		{
			MethodName: "GetSAMLAuthRequest",
			Handler:    _AuthService_GetSAMLAuthRequest_Handler,
		},
		{
			MethodName: "GetGithubConnector",
			Handler:    _AuthService_GetGithubConnector_Handler,
		},
		{
			MethodName: "GetGithubConnectors",
			Handler:    _AuthService_GetGithubConnectors_Handler,
		},
		{
			MethodName: "CreateGithubConnector",
			Handler:    _AuthService_CreateGithubConnector_Handler,
		},
		{
			MethodName: "UpdateGithubConnector",
			Handler:    _AuthService_UpdateGithubConnector_Handler,
		},
		{
			MethodName: "UpsertGithubConnector",
			Handler:    _AuthService_UpsertGithubConnector_Handler,
		},
		{
			MethodName: "UpsertGithubConnectorV2",
			Handler:    _AuthService_UpsertGithubConnectorV2_Handler,
		},
		{
			MethodName: "DeleteGithubConnector",
			Handler:    _AuthService_DeleteGithubConnector_Handler,
		},
		{
			MethodName: "CreateGithubAuthRequest",
			Handler:    _AuthService_CreateGithubAuthRequest_Handler,
		},
		{
			MethodName: "GetGithubAuthRequest",
			Handler:    _AuthService_GetGithubAuthRequest_Handler,
		},
		{
			MethodName: "GetSSODiagnosticInfo",
			Handler:    _AuthService_GetSSODiagnosticInfo_Handler,
		},
		{
			MethodName: "GetServerInfo",
			Handler:    _AuthService_GetServerInfo_Handler,
		},
		{
			MethodName: "UpsertServerInfo",
			Handler:    _AuthService_UpsertServerInfo_Handler,
		},
		{
			MethodName: "DeleteServerInfo",
			Handler:    _AuthService_DeleteServerInfo_Handler,
		},
		{
			MethodName: "DeleteAllServerInfos",
			Handler:    _AuthService_DeleteAllServerInfos_Handler,
		},
		{
			MethodName: "GetTrustedCluster",
			Handler:    _AuthService_GetTrustedCluster_Handler,
		},
		{
			MethodName: "GetTrustedClusters",
			Handler:    _AuthService_GetTrustedClusters_Handler,
		},
		{
			MethodName: "UpsertTrustedCluster",
			Handler:    _AuthService_UpsertTrustedCluster_Handler,
		},
		{
			MethodName: "DeleteTrustedCluster",
			Handler:    _AuthService_DeleteTrustedCluster_Handler,
		},
		{
			MethodName: "GetToken",
			Handler:    _AuthService_GetToken_Handler,
		},
		{
			MethodName: "GetTokens",
			Handler:    _AuthService_GetTokens_Handler,
		},
		{
			MethodName: "CreateTokenV2",
			Handler:    _AuthService_CreateTokenV2_Handler,
		},
		{
			MethodName: "UpsertTokenV2",
			Handler:    _AuthService_UpsertTokenV2_Handler,
		},
		{
			MethodName: "DeleteToken",
			Handler:    _AuthService_DeleteToken_Handler,
		},
		{
			MethodName: "GetClusterAuditConfig",
			Handler:    _AuthService_GetClusterAuditConfig_Handler,
		},
		{
			MethodName: "GetClusterNetworkingConfig",
			Handler:    _AuthService_GetClusterNetworkingConfig_Handler,
		},
		{
			MethodName: "SetClusterNetworkingConfig",
			Handler:    _AuthService_SetClusterNetworkingConfig_Handler,
		},
		{
			MethodName: "ResetClusterNetworkingConfig",
			Handler:    _AuthService_ResetClusterNetworkingConfig_Handler,
		},
		{
			MethodName: "GetSessionRecordingConfig",
			Handler:    _AuthService_GetSessionRecordingConfig_Handler,
		},
		{
			MethodName: "SetSessionRecordingConfig",
			Handler:    _AuthService_SetSessionRecordingConfig_Handler,
		},
		{
			MethodName: "ResetSessionRecordingConfig",
			Handler:    _AuthService_ResetSessionRecordingConfig_Handler,
		},
		{
			MethodName: "GetAuthPreference",
			Handler:    _AuthService_GetAuthPreference_Handler,
		},
		{
			MethodName: "SetAuthPreference",
			Handler:    _AuthService_SetAuthPreference_Handler,
		},
		{
			MethodName: "ResetAuthPreference",
			Handler:    _AuthService_ResetAuthPreference_Handler,
		},
		{
			MethodName: "GetUIConfig",
			Handler:    _AuthService_GetUIConfig_Handler,
		},
		{
			MethodName: "SetUIConfig",
			Handler:    _AuthService_SetUIConfig_Handler,
		},
		{
			MethodName: "DeleteUIConfig",
			Handler:    _AuthService_DeleteUIConfig_Handler,
		},
		{
			MethodName: "GetEvents",
			Handler:    _AuthService_GetEvents_Handler,
		},
		{
			MethodName: "GetSessionEvents",
			Handler:    _AuthService_GetSessionEvents_Handler,
		},
		{
			MethodName: "GetLock",
			Handler:    _AuthService_GetLock_Handler,
		},
		{
			MethodName: "GetLocks",
			Handler:    _AuthService_GetLocks_Handler,
		},
		{
			MethodName: "UpsertLock",
			Handler:    _AuthService_UpsertLock_Handler,
		},
		{
			MethodName: "DeleteLock",
			Handler:    _AuthService_DeleteLock_Handler,
		},
		{
			MethodName: "ReplaceRemoteLocks",
			Handler:    _AuthService_ReplaceRemoteLocks_Handler,
		},
		{
			MethodName: "GetNetworkRestrictions",
			Handler:    _AuthService_GetNetworkRestrictions_Handler,
		},
		{
			MethodName: "SetNetworkRestrictions",
			Handler:    _AuthService_SetNetworkRestrictions_Handler,
		},
		{
			MethodName: "DeleteNetworkRestrictions",
			Handler:    _AuthService_DeleteNetworkRestrictions_Handler,
		},
		{
			MethodName: "GetApps",
			Handler:    _AuthService_GetApps_Handler,
		},
		{
			MethodName: "GetApp",
			Handler:    _AuthService_GetApp_Handler,
		},
		{
			MethodName: "CreateApp",
			Handler:    _AuthService_CreateApp_Handler,
		},
		{
			MethodName: "UpdateApp",
			Handler:    _AuthService_UpdateApp_Handler,
		},
		{
			MethodName: "DeleteApp",
			Handler:    _AuthService_DeleteApp_Handler,
		},
		{
			MethodName: "DeleteAllApps",
			Handler:    _AuthService_DeleteAllApps_Handler,
		},
		{
			MethodName: "GetDatabases",
			Handler:    _AuthService_GetDatabases_Handler,
		},
		{
			MethodName: "GetDatabase",
			Handler:    _AuthService_GetDatabase_Handler,
		},
		{
			MethodName: "CreateDatabase",
			Handler:    _AuthService_CreateDatabase_Handler,
		},
		{
			MethodName: "UpdateDatabase",
			Handler:    _AuthService_UpdateDatabase_Handler,
		},
		{
			MethodName: "DeleteDatabase",
			Handler:    _AuthService_DeleteDatabase_Handler,
		},
		{
			MethodName: "DeleteAllDatabases",
			Handler:    _AuthService_DeleteAllDatabases_Handler,
		},
		{
			MethodName: "GetKubernetesClusters",
			Handler:    _AuthService_GetKubernetesClusters_Handler,
		},
		{
			MethodName: "GetKubernetesCluster",
			Handler:    _AuthService_GetKubernetesCluster_Handler,
		},
		{
			MethodName: "CreateKubernetesCluster",
			Handler:    _AuthService_CreateKubernetesCluster_Handler,
		},
		{
			MethodName: "UpdateKubernetesCluster",
			Handler:    _AuthService_UpdateKubernetesCluster_Handler,
		},
		{
			MethodName: "DeleteKubernetesCluster",
			Handler:    _AuthService_DeleteKubernetesCluster_Handler,
		},
		{
			MethodName: "DeleteAllKubernetesClusters",
			Handler:    _AuthService_DeleteAllKubernetesClusters_Handler,
		},
		{
			MethodName: "GetWindowsDesktopServices",
			Handler:    _AuthService_GetWindowsDesktopServices_Handler,
		},
		{
			MethodName: "GetWindowsDesktopService",
			Handler:    _AuthService_GetWindowsDesktopService_Handler,
		},
		{
			MethodName: "UpsertWindowsDesktopService",
			Handler:    _AuthService_UpsertWindowsDesktopService_Handler,
		},
		{
			MethodName: "DeleteWindowsDesktopService",
			Handler:    _AuthService_DeleteWindowsDesktopService_Handler,
		},
		{
			MethodName: "DeleteAllWindowsDesktopServices",
			Handler:    _AuthService_DeleteAllWindowsDesktopServices_Handler,
		},
		{
			MethodName: "GetWindowsDesktops",
			Handler:    _AuthService_GetWindowsDesktops_Handler,
		},
		{
			MethodName: "CreateWindowsDesktop",
			Handler:    _AuthService_CreateWindowsDesktop_Handler,
		},
		{
			MethodName: "UpdateWindowsDesktop",
			Handler:    _AuthService_UpdateWindowsDesktop_Handler,
		},
		{
			MethodName: "UpsertWindowsDesktop",
			Handler:    _AuthService_UpsertWindowsDesktop_Handler,
		},
		{
			MethodName: "DeleteWindowsDesktop",
			Handler:    _AuthService_DeleteWindowsDesktop_Handler,
		},
		{
			MethodName: "DeleteAllWindowsDesktops",
			Handler:    _AuthService_DeleteAllWindowsDesktops_Handler,
		},
		{
			MethodName: "GenerateWindowsDesktopCert",
			Handler:    _AuthService_GenerateWindowsDesktopCert_Handler,
		},
		{
			MethodName: "GenerateCertAuthorityCRL",
			Handler:    _AuthService_GenerateCertAuthorityCRL_Handler,
		},
		{
			MethodName: "GetDesktopBootstrapScript",
			Handler:    _AuthService_GetDesktopBootstrapScript_Handler,
		},
		{
			MethodName: "CreateConnectionDiagnostic",
			Handler:    _AuthService_CreateConnectionDiagnostic_Handler,
		},
		{
			MethodName: "UpdateConnectionDiagnostic",
			Handler:    _AuthService_UpdateConnectionDiagnostic_Handler,
		},
		{
			MethodName: "GetConnectionDiagnostic",
			Handler:    _AuthService_GetConnectionDiagnostic_Handler,
		},
		{
			MethodName: "AppendDiagnosticTrace",
			Handler:    _AuthService_AppendDiagnosticTrace_Handler,
		},
		{
			MethodName: "ChangeUserAuthentication",
			Handler:    _AuthService_ChangeUserAuthentication_Handler,
		},
		{
			MethodName: "StartAccountRecovery",
			Handler:    _AuthService_StartAccountRecovery_Handler,
		},
		{
			MethodName: "VerifyAccountRecovery",
			Handler:    _AuthService_VerifyAccountRecovery_Handler,
		},
		{
			MethodName: "CompleteAccountRecovery",
			Handler:    _AuthService_CompleteAccountRecovery_Handler,
		},
		{
			MethodName: "CreateAccountRecoveryCodes",
			Handler:    _AuthService_CreateAccountRecoveryCodes_Handler,
		},
		{
			MethodName: "GetAccountRecoveryToken",
			Handler:    _AuthService_GetAccountRecoveryToken_Handler,
		},
		{
			MethodName: "GetAccountRecoveryCodes",
			Handler:    _AuthService_GetAccountRecoveryCodes_Handler,
		},
		{
			MethodName: "CreatePrivilegeToken",
			Handler:    _AuthService_CreatePrivilegeToken_Handler,
		},
		{
			MethodName: "GetInstaller",
			Handler:    _AuthService_GetInstaller_Handler,
		},
		{
			MethodName: "GetInstallers",
			Handler:    _AuthService_GetInstallers_Handler,
		},
		{
			MethodName: "SetInstaller",
			Handler:    _AuthService_SetInstaller_Handler,
		},
		{
			MethodName: "DeleteInstaller",
			Handler:    _AuthService_DeleteInstaller_Handler,
		},
		{
			MethodName: "DeleteAllInstallers",
			Handler:    _AuthService_DeleteAllInstallers_Handler,
		},
		{
			MethodName: "ListResources",
			Handler:    _AuthService_ListResources_Handler,
		},
		{
			MethodName: "ListUnifiedResources",
			Handler:    _AuthService_ListUnifiedResources_Handler,
		},
		{
			MethodName: "GetSSHTargets",
			Handler:    _AuthService_GetSSHTargets_Handler,
		},
		{
			MethodName: "GetDomainName",
			Handler:    _AuthService_GetDomainName_Handler,
		},
		{
			MethodName: "GetClusterCACert",
			Handler:    _AuthService_GetClusterCACert_Handler,
		},
		{
			MethodName: "AssertSystemRole",
			Handler:    _AuthService_AssertSystemRole_Handler,
		},
		{
			MethodName: "SubmitUsageEvent",
			Handler:    _AuthService_SubmitUsageEvent_Handler,
		},
		{
			MethodName: "GetLicense",
			Handler:    _AuthService_GetLicense_Handler,
		},
		{
			MethodName: "ListReleases",
			Handler:    _AuthService_ListReleases_Handler,
		},
		{
			MethodName: "ListSAMLIdPServiceProviders",
			Handler:    _AuthService_ListSAMLIdPServiceProviders_Handler,
		},
		{
			MethodName: "GetSAMLIdPServiceProvider",
			Handler:    _AuthService_GetSAMLIdPServiceProvider_Handler,
		},
		{
			MethodName: "CreateSAMLIdPServiceProvider",
			Handler:    _AuthService_CreateSAMLIdPServiceProvider_Handler,
		},
		{
			MethodName: "UpdateSAMLIdPServiceProvider",
			Handler:    _AuthService_UpdateSAMLIdPServiceProvider_Handler,
		},
		{
			MethodName: "DeleteSAMLIdPServiceProvider",
			Handler:    _AuthService_DeleteSAMLIdPServiceProvider_Handler,
		},
		{
			MethodName: "DeleteAllSAMLIdPServiceProviders",
			Handler:    _AuthService_DeleteAllSAMLIdPServiceProviders_Handler,
		},
		{
			MethodName: "ListUserGroups",
			Handler:    _AuthService_ListUserGroups_Handler,
		},
		{
			MethodName: "GetUserGroup",
			Handler:    _AuthService_GetUserGroup_Handler,
		},
		{
			MethodName: "CreateUserGroup",
			Handler:    _AuthService_CreateUserGroup_Handler,
		},
		{
			MethodName: "UpdateUserGroup",
			Handler:    _AuthService_UpdateUserGroup_Handler,
		},
		{
			MethodName: "DeleteUserGroup",
			Handler:    _AuthService_DeleteUserGroup_Handler,
		},
		{
			MethodName: "DeleteAllUserGroups",
			Handler:    _AuthService_DeleteAllUserGroups_Handler,
		},
		{
			MethodName: "GetHeadlessAuthentication",
			Handler:    _AuthService_GetHeadlessAuthentication_Handler,
		},
		{
			MethodName: "UpdateHeadlessAuthenticationState",
			Handler:    _AuthService_UpdateHeadlessAuthenticationState_Handler,
		},
		{
			MethodName: "ExportUpgradeWindows",
			Handler:    _AuthService_ExportUpgradeWindows_Handler,
		},
		{
			MethodName: "GetClusterMaintenanceConfig",
			Handler:    _AuthService_GetClusterMaintenanceConfig_Handler,
		},
		{
			MethodName: "UpdateClusterMaintenanceConfig",
			Handler:    _AuthService_UpdateClusterMaintenanceConfig_Handler,
		},
		{
			MethodName: "DeleteClusterMaintenanceConfig",
			Handler:    _AuthService_DeleteClusterMaintenanceConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InventoryControlStream",
			Handler:       _AuthService_InventoryControlStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetInstances",
			Handler:       _AuthService_GetInstances_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MaintainSessionPresence",
			Handler:       _AuthService_MaintainSessionPresence_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetActiveSessionTrackers",
			Handler:       _AuthService_GetActiveSessionTrackers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetActiveSessionTrackersWithFilter",
			Handler:       _AuthService_GetActiveSessionTrackersWithFilter_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SendKeepAlives",
			Handler:       _AuthService_SendKeepAlives_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "WatchEvents",
			Handler:       _AuthService_WatchEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GenerateUserSingleUseCerts",
			Handler:       _AuthService_GenerateUserSingleUseCerts_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetAccessRequestsV2",
			Handler:       _AuthService_GetAccessRequestsV2_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetCurrentUserRoles",
			Handler:       _AuthService_GetCurrentUserRoles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetUsers",
			Handler:       _AuthService_GetUsers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateAuditStream",
			Handler:       _AuthService_CreateAuditStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "AddMFADevice",
			Handler:       _AuthService_AddMFADevice_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeleteMFADevice",
			Handler:       _AuthService_DeleteMFADevice_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetServerInfos",
			Handler:       _AuthService_GetServerInfos_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamSessionEvents",
			Handler:       _AuthService_StreamSessionEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchPendingHeadlessAuthentications",
			Handler:       _AuthService_WatchPendingHeadlessAuthentications_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "teleport/legacy/client/proto/authservice.proto",
}

func (m *Watch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Watch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Watch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowPartialSuccess {
		i--
		if m.AllowPartialSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Kinds) > 0 {
		for iNdEx := len(m.Kinds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Kinds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HostCertsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostCertsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostCertsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SystemRoleAssertionID) > 0 {
		i -= len(m.SystemRoleAssertionID)
		copy(dAtA[i:], m.SystemRoleAssertionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SystemRoleAssertionID)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.SystemRoles) > 0 {
		for iNdEx := len(m.SystemRoles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SystemRoles[iNdEx])
			copy(dAtA[i:], m.SystemRoles[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SystemRoles[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.NoCache {
		i--
		if m.NoCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Rotation != nil {
		{
			size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RemoteAddr) > 0 {
		i -= len(m.RemoteAddr)
		copy(dAtA[i:], m.RemoteAddr)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RemoteAddr)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PublicSSHKey) > 0 {
		i -= len(m.PublicSSHKey)
		copy(dAtA[i:], m.PublicSSHKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PublicSSHKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PublicTLSKey) > 0 {
		i -= len(m.PublicTLSKey)
		copy(dAtA[i:], m.PublicTLSKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PublicTLSKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DNSNames) > 0 {
		for iNdEx := len(m.DNSNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DNSNames[iNdEx])
			copy(dAtA[i:], m.DNSNames[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.DNSNames[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AdditionalPrincipals) > 0 {
		for iNdEx := len(m.AdditionalPrincipals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AdditionalPrincipals[iNdEx])
			copy(dAtA[i:], m.AdditionalPrincipals[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AdditionalPrincipals[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenSSHCertRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSSHCertRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSSHCertRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x22
	}
	if m.TTL != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *OpenSSHCert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSSHCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSSHCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserCertsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCertsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserCertsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TLSPublicKeyAttestationStatement != nil {
		{
			size, err := m.TLSPublicKeyAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SSHPublicKeyAttestationStatement != nil {
		{
			size, err := m.SSHPublicKeyAttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.TLSPublicKey) > 0 {
		i -= len(m.TLSPublicKey)
		copy(dAtA[i:], m.TLSPublicKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TLSPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.SSHPublicKey) > 0 {
		i -= len(m.SSHPublicKey)
		copy(dAtA[i:], m.SSHPublicKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SSHPublicKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Purpose != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Purpose))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AttestationStatement != nil {
		{
			size, err := m.AttestationStatement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.SSHLogin) > 0 {
		i -= len(m.SSHLogin)
		copy(dAtA[i:], m.SSHLogin)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SSHLogin)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.MFAResponse != nil {
		{
			size, err := m.MFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.RequesterName != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.RequesterName))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.ConnectionDiagnosticID) > 0 {
		i -= len(m.ConnectionDiagnosticID)
		copy(dAtA[i:], m.ConnectionDiagnosticID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ConnectionDiagnosticID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DropAccessRequests) > 0 {
		for iNdEx := len(m.DropAccessRequests) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DropAccessRequests[iNdEx])
			copy(dAtA[i:], m.DropAccessRequests[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.DropAccessRequests[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.UseRoleRequests {
		i--
		if m.UseRoleRequests {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.RouteToWindowsDesktop.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.RoleRequests) > 0 {
		for iNdEx := len(m.RoleRequests) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RoleRequests[iNdEx])
			copy(dAtA[i:], m.RoleRequests[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RoleRequests[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	{
		size, err := m.RouteToApp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.Usage != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Usage))
		i--
		dAtA[i] = 0x50
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.RouteToDatabase.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.KubernetesCluster) > 0 {
		i -= len(m.KubernetesCluster)
		copy(dAtA[i:], m.KubernetesCluster)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.KubernetesCluster)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AccessRequests) > 0 {
		for iNdEx := len(m.AccessRequests) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AccessRequests[iNdEx])
			copy(dAtA[i:], m.AccessRequests[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AccessRequests[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RouteToCluster) > 0 {
		i -= len(m.RouteToCluster)
		copy(dAtA[i:], m.RouteToCluster)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RouteToCluster)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x22
	}
	n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintAuthservice(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x1a
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteToDatabase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteToDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteToDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Database) > 0 {
		i -= len(m.Database)
		copy(dAtA[i:], m.Database)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Database)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteToWindowsDesktop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteToWindowsDesktop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteToWindowsDesktop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Login) > 0 {
		i -= len(m.Login)
		copy(dAtA[i:], m.Login)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Login)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WindowsDesktop) > 0 {
		i -= len(m.WindowsDesktop)
		copy(dAtA[i:], m.WindowsDesktop)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.WindowsDesktop)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteToApp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteToApp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteToApp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GCPServiceAccount) > 0 {
		i -= len(m.GCPServiceAccount)
		copy(dAtA[i:], m.GCPServiceAccount)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.GCPServiceAccount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AzureIdentity) > 0 {
		i -= len(m.AzureIdentity)
		copy(dAtA[i:], m.AzureIdentity)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AzureIdentity)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AWSRoleARN) > 0 {
		i -= len(m.AWSRoleARN)
		copy(dAtA[i:], m.AWSRoleARN)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AWSRoleARN)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PublicAddr) > 0 {
		i -= len(m.PublicAddr)
		copy(dAtA[i:], m.PublicAddr)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PublicAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithSecrets {
		i--
		if m.WithSecrets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetUsersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUsersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUsersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithSecrets {
		i--
		if m.WithSecrets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangePasswordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePasswordRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePasswordRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SecondFactorToken) > 0 {
		i -= len(m.SecondFactorToken)
		copy(dAtA[i:], m.SecondFactorToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SecondFactorToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NewPassword) > 0 {
		i -= len(m.NewPassword)
		copy(dAtA[i:], m.NewPassword)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NewPassword)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OldPassword) > 0 {
		i -= len(m.OldPassword)
		copy(dAtA[i:], m.OldPassword)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.OldPassword)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PluginDataSeq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginDataSeq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginDataSeq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PluginData) > 0 {
		for iNdEx := len(m.PluginData) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PluginData[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RequestStateSetter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestStateSetter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestStateSetter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AssumeStartTime != nil {
		n12, err12 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.AssumeStartTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.AssumeStartTime):])
		if err12 != nil {
			return 0, err12
		}
		i -= n12
		i = encodeVarintAuthservice(dAtA, i, uint64(n12))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size := m.Annotations.Size()
		i -= size
		if _, err := m.Annotations.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetResetPasswordTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetResetPasswordTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetResetPasswordTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TokenID) > 0 {
		i -= len(m.TokenID)
		copy(dAtA[i:], m.TokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateResetPasswordTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateResetPasswordTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateResetPasswordTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TTL != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenewableCertsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenewableCertsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenewableCertsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *PingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LoadAllCAs {
		i--
		if m.LoadAllCAs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.RemoteAddr) > 0 {
		i -= len(m.RemoteAddr)
		copy(dAtA[i:], m.RemoteAddr)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RemoteAddr)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsBoring {
		i--
		if m.IsBoring {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.ProxyPublicAddr) > 0 {
		i -= len(m.ProxyPublicAddr)
		copy(dAtA[i:], m.ProxyPublicAddr)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ProxyPublicAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.ServerFeatures != nil {
		{
			size, err := m.ServerFeatures.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServerVersion) > 0 {
		i -= len(m.ServerVersion)
		copy(dAtA[i:], m.ServerVersion)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Features) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Features) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Features) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccessMonitoringConfigured {
		i--
		if m.AccessMonitoringConfigured {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if len(m.Entitlements) > 0 {
		for k := range m.Entitlements {
			v := m.Entitlements[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAuthservice(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.MobileDeviceManagement {
		i--
		if m.MobileDeviceManagement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.JoinActiveSessions {
		i--
		if m.JoinActiveSessions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.SupportType != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.SupportType))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.ExternalAuditStorage {
		i--
		if m.ExternalAuditStorage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.IsStripeManaged {
		i--
		if m.IsStripeManaged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Questionnaire {
		i--
		if m.Questionnaire {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.ProductType != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.ProductType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.AccessMonitoring != nil {
		{
			size, err := m.AccessMonitoring.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.AccessList != nil {
		{
			size, err := m.AccessList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.AccessGraph {
		i--
		if m.AccessGraph {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.IdentityGovernance {
		i--
		if m.IdentityGovernance {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.CustomTheme) > 0 {
		i -= len(m.CustomTheme)
		copy(dAtA[i:], m.CustomTheme)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CustomTheme)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.AccessRequests != nil {
		{
			size, err := m.AccessRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.FeatureHiding {
		i--
		if m.FeatureHiding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.DeviceTrust != nil {
		{
			size, err := m.DeviceTrust.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Assist {
		i--
		if m.Assist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.IsUsageBased {
		i--
		if m.IsUsageBased {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.AutomaticUpgrades {
		i--
		if m.AutomaticUpgrades {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Plugins {
		i--
		if m.Plugins {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.RecoveryCodes {
		i--
		if m.RecoveryCodes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Desktop {
		i--
		if m.Desktop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.HSM {
		i--
		if m.HSM {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Cloud {
		i--
		if m.Cloud {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.AdvancedAccessWorkflows {
		i--
		if m.AdvancedAccessWorkflows {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AccessControls {
		i--
		if m.AccessControls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SAML {
		i--
		if m.SAML {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.OIDC {
		i--
		if m.OIDC {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DB {
		i--
		if m.DB {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.App {
		i--
		if m.App {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Kubernetes {
		i--
		if m.Kubernetes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EntitlementInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntitlementInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EntitlementInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceTrustFeature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceTrustFeature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceTrustFeature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DevicesUsageLimit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.DevicesUsageLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestsFeature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestsFeature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestsFeature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MonthlyRequestLimit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.MonthlyRequestLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessListFeature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessListFeature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessListFeature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreateLimit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.CreateLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessMonitoringFeature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessMonitoringFeature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessMonitoringFeature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxReportRangeLimit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.MaxReportRangeLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PolicyFeature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyFeature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyFeature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Semaphores) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Semaphores) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Semaphores) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Semaphores) > 0 {
		for iNdEx := len(m.Semaphores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Semaphores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuditStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuditStreamRequest_CreateStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditStreamRequest_CreateStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CreateStream != nil {
		{
			size, err := m.CreateStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AuditStreamRequest_ResumeStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditStreamRequest_ResumeStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResumeStream != nil {
		{
			size, err := m.ResumeStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AuditStreamRequest_CompleteStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditStreamRequest_CompleteStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CompleteStream != nil {
		{
			size, err := m.CompleteStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AuditStreamRequest_FlushAndCloseStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditStreamRequest_FlushAndCloseStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FlushAndCloseStream != nil {
		{
			size, err := m.FlushAndCloseStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AuditStreamRequest_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditStreamRequest_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AuditStreamStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditStreamStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditStreamStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UploadID) > 0 {
		i -= len(m.UploadID)
		copy(dAtA[i:], m.UploadID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.UploadID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResumeStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResumeStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResumeStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UploadID) > 0 {
		i -= len(m.UploadID)
		copy(dAtA[i:], m.UploadID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.UploadID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompleteStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FlushAndCloseStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushAndCloseStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlushAndCloseStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpsertApplicationServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertApplicationServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertApplicationServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Server != nil {
		{
			size, err := m.Server.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteApplicationServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteApplicationServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteApplicationServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteAllApplicationServersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAllApplicationServersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteAllApplicationServersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateAppTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateAppTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateAppTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Traits) > 0 {
		for k := range m.Traits {
			v := m.Traits[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAuthservice(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	n28, err28 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires):])
	if err28 != nil {
		return 0, err28
	}
	i -= n28
	i = encodeVarintAuthservice(dAtA, i, uint64(n28))
	i--
	dAtA[i] = 0x22
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerateAppTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateAppTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateAppTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAppSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAppSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAppSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAppSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppSessionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PageToken) > 0 {
		i -= len(m.PageToken)
		copy(dAtA[i:], m.PageToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PageToken)))
		i--
		dAtA[i] = 0x12
	}
	if m.PageSize != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListAppSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAppSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAppSessionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSnowflakeSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSnowflakeSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSnowflakeSessionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListSAMLIdPSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSAMLIdPSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSAMLIdPSessionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PageToken) > 0 {
		i -= len(m.PageToken)
		copy(dAtA[i:], m.PageToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PageToken)))
		i--
		dAtA[i] = 0x12
	}
	if m.PageSize != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListSAMLIdPSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSAMLIdPSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSAMLIdPSessionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateAppSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAppSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAppSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClientAddr) > 0 {
		i -= len(m.ClientAddr)
		copy(dAtA[i:], m.ClientAddr)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ClientAddr)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.MFAResponse != nil {
		{
			size, err := m.MFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.GCPServiceAccount) > 0 {
		i -= len(m.GCPServiceAccount)
		copy(dAtA[i:], m.GCPServiceAccount)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.GCPServiceAccount)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AzureIdentity) > 0 {
		i -= len(m.AzureIdentity)
		copy(dAtA[i:], m.AzureIdentity)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AzureIdentity)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AWSRoleARN) > 0 {
		i -= len(m.AWSRoleARN)
		copy(dAtA[i:], m.AWSRoleARN)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AWSRoleARN)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PublicAddr) > 0 {
		i -= len(m.PublicAddr)
		copy(dAtA[i:], m.PublicAddr)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PublicAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateAppSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAppSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAppSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSnowflakeSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSnowflakeSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSnowflakeSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TokenTTL != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TokenTTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSnowflakeSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSnowflakeSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSnowflakeSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSAMLIdPSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSAMLIdPSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSAMLIdPSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SAMLSession != nil {
		{
			size, err := m.SAMLSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSAMLIdPSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSAMLIdPSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSAMLIdPSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSnowflakeSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSnowflakeSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSnowflakeSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSnowflakeSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSnowflakeSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSnowflakeSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSAMLIdPSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSAMLIdPSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSAMLIdPSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSAMLIdPSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSAMLIdPSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSAMLIdPSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteAppSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAppSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteAppSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteSnowflakeSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSnowflakeSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteSnowflakeSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteSAMLIdPSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSAMLIdPSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteSAMLIdPSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserAppSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserAppSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserAppSessionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserSAMLIdPSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserSAMLIdPSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserSAMLIdPSessionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWebSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWebSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWebSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Session != nil {
		{
			size, err := m.Session.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWebSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWebSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWebSessionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetWebTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWebTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWebTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWebTokensResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWebTokensResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWebTokensResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpsertKubernetesServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertKubernetesServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertKubernetesServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Server != nil {
		{
			size, err := m.Server.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteKubernetesServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteKubernetesServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteKubernetesServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteAllKubernetesServersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAllKubernetesServersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteAllKubernetesServersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpsertDatabaseServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertDatabaseServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertDatabaseServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Server != nil {
		{
			size, err := m.Server.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteDatabaseServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDatabaseServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteDatabaseServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteAllDatabaseServersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAllDatabaseServersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteAllDatabaseServersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseServiceV1List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseServiceV1List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseServiceV1List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpsertDatabaseServiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertDatabaseServiceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertDatabaseServiceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteAllDatabaseServicesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAllDatabaseServicesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteAllDatabaseServicesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseCSRRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseCSRRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseCSRRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CSR) > 0 {
		i -= len(m.CSR)
		copy(dAtA[i:], m.CSR)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CSR)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseCSRResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseCSRResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseCSRResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CACerts) > 0 {
		for iNdEx := len(m.CACerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CACerts[iNdEx])
			copy(dAtA[i:], m.CACerts[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CACerts[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseCertRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseCertRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseCertRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CRLEndpoint) > 0 {
		i -= len(m.CRLEndpoint)
		copy(dAtA[i:], m.CRLEndpoint)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CRLEndpoint)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CertificateExtensions != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.CertificateExtensions))
		i--
		dAtA[i] = 0x30
	}
	if m.RequesterName != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.RequesterName))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ServerNames) > 0 {
		for iNdEx := len(m.ServerNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ServerNames[iNdEx])
			copy(dAtA[i:], m.ServerNames[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerNames[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TTL != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CSR) > 0 {
		i -= len(m.CSR)
		copy(dAtA[i:], m.CSR)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CSR)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseCertResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseCertResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseCertResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CACerts) > 0 {
		for iNdEx := len(m.CACerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CACerts[iNdEx])
			copy(dAtA[i:], m.CACerts[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CACerts[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnowflakeJWTRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnowflakeJWTRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnowflakeJWTRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountName) > 0 {
		i -= len(m.AccountName)
		copy(dAtA[i:], m.AccountName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AccountName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SnowflakeJWTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnowflakeJWTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnowflakeJWTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRolesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRolesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRolesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListRolesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRolesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRolesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListRolesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRolesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRolesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Roles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpsertRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Role != nil {
		{
			size, err := m.Role.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRoleRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRoleRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRoleRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MFAAuthenticateChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFAAuthenticateChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAAuthenticateChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MFARequired != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.MFARequired))
		i--
		dAtA[i] = 0x20
	}
	if m.WebauthnChallenge != nil {
		{
			size, err := m.WebauthnChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TOTP != nil {
		{
			size, err := m.TOTP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MFAAuthenticateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFAAuthenticateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAAuthenticateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MFAAuthenticateResponse_TOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAAuthenticateResponse_TOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TOTP != nil {
		{
			size, err := m.TOTP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MFAAuthenticateResponse_Webauthn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAAuthenticateResponse_Webauthn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TOTPChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TOTPChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TOTPChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TOTPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TOTPResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TOTPResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MFARegisterChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFARegisterChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFARegisterChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MFARegisterChallenge_TOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFARegisterChallenge_TOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TOTP != nil {
		{
			size, err := m.TOTP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MFARegisterChallenge_Webauthn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFARegisterChallenge_Webauthn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MFARegisterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFARegisterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFARegisterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MFARegisterResponse_TOTP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFARegisterResponse_TOTP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TOTP != nil {
		{
			size, err := m.TOTP.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MFARegisterResponse_Webauthn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFARegisterResponse_Webauthn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TOTPRegisterChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TOTPRegisterChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TOTPRegisterChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.QRCode) > 0 {
		i -= len(m.QRCode)
		copy(dAtA[i:], m.QRCode)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.QRCode)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x32
	}
	if m.Digits != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Digits))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Algorithm) > 0 {
		i -= len(m.Algorithm)
		copy(dAtA[i:], m.Algorithm)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Algorithm)))
		i--
		dAtA[i] = 0x22
	}
	if m.PeriodSeconds != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.PeriodSeconds))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TOTPRegisterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TOTPRegisterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TOTPRegisterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMFADeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMFADeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMFADeviceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AddMFADeviceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMFADeviceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMFADeviceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMFADeviceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMFADeviceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMFADeviceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMFADeviceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMFADeviceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMFADeviceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMFADeviceSyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMFADeviceSyncRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMFADeviceSyncRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExistingMFAResponse != nil {
		{
			size, err := m.ExistingMFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TokenID) > 0 {
		i -= len(m.TokenID)
		copy(dAtA[i:], m.TokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMFADeviceSyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMFADeviceSyncRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMFADeviceSyncRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ContextUser != nil {
		{
			size, err := m.ContextUser.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DeviceUsage != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.DeviceUsage))
		i--
		dAtA[i] = 0x20
	}
	if m.NewMFAResponse != nil {
		{
			size, err := m.NewMFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NewDeviceName) > 0 {
		i -= len(m.NewDeviceName)
		copy(dAtA[i:], m.NewDeviceName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NewDeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TokenID) > 0 {
		i -= len(m.TokenID)
		copy(dAtA[i:], m.TokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMFADeviceSyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMFADeviceSyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMFADeviceSyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMFADevicesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMFADevicesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMFADevicesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TokenID) > 0 {
		i -= len(m.TokenID)
		copy(dAtA[i:], m.TokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMFADevicesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMFADevicesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMFADevicesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserSingleUseCertsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSingleUseCertsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSingleUseCertsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UserSingleUseCertsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSingleUseCertsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSingleUseCertsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *IsMFARequiredRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsMFARequiredRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IsMFARequiredRequest_KubernetesCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredRequest_KubernetesCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.KubernetesCluster)
	copy(dAtA[i:], m.KubernetesCluster)
	i = encodeVarintAuthservice(dAtA, i, uint64(len(m.KubernetesCluster)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *IsMFARequiredRequest_Database) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredRequest_Database) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Database != nil {
		{
			size, err := m.Database.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IsMFARequiredRequest_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredRequest_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IsMFARequiredRequest_WindowsDesktop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredRequest_WindowsDesktop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WindowsDesktop != nil {
		{
			size, err := m.WindowsDesktop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *IsMFARequiredRequest_AdminAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredRequest_AdminAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AdminAction != nil {
		{
			size, err := m.AdminAction.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *IsMFARequiredRequest_App) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredRequest_App) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *StreamSessionEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamSessionEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamSessionEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartIndex != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.StartIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeLogin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeLogin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Login) > 0 {
		i -= len(m.Login)
		copy(dAtA[i:], m.Login)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Login)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdminAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *IsMFARequiredResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsMFARequiredResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsMFARequiredResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MFARequired != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.MFARequired))
		i--
		dAtA[i] = 0x10
	}
	if m.Required {
		i--
		if m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Order != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x38
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x32
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EventTypes) > 0 {
		for iNdEx := len(m.EventTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EventTypes[iNdEx])
			copy(dAtA[i:], m.EventTypes[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.EventTypes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	n63, err63 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.EndDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.EndDate):])
	if err63 != nil {
		return 0, err63
	}
	i -= n63
	i = encodeVarintAuthservice(dAtA, i, uint64(n63))
	i--
	dAtA[i] = 0x1a
	n64, err64 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.StartDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.StartDate):])
	if err64 != nil {
		return 0, err64
	}
	i -= n64
	i = encodeVarintAuthservice(dAtA, i, uint64(n64))
	i--
	dAtA[i] = 0x12
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSessionEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSessionEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSessionEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Order != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x28
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	n65, err65 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.EndDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.EndDate):])
	if err65 != nil {
		return 0, err65
	}
	i -= n65
	i = encodeVarintAuthservice(dAtA, i, uint64(n65))
	i--
	dAtA[i] = 0x12
	n66, err66 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.StartDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.StartDate):])
	if err66 != nil {
		return 0, err66
	}
	i -= n66
	i = encodeVarintAuthservice(dAtA, i, uint64(n66))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Events) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Events) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Events) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastKey) > 0 {
		i -= len(m.LastKey)
		copy(dAtA[i:], m.LastKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.LastKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetLocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InForceOnly {
		i--
		if m.InForceOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Targets) > 0 {
		for iNdEx := len(m.Targets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Targets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetLocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLocksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLocksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Locks) > 0 {
		for iNdEx := len(m.Locks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteLockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteLockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceRemoteLocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceRemoteLocksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceRemoteLocksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Locks) > 0 {
		for iNdEx := len(m.Locks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Locks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWindowsDesktopServicesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWindowsDesktopServicesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWindowsDesktopServicesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetWindowsDesktopServiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWindowsDesktopServiceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWindowsDesktopServiceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWindowsDesktopServiceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWindowsDesktopServiceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWindowsDesktopServiceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteWindowsDesktopServiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteWindowsDesktopServiceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteWindowsDesktopServiceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWindowsDesktopsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWindowsDesktopsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWindowsDesktopsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Desktops) > 0 {
		for iNdEx := len(m.Desktops) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Desktops[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteWindowsDesktopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteWindowsDesktopRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteWindowsDesktopRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowsDesktopCertRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsDesktopCertRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowsDesktopCertRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TTL != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CRLEndpoint) > 0 {
		i -= len(m.CRLEndpoint)
		copy(dAtA[i:], m.CRLEndpoint)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CRLEndpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CSR) > 0 {
		i -= len(m.CSR)
		copy(dAtA[i:], m.CSR)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CSR)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WindowsDesktopCertResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsDesktopCertResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WindowsDesktopCertResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DesktopBootstrapScriptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DesktopBootstrapScriptResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DesktopBootstrapScriptResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Script) > 0 {
		i -= len(m.Script)
		copy(dAtA[i:], m.Script)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Script)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListSAMLIdPServiceProvidersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSAMLIdPServiceProvidersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSAMLIdPServiceProvidersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListSAMLIdPServiceProvidersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSAMLIdPServiceProvidersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListSAMLIdPServiceProvidersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalCount != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceProviders) > 0 {
		for iNdEx := len(m.ServiceProviders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ServiceProviders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSAMLIdPServiceProviderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSAMLIdPServiceProviderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSAMLIdPServiceProviderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteSAMLIdPServiceProviderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSAMLIdPServiceProviderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteSAMLIdPServiceProviderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUserGroupsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserGroupsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserGroupsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListUserGroupsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUserGroupsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUserGroupsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalCount != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserGroups) > 0 {
		for iNdEx := len(m.UserGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetUserGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserGroupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserGroupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserGroupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertAuthorityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertAuthorityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertAuthorityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CRL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CRL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CRL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CRL) > 0 {
		i -= len(m.CRL)
		copy(dAtA[i:], m.CRL)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CRL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeUserAuthenticationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeUserAuthenticationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeUserAuthenticationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LoginIP) > 0 {
		i -= len(m.LoginIP)
		copy(dAtA[i:], m.LoginIP)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.LoginIP)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewDeviceName) > 0 {
		i -= len(m.NewDeviceName)
		copy(dAtA[i:], m.NewDeviceName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NewDeviceName)))
		i--
		dAtA[i] = 0x22
	}
	if m.NewMFARegisterResponse != nil {
		{
			size, err := m.NewMFARegisterResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NewPassword) > 0 {
		i -= len(m.NewPassword)
		copy(dAtA[i:], m.NewPassword)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NewPassword)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TokenID) > 0 {
		i -= len(m.TokenID)
		copy(dAtA[i:], m.TokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeUserAuthenticationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeUserAuthenticationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeUserAuthenticationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrivateKeyPolicyEnabled {
		i--
		if m.PrivateKeyPolicyEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Recovery != nil {
		{
			size, err := m.Recovery.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.WebSession != nil {
		{
			size, err := m.WebSession.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartAccountRecoveryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartAccountRecoveryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartAccountRecoveryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RecoverType != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.RecoverType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RecoveryCode) > 0 {
		i -= len(m.RecoveryCode)
		copy(dAtA[i:], m.RecoveryCode)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RecoveryCode)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyAccountRecoveryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyAccountRecoveryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyAccountRecoveryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthnCred != nil {
		{
			size := m.AuthnCred.Size()
			i -= size
			if _, err := m.AuthnCred.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecoveryStartTokenID) > 0 {
		i -= len(m.RecoveryStartTokenID)
		copy(dAtA[i:], m.RecoveryStartTokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RecoveryStartTokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyAccountRecoveryRequest_Password) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyAccountRecoveryRequest_Password) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Password != nil {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VerifyAccountRecoveryRequest_MFAAuthenticateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyAccountRecoveryRequest_MFAAuthenticateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MFAAuthenticateResponse != nil {
		{
			size, err := m.MFAAuthenticateResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CompleteAccountRecoveryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteAccountRecoveryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteAccountRecoveryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewAuthnCred != nil {
		{
			size := m.NewAuthnCred.Size()
			i -= size
			if _, err := m.NewAuthnCred.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.NewDeviceName) > 0 {
		i -= len(m.NewDeviceName)
		copy(dAtA[i:], m.NewDeviceName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NewDeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecoveryApprovedTokenID) > 0 {
		i -= len(m.RecoveryApprovedTokenID)
		copy(dAtA[i:], m.RecoveryApprovedTokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RecoveryApprovedTokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompleteAccountRecoveryRequest_NewPassword) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteAccountRecoveryRequest_NewPassword) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewPassword != nil {
		i -= len(m.NewPassword)
		copy(dAtA[i:], m.NewPassword)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NewPassword)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CompleteAccountRecoveryRequest_NewMFAResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteAccountRecoveryRequest_NewMFAResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewMFAResponse != nil {
		{
			size, err := m.NewMFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RecoveryCodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryCodes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryCodes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n73, err73 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err73 != nil {
		return 0, err73
	}
	i -= n73
	i = encodeVarintAuthservice(dAtA, i, uint64(n73))
	i--
	dAtA[i] = 0x12
	if len(m.Codes) > 0 {
		for iNdEx := len(m.Codes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Codes[iNdEx])
			copy(dAtA[i:], m.Codes[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Codes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateAccountRecoveryCodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAccountRecoveryCodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAccountRecoveryCodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TokenID) > 0 {
		i -= len(m.TokenID)
		copy(dAtA[i:], m.TokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAccountRecoveryTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountRecoveryTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAccountRecoveryTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RecoveryTokenID) > 0 {
		i -= len(m.RecoveryTokenID)
		copy(dAtA[i:], m.RecoveryTokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RecoveryTokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAccountRecoveryCodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountRecoveryCodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAccountRecoveryCodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UserCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContextUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContextUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContextUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Passwordless) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Passwordless) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Passwordless) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CreateAuthenticateChallengeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAuthenticateChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAuthenticateChallengeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChallengeExtensions != nil {
		{
			size, err := m.ChallengeExtensions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MFARequiredCheck != nil {
		{
			size, err := m.MFARequiredCheck.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateAuthenticateChallengeRequest_UserCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAuthenticateChallengeRequest_UserCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserCredentials != nil {
		{
			size, err := m.UserCredentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CreateAuthenticateChallengeRequest_RecoveryStartTokenID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAuthenticateChallengeRequest_RecoveryStartTokenID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RecoveryStartTokenID)
	copy(dAtA[i:], m.RecoveryStartTokenID)
	i = encodeVarintAuthservice(dAtA, i, uint64(len(m.RecoveryStartTokenID)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CreateAuthenticateChallengeRequest_ContextUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAuthenticateChallengeRequest_ContextUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContextUser != nil {
		{
			size, err := m.ContextUser.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateAuthenticateChallengeRequest_Passwordless) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateAuthenticateChallengeRequest_Passwordless) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Passwordless != nil {
		{
			size, err := m.Passwordless.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreatePrivilegeTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePrivilegeTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePrivilegeTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExistingMFAResponse != nil {
		{
			size, err := m.ExistingMFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateRegisterChallengeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRegisterChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateRegisterChallengeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExistingMFAResponse != nil {
		{
			size, err := m.ExistingMFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DeviceUsage != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.DeviceUsage))
		i--
		dAtA[i] = 0x18
	}
	if m.DeviceType != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.DeviceType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TokenID) > 0 {
		i -= len(m.TokenID)
		copy(dAtA[i:], m.TokenID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TokenID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PaginatedResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaginatedResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequiresRequest {
		i--
		if m.RequiresRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.Logins) > 0 {
		for iNdEx := len(m.Logins) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Logins[iNdEx])
			copy(dAtA[i:], m.Logins[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Logins[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Resource != nil {
		{
			size := m.Resource.Size()
			i -= size
			if _, err := m.Resource.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PaginatedResource_DatabaseServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_DatabaseServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseServer != nil {
		{
			size, err := m.DatabaseServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_AppServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_AppServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppServer != nil {
		{
			size, err := m.AppServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_WindowsDesktop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_WindowsDesktop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WindowsDesktop != nil {
		{
			size, err := m.WindowsDesktop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_KubeCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_KubeCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KubeCluster != nil {
		{
			size, err := m.KubeCluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_KubernetesServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_KubernetesServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KubernetesServer != nil {
		{
			size, err := m.KubernetesServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_WindowsDesktopService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_WindowsDesktopService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WindowsDesktopService != nil {
		{
			size, err := m.WindowsDesktopService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_DatabaseService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_DatabaseService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DatabaseService != nil {
		{
			size, err := m.DatabaseService.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_UserGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_UserGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserGroup != nil {
		{
			size, err := m.UserGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_AppServerOrSAMLIdPServiceProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_AppServerOrSAMLIdPServiceProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppServerOrSAMLIdPServiceProvider != nil {
		{
			size, err := m.AppServerOrSAMLIdPServiceProvider.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *PaginatedResource_SAMLIdPServiceProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginatedResource_SAMLIdPServiceProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SAMLIdPServiceProvider != nil {
		{
			size, err := m.SAMLIdPServiceProvider.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ListUnifiedResourcesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUnifiedResourcesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUnifiedResourcesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IncludeRequestable {
		i--
		if m.IncludeRequestable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.IncludeLogins {
		i--
		if m.IncludeLogins {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.PinnedOnly {
		i--
		if m.PinnedOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.UsePreviewAsRoles {
		i--
		if m.UsePreviewAsRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.UseSearchAsRoles {
		i--
		if m.UseSearchAsRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	{
		size, err := m.WindowsDesktopFilter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.SortBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.SearchKeywords) > 0 {
		for iNdEx := len(m.SearchKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchKeywords[iNdEx])
			copy(dAtA[i:], m.SearchKeywords[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SearchKeywords[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PredicateExpression) > 0 {
		i -= len(m.PredicateExpression)
		copy(dAtA[i:], m.PredicateExpression)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PredicateExpression)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Kinds) > 0 {
		for iNdEx := len(m.Kinds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Kinds[iNdEx])
			copy(dAtA[i:], m.Kinds[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Kinds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUnifiedResourcesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUnifiedResourcesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUnifiedResourcesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListResourcesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResourcesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListResourcesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IncludeLogins {
		i--
		if m.IncludeLogins {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.UsePreviewAsRoles {
		i--
		if m.UsePreviewAsRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.UseSearchAsRoles {
		i--
		if m.UseSearchAsRoles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	{
		size, err := m.WindowsDesktopFilter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.NeedTotalCount {
		i--
		if m.NeedTotalCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	{
		size, err := m.SortBy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.SearchKeywords) > 0 {
		for iNdEx := len(m.SearchKeywords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SearchKeywords[iNdEx])
			copy(dAtA[i:], m.SearchKeywords[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SearchKeywords[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.PredicateExpression) > 0 {
		i -= len(m.PredicateExpression)
		copy(dAtA[i:], m.PredicateExpression)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.PredicateExpression)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSSHTargetsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSSHTargetsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSSHTargetsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Port) > 0 {
		i -= len(m.Port)
		copy(dAtA[i:], m.Port)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Port)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSSHTargetsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSSHTargetsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSSHTargetsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Servers) > 0 {
		for iNdEx := len(m.Servers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Servers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListResourcesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListResourcesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListResourcesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalCount != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSessionTrackerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSessionTrackerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSessionTrackerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SessionTracker != nil {
		{
			size, err := m.SessionTracker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}

func (m *GetSessionTrackerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSessionTrackerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSessionTrackerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveSessionTrackerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveSessionTrackerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveSessionTrackerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionTrackerUpdateState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerUpdateState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerUpdateState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *SessionTrackerAddParticipant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerAddParticipant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerAddParticipant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Participant != nil {
		{
			size, err := m.Participant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SessionTrackerRemoveParticipant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerRemoveParticipant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerRemoveParticipant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParticipantID) > 0 {
		i -= len(m.ParticipantID)
		copy(dAtA[i:], m.ParticipantID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ParticipantID)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SessionTrackerUpdateExpiry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTrackerUpdateExpiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionTrackerUpdateExpiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Expires != nil {
		n98, err98 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires):])
		if err98 != nil {
			return 0, err98
		}
		i -= n98
		i = encodeVarintAuthservice(dAtA, i, uint64(n98))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSessionTrackerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSessionTrackerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSessionTrackerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Update != nil {
		{
			size := m.Update.Size()
			i -= size
			if _, err := m.Update.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSessionTrackerRequest_UpdateState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSessionTrackerRequest_UpdateState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateState != nil {
		{
			size, err := m.UpdateState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UpdateSessionTrackerRequest_AddParticipant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSessionTrackerRequest_AddParticipant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddParticipant != nil {
		{
			size, err := m.AddParticipant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *UpdateSessionTrackerRequest_RemoveParticipant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSessionTrackerRequest_RemoveParticipant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveParticipant != nil {
		{
			size, err := m.RemoveParticipant.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *UpdateSessionTrackerRequest_UpdateExpiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSessionTrackerRequest_UpdateExpiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateExpiry != nil {
		{
			size, err := m.UpdateExpiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PresenceMFAChallengeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PresenceMFAChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PresenceMFAChallengeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SessionID) > 0 {
		i -= len(m.SessionID)
		copy(dAtA[i:], m.SessionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SessionID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PresenceMFAChallengeSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PresenceMFAChallengeSend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PresenceMFAChallengeSend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PresenceMFAChallengeSend_ChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PresenceMFAChallengeSend_ChallengeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChallengeRequest != nil {
		{
			size, err := m.ChallengeRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PresenceMFAChallengeSend_ChallengeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PresenceMFAChallengeSend_ChallengeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ChallengeResponse != nil {
		{
			size, err := m.ChallengeResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetDomainNameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDomainNameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDomainNameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DomainName) > 0 {
		i -= len(m.DomainName)
		copy(dAtA[i:], m.DomainName)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.DomainName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterCACertResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterCACertResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterCACertResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TLSCA) > 0 {
		i -= len(m.TLSCA)
		copy(dAtA[i:], m.TLSCA)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TLSCA)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLicenseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLicenseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLicenseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.License) > 0 {
		i -= len(m.License)
		copy(dAtA[i:], m.License)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.License)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListReleasesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReleasesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReleasesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Releases) > 0 {
		for iNdEx := len(m.Releases) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Releases[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetOIDCAuthRequestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetOIDCAuthRequestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetOIDCAuthRequestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateToken) > 0 {
		i -= len(m.StateToken)
		copy(dAtA[i:], m.StateToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StateToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSAMLAuthRequestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSAMLAuthRequestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSAMLAuthRequestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetGithubAuthRequestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGithubAuthRequestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetGithubAuthRequestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateToken) > 0 {
		i -= len(m.StateToken)
		copy(dAtA[i:], m.StateToken)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StateToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateOIDCConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOIDCConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateOIDCConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateOIDCConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOIDCConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateOIDCConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpsertOIDCConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertOIDCConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertOIDCConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSAMLConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSAMLConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSAMLConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSAMLConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSAMLConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSAMLConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpsertSAMLConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertSAMLConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertSAMLConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateGithubConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateGithubConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateGithubConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGithubConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGithubConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGithubConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpsertGithubConnectorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertGithubConnectorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertGithubConnectorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connector != nil {
		{
			size, err := m.Connector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSSODiagnosticInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSSODiagnosticInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSSODiagnosticInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AuthRequestID) > 0 {
		i -= len(m.AuthRequestID)
		copy(dAtA[i:], m.AuthRequestID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AuthRequestID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AuthRequestKind) > 0 {
		i -= len(m.AuthRequestKind)
		copy(dAtA[i:], m.AuthRequestKind)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AuthRequestKind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemRoleAssertion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemRoleAssertion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemRoleAssertion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SystemRole) > 0 {
		i -= len(m.SystemRole)
		copy(dAtA[i:], m.SystemRole)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SystemRole)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AssertionID) > 0 {
		i -= len(m.AssertionID)
		copy(dAtA[i:], m.AssertionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AssertionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemRoleAssertionSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemRoleAssertionSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemRoleAssertionSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SystemRoles) > 0 {
		for iNdEx := len(m.SystemRoles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SystemRoles[iNdEx])
			copy(dAtA[i:], m.SystemRoles[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SystemRoles[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AssertionID) > 0 {
		i -= len(m.AssertionID)
		copy(dAtA[i:], m.AssertionID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AssertionID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamInventoryOneOf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamInventoryOneOf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryOneOf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamInventoryOneOf_Hello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryOneOf_Hello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hello != nil {
		{
			size, err := m.Hello.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *UpstreamInventoryOneOf_Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryOneOf_Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Heartbeat != nil {
		{
			size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UpstreamInventoryOneOf_Pong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryOneOf_Pong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pong != nil {
		{
			size, err := m.Pong.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *UpstreamInventoryOneOf_AgentMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryOneOf_AgentMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AgentMetadata != nil {
		{
			size, err := m.AgentMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *UpstreamInventoryOneOf_Goodbye) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryOneOf_Goodbye) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Goodbye != nil {
		{
			size, err := m.Goodbye.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DownstreamInventoryOneOf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownstreamInventoryOneOf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryOneOf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Msg != nil {
		{
			size := m.Msg.Size()
			i -= size
			if _, err := m.Msg.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DownstreamInventoryOneOf_Hello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryOneOf_Hello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hello != nil {
		{
			size, err := m.Hello.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DownstreamInventoryOneOf_Ping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryOneOf_Ping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ping != nil {
		{
			size, err := m.Ping.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DownstreamInventoryOneOf_UpdateLabels) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryOneOf_UpdateLabels) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateLabels != nil {
		{
			size, err := m.UpdateLabels.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DownstreamInventoryPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownstreamInventoryPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamInventoryPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamInventoryPong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryPong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamInventoryHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamInventoryHello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalUpgraderVersion) > 0 {
		i -= len(m.ExternalUpgraderVersion)
		copy(dAtA[i:], m.ExternalUpgraderVersion)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ExternalUpgraderVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ExternalUpgrader) > 0 {
		i -= len(m.ExternalUpgrader)
		copy(dAtA[i:], m.ExternalUpgrader)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ExternalUpgrader)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Services[iNdEx])
			copy(dAtA[i:], m.Services[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Services[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamInventoryAgentMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamInventoryAgentMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryAgentMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CloudEnvironment) > 0 {
		i -= len(m.CloudEnvironment)
		copy(dAtA[i:], m.CloudEnvironment)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.CloudEnvironment)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ContainerOrchestrator) > 0 {
		i -= len(m.ContainerOrchestrator)
		copy(dAtA[i:], m.ContainerOrchestrator)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ContainerOrchestrator)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ContainerRuntime) > 0 {
		i -= len(m.ContainerRuntime)
		copy(dAtA[i:], m.ContainerRuntime)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ContainerRuntime)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.InstallMethods) > 0 {
		for iNdEx := len(m.InstallMethods) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InstallMethods[iNdEx])
			copy(dAtA[i:], m.InstallMethods[iNdEx])
			i = encodeVarintAuthservice(dAtA, i, uint64(len(m.InstallMethods[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.GlibcVersion) > 0 {
		i -= len(m.GlibcVersion)
		copy(dAtA[i:], m.GlibcVersion)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.GlibcVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.HostArchitecture) > 0 {
		i -= len(m.HostArchitecture)
		copy(dAtA[i:], m.HostArchitecture)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.HostArchitecture)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OSVersion) > 0 {
		i -= len(m.OSVersion)
		copy(dAtA[i:], m.OSVersion)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.OSVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OS) > 0 {
		i -= len(m.OS)
		copy(dAtA[i:], m.OS)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.OS)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownstreamInventoryHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownstreamInventoryHello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Capabilities != nil {
		{
			size, err := m.Capabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownstreamInventoryHello_SupportedCapabilities) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownstreamInventoryHello_SupportedCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryHello_SupportedCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KubernetesCleanup {
		i--
		if m.KubernetesCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.KubernetesHeartbeats {
		i--
		if m.KubernetesHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.WindowsDesktopServiceCleanup {
		i--
		if m.WindowsDesktopServiceCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.WindowsDesktopServiceHeartbeats {
		i--
		if m.WindowsDesktopServiceHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.WindowsDesktopCleanup {
		i--
		if m.WindowsDesktopCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.WindowsDesktopHeartbeats {
		i--
		if m.WindowsDesktopHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.DatabaseServiceCleanup {
		i--
		if m.DatabaseServiceCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.DatabaseServiceHeartbeats {
		i--
		if m.DatabaseServiceHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.DatabaseCleanup {
		i--
		if m.DatabaseCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.DatabaseHeartbeats {
		i--
		if m.DatabaseHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.AppCleanup {
		i--
		if m.AppCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.AppHeartbeats {
		i--
		if m.AppHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.NodeCleanup {
		i--
		if m.NodeCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.NodeHeartbeats {
		i--
		if m.NodeHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.AuthCleanup {
		i--
		if m.AuthCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AuthHeartbeats {
		i--
		if m.AuthHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ProxyCleanup {
		i--
		if m.ProxyCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ProxyHeartbeats {
		i--
		if m.ProxyHeartbeats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InventoryUpdateLabelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryUpdateLabelsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryUpdateLabelsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Kind != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownstreamInventoryUpdateLabels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownstreamInventoryUpdateLabels) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamInventoryUpdateLabels) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Kind != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InventoryHeartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryHeartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryHeartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DatabaseServer != nil {
		{
			size, err := m.DatabaseServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AppServer != nil {
		{
			size, err := m.AppServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SSHServer != nil {
		{
			size, err := m.SSHServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamInventoryGoodbye) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamInventoryGoodbye) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamInventoryGoodbye) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeleteResources {
		i--
		if m.DeleteResources {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InventoryStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Connected {
		i--
		if m.Connected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InventoryStatusSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryStatusSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryStatusSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceCounts) > 0 {
		for k := range m.ServiceCounts {
			v := m.ServiceCounts[k]
			baseI := i
			i = encodeVarintAuthservice(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.UpgraderCounts) > 0 {
		for k := range m.UpgraderCounts {
			v := m.UpgraderCounts[k]
			baseI := i
			i = encodeVarintAuthservice(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.VersionCounts) > 0 {
		for k := range m.VersionCounts {
			v := m.VersionCounts[k]
			baseI := i
			i = encodeVarintAuthservice(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.InstanceCount != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.InstanceCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Connected) > 0 {
		for iNdEx := len(m.Connected) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Connected[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InventoryConnectedServiceCountsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryConnectedServiceCountsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryConnectedServiceCountsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *InventoryConnectedServiceCounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryConnectedServiceCounts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryConnectedServiceCounts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServiceCounts) > 0 {
		for k := range m.ServiceCounts {
			v := m.ServiceCounts[k]
			baseI := i
			i = encodeVarintAuthservice(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAuthservice(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAuthservice(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InventoryPingRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryPingRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryPingRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ControlLog {
		i--
		if m.ControlLog {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ServerID) > 0 {
		i -= len(m.ServerID)
		copy(dAtA[i:], m.ServerID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.ServerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InventoryPingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventoryPingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InventoryPingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Duration != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterAlertsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterAlertsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterAlertsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Alerts) > 0 {
		for iNdEx := len(m.Alerts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Alerts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetAlertAcksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAlertAcksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAlertAcksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetAlertAcksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAlertAcksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAlertAcksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Acks) > 0 {
		for iNdEx := len(m.Acks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Acks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClearAlertAcksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearAlertAcksRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearAlertAcksRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AlertID) > 0 {
		i -= len(m.AlertID)
		copy(dAtA[i:], m.AlertID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AlertID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpsertClusterAlertRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertClusterAlertRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertClusterAlertRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Alert.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAuthservice(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetConnectionDiagnosticRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetConnectionDiagnosticRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetConnectionDiagnosticRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendDiagnosticTraceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendDiagnosticTraceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendDiagnosticTraceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Trace != nil {
		{
			size, err := m.Trace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubmitUsageEventRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitUsageEventRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitUsageEventRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Event != nil {
		{
			size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLicenseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLicenseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLicenseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ListReleasesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListReleasesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListReleasesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CreateTokenV2Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTokenV2Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTokenV2Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Token != nil {
		{
			size := m.Token.Size()
			i -= size
			if _, err := m.Token.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateTokenV2Request_V2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTokenV2Request_V2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.V2 != nil {
		{
			size, err := m.V2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *UpsertTokenV2Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpsertTokenV2Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertTokenV2Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Token != nil {
		{
			size := m.Token.Size()
			i -= size
			if _, err := m.Token.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpsertTokenV2Request_V2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpsertTokenV2Request_V2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.V2 != nil {
		{
			size, err := m.V2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GetHeadlessAuthenticationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHeadlessAuthenticationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHeadlessAuthenticationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateHeadlessAuthenticationStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateHeadlessAuthenticationStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateHeadlessAuthenticationStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MfaResponse != nil {
		{
			size, err := m.MfaResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportUpgradeWindowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportUpgradeWindowsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportUpgradeWindowsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UpgraderKind) > 0 {
		i -= len(m.UpgraderKind)
		copy(dAtA[i:], m.UpgraderKind)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.UpgraderKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TeleportVersion) > 0 {
		i -= len(m.TeleportVersion)
		copy(dAtA[i:], m.TeleportVersion)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.TeleportVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportUpgradeWindowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportUpgradeWindowsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportUpgradeWindowsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SystemdUnitSchedule) > 0 {
		i -= len(m.SystemdUnitSchedule)
		copy(dAtA[i:], m.SystemdUnitSchedule)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.SystemdUnitSchedule)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KubeControllerSchedule) > 0 {
		i -= len(m.KubeControllerSchedule)
		copy(dAtA[i:], m.KubeControllerSchedule)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.KubeControllerSchedule)))
		i--
		dAtA[i] = 0x12
	}
	if m.CanonicalSchedule != nil {
		{
			size, err := m.CanonicalSchedule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAccessRequestsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAccessRequestsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAccessRequestsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Limit != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Descending {
		i--
		if m.Descending {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Sort != 0 {
		i = encodeVarintAuthservice(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x10
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListAccessRequestsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAccessRequestsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListAccessRequestsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NextKey) > 0 {
		i -= len(m.NextKey)
		copy(dAtA[i:], m.NextKey)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.NextKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccessRequests) > 0 {
		for iNdEx := len(m.AccessRequests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccessRequests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAuthservice(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestAllowedPromotionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestAllowedPromotionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestAllowedPromotionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccessRequestID) > 0 {
		i -= len(m.AccessRequestID)
		copy(dAtA[i:], m.AccessRequestID)
		i = encodeVarintAuthservice(dAtA, i, uint64(len(m.AccessRequestID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessRequestAllowedPromotionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessRequestAllowedPromotionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessRequestAllowedPromotionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AllowedPromotions != nil {
		{
			size, err := m.AllowedPromotions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthservice(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuthservice(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuthservice(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Watch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for _, e := range m.Kinds {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.AllowPartialSuccess {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HostCertsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.AdditionalPrincipals) > 0 {
		for _, s := range m.AdditionalPrincipals {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if len(m.DNSNames) > 0 {
		for _, s := range m.DNSNames {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.PublicTLSKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.PublicSSHKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.RemoteAddr)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Rotation != nil {
		l = m.Rotation.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.NoCache {
		n += 2
	}
	if len(m.SystemRoles) > 0 {
		for _, s := range m.SystemRoles {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.SystemRoleAssertionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenSSHCertRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovAuthservice(uint64(m.TTL))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenSSHCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserCertsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovAuthservice(uint64(l))
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.RouteToCluster)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.AccessRequests) > 0 {
		for _, s := range m.AccessRequests {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.KubernetesCluster)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = m.RouteToDatabase.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Usage != 0 {
		n += 1 + sovAuthservice(uint64(m.Usage))
	}
	l = m.RouteToApp.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	if len(m.RoleRequests) > 0 {
		for _, s := range m.RoleRequests {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = m.RouteToWindowsDesktop.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	if m.UseRoleRequests {
		n += 2
	}
	if len(m.DropAccessRequests) > 0 {
		for _, s := range m.DropAccessRequests {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.ConnectionDiagnosticID)
	if l > 0 {
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.RequesterName != 0 {
		n += 2 + sovAuthservice(uint64(m.RequesterName))
	}
	if m.MFAResponse != nil {
		l = m.MFAResponse.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	l = len(m.SSHLogin)
	if l > 0 {
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.AttestationStatement != nil {
		l = m.AttestationStatement.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.Purpose != 0 {
		n += 2 + sovAuthservice(uint64(m.Purpose))
	}
	l = len(m.SSHPublicKey)
	if l > 0 {
		n += 2 + l + sovAuthservice(uint64(l))
	}
	l = len(m.TLSPublicKey)
	if l > 0 {
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.SSHPublicKeyAttestationStatement != nil {
		l = m.SSHPublicKeyAttestationStatement.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.TLSPublicKeyAttestationStatement != nil {
		l = m.TLSPublicKeyAttestationStatement.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteToDatabase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Database)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteToWindowsDesktop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WindowsDesktop)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RouteToApp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.PublicAddr)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AWSRoleARN)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AzureIdentity)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.GCPServiceAccount)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.WithSecrets {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUsersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithSecrets {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePasswordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.OldPassword)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.NewPassword)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.SecondFactorToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginDataSeq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PluginData) > 0 {
		for _, e := range m.PluginData {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestStateSetter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAuthservice(uint64(m.State))
	}
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = m.Annotations.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.AssumeStartTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.AssumeStartTime)
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetResetPasswordTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateResetPasswordTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovAuthservice(uint64(m.TTL))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenewableCertsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ServerVersion)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.ServerFeatures != nil {
		l = m.ServerFeatures.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ProxyPublicAddr)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.IsBoring {
		n += 2
	}
	l = len(m.RemoteAddr)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.LoadAllCAs {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Features) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kubernetes {
		n += 2
	}
	if m.App {
		n += 2
	}
	if m.DB {
		n += 2
	}
	if m.OIDC {
		n += 2
	}
	if m.SAML {
		n += 2
	}
	if m.AccessControls {
		n += 2
	}
	if m.AdvancedAccessWorkflows {
		n += 2
	}
	if m.Cloud {
		n += 2
	}
	if m.HSM {
		n += 2
	}
	if m.Desktop {
		n += 2
	}
	if m.RecoveryCodes {
		n += 2
	}
	if m.Plugins {
		n += 2
	}
	if m.AutomaticUpgrades {
		n += 3
	}
	if m.IsUsageBased {
		n += 3
	}
	if m.Assist {
		n += 3
	}
	if m.DeviceTrust != nil {
		l = m.DeviceTrust.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.FeatureHiding {
		n += 3
	}
	if m.AccessRequests != nil {
		l = m.AccessRequests.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	l = len(m.CustomTheme)
	if l > 0 {
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.IdentityGovernance {
		n += 3
	}
	if m.AccessGraph {
		n += 3
	}
	if m.AccessList != nil {
		l = m.AccessList.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.AccessMonitoring != nil {
		l = m.AccessMonitoring.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.ProductType != 0 {
		n += 2 + sovAuthservice(uint64(m.ProductType))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 2 + l + sovAuthservice(uint64(l))
	}
	if m.Questionnaire {
		n += 3
	}
	if m.IsStripeManaged {
		n += 3
	}
	if m.ExternalAuditStorage {
		n += 3
	}
	if m.SupportType != 0 {
		n += 2 + sovAuthservice(uint64(m.SupportType))
	}
	if m.JoinActiveSessions {
		n += 3
	}
	if m.MobileDeviceManagement {
		n += 3
	}
	if len(m.Entitlements) > 0 {
		for k, v := range m.Entitlements {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAuthservice(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if m.AccessMonitoringConfigured {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EntitlementInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceTrustFeature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.DevicesUsageLimit != 0 {
		n += 1 + sovAuthservice(uint64(m.DevicesUsageLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestsFeature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonthlyRequestLimit != 0 {
		n += 1 + sovAuthservice(uint64(m.MonthlyRequestLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessListFeature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateLimit != 0 {
		n += 1 + sovAuthservice(uint64(m.CreateLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessMonitoringFeature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.MaxReportRangeLimit != 0 {
		n += 1 + sovAuthservice(uint64(m.MaxReportRangeLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PolicyFeature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteUserRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Semaphores) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Semaphores) > 0 {
		for _, e := range m.Semaphores {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuditStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuditStreamRequest_CreateStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateStream != nil {
		l = m.CreateStream.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *AuditStreamRequest_ResumeStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResumeStream != nil {
		l = m.ResumeStream.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *AuditStreamRequest_CompleteStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompleteStream != nil {
		l = m.CompleteStream.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *AuditStreamRequest_FlushAndCloseStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlushAndCloseStream != nil {
		l = m.FlushAndCloseStream.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *AuditStreamRequest_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *AuditStreamStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UploadID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResumeStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.UploadID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlushAndCloseStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertApplicationServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteApplicationServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAllApplicationServersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateAppTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Expires)
	n += 1 + l + sovAuthservice(uint64(l))
	if len(m.Traits) > 0 {
		for k, v := range m.Traits {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAuthservice(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerateAppTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAppSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageSize != 0 {
		n += 1 + sovAuthservice(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAppSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSnowflakeSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListSAMLIdPSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageSize != 0 {
		n += 1 + sovAuthservice(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListSAMLIdPSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAppSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.PublicAddr)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AWSRoleARN)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AzureIdentity)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.GCPServiceAccount)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.MFAResponse != nil {
		l = m.MFAResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ClientAddr)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAppSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSnowflakeSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TokenTTL != 0 {
		n += 1 + sovAuthservice(uint64(m.TokenTTL))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSnowflakeSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSAMLIdPSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.SAMLSession != nil {
		l = m.SAMLSession.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSAMLIdPSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSnowflakeSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSnowflakeSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSAMLIdPSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSAMLIdPSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAppSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteSnowflakeSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteSAMLIdPSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteUserAppSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteUserSAMLIdPSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWebSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWebSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWebTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWebTokensResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertKubernetesServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteKubernetesServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAllKubernetesServersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertDatabaseServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Server != nil {
		l = m.Server.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteDatabaseServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAllDatabaseServersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseServiceV1List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertDatabaseServiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAllDatabaseServicesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseCSRRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CSR)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseCSRResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.CACerts) > 0 {
		for _, b := range m.CACerts {
			l = len(b)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseCertRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CSR)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovAuthservice(uint64(m.TTL))
	}
	if len(m.ServerNames) > 0 {
		for _, s := range m.ServerNames {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.RequesterName != 0 {
		n += 1 + sovAuthservice(uint64(m.RequesterName))
	}
	if m.CertificateExtensions != 0 {
		n += 1 + sovAuthservice(uint64(m.CertificateExtensions))
	}
	l = len(m.CRLEndpoint)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseCertResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.CACerts) > 0 {
		for _, b := range m.CACerts {
			l = len(b)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnowflakeJWTRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnowflakeJWTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRolesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRolesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRolesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteRoleRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFAAuthenticateChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TOTP != nil {
		l = m.TOTP.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.WebauthnChallenge != nil {
		l = m.WebauthnChallenge.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.MFARequired != 0 {
		n += 1 + sovAuthservice(uint64(m.MFARequired))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFAAuthenticateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFAAuthenticateResponse_TOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TOTP != nil {
		l = m.TOTP.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *MFAAuthenticateResponse_Webauthn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *TOTPChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TOTPResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFARegisterChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFARegisterChallenge_TOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TOTP != nil {
		l = m.TOTP.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *MFARegisterChallenge_Webauthn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *MFARegisterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MFARegisterResponse_TOTP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TOTP != nil {
		l = m.TOTP.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *MFARegisterResponse_Webauthn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *TOTPRegisterChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.PeriodSeconds != 0 {
		n += 1 + sovAuthservice(uint64(m.PeriodSeconds))
	}
	l = len(m.Algorithm)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Digits != 0 {
		n += 1 + sovAuthservice(uint64(m.Digits))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.QRCode)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TOTPRegisterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddMFADeviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddMFADeviceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteMFADeviceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteMFADeviceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteMFADeviceSyncRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.ExistingMFAResponse != nil {
		l = m.ExistingMFAResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddMFADeviceSyncRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.NewDeviceName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.NewMFAResponse != nil {
		l = m.NewMFAResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.DeviceUsage != 0 {
		n += 1 + sovAuthservice(uint64(m.DeviceUsage))
	}
	if m.ContextUser != nil {
		l = m.ContextUser.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddMFADeviceSyncResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMFADevicesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMFADevicesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserSingleUseCertsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserSingleUseCertsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsMFARequiredRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsMFARequiredRequest_KubernetesCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KubernetesCluster)
	n += 1 + l + sovAuthservice(uint64(l))
	return n
}
func (m *IsMFARequiredRequest_Database) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *IsMFARequiredRequest_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *IsMFARequiredRequest_WindowsDesktop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowsDesktop != nil {
		l = m.WindowsDesktop.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *IsMFARequiredRequest_AdminAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdminAction != nil {
		l = m.AdminAction.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *IsMFARequiredRequest_App) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *StreamSessionEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.StartIndex != 0 {
		n += 1 + sovAuthservice(uint64(m.StartIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeLogin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IsMFARequiredResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Required {
		n += 2
	}
	if m.MFARequired != 0 {
		n += 1 + sovAuthservice(uint64(m.MFARequired))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.StartDate)
	n += 1 + l + sovAuthservice(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.EndDate)
	n += 1 + l + sovAuthservice(uint64(l))
	if len(m.EventTypes) > 0 {
		for _, s := range m.EventTypes {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovAuthservice(uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSessionEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.StartDate)
	n += 1 + l + sovAuthservice(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.EndDate)
	n += 1 + l + sovAuthservice(uint64(l))
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovAuthservice(uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Events) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.LastKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.InForceOnly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteLockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplaceRemoteLocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWindowsDesktopServicesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWindowsDesktopServiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWindowsDesktopServiceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteWindowsDesktopServiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWindowsDesktopsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Desktops) > 0 {
		for _, e := range m.Desktops {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteWindowsDesktopRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsDesktopCertRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CSR)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.CRLEndpoint)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovAuthservice(uint64(m.TTL))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WindowsDesktopCertResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DesktopBootstrapScriptResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListSAMLIdPServiceProvidersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListSAMLIdPServiceProvidersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ServiceProviders) > 0 {
		for _, e := range m.ServiceProviders {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 1 + sovAuthservice(uint64(m.TotalCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSAMLIdPServiceProviderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteSAMLIdPServiceProviderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUserGroupsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUserGroupsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserGroups) > 0 {
		for _, e := range m.UserGroups {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 1 + sovAuthservice(uint64(m.TotalCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteUserGroupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CertAuthorityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CRL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CRL)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeUserAuthenticationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.NewPassword)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.NewMFARegisterResponse != nil {
		l = m.NewMFARegisterResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.NewDeviceName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.LoginIP)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeUserAuthenticationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WebSession != nil {
		l = m.WebSession.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Recovery != nil {
		l = m.Recovery.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.PrivateKeyPolicyEnabled {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartAccountRecoveryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.RecoveryCode)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.RecoverType != 0 {
		n += 1 + sovAuthservice(uint64(m.RecoverType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyAccountRecoveryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecoveryStartTokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.AuthnCred != nil {
		n += m.AuthnCred.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyAccountRecoveryRequest_Password) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Password != nil {
		l = len(m.Password)
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *VerifyAccountRecoveryRequest_MFAAuthenticateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MFAAuthenticateResponse != nil {
		l = m.MFAAuthenticateResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *CompleteAccountRecoveryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecoveryApprovedTokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.NewDeviceName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.NewAuthnCred != nil {
		n += m.NewAuthnCred.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteAccountRecoveryRequest_NewPassword) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewPassword != nil {
		l = len(m.NewPassword)
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *CompleteAccountRecoveryRequest_NewMFAResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewMFAResponse != nil {
		l = m.NewMFAResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *RecoveryCodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for _, s := range m.Codes {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovAuthservice(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAccountRecoveryCodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAccountRecoveryTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecoveryTokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAccountRecoveryCodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContextUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Passwordless) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAuthenticateChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.MFARequiredCheck != nil {
		l = m.MFARequiredCheck.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.ChallengeExtensions != nil {
		l = m.ChallengeExtensions.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAuthenticateChallengeRequest_UserCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserCredentials != nil {
		l = m.UserCredentials.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *CreateAuthenticateChallengeRequest_RecoveryStartTokenID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecoveryStartTokenID)
	n += 1 + l + sovAuthservice(uint64(l))
	return n
}
func (m *CreateAuthenticateChallengeRequest_ContextUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContextUser != nil {
		l = m.ContextUser.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *CreateAuthenticateChallengeRequest_Passwordless) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Passwordless != nil {
		l = m.Passwordless.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *CreatePrivilegeTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExistingMFAResponse != nil {
		l = m.ExistingMFAResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateRegisterChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.DeviceType != 0 {
		n += 1 + sovAuthservice(uint64(m.DeviceType))
	}
	if m.DeviceUsage != 0 {
		n += 1 + sovAuthservice(uint64(m.DeviceUsage))
	}
	if m.ExistingMFAResponse != nil {
		l = m.ExistingMFAResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaginatedResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		n += m.Resource.Size()
	}
	if len(m.Logins) > 0 {
		for _, s := range m.Logins {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.RequiresRequest {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PaginatedResource_DatabaseServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseServer != nil {
		l = m.DatabaseServer.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_AppServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppServer != nil {
		l = m.AppServer.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_WindowsDesktop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowsDesktop != nil {
		l = m.WindowsDesktop.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_KubeCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KubeCluster != nil {
		l = m.KubeCluster.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_KubernetesServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KubernetesServer != nil {
		l = m.KubernetesServer.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_WindowsDesktopService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WindowsDesktopService != nil {
		l = m.WindowsDesktopService.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_DatabaseService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatabaseService != nil {
		l = m.DatabaseService.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_UserGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserGroup != nil {
		l = m.UserGroup.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_AppServerOrSAMLIdPServiceProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppServerOrSAMLIdPServiceProvider != nil {
		l = m.AppServerOrSAMLIdPServiceProvider.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PaginatedResource_SAMLIdPServiceProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SAMLIdPServiceProvider != nil {
		l = m.SAMLIdPServiceProvider.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *ListUnifiedResourcesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + len(v) + sovAuthservice(uint64(len(v)))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	l = len(m.PredicateExpression)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.SearchKeywords) > 0 {
		for _, s := range m.SearchKeywords {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = m.SortBy.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	l = m.WindowsDesktopFilter.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	if m.UseSearchAsRoles {
		n += 2
	}
	if m.UsePreviewAsRoles {
		n += 2
	}
	if m.PinnedOnly {
		n += 2
	}
	if m.IncludeLogins {
		n += 2
	}
	if m.IncludeRequestable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUnifiedResourcesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListResourcesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + len(v) + sovAuthservice(uint64(len(v)))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	l = len(m.PredicateExpression)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.SearchKeywords) > 0 {
		for _, s := range m.SearchKeywords {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = m.SortBy.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	if m.NeedTotalCount {
		n += 2
	}
	l = m.WindowsDesktopFilter.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	if m.UseSearchAsRoles {
		n += 2
	}
	if m.UsePreviewAsRoles {
		n += 2
	}
	if m.IncludeLogins {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSSHTargetsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSSHTargetsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListResourcesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.TotalCount != 0 {
		n += 1 + sovAuthservice(uint64(m.TotalCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSessionTrackerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionTracker != nil {
		l = m.SessionTracker.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSessionTrackerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveSessionTrackerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerUpdateState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovAuthservice(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerAddParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Participant != nil {
		l = m.Participant.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerRemoveParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParticipantID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionTrackerUpdateExpiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expires != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires)
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSessionTrackerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Update != nil {
		n += m.Update.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSessionTrackerRequest_UpdateState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateState != nil {
		l = m.UpdateState.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpdateSessionTrackerRequest_AddParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddParticipant != nil {
		l = m.AddParticipant.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpdateSessionTrackerRequest_RemoveParticipant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveParticipant != nil {
		l = m.RemoveParticipant.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpdateSessionTrackerRequest_UpdateExpiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateExpiry != nil {
		l = m.UpdateExpiry.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PresenceMFAChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PresenceMFAChallengeSend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PresenceMFAChallengeSend_ChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeRequest != nil {
		l = m.ChallengeRequest.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *PresenceMFAChallengeSend_ChallengeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChallengeResponse != nil {
		l = m.ChallengeResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *GetDomainNameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainName)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterCACertResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TLSCA)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLicenseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.License)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListReleasesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Releases) > 0 {
		for _, e := range m.Releases {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetOIDCAuthRequestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSAMLAuthRequestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetGithubAuthRequestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateToken)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateOIDCConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateOIDCConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertOIDCConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSAMLConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateSAMLConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertSAMLConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateGithubConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateGithubConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertGithubConnectorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connector != nil {
		l = m.Connector.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSSODiagnosticInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthRequestKind)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AuthRequestID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SystemRoleAssertion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AssertionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.SystemRole)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SystemRoleAssertionSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.AssertionID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.SystemRoles) > 0 {
		for _, s := range m.SystemRoles {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamInventoryOneOf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamInventoryOneOf_Hello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hello != nil {
		l = m.Hello.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpstreamInventoryOneOf_Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Heartbeat != nil {
		l = m.Heartbeat.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpstreamInventoryOneOf_Pong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pong != nil {
		l = m.Pong.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpstreamInventoryOneOf_AgentMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentMetadata != nil {
		l = m.AgentMetadata.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpstreamInventoryOneOf_Goodbye) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Goodbye != nil {
		l = m.Goodbye.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *DownstreamInventoryOneOf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		n += m.Msg.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownstreamInventoryOneOf_Hello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hello != nil {
		l = m.Hello.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *DownstreamInventoryOneOf_Ping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ping != nil {
		l = m.Ping.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *DownstreamInventoryOneOf_UpdateLabels) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateLabels != nil {
		l = m.UpdateLabels.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *DownstreamInventoryPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAuthservice(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamInventoryPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovAuthservice(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamInventoryHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, s := range m.Services {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ExternalUpgrader)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ExternalUpgraderVersion)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamInventoryAgentMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OS)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.OSVersion)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.HostArchitecture)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.GlibcVersion)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if len(m.InstallMethods) > 0 {
		for _, s := range m.InstallMethods {
			l = len(s)
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.ContainerRuntime)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ContainerOrchestrator)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.CloudEnvironment)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownstreamInventoryHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Capabilities != nil {
		l = m.Capabilities.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownstreamInventoryHello_SupportedCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProxyHeartbeats {
		n += 2
	}
	if m.ProxyCleanup {
		n += 2
	}
	if m.AuthHeartbeats {
		n += 2
	}
	if m.AuthCleanup {
		n += 2
	}
	if m.NodeHeartbeats {
		n += 2
	}
	if m.NodeCleanup {
		n += 2
	}
	if m.AppHeartbeats {
		n += 2
	}
	if m.AppCleanup {
		n += 2
	}
	if m.DatabaseHeartbeats {
		n += 2
	}
	if m.DatabaseCleanup {
		n += 2
	}
	if m.DatabaseServiceHeartbeats {
		n += 2
	}
	if m.DatabaseServiceCleanup {
		n += 2
	}
	if m.WindowsDesktopHeartbeats {
		n += 2
	}
	if m.WindowsDesktopCleanup {
		n += 2
	}
	if m.WindowsDesktopServiceHeartbeats {
		n += 2
	}
	if m.WindowsDesktopServiceCleanup {
		n += 3
	}
	if m.KubernetesHeartbeats {
		n += 3
	}
	if m.KubernetesCleanup {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryUpdateLabelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovAuthservice(uint64(m.Kind))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + len(v) + sovAuthservice(uint64(len(v)))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownstreamInventoryUpdateLabels) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovAuthservice(uint64(m.Kind))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + len(v) + sovAuthservice(uint64(len(v)))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryHeartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SSHServer != nil {
		l = m.SSHServer.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.AppServer != nil {
		l = m.AppServer.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.DatabaseServer != nil {
		l = m.DatabaseServer.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpstreamInventoryGoodbye) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteResources {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Connected {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryStatusSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Connected) > 0 {
		for _, e := range m.Connected {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.InstanceCount != 0 {
		n += 1 + sovAuthservice(uint64(m.InstanceCount))
	}
	if len(m.VersionCounts) > 0 {
		for k, v := range m.VersionCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + sovAuthservice(uint64(v))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if len(m.UpgraderCounts) > 0 {
		for k, v := range m.UpgraderCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + sovAuthservice(uint64(v))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if len(m.ServiceCounts) > 0 {
		for k, v := range m.ServiceCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + sovAuthservice(uint64(v))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryConnectedServiceCountsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryConnectedServiceCounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ServiceCounts) > 0 {
		for k, v := range m.ServiceCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAuthservice(uint64(len(k))) + 1 + sovAuthservice(uint64(v))
			n += mapEntrySize + 1 + sovAuthservice(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryPingRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.ControlLog {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InventoryPingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != 0 {
		n += 1 + sovAuthservice(uint64(m.Duration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterAlertsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Alerts) > 0 {
		for _, e := range m.Alerts {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAlertAcksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAlertAcksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Acks) > 0 {
		for _, e := range m.Acks {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearAlertAcksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AlertID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertClusterAlertRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Alert.Size()
	n += 1 + l + sovAuthservice(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetConnectionDiagnosticRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendDiagnosticTraceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitUsageEventRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLicenseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListReleasesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTokenV2Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		n += m.Token.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTokenV2Request_V2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V2 != nil {
		l = m.V2.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *UpsertTokenV2Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		n += m.Token.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpsertTokenV2Request_V2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.V2 != nil {
		l = m.V2.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	return n
}
func (m *GetHeadlessAuthenticationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateHeadlessAuthenticationStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAuthservice(uint64(m.State))
	}
	if m.MfaResponse != nil {
		l = m.MfaResponse.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExportUpgradeWindowsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TeleportVersion)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.UpgraderKind)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExportUpgradeWindowsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CanonicalSchedule != nil {
		l = m.CanonicalSchedule.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.KubeControllerSchedule)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	l = len(m.SystemdUnitSchedule)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAccessRequestsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovAuthservice(uint64(m.Sort))
	}
	if m.Descending {
		n += 2
	}
	if m.Limit != 0 {
		n += 1 + sovAuthservice(uint64(m.Limit))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAccessRequestsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AccessRequests) > 0 {
		for _, e := range m.AccessRequests {
			l = e.Size()
			n += 1 + l + sovAuthservice(uint64(l))
		}
	}
	l = len(m.NextKey)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestAllowedPromotionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccessRequestID)
	if l > 0 {
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessRequestAllowedPromotionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowedPromotions != nil {
		l = m.AllowedPromotions.Size()
		n += 1 + l + sovAuthservice(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAuthservice(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuthservice(x uint64) (n int) {
	return sovAuthservice(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Watch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Watch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Watch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, types.WatchKind{})
			if err := m.Kinds[len(m.Kinds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPartialSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPartialSuccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostCertsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostCertsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostCertsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = github_com_gravitational_teleport_api_types.SystemRole(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalPrincipals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdditionalPrincipals = append(m.AdditionalPrincipals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSNames = append(m.DNSNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicTLSKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicTLSKey = append(m.PublicTLSKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicTLSKey == nil {
				m.PublicTLSKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSSHKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicSSHKey = append(m.PublicSSHKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicSSHKey == nil {
				m.PublicSSHKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rotation == nil {
				m.Rotation = &types.Rotation{}
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCache = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemRoles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemRoles = append(m.SystemRoles, github_com_gravitational_teleport_api_types.SystemRole(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemRoleAssertionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemRoleAssertionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSSHCertRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSSHCertRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSSHCertRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &types.UserV2{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &types.RoleV6{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSSHCert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSSHCert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSSHCert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCertsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCertsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCertsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteToCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteToCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessRequests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessRequests = append(m.AccessRequests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteToDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RouteToDatabase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			m.Usage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usage |= UserCertsRequest_CertUsage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteToApp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RouteToApp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleRequests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleRequests = append(m.RoleRequests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteToWindowsDesktop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RouteToWindowsDesktop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseRoleRequests", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseRoleRequests = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropAccessRequests", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropAccessRequests = append(m.DropAccessRequests, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionDiagnosticID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionDiagnosticID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterName", wireType)
			}
			m.RequesterName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequesterName |= UserCertsRequest_Requester(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MFAResponse == nil {
				m.MFAResponse = &MFAAuthenticateResponse{}
			}
			if err := m.MFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHLogin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHLogin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttestationStatement == nil {
				m.AttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.AttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			m.Purpose = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Purpose |= UserCertsRequest_CertPurpose(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHPublicKey = append(m.SSHPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SSHPublicKey == nil {
				m.SSHPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSPublicKey = append(m.TLSPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TLSPublicKey == nil {
				m.TLSPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHPublicKeyAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SSHPublicKeyAttestationStatement == nil {
				m.SSHPublicKeyAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.SSHPublicKeyAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSPublicKeyAttestationStatement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TLSPublicKeyAttestationStatement == nil {
				m.TLSPublicKeyAttestationStatement = &v1.AttestationStatement{}
			}
			if err := m.TLSPublicKeyAttestationStatement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteToDatabase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteToDatabase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteToDatabase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Database = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteToWindowsDesktop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteToWindowsDesktop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteToWindowsDesktop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WindowsDesktop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteToApp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteToApp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteToApp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSRoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWSRoleARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureIdentity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureIdentity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCPServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GCPServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSecrets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithSecrets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUsersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUsersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUsersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithSecrets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithSecrets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePasswordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePasswordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePasswordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPassword", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldPassword = append(m.OldPassword[:0], dAtA[iNdEx:postIndex]...)
			if m.OldPassword == nil {
				m.OldPassword = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPassword", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPassword = append(m.NewPassword[:0], dAtA[iNdEx:postIndex]...)
			if m.NewPassword == nil {
				m.NewPassword = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondFactorToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondFactorToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Webauthn == nil {
				m.Webauthn = &webauthn.CredentialAssertionResponse{}
			}
			if err := m.Webauthn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginDataSeq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginDataSeq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginDataSeq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PluginData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PluginData = append(m.PluginData, &types.PluginDataV3{})
			if err := m.PluginData[len(m.PluginData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestStateSetter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestStateSetter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestStateSetter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= types.RequestState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Annotations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssumeStartTime == nil {
				m.AssumeStartTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.AssumeStartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetResetPasswordTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetResetPasswordTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetResetPasswordTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateResetPasswordTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateResetPasswordTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateResetPasswordTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenewableCertsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenewableCertsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenewableCertsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerFeatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerFeatures == nil {
				m.ServerFeatures = &Features{}
			}
			if err := m.ServerFeatures.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyPublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyPublicAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBoring", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBoring = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadAllCAs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoadAllCAs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Features) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Features: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Features: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kubernetes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kubernetes = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.App = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DB", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DB = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OIDC", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OIDC = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAML", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SAML = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessControls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccessControls = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedAccessWorkflows", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvancedAccessWorkflows = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloud", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cloud = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HSM", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HSM = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desktop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desktop = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryCodes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecoveryCodes = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plugins", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Plugins = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticUpgrades", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutomaticUpgrades = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUsageBased", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUsageBased = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Assist = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceTrust", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceTrust == nil {
				m.DeviceTrust = &DeviceTrustFeature{}
			}
			if err := m.DeviceTrust.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureHiding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FeatureHiding = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessRequests == nil {
				m.AccessRequests = &AccessRequestsFeature{}
			}
			if err := m.AccessRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomTheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomTheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityGovernance", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IdentityGovernance = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessGraph", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccessGraph = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessList == nil {
				m.AccessList = &AccessListFeature{}
			}
			if err := m.AccessList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessMonitoring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessMonitoring == nil {
				m.AccessMonitoring = &AccessMonitoringFeature{}
			}
			if err := m.AccessMonitoring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductType", wireType)
			}
			m.ProductType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductType |= ProductType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &PolicyFeature{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Questionnaire", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Questionnaire = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStripeManaged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStripeManaged = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalAuditStorage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExternalAuditStorage = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportType", wireType)
			}
			m.SupportType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupportType |= SupportType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinActiveSessions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JoinActiveSessions = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobileDeviceManagement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MobileDeviceManagement = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entitlements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entitlements == nil {
				m.Entitlements = make(map[string]*EntitlementInfo)
			}
			var mapkey string
			var mapvalue *EntitlementInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAuthservice
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntitlementInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Entitlements[mapkey] = mapvalue
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessMonitoringConfigured", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccessMonitoringConfigured = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntitlementInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntitlementInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntitlementInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceTrustFeature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceTrustFeature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceTrustFeature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicesUsageLimit", wireType)
			}
			m.DevicesUsageLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevicesUsageLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestsFeature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestsFeature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestsFeature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthlyRequestLimit", wireType)
			}
			m.MonthlyRequestLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonthlyRequestLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessListFeature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessListFeature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessListFeature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateLimit", wireType)
			}
			m.CreateLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessMonitoringFeature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessMonitoringFeature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessMonitoringFeature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReportRangeLimit", wireType)
			}
			m.MaxReportRangeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReportRangeLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyFeature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyFeature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyFeature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Semaphores) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Semaphores: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Semaphores: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Semaphores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Semaphores = append(m.Semaphores, &types.SemaphoreV3{})
			if err := m.Semaphores[len(m.Semaphores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateStream{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &AuditStreamRequest_CreateStream{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResumeStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResumeStream{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &AuditStreamRequest_ResumeStream{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompleteStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompleteStream{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &AuditStreamRequest_CompleteStream{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlushAndCloseStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlushAndCloseStream{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &AuditStreamRequest_FlushAndCloseStream{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &events.OneOf{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &AuditStreamRequest_Event{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditStreamStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditStreamStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditStreamStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResumeStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResumeStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResumeStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushAndCloseStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushAndCloseStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushAndCloseStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertApplicationServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertApplicationServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertApplicationServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &types.AppServerV3{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteApplicationServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteApplicationServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteApplicationServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAllApplicationServersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAllApplicationServersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAllApplicationServersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateAppTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateAppTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateAppTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Traits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Traits == nil {
				m.Traits = make(map[string]*wrappers.StringValues)
			}
			var mapkey string
			var mapvalue *wrappers.StringValues
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAuthservice
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &wrappers.StringValues{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Traits[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateAppTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateAppTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateAppTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &types.WebSessionV2{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &types.WebSessionV2{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSnowflakeSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSnowflakeSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSnowflakeSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &types.WebSessionV2{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSAMLIdPSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSAMLIdPSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSAMLIdPSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSAMLIdPSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSAMLIdPSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSAMLIdPSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &types.WebSessionV2{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAppSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAppSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAppSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWSRoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AWSRoleARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureIdentity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureIdentity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCPServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GCPServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MFAResponse == nil {
				m.MFAResponse = &MFAAuthenticateResponse{}
			}
			if err := m.MFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAppSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAppSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAppSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &types.WebSessionV2{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSnowflakeSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSnowflakeSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSnowflakeSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenTTL", wireType)
			}
			m.TokenTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenTTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSnowflakeSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSnowflakeSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSnowflakeSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &types.WebSessionV2{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSAMLIdPSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSAMLIdPSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSAMLIdPSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SAMLSession == nil {
				m.SAMLSession = &types.SAMLSessionData{}
			}
			if err := m.SAMLSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSAMLIdPSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSAMLIdPSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSAMLIdPSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &types.WebSessionV2{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSnowflakeSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSnowflakeSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSnowflakeSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSnowflakeSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSnowflakeSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSnowflakeSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &types.WebSessionV2{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSAMLIdPSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSAMLIdPSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSAMLIdPSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSAMLIdPSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSAMLIdPSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSAMLIdPSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &types.WebSessionV2{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAppSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAppSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAppSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSnowflakeSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSnowflakeSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSnowflakeSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSAMLIdPSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSAMLIdPSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSAMLIdPSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserAppSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserAppSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserAppSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserSAMLIdPSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserSAMLIdPSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserSAMLIdPSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWebSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWebSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWebSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &types.WebSessionV2{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWebSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWebSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWebSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &types.WebSessionV2{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWebTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWebTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWebTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.WebTokenV3{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWebTokensResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWebTokensResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWebTokensResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, &types.WebTokenV3{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertKubernetesServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertKubernetesServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertKubernetesServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &types.KubernetesServerV3{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteKubernetesServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteKubernetesServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteKubernetesServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAllKubernetesServersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAllKubernetesServersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAllKubernetesServersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertDatabaseServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertDatabaseServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertDatabaseServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Server == nil {
				m.Server = &types.DatabaseServerV3{}
			}
			if err := m.Server.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDatabaseServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDatabaseServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDatabaseServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAllDatabaseServersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAllDatabaseServersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAllDatabaseServersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseServiceV1List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseServiceV1List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseServiceV1List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &types.DatabaseServiceV1{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertDatabaseServiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertDatabaseServiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertDatabaseServiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &types.DatabaseServiceV1{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAllDatabaseServicesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAllDatabaseServicesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAllDatabaseServicesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseCSRRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseCSRRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseCSRRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CSR = append(m.CSR[:0], dAtA[iNdEx:postIndex]...)
			if m.CSR == nil {
				m.CSR = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseCSRResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseCSRResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseCSRResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACerts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACerts = append(m.CACerts, make([]byte, postIndex-iNdEx))
			copy(m.CACerts[len(m.CACerts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseCertRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseCertRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseCertRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CSR = append(m.CSR[:0], dAtA[iNdEx:postIndex]...)
			if m.CSR == nil {
				m.CSR = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNames = append(m.ServerNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterName", wireType)
			}
			m.RequesterName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequesterName |= DatabaseCertRequest_Requester(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateExtensions", wireType)
			}
			m.CertificateExtensions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertificateExtensions |= DatabaseCertRequest_Extensions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRLEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CRLEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseCertResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseCertResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseCertResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACerts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACerts = append(m.CACerts, make([]byte, postIndex-iNdEx))
			copy(m.CACerts[len(m.CACerts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnowflakeJWTRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnowflakeJWTRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnowflakeJWTRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnowflakeJWTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnowflakeJWTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnowflakeJWTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRolesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRolesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRolesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &types.RoleV6{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRolesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRolesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRolesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &types.RoleFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRolesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRolesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRolesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &types.RoleV6{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &types.RoleV6{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &types.RoleV6{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &types.RoleV6{}
			}
			if err := m.Role.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRoleRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRoleRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRoleRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFAAuthenticateChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFAAuthenticateChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFAAuthenticateChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TOTP == nil {
				m.TOTP = &TOTPChallenge{}
			}
			if err := m.TOTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebauthnChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebauthnChallenge == nil {
				m.WebauthnChallenge = &webauthn.CredentialAssertion{}
			}
			if err := m.WebauthnChallenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFARequired", wireType)
			}
			m.MFARequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFARequired |= MFARequired(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFAAuthenticateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFAAuthenticateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFAAuthenticateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TOTPResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &MFAAuthenticateResponse_TOTP{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &webauthn.CredentialAssertionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &MFAAuthenticateResponse_Webauthn{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TOTPChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TOTPChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TOTPChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TOTPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TOTPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TOTPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFARegisterChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFARegisterChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFARegisterChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TOTPRegisterChallenge{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &MFARegisterChallenge_TOTP{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &webauthn.CredentialCreation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &MFARegisterChallenge_Webauthn{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFARegisterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFARegisterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFARegisterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TOTPRegisterResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &MFARegisterResponse_TOTP{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &webauthn.CredentialCreationResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &MFARegisterResponse_Webauthn{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TOTPRegisterChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TOTPRegisterChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TOTPRegisterChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodSeconds", wireType)
			}
			m.PeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodSeconds |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digits", wireType)
			}
			m.Digits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Digits |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QRCode", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QRCode = append(m.QRCode[:0], dAtA[iNdEx:postIndex]...)
			if m.QRCode == nil {
				m.QRCode = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TOTPRegisterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TOTPRegisterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TOTPRegisterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMFADeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMFADeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMFADeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMFADeviceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMFADeviceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMFADeviceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMFADeviceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMFADeviceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMFADeviceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMFADeviceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMFADeviceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMFADeviceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMFADeviceSyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMFADeviceSyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMFADeviceSyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingMFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingMFAResponse == nil {
				m.ExistingMFAResponse = &MFAAuthenticateResponse{}
			}
			if err := m.ExistingMFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMFADeviceSyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMFADeviceSyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMFADeviceSyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewMFAResponse == nil {
				m.NewMFAResponse = &MFARegisterResponse{}
			}
			if err := m.NewMFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceUsage", wireType)
			}
			m.DeviceUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceUsage |= DeviceUsage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContextUser == nil {
				m.ContextUser = &ContextUser{}
			}
			if err := m.ContextUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMFADeviceSyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMFADeviceSyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMFADeviceSyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &types.MFADevice{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMFADevicesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMFADevicesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMFADevicesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMFADevicesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMFADevicesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMFADevicesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &types.MFADevice{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSingleUseCertsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSingleUseCertsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSingleUseCertsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSingleUseCertsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSingleUseCertsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSingleUseCertsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsMFARequiredRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsMFARequiredRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsMFARequiredRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = &IsMFARequiredRequest_KubernetesCluster{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteToDatabase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &IsMFARequiredRequest_Database{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NodeLogin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &IsMFARequiredRequest_Node{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteToWindowsDesktop{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &IsMFARequiredRequest_WindowsDesktop{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdminAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &IsMFARequiredRequest_AdminAction{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteToApp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &IsMFARequiredRequest_App{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamSessionEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamSessionEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamSessionEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsMFARequiredResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsMFARequiredResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsMFARequiredResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFARequired", wireType)
			}
			m.MFARequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MFARequired |= MFARequired(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.StartDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventTypes = append(m.EventTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= Order(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSessionEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSessionEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSessionEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.StartDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= Order(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Events) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Events: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Events: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &events.OneOf{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &types.LockTarget{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InForceOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InForceOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &types.LockV2{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceRemoteLocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceRemoteLocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceRemoteLocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &types.LockV2{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWindowsDesktopServicesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWindowsDesktopServicesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWindowsDesktopServicesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &types.WindowsDesktopServiceV3{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWindowsDesktopServiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWindowsDesktopServiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWindowsDesktopServiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWindowsDesktopServiceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWindowsDesktopServiceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWindowsDesktopServiceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &types.WindowsDesktopServiceV3{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteWindowsDesktopServiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteWindowsDesktopServiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteWindowsDesktopServiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWindowsDesktopsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWindowsDesktopsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWindowsDesktopsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desktops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desktops = append(m.Desktops, &types.WindowsDesktopV3{})
			if err := m.Desktops[len(m.Desktops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteWindowsDesktopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteWindowsDesktopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteWindowsDesktopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsDesktopCertRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsDesktopCertRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsDesktopCertRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CSR", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CSR = append(m.CSR[:0], dAtA[iNdEx:postIndex]...)
			if m.CSR == nil {
				m.CSR = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRLEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CRLEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsDesktopCertResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsDesktopCertResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsDesktopCertResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DesktopBootstrapScriptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DesktopBootstrapScriptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DesktopBootstrapScriptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSAMLIdPServiceProvidersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSAMLIdPServiceProvidersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSAMLIdPServiceProvidersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSAMLIdPServiceProvidersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSAMLIdPServiceProvidersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSAMLIdPServiceProvidersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceProviders = append(m.ServiceProviders, &types.SAMLIdPServiceProviderV1{})
			if err := m.ServiceProviders[len(m.ServiceProviders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSAMLIdPServiceProviderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSAMLIdPServiceProviderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSAMLIdPServiceProviderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSAMLIdPServiceProviderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSAMLIdPServiceProviderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSAMLIdPServiceProviderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserGroupsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserGroupsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserGroupsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUserGroupsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUserGroupsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUserGroupsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, &types.UserGroupV1{})
			if err := m.UserGroups[len(m.UserGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserGroupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertAuthorityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertAuthorityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertAuthorityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = github_com_gravitational_teleport_api_types.CertAuthType(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CRL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CRL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CRL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRL", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CRL = append(m.CRL[:0], dAtA[iNdEx:postIndex]...)
			if m.CRL == nil {
				m.CRL = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeUserAuthenticationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeUserAuthenticationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeUserAuthenticationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPassword", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPassword = append(m.NewPassword[:0], dAtA[iNdEx:postIndex]...)
			if m.NewPassword == nil {
				m.NewPassword = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMFARegisterResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewMFARegisterResponse == nil {
				m.NewMFARegisterResponse = &MFARegisterResponse{}
			}
			if err := m.NewMFARegisterResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeUserAuthenticationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeUserAuthenticationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeUserAuthenticationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebSession", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebSession == nil {
				m.WebSession = &types.WebSessionV2{}
			}
			if err := m.WebSession.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recovery", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recovery == nil {
				m.Recovery = &RecoveryCodes{}
			}
			if err := m.Recovery.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyPolicyEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrivateKeyPolicyEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartAccountRecoveryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartAccountRecoveryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartAccountRecoveryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryCode", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryCode = append(m.RecoveryCode[:0], dAtA[iNdEx:postIndex]...)
			if m.RecoveryCode == nil {
				m.RecoveryCode = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoverType", wireType)
			}
			m.RecoverType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecoverType |= types.UserTokenUsage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyAccountRecoveryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyAccountRecoveryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyAccountRecoveryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryStartTokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryStartTokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.AuthnCred = &VerifyAccountRecoveryRequest_Password{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFAAuthenticateResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MFAAuthenticateResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthnCred = &VerifyAccountRecoveryRequest_MFAAuthenticateResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteAccountRecoveryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteAccountRecoveryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteAccountRecoveryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryApprovedTokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryApprovedTokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewDeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPassword", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.NewAuthnCred = &CompleteAccountRecoveryRequest_NewPassword{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MFARegisterResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NewAuthnCred = &CompleteAccountRecoveryRequest_NewMFAResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryCodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryCodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryCodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codes = append(m.Codes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAccountRecoveryCodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAccountRecoveryCodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAccountRecoveryCodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountRecoveryTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountRecoveryTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountRecoveryTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryTokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryTokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountRecoveryCodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountRecoveryCodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountRecoveryCodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContextUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Passwordless) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Passwordless: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Passwordless: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAuthenticateChallengeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAuthenticateChallengeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAuthenticateChallengeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UserCredentials{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &CreateAuthenticateChallengeRequest_UserCredentials{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryStartTokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = &CreateAuthenticateChallengeRequest_RecoveryStartTokenID{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContextUser{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &CreateAuthenticateChallengeRequest_ContextUser{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passwordless", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Passwordless{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &CreateAuthenticateChallengeRequest_Passwordless{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFARequiredCheck", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MFARequiredCheck == nil {
				m.MFARequiredCheck = &IsMFARequiredRequest{}
			}
			if err := m.MFARequiredCheck.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeExtensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChallengeExtensions == nil {
				m.ChallengeExtensions = &v11.ChallengeExtensions{}
			}
			if err := m.ChallengeExtensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePrivilegeTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePrivilegeTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePrivilegeTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingMFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingMFAResponse == nil {
				m.ExistingMFAResponse = &MFAAuthenticateResponse{}
			}
			if err := m.ExistingMFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRegisterChallengeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRegisterChallengeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRegisterChallengeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceType", wireType)
			}
			m.DeviceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceType |= DeviceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceUsage", wireType)
			}
			m.DeviceUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceUsage |= DeviceUsage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingMFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExistingMFAResponse == nil {
				m.ExistingMFAResponse = &MFAAuthenticateResponse{}
			}
			if err := m.ExistingMFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaginatedResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaginatedResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaginatedResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.DatabaseServerV3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_DatabaseServer{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.AppServerV3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_AppServer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ServerV2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_Node{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.WindowsDesktopV3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_WindowsDesktop{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeCluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.KubernetesClusterV3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_KubeCluster{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.KubernetesServerV3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_KubernetesServer{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.WindowsDesktopServiceV3{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_WindowsDesktopService{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.DatabaseServiceV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_DatabaseService{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.UserGroupV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_UserGroup{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppServerOrSAMLIdPServiceProvider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.AppServerOrSAMLIdPServiceProviderV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_AppServerOrSAMLIdPServiceProvider{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SAMLIdPServiceProvider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.SAMLIdPServiceProviderV1{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Resource = &PaginatedResource_SAMLIdPServiceProvider{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logins = append(m.Logins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiresRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequiresRequest = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUnifiedResourcesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUnifiedResourcesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUnifiedResourcesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchKeywords = append(m.SearchKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SortBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WindowsDesktopFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSearchAsRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSearchAsRoles = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePreviewAsRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePreviewAsRoles = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PinnedOnly = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeLogins", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeLogins = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeRequestable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeRequestable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUnifiedResourcesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUnifiedResourcesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUnifiedResourcesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &PaginatedResource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResourcesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResourcesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResourcesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchKeywords = append(m.SearchKeywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SortBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedTotalCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedTotalCount = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WindowsDesktopFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSearchAsRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseSearchAsRoles = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePreviewAsRoles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePreviewAsRoles = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeLogins", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeLogins = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSSHTargetsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSSHTargetsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSSHTargetsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSSHTargetsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSSHTargetsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSSHTargetsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &types.ServerV2{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResourcesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResourcesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResourcesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &PaginatedResource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSessionTrackerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSessionTrackerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSessionTrackerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionTracker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionTracker == nil {
				m.SessionTracker = &types.SessionTrackerV1{}
			}
			if err := m.SessionTracker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSessionTrackerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSessionTrackerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSessionTrackerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveSessionTrackerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveSessionTrackerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveSessionTrackerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerUpdateState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerUpdateState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerUpdateState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= types.SessionState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerAddParticipant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerAddParticipant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerAddParticipant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Participant == nil {
				m.Participant = &types.Participant{}
			}
			if err := m.Participant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerRemoveParticipant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerRemoveParticipant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerRemoveParticipant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParticipantID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTrackerUpdateExpiry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTrackerUpdateExpiry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTrackerUpdateExpiry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expires == nil {
				m.Expires = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSessionTrackerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSessionTrackerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSessionTrackerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionTrackerUpdateState{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &UpdateSessionTrackerRequest_UpdateState{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddParticipant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionTrackerAddParticipant{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &UpdateSessionTrackerRequest_AddParticipant{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveParticipant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionTrackerRemoveParticipant{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &UpdateSessionTrackerRequest_RemoveParticipant{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateExpiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SessionTrackerUpdateExpiry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &UpdateSessionTrackerRequest_UpdateExpiry{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PresenceMFAChallengeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PresenceMFAChallengeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PresenceMFAChallengeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PresenceMFAChallengeSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PresenceMFAChallengeSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PresenceMFAChallengeSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PresenceMFAChallengeRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &PresenceMFAChallengeSend_ChallengeRequest{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MFAAuthenticateResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &PresenceMFAChallengeSend_ChallengeResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDomainNameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDomainNameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDomainNameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterCACertResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterCACertResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterCACertResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSCA", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TLSCA = append(m.TLSCA[:0], dAtA[iNdEx:postIndex]...)
			if m.TLSCA == nil {
				m.TLSCA = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLicenseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLicenseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLicenseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field License", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.License = append(m.License[:0], dAtA[iNdEx:postIndex]...)
			if m.License == nil {
				m.License = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReleasesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReleasesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReleasesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Releases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Releases = append(m.Releases, &types.Release{})
			if err := m.Releases[len(m.Releases)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetOIDCAuthRequestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetOIDCAuthRequestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetOIDCAuthRequestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSAMLAuthRequestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSAMLAuthRequestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSAMLAuthRequestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGithubAuthRequestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGithubAuthRequestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGithubAuthRequestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOIDCConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOIDCConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOIDCConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.OIDCConnectorV3{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOIDCConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOIDCConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOIDCConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.OIDCConnectorV3{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertOIDCConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertOIDCConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertOIDCConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.OIDCConnectorV3{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSAMLConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSAMLConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSAMLConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.SAMLConnectorV2{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSAMLConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSAMLConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSAMLConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.SAMLConnectorV2{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertSAMLConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertSAMLConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertSAMLConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.SAMLConnectorV2{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateGithubConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateGithubConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateGithubConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.GithubConnectorV3{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGithubConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGithubConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGithubConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.GithubConnectorV3{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertGithubConnectorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertGithubConnectorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertGithubConnectorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Connector == nil {
				m.Connector = &types.GithubConnectorV3{}
			}
			if err := m.Connector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSSODiagnosticInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSSODiagnosticInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSSODiagnosticInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthRequestKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthRequestKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemRoleAssertion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemRoleAssertion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemRoleAssertion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssertionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemRole", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemRole = github_com_gravitational_teleport_api_types.SystemRole(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemRoleAssertionSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemRoleAssertionSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemRoleAssertionSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssertionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssertionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemRoles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemRoles = append(m.SystemRoles, github_com_gravitational_teleport_api_types.SystemRole(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamInventoryOneOf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamInventoryOneOf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamInventoryOneOf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpstreamInventoryHello{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &UpstreamInventoryOneOf_Hello{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InventoryHeartbeat{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &UpstreamInventoryOneOf_Heartbeat{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pong", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpstreamInventoryPong{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &UpstreamInventoryOneOf_Pong{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpstreamInventoryAgentMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &UpstreamInventoryOneOf_AgentMetadata{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goodbye", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UpstreamInventoryGoodbye{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &UpstreamInventoryOneOf_Goodbye{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownstreamInventoryOneOf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownstreamInventoryOneOf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownstreamInventoryOneOf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hello", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DownstreamInventoryHello{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &DownstreamInventoryOneOf_Hello{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DownstreamInventoryPing{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &DownstreamInventoryOneOf_Ping{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DownstreamInventoryUpdateLabels{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Msg = &DownstreamInventoryOneOf_UpdateLabels{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownstreamInventoryPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownstreamInventoryPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownstreamInventoryPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamInventoryPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamInventoryPong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamInventoryPong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamInventoryHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamInventoryHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamInventoryHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, github_com_gravitational_teleport_api_types.SystemRole(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUpgrader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUpgrader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalUpgraderVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalUpgraderVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamInventoryAgentMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamInventoryAgentMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamInventoryAgentMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OS = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OSVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OSVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostArchitecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostArchitecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlibcVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlibcVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallMethods = append(m.InstallMethods, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRuntime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerRuntime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerOrchestrator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerOrchestrator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudEnvironment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudEnvironment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownstreamInventoryHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownstreamInventoryHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownstreamInventoryHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capabilities == nil {
				m.Capabilities = &DownstreamInventoryHello_SupportedCapabilities{}
			}
			if err := m.Capabilities.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownstreamInventoryHello_SupportedCapabilities) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportedCapabilities: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportedCapabilities: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProxyHeartbeats = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ProxyCleanup = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthHeartbeats = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AuthCleanup = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeHeartbeats = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeCleanup = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppHeartbeats = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppCleanup = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DatabaseHeartbeats = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DatabaseCleanup = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseServiceHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DatabaseServiceHeartbeats = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseServiceCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DatabaseServiceCleanup = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowsDesktopHeartbeats = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowsDesktopCleanup = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopServiceHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowsDesktopServiceHeartbeats = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WindowsDesktopServiceCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WindowsDesktopServiceCleanup = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesHeartbeats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KubernetesHeartbeats = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KubernetesCleanup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryUpdateLabelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryUpdateLabelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryUpdateLabelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= LabelUpdateKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownstreamInventoryUpdateLabels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownstreamInventoryUpdateLabels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownstreamInventoryUpdateLabels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= LabelUpdateKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryHeartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryHeartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryHeartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SSHServer == nil {
				m.SSHServer = &types.ServerV2{}
			}
			if err := m.SSHServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppServer == nil {
				m.AppServer = &types.AppServerV3{}
			}
			if err := m.AppServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatabaseServer == nil {
				m.DatabaseServer = &types.DatabaseServerV3{}
			}
			if err := m.DatabaseServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamInventoryGoodbye) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamInventoryGoodbye: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamInventoryGoodbye: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteResources", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteResources = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connected = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryStatusSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryStatusSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryStatusSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connected = append(m.Connected, UpstreamInventoryHello{})
			if err := m.Connected[len(m.Connected)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceCount", wireType)
			}
			m.InstanceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VersionCounts == nil {
				m.VersionCounts = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VersionCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgraderCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgraderCounts == nil {
				m.UpgraderCounts = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UpgraderCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceCounts == nil {
				m.ServiceCounts = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceCounts[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryConnectedServiceCountsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryConnectedServiceCountsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryConnectedServiceCountsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryConnectedServiceCounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryConnectedServiceCounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryConnectedServiceCounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceCounts == nil {
				m.ServiceCounts = make(map[github_com_gravitational_teleport_api_types.SystemRole]uint64)
			}
			var mapkey github_com_gravitational_teleport_api_types.SystemRole
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthservice
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAuthservice
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = github_com_gravitational_teleport_api_types.SystemRole(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthservice
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAuthservice(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAuthservice
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceCounts[github_com_gravitational_teleport_api_types.SystemRole(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryPingRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryPingRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryPingRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlLog", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ControlLog = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventoryPingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventoryPingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventoryPingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= time.Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterAlertsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterAlertsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterAlertsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alerts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alerts = append(m.Alerts, types.ClusterAlert{})
			if err := m.Alerts[len(m.Alerts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAlertAcksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAlertAcksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAlertAcksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAlertAcksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAlertAcksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAlertAcksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acks = append(m.Acks, types.AlertAcknowledgement{})
			if err := m.Acks[len(m.Acks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearAlertAcksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearAlertAcksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearAlertAcksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlertID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertClusterAlertRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertClusterAlertRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertClusterAlertRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Alert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetConnectionDiagnosticRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetConnectionDiagnosticRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetConnectionDiagnosticRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendDiagnosticTraceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendDiagnosticTraceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendDiagnosticTraceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &types.ConnectionDiagnosticTrace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitUsageEventRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitUsageEventRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitUsageEventRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &v12.UsageEventOneOf{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLicenseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLicenseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLicenseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListReleasesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListReleasesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListReleasesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTokenV2Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTokenV2Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTokenV2Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ProvisionTokenV2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Token = &CreateTokenV2Request_V2{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertTokenV2Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertTokenV2Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertTokenV2Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.ProvisionTokenV2{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Token = &UpsertTokenV2Request_V2{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHeadlessAuthenticationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHeadlessAuthenticationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHeadlessAuthenticationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateHeadlessAuthenticationStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateHeadlessAuthenticationStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateHeadlessAuthenticationStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= types.HeadlessAuthenticationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MfaResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MfaResponse == nil {
				m.MfaResponse = &MFAAuthenticateResponse{}
			}
			if err := m.MfaResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportUpgradeWindowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportUpgradeWindowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportUpgradeWindowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeleportVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeleportVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgraderKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpgraderKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportUpgradeWindowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportUpgradeWindowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportUpgradeWindowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CanonicalSchedule == nil {
				m.CanonicalSchedule = &types.AgentUpgradeSchedule{}
			}
			if err := m.CanonicalSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeControllerSchedule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeControllerSchedule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemdUnitSchedule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemdUnitSchedule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccessRequestsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccessRequestsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccessRequestsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &types.AccessRequestFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= AccessRequestSort(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Descending = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccessRequestsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccessRequestsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccessRequestsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessRequests = append(m.AccessRequests, &types.AccessRequestV3{})
			if err := m.AccessRequests[len(m.AccessRequests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestAllowedPromotionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessRequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessRequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessRequestAllowedPromotionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessRequestAllowedPromotionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPromotions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthservice
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthservice
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllowedPromotions == nil {
				m.AllowedPromotions = &types.AccessRequestAllowedPromotions{}
			}
			if err := m.AllowedPromotions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthservice(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthservice
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthservice(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthservice
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthservice
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuthservice
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuthservice
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuthservice
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuthservice        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthservice          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuthservice = fmt.Errorf("proto: unexpected end of group")
)
