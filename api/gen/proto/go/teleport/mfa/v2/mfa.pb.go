// Copyright 2025 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: teleport/mfa/v2/mfa.proto

// This package contains MFA service definitions and messages. Although some messages are similar to those in the legacy
// packages, they are not identical and are not interchangeable because they rely on protojson serialization instead of
// gogoproto.

package mfav2

import (
	v1 "github.com/gravitational/teleport/api/gen/proto/go/teleport/header/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SessionIdentifyingPayload contains a value that uniquely identifies a user's session. It must be computed by the
// client from session state and is used to bind MFA challenges to specific sessions.
type SessionIdentifyingPayload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*SessionIdentifyingPayload_SshSessionId
	Payload       isSessionIdentifyingPayload_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionIdentifyingPayload) Reset() {
	*x = SessionIdentifyingPayload{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionIdentifyingPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionIdentifyingPayload) ProtoMessage() {}

func (x *SessionIdentifyingPayload) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionIdentifyingPayload.ProtoReflect.Descriptor instead.
func (*SessionIdentifyingPayload) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{0}
}

func (x *SessionIdentifyingPayload) GetPayload() isSessionIdentifyingPayload_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *SessionIdentifyingPayload) GetSshSessionId() []byte {
	if x != nil {
		if x, ok := x.Payload.(*SessionIdentifyingPayload_SshSessionId); ok {
			return x.SshSessionId
		}
	}
	return nil
}

type isSessionIdentifyingPayload_Payload interface {
	isSessionIdentifyingPayload_Payload()
}

type SessionIdentifyingPayload_SshSessionId struct {
	// session_id is the SSH session hash computed from SSH session state. For example, in Go this would be the value
	// from crypto/ssh#ConnMetadata.SessionID().
	SshSessionId []byte `protobuf:"bytes,1,opt,name=ssh_session_id,json=sshSessionId,proto3,oneof"`
}

func (*SessionIdentifyingPayload_SshSessionId) isSessionIdentifyingPayload_Payload() {}

// CreateChallengeRequest is the request message for CreateChallenge.
type CreateChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// payload is a value that uniquely identifies the user's session. When VerifyValidatedMFAChallenge is called, the
	// server will verify it matches the payload supplied to CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// target_cluster is the name of the target cluster where the SSH session is being established. If unset, the server
	// assumes the challenge is for the local cluster. This is used to determine where the validated challenge should be
	// replicated to for leaf clusters. It is required when the SSH session is being established in a leaf cluster.
	TargetCluster string `protobuf:"bytes,2,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	// sso_client_redirect_url should be supplied if the client supports SSO MFA checks. If unset, the server will only
	// return non-SSO challenges.
	SsoClientRedirectUrl string `protobuf:"bytes,3,opt,name=sso_client_redirect_url,json=ssoClientRedirectUrl,proto3" json:"sso_client_redirect_url,omitempty"`
	// proxy_address_for_sso is the proxy address that the user is using to connect to the Proxy. When using SSO MFA, this
	// address is required to determine which URL to redirect the user to when there are multiple options.
	ProxyAddressForSso string `protobuf:"bytes,4,opt,name=proxy_address_for_sso,json=proxyAddressForSso,proto3" json:"proxy_address_for_sso,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CreateChallengeRequest) Reset() {
	*x = CreateChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateChallengeRequest) ProtoMessage() {}

func (x *CreateChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateChallengeRequest.ProtoReflect.Descriptor instead.
func (*CreateChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{1}
}

func (x *CreateChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *CreateChallengeRequest) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

func (x *CreateChallengeRequest) GetSsoClientRedirectUrl() string {
	if x != nil {
		return x.SsoClientRedirectUrl
	}
	return ""
}

func (x *CreateChallengeRequest) GetProxyAddressForSso() string {
	if x != nil {
		return x.ProxyAddressForSso
	}
	return ""
}

// CreateChallengeResponse is the response message for CreateChallenge.
type CreateChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the unique resource name for the issued challenge generated by the server. This value should be treated as
	// an opaque identifier and used as-is in subsequent API calls.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// mfa_challenge contains the MFA challenge that the user must respond to.
	MfaChallenge  *AuthenticateChallenge `protobuf:"bytes,2,opt,name=mfa_challenge,json=mfaChallenge,proto3" json:"mfa_challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateChallengeResponse) Reset() {
	*x = CreateChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateChallengeResponse) ProtoMessage() {}

func (x *CreateChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateChallengeResponse.ProtoReflect.Descriptor instead.
func (*CreateChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{2}
}

func (x *CreateChallengeResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateChallengeResponse) GetMfaChallenge() *AuthenticateChallenge {
	if x != nil {
		return x.MfaChallenge
	}
	return nil
}

// ValidateChallengeRequest is the request message for ValidateChallenge.
type ValidateChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the validation to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// mfa_response contains the MFA challenge response provided by the user.
	MfaResponse   *AuthenticateResponse `protobuf:"bytes,2,opt,name=mfa_response,json=mfaResponse,proto3" json:"mfa_response,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateChallengeRequest) Reset() {
	*x = ValidateChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChallengeRequest) ProtoMessage() {}

func (x *ValidateChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChallengeRequest.ProtoReflect.Descriptor instead.
func (*ValidateChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{3}
}

func (x *ValidateChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ValidateChallengeRequest) GetMfaResponse() *AuthenticateResponse {
	if x != nil {
		return x.MfaResponse
	}
	return nil
}

// ValidateChallengeResponse is the response message for ValidateChallenge.
type ValidateChallengeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateChallengeResponse) Reset() {
	*x = ValidateChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChallengeResponse) ProtoMessage() {}

func (x *ValidateChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChallengeResponse.ProtoReflect.Descriptor instead.
func (*ValidateChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{4}
}

// ReplicateValidatedMFAChallengeRequest is the request message for ReplicateValidatedMFAChallenge.
type ReplicateValidatedMFAChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the upsert to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// payload is a value that uniquely identifies the user's session. This should match the payload in
	// CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// device contains information about the user's MFA device used to authenticate.
	Device *MFADevice `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,4,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	// target_cluster is the name of the destination cluster where the validated challenge should be replicated to.
	TargetCluster string `protobuf:"bytes,5,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicateValidatedMFAChallengeRequest) Reset() {
	*x = ReplicateValidatedMFAChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateValidatedMFAChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateValidatedMFAChallengeRequest) ProtoMessage() {}

func (x *ReplicateValidatedMFAChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateValidatedMFAChallengeRequest.ProtoReflect.Descriptor instead.
func (*ReplicateValidatedMFAChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{5}
}

func (x *ReplicateValidatedMFAChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ReplicateValidatedMFAChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ReplicateValidatedMFAChallengeRequest) GetDevice() *MFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *ReplicateValidatedMFAChallengeRequest) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

func (x *ReplicateValidatedMFAChallengeRequest) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

// ReplicateValidatedMFAChallengeResponse is the response message for ReplicateValidatedMFAChallenge.
type ReplicateValidatedMFAChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// replicated_challenge is the validated MFA challenge that was replicated.
	ReplicatedChallenge *ValidatedMFAChallenge `protobuf:"bytes,1,opt,name=replicated_challenge,json=replicatedChallenge,proto3" json:"replicated_challenge,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ReplicateValidatedMFAChallengeResponse) Reset() {
	*x = ReplicateValidatedMFAChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateValidatedMFAChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateValidatedMFAChallengeResponse) ProtoMessage() {}

func (x *ReplicateValidatedMFAChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateValidatedMFAChallengeResponse.ProtoReflect.Descriptor instead.
func (*ReplicateValidatedMFAChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{6}
}

func (x *ReplicateValidatedMFAChallengeResponse) GetReplicatedChallenge() *ValidatedMFAChallenge {
	if x != nil {
		return x.ReplicatedChallenge
	}
	return nil
}

// VerifyValidatedMFAChallengeRequest is the request message for VerifyValidatedMFAChallenge.
type VerifyValidatedMFAChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the retrieval to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// payload is a value that uniquely identifies the user's session. The client calling VerifyValidatedMFAChallenge MUST
	// independently compute this value from session state. The server will verify it matches the payload supplied in
	// CreateChallengeRequest to ensure the challenge is tied to the correct session.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,3,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyValidatedMFAChallengeRequest) Reset() {
	*x = VerifyValidatedMFAChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyValidatedMFAChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyValidatedMFAChallengeRequest) ProtoMessage() {}

func (x *VerifyValidatedMFAChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyValidatedMFAChallengeRequest.ProtoReflect.Descriptor instead.
func (*VerifyValidatedMFAChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{7}
}

func (x *VerifyValidatedMFAChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VerifyValidatedMFAChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *VerifyValidatedMFAChallengeRequest) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

// VerifyValidatedMFAChallengeResponse is the response message for VerifyValidatedMFAChallenge.
type VerifyValidatedMFAChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// device contains information about the user's MFA device used to authenticate.
	Device        *MFADevice `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyValidatedMFAChallengeResponse) Reset() {
	*x = VerifyValidatedMFAChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyValidatedMFAChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyValidatedMFAChallengeResponse) ProtoMessage() {}

func (x *VerifyValidatedMFAChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyValidatedMFAChallengeResponse.ProtoReflect.Descriptor instead.
func (*VerifyValidatedMFAChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{8}
}

func (x *VerifyValidatedMFAChallengeResponse) GetDevice() *MFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

// AuthenticateChallenge is a challenge for all MFA devices registered for a user.
type AuthenticateChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// webauthn_challenge contains a Webauthn credential assertion used for login/authentication ceremonies. Credential
	// assertions hold, among other information, a list of allowed credentials for the ceremony (one for each U2F or
	// Webauthn device registered by the user).
	WebauthnChallenge *CredentialAssertion `protobuf:"bytes,1,opt,name=webauthn_challenge,json=webauthnChallenge,proto3" json:"webauthn_challenge,omitempty"`
	// sso_challenge is an SSO MFA challenge. If set, the client can go to the IdP redirect URL to perform an MFA check in
	// the IdP and obtain an MFA token. This token paired with the request id can then be used as MFA verification.
	SsoChallenge  *SSOChallenge `protobuf:"bytes,2,opt,name=sso_challenge,json=ssoChallenge,proto3" json:"sso_challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticateChallenge) Reset() {
	*x = AuthenticateChallenge{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticateChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticateChallenge) ProtoMessage() {}

func (x *AuthenticateChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticateChallenge.ProtoReflect.Descriptor instead.
func (*AuthenticateChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{9}
}

func (x *AuthenticateChallenge) GetWebauthnChallenge() *CredentialAssertion {
	if x != nil {
		return x.WebauthnChallenge
	}
	return nil
}

func (x *AuthenticateChallenge) GetSsoChallenge() *SSOChallenge {
	if x != nil {
		return x.SsoChallenge
	}
	return nil
}

// AuthenticateResponse is a response to AuthenticateChallenge using one of the MFA devices registered for a user.
type AuthenticateResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Response:
	//
	//	*AuthenticateResponse_Webauthn
	//	*AuthenticateResponse_Sso
	Response      isAuthenticateResponse_Response `protobuf_oneof:"response"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticateResponse) Reset() {
	*x = AuthenticateResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticateResponse) ProtoMessage() {}

func (x *AuthenticateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticateResponse.ProtoReflect.Descriptor instead.
func (*AuthenticateResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{10}
}

func (x *AuthenticateResponse) GetResponse() isAuthenticateResponse_Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *AuthenticateResponse) GetWebauthn() *CredentialAssertionResponse {
	if x != nil {
		if x, ok := x.Response.(*AuthenticateResponse_Webauthn); ok {
			return x.Webauthn
		}
	}
	return nil
}

func (x *AuthenticateResponse) GetSso() *SSOChallengeResponse {
	if x != nil {
		if x, ok := x.Response.(*AuthenticateResponse_Sso); ok {
			return x.Sso
		}
	}
	return nil
}

type isAuthenticateResponse_Response interface {
	isAuthenticateResponse_Response()
}

type AuthenticateResponse_Webauthn struct {
	// webauthn is a response to a Webauthn challenge.
	Webauthn *CredentialAssertionResponse `protobuf:"bytes,1,opt,name=webauthn,proto3,oneof"`
}

type AuthenticateResponse_Sso struct {
	// sso is a response to an SSO challenge.
	Sso *SSOChallengeResponse `protobuf:"bytes,2,opt,name=sso,proto3,oneof"`
}

func (*AuthenticateResponse_Webauthn) isAuthenticateResponse_Response() {}

func (*AuthenticateResponse_Sso) isAuthenticateResponse_Response() {}

// SSOChallenge contains SSO auth request details to perform an SSO MFA check.
type SSOChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// redirect_url is an IdP redirect URL to initiate the SSO MFA flow.
	RedirectUrl string `protobuf:"bytes,2,opt,name=redirect_url,json=redirectUrl,proto3" json:"redirect_url,omitempty"`
	// device is the SSO device corresponding to the challenge.
	Device        *SSOMFADevice `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSOChallenge) Reset() {
	*x = SSOChallenge{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSOChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSOChallenge) ProtoMessage() {}

func (x *SSOChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSOChallenge.ProtoReflect.Descriptor instead.
func (*SSOChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{11}
}

func (x *SSOChallenge) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SSOChallenge) GetRedirectUrl() string {
	if x != nil {
		return x.RedirectUrl
	}
	return ""
}

func (x *SSOChallenge) GetDevice() *SSOMFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

// SSOChallengeResponse is a response to SSOChallenge.
type SSOChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// token is a secret token used to verify the user's SSO MFA session.
	Token         string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSOChallengeResponse) Reset() {
	*x = SSOChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSOChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSOChallengeResponse) ProtoMessage() {}

func (x *SSOChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSOChallengeResponse.ProtoReflect.Descriptor instead.
func (*SSOChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{12}
}

func (x *SSOChallengeResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SSOChallengeResponse) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

// ValidatedMFAChallenge represents a validated MFA challenge tied to a user session.
type ValidatedMFAChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The kind of resource represented.
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// Differentiates variations of the same kind. All resources should contain one, even if it is never populated.
	SubKind string `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	// The version of the resource being represented.
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Common metadata that all resources share.
	Metadata *v1.Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The validated challenge specification.
	Spec          *ValidatedMFAChallengeSpec `protobuf:"bytes,5,opt,name=spec,proto3" json:"spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatedMFAChallenge) Reset() {
	*x = ValidatedMFAChallenge{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatedMFAChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatedMFAChallenge) ProtoMessage() {}

func (x *ValidatedMFAChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatedMFAChallenge.ProtoReflect.Descriptor instead.
func (*ValidatedMFAChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{13}
}

func (x *ValidatedMFAChallenge) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetSubKind() string {
	if x != nil {
		return x.SubKind
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetMetadata() *v1.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *ValidatedMFAChallenge) GetSpec() *ValidatedMFAChallengeSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

// ValidatedMFAChallengeSpec contains the validated challenge data that is set once during creation and never modified.
type ValidatedMFAChallengeSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// payload is a value that uniquely identifies the user's session. It is the value that was supplied in
	// CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// device contains information about the user's MFA device used to authenticate.
	Device *MFADevice `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,3,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	// target_cluster is the name of the cluster where the SSH session is being established and this resource is intended
	// for.
	TargetCluster string `protobuf:"bytes,4,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatedMFAChallengeSpec) Reset() {
	*x = ValidatedMFAChallengeSpec{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatedMFAChallengeSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatedMFAChallengeSpec) ProtoMessage() {}

func (x *ValidatedMFAChallengeSpec) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatedMFAChallengeSpec.ProtoReflect.Descriptor instead.
func (*ValidatedMFAChallengeSpec) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{14}
}

func (x *ValidatedMFAChallengeSpec) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ValidatedMFAChallengeSpec) GetDevice() *MFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *ValidatedMFAChallengeSpec) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

func (x *ValidatedMFAChallengeSpec) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

// MFADevice is a multi-factor authentication device, such as a security key or an OTP app.
type MFADevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Boilerplate for implementing the Resource interface.
	Kind     string    `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	SubKind  string    `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	Version  string    `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Metadata *Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// id is a UUID of this device.
	Id       string                 `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	AddedAt  *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=added_at,json=addedAt,proto3" json:"added_at,omitempty"`
	LastUsed *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_used,json=lastUsed,proto3" json:"last_used,omitempty"`
	// Types that are valid to be assigned to Device:
	//
	//	*MFADevice_Totp
	//	*MFADevice_U2F
	//	*MFADevice_Webauthn
	//	*MFADevice_Sso
	Device        isMFADevice_Device `protobuf_oneof:"device"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MFADevice) Reset() {
	*x = MFADevice{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MFADevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MFADevice) ProtoMessage() {}

func (x *MFADevice) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MFADevice.ProtoReflect.Descriptor instead.
func (*MFADevice) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{15}
}

func (x *MFADevice) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *MFADevice) GetSubKind() string {
	if x != nil {
		return x.SubKind
	}
	return ""
}

func (x *MFADevice) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *MFADevice) GetMetadata() *Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *MFADevice) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *MFADevice) GetAddedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.AddedAt
	}
	return nil
}

func (x *MFADevice) GetLastUsed() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUsed
	}
	return nil
}

func (x *MFADevice) GetDevice() isMFADevice_Device {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *MFADevice) GetTotp() *TOTPDevice {
	if x != nil {
		if x, ok := x.Device.(*MFADevice_Totp); ok {
			return x.Totp
		}
	}
	return nil
}

func (x *MFADevice) GetU2F() *U2FDevice {
	if x != nil {
		if x, ok := x.Device.(*MFADevice_U2F); ok {
			return x.U2F
		}
	}
	return nil
}

func (x *MFADevice) GetWebauthn() *WebauthnDevice {
	if x != nil {
		if x, ok := x.Device.(*MFADevice_Webauthn); ok {
			return x.Webauthn
		}
	}
	return nil
}

func (x *MFADevice) GetSso() *SSOMFADevice {
	if x != nil {
		if x, ok := x.Device.(*MFADevice_Sso); ok {
			return x.Sso
		}
	}
	return nil
}

type isMFADevice_Device interface {
	isMFADevice_Device()
}

type MFADevice_Totp struct {
	Totp *TOTPDevice `protobuf:"bytes,8,opt,name=totp,proto3,oneof"`
}

type MFADevice_U2F struct {
	U2F *U2FDevice `protobuf:"bytes,9,opt,name=u2f,proto3,oneof"`
}

type MFADevice_Webauthn struct {
	Webauthn *WebauthnDevice `protobuf:"bytes,10,opt,name=webauthn,proto3,oneof"`
}

type MFADevice_Sso struct {
	Sso *SSOMFADevice `protobuf:"bytes,11,opt,name=sso,proto3,oneof"`
}

func (*MFADevice_Totp) isMFADevice_Device() {}

func (*MFADevice_U2F) isMFADevice_Device() {}

func (*MFADevice_Webauthn) isMFADevice_Device() {}

func (*MFADevice_Sso) isMFADevice_Device() {}

// Metadata is resource metadata
type Metadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is an object name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// description is object description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// labels is a set of labels
	Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// expires is a global expiry time header can be set on any resource in the system.
	Expires *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=expires,proto3" json:"expires,omitempty"`
	// revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not
	// alter its value but must return the revision in any updates of a resource.
	Revision      string `protobuf:"bytes,8,opt,name=revision,proto3" json:"revision,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Metadata) Reset() {
	*x = Metadata{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Metadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metadata) ProtoMessage() {}

func (x *Metadata) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metadata.ProtoReflect.Descriptor instead.
func (*Metadata) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{16}
}

func (x *Metadata) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Metadata) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *Metadata) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Metadata) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Metadata) GetExpires() *timestamppb.Timestamp {
	if x != nil {
		return x.Expires
	}
	return nil
}

func (x *Metadata) GetRevision() string {
	if x != nil {
		return x.Revision
	}
	return ""
}

// TOTPDevice holds the TOTP-specific fields of MFADevice.
type TOTPDevice struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TOTPDevice) Reset() {
	*x = TOTPDevice{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TOTPDevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TOTPDevice) ProtoMessage() {}

func (x *TOTPDevice) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TOTPDevice.ProtoReflect.Descriptor instead.
func (*TOTPDevice) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{17}
}

func (x *TOTPDevice) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// U2FDevice holds the U2F-specific fields of MFADevice.
type U2FDevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// key_handle uniquely identifies a key on a device
	KeyHandle []byte `protobuf:"bytes,1,opt,name=key_handle,json=keyHandle,proto3" json:"key_handle,omitempty"`
	// pub_key is a DER encoded ecdsa public key
	PubKey []byte `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	// counter is the latest seen value of the U2F usage counter.
	Counter       uint32 `protobuf:"varint,3,opt,name=counter,proto3" json:"counter,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *U2FDevice) Reset() {
	*x = U2FDevice{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *U2FDevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*U2FDevice) ProtoMessage() {}

func (x *U2FDevice) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use U2FDevice.ProtoReflect.Descriptor instead.
func (*U2FDevice) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{18}
}

func (x *U2FDevice) GetKeyHandle() []byte {
	if x != nil {
		return x.KeyHandle
	}
	return nil
}

func (x *U2FDevice) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *U2FDevice) GetCounter() uint32 {
	if x != nil {
		return x.Counter
	}
	return 0
}

// WebauthnDevice holds Webauthn-specific fields of MFADevice.
type WebauthnDevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// credential_id for the authenticator.
	CredentialId []byte `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// public_key_cbor encoded in CBOR format. Webauthn supports various key algorithms; CBOR encoding is used to reflect
	// those choices. See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter reference.
	PublicKeyCbor []byte `protobuf:"bytes,2,opt,name=public_key_cbor,json=publicKeyCbor,proto3" json:"public_key_cbor,omitempty"`
	// attestation_type used by the authenticator, if any.
	AttestationType string `protobuf:"bytes,3,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type,omitempty"`
	// aaguid is the globally unique identifier of the authenticator model. Zeroed for U2F devices.
	Aaguid []byte `protobuf:"bytes,4,opt,name=aaguid,proto3" json:"aaguid,omitempty"`
	// signature_counter for login operations. Actual counter values received from the authenticator are expected to be
	// higher than the previously-stored value.
	SignatureCounter uint32 `protobuf:"varint,5,opt,name=signature_counter,json=signatureCounter,proto3" json:"signature_counter,omitempty"`
	// attestation_object, as returned by the authentication during registration. Absent for legacy entries (Teleport
	// 8.x).
	AttestationObject []byte `protobuf:"bytes,6,opt,name=attestation_object,json=attestationObject,proto3" json:"attestation_object,omitempty"`
	// resident_key is true if a resident key was requested during registration. Marks passwordless-capable devices. (Note
	// that resident_key=true represents the server-side / Relying Party view of the registration process; the
	// authenticator alone can determine if a key is truly resident.)
	ResidentKey bool `protobuf:"varint,7,opt,name=resident_key,json=residentKey,proto3" json:"resident_key,omitempty"`
	// credential_rp_id used by the credential. Recorded on registration for new credentials, or on first successful
	// authentication for "old" credentials (created before the field existed). Ideally, this is always the same as the
	// configured RPID. If an RPID change does happen, this helps Teleport detect it and react accordingly.
	CredentialRpId string `protobuf:"bytes,8,opt,name=credential_rp_id,json=credentialRpId,proto3" json:"credential_rp_id,omitempty"`
	// credential_backup_eligible (Authenticator Backup Eligibility/BE bit), recorded during registration or backfill (for
	// older authenticators). https://w3c.github.io/webauthn/#authdata-flags-be
	CredentialBackupEligible *wrapperspb.BoolValue `protobuf:"bytes,9,opt,name=credential_backup_eligible,json=credentialBackupEligible,proto3" json:"credential_backup_eligible,omitempty"`
	// credential_backed_up (Authenticator Backup State/BS bit), recorded during registration or backfill (for older
	// authenticators). https://w3c.github.io/webauthn/#authdata-flags-bs
	CredentialBackedUp *wrapperspb.BoolValue `protobuf:"bytes,10,opt,name=credential_backed_up,json=credentialBackedUp,proto3" json:"credential_backed_up,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *WebauthnDevice) Reset() {
	*x = WebauthnDevice{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebauthnDevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebauthnDevice) ProtoMessage() {}

func (x *WebauthnDevice) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebauthnDevice.ProtoReflect.Descriptor instead.
func (*WebauthnDevice) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{19}
}

func (x *WebauthnDevice) GetCredentialId() []byte {
	if x != nil {
		return x.CredentialId
	}
	return nil
}

func (x *WebauthnDevice) GetPublicKeyCbor() []byte {
	if x != nil {
		return x.PublicKeyCbor
	}
	return nil
}

func (x *WebauthnDevice) GetAttestationType() string {
	if x != nil {
		return x.AttestationType
	}
	return ""
}

func (x *WebauthnDevice) GetAaguid() []byte {
	if x != nil {
		return x.Aaguid
	}
	return nil
}

func (x *WebauthnDevice) GetSignatureCounter() uint32 {
	if x != nil {
		return x.SignatureCounter
	}
	return 0
}

func (x *WebauthnDevice) GetAttestationObject() []byte {
	if x != nil {
		return x.AttestationObject
	}
	return nil
}

func (x *WebauthnDevice) GetResidentKey() bool {
	if x != nil {
		return x.ResidentKey
	}
	return false
}

func (x *WebauthnDevice) GetCredentialRpId() string {
	if x != nil {
		return x.CredentialRpId
	}
	return ""
}

func (x *WebauthnDevice) GetCredentialBackupEligible() *wrapperspb.BoolValue {
	if x != nil {
		return x.CredentialBackupEligible
	}
	return nil
}

func (x *WebauthnDevice) GetCredentialBackedUp() *wrapperspb.BoolValue {
	if x != nil {
		return x.CredentialBackedUp
	}
	return nil
}

// SSOMFADevice contains details of an SSO MFA method.
type SSOMFADevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// connector_id is the id of the SSO connector.
	ConnectorId string `protobuf:"bytes,1,opt,name=connector_id,json=connectorId,proto3" json:"connector_id,omitempty"`
	// connector_type is the type of the SSO connector.
	ConnectorType string `protobuf:"bytes,2,opt,name=connector_type,json=connectorType,proto3" json:"connector_type,omitempty"`
	// display_name is the display name of the SSO connector
	DisplayName   string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSOMFADevice) Reset() {
	*x = SSOMFADevice{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSOMFADevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSOMFADevice) ProtoMessage() {}

func (x *SSOMFADevice) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSOMFADevice.ProtoReflect.Descriptor instead.
func (*SSOMFADevice) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{20}
}

func (x *SSOMFADevice) GetConnectorId() string {
	if x != nil {
		return x.ConnectorId
	}
	return ""
}

func (x *SSOMFADevice) GetConnectorType() string {
	if x != nil {
		return x.ConnectorType
	}
	return ""
}

func (x *SSOMFADevice) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

// Credential assertion used for login ceremonies.
type CredentialAssertion struct {
	state         protoimpl.MessageState             `protogen:"open.v1"`
	PublicKey     *PublicKeyCredentialRequestOptions `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialAssertion) Reset() {
	*x = CredentialAssertion{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialAssertion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialAssertion) ProtoMessage() {}

func (x *CredentialAssertion) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialAssertion.ProtoReflect.Descriptor instead.
func (*CredentialAssertion) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{21}
}

func (x *CredentialAssertion) GetPublicKey() *PublicKeyCredentialRequestOptions {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// Request options necessary for credential assertions, aka login ceremonies. See
// https://www.w3.org/TR/webauthn-2/#dictionary-assertion-options or refer to navigator.credentials.get in your browser.
type PublicKeyCredentialRequestOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Raw challenge used for assertion.
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	// Timeout in milliseconds.
	TimeoutMs int64 `protobuf:"varint,2,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	// Relying Party ID.
	RpId string `protobuf:"bytes,3,opt,name=rp_id,json=rpId,proto3" json:"rp_id,omitempty"`
	// Allowed credentials for assertion.
	AllowCredentials []*CredentialDescriptor `protobuf:"bytes,4,rep,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
	// Extensions supplied by the Relying Party.
	Extensions *AuthenticationExtensionsClientInputs `protobuf:"bytes,5,opt,name=extensions,proto3" json:"extensions,omitempty"`
	// User verification requirement.
	UserVerification string `protobuf:"bytes,6,opt,name=user_verification,json=userVerification,proto3" json:"user_verification,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PublicKeyCredentialRequestOptions) Reset() {
	*x = PublicKeyCredentialRequestOptions{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicKeyCredentialRequestOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKeyCredentialRequestOptions) ProtoMessage() {}

func (x *PublicKeyCredentialRequestOptions) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKeyCredentialRequestOptions.ProtoReflect.Descriptor instead.
func (*PublicKeyCredentialRequestOptions) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{22}
}

func (x *PublicKeyCredentialRequestOptions) GetChallenge() []byte {
	if x != nil {
		return x.Challenge
	}
	return nil
}

func (x *PublicKeyCredentialRequestOptions) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

func (x *PublicKeyCredentialRequestOptions) GetRpId() string {
	if x != nil {
		return x.RpId
	}
	return ""
}

func (x *PublicKeyCredentialRequestOptions) GetAllowCredentials() []*CredentialDescriptor {
	if x != nil {
		return x.AllowCredentials
	}
	return nil
}

func (x *PublicKeyCredentialRequestOptions) GetExtensions() *AuthenticationExtensionsClientInputs {
	if x != nil {
		return x.Extensions
	}
	return nil
}

func (x *PublicKeyCredentialRequestOptions) GetUserVerification() string {
	if x != nil {
		return x.UserVerification
	}
	return ""
}

// Assertion response returned by the authenticator. Refer to navigator.credentials.get in your browser.
type CredentialAssertionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of the credential, usually "public-key".
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Raw Credential ID.
	RawId []byte `protobuf:"bytes,2,opt,name=raw_id,json=rawId,proto3" json:"raw_id,omitempty"`
	// Assertion response from the authenticator.
	Response *AuthenticatorAssertionResponse `protobuf:"bytes,3,opt,name=response,proto3" json:"response,omitempty"`
	// Extensions supplied by the authenticator.
	Extensions    *AuthenticationExtensionsClientOutputs `protobuf:"bytes,4,opt,name=extensions,proto3" json:"extensions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialAssertionResponse) Reset() {
	*x = CredentialAssertionResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialAssertionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialAssertionResponse) ProtoMessage() {}

func (x *CredentialAssertionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialAssertionResponse.ProtoReflect.Descriptor instead.
func (*CredentialAssertionResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{23}
}

func (x *CredentialAssertionResponse) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *CredentialAssertionResponse) GetRawId() []byte {
	if x != nil {
		return x.RawId
	}
	return nil
}

func (x *CredentialAssertionResponse) GetResponse() *AuthenticatorAssertionResponse {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *CredentialAssertionResponse) GetExtensions() *AuthenticationExtensionsClientOutputs {
	if x != nil {
		return x.Extensions
	}
	return nil
}

// Authenticator assertion response. https://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse
type AuthenticatorAssertionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Raw client data JSON, exactly as signed by the authenticator.
	// https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata.
	ClientDataJson []byte `protobuf:"bytes,1,opt,name=client_data_json,json=clientDataJson,proto3" json:"client_data_json,omitempty"`
	// Raw authenticator data, exactly as signed by the authenticator.
	// https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data.
	AuthenticatorData []byte `protobuf:"bytes,2,opt,name=authenticator_data,json=authenticatorData,proto3" json:"authenticator_data,omitempty"`
	// Raw assertion signature performed authenticatorData|clientDataJSON.
	// https://www.w3.org/TR/webauthn-2/#assertion-signature.
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// Raw user handle returned by the authenticator, if any.
	UserHandle    []byte `protobuf:"bytes,4,opt,name=user_handle,json=userHandle,proto3" json:"user_handle,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticatorAssertionResponse) Reset() {
	*x = AuthenticatorAssertionResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticatorAssertionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticatorAssertionResponse) ProtoMessage() {}

func (x *AuthenticatorAssertionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticatorAssertionResponse.ProtoReflect.Descriptor instead.
func (*AuthenticatorAssertionResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{24}
}

func (x *AuthenticatorAssertionResponse) GetClientDataJson() []byte {
	if x != nil {
		return x.ClientDataJson
	}
	return nil
}

func (x *AuthenticatorAssertionResponse) GetAuthenticatorData() []byte {
	if x != nil {
		return x.AuthenticatorData
	}
	return nil
}

func (x *AuthenticatorAssertionResponse) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *AuthenticatorAssertionResponse) GetUserHandle() []byte {
	if x != nil {
		return x.UserHandle
	}
	return nil
}

// Public key credential descriptor. https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialdescriptor.
type CredentialDescriptor struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of the credential, usually "public-key".
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Raw Credential ID.
	Id            []byte `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialDescriptor) Reset() {
	*x = CredentialDescriptor{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialDescriptor) ProtoMessage() {}

func (x *CredentialDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialDescriptor.ProtoReflect.Descriptor instead.
func (*CredentialDescriptor) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{25}
}

func (x *CredentialDescriptor) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *CredentialDescriptor) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

// Extensions supplied by the Relying Party during credential assertion or creation.
// https://www.w3.org/TR/webauthn-2/#client-extension-input
type AuthenticationExtensionsClientInputs struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// U2F application ID to be used by the authenticator, if any. Only available if using U2F compatibility mode.
	// https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// Enables the credProps extension. https://w3c.github.io/webauthn/#sctn-authenticator-credential-properties-extension
	CredProps     bool `protobuf:"varint,2,opt,name=cred_props,json=credProps,proto3" json:"cred_props,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticationExtensionsClientInputs) Reset() {
	*x = AuthenticationExtensionsClientInputs{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticationExtensionsClientInputs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticationExtensionsClientInputs) ProtoMessage() {}

func (x *AuthenticationExtensionsClientInputs) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticationExtensionsClientInputs.ProtoReflect.Descriptor instead.
func (*AuthenticationExtensionsClientInputs) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{26}
}

func (x *AuthenticationExtensionsClientInputs) GetAppId() string {
	if x != nil {
		return x.AppId
	}
	return ""
}

func (x *AuthenticationExtensionsClientInputs) GetCredProps() bool {
	if x != nil {
		return x.CredProps
	}
	return false
}

// Extensions supplied by the authenticator to the Relying Party, during credential assertion or creation.
// https://www.w3.org/TR/webauthn-2/#client-extension-output.
type AuthenticationExtensionsClientOutputs struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, the AppID extension was used by the authenticator, which changes the rpIdHash accordingly.
	// https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
	AppId bool `protobuf:"varint,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// Credential properties per credProps extension.
	// https://w3c.github.io/webauthn/#sctn-authenticator-credential-properties-extension.
	CredProps     *CredentialPropertiesOutput `protobuf:"bytes,2,opt,name=cred_props,json=credProps,proto3" json:"cred_props,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticationExtensionsClientOutputs) Reset() {
	*x = AuthenticationExtensionsClientOutputs{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticationExtensionsClientOutputs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticationExtensionsClientOutputs) ProtoMessage() {}

func (x *AuthenticationExtensionsClientOutputs) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticationExtensionsClientOutputs.ProtoReflect.Descriptor instead.
func (*AuthenticationExtensionsClientOutputs) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{27}
}

func (x *AuthenticationExtensionsClientOutputs) GetAppId() bool {
	if x != nil {
		return x.AppId
	}
	return false
}

func (x *AuthenticationExtensionsClientOutputs) GetCredProps() *CredentialPropertiesOutput {
	if x != nil {
		return x.CredProps
	}
	return nil
}

// CredentialPropertiesOutput is the output of the credProps extension.
type CredentialPropertiesOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If true, the created credential is a resident key (regardless of the AuthenticatorSelection.require_resident_key
	// value). OPTIONAL by specification.
	Rk            bool `protobuf:"varint,1,opt,name=rk,proto3" json:"rk,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CredentialPropertiesOutput) Reset() {
	*x = CredentialPropertiesOutput{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CredentialPropertiesOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CredentialPropertiesOutput) ProtoMessage() {}

func (x *CredentialPropertiesOutput) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CredentialPropertiesOutput.ProtoReflect.Descriptor instead.
func (*CredentialPropertiesOutput) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{28}
}

func (x *CredentialPropertiesOutput) GetRk() bool {
	if x != nil {
		return x.Rk
	}
	return false
}

var File_teleport_mfa_v2_mfa_proto protoreflect.FileDescriptor

const file_teleport_mfa_v2_mfa_proto_rawDesc = "" +
	"\n" +
	"\x19teleport/mfa/v2/mfa.proto\x12\x0fteleport.mfa.v2\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a!teleport/header/v1/metadata.proto\"N\n" +
	"\x19SessionIdentifyingPayload\x12&\n" +
	"\x0essh_session_id\x18\x01 \x01(\fH\x00R\fsshSessionIdB\t\n" +
	"\apayload\"\xef\x01\n" +
	"\x16CreateChallengeRequest\x12D\n" +
	"\apayload\x18\x01 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12%\n" +
	"\x0etarget_cluster\x18\x02 \x01(\tR\rtargetCluster\x125\n" +
	"\x17sso_client_redirect_url\x18\x03 \x01(\tR\x14ssoClientRedirectUrl\x121\n" +
	"\x15proxy_address_for_sso\x18\x04 \x01(\tR\x12proxyAddressForSso\"z\n" +
	"\x17CreateChallengeResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12K\n" +
	"\rmfa_challenge\x18\x02 \x01(\v2&.teleport.mfa.v2.AuthenticateChallengeR\fmfaChallenge\"x\n" +
	"\x18ValidateChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12H\n" +
	"\fmfa_response\x18\x02 \x01(\v2%.teleport.mfa.v2.AuthenticateResponseR\vmfaResponse\"\x1b\n" +
	"\x19ValidateChallengeResponse\"\x83\x02\n" +
	"%ReplicateValidatedMFAChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12D\n" +
	"\apayload\x18\x02 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x122\n" +
	"\x06device\x18\x03 \x01(\v2\x1a.teleport.mfa.v2.MFADeviceR\x06device\x12%\n" +
	"\x0esource_cluster\x18\x04 \x01(\tR\rsourceCluster\x12%\n" +
	"\x0etarget_cluster\x18\x05 \x01(\tR\rtargetCluster\"\x83\x01\n" +
	"&ReplicateValidatedMFAChallengeResponse\x12Y\n" +
	"\x14replicated_challenge\x18\x01 \x01(\v2&.teleport.mfa.v2.ValidatedMFAChallengeR\x13replicatedChallenge\"\xa5\x01\n" +
	"\"VerifyValidatedMFAChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12D\n" +
	"\apayload\x18\x02 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12%\n" +
	"\x0esource_cluster\x18\x03 \x01(\tR\rsourceCluster\"Y\n" +
	"#VerifyValidatedMFAChallengeResponse\x122\n" +
	"\x06device\x18\x01 \x01(\v2\x1a.teleport.mfa.v2.MFADeviceR\x06device\"\xb0\x01\n" +
	"\x15AuthenticateChallenge\x12S\n" +
	"\x12webauthn_challenge\x18\x01 \x01(\v2$.teleport.mfa.v2.CredentialAssertionR\x11webauthnChallenge\x12B\n" +
	"\rsso_challenge\x18\x02 \x01(\v2\x1d.teleport.mfa.v2.SSOChallengeR\fssoChallenge\"\xa9\x01\n" +
	"\x14AuthenticateResponse\x12J\n" +
	"\bwebauthn\x18\x01 \x01(\v2,.teleport.mfa.v2.CredentialAssertionResponseH\x00R\bwebauthn\x129\n" +
	"\x03sso\x18\x02 \x01(\v2%.teleport.mfa.v2.SSOChallengeResponseH\x00R\x03ssoB\n" +
	"\n" +
	"\bresponse\"\x87\x01\n" +
	"\fSSOChallenge\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12!\n" +
	"\fredirect_url\x18\x02 \x01(\tR\vredirectUrl\x125\n" +
	"\x06device\x18\x03 \x01(\v2\x1d.teleport.mfa.v2.SSOMFADeviceR\x06device\"K\n" +
	"\x14SSOChallengeResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x14\n" +
	"\x05token\x18\x02 \x01(\tR\x05token\"\xda\x01\n" +
	"\x15ValidatedMFAChallenge\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x19\n" +
	"\bsub_kind\x18\x02 \x01(\tR\asubKind\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x128\n" +
	"\bmetadata\x18\x04 \x01(\v2\x1c.teleport.header.v1.MetadataR\bmetadata\x12>\n" +
	"\x04spec\x18\x05 \x01(\v2*.teleport.mfa.v2.ValidatedMFAChallengeSpecR\x04spec\"\xe3\x01\n" +
	"\x19ValidatedMFAChallengeSpec\x12D\n" +
	"\apayload\x18\x01 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x122\n" +
	"\x06device\x18\x02 \x01(\v2\x1a.teleport.mfa.v2.MFADeviceR\x06device\x12%\n" +
	"\x0esource_cluster\x18\x03 \x01(\tR\rsourceCluster\x12%\n" +
	"\x0etarget_cluster\x18\x04 \x01(\tR\rtargetCluster\"\xea\x03\n" +
	"\tMFADevice\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x19\n" +
	"\bsub_kind\x18\x02 \x01(\tR\asubKind\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x125\n" +
	"\bmetadata\x18\x04 \x01(\v2\x19.teleport.mfa.v2.MetadataR\bmetadata\x12\x0e\n" +
	"\x02id\x18\x05 \x01(\tR\x02id\x125\n" +
	"\badded_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\aaddedAt\x127\n" +
	"\tlast_used\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\blastUsed\x121\n" +
	"\x04totp\x18\b \x01(\v2\x1b.teleport.mfa.v2.TOTPDeviceH\x00R\x04totp\x12.\n" +
	"\x03u2f\x18\t \x01(\v2\x1a.teleport.mfa.v2.U2FDeviceH\x00R\x03u2f\x12=\n" +
	"\bwebauthn\x18\n" +
	" \x01(\v2\x1f.teleport.mfa.v2.WebauthnDeviceH\x00R\bwebauthn\x121\n" +
	"\x03sso\x18\v \x01(\v2\x1d.teleport.mfa.v2.SSOMFADeviceH\x00R\x03ssoB\b\n" +
	"\x06device\"\xb4\x02\n" +
	"\bMetadata\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
	"\tnamespace\x18\x02 \x01(\tR\tnamespace\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12=\n" +
	"\x06labels\x18\x05 \x03(\v2%.teleport.mfa.v2.Metadata.LabelsEntryR\x06labels\x124\n" +
	"\aexpires\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\aexpires\x12\x1a\n" +
	"\brevision\x18\b \x01(\tR\brevision\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01J\x04\b\a\x10\bR\x02ID\"\x1e\n" +
	"\n" +
	"TOTPDevice\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\"]\n" +
	"\tU2FDevice\x12\x1d\n" +
	"\n" +
	"key_handle\x18\x01 \x01(\fR\tkeyHandle\x12\x17\n" +
	"\apub_key\x18\x02 \x01(\fR\x06pubKey\x12\x18\n" +
	"\acounter\x18\x03 \x01(\rR\acounter\"\xf1\x03\n" +
	"\x0eWebauthnDevice\x12#\n" +
	"\rcredential_id\x18\x01 \x01(\fR\fcredentialId\x12&\n" +
	"\x0fpublic_key_cbor\x18\x02 \x01(\fR\rpublicKeyCbor\x12)\n" +
	"\x10attestation_type\x18\x03 \x01(\tR\x0fattestationType\x12\x16\n" +
	"\x06aaguid\x18\x04 \x01(\fR\x06aaguid\x12+\n" +
	"\x11signature_counter\x18\x05 \x01(\rR\x10signatureCounter\x12-\n" +
	"\x12attestation_object\x18\x06 \x01(\fR\x11attestationObject\x12!\n" +
	"\fresident_key\x18\a \x01(\bR\vresidentKey\x12(\n" +
	"\x10credential_rp_id\x18\b \x01(\tR\x0ecredentialRpId\x12X\n" +
	"\x1acredential_backup_eligible\x18\t \x01(\v2\x1a.google.protobuf.BoolValueR\x18credentialBackupEligible\x12L\n" +
	"\x14credential_backed_up\x18\n" +
	" \x01(\v2\x1a.google.protobuf.BoolValueR\x12credentialBackedUp\"{\n" +
	"\fSSOMFADevice\x12!\n" +
	"\fconnector_id\x18\x01 \x01(\tR\vconnectorId\x12%\n" +
	"\x0econnector_type\x18\x02 \x01(\tR\rconnectorType\x12!\n" +
	"\fdisplay_name\x18\x03 \x01(\tR\vdisplayName\"h\n" +
	"\x13CredentialAssertion\x12Q\n" +
	"\n" +
	"public_key\x18\x01 \x01(\v22.teleport.mfa.v2.PublicKeyCredentialRequestOptionsR\tpublicKey\"\xcd\x02\n" +
	"!PublicKeyCredentialRequestOptions\x12\x1c\n" +
	"\tchallenge\x18\x01 \x01(\fR\tchallenge\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x02 \x01(\x03R\ttimeoutMs\x12\x13\n" +
	"\x05rp_id\x18\x03 \x01(\tR\x04rpId\x12R\n" +
	"\x11allow_credentials\x18\x04 \x03(\v2%.teleport.mfa.v2.CredentialDescriptorR\x10allowCredentials\x12U\n" +
	"\n" +
	"extensions\x18\x05 \x01(\v25.teleport.mfa.v2.AuthenticationExtensionsClientInputsR\n" +
	"extensions\x12+\n" +
	"\x11user_verification\x18\x06 \x01(\tR\x10userVerification\"\xed\x01\n" +
	"\x1bCredentialAssertionResponse\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x15\n" +
	"\x06raw_id\x18\x02 \x01(\fR\x05rawId\x12K\n" +
	"\bresponse\x18\x03 \x01(\v2/.teleport.mfa.v2.AuthenticatorAssertionResponseR\bresponse\x12V\n" +
	"\n" +
	"extensions\x18\x04 \x01(\v26.teleport.mfa.v2.AuthenticationExtensionsClientOutputsR\n" +
	"extensions\"\xb8\x01\n" +
	"\x1eAuthenticatorAssertionResponse\x12(\n" +
	"\x10client_data_json\x18\x01 \x01(\fR\x0eclientDataJson\x12-\n" +
	"\x12authenticator_data\x18\x02 \x01(\fR\x11authenticatorData\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12\x1f\n" +
	"\vuser_handle\x18\x04 \x01(\fR\n" +
	"userHandle\":\n" +
	"\x14CredentialDescriptor\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\fR\x02id\"\\\n" +
	"$AuthenticationExtensionsClientInputs\x12\x15\n" +
	"\x06app_id\x18\x01 \x01(\tR\x05appId\x12\x1d\n" +
	"\n" +
	"cred_props\x18\x02 \x01(\bR\tcredProps\"\x8a\x01\n" +
	"%AuthenticationExtensionsClientOutputs\x12\x15\n" +
	"\x06app_id\x18\x01 \x01(\bR\x05appId\x12J\n" +
	"\n" +
	"cred_props\x18\x02 \x01(\v2+.teleport.mfa.v2.CredentialPropertiesOutputR\tcredProps\",\n" +
	"\x1aCredentialPropertiesOutput\x12\x0e\n" +
	"\x02rk\x18\x01 \x01(\bR\x02rk2\xfd\x03\n" +
	"\n" +
	"MFAService\x12d\n" +
	"\x0fCreateChallenge\x12'.teleport.mfa.v2.CreateChallengeRequest\x1a(.teleport.mfa.v2.CreateChallengeResponse\x12j\n" +
	"\x11ValidateChallenge\x12).teleport.mfa.v2.ValidateChallengeRequest\x1a*.teleport.mfa.v2.ValidateChallengeResponse\x12\x91\x01\n" +
	"\x1eReplicateValidatedMFAChallenge\x126.teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest\x1a7.teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse\x12\x88\x01\n" +
	"\x1bVerifyValidatedMFAChallenge\x123.teleport.mfa.v2.VerifyValidatedMFAChallengeRequest\x1a4.teleport.mfa.v2.VerifyValidatedMFAChallengeResponseBJZHgithub.com/gravitational/teleport/api/gen/proto/go/teleport/mfa/v2;mfav2b\x06proto3"

var (
	file_teleport_mfa_v2_mfa_proto_rawDescOnce sync.Once
	file_teleport_mfa_v2_mfa_proto_rawDescData []byte
)

func file_teleport_mfa_v2_mfa_proto_rawDescGZIP() []byte {
	file_teleport_mfa_v2_mfa_proto_rawDescOnce.Do(func() {
		file_teleport_mfa_v2_mfa_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_teleport_mfa_v2_mfa_proto_rawDesc), len(file_teleport_mfa_v2_mfa_proto_rawDesc)))
	})
	return file_teleport_mfa_v2_mfa_proto_rawDescData
}

var file_teleport_mfa_v2_mfa_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_teleport_mfa_v2_mfa_proto_goTypes = []any{
	(*SessionIdentifyingPayload)(nil),              // 0: teleport.mfa.v2.SessionIdentifyingPayload
	(*CreateChallengeRequest)(nil),                 // 1: teleport.mfa.v2.CreateChallengeRequest
	(*CreateChallengeResponse)(nil),                // 2: teleport.mfa.v2.CreateChallengeResponse
	(*ValidateChallengeRequest)(nil),               // 3: teleport.mfa.v2.ValidateChallengeRequest
	(*ValidateChallengeResponse)(nil),              // 4: teleport.mfa.v2.ValidateChallengeResponse
	(*ReplicateValidatedMFAChallengeRequest)(nil),  // 5: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest
	(*ReplicateValidatedMFAChallengeResponse)(nil), // 6: teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse
	(*VerifyValidatedMFAChallengeRequest)(nil),     // 7: teleport.mfa.v2.VerifyValidatedMFAChallengeRequest
	(*VerifyValidatedMFAChallengeResponse)(nil),    // 8: teleport.mfa.v2.VerifyValidatedMFAChallengeResponse
	(*AuthenticateChallenge)(nil),                  // 9: teleport.mfa.v2.AuthenticateChallenge
	(*AuthenticateResponse)(nil),                   // 10: teleport.mfa.v2.AuthenticateResponse
	(*SSOChallenge)(nil),                           // 11: teleport.mfa.v2.SSOChallenge
	(*SSOChallengeResponse)(nil),                   // 12: teleport.mfa.v2.SSOChallengeResponse
	(*ValidatedMFAChallenge)(nil),                  // 13: teleport.mfa.v2.ValidatedMFAChallenge
	(*ValidatedMFAChallengeSpec)(nil),              // 14: teleport.mfa.v2.ValidatedMFAChallengeSpec
	(*MFADevice)(nil),                              // 15: teleport.mfa.v2.MFADevice
	(*Metadata)(nil),                               // 16: teleport.mfa.v2.Metadata
	(*TOTPDevice)(nil),                             // 17: teleport.mfa.v2.TOTPDevice
	(*U2FDevice)(nil),                              // 18: teleport.mfa.v2.U2FDevice
	(*WebauthnDevice)(nil),                         // 19: teleport.mfa.v2.WebauthnDevice
	(*SSOMFADevice)(nil),                           // 20: teleport.mfa.v2.SSOMFADevice
	(*CredentialAssertion)(nil),                    // 21: teleport.mfa.v2.CredentialAssertion
	(*PublicKeyCredentialRequestOptions)(nil),      // 22: teleport.mfa.v2.PublicKeyCredentialRequestOptions
	(*CredentialAssertionResponse)(nil),            // 23: teleport.mfa.v2.CredentialAssertionResponse
	(*AuthenticatorAssertionResponse)(nil),         // 24: teleport.mfa.v2.AuthenticatorAssertionResponse
	(*CredentialDescriptor)(nil),                   // 25: teleport.mfa.v2.CredentialDescriptor
	(*AuthenticationExtensionsClientInputs)(nil),   // 26: teleport.mfa.v2.AuthenticationExtensionsClientInputs
	(*AuthenticationExtensionsClientOutputs)(nil),  // 27: teleport.mfa.v2.AuthenticationExtensionsClientOutputs
	(*CredentialPropertiesOutput)(nil),             // 28: teleport.mfa.v2.CredentialPropertiesOutput
	nil,                                            // 29: teleport.mfa.v2.Metadata.LabelsEntry
	(*v1.Metadata)(nil),                            // 30: teleport.header.v1.Metadata
	(*timestamppb.Timestamp)(nil),                  // 31: google.protobuf.Timestamp
	(*wrapperspb.BoolValue)(nil),                   // 32: google.protobuf.BoolValue
}
var file_teleport_mfa_v2_mfa_proto_depIdxs = []int32{
	0,  // 0: teleport.mfa.v2.CreateChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	9,  // 1: teleport.mfa.v2.CreateChallengeResponse.mfa_challenge:type_name -> teleport.mfa.v2.AuthenticateChallenge
	10, // 2: teleport.mfa.v2.ValidateChallengeRequest.mfa_response:type_name -> teleport.mfa.v2.AuthenticateResponse
	0,  // 3: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 4: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest.device:type_name -> teleport.mfa.v2.MFADevice
	13, // 5: teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse.replicated_challenge:type_name -> teleport.mfa.v2.ValidatedMFAChallenge
	0,  // 6: teleport.mfa.v2.VerifyValidatedMFAChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 7: teleport.mfa.v2.VerifyValidatedMFAChallengeResponse.device:type_name -> teleport.mfa.v2.MFADevice
	21, // 8: teleport.mfa.v2.AuthenticateChallenge.webauthn_challenge:type_name -> teleport.mfa.v2.CredentialAssertion
	11, // 9: teleport.mfa.v2.AuthenticateChallenge.sso_challenge:type_name -> teleport.mfa.v2.SSOChallenge
	23, // 10: teleport.mfa.v2.AuthenticateResponse.webauthn:type_name -> teleport.mfa.v2.CredentialAssertionResponse
	12, // 11: teleport.mfa.v2.AuthenticateResponse.sso:type_name -> teleport.mfa.v2.SSOChallengeResponse
	20, // 12: teleport.mfa.v2.SSOChallenge.device:type_name -> teleport.mfa.v2.SSOMFADevice
	30, // 13: teleport.mfa.v2.ValidatedMFAChallenge.metadata:type_name -> teleport.header.v1.Metadata
	14, // 14: teleport.mfa.v2.ValidatedMFAChallenge.spec:type_name -> teleport.mfa.v2.ValidatedMFAChallengeSpec
	0,  // 15: teleport.mfa.v2.ValidatedMFAChallengeSpec.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 16: teleport.mfa.v2.ValidatedMFAChallengeSpec.device:type_name -> teleport.mfa.v2.MFADevice
	16, // 17: teleport.mfa.v2.MFADevice.metadata:type_name -> teleport.mfa.v2.Metadata
	31, // 18: teleport.mfa.v2.MFADevice.added_at:type_name -> google.protobuf.Timestamp
	31, // 19: teleport.mfa.v2.MFADevice.last_used:type_name -> google.protobuf.Timestamp
	17, // 20: teleport.mfa.v2.MFADevice.totp:type_name -> teleport.mfa.v2.TOTPDevice
	18, // 21: teleport.mfa.v2.MFADevice.u2f:type_name -> teleport.mfa.v2.U2FDevice
	19, // 22: teleport.mfa.v2.MFADevice.webauthn:type_name -> teleport.mfa.v2.WebauthnDevice
	20, // 23: teleport.mfa.v2.MFADevice.sso:type_name -> teleport.mfa.v2.SSOMFADevice
	29, // 24: teleport.mfa.v2.Metadata.labels:type_name -> teleport.mfa.v2.Metadata.LabelsEntry
	31, // 25: teleport.mfa.v2.Metadata.expires:type_name -> google.protobuf.Timestamp
	32, // 26: teleport.mfa.v2.WebauthnDevice.credential_backup_eligible:type_name -> google.protobuf.BoolValue
	32, // 27: teleport.mfa.v2.WebauthnDevice.credential_backed_up:type_name -> google.protobuf.BoolValue
	22, // 28: teleport.mfa.v2.CredentialAssertion.public_key:type_name -> teleport.mfa.v2.PublicKeyCredentialRequestOptions
	25, // 29: teleport.mfa.v2.PublicKeyCredentialRequestOptions.allow_credentials:type_name -> teleport.mfa.v2.CredentialDescriptor
	26, // 30: teleport.mfa.v2.PublicKeyCredentialRequestOptions.extensions:type_name -> teleport.mfa.v2.AuthenticationExtensionsClientInputs
	24, // 31: teleport.mfa.v2.CredentialAssertionResponse.response:type_name -> teleport.mfa.v2.AuthenticatorAssertionResponse
	27, // 32: teleport.mfa.v2.CredentialAssertionResponse.extensions:type_name -> teleport.mfa.v2.AuthenticationExtensionsClientOutputs
	28, // 33: teleport.mfa.v2.AuthenticationExtensionsClientOutputs.cred_props:type_name -> teleport.mfa.v2.CredentialPropertiesOutput
	1,  // 34: teleport.mfa.v2.MFAService.CreateChallenge:input_type -> teleport.mfa.v2.CreateChallengeRequest
	3,  // 35: teleport.mfa.v2.MFAService.ValidateChallenge:input_type -> teleport.mfa.v2.ValidateChallengeRequest
	5,  // 36: teleport.mfa.v2.MFAService.ReplicateValidatedMFAChallenge:input_type -> teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest
	7,  // 37: teleport.mfa.v2.MFAService.VerifyValidatedMFAChallenge:input_type -> teleport.mfa.v2.VerifyValidatedMFAChallengeRequest
	2,  // 38: teleport.mfa.v2.MFAService.CreateChallenge:output_type -> teleport.mfa.v2.CreateChallengeResponse
	4,  // 39: teleport.mfa.v2.MFAService.ValidateChallenge:output_type -> teleport.mfa.v2.ValidateChallengeResponse
	6,  // 40: teleport.mfa.v2.MFAService.ReplicateValidatedMFAChallenge:output_type -> teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse
	8,  // 41: teleport.mfa.v2.MFAService.VerifyValidatedMFAChallenge:output_type -> teleport.mfa.v2.VerifyValidatedMFAChallengeResponse
	38, // [38:42] is the sub-list for method output_type
	34, // [34:38] is the sub-list for method input_type
	34, // [34:34] is the sub-list for extension type_name
	34, // [34:34] is the sub-list for extension extendee
	0,  // [0:34] is the sub-list for field type_name
}

func init() { file_teleport_mfa_v2_mfa_proto_init() }
func file_teleport_mfa_v2_mfa_proto_init() {
	if File_teleport_mfa_v2_mfa_proto != nil {
		return
	}
	file_teleport_mfa_v2_mfa_proto_msgTypes[0].OneofWrappers = []any{
		(*SessionIdentifyingPayload_SshSessionId)(nil),
	}
	file_teleport_mfa_v2_mfa_proto_msgTypes[10].OneofWrappers = []any{
		(*AuthenticateResponse_Webauthn)(nil),
		(*AuthenticateResponse_Sso)(nil),
	}
	file_teleport_mfa_v2_mfa_proto_msgTypes[15].OneofWrappers = []any{
		(*MFADevice_Totp)(nil),
		(*MFADevice_U2F)(nil),
		(*MFADevice_Webauthn)(nil),
		(*MFADevice_Sso)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_teleport_mfa_v2_mfa_proto_rawDesc), len(file_teleport_mfa_v2_mfa_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_teleport_mfa_v2_mfa_proto_goTypes,
		DependencyIndexes: file_teleport_mfa_v2_mfa_proto_depIdxs,
		MessageInfos:      file_teleport_mfa_v2_mfa_proto_msgTypes,
	}.Build()
	File_teleport_mfa_v2_mfa_proto = out.File
	file_teleport_mfa_v2_mfa_proto_goTypes = nil
	file_teleport_mfa_v2_mfa_proto_depIdxs = nil
}
