// Copyright 2025 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: teleport/mfa/v2/mfa.proto

// This package contains MFA service definitions and messages. Although some messages are similar to those in the legacy
// packages, they are not identical and are not interchangeable because they rely on protojson serialization instead of
// gogoproto.

package mfav2

import (
	v11 "github.com/gravitational/teleport/api/gen/proto/go/teleport/header/v1"
	v1 "github.com/gravitational/teleport/api/gen/proto/go/teleport/webauthn/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SessionIdentifyingPayload contains a value that uniquely identifies a user's session. It must be computed by the
// client from session state and is used to bind MFA challenges to specific sessions.
type SessionIdentifyingPayload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*SessionIdentifyingPayload_SshSessionId
	Payload       isSessionIdentifyingPayload_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionIdentifyingPayload) Reset() {
	*x = SessionIdentifyingPayload{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionIdentifyingPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionIdentifyingPayload) ProtoMessage() {}

func (x *SessionIdentifyingPayload) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionIdentifyingPayload.ProtoReflect.Descriptor instead.
func (*SessionIdentifyingPayload) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{0}
}

func (x *SessionIdentifyingPayload) GetPayload() isSessionIdentifyingPayload_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *SessionIdentifyingPayload) GetSshSessionId() []byte {
	if x != nil {
		if x, ok := x.Payload.(*SessionIdentifyingPayload_SshSessionId); ok {
			return x.SshSessionId
		}
	}
	return nil
}

type isSessionIdentifyingPayload_Payload interface {
	isSessionIdentifyingPayload_Payload()
}

type SessionIdentifyingPayload_SshSessionId struct {
	// session_id is the SSH session hash computed from SSH session state. For example, in Go this would be the value
	// from crypto/ssh#ConnMetadata.SessionID().
	SshSessionId []byte `protobuf:"bytes,1,opt,name=ssh_session_id,json=sshSessionId,proto3,oneof"`
}

func (*SessionIdentifyingPayload_SshSessionId) isSessionIdentifyingPayload_Payload() {}

// CreateChallengeRequest is the request message for CreateChallenge.
type CreateChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// payload is a value that uniquely identifies the user's session. When VerifyValidatedMFAChallenge is called, the
	// server will verify it matches the payload supplied to CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// target_cluster is the name of the target cluster where the SSH session is being established. If unset, the server
	// assumes the challenge is for the local cluster. This is used to determine where the validated challenge should be
	// replicated to for leaf clusters. It is required when the SSH session is being established in a leaf cluster.
	TargetCluster string `protobuf:"bytes,2,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	// sso_client_redirect_url should be supplied if the client supports SSO MFA checks. If unset, the server will only
	// return non-SSO challenges.
	SsoClientRedirectUrl string `protobuf:"bytes,3,opt,name=sso_client_redirect_url,json=ssoClientRedirectUrl,proto3" json:"sso_client_redirect_url,omitempty"`
	// proxy_address_for_sso is the proxy address that the user is using to connect to the Proxy. When using SSO MFA, this
	// address is required to determine which URL to redirect the user to when there are multiple options.
	ProxyAddressForSso string `protobuf:"bytes,4,opt,name=proxy_address_for_sso,json=proxyAddressForSso,proto3" json:"proxy_address_for_sso,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CreateChallengeRequest) Reset() {
	*x = CreateChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateChallengeRequest) ProtoMessage() {}

func (x *CreateChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateChallengeRequest.ProtoReflect.Descriptor instead.
func (*CreateChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{1}
}

func (x *CreateChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *CreateChallengeRequest) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

func (x *CreateChallengeRequest) GetSsoClientRedirectUrl() string {
	if x != nil {
		return x.SsoClientRedirectUrl
	}
	return ""
}

func (x *CreateChallengeRequest) GetProxyAddressForSso() string {
	if x != nil {
		return x.ProxyAddressForSso
	}
	return ""
}

// CreateChallengeResponse is the response message for CreateChallenge.
type CreateChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the unique resource name for the issued challenge generated by the server. This value should be treated as
	// an opaque identifier and used as-is in subsequent API calls.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// mfa_challenge contains the MFA challenge that the user must respond to.
	MfaChallenge  *AuthenticateChallenge `protobuf:"bytes,2,opt,name=mfa_challenge,json=mfaChallenge,proto3" json:"mfa_challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateChallengeResponse) Reset() {
	*x = CreateChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateChallengeResponse) ProtoMessage() {}

func (x *CreateChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateChallengeResponse.ProtoReflect.Descriptor instead.
func (*CreateChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{2}
}

func (x *CreateChallengeResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateChallengeResponse) GetMfaChallenge() *AuthenticateChallenge {
	if x != nil {
		return x.MfaChallenge
	}
	return nil
}

// ValidateChallengeRequest is the request message for ValidateChallenge.
type ValidateChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the validation to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// mfa_response contains the MFA challenge response provided by the user.
	MfaResponse   *AuthenticateResponse `protobuf:"bytes,2,opt,name=mfa_response,json=mfaResponse,proto3" json:"mfa_response,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateChallengeRequest) Reset() {
	*x = ValidateChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChallengeRequest) ProtoMessage() {}

func (x *ValidateChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChallengeRequest.ProtoReflect.Descriptor instead.
func (*ValidateChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{3}
}

func (x *ValidateChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ValidateChallengeRequest) GetMfaResponse() *AuthenticateResponse {
	if x != nil {
		return x.MfaResponse
	}
	return nil
}

// ValidateChallengeResponse is the response message for ValidateChallenge.
type ValidateChallengeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateChallengeResponse) Reset() {
	*x = ValidateChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChallengeResponse) ProtoMessage() {}

func (x *ValidateChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChallengeResponse.ProtoReflect.Descriptor instead.
func (*ValidateChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{4}
}

// ReplicateValidatedMFAChallengeRequest is the request message for ReplicateValidatedMFAChallenge.
type ReplicateValidatedMFAChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the upsert to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// payload is a value that uniquely identifies the user's session. This should match the payload in
	// CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// device contains information about the user's MFA device used to authenticate.
	Device *Device `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,4,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	// target_cluster is the name of the destination cluster where the validated challenge should be replicated to.
	TargetCluster string `protobuf:"bytes,5,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicateValidatedMFAChallengeRequest) Reset() {
	*x = ReplicateValidatedMFAChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateValidatedMFAChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateValidatedMFAChallengeRequest) ProtoMessage() {}

func (x *ReplicateValidatedMFAChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateValidatedMFAChallengeRequest.ProtoReflect.Descriptor instead.
func (*ReplicateValidatedMFAChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{5}
}

func (x *ReplicateValidatedMFAChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ReplicateValidatedMFAChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ReplicateValidatedMFAChallengeRequest) GetDevice() *Device {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *ReplicateValidatedMFAChallengeRequest) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

func (x *ReplicateValidatedMFAChallengeRequest) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

// ReplicateValidatedMFAChallengeResponse is the response message for ReplicateValidatedMFAChallenge.
type ReplicateValidatedMFAChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// replicated_challenge is the validated MFA challenge that was replicated.
	ReplicatedChallenge *ValidatedMFAChallenge `protobuf:"bytes,1,opt,name=replicated_challenge,json=replicatedChallenge,proto3" json:"replicated_challenge,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ReplicateValidatedMFAChallengeResponse) Reset() {
	*x = ReplicateValidatedMFAChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateValidatedMFAChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateValidatedMFAChallengeResponse) ProtoMessage() {}

func (x *ReplicateValidatedMFAChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateValidatedMFAChallengeResponse.ProtoReflect.Descriptor instead.
func (*ReplicateValidatedMFAChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{6}
}

func (x *ReplicateValidatedMFAChallengeResponse) GetReplicatedChallenge() *ValidatedMFAChallenge {
	if x != nil {
		return x.ReplicatedChallenge
	}
	return nil
}

// VerifyValidatedMFAChallengeRequest is the request message for VerifyValidatedMFAChallenge.
type VerifyValidatedMFAChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the retrieval to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// payload is a value that uniquely identifies the user's session. The client calling VerifyValidatedMFAChallenge MUST
	// independently compute this value from session state. The server will verify it matches the payload supplied in
	// CreateChallengeRequest to ensure the challenge is tied to the correct session.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,3,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyValidatedMFAChallengeRequest) Reset() {
	*x = VerifyValidatedMFAChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyValidatedMFAChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyValidatedMFAChallengeRequest) ProtoMessage() {}

func (x *VerifyValidatedMFAChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyValidatedMFAChallengeRequest.ProtoReflect.Descriptor instead.
func (*VerifyValidatedMFAChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{7}
}

func (x *VerifyValidatedMFAChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VerifyValidatedMFAChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *VerifyValidatedMFAChallengeRequest) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

// VerifyValidatedMFAChallengeResponse is the response message for VerifyValidatedMFAChallenge.
type VerifyValidatedMFAChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// device contains information about the user's MFA device used to authenticate.
	Device        *Device `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyValidatedMFAChallengeResponse) Reset() {
	*x = VerifyValidatedMFAChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyValidatedMFAChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyValidatedMFAChallengeResponse) ProtoMessage() {}

func (x *VerifyValidatedMFAChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyValidatedMFAChallengeResponse.ProtoReflect.Descriptor instead.
func (*VerifyValidatedMFAChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{8}
}

func (x *VerifyValidatedMFAChallengeResponse) GetDevice() *Device {
	if x != nil {
		return x.Device
	}
	return nil
}

// AuthenticateChallenge is a challenge for all MFA devices registered for a user.
type AuthenticateChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// webauthn_challenge contains a Webauthn credential assertion used for login/authentication ceremonies. Credential
	// assertions hold, among other information, a list of allowed credentials for the ceremony (one for each U2F or
	// Webauthn device registered by the user).
	WebauthnChallenge *v1.CredentialAssertion `protobuf:"bytes,1,opt,name=webauthn_challenge,json=webauthnChallenge,proto3" json:"webauthn_challenge,omitempty"`
	// sso_challenge is an SSO MFA challenge. If set, the client can go to the IdP redirect URL to perform an MFA check in
	// the IdP and obtain an MFA token. This token paired with the request id can then be used as MFA verification.
	SsoChallenge  *SSOChallenge `protobuf:"bytes,2,opt,name=sso_challenge,json=ssoChallenge,proto3" json:"sso_challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticateChallenge) Reset() {
	*x = AuthenticateChallenge{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticateChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticateChallenge) ProtoMessage() {}

func (x *AuthenticateChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticateChallenge.ProtoReflect.Descriptor instead.
func (*AuthenticateChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{9}
}

func (x *AuthenticateChallenge) GetWebauthnChallenge() *v1.CredentialAssertion {
	if x != nil {
		return x.WebauthnChallenge
	}
	return nil
}

func (x *AuthenticateChallenge) GetSsoChallenge() *SSOChallenge {
	if x != nil {
		return x.SsoChallenge
	}
	return nil
}

// AuthenticateResponse is a response to AuthenticateChallenge using one of the MFA devices registered for a user.
type AuthenticateResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Response:
	//
	//	*AuthenticateResponse_Webauthn
	//	*AuthenticateResponse_Sso
	Response      isAuthenticateResponse_Response `protobuf_oneof:"response"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticateResponse) Reset() {
	*x = AuthenticateResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticateResponse) ProtoMessage() {}

func (x *AuthenticateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticateResponse.ProtoReflect.Descriptor instead.
func (*AuthenticateResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{10}
}

func (x *AuthenticateResponse) GetResponse() isAuthenticateResponse_Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *AuthenticateResponse) GetWebauthn() *v1.CredentialAssertionResponse {
	if x != nil {
		if x, ok := x.Response.(*AuthenticateResponse_Webauthn); ok {
			return x.Webauthn
		}
	}
	return nil
}

func (x *AuthenticateResponse) GetSso() *SSOChallengeResponse {
	if x != nil {
		if x, ok := x.Response.(*AuthenticateResponse_Sso); ok {
			return x.Sso
		}
	}
	return nil
}

type isAuthenticateResponse_Response interface {
	isAuthenticateResponse_Response()
}

type AuthenticateResponse_Webauthn struct {
	// webauthn is a response to a Webauthn challenge.
	Webauthn *v1.CredentialAssertionResponse `protobuf:"bytes,1,opt,name=webauthn,proto3,oneof"`
}

type AuthenticateResponse_Sso struct {
	// sso is a response to an SSO challenge.
	Sso *SSOChallengeResponse `protobuf:"bytes,2,opt,name=sso,proto3,oneof"`
}

func (*AuthenticateResponse_Webauthn) isAuthenticateResponse_Response() {}

func (*AuthenticateResponse_Sso) isAuthenticateResponse_Response() {}

// SSOChallenge contains SSO auth request details to perform an SSO MFA check.
type SSOChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// redirect_url is an IdP redirect URL to initiate the SSO MFA flow.
	RedirectUrl string `protobuf:"bytes,2,opt,name=redirect_url,json=redirectUrl,proto3" json:"redirect_url,omitempty"`
	// device is the SSO device corresponding to the challenge.
	Device        *SSODevice `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSOChallenge) Reset() {
	*x = SSOChallenge{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSOChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSOChallenge) ProtoMessage() {}

func (x *SSOChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSOChallenge.ProtoReflect.Descriptor instead.
func (*SSOChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{11}
}

func (x *SSOChallenge) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SSOChallenge) GetRedirectUrl() string {
	if x != nil {
		return x.RedirectUrl
	}
	return ""
}

func (x *SSOChallenge) GetDevice() *SSODevice {
	if x != nil {
		return x.Device
	}
	return nil
}

// SSOChallengeResponse is a response to SSOChallenge.
type SSOChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// token is a secret token used to verify the user's SSO MFA session.
	Token         string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSOChallengeResponse) Reset() {
	*x = SSOChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSOChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSOChallengeResponse) ProtoMessage() {}

func (x *SSOChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSOChallengeResponse.ProtoReflect.Descriptor instead.
func (*SSOChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{12}
}

func (x *SSOChallengeResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SSOChallengeResponse) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

// ValidatedMFAChallenge represents a validated MFA challenge tied to a user session.
type ValidatedMFAChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The kind of resource represented.
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// Differentiates variations of the same kind. All resources should contain one, even if it is never populated.
	SubKind string `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	// The version of the resource being represented.
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Common metadata that all resources share.
	Metadata *v11.Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The validated challenge specification.
	Spec          *ValidatedMFAChallengeSpec `protobuf:"bytes,5,opt,name=spec,proto3" json:"spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatedMFAChallenge) Reset() {
	*x = ValidatedMFAChallenge{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatedMFAChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatedMFAChallenge) ProtoMessage() {}

func (x *ValidatedMFAChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatedMFAChallenge.ProtoReflect.Descriptor instead.
func (*ValidatedMFAChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{13}
}

func (x *ValidatedMFAChallenge) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetSubKind() string {
	if x != nil {
		return x.SubKind
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetMetadata() *v11.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *ValidatedMFAChallenge) GetSpec() *ValidatedMFAChallengeSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

// ValidatedMFAChallengeSpec contains the validated challenge data that is set once during creation and never modified.
type ValidatedMFAChallengeSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// payload is a value that uniquely identifies the user's session. It is the value that was supplied in
	// CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// device contains information about the user's MFA device used to authenticate.
	Device *Device `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,3,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	// target_cluster is the name of the cluster where the SSH session is being established and this resource is intended
	// for.
	TargetCluster string `protobuf:"bytes,4,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatedMFAChallengeSpec) Reset() {
	*x = ValidatedMFAChallengeSpec{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatedMFAChallengeSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatedMFAChallengeSpec) ProtoMessage() {}

func (x *ValidatedMFAChallengeSpec) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatedMFAChallengeSpec.ProtoReflect.Descriptor instead.
func (*ValidatedMFAChallengeSpec) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{14}
}

func (x *ValidatedMFAChallengeSpec) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ValidatedMFAChallengeSpec) GetDevice() *Device {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *ValidatedMFAChallengeSpec) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

func (x *ValidatedMFAChallengeSpec) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

// Device is a multi-factor authentication device, such as a security key or SSO method.
type Device struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Boilerplate for implementing the Resource interface.
	Kind     string        `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	SubKind  string        `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	Version  string        `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Metadata *v11.Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// id is a UUID of this device.
	Id       string                 `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
	AddedAt  *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=added_at,json=addedAt,proto3" json:"added_at,omitempty"`
	LastUsed *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=last_used,json=lastUsed,proto3" json:"last_used,omitempty"`
	// Types that are valid to be assigned to Device:
	//
	//	*Device_Webauthn
	//	*Device_Sso
	Device        isDevice_Device `protobuf_oneof:"device"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Device) Reset() {
	*x = Device{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Device) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Device) ProtoMessage() {}

func (x *Device) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Device.ProtoReflect.Descriptor instead.
func (*Device) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{15}
}

func (x *Device) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *Device) GetSubKind() string {
	if x != nil {
		return x.SubKind
	}
	return ""
}

func (x *Device) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Device) GetMetadata() *v11.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Device) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Device) GetAddedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.AddedAt
	}
	return nil
}

func (x *Device) GetLastUsed() *timestamppb.Timestamp {
	if x != nil {
		return x.LastUsed
	}
	return nil
}

func (x *Device) GetDevice() isDevice_Device {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *Device) GetWebauthn() *WebauthnDevice {
	if x != nil {
		if x, ok := x.Device.(*Device_Webauthn); ok {
			return x.Webauthn
		}
	}
	return nil
}

func (x *Device) GetSso() *SSODevice {
	if x != nil {
		if x, ok := x.Device.(*Device_Sso); ok {
			return x.Sso
		}
	}
	return nil
}

type isDevice_Device interface {
	isDevice_Device()
}

type Device_Webauthn struct {
	Webauthn *WebauthnDevice `protobuf:"bytes,8,opt,name=webauthn,proto3,oneof"`
}

type Device_Sso struct {
	Sso *SSODevice `protobuf:"bytes,9,opt,name=sso,proto3,oneof"`
}

func (*Device_Webauthn) isDevice_Device() {}

func (*Device_Sso) isDevice_Device() {}

// WebauthnDevice holds Webauthn-specific fields of Device.
type WebauthnDevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// credential_id for the authenticator.
	CredentialId []byte `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id,omitempty"`
	// public_key_cbor encoded in CBOR format. Webauthn supports various key algorithms; CBOR encoding is used to reflect
	// those choices. See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter reference.
	PublicKeyCbor []byte `protobuf:"bytes,2,opt,name=public_key_cbor,json=publicKeyCbor,proto3" json:"public_key_cbor,omitempty"`
	// attestation_type used by the authenticator, if any.
	AttestationType string `protobuf:"bytes,3,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type,omitempty"`
	// aaguid is the globally unique identifier of the authenticator model. Zeroed for U2F devices.
	Aaguid []byte `protobuf:"bytes,4,opt,name=aaguid,proto3" json:"aaguid,omitempty"`
	// signature_counter for login operations. Actual counter values received from the authenticator are expected to be
	// higher than the previously-stored value.
	SignatureCounter uint32 `protobuf:"varint,5,opt,name=signature_counter,json=signatureCounter,proto3" json:"signature_counter,omitempty"`
	// attestation_object, as returned by the authentication during registration. Absent for legacy entries (Teleport
	// 8.x).
	AttestationObject []byte `protobuf:"bytes,6,opt,name=attestation_object,json=attestationObject,proto3" json:"attestation_object,omitempty"`
	// resident_key is true if a resident key was requested during registration. Marks passwordless-capable devices. (Note
	// that resident_key=true represents the server-side / Relying Party view of the registration process; the
	// authenticator alone can determine if a key is truly resident.)
	ResidentKey bool `protobuf:"varint,7,opt,name=resident_key,json=residentKey,proto3" json:"resident_key,omitempty"`
	// credential_rp_id used by the credential. Recorded on registration for new credentials, or on first successful
	// authentication for "old" credentials (created before the field existed). Ideally, this is always the same as the
	// configured RPID. If an RPID change does happen, this helps Teleport detect it and react accordingly.
	CredentialRpId string `protobuf:"bytes,8,opt,name=credential_rp_id,json=credentialRpId,proto3" json:"credential_rp_id,omitempty"`
	// credential_backup_eligible (Authenticator Backup Eligibility/BE bit), recorded during registration or backfill (for
	// older authenticators). https://w3c.github.io/webauthn/#authdata-flags-be
	CredentialBackupEligible *wrapperspb.BoolValue `protobuf:"bytes,9,opt,name=credential_backup_eligible,json=credentialBackupEligible,proto3" json:"credential_backup_eligible,omitempty"`
	// credential_backed_up (Authenticator Backup State/BS bit), recorded during registration or backfill (for older
	// authenticators). https://w3c.github.io/webauthn/#authdata-flags-bs
	CredentialBackedUp *wrapperspb.BoolValue `protobuf:"bytes,10,opt,name=credential_backed_up,json=credentialBackedUp,proto3" json:"credential_backed_up,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *WebauthnDevice) Reset() {
	*x = WebauthnDevice{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebauthnDevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebauthnDevice) ProtoMessage() {}

func (x *WebauthnDevice) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebauthnDevice.ProtoReflect.Descriptor instead.
func (*WebauthnDevice) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{16}
}

func (x *WebauthnDevice) GetCredentialId() []byte {
	if x != nil {
		return x.CredentialId
	}
	return nil
}

func (x *WebauthnDevice) GetPublicKeyCbor() []byte {
	if x != nil {
		return x.PublicKeyCbor
	}
	return nil
}

func (x *WebauthnDevice) GetAttestationType() string {
	if x != nil {
		return x.AttestationType
	}
	return ""
}

func (x *WebauthnDevice) GetAaguid() []byte {
	if x != nil {
		return x.Aaguid
	}
	return nil
}

func (x *WebauthnDevice) GetSignatureCounter() uint32 {
	if x != nil {
		return x.SignatureCounter
	}
	return 0
}

func (x *WebauthnDevice) GetAttestationObject() []byte {
	if x != nil {
		return x.AttestationObject
	}
	return nil
}

func (x *WebauthnDevice) GetResidentKey() bool {
	if x != nil {
		return x.ResidentKey
	}
	return false
}

func (x *WebauthnDevice) GetCredentialRpId() string {
	if x != nil {
		return x.CredentialRpId
	}
	return ""
}

func (x *WebauthnDevice) GetCredentialBackupEligible() *wrapperspb.BoolValue {
	if x != nil {
		return x.CredentialBackupEligible
	}
	return nil
}

func (x *WebauthnDevice) GetCredentialBackedUp() *wrapperspb.BoolValue {
	if x != nil {
		return x.CredentialBackedUp
	}
	return nil
}

// SSODevice contains details of an SSO MFA method.
type SSODevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// connector_id is the id of the SSO connector.
	ConnectorId string `protobuf:"bytes,1,opt,name=connector_id,json=connectorId,proto3" json:"connector_id,omitempty"`
	// connector_type is the type of the SSO connector.
	ConnectorType string `protobuf:"bytes,2,opt,name=connector_type,json=connectorType,proto3" json:"connector_type,omitempty"`
	// display_name is the display name of the SSO connector
	DisplayName   string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSODevice) Reset() {
	*x = SSODevice{}
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSODevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSODevice) ProtoMessage() {}

func (x *SSODevice) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSODevice.ProtoReflect.Descriptor instead.
func (*SSODevice) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_proto_rawDescGZIP(), []int{17}
}

func (x *SSODevice) GetConnectorId() string {
	if x != nil {
		return x.ConnectorId
	}
	return ""
}

func (x *SSODevice) GetConnectorType() string {
	if x != nil {
		return x.ConnectorType
	}
	return ""
}

func (x *SSODevice) GetDisplayName() string {
	if x != nil {
		return x.DisplayName
	}
	return ""
}

var File_teleport_mfa_v2_mfa_proto protoreflect.FileDescriptor

const file_teleport_mfa_v2_mfa_proto_rawDesc = "" +
	"\n" +
	"\x19teleport/mfa/v2/mfa.proto\x12\x0fteleport.mfa.v2\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a!teleport/header/v1/metadata.proto\x1a#teleport/webauthn/v1/webauthn.proto\"N\n" +
	"\x19SessionIdentifyingPayload\x12&\n" +
	"\x0essh_session_id\x18\x01 \x01(\fH\x00R\fsshSessionIdB\t\n" +
	"\apayload\"\xef\x01\n" +
	"\x16CreateChallengeRequest\x12D\n" +
	"\apayload\x18\x01 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12%\n" +
	"\x0etarget_cluster\x18\x02 \x01(\tR\rtargetCluster\x125\n" +
	"\x17sso_client_redirect_url\x18\x03 \x01(\tR\x14ssoClientRedirectUrl\x121\n" +
	"\x15proxy_address_for_sso\x18\x04 \x01(\tR\x12proxyAddressForSso\"z\n" +
	"\x17CreateChallengeResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12K\n" +
	"\rmfa_challenge\x18\x02 \x01(\v2&.teleport.mfa.v2.AuthenticateChallengeR\fmfaChallenge\"x\n" +
	"\x18ValidateChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12H\n" +
	"\fmfa_response\x18\x02 \x01(\v2%.teleport.mfa.v2.AuthenticateResponseR\vmfaResponse\"\x1b\n" +
	"\x19ValidateChallengeResponse\"\x80\x02\n" +
	"%ReplicateValidatedMFAChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12D\n" +
	"\apayload\x18\x02 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12/\n" +
	"\x06device\x18\x03 \x01(\v2\x17.teleport.mfa.v2.DeviceR\x06device\x12%\n" +
	"\x0esource_cluster\x18\x04 \x01(\tR\rsourceCluster\x12%\n" +
	"\x0etarget_cluster\x18\x05 \x01(\tR\rtargetCluster\"\x83\x01\n" +
	"&ReplicateValidatedMFAChallengeResponse\x12Y\n" +
	"\x14replicated_challenge\x18\x01 \x01(\v2&.teleport.mfa.v2.ValidatedMFAChallengeR\x13replicatedChallenge\"\xa5\x01\n" +
	"\"VerifyValidatedMFAChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12D\n" +
	"\apayload\x18\x02 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12%\n" +
	"\x0esource_cluster\x18\x03 \x01(\tR\rsourceCluster\"V\n" +
	"#VerifyValidatedMFAChallengeResponse\x12/\n" +
	"\x06device\x18\x01 \x01(\v2\x17.teleport.mfa.v2.DeviceR\x06device\"\xb5\x01\n" +
	"\x15AuthenticateChallenge\x12X\n" +
	"\x12webauthn_challenge\x18\x01 \x01(\v2).teleport.webauthn.v1.CredentialAssertionR\x11webauthnChallenge\x12B\n" +
	"\rsso_challenge\x18\x02 \x01(\v2\x1d.teleport.mfa.v2.SSOChallengeR\fssoChallenge\"\xae\x01\n" +
	"\x14AuthenticateResponse\x12O\n" +
	"\bwebauthn\x18\x01 \x01(\v21.teleport.webauthn.v1.CredentialAssertionResponseH\x00R\bwebauthn\x129\n" +
	"\x03sso\x18\x02 \x01(\v2%.teleport.mfa.v2.SSOChallengeResponseH\x00R\x03ssoB\n" +
	"\n" +
	"\bresponse\"\x84\x01\n" +
	"\fSSOChallenge\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12!\n" +
	"\fredirect_url\x18\x02 \x01(\tR\vredirectUrl\x122\n" +
	"\x06device\x18\x03 \x01(\v2\x1a.teleport.mfa.v2.SSODeviceR\x06device\"K\n" +
	"\x14SSOChallengeResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x14\n" +
	"\x05token\x18\x02 \x01(\tR\x05token\"\xda\x01\n" +
	"\x15ValidatedMFAChallenge\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x19\n" +
	"\bsub_kind\x18\x02 \x01(\tR\asubKind\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x128\n" +
	"\bmetadata\x18\x04 \x01(\v2\x1c.teleport.header.v1.MetadataR\bmetadata\x12>\n" +
	"\x04spec\x18\x05 \x01(\v2*.teleport.mfa.v2.ValidatedMFAChallengeSpecR\x04spec\"\xe0\x01\n" +
	"\x19ValidatedMFAChallengeSpec\x12D\n" +
	"\apayload\x18\x01 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12/\n" +
	"\x06device\x18\x02 \x01(\v2\x17.teleport.mfa.v2.DeviceR\x06device\x12%\n" +
	"\x0esource_cluster\x18\x03 \x01(\tR\rsourceCluster\x12%\n" +
	"\x0etarget_cluster\x18\x04 \x01(\tR\rtargetCluster\"\x84\x03\n" +
	"\x06Device\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x19\n" +
	"\bsub_kind\x18\x02 \x01(\tR\asubKind\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x128\n" +
	"\bmetadata\x18\x04 \x01(\v2\x1c.teleport.header.v1.MetadataR\bmetadata\x12\x0e\n" +
	"\x02id\x18\x05 \x01(\tR\x02id\x125\n" +
	"\badded_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\aaddedAt\x127\n" +
	"\tlast_used\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\blastUsed\x12=\n" +
	"\bwebauthn\x18\b \x01(\v2\x1f.teleport.mfa.v2.WebauthnDeviceH\x00R\bwebauthn\x12.\n" +
	"\x03sso\x18\t \x01(\v2\x1a.teleport.mfa.v2.SSODeviceH\x00R\x03ssoB\b\n" +
	"\x06device\"\xf1\x03\n" +
	"\x0eWebauthnDevice\x12#\n" +
	"\rcredential_id\x18\x01 \x01(\fR\fcredentialId\x12&\n" +
	"\x0fpublic_key_cbor\x18\x02 \x01(\fR\rpublicKeyCbor\x12)\n" +
	"\x10attestation_type\x18\x03 \x01(\tR\x0fattestationType\x12\x16\n" +
	"\x06aaguid\x18\x04 \x01(\fR\x06aaguid\x12+\n" +
	"\x11signature_counter\x18\x05 \x01(\rR\x10signatureCounter\x12-\n" +
	"\x12attestation_object\x18\x06 \x01(\fR\x11attestationObject\x12!\n" +
	"\fresident_key\x18\a \x01(\bR\vresidentKey\x12(\n" +
	"\x10credential_rp_id\x18\b \x01(\tR\x0ecredentialRpId\x12X\n" +
	"\x1acredential_backup_eligible\x18\t \x01(\v2\x1a.google.protobuf.BoolValueR\x18credentialBackupEligible\x12L\n" +
	"\x14credential_backed_up\x18\n" +
	" \x01(\v2\x1a.google.protobuf.BoolValueR\x12credentialBackedUp\"x\n" +
	"\tSSODevice\x12!\n" +
	"\fconnector_id\x18\x01 \x01(\tR\vconnectorId\x12%\n" +
	"\x0econnector_type\x18\x02 \x01(\tR\rconnectorType\x12!\n" +
	"\fdisplay_name\x18\x03 \x01(\tR\vdisplayName2\xfd\x03\n" +
	"\n" +
	"MFAService\x12d\n" +
	"\x0fCreateChallenge\x12'.teleport.mfa.v2.CreateChallengeRequest\x1a(.teleport.mfa.v2.CreateChallengeResponse\x12j\n" +
	"\x11ValidateChallenge\x12).teleport.mfa.v2.ValidateChallengeRequest\x1a*.teleport.mfa.v2.ValidateChallengeResponse\x12\x91\x01\n" +
	"\x1eReplicateValidatedMFAChallenge\x126.teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest\x1a7.teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse\x12\x88\x01\n" +
	"\x1bVerifyValidatedMFAChallenge\x123.teleport.mfa.v2.VerifyValidatedMFAChallengeRequest\x1a4.teleport.mfa.v2.VerifyValidatedMFAChallengeResponseBJZHgithub.com/gravitational/teleport/api/gen/proto/go/teleport/mfa/v2;mfav2b\x06proto3"

var (
	file_teleport_mfa_v2_mfa_proto_rawDescOnce sync.Once
	file_teleport_mfa_v2_mfa_proto_rawDescData []byte
)

func file_teleport_mfa_v2_mfa_proto_rawDescGZIP() []byte {
	file_teleport_mfa_v2_mfa_proto_rawDescOnce.Do(func() {
		file_teleport_mfa_v2_mfa_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_teleport_mfa_v2_mfa_proto_rawDesc), len(file_teleport_mfa_v2_mfa_proto_rawDesc)))
	})
	return file_teleport_mfa_v2_mfa_proto_rawDescData
}

var file_teleport_mfa_v2_mfa_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_teleport_mfa_v2_mfa_proto_goTypes = []any{
	(*SessionIdentifyingPayload)(nil),              // 0: teleport.mfa.v2.SessionIdentifyingPayload
	(*CreateChallengeRequest)(nil),                 // 1: teleport.mfa.v2.CreateChallengeRequest
	(*CreateChallengeResponse)(nil),                // 2: teleport.mfa.v2.CreateChallengeResponse
	(*ValidateChallengeRequest)(nil),               // 3: teleport.mfa.v2.ValidateChallengeRequest
	(*ValidateChallengeResponse)(nil),              // 4: teleport.mfa.v2.ValidateChallengeResponse
	(*ReplicateValidatedMFAChallengeRequest)(nil),  // 5: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest
	(*ReplicateValidatedMFAChallengeResponse)(nil), // 6: teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse
	(*VerifyValidatedMFAChallengeRequest)(nil),     // 7: teleport.mfa.v2.VerifyValidatedMFAChallengeRequest
	(*VerifyValidatedMFAChallengeResponse)(nil),    // 8: teleport.mfa.v2.VerifyValidatedMFAChallengeResponse
	(*AuthenticateChallenge)(nil),                  // 9: teleport.mfa.v2.AuthenticateChallenge
	(*AuthenticateResponse)(nil),                   // 10: teleport.mfa.v2.AuthenticateResponse
	(*SSOChallenge)(nil),                           // 11: teleport.mfa.v2.SSOChallenge
	(*SSOChallengeResponse)(nil),                   // 12: teleport.mfa.v2.SSOChallengeResponse
	(*ValidatedMFAChallenge)(nil),                  // 13: teleport.mfa.v2.ValidatedMFAChallenge
	(*ValidatedMFAChallengeSpec)(nil),              // 14: teleport.mfa.v2.ValidatedMFAChallengeSpec
	(*Device)(nil),                                 // 15: teleport.mfa.v2.Device
	(*WebauthnDevice)(nil),                         // 16: teleport.mfa.v2.WebauthnDevice
	(*SSODevice)(nil),                              // 17: teleport.mfa.v2.SSODevice
	(*v1.CredentialAssertion)(nil),                 // 18: teleport.webauthn.v1.CredentialAssertion
	(*v1.CredentialAssertionResponse)(nil),         // 19: teleport.webauthn.v1.CredentialAssertionResponse
	(*v11.Metadata)(nil),                           // 20: teleport.header.v1.Metadata
	(*timestamppb.Timestamp)(nil),                  // 21: google.protobuf.Timestamp
	(*wrapperspb.BoolValue)(nil),                   // 22: google.protobuf.BoolValue
}
var file_teleport_mfa_v2_mfa_proto_depIdxs = []int32{
	0,  // 0: teleport.mfa.v2.CreateChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	9,  // 1: teleport.mfa.v2.CreateChallengeResponse.mfa_challenge:type_name -> teleport.mfa.v2.AuthenticateChallenge
	10, // 2: teleport.mfa.v2.ValidateChallengeRequest.mfa_response:type_name -> teleport.mfa.v2.AuthenticateResponse
	0,  // 3: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 4: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest.device:type_name -> teleport.mfa.v2.Device
	13, // 5: teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse.replicated_challenge:type_name -> teleport.mfa.v2.ValidatedMFAChallenge
	0,  // 6: teleport.mfa.v2.VerifyValidatedMFAChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 7: teleport.mfa.v2.VerifyValidatedMFAChallengeResponse.device:type_name -> teleport.mfa.v2.Device
	18, // 8: teleport.mfa.v2.AuthenticateChallenge.webauthn_challenge:type_name -> teleport.webauthn.v1.CredentialAssertion
	11, // 9: teleport.mfa.v2.AuthenticateChallenge.sso_challenge:type_name -> teleport.mfa.v2.SSOChallenge
	19, // 10: teleport.mfa.v2.AuthenticateResponse.webauthn:type_name -> teleport.webauthn.v1.CredentialAssertionResponse
	12, // 11: teleport.mfa.v2.AuthenticateResponse.sso:type_name -> teleport.mfa.v2.SSOChallengeResponse
	17, // 12: teleport.mfa.v2.SSOChallenge.device:type_name -> teleport.mfa.v2.SSODevice
	20, // 13: teleport.mfa.v2.ValidatedMFAChallenge.metadata:type_name -> teleport.header.v1.Metadata
	14, // 14: teleport.mfa.v2.ValidatedMFAChallenge.spec:type_name -> teleport.mfa.v2.ValidatedMFAChallengeSpec
	0,  // 15: teleport.mfa.v2.ValidatedMFAChallengeSpec.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 16: teleport.mfa.v2.ValidatedMFAChallengeSpec.device:type_name -> teleport.mfa.v2.Device
	20, // 17: teleport.mfa.v2.Device.metadata:type_name -> teleport.header.v1.Metadata
	21, // 18: teleport.mfa.v2.Device.added_at:type_name -> google.protobuf.Timestamp
	21, // 19: teleport.mfa.v2.Device.last_used:type_name -> google.protobuf.Timestamp
	16, // 20: teleport.mfa.v2.Device.webauthn:type_name -> teleport.mfa.v2.WebauthnDevice
	17, // 21: teleport.mfa.v2.Device.sso:type_name -> teleport.mfa.v2.SSODevice
	22, // 22: teleport.mfa.v2.WebauthnDevice.credential_backup_eligible:type_name -> google.protobuf.BoolValue
	22, // 23: teleport.mfa.v2.WebauthnDevice.credential_backed_up:type_name -> google.protobuf.BoolValue
	1,  // 24: teleport.mfa.v2.MFAService.CreateChallenge:input_type -> teleport.mfa.v2.CreateChallengeRequest
	3,  // 25: teleport.mfa.v2.MFAService.ValidateChallenge:input_type -> teleport.mfa.v2.ValidateChallengeRequest
	5,  // 26: teleport.mfa.v2.MFAService.ReplicateValidatedMFAChallenge:input_type -> teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest
	7,  // 27: teleport.mfa.v2.MFAService.VerifyValidatedMFAChallenge:input_type -> teleport.mfa.v2.VerifyValidatedMFAChallengeRequest
	2,  // 28: teleport.mfa.v2.MFAService.CreateChallenge:output_type -> teleport.mfa.v2.CreateChallengeResponse
	4,  // 29: teleport.mfa.v2.MFAService.ValidateChallenge:output_type -> teleport.mfa.v2.ValidateChallengeResponse
	6,  // 30: teleport.mfa.v2.MFAService.ReplicateValidatedMFAChallenge:output_type -> teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse
	8,  // 31: teleport.mfa.v2.MFAService.VerifyValidatedMFAChallenge:output_type -> teleport.mfa.v2.VerifyValidatedMFAChallengeResponse
	28, // [28:32] is the sub-list for method output_type
	24, // [24:28] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_teleport_mfa_v2_mfa_proto_init() }
func file_teleport_mfa_v2_mfa_proto_init() {
	if File_teleport_mfa_v2_mfa_proto != nil {
		return
	}
	file_teleport_mfa_v2_mfa_proto_msgTypes[0].OneofWrappers = []any{
		(*SessionIdentifyingPayload_SshSessionId)(nil),
	}
	file_teleport_mfa_v2_mfa_proto_msgTypes[10].OneofWrappers = []any{
		(*AuthenticateResponse_Webauthn)(nil),
		(*AuthenticateResponse_Sso)(nil),
	}
	file_teleport_mfa_v2_mfa_proto_msgTypes[15].OneofWrappers = []any{
		(*Device_Webauthn)(nil),
		(*Device_Sso)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_teleport_mfa_v2_mfa_proto_rawDesc), len(file_teleport_mfa_v2_mfa_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_teleport_mfa_v2_mfa_proto_goTypes,
		DependencyIndexes: file_teleport_mfa_v2_mfa_proto_depIdxs,
		MessageInfos:      file_teleport_mfa_v2_mfa_proto_msgTypes,
	}.Build()
	File_teleport_mfa_v2_mfa_proto = out.File
	file_teleport_mfa_v2_mfa_proto_goTypes = nil
	file_teleport_mfa_v2_mfa_proto_depIdxs = nil
}
