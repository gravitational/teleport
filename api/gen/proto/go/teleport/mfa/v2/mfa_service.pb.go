// Copyright 2025 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: teleport/mfa/v2/mfa_service.proto

package mfav2

import (
	v1 "github.com/gravitational/teleport/api/gen/proto/go/teleport/header/v1"
	types "github.com/gravitational/teleport/api/types"
	webauthn "github.com/gravitational/teleport/api/types/webauthn"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SessionIdentifyingPayload contains a value that uniquely identifies a user's session. It must be computed by the
// client from session state and is used to bind MFA challenges to specific sessions.
type SessionIdentifyingPayload struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*SessionIdentifyingPayload_SshSessionId
	Payload       isSessionIdentifyingPayload_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionIdentifyingPayload) Reset() {
	*x = SessionIdentifyingPayload{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionIdentifyingPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionIdentifyingPayload) ProtoMessage() {}

func (x *SessionIdentifyingPayload) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionIdentifyingPayload.ProtoReflect.Descriptor instead.
func (*SessionIdentifyingPayload) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{0}
}

func (x *SessionIdentifyingPayload) GetPayload() isSessionIdentifyingPayload_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *SessionIdentifyingPayload) GetSshSessionId() []byte {
	if x != nil {
		if x, ok := x.Payload.(*SessionIdentifyingPayload_SshSessionId); ok {
			return x.SshSessionId
		}
	}
	return nil
}

type isSessionIdentifyingPayload_Payload interface {
	isSessionIdentifyingPayload_Payload()
}

type SessionIdentifyingPayload_SshSessionId struct {
	// session_id is the SSH session hash computed from SSH session state. For example, in Go this would be the value
	// from crypto/ssh#ConnMetadata.SessionID().
	SshSessionId []byte `protobuf:"bytes,1,opt,name=ssh_session_id,json=sshSessionId,proto3,oneof"`
}

func (*SessionIdentifyingPayload_SshSessionId) isSessionIdentifyingPayload_Payload() {}

// CreateChallengeRequest is the request message for CreateChallenge.
type CreateChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// payload is a value that uniquely identifies the user's session. When VerifyValidatedMFAChallenge is called, the
	// server will verify it matches the payload supplied to CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// target_cluster is the name of the target cluster where the SSH session is being established. If unset, the server
	// assumes the challenge is for the local cluster. This is used to determine where the validated challenge should be
	// replicated to for leaf clusters. It is required when the SSH session is being established in a leaf cluster.
	TargetCluster string `protobuf:"bytes,2,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	// sso_client_redirect_url should be supplied if the client supports SSO MFA checks. If unset, the server will only
	// return non-SSO challenges.
	SsoClientRedirectUrl string `protobuf:"bytes,3,opt,name=sso_client_redirect_url,json=ssoClientRedirectUrl,proto3" json:"sso_client_redirect_url,omitempty"`
	// proxy_address_for_sso is the proxy address that the user is using to connect to the Proxy. When using SSO MFA, this
	// address is required to determine which URL to redirect the user to when there are multiple options.
	ProxyAddressForSso string `protobuf:"bytes,4,opt,name=proxy_address_for_sso,json=proxyAddressForSso,proto3" json:"proxy_address_for_sso,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CreateChallengeRequest) Reset() {
	*x = CreateChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateChallengeRequest) ProtoMessage() {}

func (x *CreateChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateChallengeRequest.ProtoReflect.Descriptor instead.
func (*CreateChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{1}
}

func (x *CreateChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *CreateChallengeRequest) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

func (x *CreateChallengeRequest) GetSsoClientRedirectUrl() string {
	if x != nil {
		return x.SsoClientRedirectUrl
	}
	return ""
}

func (x *CreateChallengeRequest) GetProxyAddressForSso() string {
	if x != nil {
		return x.ProxyAddressForSso
	}
	return ""
}

// CreateChallengeResponse is the response message for CreateChallenge.
type CreateChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the unique resource name for the issued challenge generated by the server. This value should be treated as
	// an opaque identifier and used as-is in subsequent API calls.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// mfa_challenge contains the MFA challenge that the user must respond to.
	MfaChallenge  *AuthenticateChallenge `protobuf:"bytes,2,opt,name=mfa_challenge,json=mfaChallenge,proto3" json:"mfa_challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateChallengeResponse) Reset() {
	*x = CreateChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateChallengeResponse) ProtoMessage() {}

func (x *CreateChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateChallengeResponse.ProtoReflect.Descriptor instead.
func (*CreateChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{2}
}

func (x *CreateChallengeResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateChallengeResponse) GetMfaChallenge() *AuthenticateChallenge {
	if x != nil {
		return x.MfaChallenge
	}
	return nil
}

// ValidateChallengeRequest is the request message for ValidateChallenge.
type ValidateChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the validation to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// mfa_response contains the MFA challenge response provided by the user.
	MfaResponse   *AuthenticateResponse `protobuf:"bytes,2,opt,name=mfa_response,json=mfaResponse,proto3" json:"mfa_response,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateChallengeRequest) Reset() {
	*x = ValidateChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChallengeRequest) ProtoMessage() {}

func (x *ValidateChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChallengeRequest.ProtoReflect.Descriptor instead.
func (*ValidateChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{3}
}

func (x *ValidateChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ValidateChallengeRequest) GetMfaResponse() *AuthenticateResponse {
	if x != nil {
		return x.MfaResponse
	}
	return nil
}

// ValidateChallengeResponse is the response message for ValidateChallenge.
type ValidateChallengeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateChallengeResponse) Reset() {
	*x = ValidateChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateChallengeResponse) ProtoMessage() {}

func (x *ValidateChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateChallengeResponse.ProtoReflect.Descriptor instead.
func (*ValidateChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{4}
}

// ReplicateValidatedMFAChallengeRequest is the request message for ReplicateValidatedMFAChallenge.
type ReplicateValidatedMFAChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the upsert to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// payload is a value that uniquely identifies the user's session. This should match the payload in
	// CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// device contains information about the user's MFA device used to authenticate.
	Device *types.MFADevice `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,4,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	// target_cluster is the name of the destination cluster where the validated challenge should be replicated to.
	TargetCluster string `protobuf:"bytes,5,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicateValidatedMFAChallengeRequest) Reset() {
	*x = ReplicateValidatedMFAChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateValidatedMFAChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateValidatedMFAChallengeRequest) ProtoMessage() {}

func (x *ReplicateValidatedMFAChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateValidatedMFAChallengeRequest.ProtoReflect.Descriptor instead.
func (*ReplicateValidatedMFAChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{5}
}

func (x *ReplicateValidatedMFAChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ReplicateValidatedMFAChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ReplicateValidatedMFAChallengeRequest) GetDevice() *types.MFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *ReplicateValidatedMFAChallengeRequest) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

func (x *ReplicateValidatedMFAChallengeRequest) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

// ReplicateValidatedMFAChallengeResponse is the response message for ReplicateValidatedMFAChallenge.
type ReplicateValidatedMFAChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// replicated_challenge is the validated MFA challenge that was replicated.
	ReplicatedChallenge *ValidatedMFAChallenge `protobuf:"bytes,1,opt,name=replicated_challenge,json=replicatedChallenge,proto3" json:"replicated_challenge,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ReplicateValidatedMFAChallengeResponse) Reset() {
	*x = ReplicateValidatedMFAChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicateValidatedMFAChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicateValidatedMFAChallengeResponse) ProtoMessage() {}

func (x *ReplicateValidatedMFAChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicateValidatedMFAChallengeResponse.ProtoReflect.Descriptor instead.
func (*ReplicateValidatedMFAChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{6}
}

func (x *ReplicateValidatedMFAChallengeResponse) GetReplicatedChallenge() *ValidatedMFAChallenge {
	if x != nil {
		return x.ReplicatedChallenge
	}
	return nil
}

// VerifyValidatedMFAChallengeRequest is the request message for VerifyValidatedMFAChallenge.
type VerifyValidatedMFAChallengeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the resource name for the issued challenge. This must match the 'name' returned in CreateChallengeResponse
	// to tie the retrieval to the correct challenge.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// payload is a value that uniquely identifies the user's session. The client calling VerifyValidatedMFAChallenge MUST
	// independently compute this value from session state. The server will verify it matches the payload supplied in
	// CreateChallengeRequest to ensure the challenge is tied to the correct session.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,3,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyValidatedMFAChallengeRequest) Reset() {
	*x = VerifyValidatedMFAChallengeRequest{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyValidatedMFAChallengeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyValidatedMFAChallengeRequest) ProtoMessage() {}

func (x *VerifyValidatedMFAChallengeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyValidatedMFAChallengeRequest.ProtoReflect.Descriptor instead.
func (*VerifyValidatedMFAChallengeRequest) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{7}
}

func (x *VerifyValidatedMFAChallengeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *VerifyValidatedMFAChallengeRequest) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *VerifyValidatedMFAChallengeRequest) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

// VerifyValidatedMFAChallengeResponse is the response message for VerifyValidatedMFAChallenge.
type VerifyValidatedMFAChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// device contains information about the user's MFA device used to authenticate.
	Device        *types.MFADevice `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerifyValidatedMFAChallengeResponse) Reset() {
	*x = VerifyValidatedMFAChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerifyValidatedMFAChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerifyValidatedMFAChallengeResponse) ProtoMessage() {}

func (x *VerifyValidatedMFAChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerifyValidatedMFAChallengeResponse.ProtoReflect.Descriptor instead.
func (*VerifyValidatedMFAChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{8}
}

func (x *VerifyValidatedMFAChallengeResponse) GetDevice() *types.MFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

// AuthenticateChallenge is a challenge for all MFA devices registered for a user.
type AuthenticateChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// webauthn_challenge contains a Webauthn credential assertion used for login/authentication ceremonies. Credential
	// assertions hold, among other information, a list of allowed credentials for the ceremony (one for each U2F or
	// Webauthn device registered by the user).
	WebauthnChallenge *webauthn.CredentialAssertion `protobuf:"bytes,1,opt,name=webauthn_challenge,json=webauthnChallenge,proto3" json:"webauthn_challenge,omitempty"`
	// sso_challenge is an SSO MFA challenge. If set, the client can go to the IdP redirect URL to perform an MFA check in
	// the IdP and obtain an MFA token. This token paired with the request id can then be used as MFA verification.
	SsoChallenge  *SSOChallenge `protobuf:"bytes,2,opt,name=sso_challenge,json=ssoChallenge,proto3" json:"sso_challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticateChallenge) Reset() {
	*x = AuthenticateChallenge{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticateChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticateChallenge) ProtoMessage() {}

func (x *AuthenticateChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticateChallenge.ProtoReflect.Descriptor instead.
func (*AuthenticateChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{9}
}

func (x *AuthenticateChallenge) GetWebauthnChallenge() *webauthn.CredentialAssertion {
	if x != nil {
		return x.WebauthnChallenge
	}
	return nil
}

func (x *AuthenticateChallenge) GetSsoChallenge() *SSOChallenge {
	if x != nil {
		return x.SsoChallenge
	}
	return nil
}

// AuthenticateResponse is a response to AuthenticateChallenge using one of the MFA devices registered for a user.
type AuthenticateResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Response:
	//
	//	*AuthenticateResponse_Webauthn
	//	*AuthenticateResponse_Sso
	Response      isAuthenticateResponse_Response `protobuf_oneof:"response"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticateResponse) Reset() {
	*x = AuthenticateResponse{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticateResponse) ProtoMessage() {}

func (x *AuthenticateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticateResponse.ProtoReflect.Descriptor instead.
func (*AuthenticateResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{10}
}

func (x *AuthenticateResponse) GetResponse() isAuthenticateResponse_Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *AuthenticateResponse) GetWebauthn() *webauthn.CredentialAssertionResponse {
	if x != nil {
		if x, ok := x.Response.(*AuthenticateResponse_Webauthn); ok {
			return x.Webauthn
		}
	}
	return nil
}

func (x *AuthenticateResponse) GetSso() *SSOChallengeResponse {
	if x != nil {
		if x, ok := x.Response.(*AuthenticateResponse_Sso); ok {
			return x.Sso
		}
	}
	return nil
}

type isAuthenticateResponse_Response interface {
	isAuthenticateResponse_Response()
}

type AuthenticateResponse_Webauthn struct {
	// webauthn is a response to a Webauthn challenge.
	Webauthn *webauthn.CredentialAssertionResponse `protobuf:"bytes,1,opt,name=webauthn,proto3,oneof"`
}

type AuthenticateResponse_Sso struct {
	// sso is a response to an SSO challenge.
	Sso *SSOChallengeResponse `protobuf:"bytes,2,opt,name=sso,proto3,oneof"`
}

func (*AuthenticateResponse_Webauthn) isAuthenticateResponse_Response() {}

func (*AuthenticateResponse_Sso) isAuthenticateResponse_Response() {}

// SSOChallenge contains SSO auth request details to perform an SSO MFA check.
type SSOChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// redirect_url is an IdP redirect URL to initiate the SSO MFA flow.
	RedirectUrl string `protobuf:"bytes,2,opt,name=redirect_url,json=redirectUrl,proto3" json:"redirect_url,omitempty"`
	// device is the SSO device corresponding to the challenge.
	Device        *types.SSOMFADevice `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSOChallenge) Reset() {
	*x = SSOChallenge{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSOChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSOChallenge) ProtoMessage() {}

func (x *SSOChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSOChallenge.ProtoReflect.Descriptor instead.
func (*SSOChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{11}
}

func (x *SSOChallenge) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SSOChallenge) GetRedirectUrl() string {
	if x != nil {
		return x.RedirectUrl
	}
	return ""
}

func (x *SSOChallenge) GetDevice() *types.SSOMFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

// SSOChallengeResponse is a response to SSOChallenge.
type SSOChallengeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// token is a secret token used to verify the user's SSO MFA session.
	Token         string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SSOChallengeResponse) Reset() {
	*x = SSOChallengeResponse{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SSOChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SSOChallengeResponse) ProtoMessage() {}

func (x *SSOChallengeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SSOChallengeResponse.ProtoReflect.Descriptor instead.
func (*SSOChallengeResponse) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{12}
}

func (x *SSOChallengeResponse) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *SSOChallengeResponse) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

// ValidatedMFAChallenge represents a validated MFA challenge tied to a user session.
type ValidatedMFAChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The kind of resource represented.
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// Differentiates variations of the same kind. All resources should contain one, even if it is never populated.
	SubKind string `protobuf:"bytes,2,opt,name=sub_kind,json=subKind,proto3" json:"sub_kind,omitempty"`
	// The version of the resource being represented.
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Common metadata that all resources share.
	Metadata *v1.Metadata `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The validated challenge specification.
	Spec          *ValidatedMFAChallengeSpec `protobuf:"bytes,5,opt,name=spec,proto3" json:"spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatedMFAChallenge) Reset() {
	*x = ValidatedMFAChallenge{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatedMFAChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatedMFAChallenge) ProtoMessage() {}

func (x *ValidatedMFAChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatedMFAChallenge.ProtoReflect.Descriptor instead.
func (*ValidatedMFAChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{13}
}

func (x *ValidatedMFAChallenge) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetSubKind() string {
	if x != nil {
		return x.SubKind
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ValidatedMFAChallenge) GetMetadata() *v1.Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *ValidatedMFAChallenge) GetSpec() *ValidatedMFAChallengeSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

// ValidatedMFAChallengeSpec contains the validated challenge data that is set once during creation and never modified.
type ValidatedMFAChallengeSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// payload is a value that uniquely identifies the user's session. It is the value that was supplied in
	// CreateChallengeRequest.
	Payload *SessionIdentifyingPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// device contains information about the user's MFA device used to authenticate.
	Device *types.MFADevice `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
	// source_cluster is the name of the cluster where the validated challenge originated.
	SourceCluster string `protobuf:"bytes,3,opt,name=source_cluster,json=sourceCluster,proto3" json:"source_cluster,omitempty"`
	// target_cluster is the name of the cluster where the SSH session is being established and this resource is intended
	// for.
	TargetCluster string `protobuf:"bytes,4,opt,name=target_cluster,json=targetCluster,proto3" json:"target_cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatedMFAChallengeSpec) Reset() {
	*x = ValidatedMFAChallengeSpec{}
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatedMFAChallengeSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatedMFAChallengeSpec) ProtoMessage() {}

func (x *ValidatedMFAChallengeSpec) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_mfa_v2_mfa_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatedMFAChallengeSpec.ProtoReflect.Descriptor instead.
func (*ValidatedMFAChallengeSpec) Descriptor() ([]byte, []int) {
	return file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP(), []int{14}
}

func (x *ValidatedMFAChallengeSpec) GetPayload() *SessionIdentifyingPayload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ValidatedMFAChallengeSpec) GetDevice() *types.MFADevice {
	if x != nil {
		return x.Device
	}
	return nil
}

func (x *ValidatedMFAChallengeSpec) GetSourceCluster() string {
	if x != nil {
		return x.SourceCluster
	}
	return ""
}

func (x *ValidatedMFAChallengeSpec) GetTargetCluster() string {
	if x != nil {
		return x.TargetCluster
	}
	return ""
}

var File_teleport_mfa_v2_mfa_service_proto protoreflect.FileDescriptor

const file_teleport_mfa_v2_mfa_service_proto_rawDesc = "" +
	"\n" +
	"!teleport/mfa/v2/mfa_service.proto\x12\x0fteleport.mfa.v2\x1a!teleport/header/v1/metadata.proto\x1a!teleport/legacy/types/types.proto\x1a-teleport/legacy/types/webauthn/webauthn.proto\"N\n" +
	"\x19SessionIdentifyingPayload\x12&\n" +
	"\x0essh_session_id\x18\x01 \x01(\fH\x00R\fsshSessionIdB\t\n" +
	"\apayload\"\xef\x01\n" +
	"\x16CreateChallengeRequest\x12D\n" +
	"\apayload\x18\x01 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12%\n" +
	"\x0etarget_cluster\x18\x02 \x01(\tR\rtargetCluster\x125\n" +
	"\x17sso_client_redirect_url\x18\x03 \x01(\tR\x14ssoClientRedirectUrl\x121\n" +
	"\x15proxy_address_for_sso\x18\x04 \x01(\tR\x12proxyAddressForSso\"z\n" +
	"\x17CreateChallengeResponse\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12K\n" +
	"\rmfa_challenge\x18\x02 \x01(\v2&.teleport.mfa.v2.AuthenticateChallengeR\fmfaChallenge\"x\n" +
	"\x18ValidateChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12H\n" +
	"\fmfa_response\x18\x02 \x01(\v2%.teleport.mfa.v2.AuthenticateResponseR\vmfaResponse\"\x1b\n" +
	"\x19ValidateChallengeResponse\"\xf9\x01\n" +
	"%ReplicateValidatedMFAChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12D\n" +
	"\apayload\x18\x02 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12(\n" +
	"\x06device\x18\x03 \x01(\v2\x10.types.MFADeviceR\x06device\x12%\n" +
	"\x0esource_cluster\x18\x04 \x01(\tR\rsourceCluster\x12%\n" +
	"\x0etarget_cluster\x18\x05 \x01(\tR\rtargetCluster\"\x83\x01\n" +
	"&ReplicateValidatedMFAChallengeResponse\x12Y\n" +
	"\x14replicated_challenge\x18\x01 \x01(\v2&.teleport.mfa.v2.ValidatedMFAChallengeR\x13replicatedChallenge\"\xa5\x01\n" +
	"\"VerifyValidatedMFAChallengeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12D\n" +
	"\apayload\x18\x02 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12%\n" +
	"\x0esource_cluster\x18\x03 \x01(\tR\rsourceCluster\"O\n" +
	"#VerifyValidatedMFAChallengeResponse\x12(\n" +
	"\x06device\x18\x01 \x01(\v2\x10.types.MFADeviceR\x06device\"\xa9\x01\n" +
	"\x15AuthenticateChallenge\x12L\n" +
	"\x12webauthn_challenge\x18\x01 \x01(\v2\x1d.webauthn.CredentialAssertionR\x11webauthnChallenge\x12B\n" +
	"\rsso_challenge\x18\x02 \x01(\v2\x1d.teleport.mfa.v2.SSOChallengeR\fssoChallenge\"\xa2\x01\n" +
	"\x14AuthenticateResponse\x12C\n" +
	"\bwebauthn\x18\x01 \x01(\v2%.webauthn.CredentialAssertionResponseH\x00R\bwebauthn\x129\n" +
	"\x03sso\x18\x02 \x01(\v2%.teleport.mfa.v2.SSOChallengeResponseH\x00R\x03ssoB\n" +
	"\n" +
	"\bresponse\"}\n" +
	"\fSSOChallenge\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12!\n" +
	"\fredirect_url\x18\x02 \x01(\tR\vredirectUrl\x12+\n" +
	"\x06device\x18\x03 \x01(\v2\x13.types.SSOMFADeviceR\x06device\"K\n" +
	"\x14SSOChallengeResponse\x12\x1d\n" +
	"\n" +
	"request_id\x18\x01 \x01(\tR\trequestId\x12\x14\n" +
	"\x05token\x18\x02 \x01(\tR\x05token\"\xda\x01\n" +
	"\x15ValidatedMFAChallenge\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x19\n" +
	"\bsub_kind\x18\x02 \x01(\tR\asubKind\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x128\n" +
	"\bmetadata\x18\x04 \x01(\v2\x1c.teleport.header.v1.MetadataR\bmetadata\x12>\n" +
	"\x04spec\x18\x05 \x01(\v2*.teleport.mfa.v2.ValidatedMFAChallengeSpecR\x04spec\"\xd9\x01\n" +
	"\x19ValidatedMFAChallengeSpec\x12D\n" +
	"\apayload\x18\x01 \x01(\v2*.teleport.mfa.v2.SessionIdentifyingPayloadR\apayload\x12(\n" +
	"\x06device\x18\x02 \x01(\v2\x10.types.MFADeviceR\x06device\x12%\n" +
	"\x0esource_cluster\x18\x03 \x01(\tR\rsourceCluster\x12%\n" +
	"\x0etarget_cluster\x18\x04 \x01(\tR\rtargetCluster2\xfd\x03\n" +
	"\n" +
	"MFAService\x12d\n" +
	"\x0fCreateChallenge\x12'.teleport.mfa.v2.CreateChallengeRequest\x1a(.teleport.mfa.v2.CreateChallengeResponse\x12j\n" +
	"\x11ValidateChallenge\x12).teleport.mfa.v2.ValidateChallengeRequest\x1a*.teleport.mfa.v2.ValidateChallengeResponse\x12\x91\x01\n" +
	"\x1eReplicateValidatedMFAChallenge\x126.teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest\x1a7.teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse\x12\x88\x01\n" +
	"\x1bVerifyValidatedMFAChallenge\x123.teleport.mfa.v2.VerifyValidatedMFAChallengeRequest\x1a4.teleport.mfa.v2.VerifyValidatedMFAChallengeResponseBJZHgithub.com/gravitational/teleport/api/gen/proto/go/teleport/mfa/v2;mfav2b\x06proto3"

var (
	file_teleport_mfa_v2_mfa_service_proto_rawDescOnce sync.Once
	file_teleport_mfa_v2_mfa_service_proto_rawDescData []byte
)

func file_teleport_mfa_v2_mfa_service_proto_rawDescGZIP() []byte {
	file_teleport_mfa_v2_mfa_service_proto_rawDescOnce.Do(func() {
		file_teleport_mfa_v2_mfa_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_teleport_mfa_v2_mfa_service_proto_rawDesc), len(file_teleport_mfa_v2_mfa_service_proto_rawDesc)))
	})
	return file_teleport_mfa_v2_mfa_service_proto_rawDescData
}

var file_teleport_mfa_v2_mfa_service_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_teleport_mfa_v2_mfa_service_proto_goTypes = []any{
	(*SessionIdentifyingPayload)(nil),              // 0: teleport.mfa.v2.SessionIdentifyingPayload
	(*CreateChallengeRequest)(nil),                 // 1: teleport.mfa.v2.CreateChallengeRequest
	(*CreateChallengeResponse)(nil),                // 2: teleport.mfa.v2.CreateChallengeResponse
	(*ValidateChallengeRequest)(nil),               // 3: teleport.mfa.v2.ValidateChallengeRequest
	(*ValidateChallengeResponse)(nil),              // 4: teleport.mfa.v2.ValidateChallengeResponse
	(*ReplicateValidatedMFAChallengeRequest)(nil),  // 5: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest
	(*ReplicateValidatedMFAChallengeResponse)(nil), // 6: teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse
	(*VerifyValidatedMFAChallengeRequest)(nil),     // 7: teleport.mfa.v2.VerifyValidatedMFAChallengeRequest
	(*VerifyValidatedMFAChallengeResponse)(nil),    // 8: teleport.mfa.v2.VerifyValidatedMFAChallengeResponse
	(*AuthenticateChallenge)(nil),                  // 9: teleport.mfa.v2.AuthenticateChallenge
	(*AuthenticateResponse)(nil),                   // 10: teleport.mfa.v2.AuthenticateResponse
	(*SSOChallenge)(nil),                           // 11: teleport.mfa.v2.SSOChallenge
	(*SSOChallengeResponse)(nil),                   // 12: teleport.mfa.v2.SSOChallengeResponse
	(*ValidatedMFAChallenge)(nil),                  // 13: teleport.mfa.v2.ValidatedMFAChallenge
	(*ValidatedMFAChallengeSpec)(nil),              // 14: teleport.mfa.v2.ValidatedMFAChallengeSpec
	(*types.MFADevice)(nil),                        // 15: types.MFADevice
	(*webauthn.CredentialAssertion)(nil),           // 16: webauthn.CredentialAssertion
	(*webauthn.CredentialAssertionResponse)(nil),   // 17: webauthn.CredentialAssertionResponse
	(*types.SSOMFADevice)(nil),                     // 18: types.SSOMFADevice
	(*v1.Metadata)(nil),                            // 19: teleport.header.v1.Metadata
}
var file_teleport_mfa_v2_mfa_service_proto_depIdxs = []int32{
	0,  // 0: teleport.mfa.v2.CreateChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	9,  // 1: teleport.mfa.v2.CreateChallengeResponse.mfa_challenge:type_name -> teleport.mfa.v2.AuthenticateChallenge
	10, // 2: teleport.mfa.v2.ValidateChallengeRequest.mfa_response:type_name -> teleport.mfa.v2.AuthenticateResponse
	0,  // 3: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 4: teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest.device:type_name -> types.MFADevice
	13, // 5: teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse.replicated_challenge:type_name -> teleport.mfa.v2.ValidatedMFAChallenge
	0,  // 6: teleport.mfa.v2.VerifyValidatedMFAChallengeRequest.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 7: teleport.mfa.v2.VerifyValidatedMFAChallengeResponse.device:type_name -> types.MFADevice
	16, // 8: teleport.mfa.v2.AuthenticateChallenge.webauthn_challenge:type_name -> webauthn.CredentialAssertion
	11, // 9: teleport.mfa.v2.AuthenticateChallenge.sso_challenge:type_name -> teleport.mfa.v2.SSOChallenge
	17, // 10: teleport.mfa.v2.AuthenticateResponse.webauthn:type_name -> webauthn.CredentialAssertionResponse
	12, // 11: teleport.mfa.v2.AuthenticateResponse.sso:type_name -> teleport.mfa.v2.SSOChallengeResponse
	18, // 12: teleport.mfa.v2.SSOChallenge.device:type_name -> types.SSOMFADevice
	19, // 13: teleport.mfa.v2.ValidatedMFAChallenge.metadata:type_name -> teleport.header.v1.Metadata
	14, // 14: teleport.mfa.v2.ValidatedMFAChallenge.spec:type_name -> teleport.mfa.v2.ValidatedMFAChallengeSpec
	0,  // 15: teleport.mfa.v2.ValidatedMFAChallengeSpec.payload:type_name -> teleport.mfa.v2.SessionIdentifyingPayload
	15, // 16: teleport.mfa.v2.ValidatedMFAChallengeSpec.device:type_name -> types.MFADevice
	1,  // 17: teleport.mfa.v2.MFAService.CreateChallenge:input_type -> teleport.mfa.v2.CreateChallengeRequest
	3,  // 18: teleport.mfa.v2.MFAService.ValidateChallenge:input_type -> teleport.mfa.v2.ValidateChallengeRequest
	5,  // 19: teleport.mfa.v2.MFAService.ReplicateValidatedMFAChallenge:input_type -> teleport.mfa.v2.ReplicateValidatedMFAChallengeRequest
	7,  // 20: teleport.mfa.v2.MFAService.VerifyValidatedMFAChallenge:input_type -> teleport.mfa.v2.VerifyValidatedMFAChallengeRequest
	2,  // 21: teleport.mfa.v2.MFAService.CreateChallenge:output_type -> teleport.mfa.v2.CreateChallengeResponse
	4,  // 22: teleport.mfa.v2.MFAService.ValidateChallenge:output_type -> teleport.mfa.v2.ValidateChallengeResponse
	6,  // 23: teleport.mfa.v2.MFAService.ReplicateValidatedMFAChallenge:output_type -> teleport.mfa.v2.ReplicateValidatedMFAChallengeResponse
	8,  // 24: teleport.mfa.v2.MFAService.VerifyValidatedMFAChallenge:output_type -> teleport.mfa.v2.VerifyValidatedMFAChallengeResponse
	21, // [21:25] is the sub-list for method output_type
	17, // [17:21] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_teleport_mfa_v2_mfa_service_proto_init() }
func file_teleport_mfa_v2_mfa_service_proto_init() {
	if File_teleport_mfa_v2_mfa_service_proto != nil {
		return
	}
	file_teleport_mfa_v2_mfa_service_proto_msgTypes[0].OneofWrappers = []any{
		(*SessionIdentifyingPayload_SshSessionId)(nil),
	}
	file_teleport_mfa_v2_mfa_service_proto_msgTypes[10].OneofWrappers = []any{
		(*AuthenticateResponse_Webauthn)(nil),
		(*AuthenticateResponse_Sso)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_teleport_mfa_v2_mfa_service_proto_rawDesc), len(file_teleport_mfa_v2_mfa_service_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_teleport_mfa_v2_mfa_service_proto_goTypes,
		DependencyIndexes: file_teleport_mfa_v2_mfa_service_proto_depIdxs,
		MessageInfos:      file_teleport_mfa_v2_mfa_service_proto_msgTypes,
	}.Build()
	File_teleport_mfa_v2_mfa_service_proto = out.File
	file_teleport_mfa_v2_mfa_service_proto_goTypes = nil
	file_teleport_mfa_v2_mfa_service_proto_depIdxs = nil
}
