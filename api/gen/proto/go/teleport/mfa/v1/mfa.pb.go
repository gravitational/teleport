// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/mfa/v1/mfa.proto

package mfav1

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gravitational/teleport/api/types"
	webauthn "github.com/gravitational/teleport/api/types/webauthn"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ChallengeScope is a scope authorized by an MFA challenge resolution.
type ChallengeScope int32

const (
	// Scope unknown or not specified.
	ChallengeScope_CHALLENGE_SCOPE_UNSPECIFIED ChallengeScope = 0
	// Standard webauthn login.
	ChallengeScope_CHALLENGE_SCOPE_LOGIN ChallengeScope = 1
	// Passwordless webauthn login.
	ChallengeScope_CHALLENGE_SCOPE_PASSWORDLESS_LOGIN ChallengeScope = 2
	// Headless login.
	ChallengeScope_CHALLENGE_SCOPE_HEADLESS_LOGIN ChallengeScope = 3
	// MFA device management.
	ChallengeScope_CHALLENGE_SCOPE_MANAGE_DEVICES ChallengeScope = 4
	// Account recovery.
	ChallengeScope_CHALLENGE_SCOPE_ACCOUNT_RECOVERY ChallengeScope = 5
	// Used for per-session MFA and moderated session presence checks.
	ChallengeScope_CHALLENGE_SCOPE_USER_SESSION ChallengeScope = 6
	// Used for various administrative actions, such as adding, updating, or deleting administrative resources (users,
	// roles, etc.).
	//
	// Note: this scope should not be used for new MFA capabilities that have more precise scope. Instead, new scopes
	// should be added. This scope may also be split into multiple smaller scopes in the future.
	ChallengeScope_CHALLENGE_SCOPE_ADMIN_ACTION ChallengeScope = 7
	// Used for changing user's password.
	ChallengeScope_CHALLENGE_SCOPE_CHANGE_PASSWORD ChallengeScope = 8
)

var ChallengeScope_name = map[int32]string{
	0: "CHALLENGE_SCOPE_UNSPECIFIED",
	1: "CHALLENGE_SCOPE_LOGIN",
	2: "CHALLENGE_SCOPE_PASSWORDLESS_LOGIN",
	3: "CHALLENGE_SCOPE_HEADLESS_LOGIN",
	4: "CHALLENGE_SCOPE_MANAGE_DEVICES",
	5: "CHALLENGE_SCOPE_ACCOUNT_RECOVERY",
	6: "CHALLENGE_SCOPE_USER_SESSION",
	7: "CHALLENGE_SCOPE_ADMIN_ACTION",
	8: "CHALLENGE_SCOPE_CHANGE_PASSWORD",
}

var ChallengeScope_value = map[string]int32{
	"CHALLENGE_SCOPE_UNSPECIFIED":        0,
	"CHALLENGE_SCOPE_LOGIN":              1,
	"CHALLENGE_SCOPE_PASSWORDLESS_LOGIN": 2,
	"CHALLENGE_SCOPE_HEADLESS_LOGIN":     3,
	"CHALLENGE_SCOPE_MANAGE_DEVICES":     4,
	"CHALLENGE_SCOPE_ACCOUNT_RECOVERY":   5,
	"CHALLENGE_SCOPE_USER_SESSION":       6,
	"CHALLENGE_SCOPE_ADMIN_ACTION":       7,
	"CHALLENGE_SCOPE_CHANGE_PASSWORD":    8,
}

func (x ChallengeScope) String() string {
	return proto.EnumName(ChallengeScope_name, int32(x))
}

func (ChallengeScope) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{0}
}

// ChallengeAllowReuse determines whether an MFA challenge response can be used to authenticate the user more than once
// until the challenge expires.
//
// Reuse is only permitted for specific actions by the discretion of the server. See the server implementation for
// details.
type ChallengeAllowReuse int32

const (
	// Reuse unspecified, treated as CHALLENGE_ALLOW_REUSE_NO.
	ChallengeAllowReuse_CHALLENGE_ALLOW_REUSE_UNSPECIFIED ChallengeAllowReuse = 0
	// Reuse is permitted.
	ChallengeAllowReuse_CHALLENGE_ALLOW_REUSE_YES ChallengeAllowReuse = 1
	// Reuse is not permitted.
	ChallengeAllowReuse_CHALLENGE_ALLOW_REUSE_NO ChallengeAllowReuse = 2
)

var ChallengeAllowReuse_name = map[int32]string{
	0: "CHALLENGE_ALLOW_REUSE_UNSPECIFIED",
	1: "CHALLENGE_ALLOW_REUSE_YES",
	2: "CHALLENGE_ALLOW_REUSE_NO",
}

var ChallengeAllowReuse_value = map[string]int32{
	"CHALLENGE_ALLOW_REUSE_UNSPECIFIED": 0,
	"CHALLENGE_ALLOW_REUSE_YES":         1,
	"CHALLENGE_ALLOW_REUSE_NO":          2,
}

func (x ChallengeAllowReuse) String() string {
	return proto.EnumName(ChallengeAllowReuse_name, int32(x))
}

func (ChallengeAllowReuse) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{1}
}

// ChallengeExtensions contains MFA challenge extensions used by Teleport during MFA authentication.
type ChallengeExtensions struct {
	// Scope is an authorization scope for this MFA challenge. Required.
	Scope ChallengeScope `protobuf:"varint,1,opt,name=scope,proto3,enum=teleport.mfa.v1.ChallengeScope" json:"scope,omitempty"`
	// AllowReuse determines whether the MFA challenge allows reuse. Defaults to CHALLENGE_ALLOW_REUSE_NO.
	//
	// Note that reuse is only permitted for specific actions by the discretion of the server. See the server
	// implementation for details.
	AllowReuse ChallengeAllowReuse `protobuf:"varint,2,opt,name=allow_reuse,json=allowReuse,proto3,enum=teleport.mfa.v1.ChallengeAllowReuse" json:"allow_reuse,omitempty"`
	// User verification requirement for the challenge.
	//
	// * https://www.w3.org/TR/webauthn-2/#enum-userVerificationRequirement.
	// * https://pkg.go.dev/github.com/go-webauthn/webauthn/protocol#UserVerificationRequirement.
	//
	// Optional. Empty is equivalent to "discouraged".
	UserVerificationRequirement string   `protobuf:"bytes,3,opt,name=user_verification_requirement,json=userVerificationRequirement,proto3" json:"user_verification_requirement,omitempty"`
	XXX_NoUnkeyedLiteral        struct{} `json:"-"`
	XXX_unrecognized            []byte   `json:"-"`
	XXX_sizecache               int32    `json:"-"`
}

func (m *ChallengeExtensions) Reset()         { *m = ChallengeExtensions{} }
func (m *ChallengeExtensions) String() string { return proto.CompactTextString(m) }
func (*ChallengeExtensions) ProtoMessage()    {}
func (*ChallengeExtensions) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{0}
}
func (m *ChallengeExtensions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeExtensions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeExtensions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeExtensions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeExtensions.Merge(m, src)
}
func (m *ChallengeExtensions) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeExtensions) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeExtensions.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeExtensions proto.InternalMessageInfo

func (m *ChallengeExtensions) GetScope() ChallengeScope {
	if m != nil {
		return m.Scope
	}
	return ChallengeScope_CHALLENGE_SCOPE_UNSPECIFIED
}

func (m *ChallengeExtensions) GetAllowReuse() ChallengeAllowReuse {
	if m != nil {
		return m.AllowReuse
	}
	return ChallengeAllowReuse_CHALLENGE_ALLOW_REUSE_UNSPECIFIED
}

func (m *ChallengeExtensions) GetUserVerificationRequirement() string {
	if m != nil {
		return m.UserVerificationRequirement
	}
	return ""
}

// CreateChallengeForActionRequest is the request message for CreateChallengeForAction.
type CreateChallengeForActionRequest struct {
	// action_id is a required unique identifier associated with the MFA challenge. The challenge will be correlated to a
	// specific user action based on this ID. This field MUST be a UUID v4 (RFC 4122, version 4).
	ActionId string `protobuf:"bytes,1,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty"`
	// user is the username of the user attempting to authenticate.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// sso_client_redirect_url should be supplied if the client supports SSO MFA checks. If unset, the server will only
	// return non-SSO challenges.
	SsoClientRedirectUrl string `protobuf:"bytes,3,opt,name=sso_client_redirect_url,json=ssoClientRedirectUrl,proto3" json:"sso_client_redirect_url,omitempty"`
	// proxy_address is the proxy address that the user is using to connect to the Proxy. When using SSO MFA, this address
	// is required to determine which URL to redirect the user to when there are multiple options.
	ProxyAddress         string   `protobuf:"bytes,4,opt,name=proxy_address,json=proxyAddress,proto3" json:"proxy_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateChallengeForActionRequest) Reset()         { *m = CreateChallengeForActionRequest{} }
func (m *CreateChallengeForActionRequest) String() string { return proto.CompactTextString(m) }
func (*CreateChallengeForActionRequest) ProtoMessage()    {}
func (*CreateChallengeForActionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{1}
}
func (m *CreateChallengeForActionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateChallengeForActionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateChallengeForActionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateChallengeForActionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateChallengeForActionRequest.Merge(m, src)
}
func (m *CreateChallengeForActionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateChallengeForActionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateChallengeForActionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateChallengeForActionRequest proto.InternalMessageInfo

func (m *CreateChallengeForActionRequest) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CreateChallengeForActionRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *CreateChallengeForActionRequest) GetSsoClientRedirectUrl() string {
	if m != nil {
		return m.SsoClientRedirectUrl
	}
	return ""
}

func (m *CreateChallengeForActionRequest) GetProxyAddress() string {
	if m != nil {
		return m.ProxyAddress
	}
	return ""
}

// CreateChallengeForActionResponse is the response message for CreateChallengeForAction.
type CreateChallengeForActionResponse struct {
	// action_id is the unique identifier associated with the MFA challenge. It indicates which action the
	// challenge/response will be tied to. This field MUST be a UUID v4 (RFC 4122, version 4).
	ActionId string `protobuf:"bytes,1,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty"`
	// mfa_challenge contains the MFA challenge that the user must respond to.
	MfaChallenge         *AuthenticateChallenge `protobuf:"bytes,2,opt,name=mfa_challenge,json=mfaChallenge,proto3" json:"mfa_challenge,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *CreateChallengeForActionResponse) Reset()         { *m = CreateChallengeForActionResponse{} }
func (m *CreateChallengeForActionResponse) String() string { return proto.CompactTextString(m) }
func (*CreateChallengeForActionResponse) ProtoMessage()    {}
func (*CreateChallengeForActionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{2}
}
func (m *CreateChallengeForActionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateChallengeForActionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateChallengeForActionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateChallengeForActionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateChallengeForActionResponse.Merge(m, src)
}
func (m *CreateChallengeForActionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateChallengeForActionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateChallengeForActionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateChallengeForActionResponse proto.InternalMessageInfo

func (m *CreateChallengeForActionResponse) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CreateChallengeForActionResponse) GetMfaChallenge() *AuthenticateChallenge {
	if m != nil {
		return m.MfaChallenge
	}
	return nil
}

// ValidateChallengeForActionRequest is the request message for ValidateChallengeForAction.
type ValidateChallengeForActionRequest struct {
	// action_id is a required unique identifier associated with the MFA challenge. It validates that the challenge and
	// response are tied to a specific user action. This field MUST be a UUID v4 (RFC 4122, version 4).
	ActionId string `protobuf:"bytes,1,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty"`
	// mfa_response contains the MFA challenge response provided by the user.
	MfaResponse *AuthenticateResponse `protobuf:"bytes,2,opt,name=mfa_response,json=mfaResponse,proto3" json:"mfa_response,omitempty"`
	// user is the username of the user attempting to authenticate.
	User                 string   `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidateChallengeForActionRequest) Reset()         { *m = ValidateChallengeForActionRequest{} }
func (m *ValidateChallengeForActionRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateChallengeForActionRequest) ProtoMessage()    {}
func (*ValidateChallengeForActionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{3}
}
func (m *ValidateChallengeForActionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateChallengeForActionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateChallengeForActionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateChallengeForActionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateChallengeForActionRequest.Merge(m, src)
}
func (m *ValidateChallengeForActionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateChallengeForActionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateChallengeForActionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateChallengeForActionRequest proto.InternalMessageInfo

func (m *ValidateChallengeForActionRequest) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *ValidateChallengeForActionRequest) GetMfaResponse() *AuthenticateResponse {
	if m != nil {
		return m.MfaResponse
	}
	return nil
}

func (m *ValidateChallengeForActionRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

// ValidateChallengeForActionResponse is the response message for ValidateChallengeForAction.
type ValidateChallengeForActionResponse struct {
	// action_id is the unique identifier associated with the MFA challenge. It indicates which action the
	// challenge/response was tied to. This field MUST be a UUID v4 (RFC 4122, version 4).
	ActionId string `protobuf:"bytes,1,opt,name=action_id,json=actionId,proto3" json:"action_id,omitempty"`
	// user is the username of the user authenticated by the MFA challenge.
	User string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// device contains information about the user's MFA device used to authenticate.
	Device               *types.MFADevice `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ValidateChallengeForActionResponse) Reset()         { *m = ValidateChallengeForActionResponse{} }
func (m *ValidateChallengeForActionResponse) String() string { return proto.CompactTextString(m) }
func (*ValidateChallengeForActionResponse) ProtoMessage()    {}
func (*ValidateChallengeForActionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{4}
}
func (m *ValidateChallengeForActionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateChallengeForActionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateChallengeForActionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateChallengeForActionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateChallengeForActionResponse.Merge(m, src)
}
func (m *ValidateChallengeForActionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidateChallengeForActionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateChallengeForActionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateChallengeForActionResponse proto.InternalMessageInfo

func (m *ValidateChallengeForActionResponse) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *ValidateChallengeForActionResponse) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *ValidateChallengeForActionResponse) GetDevice() *types.MFADevice {
	if m != nil {
		return m.Device
	}
	return nil
}

// AuthenticateChallenge is a challenge for all MFA devices registered for a user.
type AuthenticateChallenge struct {
	// webauthn_challenge contains a Webauthn credential assertion used for login/authentication ceremonies. Credential
	// assertions hold, among other information, a list of allowed credentials for the ceremony (one for each U2F or
	// Webauthn device registered by the user).
	WebauthnChallenge *webauthn.CredentialAssertion `protobuf:"bytes,1,opt,name=webauthn_challenge,json=webauthnChallenge,proto3" json:"webauthn_challenge,omitempty"`
	// sso_challenge is an SSO MFA challenge. If set, the client can go to the IdP redirect URL to perform an MFA check in
	// the IdP and obtain an MFA token. This token paired with the request id can then be used as MFA verification.
	SsoChallenge         *SSOChallenge `protobuf:"bytes,2,opt,name=sso_challenge,json=ssoChallenge,proto3" json:"sso_challenge,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AuthenticateChallenge) Reset()         { *m = AuthenticateChallenge{} }
func (m *AuthenticateChallenge) String() string { return proto.CompactTextString(m) }
func (*AuthenticateChallenge) ProtoMessage()    {}
func (*AuthenticateChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{5}
}
func (m *AuthenticateChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticateChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticateChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticateChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticateChallenge.Merge(m, src)
}
func (m *AuthenticateChallenge) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticateChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticateChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticateChallenge proto.InternalMessageInfo

func (m *AuthenticateChallenge) GetWebauthnChallenge() *webauthn.CredentialAssertion {
	if m != nil {
		return m.WebauthnChallenge
	}
	return nil
}

func (m *AuthenticateChallenge) GetSsoChallenge() *SSOChallenge {
	if m != nil {
		return m.SsoChallenge
	}
	return nil
}

// AuthenticateResponse is a response to AuthenticateChallenge using one of the MFA devices registered for a user.
type AuthenticateResponse struct {
	// Types that are valid to be assigned to Response:
	//	*AuthenticateResponse_Webauthn
	//	*AuthenticateResponse_Sso
	Response             isAuthenticateResponse_Response `protobuf_oneof:"response"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *AuthenticateResponse) Reset()         { *m = AuthenticateResponse{} }
func (m *AuthenticateResponse) String() string { return proto.CompactTextString(m) }
func (*AuthenticateResponse) ProtoMessage()    {}
func (*AuthenticateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{6}
}
func (m *AuthenticateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticateResponse.Merge(m, src)
}
func (m *AuthenticateResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticateResponse proto.InternalMessageInfo

type isAuthenticateResponse_Response interface {
	isAuthenticateResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthenticateResponse_Webauthn struct {
	Webauthn *webauthn.CredentialAssertionResponse `protobuf:"bytes,1,opt,name=webauthn,proto3,oneof" json:"webauthn,omitempty"`
}
type AuthenticateResponse_Sso struct {
	Sso *SSOChallengeResponse `protobuf:"bytes,2,opt,name=sso,proto3,oneof" json:"sso,omitempty"`
}

func (*AuthenticateResponse_Webauthn) isAuthenticateResponse_Response() {}
func (*AuthenticateResponse_Sso) isAuthenticateResponse_Response()      {}

func (m *AuthenticateResponse) GetResponse() isAuthenticateResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *AuthenticateResponse) GetWebauthn() *webauthn.CredentialAssertionResponse {
	if x, ok := m.GetResponse().(*AuthenticateResponse_Webauthn); ok {
		return x.Webauthn
	}
	return nil
}

func (m *AuthenticateResponse) GetSso() *SSOChallengeResponse {
	if x, ok := m.GetResponse().(*AuthenticateResponse_Sso); ok {
		return x.Sso
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AuthenticateResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AuthenticateResponse_Webauthn)(nil),
		(*AuthenticateResponse_Sso)(nil),
	}
}

// SSOChallenge contains SSO auth request details to perform an SSO MFA check.
type SSOChallenge struct {
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// redirect_url is an IdP redirect URL to initiate the SSO MFA flow.
	RedirectUrl string `protobuf:"bytes,2,opt,name=redirect_url,json=redirectUrl,proto3" json:"redirect_url,omitempty"`
	// device is the SSO device corresponding to the challenge.
	Device               *types.SSOMFADevice `protobuf:"bytes,3,opt,name=device,proto3" json:"device,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SSOChallenge) Reset()         { *m = SSOChallenge{} }
func (m *SSOChallenge) String() string { return proto.CompactTextString(m) }
func (*SSOChallenge) ProtoMessage()    {}
func (*SSOChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{7}
}
func (m *SSOChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSOChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSOChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSOChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSOChallenge.Merge(m, src)
}
func (m *SSOChallenge) XXX_Size() int {
	return m.Size()
}
func (m *SSOChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_SSOChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_SSOChallenge proto.InternalMessageInfo

func (m *SSOChallenge) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *SSOChallenge) GetRedirectUrl() string {
	if m != nil {
		return m.RedirectUrl
	}
	return ""
}

func (m *SSOChallenge) GetDevice() *types.SSOMFADevice {
	if m != nil {
		return m.Device
	}
	return nil
}

// SSOChallengeResponse is a response to SSOChallenge.
type SSOChallengeResponse struct {
	// request_id is the ID of an SSO auth request.
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// token is a secret token used to verify the user's SSO MFA session.
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSOChallengeResponse) Reset()         { *m = SSOChallengeResponse{} }
func (m *SSOChallengeResponse) String() string { return proto.CompactTextString(m) }
func (*SSOChallengeResponse) ProtoMessage()    {}
func (*SSOChallengeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb9e544d66a5853a, []int{8}
}
func (m *SSOChallengeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSOChallengeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSOChallengeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SSOChallengeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSOChallengeResponse.Merge(m, src)
}
func (m *SSOChallengeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SSOChallengeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SSOChallengeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SSOChallengeResponse proto.InternalMessageInfo

func (m *SSOChallengeResponse) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *SSOChallengeResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func init() {
	proto.RegisterEnum("teleport.mfa.v1.ChallengeScope", ChallengeScope_name, ChallengeScope_value)
	proto.RegisterEnum("teleport.mfa.v1.ChallengeAllowReuse", ChallengeAllowReuse_name, ChallengeAllowReuse_value)
	proto.RegisterType((*ChallengeExtensions)(nil), "teleport.mfa.v1.ChallengeExtensions")
	proto.RegisterType((*CreateChallengeForActionRequest)(nil), "teleport.mfa.v1.CreateChallengeForActionRequest")
	proto.RegisterType((*CreateChallengeForActionResponse)(nil), "teleport.mfa.v1.CreateChallengeForActionResponse")
	proto.RegisterType((*ValidateChallengeForActionRequest)(nil), "teleport.mfa.v1.ValidateChallengeForActionRequest")
	proto.RegisterType((*ValidateChallengeForActionResponse)(nil), "teleport.mfa.v1.ValidateChallengeForActionResponse")
	proto.RegisterType((*AuthenticateChallenge)(nil), "teleport.mfa.v1.AuthenticateChallenge")
	proto.RegisterType((*AuthenticateResponse)(nil), "teleport.mfa.v1.AuthenticateResponse")
	proto.RegisterType((*SSOChallenge)(nil), "teleport.mfa.v1.SSOChallenge")
	proto.RegisterType((*SSOChallengeResponse)(nil), "teleport.mfa.v1.SSOChallengeResponse")
}

func init() { proto.RegisterFile("teleport/mfa/v1/mfa.proto", fileDescriptor_eb9e544d66a5853a) }

var fileDescriptor_eb9e544d66a5853a = []byte{
	// 949 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4d, 0x73, 0xda, 0x46,
	0x18, 0x8e, 0xfc, 0x55, 0xf3, 0x62, 0xa7, 0x74, 0x43, 0xa6, 0x18, 0x07, 0x1b, 0x2b, 0x71, 0xc6,
	0x93, 0x4e, 0xa1, 0x26, 0x93, 0x43, 0xa7, 0x27, 0x59, 0xac, 0x0d, 0x13, 0x8c, 0x3c, 0xda, 0x98,
	0x4c, 0x7a, 0xd1, 0xac, 0x61, 0xc1, 0x9a, 0x0a, 0x89, 0xee, 0x0a, 0x12, 0x1f, 0x3a, 0x39, 0xf5,
	0xd6, 0x6b, 0xaf, 0x3d, 0xf4, 0xd6, 0x4b, 0x7f, 0x47, 0x67, 0x7a, 0xe9, 0xad, 0xd7, 0x8e, 0x7f,
	0x49, 0x47, 0x9f, 0x60, 0x21, 0x48, 0xd3, 0x0b, 0xac, 0xde, 0xf7, 0x79, 0x76, 0x9f, 0x7d, 0x9f,
	0xfd, 0x82, 0x1d, 0x97, 0x59, 0x6c, 0xe4, 0x70, 0xb7, 0x3a, 0xec, 0xd3, 0xea, 0xe4, 0xd8, 0xfb,
	0xab, 0x8c, 0xb8, 0xe3, 0x3a, 0xe8, 0xd3, 0x28, 0x55, 0xf1, 0x62, 0x93, 0xe3, 0x62, 0x7e, 0xe0,
	0x0c, 0x1c, 0x3f, 0x57, 0xf5, 0x5a, 0x01, 0xac, 0x78, 0x10, 0xf7, 0x60, 0xb1, 0x01, 0xed, 0xde,
	0x54, 0xdd, 0x9b, 0x11, 0x13, 0xc1, 0x6f, 0x08, 0xf9, 0x32, 0x1d, 0xf2, 0x96, 0x5d, 0xd1, 0xb1,
	0x7b, 0x6d, 0xc7, 0x8d, 0x00, 0x2e, 0xff, 0x2d, 0xc1, 0x03, 0xf5, 0x9a, 0x5a, 0x16, 0xb3, 0x07,
	0x0c, 0xbf, 0x73, 0x99, 0x2d, 0x4c, 0xc7, 0x16, 0xe8, 0x05, 0xac, 0x8b, 0xae, 0x33, 0x62, 0x05,
	0xa9, 0x2c, 0x1d, 0xdd, 0xaf, 0xed, 0x57, 0x12, 0x02, 0x2b, 0x31, 0x89, 0x78, 0x30, 0x3d, 0x40,
	0x23, 0x0c, 0x59, 0x6a, 0x59, 0xce, 0x5b, 0x83, 0xb3, 0xb1, 0x60, 0x85, 0x15, 0x9f, 0xfc, 0x64,
	0x31, 0x59, 0xf1, 0xc0, 0xba, 0x87, 0xd5, 0x81, 0xc6, 0x6d, 0x74, 0x02, 0xa5, 0xb1, 0x60, 0xdc,
	0x98, 0x30, 0x6e, 0xf6, 0xcd, 0x2e, 0x75, 0x4d, 0xc7, 0x36, 0x38, 0xfb, 0x7e, 0x6c, 0x72, 0x36,
	0x64, 0xb6, 0x5b, 0x58, 0x2d, 0x4b, 0x47, 0x19, 0x7d, 0xd7, 0x03, 0x75, 0x66, 0x30, 0xfa, 0x14,
	0x22, 0xff, 0x2e, 0xc1, 0xbe, 0xca, 0x19, 0x75, 0x59, 0x3c, 0xda, 0xa9, 0xc3, 0x95, 0x6e, 0x84,
	0x63, 0xc2, 0x45, 0xbb, 0x90, 0xa1, 0x7e, 0xc0, 0x30, 0x7b, 0xfe, 0x4c, 0x33, 0xfa, 0x66, 0x10,
	0x68, 0xf6, 0x10, 0x82, 0x35, 0xaf, 0x7f, 0x7f, 0x12, 0x19, 0xdd, 0x6f, 0xa3, 0x17, 0xf0, 0xb9,
	0x10, 0x8e, 0xd1, 0xb5, 0x4c, 0x66, 0xbb, 0x06, 0x67, 0x3d, 0x93, 0xb3, 0xae, 0x6b, 0x8c, 0xb9,
	0x15, 0x4a, 0xca, 0x0b, 0xe1, 0xa8, 0x7e, 0x56, 0x0f, 0x93, 0x97, 0xdc, 0x42, 0x8f, 0x61, 0x7b,
	0xc4, 0x9d, 0x77, 0x37, 0x06, 0xed, 0xf5, 0x38, 0x13, 0xa2, 0xb0, 0xe6, 0x83, 0xb7, 0xfc, 0xa0,
	0x12, 0xc4, 0xe4, 0x9f, 0x24, 0x28, 0x2f, 0x16, 0x2c, 0x46, 0x8e, 0x2d, 0xd8, 0x72, 0xc5, 0x2f,
	0x61, 0x7b, 0xd8, 0xa7, 0x46, 0x37, 0xa2, 0xfb, 0xd2, 0xb3, 0xb5, 0xa7, 0x73, 0xf5, 0x57, 0xc6,
	0xee, 0x35, 0xb3, 0x5d, 0xaf, 0x6a, 0xd3, 0xc1, 0xf4, 0xad, 0x61, 0x9f, 0xc6, 0x5f, 0xf2, 0x2f,
	0x12, 0x1c, 0x74, 0xa8, 0x65, 0xf6, 0xfe, 0x7f, 0x05, 0x1b, 0xe0, 0x75, 0x69, 0xf0, 0x50, 0x7c,
	0x28, 0xe7, 0x70, 0xa9, 0x9c, 0x68, 0xa6, 0x7a, 0x76, 0xd8, 0xa7, 0xf1, 0xb4, 0x23, 0x2f, 0x56,
	0xa7, 0x5e, 0xc8, 0xef, 0x41, 0x5e, 0xa6, 0xef, 0xbf, 0x14, 0x2c, 0xcd, 0xe2, 0x23, 0xd8, 0xe8,
	0xb1, 0x89, 0xd9, 0x65, 0xfe, 0x60, 0xd9, 0x5a, 0xae, 0x12, 0x6c, 0xaf, 0xf3, 0x53, 0xa5, 0xee,
	0xc7, 0xf5, 0x30, 0x2f, 0xff, 0x26, 0xc1, 0xc3, 0xd4, 0x4a, 0xa2, 0x16, 0xa0, 0x68, 0x9f, 0xcd,
	0xb8, 0x21, 0xf9, 0xfd, 0x95, 0x2a, 0xf1, 0x16, 0x54, 0x39, 0xeb, 0x79, 0x64, 0x6a, 0x29, 0x42,
	0x30, 0xee, 0xeb, 0xfe, 0x2c, 0xca, 0x4e, 0x7b, 0x3b, 0x81, 0x6d, 0x7f, 0xd1, 0x25, 0x6c, 0x2d,
	0xcd, 0xd5, 0x91, 0x10, 0x6d, 0xc6, 0x4d, 0x6f, 0x25, 0xc6, 0x6e, 0xfe, 0x2a, 0x41, 0x3e, 0xad,
	0xcc, 0x48, 0x85, 0xcd, 0x68, 0xc4, 0x50, 0xe0, 0xe1, 0x72, 0x81, 0x21, 0xb1, 0x71, 0x4f, 0x8f,
	0x89, 0xe8, 0x6b, 0x58, 0x15, 0xc2, 0x59, 0xe8, 0xef, 0x1d, 0x5d, 0x53, 0xbe, 0xc7, 0x39, 0x01,
	0xd8, 0x8c, 0xd6, 0x87, 0xfc, 0x03, 0x6c, 0xcd, 0x42, 0x51, 0x09, 0x80, 0x07, 0xeb, 0x6c, 0x6a,
	0x5e, 0x26, 0x8c, 0x34, 0x7b, 0xe8, 0x00, 0xb6, 0xee, 0xec, 0xc0, 0xc0, 0xc5, 0x2c, 0x9f, 0xd9,
	0x78, 0x5f, 0x24, 0xcc, 0x7c, 0x10, 0x9a, 0x49, 0x88, 0x36, 0xef, 0xe7, 0x4b, 0xc8, 0xa7, 0x29,
	0xfd, 0x90, 0x8c, 0x3c, 0xac, 0xbb, 0xce, 0x77, 0xcc, 0x0e, 0xc7, 0x0f, 0x3e, 0x9e, 0xfd, 0xb9,
	0x02, 0xf7, 0xef, 0x9e, 0x91, 0x68, 0x1f, 0x76, 0xd5, 0x86, 0xd2, 0x6a, 0xe1, 0xf6, 0x19, 0x36,
	0x88, 0xaa, 0x5d, 0x60, 0xe3, 0xb2, 0x4d, 0x2e, 0xb0, 0xda, 0x3c, 0x6d, 0xe2, 0x7a, 0xee, 0x1e,
	0xda, 0x81, 0x87, 0x49, 0x40, 0x4b, 0x3b, 0x6b, 0xb6, 0x73, 0x12, 0x7a, 0x0a, 0x72, 0x32, 0x75,
	0xa1, 0x10, 0xf2, 0x5a, 0xd3, 0xeb, 0x2d, 0x4c, 0x48, 0x88, 0x5b, 0x41, 0x32, 0xec, 0x25, 0x71,
	0x0d, 0xac, 0xcc, 0x62, 0x56, 0xd3, 0x30, 0xe7, 0x4a, 0x5b, 0x39, 0xc3, 0x46, 0x1d, 0x77, 0x9a,
	0x2a, 0x26, 0xb9, 0x35, 0xf4, 0x04, 0xca, 0x49, 0x8c, 0xa2, 0xaa, 0xda, 0x65, 0xfb, 0x95, 0xa1,
	0x63, 0x55, 0xeb, 0x60, 0xfd, 0x4d, 0x6e, 0x1d, 0x95, 0xe1, 0xd1, 0xdc, 0x8c, 0x08, 0xd6, 0x0d,
	0x82, 0x09, 0x69, 0x6a, 0xed, 0xdc, 0x46, 0x1a, 0x42, 0xa9, 0x9f, 0x37, 0xdb, 0x86, 0xa2, 0xbe,
	0xf2, 0x10, 0x9f, 0xa0, 0xc7, 0xb0, 0x9f, 0x44, 0xa8, 0x0d, 0xc5, 0xfb, 0x88, 0x26, 0x98, 0xdb,
	0x7c, 0x76, 0x33, 0x73, 0x4b, 0x4d, 0xef, 0x0c, 0x74, 0x08, 0x07, 0x53, 0xae, 0xd2, 0x6a, 0x69,
	0xaf, 0x0d, 0x1d, 0x5f, 0x92, 0x64, 0x5d, 0x4b, 0xb0, 0x93, 0x0e, 0x7b, 0x83, 0x49, 0x4e, 0x42,
	0x8f, 0xa0, 0x90, 0x9e, 0x6e, 0x6b, 0xb9, 0x95, 0xda, 0xcf, 0x2b, 0x00, 0xe7, 0xa7, 0x0a, 0x61,
	0xdc, 0x5b, 0x24, 0xe8, 0x3d, 0x14, 0x16, 0x1d, 0xd2, 0xe8, 0xab, 0xf9, 0x8b, 0x6e, 0xf9, 0x05,
	0x54, 0x3c, 0xfe, 0x08, 0x46, 0xb8, 0x1a, 0x7f, 0x94, 0xa0, 0xb8, 0xf8, 0xdc, 0x43, 0xb5, 0xb9,
	0x1e, 0x3f, 0x78, 0x88, 0x17, 0x9f, 0x7f, 0x14, 0x27, 0xd0, 0x71, 0xd2, 0xf9, 0xe3, 0x76, 0x4f,
	0xfa, 0xeb, 0x76, 0x4f, 0xfa, 0xe7, 0x76, 0x4f, 0xfa, 0xb6, 0x31, 0x30, 0xdd, 0xeb, 0xf1, 0x55,
	0xa5, 0xeb, 0x0c, 0xab, 0x03, 0x4e, 0x27, 0xa6, 0xeb, 0x5f, 0xc8, 0xd4, 0xaa, 0xc6, 0xef, 0x11,
	0x3a, 0x32, 0xab, 0x03, 0x66, 0x57, 0xa3, 0x57, 0x4d, 0x35, 0xf1, 0x1c, 0xfa, 0x66, 0xd8, 0xa7,
	0x93, 0xe3, 0xab, 0x0d, 0x3f, 0xff, 0xfc, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x55, 0x36, 0x1f,
	0x69, 0x2e, 0x09, 0x00, 0x00,
}

func (m *ChallengeExtensions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeExtensions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeExtensions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserVerificationRequirement) > 0 {
		i -= len(m.UserVerificationRequirement)
		copy(dAtA[i:], m.UserVerificationRequirement)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.UserVerificationRequirement)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AllowReuse != 0 {
		i = encodeVarintMfa(dAtA, i, uint64(m.AllowReuse))
		i--
		dAtA[i] = 0x10
	}
	if m.Scope != 0 {
		i = encodeVarintMfa(dAtA, i, uint64(m.Scope))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateChallengeForActionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateChallengeForActionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateChallengeForActionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyAddress) > 0 {
		i -= len(m.ProxyAddress)
		copy(dAtA[i:], m.ProxyAddress)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.ProxyAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SsoClientRedirectUrl) > 0 {
		i -= len(m.SsoClientRedirectUrl)
		copy(dAtA[i:], m.SsoClientRedirectUrl)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.SsoClientRedirectUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateChallengeForActionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateChallengeForActionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateChallengeForActionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MfaChallenge != nil {
		{
			size, err := m.MfaChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateChallengeForActionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateChallengeForActionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateChallengeForActionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MfaResponse != nil {
		{
			size, err := m.MfaResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateChallengeForActionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateChallengeForActionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateChallengeForActionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticateChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticateChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticateChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SsoChallenge != nil {
		{
			size, err := m.SsoChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.WebauthnChallenge != nil {
		{
			size, err := m.WebauthnChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticateResponse_Webauthn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticateResponse_Webauthn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Webauthn != nil {
		{
			size, err := m.Webauthn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AuthenticateResponse_Sso) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticateResponse_Sso) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sso != nil {
		{
			size, err := m.Sso.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SSOChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSOChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSOChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Device != nil {
		{
			size, err := m.Device.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMfa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RedirectUrl) > 0 {
		i -= len(m.RedirectUrl)
		copy(dAtA[i:], m.RedirectUrl)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.RedirectUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SSOChallengeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSOChallengeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SSOChallengeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintMfa(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMfa(dAtA []byte, offset int, v uint64) int {
	offset -= sovMfa(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChallengeExtensions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scope != 0 {
		n += 1 + sovMfa(uint64(m.Scope))
	}
	if m.AllowReuse != 0 {
		n += 1 + sovMfa(uint64(m.AllowReuse))
	}
	l = len(m.UserVerificationRequirement)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateChallengeForActionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	l = len(m.SsoClientRedirectUrl)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	l = len(m.ProxyAddress)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateChallengeForActionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.MfaChallenge != nil {
		l = m.MfaChallenge.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateChallengeForActionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.MfaResponse != nil {
		l = m.MfaResponse.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidateChallengeForActionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticateChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WebauthnChallenge != nil {
		l = m.WebauthnChallenge.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.SsoChallenge != nil {
		l = m.SsoChallenge.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticateResponse_Webauthn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Webauthn != nil {
		l = m.Webauthn.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	return n
}
func (m *AuthenticateResponse_Sso) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sso != nil {
		l = m.Sso.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	return n
}
func (m *SSOChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	l = len(m.RedirectUrl)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SSOChallengeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovMfa(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMfa(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMfa(x uint64) (n int) {
	return sovMfa(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChallengeExtensions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeExtensions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeExtensions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			m.Scope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scope |= ChallengeScope(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowReuse", wireType)
			}
			m.AllowReuse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowReuse |= ChallengeAllowReuse(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVerificationRequirement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserVerificationRequirement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateChallengeForActionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateChallengeForActionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateChallengeForActionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsoClientRedirectUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SsoClientRedirectUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateChallengeForActionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateChallengeForActionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateChallengeForActionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MfaChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MfaChallenge == nil {
				m.MfaChallenge = &AuthenticateChallenge{}
			}
			if err := m.MfaChallenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateChallengeForActionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateChallengeForActionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateChallengeForActionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MfaResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MfaResponse == nil {
				m.MfaResponse = &AuthenticateResponse{}
			}
			if err := m.MfaResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateChallengeForActionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateChallengeForActionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateChallengeForActionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &types.MFADevice{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticateChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticateChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticateChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebauthnChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebauthnChallenge == nil {
				m.WebauthnChallenge = &webauthn.CredentialAssertion{}
			}
			if err := m.WebauthnChallenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SsoChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SsoChallenge == nil {
				m.SsoChallenge = &SSOChallenge{}
			}
			if err := m.SsoChallenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Webauthn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &webauthn.CredentialAssertionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &AuthenticateResponse_Webauthn{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sso", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSOChallengeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &AuthenticateResponse_Sso{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSOChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSOChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSOChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &types.SSOMFADevice{}
			}
			if err := m.Device.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSOChallengeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSOChallengeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSOChallengeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMfa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMfa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMfa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMfa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMfa(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMfa
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMfa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMfa
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMfa
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMfa
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMfa        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMfa          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMfa = fmt.Errorf("proto: unexpected end of group")
)
