// Copyright 2025 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: teleport/transport/v2/transport_service.proto

package transportv2

import (
	proto "github.com/gravitational/teleport/api/client/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Request for ProxySSH
//
// In order for proxying to begin the client must send either an MFAAuthenticateResponse (if MFA is required) or a
// TargetHost (if MFA is not required) as the first message. Creating the stream doesn't actually open the SSH
// connection. Any attempts to exchange SSH or agent frames prior to the client sending one of these initial messages
// will result in the stream being terminated.
type ProxySSHRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Only one of these fields should be set per message.
	// - If MFA is required, client sends MFAAuthenticateResponse after receiving challenge.
	// - If MFA is not required, client sends dial_target directly.
	// - After connection is established, client sends SSH or agent frames as raw bytes.
	//
	// Validation: The server MUST validate that exactly one field in the oneof payload is set per message.
	// If zero or more than one field is set, the server MUST reject the message and terminate the stream with an error.
	//
	// Types that are valid to be assigned to Payload:
	//
	//	*ProxySSHRequest_MfaResponse
	//	*ProxySSHRequest_DialTarget
	//	*ProxySSHRequest_Ssh
	//	*ProxySSHRequest_Agent
	Payload       isProxySSHRequest_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxySSHRequest) Reset() {
	*x = ProxySSHRequest{}
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxySSHRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxySSHRequest) ProtoMessage() {}

func (x *ProxySSHRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxySSHRequest.ProtoReflect.Descriptor instead.
func (*ProxySSHRequest) Descriptor() ([]byte, []int) {
	return file_teleport_transport_v2_transport_service_proto_rawDescGZIP(), []int{0}
}

func (x *ProxySSHRequest) GetPayload() isProxySSHRequest_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ProxySSHRequest) GetMfaResponse() *proto.MFAAuthenticateResponse {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHRequest_MfaResponse); ok {
			return x.MfaResponse
		}
	}
	return nil
}

func (x *ProxySSHRequest) GetDialTarget() *TargetHost {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHRequest_DialTarget); ok {
			return x.DialTarget
		}
	}
	return nil
}

func (x *ProxySSHRequest) GetSsh() *Frame {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHRequest_Ssh); ok {
			return x.Ssh
		}
	}
	return nil
}

func (x *ProxySSHRequest) GetAgent() *Frame {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHRequest_Agent); ok {
			return x.Agent
		}
	}
	return nil
}

type isProxySSHRequest_Payload interface {
	isProxySSHRequest_Payload()
}

type ProxySSHRequest_MfaResponse struct {
	MfaResponse *proto.MFAAuthenticateResponse `protobuf:"bytes,1,opt,name=mfa_response,json=mfaResponse,proto3,oneof"` // Sent by client after receiving MFA challenge (if required)
}

type ProxySSHRequest_DialTarget struct {
	DialTarget *TargetHost `protobuf:"bytes,2,opt,name=dial_target,json=dialTarget,proto3,oneof"` // Sent by client after successful MFA or if MFA is not required
}

type ProxySSHRequest_Ssh struct {
	Ssh *Frame `protobuf:"bytes,3,opt,name=ssh,proto3,oneof"` // SSH payload
}

type ProxySSHRequest_Agent struct {
	Agent *Frame `protobuf:"bytes,4,opt,name=agent,proto3,oneof"` // SSH Agent payload
}

func (*ProxySSHRequest_MfaResponse) isProxySSHRequest_Payload() {}

func (*ProxySSHRequest_DialTarget) isProxySSHRequest_Payload() {}

func (*ProxySSHRequest_Ssh) isProxySSHRequest_Payload() {}

func (*ProxySSHRequest_Agent) isProxySSHRequest_Payload() {}

// Response for ProxySSH
//
// The first message from the server will be either an MFAAuthenticateChallenge (if MFA is required) or ClusterDetails
// (if MFA is not required). After any required MFA, the server will send ClusterDetails and then SSH/agent frames as
// raw bytes.
type ProxySSHResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Only one of these fields will be set per message.
	// The first message from the server will be:
	// - MFAAuthenticateChallenge if MFA is required (client must respond with MFAAuthenticateResponse)
	// - ClusterDetails if MFA is not required (client can send dial_target immediately)
	// After MFA (or if not required), server sends ClusterDetails and then SSH/agent frames.
	//
	// Types that are valid to be assigned to Payload:
	//
	//	*ProxySSHResponse_MfaChallenge
	//	*ProxySSHResponse_Details
	//	*ProxySSHResponse_Ssh
	//	*ProxySSHResponse_Agent
	Payload       isProxySSHResponse_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProxySSHResponse) Reset() {
	*x = ProxySSHResponse{}
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProxySSHResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProxySSHResponse) ProtoMessage() {}

func (x *ProxySSHResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProxySSHResponse.ProtoReflect.Descriptor instead.
func (*ProxySSHResponse) Descriptor() ([]byte, []int) {
	return file_teleport_transport_v2_transport_service_proto_rawDescGZIP(), []int{1}
}

func (x *ProxySSHResponse) GetPayload() isProxySSHResponse_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ProxySSHResponse) GetMfaChallenge() *proto.MFAAuthenticateChallenge {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHResponse_MfaChallenge); ok {
			return x.MfaChallenge
		}
	}
	return nil
}

func (x *ProxySSHResponse) GetDetails() *ClusterDetails {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHResponse_Details); ok {
			return x.Details
		}
	}
	return nil
}

func (x *ProxySSHResponse) GetSsh() *Frame {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHResponse_Ssh); ok {
			return x.Ssh
		}
	}
	return nil
}

func (x *ProxySSHResponse) GetAgent() *Frame {
	if x != nil {
		if x, ok := x.Payload.(*ProxySSHResponse_Agent); ok {
			return x.Agent
		}
	}
	return nil
}

type isProxySSHResponse_Payload interface {
	isProxySSHResponse_Payload()
}

type ProxySSHResponse_MfaChallenge struct {
	MfaChallenge *proto.MFAAuthenticateChallenge `protobuf:"bytes,1,opt,name=mfa_challenge,json=mfaChallenge,proto3,oneof"` // Sent by server as first message if MFA is required
}

type ProxySSHResponse_Details struct {
	Details *ClusterDetails `protobuf:"bytes,2,opt,name=details,proto3,oneof"` // Sent by server as first message if MFA is not required, and after MFA if required
}

type ProxySSHResponse_Ssh struct {
	Ssh *Frame `protobuf:"bytes,3,opt,name=ssh,proto3,oneof"` // SSH payload
}

type ProxySSHResponse_Agent struct {
	Agent *Frame `protobuf:"bytes,4,opt,name=agent,proto3,oneof"` // SSH Agent payload
}

func (*ProxySSHResponse_MfaChallenge) isProxySSHResponse_Payload() {}

func (*ProxySSHResponse_Details) isProxySSHResponse_Payload() {}

func (*ProxySSHResponse_Ssh) isProxySSHResponse_Payload() {}

func (*ProxySSHResponse_Agent) isProxySSHResponse_Payload() {}

// Encapsulates protocol specific payloads
type Frame struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The raw packet of data
	Payload       []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Frame) Reset() {
	*x = Frame{}
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Frame) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Frame) ProtoMessage() {}

func (x *Frame) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Frame.ProtoReflect.Descriptor instead.
func (*Frame) Descriptor() ([]byte, []int) {
	return file_teleport_transport_v2_transport_service_proto_rawDescGZIP(), []int{2}
}

func (x *Frame) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// TargetHost indicates which server the connection is for
type TargetHost struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The hostname/ip/uuid:port of the remote host.
	HostPort string `protobuf:"bytes,1,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	// The cluster the server is a member of
	Cluster string `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// The OS login name to use when connecting to the host.
	LoginName     string `protobuf:"bytes,3,opt,name=login_name,json=loginName,proto3" json:"login_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TargetHost) Reset() {
	*x = TargetHost{}
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TargetHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TargetHost) ProtoMessage() {}

func (x *TargetHost) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TargetHost.ProtoReflect.Descriptor instead.
func (*TargetHost) Descriptor() ([]byte, []int) {
	return file_teleport_transport_v2_transport_service_proto_rawDescGZIP(), []int{3}
}

func (x *TargetHost) GetHostPort() string {
	if x != nil {
		return x.HostPort
	}
	return ""
}

func (x *TargetHost) GetCluster() string {
	if x != nil {
		return x.Cluster
	}
	return ""
}

func (x *TargetHost) GetLoginName() string {
	if x != nil {
		return x.LoginName
	}
	return ""
}

// ClusterDetails contains cluster configuration information
type ClusterDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If the cluster is running in FIPS mode
	FipsEnabled   bool `protobuf:"varint,1,opt,name=fips_enabled,json=fipsEnabled,proto3" json:"fips_enabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterDetails) Reset() {
	*x = ClusterDetails{}
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterDetails) ProtoMessage() {}

func (x *ClusterDetails) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_transport_v2_transport_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterDetails.ProtoReflect.Descriptor instead.
func (*ClusterDetails) Descriptor() ([]byte, []int) {
	return file_teleport_transport_v2_transport_service_proto_rawDescGZIP(), []int{4}
}

func (x *ClusterDetails) GetFipsEnabled() bool {
	if x != nil {
		return x.FipsEnabled
	}
	return false
}

var File_teleport_transport_v2_transport_service_proto protoreflect.FileDescriptor

const file_teleport_transport_v2_transport_service_proto_rawDesc = "" +
	"\n" +
	"-teleport/transport/v2/transport_service.proto\x12\x15teleport.transport.v2\x1a.teleport/legacy/client/proto/authservice.proto\"\x8f\x02\n" +
	"\x0fProxySSHRequest\x12C\n" +
	"\fmfa_response\x18\x01 \x01(\v2\x1e.proto.MFAAuthenticateResponseH\x00R\vmfaResponse\x12D\n" +
	"\vdial_target\x18\x02 \x01(\v2!.teleport.transport.v2.TargetHostH\x00R\n" +
	"dialTarget\x120\n" +
	"\x03ssh\x18\x03 \x01(\v2\x1c.teleport.transport.v2.FrameH\x00R\x03ssh\x124\n" +
	"\x05agent\x18\x04 \x01(\v2\x1c.teleport.transport.v2.FrameH\x00R\x05agentB\t\n" +
	"\apayload\"\x90\x02\n" +
	"\x10ProxySSHResponse\x12F\n" +
	"\rmfa_challenge\x18\x01 \x01(\v2\x1f.proto.MFAAuthenticateChallengeH\x00R\fmfaChallenge\x12A\n" +
	"\adetails\x18\x02 \x01(\v2%.teleport.transport.v2.ClusterDetailsH\x00R\adetails\x120\n" +
	"\x03ssh\x18\x03 \x01(\v2\x1c.teleport.transport.v2.FrameH\x00R\x03ssh\x124\n" +
	"\x05agent\x18\x04 \x01(\v2\x1c.teleport.transport.v2.FrameH\x00R\x05agentB\t\n" +
	"\apayload\"!\n" +
	"\x05Frame\x12\x18\n" +
	"\apayload\x18\x01 \x01(\fR\apayload\"b\n" +
	"\n" +
	"TargetHost\x12\x1b\n" +
	"\thost_port\x18\x01 \x01(\tR\bhostPort\x12\x18\n" +
	"\acluster\x18\x02 \x01(\tR\acluster\x12\x1d\n" +
	"\n" +
	"login_name\x18\x03 \x01(\tR\tloginName\"3\n" +
	"\x0eClusterDetails\x12!\n" +
	"\ffips_enabled\x18\x01 \x01(\bR\vfipsEnabled2s\n" +
	"\x10TransportService\x12_\n" +
	"\bProxySSH\x12&.teleport.transport.v2.ProxySSHRequest\x1a'.teleport.transport.v2.ProxySSHResponse(\x010\x01BVZTgithub.com/gravitational/teleport/api/gen/proto/go/teleport/transport/v2;transportv2b\x06proto3"

var (
	file_teleport_transport_v2_transport_service_proto_rawDescOnce sync.Once
	file_teleport_transport_v2_transport_service_proto_rawDescData []byte
)

func file_teleport_transport_v2_transport_service_proto_rawDescGZIP() []byte {
	file_teleport_transport_v2_transport_service_proto_rawDescOnce.Do(func() {
		file_teleport_transport_v2_transport_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_teleport_transport_v2_transport_service_proto_rawDesc), len(file_teleport_transport_v2_transport_service_proto_rawDesc)))
	})
	return file_teleport_transport_v2_transport_service_proto_rawDescData
}

var file_teleport_transport_v2_transport_service_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_teleport_transport_v2_transport_service_proto_goTypes = []any{
	(*ProxySSHRequest)(nil),                // 0: teleport.transport.v2.ProxySSHRequest
	(*ProxySSHResponse)(nil),               // 1: teleport.transport.v2.ProxySSHResponse
	(*Frame)(nil),                          // 2: teleport.transport.v2.Frame
	(*TargetHost)(nil),                     // 3: teleport.transport.v2.TargetHost
	(*ClusterDetails)(nil),                 // 4: teleport.transport.v2.ClusterDetails
	(*proto.MFAAuthenticateResponse)(nil),  // 5: proto.MFAAuthenticateResponse
	(*proto.MFAAuthenticateChallenge)(nil), // 6: proto.MFAAuthenticateChallenge
}
var file_teleport_transport_v2_transport_service_proto_depIdxs = []int32{
	5, // 0: teleport.transport.v2.ProxySSHRequest.mfa_response:type_name -> proto.MFAAuthenticateResponse
	3, // 1: teleport.transport.v2.ProxySSHRequest.dial_target:type_name -> teleport.transport.v2.TargetHost
	2, // 2: teleport.transport.v2.ProxySSHRequest.ssh:type_name -> teleport.transport.v2.Frame
	2, // 3: teleport.transport.v2.ProxySSHRequest.agent:type_name -> teleport.transport.v2.Frame
	6, // 4: teleport.transport.v2.ProxySSHResponse.mfa_challenge:type_name -> proto.MFAAuthenticateChallenge
	4, // 5: teleport.transport.v2.ProxySSHResponse.details:type_name -> teleport.transport.v2.ClusterDetails
	2, // 6: teleport.transport.v2.ProxySSHResponse.ssh:type_name -> teleport.transport.v2.Frame
	2, // 7: teleport.transport.v2.ProxySSHResponse.agent:type_name -> teleport.transport.v2.Frame
	0, // 8: teleport.transport.v2.TransportService.ProxySSH:input_type -> teleport.transport.v2.ProxySSHRequest
	1, // 9: teleport.transport.v2.TransportService.ProxySSH:output_type -> teleport.transport.v2.ProxySSHResponse
	9, // [9:10] is the sub-list for method output_type
	8, // [8:9] is the sub-list for method input_type
	8, // [8:8] is the sub-list for extension type_name
	8, // [8:8] is the sub-list for extension extendee
	0, // [0:8] is the sub-list for field type_name
}

func init() { file_teleport_transport_v2_transport_service_proto_init() }
func file_teleport_transport_v2_transport_service_proto_init() {
	if File_teleport_transport_v2_transport_service_proto != nil {
		return
	}
	file_teleport_transport_v2_transport_service_proto_msgTypes[0].OneofWrappers = []any{
		(*ProxySSHRequest_MfaResponse)(nil),
		(*ProxySSHRequest_DialTarget)(nil),
		(*ProxySSHRequest_Ssh)(nil),
		(*ProxySSHRequest_Agent)(nil),
	}
	file_teleport_transport_v2_transport_service_proto_msgTypes[1].OneofWrappers = []any{
		(*ProxySSHResponse_MfaChallenge)(nil),
		(*ProxySSHResponse_Details)(nil),
		(*ProxySSHResponse_Ssh)(nil),
		(*ProxySSHResponse_Agent)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_teleport_transport_v2_transport_service_proto_rawDesc), len(file_teleport_transport_v2_transport_service_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_teleport_transport_v2_transport_service_proto_goTypes,
		DependencyIndexes: file_teleport_transport_v2_transport_service_proto_depIdxs,
		MessageInfos:      file_teleport_transport_v2_transport_service_proto_msgTypes,
	}.Build()
	File_teleport_transport_v2_transport_service_proto = out.File
	file_teleport_transport_v2_transport_service_proto_goTypes = nil
	file_teleport_transport_v2_transport_service_proto_depIdxs = nil
}
