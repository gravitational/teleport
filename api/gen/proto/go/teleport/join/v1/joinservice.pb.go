// Copyright 2025 Gravitational, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: teleport/join/v1/joinservice.proto

package joinv1

import (
	v1 "github.com/gravitational/teleport/api/gen/proto/go/teleport/scopes/joining/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Reason is the reason the client is giving up.
type GivingUp_Reason int32

const (
	// REASON_UNSPECIFIED is an unspecified reason.
	GivingUp_REASON_UNSPECIFIED GivingUp_Reason = 0
	// REASON_UNSUPPORTED_JOIN_METHOD means the client does not support the
	// join method sent by the server.
	GivingUp_REASON_UNSUPPORTED_JOIN_METHOD GivingUp_Reason = 1
	// REASON_UNSUPPORTED_MESSAGE_TYPE means the client can not handle a
	// message type sent by the server.
	GivingUp_REASON_UNSUPPORTED_MESSAGE_TYPE GivingUp_Reason = 2
	// REASON_CHALLENGE_SOLUTION_FAILED means the client failed to solve a
	// challenge sent by the server.
	GivingUp_REASON_CHALLENGE_SOLUTION_FAILED GivingUp_Reason = 3
)

// Enum value maps for GivingUp_Reason.
var (
	GivingUp_Reason_name = map[int32]string{
		0: "REASON_UNSPECIFIED",
		1: "REASON_UNSUPPORTED_JOIN_METHOD",
		2: "REASON_UNSUPPORTED_MESSAGE_TYPE",
		3: "REASON_CHALLENGE_SOLUTION_FAILED",
	}
	GivingUp_Reason_value = map[string]int32{
		"REASON_UNSPECIFIED":               0,
		"REASON_UNSUPPORTED_JOIN_METHOD":   1,
		"REASON_UNSUPPORTED_MESSAGE_TYPE":  2,
		"REASON_CHALLENGE_SOLUTION_FAILED": 3,
	}
)

func (x GivingUp_Reason) Enum() *GivingUp_Reason {
	p := new(GivingUp_Reason)
	*p = x
	return p
}

func (x GivingUp_Reason) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GivingUp_Reason) Descriptor() protoreflect.EnumDescriptor {
	return file_teleport_join_v1_joinservice_proto_enumTypes[0].Descriptor()
}

func (GivingUp_Reason) Type() protoreflect.EnumType {
	return &file_teleport_join_v1_joinservice_proto_enumTypes[0]
}

func (x GivingUp_Reason) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GivingUp_Reason.Descriptor instead.
func (GivingUp_Reason) EnumDescriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{27, 0}
}

// ClientInit is the first message sent from the client during the join process, it
// holds parameters common to all join methods.
type ClientInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// JoinMethod is the name of the join method that the client is configured to use.
	// This parameter is optional, the client can leave it empty to allow the
	// server to determine the join method based on the provision token named by
	// TokenName, it will be sent to the client in the ServerInit message.
	JoinMethod *string `protobuf:"bytes,1,opt,name=join_method,json=joinMethod,proto3,oneof" json:"join_method,omitempty"`
	// TokenName is the name of the join token.
	// This is a secret if using the token join method, otherwise it is a
	// non-secret name of a provision token resource.
	TokenName string `protobuf:"bytes,2,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`
	// SystemRole is the system role requested, e.g. Proxy, Node, Instance, Bot.
	SystemRole string `protobuf:"bytes,3,opt,name=system_role,json=systemRole,proto3" json:"system_role,omitempty"`
	// ForwardedByProxy will be set to true when the message is forwarded by the
	// Proxy service. When this is set the Auth service must ignore any
	// any credentials authenticating the request, except for the purpose of
	// accepting ProxySuppliedParams.
	ForwardedByProxy        bool                            `protobuf:"varint,4,opt,name=forwarded_by_proxy,json=forwardedByProxy,proto3" json:"forwarded_by_proxy,omitempty"`
	ProxySuppliedParameters *ClientInit_ProxySuppliedParams `protobuf:"bytes,5,opt,name=proxy_supplied_parameters,json=proxySuppliedParameters,proto3,oneof" json:"proxy_supplied_parameters,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ClientInit) Reset() {
	*x = ClientInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientInit) ProtoMessage() {}

func (x *ClientInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientInit.ProtoReflect.Descriptor instead.
func (*ClientInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{0}
}

func (x *ClientInit) GetJoinMethod() string {
	if x != nil && x.JoinMethod != nil {
		return *x.JoinMethod
	}
	return ""
}

func (x *ClientInit) GetTokenName() string {
	if x != nil {
		return x.TokenName
	}
	return ""
}

func (x *ClientInit) GetSystemRole() string {
	if x != nil {
		return x.SystemRole
	}
	return ""
}

func (x *ClientInit) GetForwardedByProxy() bool {
	if x != nil {
		return x.ForwardedByProxy
	}
	return false
}

func (x *ClientInit) GetProxySuppliedParameters() *ClientInit_ProxySuppliedParams {
	if x != nil {
		return x.ProxySuppliedParameters
	}
	return nil
}

// PublicKeys holds public keys sent by the client requested subject keys for
// issued certificates.
type PublicKeys struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// PublicTlsKey is the public key requested for the subject of the x509 certificate.
	// It must be encoded in PKIX, ASN.1 DER form.
	PublicTlsKey []byte `protobuf:"bytes,1,opt,name=public_tls_key,json=publicTlsKey,proto3" json:"public_tls_key,omitempty"`
	// PublicSshKey is the public key requested for the subject of the SSH certificate.
	// It must be encoded in SSH wire format.
	PublicSshKey  []byte `protobuf:"bytes,2,opt,name=public_ssh_key,json=publicSshKey,proto3" json:"public_ssh_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicKeys) Reset() {
	*x = PublicKeys{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicKeys) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKeys) ProtoMessage() {}

func (x *PublicKeys) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKeys.ProtoReflect.Descriptor instead.
func (*PublicKeys) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{1}
}

func (x *PublicKeys) GetPublicTlsKey() []byte {
	if x != nil {
		return x.PublicTlsKey
	}
	return nil
}

func (x *PublicKeys) GetPublicSshKey() []byte {
	if x != nil {
		return x.PublicSshKey
	}
	return nil
}

// HostParams holds parameters required for host joining.
type HostParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// PublicKeys holds the host public keys.
	PublicKeys *PublicKeys `protobuf:"bytes,1,opt,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty"`
	// HostName is the user-friendly node name for the host. This comes from
	// teleport.nodename in the service configuration and defaults to the
	// hostname. It is encoded as a valid principal in issued certificates.
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// AdditionalPrincipals is a list of additional principals requested.
	AdditionalPrincipals []string `protobuf:"bytes,3,rep,name=additional_principals,json=additionalPrincipals,proto3" json:"additional_principals,omitempty"`
	// DnsNames is a list of DNS names requested for inclusion in the x509 certificate.
	DnsNames      []string `protobuf:"bytes,4,rep,name=dns_names,json=dnsNames,proto3" json:"dns_names,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HostParams) Reset() {
	*x = HostParams{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HostParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostParams) ProtoMessage() {}

func (x *HostParams) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostParams.ProtoReflect.Descriptor instead.
func (*HostParams) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{2}
}

func (x *HostParams) GetPublicKeys() *PublicKeys {
	if x != nil {
		return x.PublicKeys
	}
	return nil
}

func (x *HostParams) GetHostName() string {
	if x != nil {
		return x.HostName
	}
	return ""
}

func (x *HostParams) GetAdditionalPrincipals() []string {
	if x != nil {
		return x.AdditionalPrincipals
	}
	return nil
}

func (x *HostParams) GetDnsNames() []string {
	if x != nil {
		return x.DnsNames
	}
	return nil
}

// BotParams holds parameters required for bot joining.
type BotParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// PublicKeys holds the bot public keys.
	PublicKeys *PublicKeys `protobuf:"bytes,1,opt,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty"`
	// Expires is a desired time of the expiry of the returned certificates.
	Expires       *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=expires,proto3,oneof" json:"expires,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BotParams) Reset() {
	*x = BotParams{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BotParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BotParams) ProtoMessage() {}

func (x *BotParams) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BotParams.ProtoReflect.Descriptor instead.
func (*BotParams) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{3}
}

func (x *BotParams) GetPublicKeys() *PublicKeys {
	if x != nil {
		return x.PublicKeys
	}
	return nil
}

func (x *BotParams) GetExpires() *timestamppb.Timestamp {
	if x != nil {
		return x.Expires
	}
	return nil
}

// ClientParams holds either host or bot join parameters.
type ClientParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*ClientParams_HostParams
	//	*ClientParams_BotParams
	Payload       isClientParams_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientParams) Reset() {
	*x = ClientParams{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientParams) ProtoMessage() {}

func (x *ClientParams) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientParams.ProtoReflect.Descriptor instead.
func (*ClientParams) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{4}
}

func (x *ClientParams) GetPayload() isClientParams_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ClientParams) GetHostParams() *HostParams {
	if x != nil {
		if x, ok := x.Payload.(*ClientParams_HostParams); ok {
			return x.HostParams
		}
	}
	return nil
}

func (x *ClientParams) GetBotParams() *BotParams {
	if x != nil {
		if x, ok := x.Payload.(*ClientParams_BotParams); ok {
			return x.BotParams
		}
	}
	return nil
}

type isClientParams_Payload interface {
	isClientParams_Payload()
}

type ClientParams_HostParams struct {
	HostParams *HostParams `protobuf:"bytes,1,opt,name=host_params,json=hostParams,proto3,oneof"`
}

type ClientParams_BotParams struct {
	BotParams *BotParams `protobuf:"bytes,2,opt,name=bot_params,json=botParams,proto3,oneof"`
}

func (*ClientParams_HostParams) isClientParams_Payload() {}

func (*ClientParams_BotParams) isClientParams_Payload() {}

// TokenInit is sent by the client in response to the ServerInit message for
// the Token join method.
//
// The Token method join flow is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: TokenInit
// 4. server->client: Result
type TokenInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	// The secret value that must be provided when using the token join method.
	Secret        string `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenInit) Reset() {
	*x = TokenInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenInit) ProtoMessage() {}

func (x *TokenInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenInit.ProtoReflect.Descriptor instead.
func (*TokenInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{5}
}

func (x *TokenInit) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

func (x *TokenInit) GetSecret() string {
	if x != nil {
		return x.Secret
	}
	return ""
}

// OIDCInit holds the OIDC identity token used for all OIDC-based join methods.
//
// The join flow for all OIDC-based join methods is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: OIDCInit
// 4. server->client: Result
type OIDCInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	// IdToken is the OIDC identity token.
	IdToken       []byte `protobuf:"bytes,2,opt,name=id_token,json=idToken,proto3" json:"id_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OIDCInit) Reset() {
	*x = OIDCInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OIDCInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OIDCInit) ProtoMessage() {}

func (x *OIDCInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OIDCInit.ProtoReflect.Descriptor instead.
func (*OIDCInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{6}
}

func (x *OIDCInit) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

func (x *OIDCInit) GetIdToken() []byte {
	if x != nil {
		return x.IdToken
	}
	return nil
}

// BoundKeypairInit is sent from the client in response to the ServerInit
// message for the bound keypair join method.
// The server is expected to respond with a BoundKeypairChallenge.
//
// The bound keypair method join flow is:
//  1. client->server: ClientInit
//  2. server->client: ServerInit
//  3. client->server: BoundKeypairInit
//  4. server->client: BoundKeypairChallenge
//  5. client->server: BoundKeypairChallengeSolution
//     (optional additional steps if keypair rotation is required)
//     server->client: BoundKeypairRotationRequest
//     client->server: BoundKeypairRotationResponse
//     server->client: BoundKeypairChallenge
//     client->server: BoundKeypairChallengeSolution
//  6. server->client: Result containing BoundKeypairResult
type BoundKeypairInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	// If set, attempts to bind a new keypair using an initial join secret.
	// Any value set here will be ignored if a keypair is already bound.
	InitialJoinSecret string `protobuf:"bytes,2,opt,name=initial_join_secret,json=initialJoinSecret,proto3" json:"initial_join_secret,omitempty"`
	// A document signed by Auth containing join state parameters from the
	// previous join attempt. Not required on initial join; required on all
	// subsequent joins.
	PreviousJoinState []byte `protobuf:"bytes,3,opt,name=previous_join_state,json=previousJoinState,proto3" json:"previous_join_state,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BoundKeypairInit) Reset() {
	*x = BoundKeypairInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundKeypairInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundKeypairInit) ProtoMessage() {}

func (x *BoundKeypairInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundKeypairInit.ProtoReflect.Descriptor instead.
func (*BoundKeypairInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{7}
}

func (x *BoundKeypairInit) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

func (x *BoundKeypairInit) GetInitialJoinSecret() string {
	if x != nil {
		return x.InitialJoinSecret
	}
	return ""
}

func (x *BoundKeypairInit) GetPreviousJoinState() []byte {
	if x != nil {
		return x.PreviousJoinState
	}
	return nil
}

// BoundKeypairChallenge is a challenge issued by the server that joining
// clients are expected to complete.
// The client is expected to respond with a BoundKeypairChallengeSolution.
type BoundKeypairChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The desired public key corresponding to the private key that should be used
	// to sign this challenge, in SSH authorized keys format.
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// A challenge to sign with the requested public key. During keypair rotation,
	// a second challenge will be provided to verify the new keypair before certs
	// are returned.
	Challenge     string `protobuf:"bytes,2,opt,name=challenge,proto3" json:"challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BoundKeypairChallenge) Reset() {
	*x = BoundKeypairChallenge{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundKeypairChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundKeypairChallenge) ProtoMessage() {}

func (x *BoundKeypairChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundKeypairChallenge.ProtoReflect.Descriptor instead.
func (*BoundKeypairChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{8}
}

func (x *BoundKeypairChallenge) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *BoundKeypairChallenge) GetChallenge() string {
	if x != nil {
		return x.Challenge
	}
	return ""
}

// BoundKeypairChallengeSolution is sent from the client in response to the
// BoundKeypairChallenge.
// The server is expected to respond with either a Result or a
// BoundKeypairRotationRequest.
type BoundKeypairChallengeSolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A solution to a challenge from the server. This generated by signing the
	// challenge as a JWT using the keypair associated with the requested public
	// key.
	Solution      []byte `protobuf:"bytes,1,opt,name=solution,proto3" json:"solution,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BoundKeypairChallengeSolution) Reset() {
	*x = BoundKeypairChallengeSolution{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundKeypairChallengeSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundKeypairChallengeSolution) ProtoMessage() {}

func (x *BoundKeypairChallengeSolution) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundKeypairChallengeSolution.ProtoReflect.Descriptor instead.
func (*BoundKeypairChallengeSolution) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{9}
}

func (x *BoundKeypairChallengeSolution) GetSolution() []byte {
	if x != nil {
		return x.Solution
	}
	return nil
}

// BoundKeypairRotationRequest is sent by the server in response to a
// BoundKeypairChallenge when a keypair rotation is required. It acts like an
// additional challenge, the client is expected to respond with a
// BoundKeypairRotationResponse.
type BoundKeypairRotationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signature algorithm suite in use by the cluster.
	SignatureAlgorithmSuite string `protobuf:"bytes,1,opt,name=signature_algorithm_suite,json=signatureAlgorithmSuite,proto3" json:"signature_algorithm_suite,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *BoundKeypairRotationRequest) Reset() {
	*x = BoundKeypairRotationRequest{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundKeypairRotationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundKeypairRotationRequest) ProtoMessage() {}

func (x *BoundKeypairRotationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundKeypairRotationRequest.ProtoReflect.Descriptor instead.
func (*BoundKeypairRotationRequest) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{10}
}

func (x *BoundKeypairRotationRequest) GetSignatureAlgorithmSuite() string {
	if x != nil {
		return x.SignatureAlgorithmSuite
	}
	return ""
}

// BoundKeypairRotationResponse is sent by the client in response to a
// BoundKeypairRotationRequest from the server.
// The server is expected to respond with an additional BoundKeypairChallenge
// for the new key.
type BoundKeypairRotationResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The public key to be registered with auth. Clients should expect a
	// subsequent challenge against this public key to be sent. This is encoded in
	// SSH authorized keys format.
	PublicKey     []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BoundKeypairRotationResponse) Reset() {
	*x = BoundKeypairRotationResponse{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundKeypairRotationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundKeypairRotationResponse) ProtoMessage() {}

func (x *BoundKeypairRotationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundKeypairRotationResponse.ProtoReflect.Descriptor instead.
func (*BoundKeypairRotationResponse) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{11}
}

func (x *BoundKeypairRotationResponse) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// BoundKeypairResult holds additional result parameters relevant to the bound
// keypair join method.
type BoundKeypairResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A signed join state document to be provided on the next join attempt.
	JoinState []byte `protobuf:"bytes,2,opt,name=join_state,json=joinState,proto3" json:"join_state,omitempty"`
	// The public key registered with Auth at the end of the joining ceremony.
	// After a successful keypair rotation, this should reflect the newly
	// registered public key. This is encoded in SSH authorized keys format.
	PublicKey     []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BoundKeypairResult) Reset() {
	*x = BoundKeypairResult{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BoundKeypairResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoundKeypairResult) ProtoMessage() {}

func (x *BoundKeypairResult) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoundKeypairResult.ProtoReflect.Descriptor instead.
func (*BoundKeypairResult) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{12}
}

func (x *BoundKeypairResult) GetJoinState() []byte {
	if x != nil {
		return x.JoinState
	}
	return nil
}

func (x *BoundKeypairResult) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// IAMInit is sent from the client in response to the ServerInit message for
// the IAM join method.
//
// The IAM method join flow is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: IAMInit
// 4. server->client: IAMChallenge
// 5. client->server: IAMChallengeSolution
// 6. server->client: Result
type IAMInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams  *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IAMInit) Reset() {
	*x = IAMInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IAMInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IAMInit) ProtoMessage() {}

func (x *IAMInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IAMInit.ProtoReflect.Descriptor instead.
func (*IAMInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{13}
}

func (x *IAMInit) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

// IAMChallenge is from the server in response to the IAMInit message from the client.
// The client is expected to respond with a IAMChallengeSolution.
type IAMChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Challenge is a a crypto-random string that should be included by the
	// client in the IAMChallengeSolution message.
	Challenge     string `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IAMChallenge) Reset() {
	*x = IAMChallenge{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IAMChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IAMChallenge) ProtoMessage() {}

func (x *IAMChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IAMChallenge.ProtoReflect.Descriptor instead.
func (*IAMChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{14}
}

func (x *IAMChallenge) GetChallenge() string {
	if x != nil {
		return x.Challenge
	}
	return ""
}

// IAMChallengeSolution must be sent from the client in response to the
// IAMChallenge message.
type IAMChallengeSolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// STSIdentityRequest is a signed sts:GetCallerIdentity API request used
	// to prove the AWS identity of a joining node. It must include the
	// challenge string as a signed header.
	StsIdentityRequest []byte `protobuf:"bytes,1,opt,name=sts_identity_request,json=stsIdentityRequest,proto3" json:"sts_identity_request,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *IAMChallengeSolution) Reset() {
	*x = IAMChallengeSolution{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IAMChallengeSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IAMChallengeSolution) ProtoMessage() {}

func (x *IAMChallengeSolution) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IAMChallengeSolution.ProtoReflect.Descriptor instead.
func (*IAMChallengeSolution) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{15}
}

func (x *IAMChallengeSolution) GetStsIdentityRequest() []byte {
	if x != nil {
		return x.StsIdentityRequest
	}
	return nil
}

// EC2Init is sent from the client in response to the ServerInit message for
// the EC2 join method.
//
// The EC2 method join flow is:
// 1. client->server: ClientInit
// 2. server->client: ServerInit
// 3. client->server: EC2Init
// 4. server->client: Result
type EC2Init struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	// Document is a signed EC2 Instance Identity Document used to prove the
	// identity of a joining EC2 instance.
	Document      []byte `protobuf:"bytes,2,opt,name=document,proto3" json:"document,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EC2Init) Reset() {
	*x = EC2Init{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EC2Init) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EC2Init) ProtoMessage() {}

func (x *EC2Init) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EC2Init.ProtoReflect.Descriptor instead.
func (*EC2Init) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{16}
}

func (x *EC2Init) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

func (x *EC2Init) GetDocument() []byte {
	if x != nil {
		return x.Document
	}
	return nil
}

// OracleInit is sent from the client in response to the ServerInit message for
// the Oracle join method.
//
// The Oracle method join flow is:
// 1. client->server: ClientInit
// 2. client<-server: ServerInit
// 3. client->server: OracleInit
// 4. client<-server: OracleChallenge
// 5. client->server: OracleChallengeSolution
// 6. client<-server: Result
type OracleInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams  *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OracleInit) Reset() {
	*x = OracleInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OracleInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OracleInit) ProtoMessage() {}

func (x *OracleInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OracleInit.ProtoReflect.Descriptor instead.
func (*OracleInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{17}
}

func (x *OracleInit) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

// OracleChallenge is sent from the server in response to the OracleInit message from the client.
// The client is expected to respond with a OracleChallengeSolution.
type OracleChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Challenge is a a crypto-random string that should be included by the
	// client in the OracleChallengeSolution message.
	Challenge     string `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OracleChallenge) Reset() {
	*x = OracleChallenge{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OracleChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OracleChallenge) ProtoMessage() {}

func (x *OracleChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OracleChallenge.ProtoReflect.Descriptor instead.
func (*OracleChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{18}
}

func (x *OracleChallenge) GetChallenge() string {
	if x != nil {
		return x.Challenge
	}
	return ""
}

// OracleChallengeSolution must be sent from the client in response to the
// OracleChallenge message.
type OracleChallengeSolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Cert is the OCI instance identity certificate, an X509 certificate in PEM format.
	Cert []byte `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
	// Intermediate encodes the intermediate CAs that issued the instance
	// identity certificate, in PEM format.
	Intermediate []byte `protobuf:"bytes,2,opt,name=intermediate,proto3" json:"intermediate,omitempty"`
	// Signature is a signature over the challenge, signed by the private key
	// matching the instance identity certificate.
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// SignedRootCaReq is a signed request to the Oracle API for retreiving the
	// root CAs that issued the instance identity certificate.
	SignedRootCaReq []byte `protobuf:"bytes,4,opt,name=signed_root_ca_req,json=signedRootCaReq,proto3" json:"signed_root_ca_req,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *OracleChallengeSolution) Reset() {
	*x = OracleChallengeSolution{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OracleChallengeSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OracleChallengeSolution) ProtoMessage() {}

func (x *OracleChallengeSolution) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OracleChallengeSolution.ProtoReflect.Descriptor instead.
func (*OracleChallengeSolution) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{19}
}

func (x *OracleChallengeSolution) GetCert() []byte {
	if x != nil {
		return x.Cert
	}
	return nil
}

func (x *OracleChallengeSolution) GetIntermediate() []byte {
	if x != nil {
		return x.Intermediate
	}
	return nil
}

func (x *OracleChallengeSolution) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *OracleChallengeSolution) GetSignedRootCaReq() []byte {
	if x != nil {
		return x.SignedRootCaReq
	}
	return nil
}

// TPMInit is the message sent from the client in response to the ServerInit
// message for the TPM join flow.
// The server is expected to respond with a TPMEncryptedCredential message.
//
// The TPM method join flow is:
// 1. client->server: ClientInit
// 2. client<-server: ServerInit
// 3. client->server: TPMInit
// 4. client<-server: TPMEncryptedCredential
// 5. client->server: TPMSolution
// 6. client<-server: Result
type TPMInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	// The encoded TPMT_PUBLIC structure containing the attestation public key
	// and signing parameters.
	Public []byte `protobuf:"bytes,2,opt,name=public,proto3" json:"public,omitempty"`
	// The properties of the attestation key, encoded as a TPMS_CREATION_DATA
	// structure.
	CreateData []byte `protobuf:"bytes,3,opt,name=create_data,json=createData,proto3" json:"create_data,omitempty"`
	// An assertion as to the details of the key, encoded as a TPMS_ATTEST
	// structure.
	CreateAttestation []byte `protobuf:"bytes,4,opt,name=create_attestation,json=createAttestation,proto3" json:"create_attestation,omitempty"`
	// A signature of create_attestation, encoded as a TPMT_SIGNATURE structure.
	CreateSignature []byte `protobuf:"bytes,5,opt,name=create_signature,json=createSignature,proto3" json:"create_signature,omitempty"`
	// Types that are valid to be assigned to Ek:
	//
	//	*TPMInit_EkCert
	//	*TPMInit_EkKey
	Ek            isTPMInit_Ek `protobuf_oneof:"ek"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TPMInit) Reset() {
	*x = TPMInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TPMInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TPMInit) ProtoMessage() {}

func (x *TPMInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TPMInit.ProtoReflect.Descriptor instead.
func (*TPMInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{20}
}

func (x *TPMInit) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

func (x *TPMInit) GetPublic() []byte {
	if x != nil {
		return x.Public
	}
	return nil
}

func (x *TPMInit) GetCreateData() []byte {
	if x != nil {
		return x.CreateData
	}
	return nil
}

func (x *TPMInit) GetCreateAttestation() []byte {
	if x != nil {
		return x.CreateAttestation
	}
	return nil
}

func (x *TPMInit) GetCreateSignature() []byte {
	if x != nil {
		return x.CreateSignature
	}
	return nil
}

func (x *TPMInit) GetEk() isTPMInit_Ek {
	if x != nil {
		return x.Ek
	}
	return nil
}

func (x *TPMInit) GetEkCert() []byte {
	if x != nil {
		if x, ok := x.Ek.(*TPMInit_EkCert); ok {
			return x.EkCert
		}
	}
	return nil
}

func (x *TPMInit) GetEkKey() []byte {
	if x != nil {
		if x, ok := x.Ek.(*TPMInit_EkKey); ok {
			return x.EkKey
		}
	}
	return nil
}

type isTPMInit_Ek interface {
	isTPMInit_Ek()
}

type TPMInit_EkCert struct {
	// The device's endorsement certificate in X509, ASN.1 DER form. This
	// certificate contains the public key of the endorsement key. This is
	// preferred to ek_key.
	EkCert []byte `protobuf:"bytes,6,opt,name=ek_cert,json=ekCert,proto3,oneof"`
}

type TPMInit_EkKey struct {
	// The device's public endorsement key in PKIX, ASN.1 DER form. This is
	// used when a TPM does not contain any endorsement certificates.
	EkKey []byte `protobuf:"bytes,7,opt,name=ek_key,json=ekKey,proto3,oneof"`
}

func (*TPMInit_EkCert) isTPMInit_Ek() {}

func (*TPMInit_EkKey) isTPMInit_Ek() {}

// TPMEncryptedCredential is the message sent from the server in response to the
// TPMInit message.
// The client is expected to respond with a TPMSolution message.
type TPMEncryptedCredential struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The `credential_blob` parameter to be used with the `ActivateCredential`
	// command. This is used with the decrypted value of `secret` in a
	// cryptographic process to decrypt the solution.
	CredentialBlob []byte `protobuf:"bytes,1,opt,name=credential_blob,json=credentialBlob,proto3" json:"credential_blob,omitempty"`
	// The `secret` parameter to be used with `ActivateCredential`. This is a
	// seed which can be decrypted with the EK. The decrypted seed is then used
	// when decrypting `credential_blob`.
	Secret        []byte `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TPMEncryptedCredential) Reset() {
	*x = TPMEncryptedCredential{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TPMEncryptedCredential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TPMEncryptedCredential) ProtoMessage() {}

func (x *TPMEncryptedCredential) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TPMEncryptedCredential.ProtoReflect.Descriptor instead.
func (*TPMEncryptedCredential) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{21}
}

func (x *TPMEncryptedCredential) GetCredentialBlob() []byte {
	if x != nil {
		return x.CredentialBlob
	}
	return nil
}

func (x *TPMEncryptedCredential) GetSecret() []byte {
	if x != nil {
		return x.Secret
	}
	return nil
}

// TPMSolution is the message sent from the client in response to the
// TPMEncryptedCredential message. The server is expected to respond with a
// Result message.
type TPMSolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The client's solution to TPMEncryptedCredential using ActivateCredential.
	Solution      []byte `protobuf:"bytes,1,opt,name=solution,proto3" json:"solution,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TPMSolution) Reset() {
	*x = TPMSolution{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TPMSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TPMSolution) ProtoMessage() {}

func (x *TPMSolution) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TPMSolution.ProtoReflect.Descriptor instead.
func (*TPMSolution) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{22}
}

func (x *TPMSolution) GetSolution() []byte {
	if x != nil {
		return x.Solution
	}
	return nil
}

// AzureInit is sent from the client in response to the ServerInit message for
// the Azure join method.
//
// The Azure method join flow is:
// 1. client->server: ClientInit
// 2. client<-server: ServerInit
// 3. client->server: AzureInit
// 4. client<-server: AzureChallenge
// 5. client->server: AzureChallengeSolution
// 6. client<-server: Result
type AzureInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClientParams holds parameters for the specific type of client trying to join.
	ClientParams  *ClientParams `protobuf:"bytes,1,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AzureInit) Reset() {
	*x = AzureInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureInit) ProtoMessage() {}

func (x *AzureInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureInit.ProtoReflect.Descriptor instead.
func (*AzureInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{23}
}

func (x *AzureInit) GetClientParams() *ClientParams {
	if x != nil {
		return x.ClientParams
	}
	return nil
}

// AzureChallenge is sent from the server in response to the AzureInit message from the client.
// The client is expected to respond with a AzureChallengeSolution.
type AzureChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Challenge is a a crypto-random string that should be included by the
	// client in the challenge response message.
	Challenge     string `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AzureChallenge) Reset() {
	*x = AzureChallenge{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureChallenge) ProtoMessage() {}

func (x *AzureChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureChallenge.ProtoReflect.Descriptor instead.
func (*AzureChallenge) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{24}
}

func (x *AzureChallenge) GetChallenge() string {
	if x != nil {
		return x.Challenge
	}
	return ""
}

// AzureChallengeSolution must be sent from the client in response to the
// AzureChallenge message.
type AzureChallengeSolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// AttestedData is a signed JSON document from an Azure VM's attested data
	// metadata endpoint used to prove the identity of a joining node. It must
	// include the challenge string as the nonce.
	AttestedData []byte `protobuf:"bytes,1,opt,name=attested_data,json=attestedData,proto3" json:"attested_data,omitempty"`
	// Intermediate encodes the intermediate CAs that issued the leaf certificate
	// used to sign the attested data document, in x509 DER format.
	Intermediate []byte `protobuf:"bytes,2,opt,name=intermediate,proto3" json:"intermediate,omitempty"`
	// AccessToken is a JWT signed by Azure, used to prove the identity of a
	// joining node.
	AccessToken   string `protobuf:"bytes,3,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AzureChallengeSolution) Reset() {
	*x = AzureChallengeSolution{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AzureChallengeSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AzureChallengeSolution) ProtoMessage() {}

func (x *AzureChallengeSolution) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AzureChallengeSolution.ProtoReflect.Descriptor instead.
func (*AzureChallengeSolution) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{25}
}

func (x *AzureChallengeSolution) GetAttestedData() []byte {
	if x != nil {
		return x.AttestedData
	}
	return nil
}

func (x *AzureChallengeSolution) GetIntermediate() []byte {
	if x != nil {
		return x.Intermediate
	}
	return nil
}

func (x *AzureChallengeSolution) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

// ChallengeSolution holds a solution to a challenge issued by the server.
type ChallengeSolution struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*ChallengeSolution_BoundKeypairChallengeSolution
	//	*ChallengeSolution_BoundKeypairRotationResponse
	//	*ChallengeSolution_IamChallengeSolution
	//	*ChallengeSolution_OracleChallengeSolution
	//	*ChallengeSolution_TpmSolution
	//	*ChallengeSolution_AzureChallengeSolution
	Payload       isChallengeSolution_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChallengeSolution) Reset() {
	*x = ChallengeSolution{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChallengeSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChallengeSolution) ProtoMessage() {}

func (x *ChallengeSolution) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChallengeSolution.ProtoReflect.Descriptor instead.
func (*ChallengeSolution) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{26}
}

func (x *ChallengeSolution) GetPayload() isChallengeSolution_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *ChallengeSolution) GetBoundKeypairChallengeSolution() *BoundKeypairChallengeSolution {
	if x != nil {
		if x, ok := x.Payload.(*ChallengeSolution_BoundKeypairChallengeSolution); ok {
			return x.BoundKeypairChallengeSolution
		}
	}
	return nil
}

func (x *ChallengeSolution) GetBoundKeypairRotationResponse() *BoundKeypairRotationResponse {
	if x != nil {
		if x, ok := x.Payload.(*ChallengeSolution_BoundKeypairRotationResponse); ok {
			return x.BoundKeypairRotationResponse
		}
	}
	return nil
}

func (x *ChallengeSolution) GetIamChallengeSolution() *IAMChallengeSolution {
	if x != nil {
		if x, ok := x.Payload.(*ChallengeSolution_IamChallengeSolution); ok {
			return x.IamChallengeSolution
		}
	}
	return nil
}

func (x *ChallengeSolution) GetOracleChallengeSolution() *OracleChallengeSolution {
	if x != nil {
		if x, ok := x.Payload.(*ChallengeSolution_OracleChallengeSolution); ok {
			return x.OracleChallengeSolution
		}
	}
	return nil
}

func (x *ChallengeSolution) GetTpmSolution() *TPMSolution {
	if x != nil {
		if x, ok := x.Payload.(*ChallengeSolution_TpmSolution); ok {
			return x.TpmSolution
		}
	}
	return nil
}

func (x *ChallengeSolution) GetAzureChallengeSolution() *AzureChallengeSolution {
	if x != nil {
		if x, ok := x.Payload.(*ChallengeSolution_AzureChallengeSolution); ok {
			return x.AzureChallengeSolution
		}
	}
	return nil
}

type isChallengeSolution_Payload interface {
	isChallengeSolution_Payload()
}

type ChallengeSolution_BoundKeypairChallengeSolution struct {
	BoundKeypairChallengeSolution *BoundKeypairChallengeSolution `protobuf:"bytes,1,opt,name=bound_keypair_challenge_solution,json=boundKeypairChallengeSolution,proto3,oneof"`
}

type ChallengeSolution_BoundKeypairRotationResponse struct {
	BoundKeypairRotationResponse *BoundKeypairRotationResponse `protobuf:"bytes,2,opt,name=bound_keypair_rotation_response,json=boundKeypairRotationResponse,proto3,oneof"`
}

type ChallengeSolution_IamChallengeSolution struct {
	IamChallengeSolution *IAMChallengeSolution `protobuf:"bytes,3,opt,name=iam_challenge_solution,json=iamChallengeSolution,proto3,oneof"`
}

type ChallengeSolution_OracleChallengeSolution struct {
	OracleChallengeSolution *OracleChallengeSolution `protobuf:"bytes,4,opt,name=oracle_challenge_solution,json=oracleChallengeSolution,proto3,oneof"`
}

type ChallengeSolution_TpmSolution struct {
	TpmSolution *TPMSolution `protobuf:"bytes,5,opt,name=tpm_solution,json=tpmSolution,proto3,oneof"`
}

type ChallengeSolution_AzureChallengeSolution struct {
	AzureChallengeSolution *AzureChallengeSolution `protobuf:"bytes,6,opt,name=azure_challenge_solution,json=azureChallengeSolution,proto3,oneof"`
}

func (*ChallengeSolution_BoundKeypairChallengeSolution) isChallengeSolution_Payload() {}

func (*ChallengeSolution_BoundKeypairRotationResponse) isChallengeSolution_Payload() {}

func (*ChallengeSolution_IamChallengeSolution) isChallengeSolution_Payload() {}

func (*ChallengeSolution_OracleChallengeSolution) isChallengeSolution_Payload() {}

func (*ChallengeSolution_TpmSolution) isChallengeSolution_Payload() {}

func (*ChallengeSolution_AzureChallengeSolution) isChallengeSolution_Payload() {}

// GivingUp should be sent by clients that fail to complete the join flow so
// that the Auth service can log an informative error message.
type GivingUp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Reason is the reason the client is giving up.
	Reason GivingUp_Reason `protobuf:"varint,1,opt,name=reason,proto3,enum=teleport.join.v1.GivingUp_Reason" json:"reason,omitempty"`
	// Msg is an error message related to the failure.
	Msg           string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GivingUp) Reset() {
	*x = GivingUp{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GivingUp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GivingUp) ProtoMessage() {}

func (x *GivingUp) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GivingUp.ProtoReflect.Descriptor instead.
func (*GivingUp) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{27}
}

func (x *GivingUp) GetReason() GivingUp_Reason {
	if x != nil {
		return x.Reason
	}
	return GivingUp_REASON_UNSPECIFIED
}

func (x *GivingUp) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

// JoinRequest is the message type sent from the joining client to the server.
type JoinRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*JoinRequest_ClientInit
	//	*JoinRequest_TokenInit
	//	*JoinRequest_BoundKeypairInit
	//	*JoinRequest_Solution
	//	*JoinRequest_IamInit
	//	*JoinRequest_GivingUp
	//	*JoinRequest_Ec2Init
	//	*JoinRequest_OidcInit
	//	*JoinRequest_OracleInit
	//	*JoinRequest_TpmInit
	//	*JoinRequest_AzureInit
	Payload       isJoinRequest_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JoinRequest) Reset() {
	*x = JoinRequest{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JoinRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JoinRequest) ProtoMessage() {}

func (x *JoinRequest) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JoinRequest.ProtoReflect.Descriptor instead.
func (*JoinRequest) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{28}
}

func (x *JoinRequest) GetPayload() isJoinRequest_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *JoinRequest) GetClientInit() *ClientInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_ClientInit); ok {
			return x.ClientInit
		}
	}
	return nil
}

func (x *JoinRequest) GetTokenInit() *TokenInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_TokenInit); ok {
			return x.TokenInit
		}
	}
	return nil
}

func (x *JoinRequest) GetBoundKeypairInit() *BoundKeypairInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_BoundKeypairInit); ok {
			return x.BoundKeypairInit
		}
	}
	return nil
}

func (x *JoinRequest) GetSolution() *ChallengeSolution {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_Solution); ok {
			return x.Solution
		}
	}
	return nil
}

func (x *JoinRequest) GetIamInit() *IAMInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_IamInit); ok {
			return x.IamInit
		}
	}
	return nil
}

func (x *JoinRequest) GetGivingUp() *GivingUp {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_GivingUp); ok {
			return x.GivingUp
		}
	}
	return nil
}

func (x *JoinRequest) GetEc2Init() *EC2Init {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_Ec2Init); ok {
			return x.Ec2Init
		}
	}
	return nil
}

func (x *JoinRequest) GetOidcInit() *OIDCInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_OidcInit); ok {
			return x.OidcInit
		}
	}
	return nil
}

func (x *JoinRequest) GetOracleInit() *OracleInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_OracleInit); ok {
			return x.OracleInit
		}
	}
	return nil
}

func (x *JoinRequest) GetTpmInit() *TPMInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_TpmInit); ok {
			return x.TpmInit
		}
	}
	return nil
}

func (x *JoinRequest) GetAzureInit() *AzureInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinRequest_AzureInit); ok {
			return x.AzureInit
		}
	}
	return nil
}

type isJoinRequest_Payload interface {
	isJoinRequest_Payload()
}

type JoinRequest_ClientInit struct {
	ClientInit *ClientInit `protobuf:"bytes,1,opt,name=client_init,json=clientInit,proto3,oneof"`
}

type JoinRequest_TokenInit struct {
	TokenInit *TokenInit `protobuf:"bytes,2,opt,name=token_init,json=tokenInit,proto3,oneof"`
}

type JoinRequest_BoundKeypairInit struct {
	BoundKeypairInit *BoundKeypairInit `protobuf:"bytes,3,opt,name=bound_keypair_init,json=boundKeypairInit,proto3,oneof"`
}

type JoinRequest_Solution struct {
	Solution *ChallengeSolution `protobuf:"bytes,4,opt,name=solution,proto3,oneof"`
}

type JoinRequest_IamInit struct {
	IamInit *IAMInit `protobuf:"bytes,5,opt,name=iam_init,json=iamInit,proto3,oneof"`
}

type JoinRequest_GivingUp struct {
	GivingUp *GivingUp `protobuf:"bytes,6,opt,name=giving_up,json=givingUp,proto3,oneof"`
}

type JoinRequest_Ec2Init struct {
	Ec2Init *EC2Init `protobuf:"bytes,7,opt,name=ec2_init,json=ec2Init,proto3,oneof"`
}

type JoinRequest_OidcInit struct {
	OidcInit *OIDCInit `protobuf:"bytes,8,opt,name=oidc_init,json=oidcInit,proto3,oneof"`
}

type JoinRequest_OracleInit struct {
	OracleInit *OracleInit `protobuf:"bytes,9,opt,name=oracle_init,json=oracleInit,proto3,oneof"`
}

type JoinRequest_TpmInit struct {
	TpmInit *TPMInit `protobuf:"bytes,10,opt,name=tpm_init,json=tpmInit,proto3,oneof"`
}

type JoinRequest_AzureInit struct {
	AzureInit *AzureInit `protobuf:"bytes,11,opt,name=azure_init,json=azureInit,proto3,oneof"`
}

func (*JoinRequest_ClientInit) isJoinRequest_Payload() {}

func (*JoinRequest_TokenInit) isJoinRequest_Payload() {}

func (*JoinRequest_BoundKeypairInit) isJoinRequest_Payload() {}

func (*JoinRequest_Solution) isJoinRequest_Payload() {}

func (*JoinRequest_IamInit) isJoinRequest_Payload() {}

func (*JoinRequest_GivingUp) isJoinRequest_Payload() {}

func (*JoinRequest_Ec2Init) isJoinRequest_Payload() {}

func (*JoinRequest_OidcInit) isJoinRequest_Payload() {}

func (*JoinRequest_OracleInit) isJoinRequest_Payload() {}

func (*JoinRequest_TpmInit) isJoinRequest_Payload() {}

func (*JoinRequest_AzureInit) isJoinRequest_Payload() {}

// ServerInit is the first message sent from the server in response to the
// ClientInit message.
type ServerInit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// JoinMethod is the name of the selected join method.
	JoinMethod string `protobuf:"bytes,1,opt,name=join_method,json=joinMethod,proto3" json:"join_method,omitempty"`
	// SignatureAlgorithmSuite is the name of the signature algorithm suite
	// currently configured for the cluster.
	SignatureAlgorithmSuite string `protobuf:"bytes,2,opt,name=signature_algorithm_suite,json=signatureAlgorithmSuite,proto3" json:"signature_algorithm_suite,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ServerInit) Reset() {
	*x = ServerInit{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerInit) ProtoMessage() {}

func (x *ServerInit) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerInit.ProtoReflect.Descriptor instead.
func (*ServerInit) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{29}
}

func (x *ServerInit) GetJoinMethod() string {
	if x != nil {
		return x.JoinMethod
	}
	return ""
}

func (x *ServerInit) GetSignatureAlgorithmSuite() string {
	if x != nil {
		return x.SignatureAlgorithmSuite
	}
	return ""
}

// Challenge is a challenge message sent from the server that the client must solve.
type Challenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*Challenge_BoundKeypairChallenge
	//	*Challenge_BoundKeypairRotationRequest
	//	*Challenge_IamChallenge
	//	*Challenge_OracleChallenge
	//	*Challenge_TpmEncryptedCredential
	//	*Challenge_AzureChallenge
	Payload       isChallenge_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Challenge) Reset() {
	*x = Challenge{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Challenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Challenge) ProtoMessage() {}

func (x *Challenge) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Challenge.ProtoReflect.Descriptor instead.
func (*Challenge) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{30}
}

func (x *Challenge) GetPayload() isChallenge_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Challenge) GetBoundKeypairChallenge() *BoundKeypairChallenge {
	if x != nil {
		if x, ok := x.Payload.(*Challenge_BoundKeypairChallenge); ok {
			return x.BoundKeypairChallenge
		}
	}
	return nil
}

func (x *Challenge) GetBoundKeypairRotationRequest() *BoundKeypairRotationRequest {
	if x != nil {
		if x, ok := x.Payload.(*Challenge_BoundKeypairRotationRequest); ok {
			return x.BoundKeypairRotationRequest
		}
	}
	return nil
}

func (x *Challenge) GetIamChallenge() *IAMChallenge {
	if x != nil {
		if x, ok := x.Payload.(*Challenge_IamChallenge); ok {
			return x.IamChallenge
		}
	}
	return nil
}

func (x *Challenge) GetOracleChallenge() *OracleChallenge {
	if x != nil {
		if x, ok := x.Payload.(*Challenge_OracleChallenge); ok {
			return x.OracleChallenge
		}
	}
	return nil
}

func (x *Challenge) GetTpmEncryptedCredential() *TPMEncryptedCredential {
	if x != nil {
		if x, ok := x.Payload.(*Challenge_TpmEncryptedCredential); ok {
			return x.TpmEncryptedCredential
		}
	}
	return nil
}

func (x *Challenge) GetAzureChallenge() *AzureChallenge {
	if x != nil {
		if x, ok := x.Payload.(*Challenge_AzureChallenge); ok {
			return x.AzureChallenge
		}
	}
	return nil
}

type isChallenge_Payload interface {
	isChallenge_Payload()
}

type Challenge_BoundKeypairChallenge struct {
	BoundKeypairChallenge *BoundKeypairChallenge `protobuf:"bytes,1,opt,name=bound_keypair_challenge,json=boundKeypairChallenge,proto3,oneof"`
}

type Challenge_BoundKeypairRotationRequest struct {
	BoundKeypairRotationRequest *BoundKeypairRotationRequest `protobuf:"bytes,2,opt,name=bound_keypair_rotation_request,json=boundKeypairRotationRequest,proto3,oneof"`
}

type Challenge_IamChallenge struct {
	IamChallenge *IAMChallenge `protobuf:"bytes,3,opt,name=iam_challenge,json=iamChallenge,proto3,oneof"`
}

type Challenge_OracleChallenge struct {
	OracleChallenge *OracleChallenge `protobuf:"bytes,4,opt,name=oracle_challenge,json=oracleChallenge,proto3,oneof"`
}

type Challenge_TpmEncryptedCredential struct {
	TpmEncryptedCredential *TPMEncryptedCredential `protobuf:"bytes,5,opt,name=tpm_encrypted_credential,json=tpmEncryptedCredential,proto3,oneof"`
}

type Challenge_AzureChallenge struct {
	AzureChallenge *AzureChallenge `protobuf:"bytes,6,opt,name=azure_challenge,json=azureChallenge,proto3,oneof"`
}

func (*Challenge_BoundKeypairChallenge) isChallenge_Payload() {}

func (*Challenge_BoundKeypairRotationRequest) isChallenge_Payload() {}

func (*Challenge_IamChallenge) isChallenge_Payload() {}

func (*Challenge_OracleChallenge) isChallenge_Payload() {}

func (*Challenge_TpmEncryptedCredential) isChallenge_Payload() {}

func (*Challenge_AzureChallenge) isChallenge_Payload() {}

// Result is the final message sent from the cluster back to the client, it
// contains the result of the joining process including the assigned host ID
// and issued certificates.
type Result struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*Result_HostResult
	//	*Result_BotResult
	Payload       isResult_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Result) Reset() {
	*x = Result{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Result) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Result) ProtoMessage() {}

func (x *Result) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Result.ProtoReflect.Descriptor instead.
func (*Result) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{31}
}

func (x *Result) GetPayload() isResult_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Result) GetHostResult() *HostResult {
	if x != nil {
		if x, ok := x.Payload.(*Result_HostResult); ok {
			return x.HostResult
		}
	}
	return nil
}

func (x *Result) GetBotResult() *BotResult {
	if x != nil {
		if x, ok := x.Payload.(*Result_BotResult); ok {
			return x.BotResult
		}
	}
	return nil
}

type isResult_Payload interface {
	isResult_Payload()
}

type Result_HostResult struct {
	HostResult *HostResult `protobuf:"bytes,1,opt,name=host_result,json=hostResult,proto3,oneof"`
}

type Result_BotResult struct {
	BotResult *BotResult `protobuf:"bytes,2,opt,name=bot_result,json=botResult,proto3,oneof"`
}

func (*Result_HostResult) isResult_Payload() {}

func (*Result_BotResult) isResult_Payload() {}

// Certificates holds issued certificates and cluster CAs.
type Certificates struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// TlsCert is an X.509 certificate encoded in ASN.1 DER form.
	TlsCert []byte `protobuf:"bytes,1,opt,name=tls_cert,json=tlsCert,proto3" json:"tls_cert,omitempty"`
	// TlsCaCerts is a list of TLS certificate authorities that the client should trust.
	// Each certificate is encoding in ASN.1 DER form.
	TlsCaCerts [][]byte `protobuf:"bytes,2,rep,name=tls_ca_certs,json=tlsCaCerts,proto3" json:"tls_ca_certs,omitempty"`
	// SshCert is an SSH certificate encoded in SSH wire format.
	SshCert []byte `protobuf:"bytes,3,opt,name=ssh_cert,json=sshCert,proto3" json:"ssh_cert,omitempty"`
	// SshCaKey is a list of SSH certificate authority public keys that the client should trust.
	// Each CA key is encoded in SSH wire format.
	SshCaKeys     [][]byte `protobuf:"bytes,4,rep,name=ssh_ca_keys,json=sshCaKeys,proto3" json:"ssh_ca_keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Certificates) Reset() {
	*x = Certificates{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Certificates) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Certificates) ProtoMessage() {}

func (x *Certificates) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Certificates.ProtoReflect.Descriptor instead.
func (*Certificates) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{32}
}

func (x *Certificates) GetTlsCert() []byte {
	if x != nil {
		return x.TlsCert
	}
	return nil
}

func (x *Certificates) GetTlsCaCerts() [][]byte {
	if x != nil {
		return x.TlsCaCerts
	}
	return nil
}

func (x *Certificates) GetSshCert() []byte {
	if x != nil {
		return x.SshCert
	}
	return nil
}

func (x *Certificates) GetSshCaKeys() [][]byte {
	if x != nil {
		return x.SshCaKeys
	}
	return nil
}

// HostResult holds results for host joining.
type HostResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Certificates holds issued certificates and cluster CAs.
	Certificates *Certificates `protobuf:"bytes,1,opt,name=certificates,proto3" json:"certificates,omitempty"`
	// HostId is the unique ID assigned to the host.
	HostId string `protobuf:"bytes,2,opt,name=host_id,json=hostId,proto3" json:"host_id,omitempty"`
	// The immutable labels assigned to the host by their join token.
	ImmutableLabels *v1.ImmutableLabels `protobuf:"bytes,3,opt,name=immutable_labels,json=immutableLabels,proto3" json:"immutable_labels,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *HostResult) Reset() {
	*x = HostResult{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HostResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HostResult) ProtoMessage() {}

func (x *HostResult) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HostResult.ProtoReflect.Descriptor instead.
func (*HostResult) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{33}
}

func (x *HostResult) GetCertificates() *Certificates {
	if x != nil {
		return x.Certificates
	}
	return nil
}

func (x *HostResult) GetHostId() string {
	if x != nil {
		return x.HostId
	}
	return ""
}

func (x *HostResult) GetImmutableLabels() *v1.ImmutableLabels {
	if x != nil {
		return x.ImmutableLabels
	}
	return nil
}

// HostResult holds results for bot joining.
type BotResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Certificates holds issued certificates and cluster CAs.
	Certificates *Certificates `protobuf:"bytes,1,opt,name=certificates,proto3" json:"certificates,omitempty"`
	// BoundKeypairResult holds extra result parameters relevant to the bound keypair join method.
	BoundKeypairResult *BoundKeypairResult `protobuf:"bytes,2,opt,name=bound_keypair_result,json=boundKeypairResult,proto3,oneof" json:"bound_keypair_result,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *BotResult) Reset() {
	*x = BotResult{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BotResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BotResult) ProtoMessage() {}

func (x *BotResult) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BotResult.ProtoReflect.Descriptor instead.
func (*BotResult) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{34}
}

func (x *BotResult) GetCertificates() *Certificates {
	if x != nil {
		return x.Certificates
	}
	return nil
}

func (x *BotResult) GetBoundKeypairResult() *BoundKeypairResult {
	if x != nil {
		return x.BoundKeypairResult
	}
	return nil
}

// JoinResponse is the message type sent from the server to the joining client.
type JoinResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Payload:
	//
	//	*JoinResponse_Init
	//	*JoinResponse_Challenge
	//	*JoinResponse_Result
	Payload       isJoinResponse_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JoinResponse) Reset() {
	*x = JoinResponse{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JoinResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JoinResponse) ProtoMessage() {}

func (x *JoinResponse) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JoinResponse.ProtoReflect.Descriptor instead.
func (*JoinResponse) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{35}
}

func (x *JoinResponse) GetPayload() isJoinResponse_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *JoinResponse) GetInit() *ServerInit {
	if x != nil {
		if x, ok := x.Payload.(*JoinResponse_Init); ok {
			return x.Init
		}
	}
	return nil
}

func (x *JoinResponse) GetChallenge() *Challenge {
	if x != nil {
		if x, ok := x.Payload.(*JoinResponse_Challenge); ok {
			return x.Challenge
		}
	}
	return nil
}

func (x *JoinResponse) GetResult() *Result {
	if x != nil {
		if x, ok := x.Payload.(*JoinResponse_Result); ok {
			return x.Result
		}
	}
	return nil
}

type isJoinResponse_Payload interface {
	isJoinResponse_Payload()
}

type JoinResponse_Init struct {
	// Init is the initial message sent from the server in response to the
	// ClientInit message. It specifies the join method used by the provision token.
	Init *ServerInit `protobuf:"bytes,1,opt,name=init,proto3,oneof"`
}

type JoinResponse_Challenge struct {
	// Challenge is a challenge issued by the server that the client must solve
	// in order to complete the join flow. The challenge type depends on the join method.
	// Each method may issue zero or more challenges that the client must solve.
	Challenge *Challenge `protobuf:"bytes,2,opt,name=challenge,proto3,oneof"`
}

type JoinResponse_Result struct {
	// Result is the result of the join flow, it is the final message sent from
	// the cluster when the join flow is successful.
	// For the token join method, it is sent immediately in response to the ClientInit request.
	Result *Result `protobuf:"bytes,3,opt,name=result,proto3,oneof"`
}

func (*JoinResponse_Init) isJoinResponse_Payload() {}

func (*JoinResponse_Challenge) isJoinResponse_Payload() {}

func (*JoinResponse_Result) isJoinResponse_Payload() {}

// ProxySuppliedParams holds parameters set by the Proxy when nodes join
// via the proxy address. They must only be trusted if the incoming join
// request is authenticated as the Proxy.
type ClientInit_ProxySuppliedParams struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// RemoteAddr is the remote address of the host requesting a host certificate.
	// It replaces 0.0.0.0 in the list of additional principals.
	RemoteAddr string `protobuf:"bytes,1,opt,name=remote_addr,json=remoteAddr,proto3" json:"remote_addr,omitempty"`
	// ClientVersion is the Teleport version of the client attempting to join.
	ClientVersion string `protobuf:"bytes,2,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClientInit_ProxySuppliedParams) Reset() {
	*x = ClientInit_ProxySuppliedParams{}
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClientInit_ProxySuppliedParams) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientInit_ProxySuppliedParams) ProtoMessage() {}

func (x *ClientInit_ProxySuppliedParams) ProtoReflect() protoreflect.Message {
	mi := &file_teleport_join_v1_joinservice_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientInit_ProxySuppliedParams.ProtoReflect.Descriptor instead.
func (*ClientInit_ProxySuppliedParams) Descriptor() ([]byte, []int) {
	return file_teleport_join_v1_joinservice_proto_rawDescGZIP(), []int{0, 0}
}

func (x *ClientInit_ProxySuppliedParams) GetRemoteAddr() string {
	if x != nil {
		return x.RemoteAddr
	}
	return ""
}

func (x *ClientInit_ProxySuppliedParams) GetClientVersion() string {
	if x != nil {
		return x.ClientVersion
	}
	return ""
}

var File_teleport_join_v1_joinservice_proto protoreflect.FileDescriptor

const file_teleport_join_v1_joinservice_proto_rawDesc = "" +
	"\n" +
	"\"teleport/join/v1/joinservice.proto\x12\x10teleport.join.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a&teleport/scopes/joining/v1/token.proto\"\xa0\x03\n" +
	"\n" +
	"ClientInit\x12$\n" +
	"\vjoin_method\x18\x01 \x01(\tH\x00R\n" +
	"joinMethod\x88\x01\x01\x12\x1d\n" +
	"\n" +
	"token_name\x18\x02 \x01(\tR\ttokenName\x12\x1f\n" +
	"\vsystem_role\x18\x03 \x01(\tR\n" +
	"systemRole\x12,\n" +
	"\x12forwarded_by_proxy\x18\x04 \x01(\bR\x10forwardedByProxy\x12q\n" +
	"\x19proxy_supplied_parameters\x18\x05 \x01(\v20.teleport.join.v1.ClientInit.ProxySuppliedParamsH\x01R\x17proxySuppliedParameters\x88\x01\x01\x1a]\n" +
	"\x13ProxySuppliedParams\x12\x1f\n" +
	"\vremote_addr\x18\x01 \x01(\tR\n" +
	"remoteAddr\x12%\n" +
	"\x0eclient_version\x18\x02 \x01(\tR\rclientVersionB\x0e\n" +
	"\f_join_methodB\x1c\n" +
	"\x1a_proxy_supplied_parameters\"X\n" +
	"\n" +
	"PublicKeys\x12$\n" +
	"\x0epublic_tls_key\x18\x01 \x01(\fR\fpublicTlsKey\x12$\n" +
	"\x0epublic_ssh_key\x18\x02 \x01(\fR\fpublicSshKey\"\xba\x01\n" +
	"\n" +
	"HostParams\x12=\n" +
	"\vpublic_keys\x18\x01 \x01(\v2\x1c.teleport.join.v1.PublicKeysR\n" +
	"publicKeys\x12\x1b\n" +
	"\thost_name\x18\x02 \x01(\tR\bhostName\x123\n" +
	"\x15additional_principals\x18\x03 \x03(\tR\x14additionalPrincipals\x12\x1b\n" +
	"\tdns_names\x18\x04 \x03(\tR\bdnsNames\"\x91\x01\n" +
	"\tBotParams\x12=\n" +
	"\vpublic_keys\x18\x01 \x01(\v2\x1c.teleport.join.v1.PublicKeysR\n" +
	"publicKeys\x129\n" +
	"\aexpires\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\aexpires\x88\x01\x01B\n" +
	"\n" +
	"\b_expires\"\x98\x01\n" +
	"\fClientParams\x12?\n" +
	"\vhost_params\x18\x01 \x01(\v2\x1c.teleport.join.v1.HostParamsH\x00R\n" +
	"hostParams\x12<\n" +
	"\n" +
	"bot_params\x18\x02 \x01(\v2\x1b.teleport.join.v1.BotParamsH\x00R\tbotParamsB\t\n" +
	"\apayload\"h\n" +
	"\tTokenInit\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\x12\x16\n" +
	"\x06secret\x18\x02 \x01(\tR\x06secret\"j\n" +
	"\bOIDCInit\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\x12\x19\n" +
	"\bid_token\x18\x02 \x01(\fR\aidToken\"\xb7\x01\n" +
	"\x10BoundKeypairInit\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\x12.\n" +
	"\x13initial_join_secret\x18\x02 \x01(\tR\x11initialJoinSecret\x12.\n" +
	"\x13previous_join_state\x18\x03 \x01(\fR\x11previousJoinState\"T\n" +
	"\x15BoundKeypairChallenge\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\fR\tpublicKey\x12\x1c\n" +
	"\tchallenge\x18\x02 \x01(\tR\tchallenge\";\n" +
	"\x1dBoundKeypairChallengeSolution\x12\x1a\n" +
	"\bsolution\x18\x01 \x01(\fR\bsolution\"Y\n" +
	"\x1bBoundKeypairRotationRequest\x12:\n" +
	"\x19signature_algorithm_suite\x18\x01 \x01(\tR\x17signatureAlgorithmSuite\"=\n" +
	"\x1cBoundKeypairRotationResponse\x12\x1d\n" +
	"\n" +
	"public_key\x18\x01 \x01(\fR\tpublicKey\"R\n" +
	"\x12BoundKeypairResult\x12\x1d\n" +
	"\n" +
	"join_state\x18\x02 \x01(\fR\tjoinState\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fR\tpublicKey\"N\n" +
	"\aIAMInit\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\",\n" +
	"\fIAMChallenge\x12\x1c\n" +
	"\tchallenge\x18\x01 \x01(\tR\tchallenge\"H\n" +
	"\x14IAMChallengeSolution\x120\n" +
	"\x14sts_identity_request\x18\x01 \x01(\fR\x12stsIdentityRequest\"j\n" +
	"\aEC2Init\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\x12\x1a\n" +
	"\bdocument\x18\x02 \x01(\fR\bdocument\"Q\n" +
	"\n" +
	"OracleInit\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\"/\n" +
	"\x0fOracleChallenge\x12\x1c\n" +
	"\tchallenge\x18\x01 \x01(\tR\tchallenge\"\x9c\x01\n" +
	"\x17OracleChallengeSolution\x12\x12\n" +
	"\x04cert\x18\x01 \x01(\fR\x04cert\x12\"\n" +
	"\fintermediate\x18\x02 \x01(\fR\fintermediate\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12+\n" +
	"\x12signed_root_ca_req\x18\x04 \x01(\fR\x0fsignedRootCaReq\"\x9b\x02\n" +
	"\aTPMInit\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\x12\x16\n" +
	"\x06public\x18\x02 \x01(\fR\x06public\x12\x1f\n" +
	"\vcreate_data\x18\x03 \x01(\fR\n" +
	"createData\x12-\n" +
	"\x12create_attestation\x18\x04 \x01(\fR\x11createAttestation\x12)\n" +
	"\x10create_signature\x18\x05 \x01(\fR\x0fcreateSignature\x12\x19\n" +
	"\aek_cert\x18\x06 \x01(\fH\x00R\x06ekCert\x12\x17\n" +
	"\x06ek_key\x18\a \x01(\fH\x00R\x05ekKeyB\x04\n" +
	"\x02ek\"Y\n" +
	"\x16TPMEncryptedCredential\x12'\n" +
	"\x0fcredential_blob\x18\x01 \x01(\fR\x0ecredentialBlob\x12\x16\n" +
	"\x06secret\x18\x02 \x01(\fR\x06secret\")\n" +
	"\vTPMSolution\x12\x1a\n" +
	"\bsolution\x18\x01 \x01(\fR\bsolution\"P\n" +
	"\tAzureInit\x12C\n" +
	"\rclient_params\x18\x01 \x01(\v2\x1e.teleport.join.v1.ClientParamsR\fclientParams\".\n" +
	"\x0eAzureChallenge\x12\x1c\n" +
	"\tchallenge\x18\x01 \x01(\tR\tchallenge\"\x84\x01\n" +
	"\x16AzureChallengeSolution\x12#\n" +
	"\rattested_data\x18\x01 \x01(\fR\fattestedData\x12\"\n" +
	"\fintermediate\x18\x02 \x01(\fR\fintermediate\x12!\n" +
	"\faccess_token\x18\x03 \x01(\tR\vaccessToken\"\x86\x05\n" +
	"\x11ChallengeSolution\x12z\n" +
	" bound_keypair_challenge_solution\x18\x01 \x01(\v2/.teleport.join.v1.BoundKeypairChallengeSolutionH\x00R\x1dboundKeypairChallengeSolution\x12w\n" +
	"\x1fbound_keypair_rotation_response\x18\x02 \x01(\v2..teleport.join.v1.BoundKeypairRotationResponseH\x00R\x1cboundKeypairRotationResponse\x12^\n" +
	"\x16iam_challenge_solution\x18\x03 \x01(\v2&.teleport.join.v1.IAMChallengeSolutionH\x00R\x14iamChallengeSolution\x12g\n" +
	"\x19oracle_challenge_solution\x18\x04 \x01(\v2).teleport.join.v1.OracleChallengeSolutionH\x00R\x17oracleChallengeSolution\x12B\n" +
	"\ftpm_solution\x18\x05 \x01(\v2\x1d.teleport.join.v1.TPMSolutionH\x00R\vtpmSolution\x12d\n" +
	"\x18azure_challenge_solution\x18\x06 \x01(\v2(.teleport.join.v1.AzureChallengeSolutionH\x00R\x16azureChallengeSolutionB\t\n" +
	"\apayload\"\xe9\x01\n" +
	"\bGivingUp\x129\n" +
	"\x06reason\x18\x01 \x01(\x0e2!.teleport.join.v1.GivingUp.ReasonR\x06reason\x12\x10\n" +
	"\x03msg\x18\x02 \x01(\tR\x03msg\"\x8f\x01\n" +
	"\x06Reason\x12\x16\n" +
	"\x12REASON_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eREASON_UNSUPPORTED_JOIN_METHOD\x10\x01\x12#\n" +
	"\x1fREASON_UNSUPPORTED_MESSAGE_TYPE\x10\x02\x12$\n" +
	" REASON_CHALLENGE_SOLUTION_FAILED\x10\x03\"\xcb\x05\n" +
	"\vJoinRequest\x12?\n" +
	"\vclient_init\x18\x01 \x01(\v2\x1c.teleport.join.v1.ClientInitH\x00R\n" +
	"clientInit\x12<\n" +
	"\n" +
	"token_init\x18\x02 \x01(\v2\x1b.teleport.join.v1.TokenInitH\x00R\ttokenInit\x12R\n" +
	"\x12bound_keypair_init\x18\x03 \x01(\v2\".teleport.join.v1.BoundKeypairInitH\x00R\x10boundKeypairInit\x12A\n" +
	"\bsolution\x18\x04 \x01(\v2#.teleport.join.v1.ChallengeSolutionH\x00R\bsolution\x126\n" +
	"\biam_init\x18\x05 \x01(\v2\x19.teleport.join.v1.IAMInitH\x00R\aiamInit\x129\n" +
	"\tgiving_up\x18\x06 \x01(\v2\x1a.teleport.join.v1.GivingUpH\x00R\bgivingUp\x126\n" +
	"\bec2_init\x18\a \x01(\v2\x19.teleport.join.v1.EC2InitH\x00R\aec2Init\x129\n" +
	"\toidc_init\x18\b \x01(\v2\x1a.teleport.join.v1.OIDCInitH\x00R\boidcInit\x12?\n" +
	"\voracle_init\x18\t \x01(\v2\x1c.teleport.join.v1.OracleInitH\x00R\n" +
	"oracleInit\x126\n" +
	"\btpm_init\x18\n" +
	" \x01(\v2\x19.teleport.join.v1.TPMInitH\x00R\atpmInit\x12<\n" +
	"\n" +
	"azure_init\x18\v \x01(\v2\x1b.teleport.join.v1.AzureInitH\x00R\tazureInitB\t\n" +
	"\apayload\"i\n" +
	"\n" +
	"ServerInit\x12\x1f\n" +
	"\vjoin_method\x18\x01 \x01(\tR\n" +
	"joinMethod\x12:\n" +
	"\x19signature_algorithm_suite\x18\x02 \x01(\tR\x17signatureAlgorithmSuite\"\xb9\x04\n" +
	"\tChallenge\x12a\n" +
	"\x17bound_keypair_challenge\x18\x01 \x01(\v2'.teleport.join.v1.BoundKeypairChallengeH\x00R\x15boundKeypairChallenge\x12t\n" +
	"\x1ebound_keypair_rotation_request\x18\x02 \x01(\v2-.teleport.join.v1.BoundKeypairRotationRequestH\x00R\x1bboundKeypairRotationRequest\x12E\n" +
	"\riam_challenge\x18\x03 \x01(\v2\x1e.teleport.join.v1.IAMChallengeH\x00R\fiamChallenge\x12N\n" +
	"\x10oracle_challenge\x18\x04 \x01(\v2!.teleport.join.v1.OracleChallengeH\x00R\x0foracleChallenge\x12d\n" +
	"\x18tpm_encrypted_credential\x18\x05 \x01(\v2(.teleport.join.v1.TPMEncryptedCredentialH\x00R\x16tpmEncryptedCredential\x12K\n" +
	"\x0fazure_challenge\x18\x06 \x01(\v2 .teleport.join.v1.AzureChallengeH\x00R\x0eazureChallengeB\t\n" +
	"\apayload\"\x92\x01\n" +
	"\x06Result\x12?\n" +
	"\vhost_result\x18\x01 \x01(\v2\x1c.teleport.join.v1.HostResultH\x00R\n" +
	"hostResult\x12<\n" +
	"\n" +
	"bot_result\x18\x02 \x01(\v2\x1b.teleport.join.v1.BotResultH\x00R\tbotResultB\t\n" +
	"\apayload\"\x86\x01\n" +
	"\fCertificates\x12\x19\n" +
	"\btls_cert\x18\x01 \x01(\fR\atlsCert\x12 \n" +
	"\ftls_ca_certs\x18\x02 \x03(\fR\n" +
	"tlsCaCerts\x12\x19\n" +
	"\bssh_cert\x18\x03 \x01(\fR\asshCert\x12\x1e\n" +
	"\vssh_ca_keys\x18\x04 \x03(\fR\tsshCaKeys\"\xc1\x01\n" +
	"\n" +
	"HostResult\x12B\n" +
	"\fcertificates\x18\x01 \x01(\v2\x1e.teleport.join.v1.CertificatesR\fcertificates\x12\x17\n" +
	"\ahost_id\x18\x02 \x01(\tR\x06hostId\x12V\n" +
	"\x10immutable_labels\x18\x03 \x01(\v2+.teleport.scopes.joining.v1.ImmutableLabelsR\x0fimmutableLabels\"\xc5\x01\n" +
	"\tBotResult\x12B\n" +
	"\fcertificates\x18\x01 \x01(\v2\x1e.teleport.join.v1.CertificatesR\fcertificates\x12[\n" +
	"\x14bound_keypair_result\x18\x02 \x01(\v2$.teleport.join.v1.BoundKeypairResultH\x00R\x12boundKeypairResult\x88\x01\x01B\x17\n" +
	"\x15_bound_keypair_result\"\xbe\x01\n" +
	"\fJoinResponse\x122\n" +
	"\x04init\x18\x01 \x01(\v2\x1c.teleport.join.v1.ServerInitH\x00R\x04init\x12;\n" +
	"\tchallenge\x18\x02 \x01(\v2\x1b.teleport.join.v1.ChallengeH\x00R\tchallenge\x122\n" +
	"\x06result\x18\x03 \x01(\v2\x18.teleport.join.v1.ResultH\x00R\x06resultB\t\n" +
	"\apayload2X\n" +
	"\vJoinService\x12I\n" +
	"\x04Join\x12\x1d.teleport.join.v1.JoinRequest\x1a\x1e.teleport.join.v1.JoinResponse(\x010\x01BLZJgithub.com/gravitational/teleport/api/gen/proto/go/teleport/join/v1;joinv1b\x06proto3"

var (
	file_teleport_join_v1_joinservice_proto_rawDescOnce sync.Once
	file_teleport_join_v1_joinservice_proto_rawDescData []byte
)

func file_teleport_join_v1_joinservice_proto_rawDescGZIP() []byte {
	file_teleport_join_v1_joinservice_proto_rawDescOnce.Do(func() {
		file_teleport_join_v1_joinservice_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_teleport_join_v1_joinservice_proto_rawDesc), len(file_teleport_join_v1_joinservice_proto_rawDesc)))
	})
	return file_teleport_join_v1_joinservice_proto_rawDescData
}

var file_teleport_join_v1_joinservice_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_teleport_join_v1_joinservice_proto_msgTypes = make([]protoimpl.MessageInfo, 37)
var file_teleport_join_v1_joinservice_proto_goTypes = []any{
	(GivingUp_Reason)(0),                   // 0: teleport.join.v1.GivingUp.Reason
	(*ClientInit)(nil),                     // 1: teleport.join.v1.ClientInit
	(*PublicKeys)(nil),                     // 2: teleport.join.v1.PublicKeys
	(*HostParams)(nil),                     // 3: teleport.join.v1.HostParams
	(*BotParams)(nil),                      // 4: teleport.join.v1.BotParams
	(*ClientParams)(nil),                   // 5: teleport.join.v1.ClientParams
	(*TokenInit)(nil),                      // 6: teleport.join.v1.TokenInit
	(*OIDCInit)(nil),                       // 7: teleport.join.v1.OIDCInit
	(*BoundKeypairInit)(nil),               // 8: teleport.join.v1.BoundKeypairInit
	(*BoundKeypairChallenge)(nil),          // 9: teleport.join.v1.BoundKeypairChallenge
	(*BoundKeypairChallengeSolution)(nil),  // 10: teleport.join.v1.BoundKeypairChallengeSolution
	(*BoundKeypairRotationRequest)(nil),    // 11: teleport.join.v1.BoundKeypairRotationRequest
	(*BoundKeypairRotationResponse)(nil),   // 12: teleport.join.v1.BoundKeypairRotationResponse
	(*BoundKeypairResult)(nil),             // 13: teleport.join.v1.BoundKeypairResult
	(*IAMInit)(nil),                        // 14: teleport.join.v1.IAMInit
	(*IAMChallenge)(nil),                   // 15: teleport.join.v1.IAMChallenge
	(*IAMChallengeSolution)(nil),           // 16: teleport.join.v1.IAMChallengeSolution
	(*EC2Init)(nil),                        // 17: teleport.join.v1.EC2Init
	(*OracleInit)(nil),                     // 18: teleport.join.v1.OracleInit
	(*OracleChallenge)(nil),                // 19: teleport.join.v1.OracleChallenge
	(*OracleChallengeSolution)(nil),        // 20: teleport.join.v1.OracleChallengeSolution
	(*TPMInit)(nil),                        // 21: teleport.join.v1.TPMInit
	(*TPMEncryptedCredential)(nil),         // 22: teleport.join.v1.TPMEncryptedCredential
	(*TPMSolution)(nil),                    // 23: teleport.join.v1.TPMSolution
	(*AzureInit)(nil),                      // 24: teleport.join.v1.AzureInit
	(*AzureChallenge)(nil),                 // 25: teleport.join.v1.AzureChallenge
	(*AzureChallengeSolution)(nil),         // 26: teleport.join.v1.AzureChallengeSolution
	(*ChallengeSolution)(nil),              // 27: teleport.join.v1.ChallengeSolution
	(*GivingUp)(nil),                       // 28: teleport.join.v1.GivingUp
	(*JoinRequest)(nil),                    // 29: teleport.join.v1.JoinRequest
	(*ServerInit)(nil),                     // 30: teleport.join.v1.ServerInit
	(*Challenge)(nil),                      // 31: teleport.join.v1.Challenge
	(*Result)(nil),                         // 32: teleport.join.v1.Result
	(*Certificates)(nil),                   // 33: teleport.join.v1.Certificates
	(*HostResult)(nil),                     // 34: teleport.join.v1.HostResult
	(*BotResult)(nil),                      // 35: teleport.join.v1.BotResult
	(*JoinResponse)(nil),                   // 36: teleport.join.v1.JoinResponse
	(*ClientInit_ProxySuppliedParams)(nil), // 37: teleport.join.v1.ClientInit.ProxySuppliedParams
	(*timestamppb.Timestamp)(nil),          // 38: google.protobuf.Timestamp
	(*v1.ImmutableLabels)(nil),             // 39: teleport.scopes.joining.v1.ImmutableLabels
}
var file_teleport_join_v1_joinservice_proto_depIdxs = []int32{
	37, // 0: teleport.join.v1.ClientInit.proxy_supplied_parameters:type_name -> teleport.join.v1.ClientInit.ProxySuppliedParams
	2,  // 1: teleport.join.v1.HostParams.public_keys:type_name -> teleport.join.v1.PublicKeys
	2,  // 2: teleport.join.v1.BotParams.public_keys:type_name -> teleport.join.v1.PublicKeys
	38, // 3: teleport.join.v1.BotParams.expires:type_name -> google.protobuf.Timestamp
	3,  // 4: teleport.join.v1.ClientParams.host_params:type_name -> teleport.join.v1.HostParams
	4,  // 5: teleport.join.v1.ClientParams.bot_params:type_name -> teleport.join.v1.BotParams
	5,  // 6: teleport.join.v1.TokenInit.client_params:type_name -> teleport.join.v1.ClientParams
	5,  // 7: teleport.join.v1.OIDCInit.client_params:type_name -> teleport.join.v1.ClientParams
	5,  // 8: teleport.join.v1.BoundKeypairInit.client_params:type_name -> teleport.join.v1.ClientParams
	5,  // 9: teleport.join.v1.IAMInit.client_params:type_name -> teleport.join.v1.ClientParams
	5,  // 10: teleport.join.v1.EC2Init.client_params:type_name -> teleport.join.v1.ClientParams
	5,  // 11: teleport.join.v1.OracleInit.client_params:type_name -> teleport.join.v1.ClientParams
	5,  // 12: teleport.join.v1.TPMInit.client_params:type_name -> teleport.join.v1.ClientParams
	5,  // 13: teleport.join.v1.AzureInit.client_params:type_name -> teleport.join.v1.ClientParams
	10, // 14: teleport.join.v1.ChallengeSolution.bound_keypair_challenge_solution:type_name -> teleport.join.v1.BoundKeypairChallengeSolution
	12, // 15: teleport.join.v1.ChallengeSolution.bound_keypair_rotation_response:type_name -> teleport.join.v1.BoundKeypairRotationResponse
	16, // 16: teleport.join.v1.ChallengeSolution.iam_challenge_solution:type_name -> teleport.join.v1.IAMChallengeSolution
	20, // 17: teleport.join.v1.ChallengeSolution.oracle_challenge_solution:type_name -> teleport.join.v1.OracleChallengeSolution
	23, // 18: teleport.join.v1.ChallengeSolution.tpm_solution:type_name -> teleport.join.v1.TPMSolution
	26, // 19: teleport.join.v1.ChallengeSolution.azure_challenge_solution:type_name -> teleport.join.v1.AzureChallengeSolution
	0,  // 20: teleport.join.v1.GivingUp.reason:type_name -> teleport.join.v1.GivingUp.Reason
	1,  // 21: teleport.join.v1.JoinRequest.client_init:type_name -> teleport.join.v1.ClientInit
	6,  // 22: teleport.join.v1.JoinRequest.token_init:type_name -> teleport.join.v1.TokenInit
	8,  // 23: teleport.join.v1.JoinRequest.bound_keypair_init:type_name -> teleport.join.v1.BoundKeypairInit
	27, // 24: teleport.join.v1.JoinRequest.solution:type_name -> teleport.join.v1.ChallengeSolution
	14, // 25: teleport.join.v1.JoinRequest.iam_init:type_name -> teleport.join.v1.IAMInit
	28, // 26: teleport.join.v1.JoinRequest.giving_up:type_name -> teleport.join.v1.GivingUp
	17, // 27: teleport.join.v1.JoinRequest.ec2_init:type_name -> teleport.join.v1.EC2Init
	7,  // 28: teleport.join.v1.JoinRequest.oidc_init:type_name -> teleport.join.v1.OIDCInit
	18, // 29: teleport.join.v1.JoinRequest.oracle_init:type_name -> teleport.join.v1.OracleInit
	21, // 30: teleport.join.v1.JoinRequest.tpm_init:type_name -> teleport.join.v1.TPMInit
	24, // 31: teleport.join.v1.JoinRequest.azure_init:type_name -> teleport.join.v1.AzureInit
	9,  // 32: teleport.join.v1.Challenge.bound_keypair_challenge:type_name -> teleport.join.v1.BoundKeypairChallenge
	11, // 33: teleport.join.v1.Challenge.bound_keypair_rotation_request:type_name -> teleport.join.v1.BoundKeypairRotationRequest
	15, // 34: teleport.join.v1.Challenge.iam_challenge:type_name -> teleport.join.v1.IAMChallenge
	19, // 35: teleport.join.v1.Challenge.oracle_challenge:type_name -> teleport.join.v1.OracleChallenge
	22, // 36: teleport.join.v1.Challenge.tpm_encrypted_credential:type_name -> teleport.join.v1.TPMEncryptedCredential
	25, // 37: teleport.join.v1.Challenge.azure_challenge:type_name -> teleport.join.v1.AzureChallenge
	34, // 38: teleport.join.v1.Result.host_result:type_name -> teleport.join.v1.HostResult
	35, // 39: teleport.join.v1.Result.bot_result:type_name -> teleport.join.v1.BotResult
	33, // 40: teleport.join.v1.HostResult.certificates:type_name -> teleport.join.v1.Certificates
	39, // 41: teleport.join.v1.HostResult.immutable_labels:type_name -> teleport.scopes.joining.v1.ImmutableLabels
	33, // 42: teleport.join.v1.BotResult.certificates:type_name -> teleport.join.v1.Certificates
	13, // 43: teleport.join.v1.BotResult.bound_keypair_result:type_name -> teleport.join.v1.BoundKeypairResult
	30, // 44: teleport.join.v1.JoinResponse.init:type_name -> teleport.join.v1.ServerInit
	31, // 45: teleport.join.v1.JoinResponse.challenge:type_name -> teleport.join.v1.Challenge
	32, // 46: teleport.join.v1.JoinResponse.result:type_name -> teleport.join.v1.Result
	29, // 47: teleport.join.v1.JoinService.Join:input_type -> teleport.join.v1.JoinRequest
	36, // 48: teleport.join.v1.JoinService.Join:output_type -> teleport.join.v1.JoinResponse
	48, // [48:49] is the sub-list for method output_type
	47, // [47:48] is the sub-list for method input_type
	47, // [47:47] is the sub-list for extension type_name
	47, // [47:47] is the sub-list for extension extendee
	0,  // [0:47] is the sub-list for field type_name
}

func init() { file_teleport_join_v1_joinservice_proto_init() }
func file_teleport_join_v1_joinservice_proto_init() {
	if File_teleport_join_v1_joinservice_proto != nil {
		return
	}
	file_teleport_join_v1_joinservice_proto_msgTypes[0].OneofWrappers = []any{}
	file_teleport_join_v1_joinservice_proto_msgTypes[3].OneofWrappers = []any{}
	file_teleport_join_v1_joinservice_proto_msgTypes[4].OneofWrappers = []any{
		(*ClientParams_HostParams)(nil),
		(*ClientParams_BotParams)(nil),
	}
	file_teleport_join_v1_joinservice_proto_msgTypes[20].OneofWrappers = []any{
		(*TPMInit_EkCert)(nil),
		(*TPMInit_EkKey)(nil),
	}
	file_teleport_join_v1_joinservice_proto_msgTypes[26].OneofWrappers = []any{
		(*ChallengeSolution_BoundKeypairChallengeSolution)(nil),
		(*ChallengeSolution_BoundKeypairRotationResponse)(nil),
		(*ChallengeSolution_IamChallengeSolution)(nil),
		(*ChallengeSolution_OracleChallengeSolution)(nil),
		(*ChallengeSolution_TpmSolution)(nil),
		(*ChallengeSolution_AzureChallengeSolution)(nil),
	}
	file_teleport_join_v1_joinservice_proto_msgTypes[28].OneofWrappers = []any{
		(*JoinRequest_ClientInit)(nil),
		(*JoinRequest_TokenInit)(nil),
		(*JoinRequest_BoundKeypairInit)(nil),
		(*JoinRequest_Solution)(nil),
		(*JoinRequest_IamInit)(nil),
		(*JoinRequest_GivingUp)(nil),
		(*JoinRequest_Ec2Init)(nil),
		(*JoinRequest_OidcInit)(nil),
		(*JoinRequest_OracleInit)(nil),
		(*JoinRequest_TpmInit)(nil),
		(*JoinRequest_AzureInit)(nil),
	}
	file_teleport_join_v1_joinservice_proto_msgTypes[30].OneofWrappers = []any{
		(*Challenge_BoundKeypairChallenge)(nil),
		(*Challenge_BoundKeypairRotationRequest)(nil),
		(*Challenge_IamChallenge)(nil),
		(*Challenge_OracleChallenge)(nil),
		(*Challenge_TpmEncryptedCredential)(nil),
		(*Challenge_AzureChallenge)(nil),
	}
	file_teleport_join_v1_joinservice_proto_msgTypes[31].OneofWrappers = []any{
		(*Result_HostResult)(nil),
		(*Result_BotResult)(nil),
	}
	file_teleport_join_v1_joinservice_proto_msgTypes[34].OneofWrappers = []any{}
	file_teleport_join_v1_joinservice_proto_msgTypes[35].OneofWrappers = []any{
		(*JoinResponse_Init)(nil),
		(*JoinResponse_Challenge)(nil),
		(*JoinResponse_Result)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_teleport_join_v1_joinservice_proto_rawDesc), len(file_teleport_join_v1_joinservice_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   37,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_teleport_join_v1_joinservice_proto_goTypes,
		DependencyIndexes: file_teleport_join_v1_joinservice_proto_depIdxs,
		EnumInfos:         file_teleport_join_v1_joinservice_proto_enumTypes,
		MessageInfos:      file_teleport_join_v1_joinservice_proto_msgTypes,
	}.Build()
	File_teleport_join_v1_joinservice_proto = out.File
	file_teleport_join_v1_joinservice_proto_goTypes = nil
	file_teleport_join_v1_joinservice_proto_depIdxs = nil
}
