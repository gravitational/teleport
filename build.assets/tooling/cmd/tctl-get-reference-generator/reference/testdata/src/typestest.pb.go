// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/legacy/typestest/typestest.proto

package typestest

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DatabaseTLSMode represents the level of TLS verification performed by
// DB agent when connecting to a database.
type DatabaseTLSMode int32

const (
	// VERIFY_FULL performs full certificate validation.
	DatabaseTLSMode_VERIFY_FULL DatabaseTLSMode = 0
	// VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.
	DatabaseTLSMode_VERIFY_CA DatabaseTLSMode = 1
	// INSECURE accepts any certificate provided by server. This is the least secure option.
	DatabaseTLSMode_INSECURE DatabaseTLSMode = 2
)

var DatabaseTLSMode_name = map[int32]string{
	0: "VERIFY_FULL",
	1: "VERIFY_CA",
	2: "INSECURE",
}

var DatabaseTLSMode_value = map[string]int32{
	"VERIFY_FULL": 0,
	"VERIFY_CA":   1,
	"INSECURE":    2,
}

func (x DatabaseTLSMode) String() string {
	return proto.EnumName(DatabaseTLSMode_name, int32(x))
}

func (DatabaseTLSMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{0}
}

// IAMPolicyStatus represents states that describe if an AWS database
// has its IAM policy properly configured or not.
// This enum is set in a Sync.Map during an IAM task that checks for the
// validity of IAM policy, and the database gets updated with the value
// from this map during a heartbeat.
type IAMPolicyStatus int32

const (
	// IAM_POLICY_STATUS_UNSPECIFIED represents a zero value where
	// nothing has been attempted yet.
	IAMPolicyStatus_IAM_POLICY_STATUS_UNSPECIFIED IAMPolicyStatus = 0
	// IAM_POLICY_STATUS_PENDING represents a state where iam policy status
	// is pending to be checked. This enum value is set at the start of
	// registering a database -> IAM setup (before the db heartbeat starts).
	//
	// This state was required for two reasons:
	//   1) To be able to tell apart from an older service that do not update
	//      the IAMPolicyStatus (in which case the enum value will remain the
	//      zero value).
	//   2) When starting a database, the heartbeat and its IAM task starts,
	//      and the heartbeat may run first before the IAM task finishes.
	IAMPolicyStatus_IAM_POLICY_STATUS_PENDING IAMPolicyStatus = 1
	// IAM_POLICY_STATUS_FAILED represents a state where an error occured
	// while checking for IAM policy status eg: no AWS credentials provider found
	// or the policy was misconfigured.
	IAMPolicyStatus_IAM_POLICY_STATUS_FAILED IAMPolicyStatus = 2
	// IAM_POLICY_STATUS_SUCCESS represents a state where IAM policy was configured
	// correctly.
	IAMPolicyStatus_IAM_POLICY_STATUS_SUCCESS IAMPolicyStatus = 3
)

var IAMPolicyStatus_name = map[int32]string{
	0: "IAM_POLICY_STATUS_UNSPECIFIED",
	1: "IAM_POLICY_STATUS_PENDING",
	2: "IAM_POLICY_STATUS_FAILED",
	3: "IAM_POLICY_STATUS_SUCCESS",
}

var IAMPolicyStatus_value = map[string]int32{
	"IAM_POLICY_STATUS_UNSPECIFIED": 0,
	"IAM_POLICY_STATUS_PENDING":     1,
	"IAM_POLICY_STATUS_FAILED":      2,
	"IAM_POLICY_STATUS_SUCCESS":     3,
}

func (x IAMPolicyStatus) String() string {
	return proto.EnumName(IAMPolicyStatus_name, int32(x))
}

func (IAMPolicyStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{1}
}

// ResourceHeader is a shared resource header
// used in cases when only type and name is known
type ResourceHeader struct {
	// Kind is a resource kind
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind,omitempty"`
	// SubKind is an optional resource sub kind, used in some resources
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is version
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version,omitempty"`
	// Metadata is resource metadata
	Metadata             Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceHeader) Reset()         { *m = ResourceHeader{} }
func (m *ResourceHeader) String() string { return proto.CompactTextString(m) }
func (*ResourceHeader) ProtoMessage()    {}
func (*ResourceHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{0}
}
func (m *ResourceHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeader.Merge(m, src)
}
func (m *ResourceHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeader proto.InternalMessageInfo

// Metadata is resource metadata
type Metadata struct {
	// Name is an object name
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Namespace is object namespace. The field should be called "namespace"
	// when it returns in Teleport 2.4.
	Namespace string `protobuf:"bytes,2,opt,name=Namespace,proto3" json:"-"`
	// Description is object description
	Description string `protobuf:"bytes,3,opt,name=Description,proto3" json:"description,omitempty"`
	// Labels is a set of labels
	Labels map[string]string `protobuf:"bytes,5,rep,name=Labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Expires is a global expiry time header can be set on any resource in the
	// system.
	Expires *time.Time `protobuf:"bytes,6,opt,name=Expires,proto3,stdtime" json:"expires,omitempty"`
	// ID is a record ID.
	// Deprecated: Use revision instead.
	ID int64 `protobuf:"varint,7,opt,name=ID,proto3" json:"id,omitempty"` // Deprecated: Do not use.
	// Revision is an opaque identifier which tracks the versions of a resource
	// over time. Clients should ignore and not alter its value but must return
	// the revision in any updates of a resource.
	Revision             string   `protobuf:"bytes,8,opt,name=Revision,proto3" json:"revision,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{1}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

// CommandLabelV2 is a label that has a value as a result of the
// output generated by running command, e.g. hostname
type CommandLabelV2 struct {
	// Period is a time between command runs
	Period Duration `protobuf:"varint,1,opt,name=Period,proto3,casttype=Duration" json:"period"`
	// Command is a command to run
	Command []string `protobuf:"bytes,2,rep,name=Command,proto3" json:"command"`
	// Result captures standard output
	Result               string   `protobuf:"bytes,3,opt,name=Result,proto3" json:"result"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandLabelV2) Reset()         { *m = CommandLabelV2{} }
func (m *CommandLabelV2) String() string { return proto.CompactTextString(m) }
func (*CommandLabelV2) ProtoMessage()    {}
func (*CommandLabelV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{2}
}
func (m *CommandLabelV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandLabelV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandLabelV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandLabelV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandLabelV2.Merge(m, src)
}
func (m *CommandLabelV2) XXX_Size() int {
	return m.Size()
}
func (m *CommandLabelV2) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandLabelV2.DiscardUnknown(m)
}

var xxx_messageInfo_CommandLabelV2 proto.InternalMessageInfo

// DatabaseSpecV3 is the database spec.
type DatabaseSpecV3 struct {
	// Protocol is the database protocol: postgres, mysql, mongodb, etc.
	Protocol string `protobuf:"bytes,1,opt,name=Protocol,proto3" json:"protocol"`
	// URI is the database connection endpoint.
	URI string `protobuf:"bytes,2,opt,name=URI,proto3" json:"uri"`
	// CACert is the PEM-encoded database CA certificate.
	//
	// DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
	CACert string `protobuf:"bytes,3,opt,name=CACert,proto3" json:"ca_cert,omitempty"` // Deprecated: Do not use.
	// DynamicLabels is the database dynamic labels.
	DynamicLabels map[string]CommandLabelV2 `protobuf:"bytes,4,rep,name=DynamicLabels,proto3" json:"dynamic_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
	AWS AWS `protobuf:"bytes,5,opt,name=AWS,proto3" json:"aws,omitempty"`
	// GCP contains parameters specific to GCP Cloud SQL databases.
	GCP GCPCloudSQL `protobuf:"bytes,6,opt,name=GCP,proto3" json:"gcp,omitempty"`
	// Azure contains Azure specific database metadata.
	Azure Azure `protobuf:"bytes,7,opt,name=Azure,proto3" json:"azure,omitempty"`
	// TLS is the TLS configuration used when establishing connection to target database.
	// Allows to provide custom CA cert or override server name.
	TLS DatabaseTLS `protobuf:"bytes,8,opt,name=TLS,proto3" json:"tls,omitempty"`
	// AD is the Active Directory configuration for the database.
	AD AD `protobuf:"bytes,9,opt,name=AD,proto3" json:"ad,omitempty"`
	// MySQL is an additional section with MySQL database options.
	MySQL MySQLOptions `protobuf:"bytes,10,opt,name=MySQL,proto3" json:"mysql,omitempty"`
	// AdminUser is the database admin user for automatic user provisioning.
	AdminUser *DatabaseAdminUser `protobuf:"bytes,11,opt,name=AdminUser,proto3" json:"admin_user,omitempty"`
	// MongoAtlas contains Atlas metadata about the database.
	MongoAtlas MongoAtlas `protobuf:"bytes,12,opt,name=MongoAtlas,proto3" json:"mongo_atlas,omitempty"`
	// Oracle is an additional Oracle configuration options.
	Oracle               OracleOptions `protobuf:"bytes,13,opt,name=Oracle,proto3" json:"oracle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DatabaseSpecV3) Reset()         { *m = DatabaseSpecV3{} }
func (m *DatabaseSpecV3) String() string { return proto.CompactTextString(m) }
func (*DatabaseSpecV3) ProtoMessage()    {}
func (*DatabaseSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{3}
}
func (m *DatabaseSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseSpecV3.Merge(m, src)
}
func (m *DatabaseSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseSpecV3 proto.InternalMessageInfo

// DatabaseV3 represents a single proxied database.
type DatabaseV3 struct {
	// Kind is the database resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the database metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the database spec.
	Spec DatabaseSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	// Status is the database runtime information.
	Status               DatabaseStatusV3 `protobuf:"bytes,6,opt,name=Status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DatabaseV3) Reset()      { *m = DatabaseV3{} }
func (*DatabaseV3) ProtoMessage() {}
func (*DatabaseV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{4}
}
func (m *DatabaseV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseV3.Merge(m, src)
}
func (m *DatabaseV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseV3 proto.InternalMessageInfo

// DatabaseServerV3 represents a database access server.
type DatabaseServerV3 struct {
	// Kind is the database server resource kind.
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the database server metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the database server spec.
	Spec                 DatabaseServerSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DatabaseServerV3) Reset()      { *m = DatabaseServerV3{} }
func (*DatabaseServerV3) ProtoMessage() {}
func (*DatabaseServerV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{5}
}
func (m *DatabaseServerV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseServerV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseServerV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseServerV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseServerV3.Merge(m, src)
}
func (m *DatabaseServerV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseServerV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseServerV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseServerV3 proto.InternalMessageInfo

// DatabaseServerSpecV3 is the database server spec.
type DatabaseServerSpecV3 struct {
	// Version is the Teleport version that the server is running.
	Version string `protobuf:"bytes,6,opt,name=Version,proto3" json:"version"`
	// Hostname is the database server hostname.
	Hostname string `protobuf:"bytes,7,opt,name=Hostname,proto3" json:"hostname"`
	// HostID is the ID of the host the database server is running on.
	HostID string `protobuf:"bytes,8,opt,name=HostID,proto3" json:"host_id"`
	// Rotation contains the server CA rotation information.
	Rotation Rotation `protobuf:"bytes,10,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// Database is the database proxied by this database server.
	Database *DatabaseV3 `protobuf:"bytes,12,opt,name=Database,proto3" json:"database,omitempty"`
	// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
	ProxyIDs             []string `protobuf:"bytes,13,rep,name=ProxyIDs,proto3" json:"proxy_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseServerSpecV3) Reset()         { *m = DatabaseServerSpecV3{} }
func (m *DatabaseServerSpecV3) String() string { return proto.CompactTextString(m) }
func (*DatabaseServerSpecV3) ProtoMessage()    {}
func (*DatabaseServerSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{6}
}
func (m *DatabaseServerSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseServerSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseServerSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseServerSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseServerSpecV3.Merge(m, src)
}
func (m *DatabaseServerSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseServerSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseServerSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseServerSpecV3 proto.InternalMessageInfo

// DatabaseStatusV3 contains runtime information about the database.
type DatabaseStatusV3 struct {
	// CACert is the auto-downloaded cloud database CA certificate.
	CACert string `protobuf:"bytes,1,opt,name=CACert,proto3" json:"ca_cert,omitempty"`
	// AWS is the auto-discovered AWS cloud database metadata.
	AWS AWS `protobuf:"bytes,2,opt,name=AWS,proto3" json:"aws"`
	// MySQL is an additional section with MySQL runtime database information.
	MySQL MySQLOptions `protobuf:"bytes,3,opt,name=MySQL,proto3" json:"mysql,omitempty"`
	// ManagedUsers is a list of database users that are managed by Teleport.
	ManagedUsers []string `protobuf:"bytes,4,rep,name=ManagedUsers,proto3" json:"managed_users,omitempty"`
	// Azure is the auto-discovered Azure cloud database metadata.
	Azure                Azure    `protobuf:"bytes,5,opt,name=Azure,proto3" json:"azure"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseStatusV3) Reset()         { *m = DatabaseStatusV3{} }
func (m *DatabaseStatusV3) String() string { return proto.CompactTextString(m) }
func (*DatabaseStatusV3) ProtoMessage()    {}
func (*DatabaseStatusV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{7}
}
func (m *DatabaseStatusV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseStatusV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseStatusV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseStatusV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseStatusV3.Merge(m, src)
}
func (m *DatabaseStatusV3) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseStatusV3) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseStatusV3.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseStatusV3 proto.InternalMessageInfo

// AWS contains AWS metadata about the database.
type AWS struct {
	// Region is a AWS cloud region.
	Region string `protobuf:"bytes,1,opt,name=Region,proto3" json:"region,omitempty"`
	// Redshift contains Redshift specific metadata.
	Redshift Redshift `protobuf:"bytes,2,opt,name=Redshift,proto3" json:"redshift,omitempty"`
	// RDS contains RDS specific metadata.
	RDS RDS `protobuf:"bytes,3,opt,name=RDS,proto3" json:"rds,omitempty"`
	// AccountID is the AWS account ID this database belongs to.
	AccountID string `protobuf:"bytes,4,opt,name=AccountID,proto3" json:"account_id,omitempty"`
	// ElastiCache contains AWS ElastiCache Redis specific metadata.
	ElastiCache ElastiCache `protobuf:"bytes,5,opt,name=ElastiCache,proto3" json:"elasticache,omitempty"`
	// SecretStore contains secret store configurations.
	SecretStore SecretStore `protobuf:"bytes,6,opt,name=SecretStore,proto3" json:"secret_store,omitempty"`
	// MemoryDB contains AWS MemoryDB specific metadata.
	MemoryDB MemoryDB `protobuf:"bytes,7,opt,name=MemoryDB,proto3" json:"memorydb,omitempty"`
	// RDSProxy contains AWS Proxy specific metadata.
	RDSProxy RDSProxy `protobuf:"bytes,8,opt,name=RDSProxy,proto3" json:"rdsproxy,omitempty"`
	// RedshiftServerless contains AWS Redshift Serverless specific metadata.
	RedshiftServerless RedshiftServerless `protobuf:"bytes,9,opt,name=RedshiftServerless,proto3" json:"redshift_serverless,omitempty"`
	// ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
	ExternalID string `protobuf:"bytes,10,opt,name=ExternalID,proto3" json:"external_id,omitempty"`
	// AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
	// Set this field and ExternalID to enable access across AWS accounts.
	AssumeRoleARN string `protobuf:"bytes,11,opt,name=AssumeRoleARN,proto3" json:"assume_role_arn,omitempty"`
	// OpenSearch contains AWS OpenSearch specific metadata.
	OpenSearch OpenSearch `protobuf:"bytes,12,opt,name=OpenSearch,proto3" json:"opensearch,omitempty"`
	// IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access.
	// If not, the user must update the AWS profile identity to allow access to the Database.
	// Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
	IAMPolicyStatus      IAMPolicyStatus `protobuf:"varint,14,opt,name=IAMPolicyStatus,proto3,enum=typestest.IAMPolicyStatus" json:"iam_policy_status"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AWS) Reset()         { *m = AWS{} }
func (m *AWS) String() string { return proto.CompactTextString(m) }
func (*AWS) ProtoMessage()    {}
func (*AWS) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{8}
}
func (m *AWS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWS.Merge(m, src)
}
func (m *AWS) XXX_Size() int {
	return m.Size()
}
func (m *AWS) XXX_DiscardUnknown() {
	xxx_messageInfo_AWS.DiscardUnknown(m)
}

var xxx_messageInfo_AWS proto.InternalMessageInfo

// Header represents a single http header passed over to the proxied application.
type Header struct {
	// Name is the http header name.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	// Value is the http header value.
	Value                string   `protobuf:"bytes,2,opt,name=Value,proto3" json:"value"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{9}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

// AzureRedis contains Azure Cache for Redis specific database metadata.
type AzureRedis struct {
	// ClusteringPolicy is the clustering policy for Redis Enterprise.
	ClusteringPolicy     string   `protobuf:"bytes,1,opt,name=ClusteringPolicy,proto3" json:"clustering_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AzureRedis) Reset()         { *m = AzureRedis{} }
func (m *AzureRedis) String() string { return proto.CompactTextString(m) }
func (*AzureRedis) ProtoMessage()    {}
func (*AzureRedis) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{10}
}
func (m *AzureRedis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureRedis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AzureRedis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AzureRedis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureRedis.Merge(m, src)
}
func (m *AzureRedis) XXX_Size() int {
	return m.Size()
}
func (m *AzureRedis) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureRedis.DiscardUnknown(m)
}

var xxx_messageInfo_AzureRedis proto.InternalMessageInfo

// Redshift contains AWS Redshift specific database metadata.
type Redshift struct {
	// ClusterID is the Redshift cluster identifier.
	ClusterID            string   `protobuf:"bytes,1,opt,name=ClusterID,proto3" json:"cluster_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Redshift) Reset()         { *m = Redshift{} }
func (m *Redshift) String() string { return proto.CompactTextString(m) }
func (*Redshift) ProtoMessage()    {}
func (*Redshift) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{11}
}
func (m *Redshift) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Redshift) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Redshift.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Redshift) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Redshift.Merge(m, src)
}
func (m *Redshift) XXX_Size() int {
	return m.Size()
}
func (m *Redshift) XXX_DiscardUnknown() {
	xxx_messageInfo_Redshift.DiscardUnknown(m)
}

var xxx_messageInfo_Redshift proto.InternalMessageInfo

// RDS contains AWS RDS specific database metadata.
type RDS struct {
	// InstanceID is the RDS instance identifier.
	InstanceID string `protobuf:"bytes,1,opt,name=InstanceID,proto3" json:"instance_id,omitempty"`
	// ClusterID is the RDS cluster (Aurora) identifier.
	ClusterID string `protobuf:"bytes,2,opt,name=ClusterID,proto3" json:"cluster_id,omitempty"`
	// ResourceID is the RDS instance resource identifier (db-xxx).
	ResourceID string `protobuf:"bytes,3,opt,name=ResourceID,proto3" json:"resource_id,omitempty"`
	// IAMAuth indicates whether database IAM authentication is enabled.
	IAMAuth bool `protobuf:"varint,4,opt,name=IAMAuth,proto3" json:"iam_auth"`
	// Subnets is a list of subnets for the RDS instance.
	Subnets []string `protobuf:"bytes,5,rep,name=Subnets,proto3" json:"subnets,omitempty"`
	// VPCID is the VPC where the RDS is running.
	VPCID                string   `protobuf:"bytes,6,opt,name=VPCID,proto3" json:"vpc_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RDS) Reset()         { *m = RDS{} }
func (m *RDS) String() string { return proto.CompactTextString(m) }
func (*RDS) ProtoMessage()    {}
func (*RDS) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{12}
}
func (m *RDS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RDS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RDS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RDS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RDS.Merge(m, src)
}
func (m *RDS) XXX_Size() int {
	return m.Size()
}
func (m *RDS) XXX_DiscardUnknown() {
	xxx_messageInfo_RDS.DiscardUnknown(m)
}

var xxx_messageInfo_RDS proto.InternalMessageInfo

// ElastiCache contains AWS ElastiCache Redis specific metadata.
type ElastiCache struct {
	// ReplicationGroupID is the Redis replication group ID.
	ReplicationGroupID string `protobuf:"bytes,1,opt,name=ReplicationGroupID,proto3" json:"replication_group_id,omitempty"`
	// UserGroupIDs is a list of user group IDs.
	UserGroupIDs []string `protobuf:"bytes,2,rep,name=UserGroupIDs,proto3" json:"user_group_ids,omitempty"`
	// TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
	TransitEncryptionEnabled bool `protobuf:"varint,3,opt,name=TransitEncryptionEnabled,proto3" json:"transit_encryption_enabled,omitempty"`
	// EndpointType is the type of the endpoint.
	EndpointType         string   `protobuf:"bytes,4,opt,name=EndpointType,proto3" json:"endpoint_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ElastiCache) Reset()         { *m = ElastiCache{} }
func (m *ElastiCache) String() string { return proto.CompactTextString(m) }
func (*ElastiCache) ProtoMessage()    {}
func (*ElastiCache) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{13}
}
func (m *ElastiCache) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElastiCache) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ElastiCache.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ElastiCache) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElastiCache.Merge(m, src)
}
func (m *ElastiCache) XXX_Size() int {
	return m.Size()
}
func (m *ElastiCache) XXX_DiscardUnknown() {
	xxx_messageInfo_ElastiCache.DiscardUnknown(m)
}

var xxx_messageInfo_ElastiCache proto.InternalMessageInfo

// SecretStore contains secret store configurations.
type SecretStore struct {
	// KeyPrefix specifies the secret key prefix.
	KeyPrefix string `protobuf:"bytes,1,opt,name=KeyPrefix,proto3" json:"key_prefix,omitempty"`
	// KMSKeyID specifies the AWS KMS key for encryption.
	KMSKeyID             string   `protobuf:"bytes,2,opt,name=KMSKeyID,proto3" json:"kms_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecretStore) Reset()         { *m = SecretStore{} }
func (m *SecretStore) String() string { return proto.CompactTextString(m) }
func (*SecretStore) ProtoMessage()    {}
func (*SecretStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{14}
}
func (m *SecretStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecretStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretStore.Merge(m, src)
}
func (m *SecretStore) XXX_Size() int {
	return m.Size()
}
func (m *SecretStore) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretStore.DiscardUnknown(m)
}

var xxx_messageInfo_SecretStore proto.InternalMessageInfo

// MemoryDB contains AWS MemoryDB specific metadata.
type MemoryDB struct {
	// ClusterName is the name of the MemoryDB cluster.
	ClusterName string `protobuf:"bytes,1,opt,name=ClusterName,proto3" json:"cluster_name,omitempty"`
	// ACLName is the name of the ACL associated with the cluster.
	ACLName string `protobuf:"bytes,2,opt,name=ACLName,proto3" json:"acl_name,omitempty"`
	// TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
	TLSEnabled bool `protobuf:"varint,3,opt,name=TLSEnabled,proto3" json:"tls_enabled,omitempty"`
	// EndpointType is the type of the endpoint.
	EndpointType         string   `protobuf:"bytes,4,opt,name=EndpointType,proto3" json:"endpoint_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryDB) Reset()         { *m = MemoryDB{} }
func (m *MemoryDB) String() string { return proto.CompactTextString(m) }
func (*MemoryDB) ProtoMessage()    {}
func (*MemoryDB) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{15}
}
func (m *MemoryDB) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryDB) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryDB.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryDB) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryDB.Merge(m, src)
}
func (m *MemoryDB) XXX_Size() int {
	return m.Size()
}
func (m *MemoryDB) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryDB.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryDB proto.InternalMessageInfo

// RDSProxy contains AWS RDS Proxy specific database metadata.
type RDSProxy struct {
	// Name is the identifier of an RDS Proxy.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	// CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
	CustomEndpointName string `protobuf:"bytes,2,opt,name=CustomEndpointName,proto3" json:"custom_endpoint_name,omitempty"`
	// ResourceID is the RDS instance resource identifier (prx-xxx).
	ResourceID           string   `protobuf:"bytes,3,opt,name=ResourceID,proto3" json:"resource_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RDSProxy) Reset()         { *m = RDSProxy{} }
func (m *RDSProxy) String() string { return proto.CompactTextString(m) }
func (*RDSProxy) ProtoMessage()    {}
func (*RDSProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{16}
}
func (m *RDSProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RDSProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RDSProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RDSProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RDSProxy.Merge(m, src)
}
func (m *RDSProxy) XXX_Size() int {
	return m.Size()
}
func (m *RDSProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_RDSProxy.DiscardUnknown(m)
}

var xxx_messageInfo_RDSProxy proto.InternalMessageInfo

// RedshiftServerless contains AWS Redshift Serverless specific metadata.
type RedshiftServerless struct {
	// WorkgroupName is the workgroup name.
	WorkgroupName string `protobuf:"bytes,1,opt,name=WorkgroupName,proto3" json:"workgroup_name,omitempty"`
	// EndpointName is the VPC endpoint name.
	EndpointName string `protobuf:"bytes,2,opt,name=EndpointName,proto3" json:"endpoint_name,omitempty"`
	// WorkgroupID is the workgroup ID.
	WorkgroupID          string   `protobuf:"bytes,3,opt,name=WorkgroupID,proto3" json:"workgroup_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RedshiftServerless) Reset()         { *m = RedshiftServerless{} }
func (m *RedshiftServerless) String() string { return proto.CompactTextString(m) }
func (*RedshiftServerless) ProtoMessage()    {}
func (*RedshiftServerless) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{17}
}
func (m *RedshiftServerless) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedshiftServerless) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedshiftServerless.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedshiftServerless) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedshiftServerless.Merge(m, src)
}
func (m *RedshiftServerless) XXX_Size() int {
	return m.Size()
}
func (m *RedshiftServerless) XXX_DiscardUnknown() {
	xxx_messageInfo_RedshiftServerless.DiscardUnknown(m)
}

var xxx_messageInfo_RedshiftServerless proto.InternalMessageInfo

// OpenSearch contains AWS OpenSearch specific metadata.
type OpenSearch struct {
	// DomainName is the name of the domain.
	DomainName string `protobuf:"bytes,1,opt,name=DomainName,proto3" json:"domain_name,omitempty"`
	// DomainID is the ID of the domain.
	DomainID string `protobuf:"bytes,2,opt,name=DomainID,proto3" json:"domain_id,omitempty"`
	// EndpointType is the type of the endpoint.
	EndpointType         string   `protobuf:"bytes,3,opt,name=EndpointType,proto3" json:"endpoint_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenSearch) Reset()         { *m = OpenSearch{} }
func (m *OpenSearch) String() string { return proto.CompactTextString(m) }
func (*OpenSearch) ProtoMessage()    {}
func (*OpenSearch) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{18}
}
func (m *OpenSearch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenSearch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenSearch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenSearch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenSearch.Merge(m, src)
}
func (m *OpenSearch) XXX_Size() int {
	return m.Size()
}
func (m *OpenSearch) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenSearch.DiscardUnknown(m)
}

var xxx_messageInfo_OpenSearch proto.InternalMessageInfo

// GCPCloudSQL contains parameters specific to GCP Cloud SQL databases.
type GCPCloudSQL struct {
	// ProjectID is the GCP project ID the Cloud SQL instance resides in.
	ProjectID string `protobuf:"bytes,1,opt,name=ProjectID,proto3" json:"project_id,omitempty"`
	// InstanceID is the Cloud SQL instance ID.
	InstanceID           string   `protobuf:"bytes,2,opt,name=InstanceID,proto3" json:"instance_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GCPCloudSQL) Reset()         { *m = GCPCloudSQL{} }
func (m *GCPCloudSQL) String() string { return proto.CompactTextString(m) }
func (*GCPCloudSQL) ProtoMessage()    {}
func (*GCPCloudSQL) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{19}
}
func (m *GCPCloudSQL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPCloudSQL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GCPCloudSQL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GCPCloudSQL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPCloudSQL.Merge(m, src)
}
func (m *GCPCloudSQL) XXX_Size() int {
	return m.Size()
}
func (m *GCPCloudSQL) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPCloudSQL.DiscardUnknown(m)
}

var xxx_messageInfo_GCPCloudSQL proto.InternalMessageInfo

// Azure contains Azure specific database metadata.
type Azure struct {
	// Name is the Azure database server name.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	// ResourceID is the Azure fully qualified ID for the resource.
	ResourceID string `protobuf:"bytes,2,opt,name=ResourceID,proto3" json:"resource_id,omitempty"`
	// Redis contains Azure Cache for Redis specific database metadata.
	Redis AzureRedis `protobuf:"bytes,3,opt,name=Redis,proto3" json:"redis,omitempty"`
	// IsFlexiServer is true if the database is an Azure Flexible server.
	IsFlexiServer        bool     `protobuf:"varint,4,opt,name=IsFlexiServer,proto3" json:"is_flexi_server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Azure) Reset()         { *m = Azure{} }
func (m *Azure) String() string { return proto.CompactTextString(m) }
func (*Azure) ProtoMessage()    {}
func (*Azure) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{20}
}
func (m *Azure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Azure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Azure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Azure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Azure.Merge(m, src)
}
func (m *Azure) XXX_Size() int {
	return m.Size()
}
func (m *Azure) XXX_DiscardUnknown() {
	xxx_messageInfo_Azure.DiscardUnknown(m)
}

var xxx_messageInfo_Azure proto.InternalMessageInfo

// DatabaseTLS contains TLS configuration options.
type DatabaseTLS struct {
	// Mode is a TLS connection mode. See DatabaseTLSMode for details.
	Mode DatabaseTLSMode `protobuf:"varint,1,opt,name=Mode,proto3,enum=typestest.DatabaseTLSMode" json:"mode"`
	// CACert is an optional user provided CA certificate used for verifying
	// database TLS connection.
	CACert string `protobuf:"bytes,2,opt,name=CACert,proto3" json:"ca_cert,omitempty"`
	// ServerName allows to provide custom hostname. This value will override the
	// servername/hostname on a certificate during validation.
	ServerName           string   `protobuf:"bytes,3,opt,name=ServerName,proto3" json:"server_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseTLS) Reset()         { *m = DatabaseTLS{} }
func (m *DatabaseTLS) String() string { return proto.CompactTextString(m) }
func (*DatabaseTLS) ProtoMessage()    {}
func (*DatabaseTLS) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{21}
}
func (m *DatabaseTLS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseTLS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseTLS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseTLS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseTLS.Merge(m, src)
}
func (m *DatabaseTLS) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseTLS) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseTLS.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseTLS proto.InternalMessageInfo

// AD contains Active Directory specific database configuration.
type AD struct {
	// KeytabFile is the path to the Kerberos keytab file.
	KeytabFile string `protobuf:"bytes,1,opt,name=KeytabFile,proto3" json:"keytab_file,omitempty"`
	// Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
	Krb5File string `protobuf:"bytes,2,opt,name=Krb5File,proto3" json:"krb5_file,omitempty"`
	// Domain is the Active Directory domain the database resides in.
	Domain string `protobuf:"bytes,3,opt,name=Domain,proto3" json:"domain"`
	// SPN is the service principal name for the database.
	SPN string `protobuf:"bytes,4,opt,name=SPN,proto3" json:"spn"`
	// LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
	LDAPCert string `protobuf:"bytes,5,opt,name=LDAPCert,proto3" json:"ldap_cert,omitempty"`
	// KDCHostName is the host name for a KDC for x509 Authentication.
	KDCHostName          string   `protobuf:"bytes,6,opt,name=KDCHostName,proto3" json:"kdc_host_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AD) Reset()         { *m = AD{} }
func (m *AD) String() string { return proto.CompactTextString(m) }
func (*AD) ProtoMessage()    {}
func (*AD) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{22}
}
func (m *AD) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AD) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AD.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AD) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AD.Merge(m, src)
}
func (m *AD) XXX_Size() int {
	return m.Size()
}
func (m *AD) XXX_DiscardUnknown() {
	xxx_messageInfo_AD.DiscardUnknown(m)
}

var xxx_messageInfo_AD proto.InternalMessageInfo

// MySQLOptions are additional MySQL database options.
type MySQLOptions struct {
	// ServerVersion is the server version reported by DB proxy if the runtime information is
	// not available.
	ServerVersion        string   `protobuf:"bytes,1,opt,name=ServerVersion,proto3" json:"server_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MySQLOptions) Reset()         { *m = MySQLOptions{} }
func (m *MySQLOptions) String() string { return proto.CompactTextString(m) }
func (*MySQLOptions) ProtoMessage()    {}
func (*MySQLOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{23}
}
func (m *MySQLOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MySQLOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MySQLOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MySQLOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MySQLOptions.Merge(m, src)
}
func (m *MySQLOptions) XXX_Size() int {
	return m.Size()
}
func (m *MySQLOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MySQLOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MySQLOptions proto.InternalMessageInfo

// DatabaseAdminUser contains information about privileged database user used
// for automatic user provisioning.
type DatabaseAdminUser struct {
	// Name is the username of the privileged database user.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatabaseAdminUser) Reset()         { *m = DatabaseAdminUser{} }
func (m *DatabaseAdminUser) String() string { return proto.CompactTextString(m) }
func (*DatabaseAdminUser) ProtoMessage()    {}
func (*DatabaseAdminUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{24}
}
func (m *DatabaseAdminUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatabaseAdminUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatabaseAdminUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatabaseAdminUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatabaseAdminUser.Merge(m, src)
}
func (m *DatabaseAdminUser) XXX_Size() int {
	return m.Size()
}
func (m *DatabaseAdminUser) XXX_DiscardUnknown() {
	xxx_messageInfo_DatabaseAdminUser.DiscardUnknown(m)
}

var xxx_messageInfo_DatabaseAdminUser proto.InternalMessageInfo

// MongoAtlas contains Atlas metadata about the database.
type MongoAtlas struct {
	// Name is the Atlas database instance name.
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MongoAtlas) Reset()         { *m = MongoAtlas{} }
func (m *MongoAtlas) String() string { return proto.CompactTextString(m) }
func (*MongoAtlas) ProtoMessage()    {}
func (*MongoAtlas) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{25}
}
func (m *MongoAtlas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MongoAtlas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MongoAtlas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MongoAtlas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MongoAtlas.Merge(m, src)
}
func (m *MongoAtlas) XXX_Size() int {
	return m.Size()
}
func (m *MongoAtlas) XXX_DiscardUnknown() {
	xxx_messageInfo_MongoAtlas.DiscardUnknown(m)
}

var xxx_messageInfo_MongoAtlas proto.InternalMessageInfo

// OracleOptions contains information about privileged database user used
// for database audit.
type OracleOptions struct {
	// AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
	AuditUser            string   `protobuf:"bytes,1,opt,name=AuditUser,proto3" json:"audit_user"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleOptions) Reset()         { *m = OracleOptions{} }
func (m *OracleOptions) String() string { return proto.CompactTextString(m) }
func (*OracleOptions) ProtoMessage()    {}
func (*OracleOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{26}
}
func (m *OracleOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleOptions.Merge(m, src)
}
func (m *OracleOptions) XXX_Size() int {
	return m.Size()
}
func (m *OracleOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleOptions.DiscardUnknown(m)
}

var xxx_messageInfo_OracleOptions proto.InternalMessageInfo

// AppServerV3 represents a single proxied web app.
type AppServerV3 struct {
	// Kind is the app server resource kind. Always "app_server".
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the app server metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the app server spec.
	Spec                 AppServerSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *AppServerV3) Reset()      { *m = AppServerV3{} }
func (*AppServerV3) ProtoMessage() {}
func (*AppServerV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{27}
}
func (m *AppServerV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppServerV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppServerV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppServerV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppServerV3.Merge(m, src)
}
func (m *AppServerV3) XXX_Size() int {
	return m.Size()
}
func (m *AppServerV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppServerV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppServerV3 proto.InternalMessageInfo

// AppServerSpecV3 is the app access server spec.
type AppServerSpecV3 struct {
	// Version is the Teleport version that the server is running.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"version"`
	// Hostname is the app server hostname.
	Hostname string `protobuf:"bytes,2,opt,name=Hostname,proto3" json:"hostname"`
	// HostID is the app server host uuid.
	HostID string `protobuf:"bytes,3,opt,name=HostID,proto3" json:"host_id"`
	// Rotation contains the app server CA rotation information.
	Rotation Rotation `protobuf:"bytes,4,opt,name=Rotation,proto3" json:"rotation,omitempty"`
	// App is the app proxied by this app server.
	App *AppV3 `protobuf:"bytes,5,opt,name=App,proto3" json:"app"`
	// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
	ProxyIDs             []string `protobuf:"bytes,6,rep,name=ProxyIDs,proto3" json:"proxy_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppServerSpecV3) Reset()         { *m = AppServerSpecV3{} }
func (m *AppServerSpecV3) String() string { return proto.CompactTextString(m) }
func (*AppServerSpecV3) ProtoMessage()    {}
func (*AppServerSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{28}
}
func (m *AppServerSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppServerSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppServerSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppServerSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppServerSpecV3.Merge(m, src)
}
func (m *AppServerSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *AppServerSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppServerSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppServerSpecV3 proto.InternalMessageInfo

// AppV3 represents an app resource.
type AppV3 struct {
	// Kind is the app resource kind. Always "app".
	Kind string `protobuf:"bytes,1,opt,name=Kind,proto3" json:"kind"`
	// SubKind is an optional resource subkind.
	SubKind string `protobuf:"bytes,2,opt,name=SubKind,proto3" json:"sub_kind,omitempty"`
	// Version is the resource version.
	Version string `protobuf:"bytes,3,opt,name=Version,proto3" json:"version"`
	// Metadata is the app resource metadata.
	Metadata Metadata `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"metadata"`
	// Spec is the app resource spec.
	Spec                 AppSpecV3 `protobuf:"bytes,5,opt,name=Spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AppV3) Reset()      { *m = AppV3{} }
func (*AppV3) ProtoMessage() {}
func (*AppV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{29}
}
func (m *AppV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppV3.Merge(m, src)
}
func (m *AppV3) XXX_Size() int {
	return m.Size()
}
func (m *AppV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppV3 proto.InternalMessageInfo

// AppSpecV3 is the AppV3 resource spec.
type AppSpecV3 struct {
	// URI is the web app endpoint.
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"uri"`
	// PublicAddr is the public address the application is accessible at.
	PublicAddr string `protobuf:"bytes,2,opt,name=PublicAddr,proto3" json:"public_addr,omitempty"`
	// DynamicLabels are the app's command labels.
	DynamicLabels map[string]CommandLabelV2 `protobuf:"bytes,3,rep,name=DynamicLabels,proto3" json:"dynamic_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// InsecureSkipVerify disables app's TLS certificate verification.
	InsecureSkipVerify bool `protobuf:"varint,4,opt,name=InsecureSkipVerify,proto3" json:"insecure_skip_verify"`
	// Rewrite is a list of rewriting rules to apply to requests and responses.
	Rewrite *Rewrite `protobuf:"bytes,5,opt,name=Rewrite,proto3" json:"rewrite,omitempty"`
	// AWS contains additional options for AWS applications.
	AWS *AppAWS `protobuf:"bytes,6,opt,name=AWS,proto3" json:"aws,omitempty"`
	// Cloud identifies the cloud instance the app represents.
	Cloud string `protobuf:"bytes,7,opt,name=Cloud,proto3" json:"cloud,omitempty"`
	// UserGroups are a list of user group IDs that this app is associated with.
	UserGroups           []string `protobuf:"bytes,8,rep,name=UserGroups,proto3" json:"UserGroups,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppSpecV3) Reset()         { *m = AppSpecV3{} }
func (m *AppSpecV3) String() string { return proto.CompactTextString(m) }
func (*AppSpecV3) ProtoMessage()    {}
func (*AppSpecV3) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{30}
}
func (m *AppSpecV3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppSpecV3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppSpecV3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppSpecV3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppSpecV3.Merge(m, src)
}
func (m *AppSpecV3) XXX_Size() int {
	return m.Size()
}
func (m *AppSpecV3) XXX_DiscardUnknown() {
	xxx_messageInfo_AppSpecV3.DiscardUnknown(m)
}

var xxx_messageInfo_AppSpecV3 proto.InternalMessageInfo

// Rewrite is a list of rewriting rules to apply to requests and responses.
type Rewrite struct {
	// Redirect defines a list of hosts which will be rewritten to the public
	// address of the application if they occur in the "Location" header.
	Redirect []string `protobuf:"bytes,1,rep,name=Redirect,proto3" json:"redirect,omitempty"`
	// Headers is a list of headers to inject when passing the request over
	// to the application.
	Headers []*Header `protobuf:"bytes,2,rep,name=Headers,proto3" json:"headers,omitempty"`
	// JWTClaims configures whether roles/traits are included in the JWT token.
	JWTClaims            string   `protobuf:"bytes,3,opt,name=JWTClaims,proto3" json:"jwt_claims,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rewrite) Reset()         { *m = Rewrite{} }
func (m *Rewrite) String() string { return proto.CompactTextString(m) }
func (*Rewrite) ProtoMessage()    {}
func (*Rewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{31}
}
func (m *Rewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rewrite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rewrite.Merge(m, src)
}
func (m *Rewrite) XXX_Size() int {
	return m.Size()
}
func (m *Rewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_Rewrite.DiscardUnknown(m)
}

var xxx_messageInfo_Rewrite proto.InternalMessageInfo

// AppAWS contains additional options for AWS applications.
type AppAWS struct {
	// ExternalID is the AWS External ID used when assuming roles in this app.
	ExternalID           string   `protobuf:"bytes,1,opt,name=ExternalID,proto3" json:"external_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppAWS) Reset()         { *m = AppAWS{} }
func (m *AppAWS) String() string { return proto.CompactTextString(m) }
func (*AppAWS) ProtoMessage()    {}
func (*AppAWS) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{32}
}
func (m *AppAWS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppAWS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppAWS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppAWS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppAWS.Merge(m, src)
}
func (m *AppAWS) XXX_Size() int {
	return m.Size()
}
func (m *AppAWS) XXX_DiscardUnknown() {
	xxx_messageInfo_AppAWS.DiscardUnknown(m)
}

var xxx_messageInfo_AppAWS proto.InternalMessageInfo

// Rotation is a status of the rotation of the certificate authority
type Rotation struct {
	// State could be one of "init" or "in_progress".
	State string `protobuf:"bytes,1,opt,name=State,proto3" json:"state,omitempty"`
	// Phase is the current rotation phase.
	Phase string `protobuf:"bytes,2,opt,name=Phase,proto3" json:"phase,omitempty"`
	// Mode sets manual or automatic rotation mode.
	Mode string `protobuf:"bytes,3,opt,name=Mode,proto3" json:"mode,omitempty"`
	// CurrentID is the ID of the rotation operation
	// to differentiate between rotation attempts.
	CurrentID string `protobuf:"bytes,4,opt,name=CurrentID,proto3" json:"current_id"`
	// Started is set to the time when rotation has been started
	// in case if the state of the rotation is "in_progress".
	Started time.Time `protobuf:"bytes,5,opt,name=Started,proto3,stdtime" json:"started,omitempty"`
	// GracePeriod is a period during which old and new CA
	// are valid for checking purposes, but only new CA is issuing certificates.
	GracePeriod Duration `protobuf:"varint,6,opt,name=GracePeriod,proto3,casttype=Duration" json:"grace_period,omitempty"`
	// LastRotated specifies the last time of the completed rotation.
	LastRotated time.Time `protobuf:"bytes,7,opt,name=LastRotated,proto3,stdtime" json:"last_rotated,omitempty"`
	// Schedule is a rotation schedule - used in
	// automatic mode to switch between phases.
	Schedule             RotationSchedule `protobuf:"bytes,8,opt,name=Schedule,proto3" json:"schedule,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Rotation) Reset()      { *m = Rotation{} }
func (*Rotation) ProtoMessage() {}
func (*Rotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{33}
}
func (m *Rotation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rotation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rotation.Merge(m, src)
}
func (m *Rotation) XXX_Size() int {
	return m.Size()
}
func (m *Rotation) XXX_DiscardUnknown() {
	xxx_messageInfo_Rotation.DiscardUnknown(m)
}

var xxx_messageInfo_Rotation proto.InternalMessageInfo

// RotationSchedule is a rotation schedule setting time switches
// for different phases.
type RotationSchedule struct {
	// UpdateClients specifies time to switch to the "Update clients" phase
	UpdateClients time.Time `protobuf:"bytes,1,opt,name=UpdateClients,proto3,stdtime" json:"update_clients,omitempty"`
	// UpdateServers specifies time to switch to the "Update servers" phase.
	UpdateServers time.Time `protobuf:"bytes,2,opt,name=UpdateServers,proto3,stdtime" json:"update_servers,omitempty"`
	// Standby specifies time to switch to the "Standby" phase.
	Standby              time.Time `protobuf:"bytes,3,opt,name=Standby,proto3,stdtime" json:"standby,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RotationSchedule) Reset()         { *m = RotationSchedule{} }
func (m *RotationSchedule) String() string { return proto.CompactTextString(m) }
func (*RotationSchedule) ProtoMessage()    {}
func (*RotationSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_bc34f0fadc11836f, []int{34}
}
func (m *RotationSchedule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RotationSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RotationSchedule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RotationSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotationSchedule.Merge(m, src)
}
func (m *RotationSchedule) XXX_Size() int {
	return m.Size()
}
func (m *RotationSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_RotationSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_RotationSchedule proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("typestest.DatabaseTLSMode", DatabaseTLSMode_name, DatabaseTLSMode_value)
	proto.RegisterEnum("typestest.IAMPolicyStatus", IAMPolicyStatus_name, IAMPolicyStatus_value)
	proto.RegisterType((*ResourceHeader)(nil), "typestest.ResourceHeader")
	proto.RegisterType((*Metadata)(nil), "typestest.Metadata")
	proto.RegisterMapType((map[string]string)(nil), "typestest.Metadata.LabelsEntry")
	proto.RegisterType((*CommandLabelV2)(nil), "typestest.CommandLabelV2")
	proto.RegisterType((*DatabaseSpecV3)(nil), "typestest.DatabaseSpecV3")
	proto.RegisterMapType((map[string]CommandLabelV2)(nil), "typestest.DatabaseSpecV3.DynamicLabelsEntry")
	proto.RegisterType((*DatabaseV3)(nil), "typestest.DatabaseV3")
	proto.RegisterType((*DatabaseServerV3)(nil), "typestest.DatabaseServerV3")
	proto.RegisterType((*DatabaseServerSpecV3)(nil), "typestest.DatabaseServerSpecV3")
	proto.RegisterType((*DatabaseStatusV3)(nil), "typestest.DatabaseStatusV3")
	proto.RegisterType((*AWS)(nil), "typestest.AWS")
	proto.RegisterType((*Header)(nil), "typestest.Header")
	proto.RegisterType((*AzureRedis)(nil), "typestest.AzureRedis")
	proto.RegisterType((*Redshift)(nil), "typestest.Redshift")
	proto.RegisterType((*RDS)(nil), "typestest.RDS")
	proto.RegisterType((*ElastiCache)(nil), "typestest.ElastiCache")
	proto.RegisterType((*SecretStore)(nil), "typestest.SecretStore")
	proto.RegisterType((*MemoryDB)(nil), "typestest.MemoryDB")
	proto.RegisterType((*RDSProxy)(nil), "typestest.RDSProxy")
	proto.RegisterType((*RedshiftServerless)(nil), "typestest.RedshiftServerless")
	proto.RegisterType((*OpenSearch)(nil), "typestest.OpenSearch")
	proto.RegisterType((*GCPCloudSQL)(nil), "typestest.GCPCloudSQL")
	proto.RegisterType((*Azure)(nil), "typestest.Azure")
	proto.RegisterType((*DatabaseTLS)(nil), "typestest.DatabaseTLS")
	proto.RegisterType((*AD)(nil), "typestest.AD")
	proto.RegisterType((*MySQLOptions)(nil), "typestest.MySQLOptions")
	proto.RegisterType((*DatabaseAdminUser)(nil), "typestest.DatabaseAdminUser")
	proto.RegisterType((*MongoAtlas)(nil), "typestest.MongoAtlas")
	proto.RegisterType((*OracleOptions)(nil), "typestest.OracleOptions")
	proto.RegisterType((*AppServerV3)(nil), "typestest.AppServerV3")
	proto.RegisterType((*AppServerSpecV3)(nil), "typestest.AppServerSpecV3")
	proto.RegisterType((*AppV3)(nil), "typestest.AppV3")
	proto.RegisterType((*AppSpecV3)(nil), "typestest.AppSpecV3")
	proto.RegisterMapType((map[string]CommandLabelV2)(nil), "typestest.AppSpecV3.DynamicLabelsEntry")
	proto.RegisterType((*Rewrite)(nil), "typestest.Rewrite")
	proto.RegisterType((*AppAWS)(nil), "typestest.AppAWS")
	proto.RegisterType((*Rotation)(nil), "typestest.Rotation")
	proto.RegisterType((*RotationSchedule)(nil), "typestest.RotationSchedule")
}

func init() {
	proto.RegisterFile("teleport/legacy/typestest/typestest.proto", fileDescriptor_bc34f0fadc11836f)
}

var fileDescriptor_bc34f0fadc11836f = []byte{
	// 3349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0x3d, 0x70, 0x1c, 0xc7,
	0xb1, 0xe6, 0xde, 0x1f, 0x0e, 0x73, 0x00, 0x78, 0x1c, 0x82, 0xe2, 0x11, 0xfc, 0x39, 0xbc, 0x95,
	0xc4, 0x07, 0xe9, 0x51, 0xc0, 0x7b, 0xa4, 0xa4, 0x27, 0xea, 0xa7, 0xf8, 0xee, 0x8f, 0xe4, 0xe1,
	0x87, 0x3c, 0xed, 0x02, 0xe0, 0x93, 0x15, 0xac, 0x17, 0xbb, 0x03, 0x60, 0x85, 0xbd, 0xdb, 0xf5,
	0xce, 0x1e, 0xc9, 0xb3, 0x13, 0x55, 0x39, 0x74, 0x60, 0x45, 0x2e, 0x3b, 0x73, 0xe6, 0xd4, 0x4e,
	0xfc, 0x13, 0xb8, 0xca, 0xca, 0x58, 0x8a, 0x5c, 0x4e, 0x9c, 0xb8, 0xce, 0xb6, 0x22, 0xd7, 0xe5,
	0x76, 0xe0, 0x2a, 0x57, 0xb9, 0xa6, 0x67, 0x76, 0x77, 0x76, 0x71, 0x64, 0x81, 0xa6, 0x1d, 0xc8,
	0x11, 0x70, 0x3d, 0x5f, 0xf7, 0xcc, 0xf4, 0xf4, 0xf4, 0xd7, 0xd3, 0x77, 0xe8, 0xb5, 0x90, 0xb8,
	0xc4, 0xf7, 0x82, 0x70, 0xcd, 0x25, 0x07, 0xa6, 0x35, 0x5a, 0x0b, 0x47, 0x3e, 0xa1, 0x21, 0xa1,
	0x61, 0xf2, 0xdf, 0xaa, 0x1f, 0x78, 0xa1, 0x87, 0x67, 0x63, 0xc1, 0xd2, 0xe2, 0x81, 0x77, 0xe0,
	0x81, 0x74, 0x8d, 0xfd, 0xc7, 0x01, 0x4b, 0xf5, 0x03, 0xcf, 0x3b, 0x70, 0xc9, 0x1a, 0x7c, 0xda,
	0x1b, 0xee, 0xaf, 0x85, 0x4e, 0x9f, 0xd0, 0xd0, 0xec, 0xfb, 0x1c, 0xa0, 0xfe, 0x49, 0x41, 0x0b,
	0x1a, 0xa1, 0xde, 0x30, 0xb0, 0xc8, 0x5d, 0x62, 0xda, 0x24, 0xc0, 0x57, 0x51, 0x61, 0xc3, 0x19,
	0xd8, 0x35, 0x65, 0x59, 0x59, 0x99, 0x6d, 0xe2, 0xc9, 0xb8, 0xbe, 0x70, 0xe4, 0x0c, 0xec, 0x6b,
	0x5e, 0xdf, 0x09, 0x49, 0xdf, 0x0f, 0x47, 0x1a, 0x8c, 0xe3, 0xff, 0x46, 0x33, 0xfa, 0x70, 0x0f,
	0xa0, 0x39, 0x80, 0xbe, 0x34, 0x19, 0xd7, 0x31, 0x1d, 0xee, 0x19, 0x19, 0x78, 0x04, 0xc3, 0x6b,
	0x68, 0x66, 0x97, 0x04, 0xd4, 0xf1, 0x06, 0xb5, 0x3c, 0x68, 0x9c, 0x9b, 0x8c, 0xeb, 0x67, 0x1e,
	0x72, 0x91, 0xac, 0x20, 0x50, 0x78, 0x03, 0x95, 0xb7, 0x48, 0x68, 0xda, 0x66, 0x68, 0xd6, 0x0a,
	0xcb, 0xca, 0x4a, 0xe5, 0xfa, 0xd9, 0xd5, 0xc4, 0x07, 0xd1, 0x50, 0x73, 0xe9, 0xc9, 0xb8, 0x7e,
	0x8a, 0x4d, 0xde, 0x17, 0x12, 0xc9, 0x56, 0x6c, 0x40, 0xfd, 0x3c, 0x9f, 0x58, 0xc3, 0x97, 0x50,
	0xe1, 0x9e, 0xd9, 0x27, 0x62, 0x93, 0xe5, 0xc9, 0xb8, 0x5e, 0x18, 0x98, 0x7d, 0xa2, 0x81, 0x14,
	0xbf, 0x8c, 0x66, 0xd9, 0x5f, 0xea, 0x9b, 0x16, 0x11, 0x9b, 0x2b, 0x4e, 0xc6, 0x75, 0xe5, 0x0d,
	0x2d, 0x91, 0xe3, 0xf7, 0x50, 0xa5, 0x4d, 0xa8, 0x15, 0x38, 0x7e, 0x98, 0xec, 0xe8, 0xc2, 0x64,
	0x5c, 0x3f, 0x67, 0x27, 0x62, 0x69, 0x25, 0x32, 0x1a, 0x6f, 0xa1, 0xd2, 0xa6, 0xb9, 0x47, 0x5c,
	0x5a, 0x2b, 0x2e, 0xe7, 0x57, 0x2a, 0xd7, 0xeb, 0x53, 0xf6, 0xb5, 0xca, 0x11, 0x9d, 0x41, 0x18,
	0x8c, 0x9a, 0x8b, 0x93, 0x71, 0xbd, 0xea, 0x82, 0x40, 0xb2, 0x29, 0x8c, 0x60, 0x1d, 0xcd, 0x74,
	0x1e, 0xfb, 0x4e, 0x40, 0x68, 0xad, 0x04, 0x7e, 0x5a, 0x5a, 0xe5, 0x27, 0xbf, 0x1a, 0x9d, 0xfc,
	0xea, 0x76, 0x74, 0xf2, 0xcd, 0xcb, 0x4f, 0xc6, 0x75, 0x85, 0x79, 0x9e, 0x70, 0x95, 0xc4, 0xde,
	0x67, 0xbf, 0xaf, 0x2b, 0x5a, 0x64, 0x09, 0xab, 0x28, 0xd7, 0x6d, 0xd7, 0x66, 0x96, 0x95, 0x95,
	0x3c, 0x84, 0xc1, 0x9c, 0x23, 0x9d, 0x6a, 0x4d, 0xd1, 0x72, 0xdd, 0x36, 0xbe, 0x8e, 0xca, 0x1a,
	0x79, 0xe8, 0xc0, 0x99, 0x96, 0x93, 0x28, 0x08, 0x84, 0x4c, 0x3e, 0x88, 0x08, 0xb7, 0x74, 0x13,
	0x55, 0xa4, 0x9d, 0xe1, 0x2a, 0xca, 0x1f, 0x91, 0x11, 0x3f, 0x09, 0x8d, 0xfd, 0x8b, 0x17, 0x51,
	0xf1, 0xa1, 0xe9, 0x0e, 0x85, 0xeb, 0x35, 0xfe, 0xe1, 0xdd, 0xdc, 0x3b, 0x8a, 0xfa, 0x1d, 0x05,
	0x2d, 0xb4, 0xbc, 0x7e, 0xdf, 0x1c, 0xd8, 0x60, 0x62, 0xf7, 0x3a, 0x5e, 0x45, 0xa5, 0x1e, 0x09,
	0x1c, 0x8f, 0x07, 0x6c, 0x1e, 0xe6, 0x2f, 0xf9, 0x20, 0xf9, 0xeb, 0xb8, 0x5e, 0x6e, 0x0f, 0x03,
	0x93, 0x79, 0x5c, 0x13, 0x28, 0xfc, 0x2a, 0x9a, 0x11, 0x16, 0x6a, 0xb9, 0xe5, 0xfc, 0xca, 0x6c,
	0xb3, 0x32, 0x19, 0xd7, 0x67, 0x2c, 0x2e, 0xd2, 0xa2, 0x31, 0xac, 0xa2, 0x92, 0x46, 0xe8, 0xd0,
	0x0d, 0xc5, 0xc1, 0x22, 0x66, 0x36, 0x00, 0x89, 0x26, 0x46, 0xd4, 0x2f, 0x66, 0xd0, 0x42, 0xdb,
	0x0c, 0xcd, 0x3d, 0x93, 0x12, 0xdd, 0x27, 0xd6, 0xee, 0x0d, 0xbc, 0x82, 0xca, 0x3d, 0xe6, 0x71,
	0xcb, 0x73, 0x45, 0x6c, 0xcd, 0x4d, 0xc6, 0xf5, 0xb2, 0x2f, 0x64, 0x5a, 0x3c, 0x8a, 0x2f, 0xa0,
	0xfc, 0x8e, 0xd6, 0x15, 0xd1, 0x35, 0x33, 0x19, 0xd7, 0xf3, 0xc3, 0xc0, 0xd1, 0x98, 0x0c, 0xaf,
	0xa1, 0x52, 0xab, 0xd1, 0x22, 0x41, 0x34, 0xf7, 0x79, 0x76, 0x58, 0x96, 0x69, 0x58, 0x24, 0x08,
	0x53, 0x27, 0x20, 0x60, 0x38, 0x44, 0xf3, 0xed, 0xd1, 0xc0, 0xec, 0x3b, 0x96, 0x08, 0xaa, 0x02,
	0x04, 0xd5, 0x35, 0x29, 0xa8, 0xd2, 0xeb, 0x5c, 0x4d, 0xc1, 0x79, 0x84, 0x2d, 0x8b, 0x5b, 0x54,
	0xb3, 0xf9, 0x98, 0x71, 0x2c, 0xda, 0xd2, 0x93, 0xe0, 0xff, 0x45, 0xf9, 0xc6, 0x03, 0xbd, 0x56,
	0x84, 0x80, 0x5b, 0x90, 0xe6, 0x6a, 0x3c, 0xd0, 0x9b, 0xe7, 0x84, 0xb5, 0x79, 0xf3, 0x91, 0x6c,
	0x82, 0x69, 0xe0, 0x5b, 0x28, 0x7f, 0xa7, 0xd5, 0x13, 0x91, 0xfa, 0x92, 0xa4, 0x78, 0xa7, 0xd5,
	0x6b, 0xb9, 0xde, 0xd0, 0xd6, 0x3f, 0xdc, 0x4c, 0x0c, 0x1c, 0x58, 0xbe, 0x6c, 0xe0, 0x4e, 0xab,
	0x87, 0x6f, 0xa1, 0x62, 0xe3, 0x9b, 0xc3, 0x80, 0x40, 0x70, 0x56, 0xae, 0x57, 0xe5, 0xb9, 0x99,
	0xbc, 0x79, 0x5e, 0x28, 0x9f, 0x36, 0xd9, 0x47, 0x49, 0x9d, 0xeb, 0xb1, 0x15, 0x6c, 0x6f, 0xea,
	0x10, 0xb1, 0xe9, 0x15, 0x44, 0x6e, 0xda, 0xde, 0x94, 0xb6, 0x10, 0xa6, 0xbc, 0xc0, 0x34, 0xf1,
	0x0d, 0x94, 0x6b, 0xb4, 0x6b, 0xb3, 0xa0, 0x3f, 0x2f, 0x4f, 0xdf, 0x6e, 0x2e, 0x0a, 0xb5, 0x39,
	0x53, 0x4e, 0x82, 0xb9, 0x46, 0x1b, 0xdf, 0x46, 0xc5, 0xad, 0x91, 0xfe, 0xe1, 0x66, 0x0d, 0x81,
	0xde, 0x79, 0xf9, 0xce, 0x33, 0xf9, 0x7d, 0xc8, 0x0d, 0x34, 0x59, 0x7d, 0x7f, 0x44, 0xbf, 0xe1,
	0xca, 0xab, 0x07, 0x18, 0xde, 0x46, 0xb3, 0x0d, 0xbb, 0xef, 0x0c, 0x76, 0x28, 0x09, 0x6a, 0x15,
	0xb0, 0x75, 0x69, 0xca, 0x1e, 0x62, 0x4c, 0xb3, 0x36, 0x19, 0xd7, 0x17, 0x4d, 0xf6, 0xd1, 0x18,
	0x52, 0x12, 0x48, 0x16, 0x13, 0x43, 0x78, 0x1b, 0xa1, 0x2d, 0x6f, 0x70, 0xe0, 0x35, 0x42, 0xd7,
	0xa4, 0xb5, 0x39, 0x30, 0x7b, 0x4e, 0x5e, 0x62, 0x3c, 0x08, 0x19, 0x84, 0x2d, 0xf0, 0x5c, 0x9f,
	0xc9, 0x0c, 0x93, 0x09, 0x25, 0xa3, 0x92, 0x1d, 0xbc, 0x8e, 0x4a, 0xf7, 0x03, 0xd3, 0x72, 0x49,
	0x6d, 0x1e, 0x2c, 0xd6, 0x24, 0x8b, 0x7c, 0x20, 0xda, 0x75, 0x4d, 0x18, 0xad, 0x7a, 0x20, 0x96,
	0xb3, 0x1c, 0x07, 0x2e, 0x7d, 0x8c, 0xf0, 0xf1, 0xb8, 0x9d, 0x92, 0x3f, 0xd6, 0xe4, 0xfc, 0x51,
	0xb9, 0x7e, 0x41, 0x9a, 0x32, 0x9d, 0x3c, 0xe4, 0xd4, 0xf2, 0x9b, 0x1c, 0x42, 0x91, 0xe7, 0x76,
	0x6f, 0x30, 0x82, 0x90, 0x58, 0x10, 0x08, 0x82, 0xd1, 0xda, 0x3f, 0xcc, 0x7d, 0xaf, 0x66, 0xb9,
	0x0f, 0xd2, 0x8e, 0xe0, 0xbe, 0x84, 0xf1, 0x1a, 0x27, 0x63, 0xbc, 0xaa, 0xf0, 0x55, 0x39, 0x62,
	0xbc, 0x84, 0xe7, 0xf0, 0x7b, 0xa8, 0xc0, 0x2e, 0xb9, 0xb8, 0x97, 0x17, 0x9e, 0x9a, 0x03, 0x9a,
	0x73, 0xc2, 0x48, 0x81, 0xfa, 0xc4, 0xd2, 0x40, 0x09, 0xb7, 0x50, 0x49, 0x0f, 0xcd, 0x70, 0x18,
	0xf1, 0xc8, 0xc5, 0x69, 0xea, 0x00, 0xd8, 0xbd, 0xd1, 0x5c, 0x10, 0x06, 0x4a, 0x14, 0x24, 0x9a,
	0x50, 0x7d, 0xb7, 0xfc, 0xfd, 0x1f, 0xd6, 0x4f, 0x7d, 0xfa, 0xbb, 0xe5, 0x53, 0xea, 0x0f, 0x72,
	0xa8, 0x1a, 0xab, 0x91, 0xe0, 0x21, 0x09, 0xbe, 0xd2, 0xae, 0x6d, 0xa4, 0x5c, 0x5b, 0x9f, 0xe6,
	0x1b, 0xd8, 0xe4, 0xd3, 0x1d, 0x2c, 0xf9, 0xe6, 0x57, 0x79, 0xb4, 0x38, 0x4d, 0x4d, 0xde, 0x4f,
	0xe9, 0x19, 0xfb, 0x59, 0x41, 0xe5, 0xbb, 0x1e, 0x0d, 0x59, 0xd9, 0x02, 0x79, 0x50, 0x50, 0xcd,
	0xa1, 0x90, 0x69, 0xf1, 0x28, 0x7e, 0x19, 0x95, 0xd8, 0xff, 0xdd, 0xb6, 0xa0, 0x68, 0xb0, 0xc7,
	0x70, 0x86, 0x63, 0x6b, 0x62, 0x88, 0xd5, 0x5a, 0x9a, 0x17, 0x02, 0x57, 0x8a, 0xfc, 0x24, 0xbb,
	0x27, 0x1a, 0x4a, 0x6a, 0xad, 0x40, 0x48, 0x52, 0x14, 0x2f, 0x64, 0xb8, 0x8b, 0xca, 0xd1, 0xd6,
	0xa6, 0x64, 0x92, 0xe4, 0x9a, 0xf1, 0xc3, 0xb5, 0xc5, 0x67, 0xd9, 0x54, 0x84, 0xc1, 0x37, 0x80,
	0x51, 0x1f, 0x8f, 0xba, 0x6d, 0x5a, 0x9b, 0x07, 0xc2, 0x66, 0x74, 0x78, 0xd6, 0x67, 0x32, 0xc3,
	0xb1, 0xe5, 0xbc, 0x13, 0x03, 0xd7, 0x0b, 0x65, 0xa5, 0x9a, 0x5b, 0x2f, 0x94, 0x73, 0xd5, 0xfc,
	0x7a, 0xa1, 0x9c, 0xaf, 0x16, 0xd6, 0x0b, 0xe5, 0x42, 0xb5, 0xb8, 0x5e, 0x28, 0x17, 0xab, 0xa5,
	0xf5, 0x42, 0x79, 0xb6, 0x8a, 0xd6, 0x0b, 0xe5, 0x4a, 0x75, 0x2e, 0x55, 0x95, 0x25, 0xec, 0x0c,
	0x3c, 0x1c, 0xd1, 0x2b, 0x90, 0x56, 0x86, 0xfc, 0x80, 0x87, 0xd4, 0x1f, 0xcb, 0xe1, 0x2d, 0x6e,
	0x05, 0x7e, 0x23, 0x66, 0x6f, 0x25, 0x29, 0x72, 0x8f, 0xb1, 0x77, 0xcc, 0xdd, 0x6f, 0x70, 0x16,
	0xcd, 0x4d, 0x65, 0xd1, 0x8a, 0xf0, 0x76, 0xde, 0x7c, 0x44, 0x39, 0x77, 0xc6, 0x1c, 0x92, 0x7f,
	0x31, 0x0e, 0xb9, 0x85, 0xe6, 0xb6, 0xcc, 0x81, 0x79, 0x40, 0x6c, 0x96, 0xfc, 0x79, 0xc5, 0x30,
	0xdb, 0xbc, 0x38, 0x19, 0xd7, 0xcf, 0xf7, 0xb9, 0x1c, 0xa8, 0x42, 0x76, 0x6f, 0x4a, 0x01, 0xbf,
	0x15, 0x71, 0x70, 0xf1, 0x29, 0x1c, 0x3c, 0x2f, 0x56, 0x50, 0x04, 0x0e, 0x16, 0xcc, 0xab, 0xfe,
	0x6d, 0x06, 0xf6, 0x8b, 0xaf, 0xb1, 0xfa, 0xea, 0x80, 0x05, 0x1b, 0xf7, 0x12, 0xd4, 0xb7, 0x01,
	0x48, 0x64, 0x27, 0x71, 0x0c, 0x04, 0x27, 0xb1, 0xe9, 0xa1, 0xb3, 0x1f, 0x0a, 0x4f, 0xa5, 0x82,
	0x53, 0x0c, 0x49, 0xc1, 0x29, 0x24, 0xe9, 0xfa, 0x93, 0xcb, 0x58, 0xdd, 0xa2, 0xb5, 0x75, 0xe1,
	0x40, 0xd9, 0xe3, 0x5a, 0x5b, 0x22, 0xfd, 0x20, 0x15, 0x5a, 0x4c, 0x03, 0xbf, 0x8d, 0x66, 0x1b,
	0x96, 0xe5, 0x0d, 0x07, 0xec, 0x2a, 0x15, 0x60, 0xd9, 0x9c, 0x59, 0xb9, 0xd0, 0x90, 0xeb, 0x63,
	0x2d, 0x81, 0xe2, 0x07, 0xa8, 0xd2, 0x71, 0x4d, 0x1a, 0x3a, 0x2d, 0xd3, 0x3a, 0x8c, 0x1c, 0x26,
	0x57, 0x1d, 0xd2, 0x68, 0xc2, 0xad, 0x04, 0x84, 0x16, 0x13, 0xca, 0xaf, 0x08, 0x09, 0x8b, 0xff,
	0x1f, 0x55, 0x74, 0x62, 0x05, 0x24, 0xd4, 0x43, 0x2f, 0x20, 0x53, 0x0a, 0x2a, 0x69, 0xb4, 0x79,
	0x45, 0x18, 0x7e, 0x89, 0x82, 0xd0, 0xa0, 0x4c, 0x2a, 0x5b, 0x96, 0xc0, 0xfc, 0xe5, 0xd5, 0xf7,
	0x82, 0x51, 0xbb, 0x29, 0x8a, 0xac, 0x74, 0xb2, 0xe4, 0x43, 0xf2, 0xcb, 0x8b, 0x49, 0xec, 0xbd,
	0xf4, 0xcb, 0x8b, 0xa3, 0xe0, 0xf4, 0xda, 0x3a, 0x5c, 0x4e, 0x51, 0x72, 0x9d, 0x4d, 0x7b, 0x1d,
	0x86, 0xa4, 0xd3, 0xb3, 0x29, 0x5c, 0xef, 0xd4, 0xe9, 0x09, 0x14, 0x0e, 0x11, 0x8e, 0x4e, 0x92,
	0x67, 0x4d, 0x97, 0x50, 0x2a, 0x2a, 0xb1, 0xcb, 0x53, 0x82, 0x22, 0x01, 0x35, 0x5f, 0x15, 0x13,
	0x5c, 0x8e, 0xc2, 0xc3, 0xa0, 0xf1, 0xa0, 0x34, 0xd7, 0x14, 0xfb, 0xf8, 0x26, 0x42, 0x9d, 0xc7,
	0x21, 0x09, 0x06, 0xa6, 0xdb, 0x6d, 0x43, 0x7e, 0x14, 0x6f, 0x3d, 0x22, 0xa4, 0xe9, 0xc3, 0x97,
	0xc0, 0xb8, 0x85, 0xe6, 0x1b, 0x94, 0x0e, 0xfb, 0x44, 0xf3, 0x5c, 0xd2, 0xd0, 0xee, 0x41, 0xc5,
	0x36, 0xdb, 0xbc, 0x3c, 0x19, 0xd7, 0x2f, 0x98, 0x30, 0x60, 0x04, 0x9e, 0x4b, 0x0c, 0x33, 0x90,
	0x23, 0x3f, 0xad, 0x83, 0x75, 0x84, 0xee, 0xfb, 0x64, 0xa0, 0x13, 0x33, 0xb0, 0x0e, 0xa7, 0xa4,
	0xd4, 0x64, 0xb0, 0x79, 0x49, 0xec, 0x72, 0xd1, 0xf3, 0xc9, 0x80, 0x82, 0x4c, 0x5e, 0x59, 0x82,
	0xc4, 0x1f, 0xa3, 0xd3, 0xdd, 0xc6, 0x56, 0xcf, 0x73, 0x1d, 0x6b, 0x24, 0x58, 0x7f, 0x61, 0x59,
	0x59, 0x59, 0xb8, 0xbe, 0x24, 0x59, 0xce, 0x20, 0x78, 0x3a, 0x73, 0xcc, 0xbe, 0xe1, 0x83, 0xd4,
	0x10, 0xdc, 0x9f, 0xb5, 0xb4, 0x5e, 0x28, 0xcf, 0x57, 0x17, 0x24, 0x71, 0xe7, 0xb1, 0x43, 0x43,
	0xaa, 0xde, 0x41, 0x25, 0xd1, 0x67, 0x78, 0xf6, 0x13, 0xbc, 0x8e, 0x8a, 0xbb, 0xc9, 0x1b, 0xb0,
	0x39, 0xcb, 0x12, 0x09, 0x14, 0x6b, 0x1a, 0x97, 0xab, 0x1f, 0x21, 0x04, 0x19, 0x45, 0x23, 0xb6,
	0x43, 0xf1, 0x06, 0xaa, 0xb6, 0xdc, 0x21, 0x0d, 0x49, 0xe0, 0x0c, 0x0e, 0xf8, 0x84, 0xc2, 0x70,
	0x7d, 0x32, 0xae, 0x5f, 0xb4, 0xe2, 0x31, 0xb1, 0x6c, 0xc9, 0x23, 0xc7, 0x14, 0xd5, 0x66, 0x92,
	0x6d, 0xd8, 0x9d, 0x17, 0xe3, 0xdd, 0xb6, 0xb0, 0x08, 0x77, 0x5e, 0x58, 0xcc, 0xdc, 0xf9, 0x18,
	0xaa, 0xfe, 0x3c, 0x07, 0x59, 0x86, 0x05, 0x4e, 0x77, 0x40, 0x43, 0x73, 0x60, 0x91, 0xd8, 0x00,
	0x04, 0x8e, 0x23, 0xa4, 0x99, 0xc0, 0x49, 0xc0, 0xe9, 0xa9, 0x73, 0x27, 0x9e, 0x9a, 0x4d, 0x19,
	0xb5, 0x74, 0xba, 0x6d, 0xb9, 0x2f, 0x11, 0x08, 0x69, 0x66, 0xca, 0x04, 0x8c, 0xaf, 0xa2, 0x99,
	0x6e, 0x63, 0xab, 0x31, 0x0c, 0x0f, 0x21, 0xbf, 0x95, 0x79, 0x49, 0xc1, 0x4e, 0xdb, 0x1c, 0x86,
	0x87, 0x5a, 0x34, 0x88, 0xd7, 0xa0, 0x48, 0x1b, 0x90, 0x90, 0xf7, 0x2f, 0x04, 0xc9, 0x51, 0x2e,
	0xca, 0xd4, 0x68, 0x4c, 0x84, 0x5f, 0x47, 0xc5, 0xdd, 0x5e, 0xab, 0xdb, 0x16, 0x15, 0x0d, 0x64,
	0xfb, 0x87, 0xbe, 0x95, 0x5e, 0x09, 0x87, 0xa8, 0x5f, 0xe4, 0x52, 0xf9, 0x12, 0x6b, 0xec, 0xc6,
	0xfb, 0xae, 0x63, 0x41, 0x6d, 0x71, 0x27, 0xf0, 0x86, 0x7e, 0xec, 0x4a, 0x75, 0x32, 0xae, 0x5f,
	0x09, 0x92, 0x51, 0xe3, 0x80, 0x0d, 0xa7, 0xcd, 0x4e, 0xd1, 0xc6, 0xff, 0x87, 0xe6, 0x18, 0x8d,
	0x89, 0x8f, 0x54, 0xb4, 0x02, 0x2e, 0xb1, 0xe7, 0x2f, 0xa3, 0xbd, 0xd8, 0x4c, 0x8a, 0xff, 0x64,
	0x0d, 0x6c, 0xa3, 0xda, 0x76, 0x60, 0x0e, 0xa8, 0x13, 0x76, 0x06, 0x56, 0x30, 0x02, 0xda, 0xed,
	0x0c, 0xcc, 0x3d, 0x97, 0xd8, 0xe0, 0xf3, 0x72, 0x73, 0x65, 0x32, 0xae, 0xbf, 0x12, 0x72, 0x8c,
	0x41, 0x62, 0x90, 0x41, 0x38, 0x4a, 0xb2, 0xfc, 0x54, 0x4b, 0x8c, 0xa6, 0x3b, 0x03, 0xdb, 0xf7,
	0x9c, 0x41, 0xb8, 0x3d, 0xf2, 0x89, 0x60, 0x1d, 0xa0, 0x69, 0x22, 0xe4, 0x06, 0xbb, 0xab, 0xf2,
	0x32, 0x65, 0x05, 0xf5, 0x5b, 0x29, 0x8a, 0x60, 0x31, 0xb5, 0x41, 0x46, 0xbd, 0x80, 0xec, 0x3b,
	0x8f, 0xe5, 0x70, 0x3e, 0x22, 0x23, 0xc3, 0x07, 0xa9, 0x1c, 0x53, 0x31, 0x14, 0xbf, 0x89, 0xca,
	0x1b, 0x5b, 0xfa, 0x06, 0x19, 0xa5, 0x43, 0xf1, 0xa8, 0x4f, 0x0d, 0xa6, 0x9a, 0xf2, 0x77, 0x8c,
	0x54, 0xff, 0xa2, 0x24, 0x34, 0x82, 0xdf, 0x47, 0x15, 0x11, 0xa3, 0xd2, 0xb5, 0x5f, 0x62, 0x84,
	0x14, 0x05, 0x34, 0xbb, 0xfe, 0x32, 0x21, 0x49, 0x70, 0xf6, 0x2c, 0x68, 0xb4, 0x36, 0x41, 0x53,
	0x7a, 0x16, 0x98, 0x96, 0x9b, 0xd5, 0x8a, 0x60, 0xec, 0x1a, 0x6c, 0x6f, 0xea, 0xe9, 0x23, 0x81,
	0x6b, 0x10, 0xba, 0x74, 0xca, 0x19, 0x48, 0xe0, 0x17, 0xf7, 0xfa, 0xe7, 0x4a, 0x42, 0x79, 0xf8,
	0x6a, 0x2a, 0xd1, 0x41, 0x43, 0x35, 0xb3, 0x66, 0x9e, 0xf2, 0x34, 0x84, 0x5b, 0x43, 0x1a, 0x7a,
	0xfd, 0xc8, 0x94, 0xb4, 0x5b, 0x88, 0x73, 0x0b, 0x46, 0x8d, 0x78, 0x09, 0x19, 0x2b, 0x53, 0xb4,
	0x5f, 0x20, 0x17, 0xa8, 0xbf, 0x55, 0xa6, 0x31, 0x2d, 0x6e, 0xa2, 0xf9, 0x07, 0x5e, 0x70, 0x04,
	0x17, 0x44, 0xda, 0x16, 0x5c, 0x9d, 0x47, 0xd1, 0x40, 0x76, 0x69, 0x69, 0x15, 0xd9, 0xbf, 0xd2,
	0x1e, 0xd3, 0xfe, 0xcd, 0x58, 0x48, 0x29, 0xb0, 0x58, 0x8a, 0x2d, 0xc6, 0xfb, 0x82, 0x58, 0x4a,
	0x96, 0x90, 0xda, 0x98, 0x0c, 0x57, 0x7f, 0xa9, 0xc8, 0x6c, 0xca, 0x7c, 0xd4, 0xf6, 0xfa, 0xa6,
	0x33, 0x90, 0xb6, 0xc3, 0xfb, 0xb8, 0x20, 0xcd, 0xae, 0x44, 0x02, 0xb3, 0xc7, 0x09, 0xff, 0x14,
	0x5f, 0x0b, 0x78, 0x9c, 0x08, 0xc5, 0xf4, 0xad, 0x88, 0x80, 0xc7, 0xa2, 0x2b, 0xff, 0xbc, 0xd1,
	0xf5, 0xa9, 0x82, 0x2a, 0x52, 0xab, 0x8c, 0x5d, 0xea, 0x5e, 0xe0, 0x7d, 0x42, 0xac, 0x30, 0xcd,
	0x51, 0x3e, 0x17, 0x66, 0x88, 0x22, 0x86, 0x66, 0xb8, 0x29, 0xf7, 0x1c, 0xdc, 0xa4, 0xfe, 0x59,
	0x11, 0xe5, 0xff, 0x89, 0xa3, 0x3b, 0x1d, 0x89, 0xb9, 0xe7, 0x61, 0xa5, 0x36, 0x2a, 0x02, 0xcb,
	0x8b, 0x92, 0xfd, 0x5c, 0xf6, 0xa9, 0x01, 0x83, 0xc9, 0x8b, 0x27, 0x60, 0x1f, 0x65, 0x5a, 0xe1,
	0x25, 0x42, 0x0b, 0xcd, 0x77, 0xe9, 0x6d, 0x97, 0x3c, 0x76, 0x78, 0x34, 0x0b, 0x86, 0x83, 0x3a,
	0xcc, 0xa1, 0xc6, 0x3e, 0x1b, 0x11, 0x05, 0xa1, 0x1c, 0xb9, 0x29, 0x1d, 0xf5, 0x27, 0x0a, 0xaa,
	0x48, 0x3d, 0x42, 0xfc, 0x0e, 0x2a, 0x6c, 0x79, 0x36, 0xdf, 0x7d, 0xba, 0x6e, 0x92, 0x50, 0x0c,
	0xc1, 0x0b, 0x9c, 0xbe, 0x67, 0x13, 0x0d, 0x34, 0xa4, 0x67, 0x62, 0xee, 0x24, 0xcf, 0xc4, 0x9b,
	0x08, 0xf1, 0x25, 0x80, 0xb3, 0xa5, 0x8b, 0xcc, 0x57, 0x7c, 0x2c, 0x48, 0x13, 0xb0, 0xfa, 0xa3,
	0x1c, 0xca, 0x35, 0xe0, 0xb4, 0x37, 0xc8, 0x28, 0x34, 0xf7, 0x6e, 0x3b, 0x6e, 0x2a, 0xcc, 0x8f,
	0x40, 0x6a, 0xec, 0x3b, 0xa9, 0xa6, 0x9b, 0x04, 0x66, 0x61, 0xbe, 0x11, 0xec, 0xbd, 0x05, 0x8a,
	0x52, 0x98, 0x1f, 0x05, 0x7b, 0x6f, 0x65, 0xd5, 0x62, 0x20, 0x56, 0x51, 0x89, 0x87, 0xbc, 0xdc,
	0x41, 0xe7, 0x37, 0x43, 0x13, 0x23, 0xf8, 0x02, 0xca, 0xeb, 0xbd, 0x7b, 0x22, 0xbf, 0x42, 0x13,
	0x9c, 0xfa, 0x03, 0x8d, 0xc9, 0xd8, 0x9c, 0x9b, 0xed, 0x46, 0x0f, 0x3c, 0x54, 0x4c, 0xe6, 0x74,
	0x6d, 0xd3, 0xcf, 0xfa, 0x28, 0x06, 0xe2, 0x0f, 0x50, 0x65, 0xa3, 0xdd, 0xba, 0xeb, 0x51, 0x9e,
	0x57, 0x4a, 0xc9, 0xcd, 0x3a, 0xb2, 0x2d, 0x03, 0x5a, 0x1e, 0x59, 0x92, 0x91, 0xf0, 0xaa, 0x86,
	0xe6, 0xe4, 0x47, 0x34, 0xcb, 0x75, 0xa2, 0x6b, 0x25, 0xfa, 0x31, 0x52, 0xae, 0x13, 0x7e, 0x3f,
	0xfe, 0xed, 0x55, 0x5a, 0x45, 0xfd, 0x1f, 0x74, 0xe6, 0x58, 0x43, 0xf6, 0xd9, 0xb5, 0xaf, 0xfa,
	0xa6, 0xdc, 0x89, 0x3d, 0xe9, 0x05, 0x53, 0x3f, 0x40, 0xf3, 0xa9, 0x86, 0x2a, 0xbe, 0x86, 0x66,
	0x1b, 0x43, 0xdb, 0x09, 0xa1, 0x4d, 0xcc, 0xb5, 0x17, 0x26, 0xe3, 0x3a, 0x32, 0x99, 0x10, 0x5e,
	0xf7, 0x5a, 0x02, 0x50, 0xbf, 0x9b, 0x43, 0x95, 0x86, 0xef, 0xff, 0x1b, 0x74, 0xe9, 0xde, 0x4f,
	0x75, 0xe9, 0xe4, 0x3b, 0x19, 0xef, 0xef, 0x44, 0x0d, 0xba, 0x9f, 0xe6, 0xd0, 0xe9, 0x8c, 0x86,
	0xbc, 0x0b, 0xe5, 0x84, 0xbd, 0xb9, 0xdc, 0x09, 0x7b, 0x73, 0xf9, 0x93, 0xf5, 0xe6, 0x0a, 0x2f,
	0xda, 0x9b, 0xfb, 0x2f, 0x94, 0x6f, 0xf8, 0xfe, 0xb4, 0xb6, 0x8d, 0xef, 0xef, 0xde, 0xe0, 0xb7,
	0xd0, 0xf4, 0x7d, 0x8d, 0xa1, 0x52, 0xdd, 0xb7, 0xd2, 0x09, 0xbb, 0x6f, 0xea, 0xb7, 0x73, 0xa8,
	0x08, 0xc6, 0xbe, 0xc2, 0x41, 0xf4, 0x76, 0x2a, 0x88, 0x16, 0x33, 0x41, 0x74, 0x92, 0xf0, 0xf9,
	0xbc, 0x80, 0x66, 0x63, 0x6c, 0xf4, 0x75, 0x9f, 0x32, 0xe5, 0xeb, 0xbe, 0x9b, 0x08, 0xf5, 0x86,
	0x7b, 0xae, 0x63, 0x35, 0x6c, 0x3b, 0x90, 0x99, 0xd1, 0x07, 0xa9, 0x61, 0xda, 0xb6, 0xcc, 0x48,
	0x12, 0x18, 0x7b, 0xd9, 0x2f, 0xfe, 0xf2, 0xf0, 0xc5, 0xdf, 0x7f, 0x4e, 0x5b, 0xee, 0x3f, 0xe5,
	0x3b, 0xbf, 0xbb, 0x08, 0x77, 0x07, 0x94, 0x58, 0xc3, 0x80, 0xe8, 0x47, 0x8e, 0xbf, 0x4b, 0x02,
	0x67, 0x7f, 0x24, 0x98, 0x14, 0x6a, 0x0e, 0x47, 0x8c, 0x1a, 0xf4, 0xc8, 0xf1, 0x59, 0x76, 0x74,
	0xf6, 0x47, 0xda, 0x14, 0x1d, 0xdc, 0x42, 0x33, 0x1a, 0x79, 0x14, 0x38, 0x61, 0xd4, 0x10, 0xc3,
	0xa9, 0xe6, 0x0d, 0x8c, 0x70, 0x52, 0x0c, 0xf8, 0x07, 0x39, 0x1e, 0xc4, 0x38, 0x7e, 0x9b, 0x37,
	0x4f, 0x79, 0xe3, 0xeb, 0x4c, 0x7a, 0xd7, 0x8d, 0x07, 0x7a, 0xf3, 0xcc, 0x53, 0xbe, 0x81, 0x7c,
	0x0d, 0x15, 0xa1, 0x7a, 0x12, 0x8d, 0xf3, 0xb3, 0xac, 0x6c, 0xb0, 0x98, 0x40, 0x2e, 0x1b, 0x00,
	0x81, 0xaf, 0x20, 0x14, 0xbf, 0xfb, 0x68, 0xad, 0xcc, 0xee, 0x80, 0x26, 0x49, 0xfe, 0xb5, 0x5f,
	0x4a, 0xfd, 0x42, 0x89, 0xbd, 0xc4, 0xbf, 0x6a, 0xb7, 0x9d, 0x80, 0x58, 0x61, 0x4d, 0x81, 0xab,
	0x28, 0xbe, 0x6a, 0xe7, 0xb2, 0x4c, 0xab, 0x13, 0x64, 0xb8, 0x89, 0x66, 0x78, 0xb7, 0x85, 0xbf,
	0x70, 0xd3, 0x3e, 0xe2, 0x23, 0xdc, 0xc7, 0x87, 0x1c, 0x25, 0xfb, 0x58, 0x28, 0xb2, 0xea, 0x72,
	0xfd, 0xc1, 0x76, 0xcb, 0x35, 0x9d, 0x3e, 0x15, 0xb7, 0x0e, 0x4e, 0xfa, 0x93, 0x47, 0xa1, 0x61,
	0x81, 0x54, 0xae, 0x2e, 0x63, 0xa8, 0xda, 0x42, 0x25, 0x7e, 0x0a, 0x99, 0xe6, 0x99, 0xf2, 0x1c,
	0xcd, 0x33, 0xf5, 0x7b, 0x85, 0x24, 0xf5, 0xb1, 0x53, 0xd3, 0x43, 0x33, 0x8c, 0xa8, 0x10, 0x4e,
	0x8d, 0x32, 0x81, 0x7c, 0x6a, 0x80, 0x60, 0xd0, 0xde, 0xa1, 0x49, 0xa3, 0xec, 0x0b, 0x50, 0xff,
	0x30, 0xfd, 0x1d, 0x03, 0x47, 0x30, 0x7e, 0x85, 0x12, 0x2e, 0x9f, 0xf0, 0x2b, 0x2b, 0xd3, 0x64,
	0x7e, 0x85, 0x82, 0xed, 0x1a, 0x9a, 0x6d, 0x0d, 0x83, 0x80, 0x48, 0xdd, 0x5f, 0xa0, 0x53, 0x8b,
	0x0b, 0x59, 0xbe, 0x4e, 0x00, 0x58, 0x47, 0x33, 0x7a, 0x68, 0x06, 0x21, 0xb1, 0x63, 0x1e, 0x7a,
	0xf6, 0x2f, 0x32, 0x4e, 0x41, 0x07, 0x85, 0xab, 0x64, 0x7f, 0x91, 0x21, 0x2c, 0xe1, 0xbb, 0xa8,
	0x72, 0x27, 0x30, 0x2d, 0x22, 0x7e, 0xf0, 0x50, 0x82, 0x1f, 0x3c, 0x5c, 0x65, 0xcf, 0x9e, 0x03,
	0x26, 0x36, 0xf8, 0xcf, 0x1e, 0x12, 0xed, 0xd4, 0x0f, 0x20, 0x64, 0x55, 0xfc, 0x75, 0x54, 0xd9,
	0x34, 0x69, 0x08, 0xae, 0x25, 0xb6, 0x68, 0xf1, 0x3e, 0x6b, 0x89, 0x6a, 0xd4, 0x3d, 0x76, 0x4d,
	0x1a, 0x1a, 0x01, 0xd7, 0xcb, 0xac, 0x53, 0x36, 0x89, 0x75, 0x54, 0xd6, 0xad, 0x43, 0x62, 0x0f,
	0x5d, 0x22, 0x9a, 0xbe, 0x17, 0xa7, 0x70, 0x56, 0x04, 0x49, 0xb8, 0x8b, 0x0a, 0x89, 0x1c, 0xcf,
	0x11, 0x4a, 0xca, 0xae, 0x3f, 0xcb, 0xa1, 0x6a, 0xd6, 0x08, 0xde, 0x47, 0xf3, 0x3b, 0xbe, 0x6d,
	0x86, 0xa4, 0xe5, 0x3a, 0x64, 0x10, 0x52, 0x08, 0x94, 0x67, 0xef, 0xeb, 0x95, 0x28, 0x03, 0x0e,
	0x41, 0xd1, 0xb0, 0xb8, 0x66, 0x66, 0x67, 0x69, 0xb3, 0xc9, 0x3c, 0xbc, 0x36, 0xa0, 0xe2, 0x4e,
	0x3f, 0xcf, 0x3c, 0xbc, 0x7c, 0x7c, 0xca, 0x3c, 0xc2, 0xac, 0x08, 0xa2, 0x81, 0xbd, 0x37, 0x12,
	0x4f, 0x9f, 0x93, 0x06, 0x11, 0x53, 0x99, 0x12, 0x44, 0x4c, 0xfc, 0xfa, 0x2d, 0x74, 0x3a, 0xf3,
	0x36, 0xc1, 0xa7, 0x51, 0x65, 0xb7, 0xa3, 0x75, 0x6f, 0x7f, 0x64, 0xdc, 0xde, 0xd9, 0xdc, 0xac,
	0x9e, 0xc2, 0xf3, 0x68, 0x56, 0x08, 0x5a, 0x8d, 0xaa, 0x82, 0xe7, 0x50, 0xb9, 0x7b, 0x4f, 0xef,
	0xb4, 0x76, 0xb4, 0x4e, 0x35, 0xf7, 0xfa, 0x67, 0xca, 0xb1, 0xbe, 0x31, 0xfe, 0x0f, 0x74, 0xb9,
	0xdb, 0xd8, 0x32, 0x7a, 0xf7, 0x37, 0xbb, 0xad, 0x8f, 0x0c, 0x7d, 0xbb, 0xb1, 0xbd, 0xa3, 0x1b,
	0x3b, 0xf7, 0xf4, 0x5e, 0xa7, 0xd5, 0xbd, 0xdd, 0xed, 0xb4, 0xab, 0xa7, 0xf0, 0x65, 0x74, 0xe1,
	0x38, 0xa4, 0xd7, 0xb9, 0xd7, 0xee, 0xde, 0xbb, 0x53, 0x55, 0xf0, 0x25, 0x54, 0x3b, 0x3e, 0x7c,
	0xbb, 0xd1, 0xdd, 0xec, 0xb4, 0xab, 0xb9, 0xe9, 0xca, 0xfa, 0x4e, 0xab, 0xd5, 0xd1, 0xf5, 0x6a,
	0xbe, 0xd9, 0x78, 0xf2, 0xc7, 0x2b, 0xa7, 0x9e, 0x7c, 0x79, 0x45, 0xf9, 0xf5, 0x97, 0x57, 0x94,
	0x3f, 0x7c, 0x79, 0x45, 0xf9, 0xda, 0xda, 0x81, 0x13, 0x1e, 0x0e, 0xf7, 0x56, 0x2d, 0xaf, 0xbf,
	0x76, 0x10, 0x98, 0x0f, 0x1d, 0x1e, 0x2a, 0xa6, 0xbb, 0x16, 0xff, 0xbc, 0xce, 0xf4, 0x9d, 0xe4,
	0x17, 0x75, 0x7b, 0x25, 0x70, 0xe9, 0x8d, 0xbf, 0x07, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x5c, 0x23,
	0xf8, 0x7f, 0x27, 0x00, 0x00,
}

func (m *ResourceHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0x42
	}
	if m.ID != 0 {
		i = encodeVarintTypestest(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x38
	}
	if m.Expires != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Expires, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintTypestest(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypestest(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypestest(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypestest(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandLabelV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandLabelV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandLabelV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Command) > 0 {
		for iNdEx := len(m.Command) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Command[iNdEx])
			copy(dAtA[i:], m.Command[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.Command[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Period != 0 {
		i = encodeVarintTypestest(dAtA, i, uint64(m.Period))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Oracle.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.MongoAtlas.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.AdminUser != nil {
		{
			size, err := m.AdminUser.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypestest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	{
		size, err := m.MySQL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.AD.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.TLS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.GCP.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.DynamicLabels) > 0 {
		for k := range m.DynamicLabels {
			v := m.DynamicLabels[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypestest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypestest(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypestest(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CACert) > 0 {
		i -= len(m.CACert)
		copy(dAtA[i:], m.CACert)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.CACert)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseServerV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseServerV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseServerV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseServerSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseServerSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseServerSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyIDs) > 0 {
		for iNdEx := len(m.ProxyIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProxyIDs[iNdEx])
			copy(dAtA[i:], m.ProxyIDs[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.ProxyIDs[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Database != nil {
		{
			size, err := m.Database.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypestest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	{
		size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseStatusV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseStatusV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseStatusV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Azure.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.ManagedUsers) > 0 {
		for iNdEx := len(m.ManagedUsers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ManagedUsers[iNdEx])
			copy(dAtA[i:], m.ManagedUsers[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.ManagedUsers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.MySQL.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.CACert) > 0 {
		i -= len(m.CACert)
		copy(dAtA[i:], m.CACert)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.CACert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IAMPolicyStatus != 0 {
		i = encodeVarintTypestest(dAtA, i, uint64(m.IAMPolicyStatus))
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.OpenSearch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if len(m.AssumeRoleARN) > 0 {
		i -= len(m.AssumeRoleARN)
		copy(dAtA[i:], m.AssumeRoleARN)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.AssumeRoleARN)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.RedshiftServerless.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.RDSProxy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.MemoryDB.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.SecretStore.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.ElastiCache.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.AccountID) > 0 {
		i -= len(m.AccountID)
		copy(dAtA[i:], m.AccountID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.AccountID)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.RDS.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Redshift.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureRedis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureRedis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureRedis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusteringPolicy) > 0 {
		i -= len(m.ClusteringPolicy)
		copy(dAtA[i:], m.ClusteringPolicy)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ClusteringPolicy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Redshift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Redshift) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Redshift) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RDS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RDS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RDS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VPCID) > 0 {
		i -= len(m.VPCID)
		copy(dAtA[i:], m.VPCID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.VPCID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Subnets[iNdEx])
			copy(dAtA[i:], m.Subnets[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.Subnets[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.IAMAuth {
		i--
		if m.IAMAuth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.ResourceID) > 0 {
		i -= len(m.ResourceID)
		copy(dAtA[i:], m.ResourceID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ResourceID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InstanceID) > 0 {
		i -= len(m.InstanceID)
		copy(dAtA[i:], m.InstanceID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.InstanceID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ElastiCache) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElastiCache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElastiCache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointType) > 0 {
		i -= len(m.EndpointType)
		copy(dAtA[i:], m.EndpointType)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.EndpointType)))
		i--
		dAtA[i] = 0x22
	}
	if m.TransitEncryptionEnabled {
		i--
		if m.TransitEncryptionEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserGroupIDs) > 0 {
		for iNdEx := len(m.UserGroupIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserGroupIDs[iNdEx])
			copy(dAtA[i:], m.UserGroupIDs[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.UserGroupIDs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ReplicationGroupID) > 0 {
		i -= len(m.ReplicationGroupID)
		copy(dAtA[i:], m.ReplicationGroupID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ReplicationGroupID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecretStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KMSKeyID) > 0 {
		i -= len(m.KMSKeyID)
		copy(dAtA[i:], m.KMSKeyID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.KMSKeyID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyPrefix) > 0 {
		i -= len(m.KeyPrefix)
		copy(dAtA[i:], m.KeyPrefix)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.KeyPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoryDB) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryDB) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryDB) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointType) > 0 {
		i -= len(m.EndpointType)
		copy(dAtA[i:], m.EndpointType)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.EndpointType)))
		i--
		dAtA[i] = 0x22
	}
	if m.TLSEnabled {
		i--
		if m.TLSEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ACLName) > 0 {
		i -= len(m.ACLName)
		copy(dAtA[i:], m.ACLName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ACLName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RDSProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RDSProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RDSProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ResourceID) > 0 {
		i -= len(m.ResourceID)
		copy(dAtA[i:], m.ResourceID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ResourceID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CustomEndpointName) > 0 {
		i -= len(m.CustomEndpointName)
		copy(dAtA[i:], m.CustomEndpointName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.CustomEndpointName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedshiftServerless) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedshiftServerless) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedshiftServerless) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.WorkgroupID) > 0 {
		i -= len(m.WorkgroupID)
		copy(dAtA[i:], m.WorkgroupID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.WorkgroupID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EndpointName) > 0 {
		i -= len(m.EndpointName)
		copy(dAtA[i:], m.EndpointName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.EndpointName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WorkgroupName) > 0 {
		i -= len(m.WorkgroupName)
		copy(dAtA[i:], m.WorkgroupName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.WorkgroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenSearch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenSearch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenSearch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EndpointType) > 0 {
		i -= len(m.EndpointType)
		copy(dAtA[i:], m.EndpointType)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.EndpointType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DomainID) > 0 {
		i -= len(m.DomainID)
		copy(dAtA[i:], m.DomainID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.DomainID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DomainName) > 0 {
		i -= len(m.DomainName)
		copy(dAtA[i:], m.DomainName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.DomainName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPCloudSQL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPCloudSQL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPCloudSQL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.InstanceID) > 0 {
		i -= len(m.InstanceID)
		copy(dAtA[i:], m.InstanceID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.InstanceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProjectID) > 0 {
		i -= len(m.ProjectID)
		copy(dAtA[i:], m.ProjectID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ProjectID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Azure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Azure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Azure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsFlexiServer {
		i--
		if m.IsFlexiServer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Redis.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ResourceID) > 0 {
		i -= len(m.ResourceID)
		copy(dAtA[i:], m.ResourceID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ResourceID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseTLS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseTLS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseTLS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CACert) > 0 {
		i -= len(m.CACert)
		copy(dAtA[i:], m.CACert)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.CACert)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mode != 0 {
		i = encodeVarintTypestest(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AD) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AD) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AD) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KDCHostName) > 0 {
		i -= len(m.KDCHostName)
		copy(dAtA[i:], m.KDCHostName)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.KDCHostName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LDAPCert) > 0 {
		i -= len(m.LDAPCert)
		copy(dAtA[i:], m.LDAPCert)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.LDAPCert)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SPN) > 0 {
		i -= len(m.SPN)
		copy(dAtA[i:], m.SPN)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.SPN)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Krb5File) > 0 {
		i -= len(m.Krb5File)
		copy(dAtA[i:], m.Krb5File)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Krb5File)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeytabFile) > 0 {
		i -= len(m.KeytabFile)
		copy(dAtA[i:], m.KeytabFile)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.KeytabFile)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MySQLOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MySQLOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MySQLOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerVersion) > 0 {
		i -= len(m.ServerVersion)
		copy(dAtA[i:], m.ServerVersion)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ServerVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatabaseAdminUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatabaseAdminUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatabaseAdminUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MongoAtlas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MongoAtlas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MongoAtlas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AuditUser) > 0 {
		i -= len(m.AuditUser)
		copy(dAtA[i:], m.AuditUser)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.AuditUser)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppServerV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppServerV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppServerV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppServerSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppServerSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppServerSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProxyIDs) > 0 {
		for iNdEx := len(m.ProxyIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProxyIDs[iNdEx])
			copy(dAtA[i:], m.ProxyIDs[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.ProxyIDs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.App != nil {
		{
			size, err := m.App.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypestest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.HostID) > 0 {
		i -= len(m.HostID)
		copy(dAtA[i:], m.HostID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.HostID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Spec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SubKind) > 0 {
		i -= len(m.SubKind)
		copy(dAtA[i:], m.SubKind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.SubKind)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppSpecV3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppSpecV3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppSpecV3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserGroups) > 0 {
		for iNdEx := len(m.UserGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserGroups[iNdEx])
			copy(dAtA[i:], m.UserGroups[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.UserGroups[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Cloud) > 0 {
		i -= len(m.Cloud)
		copy(dAtA[i:], m.Cloud)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Cloud)))
		i--
		dAtA[i] = 0x3a
	}
	if m.AWS != nil {
		{
			size, err := m.AWS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypestest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Rewrite != nil {
		{
			size, err := m.Rewrite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypestest(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.InsecureSkipVerify {
		i--
		if m.InsecureSkipVerify {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.DynamicLabels) > 0 {
		for k := range m.DynamicLabels {
			v := m.DynamicLabels[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypestest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypestest(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypestest(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PublicAddr) > 0 {
		i -= len(m.PublicAddr)
		copy(dAtA[i:], m.PublicAddr)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.PublicAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.URI) > 0 {
		i -= len(m.URI)
		copy(dAtA[i:], m.URI)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.URI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JWTClaims) > 0 {
		i -= len(m.JWTClaims)
		copy(dAtA[i:], m.JWTClaims)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.JWTClaims)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypestest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Redirect) > 0 {
		for iNdEx := len(m.Redirect) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Redirect[iNdEx])
			copy(dAtA[i:], m.Redirect[iNdEx])
			i = encodeVarintTypestest(dAtA, i, uint64(len(m.Redirect[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppAWS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppAWS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppAWS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ExternalID) > 0 {
		i -= len(m.ExternalID)
		copy(dAtA[i:], m.ExternalID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.ExternalID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Rotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rotation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rotation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Schedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypestest(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	n42, err42 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastRotated, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastRotated):])
	if err42 != nil {
		return 0, err42
	}
	i -= n42
	i = encodeVarintTypestest(dAtA, i, uint64(n42))
	i--
	dAtA[i] = 0x3a
	if m.GracePeriod != 0 {
		i = encodeVarintTypestest(dAtA, i, uint64(m.GracePeriod))
		i--
		dAtA[i] = 0x30
	}
	n43, err43 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Started, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Started):])
	if err43 != nil {
		return 0, err43
	}
	i -= n43
	i = encodeVarintTypestest(dAtA, i, uint64(n43))
	i--
	dAtA[i] = 0x2a
	if len(m.CurrentID) > 0 {
		i -= len(m.CurrentID)
		copy(dAtA[i:], m.CurrentID)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.CurrentID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Phase) > 0 {
		i -= len(m.Phase)
		copy(dAtA[i:], m.Phase)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.Phase)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintTypestest(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RotationSchedule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RotationSchedule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RotationSchedule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n44, err44 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Standby, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Standby):])
	if err44 != nil {
		return 0, err44
	}
	i -= n44
	i = encodeVarintTypestest(dAtA, i, uint64(n44))
	i--
	dAtA[i] = 0x1a
	n45, err45 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdateServers, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateServers):])
	if err45 != nil {
		return 0, err45
	}
	i -= n45
	i = encodeVarintTypestest(dAtA, i, uint64(n45))
	i--
	dAtA[i] = 0x12
	n46, err46 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdateClients, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateClients):])
	if err46 != nil {
		return 0, err46
	}
	i -= n46
	i = encodeVarintTypestest(dAtA, i, uint64(n46))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintTypestest(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypestest(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ResourceHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypestest(uint64(len(k))) + 1 + len(v) + sovTypestest(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypestest(uint64(mapEntrySize))
		}
	}
	if m.Expires != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Expires)
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovTypestest(uint64(m.ID))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommandLabelV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Period != 0 {
		n += 1 + sovTypestest(uint64(m.Period))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.CACert)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if len(m.DynamicLabels) > 0 {
		for k, v := range m.DynamicLabels {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypestest(uint64(len(k))) + 1 + l + sovTypestest(uint64(l))
			n += mapEntrySize + 1 + sovTypestest(uint64(mapEntrySize))
		}
	}
	l = m.AWS.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.GCP.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Azure.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.TLS.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.AD.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.MySQL.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.AdminUser != nil {
		l = m.AdminUser.Size()
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.MongoAtlas.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Oracle.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseServerV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseServerSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Rotation.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.Database != nil {
		l = m.Database.Size()
		n += 1 + l + sovTypestest(uint64(l))
	}
	if len(m.ProxyIDs) > 0 {
		for _, s := range m.ProxyIDs {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseStatusV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CACert)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.AWS.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.MySQL.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if len(m.ManagedUsers) > 0 {
		for _, s := range m.ManagedUsers {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	l = m.Azure.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AWS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Redshift.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.RDS.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.ElastiCache.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.SecretStore.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.MemoryDB.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.RDSProxy.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.RedshiftServerless.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.AssumeRoleARN)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.OpenSearch.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.IAMPolicyStatus != 0 {
		n += 1 + sovTypestest(uint64(m.IAMPolicyStatus))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AzureRedis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusteringPolicy)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Redshift) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RDS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.ResourceID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.IAMAuth {
		n += 2
	}
	if len(m.Subnets) > 0 {
		for _, s := range m.Subnets {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	l = len(m.VPCID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ElastiCache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReplicationGroupID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if len(m.UserGroupIDs) > 0 {
		for _, s := range m.UserGroupIDs {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	if m.TransitEncryptionEnabled {
		n += 2
	}
	l = len(m.EndpointType)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecretStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyPrefix)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.KMSKeyID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryDB) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.ACLName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.TLSEnabled {
		n += 2
	}
	l = len(m.EndpointType)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RDSProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.CustomEndpointName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.ResourceID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RedshiftServerless) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkgroupName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.EndpointName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.WorkgroupID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpenSearch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.DomainID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.EndpointType)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GCPCloudSQL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Azure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.ResourceID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Redis.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.IsFlexiServer {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseTLS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovTypestest(uint64(m.Mode))
	}
	l = len(m.CACert)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AD) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeytabFile)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Krb5File)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.SPN)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.LDAPCert)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.KDCHostName)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MySQLOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServerVersion)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatabaseAdminUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MongoAtlas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuditUser)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppServerV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppServerSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.HostID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Rotation.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovTypestest(uint64(l))
	}
	if len(m.ProxyIDs) > 0 {
		for _, s := range m.ProxyIDs {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.SubKind)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppSpecV3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.PublicAddr)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if len(m.DynamicLabels) > 0 {
		for k, v := range m.DynamicLabels {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovTypestest(uint64(len(k))) + 1 + l + sovTypestest(uint64(l))
			n += mapEntrySize + 1 + sovTypestest(uint64(mapEntrySize))
		}
	}
	if m.InsecureSkipVerify {
		n += 2
	}
	if m.Rewrite != nil {
		l = m.Rewrite.Size()
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.AWS != nil {
		l = m.AWS.Size()
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Cloud)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if len(m.UserGroups) > 0 {
		for _, s := range m.UserGroups {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Redirect) > 0 {
		for _, s := range m.Redirect {
			l = len(s)
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypestest(uint64(l))
		}
	}
	l = len(m.JWTClaims)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppAWS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExternalID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rotation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = len(m.CurrentID)
	if l > 0 {
		n += 1 + l + sovTypestest(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Started)
	n += 1 + l + sovTypestest(uint64(l))
	if m.GracePeriod != 0 {
		n += 1 + sovTypestest(uint64(m.GracePeriod))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastRotated)
	n += 1 + l + sovTypestest(uint64(l))
	l = m.Schedule.Size()
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RotationSchedule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateClients)
	n += 1 + l + sovTypestest(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateServers)
	n += 1 + l + sovTypestest(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Standby)
	n += 1 + l + sovTypestest(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypestest(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypestest(x uint64) (n int) {
	return sovTypestest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResourceHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypestest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypestest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypestest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypestest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypestest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypestest
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypestest
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypestest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypestest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expires == nil {
				m.Expires = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Expires, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandLabelV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandLabelV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandLabelV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicLabels == nil {
				m.DynamicLabels = make(map[string]CommandLabelV2)
			}
			var mapkey string
			mapvalue := &CommandLabelV2{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypestest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypestest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypestest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypestest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypestest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypestest
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypestest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLabelV2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypestest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypestest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DynamicLabels[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GCP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TLS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AD.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MySQL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MySQL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminUser == nil {
				m.AdminUser = &DatabaseAdminUser{}
			}
			if err := m.AdminUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MongoAtlas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MongoAtlas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oracle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Oracle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseServerV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseServerV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseServerV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseServerSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseServerSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseServerSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Database", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Database == nil {
				m.Database = &DatabaseV3{}
			}
			if err := m.Database.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyIDs = append(m.ProxyIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseStatusV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseStatusV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseStatusV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MySQL", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MySQL.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagedUsers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ManagedUsers = append(m.ManagedUsers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Azure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Azure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redshift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Redshift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RDS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElastiCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ElastiCache.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SecretStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryDB", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MemoryDB.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RDSProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RDSProxy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedshiftServerless", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RedshiftServerless.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeRoleARN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssumeRoleARN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenSearch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OpenSearch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IAMPolicyStatus", wireType)
			}
			m.IAMPolicyStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IAMPolicyStatus |= IAMPolicyStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureRedis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureRedis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureRedis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusteringPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusteringPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Redshift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Redshift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Redshift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RDS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RDS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RDS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IAMAuth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IAMAuth = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VPCID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VPCID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElastiCache) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElastiCache: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElastiCache: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationGroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicationGroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroupIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroupIDs = append(m.UserGroupIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitEncryptionEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TransitEncryptionEnabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KMSKeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KMSKeyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryDB) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryDB: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryDB: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ACLName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ACLName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TLSEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TLSEnabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RDSProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RDSProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RDSProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomEndpointName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomEndpointName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedshiftServerless) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedshiftServerless: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedshiftServerless: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkgroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkgroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenSearch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenSearch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenSearch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPCloudSQL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPCloudSQL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPCloudSQL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Azure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Azure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Azure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Redis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFlexiServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFlexiServer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseTLS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseTLS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseTLS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= DatabaseTLSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CACert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CACert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AD) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeytabFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeytabFile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Krb5File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Krb5File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SPN", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SPN = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LDAPCert", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LDAPCert = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KDCHostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KDCHostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MySQLOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MySQLOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MySQLOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatabaseAdminUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatabaseAdminUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatabaseAdminUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MongoAtlas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MongoAtlas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MongoAtlas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuditUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppServerV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppServerV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppServerV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppServerSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppServerSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppServerSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &AppV3{}
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyIDs = append(m.ProxyIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppSpecV3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppSpecV3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppSpecV3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DynamicLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DynamicLabels == nil {
				m.DynamicLabels = make(map[string]CommandLabelV2)
			}
			var mapkey string
			mapvalue := &CommandLabelV2{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypestest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypestest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypestest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypestest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypestest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypestest
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypestest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CommandLabelV2{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypestest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypestest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DynamicLabels[mapkey] = *mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureSkipVerify", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InsecureSkipVerify = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewrite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewrite == nil {
				m.Rewrite = &Rewrite{}
			}
			if err := m.Rewrite.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AWS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AWS == nil {
				m.AWS = &AppAWS{}
			}
			if err := m.AWS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cloud", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cloud = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserGroups = append(m.UserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Redirect = append(m.Redirect, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &Header{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWTClaims", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWTClaims = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppAWS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppAWS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppAWS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Started, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GracePeriod", wireType)
			}
			m.GracePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GracePeriod |= Duration(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRotated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastRotated, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Schedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RotationSchedule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RotationSchedule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RotationSchedule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateClients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdateClients, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdateServers, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Standby", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypestest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypestest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Standby, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypestest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypestest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypestest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypestest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypestest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypestest
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypestest
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypestest
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypestest        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypestest          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypestest = fmt.Errorf("proto: unexpected end of group")
)
