// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: prehog/v1alpha/teleport.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// UserOrigin is the origin of a user account.
/// Keep the values in sync with UserOrigin enum defined in
/// API events and prehogv1.
public enum Prehog_V1alpha_UserOrigin: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Indicates a legacy cluster emitting events without a defined user origin.
  case unspecified // = 0

  /// Indicates a local user.
  case local // = 1

  /// Indicates an SSO user originated from the SAML or OIDC connector.
  case sso // = 2

  /// Indicates a user originated from the Okta integration.
  case okta // = 3

  /// Indicates a user originated from the SCIM integration.
  case scim // = 4

  /// Indicates a user originated from the EntraID integration.
  case entraid // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .local
    case 2: self = .sso
    case 3: self = .okta
    case 4: self = .scim
    case 5: self = .entraid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .local: return 1
    case .sso: return 2
    case .okta: return 3
    case .scim: return 4
    case .entraid: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_UserOrigin] = [
    .unspecified,
    .local,
    .sso,
    .okta,
    .scim,
    .entraid,
  ]

}

/// the kind of a "resource" as intended by ResourceHeartbeatEvent
/// Keep in sync with prehog/v1/teleport.proto
public enum Prehog_V1alpha_ResourceKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// PostHog property value: "node"
  case node // = 1

  /// PostHog property value: "app_server"
  case appServer // = 2

  /// PostHog property value: "kube_server"
  case kubeServer // = 3

  /// PostHog property value: "db_server"
  case dbServer // = 4

  /// PostHog property value: "windows_desktop"
  case windowsDesktop // = 5

  /// ServerV3 ("node") heartbeat with a subkind of "openssh" (as opposed to
  /// empty or "teleport"); not used in keepalives
  ///
  /// PostHog property value: "node.openssh"
  case nodeOpenssh // = 6

  /// ServerV3 ("node") heartbeat with a subkind of "openssh-ec2-ice".
  /// Nodes that map EC2 instances and are accessed using EC2 Instance Connect Endpoint.
  /// Not used in keepalives.
  /// This is the SubKind SubKindOpenSSHEICENode in teleport repo.
  ///
  /// PostHog property value: "node.openssh_ec2_ice"
  case nodeOpensshEice // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .node
    case 2: self = .appServer
    case 3: self = .kubeServer
    case 4: self = .dbServer
    case 5: self = .windowsDesktop
    case 6: self = .nodeOpenssh
    case 7: self = .nodeOpensshEice
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .node: return 1
    case .appServer: return 2
    case .kubeServer: return 3
    case .dbServer: return 4
    case .windowsDesktop: return 5
    case .nodeOpenssh: return 6
    case .nodeOpensshEice: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_ResourceKind] = [
    .unspecified,
    .node,
    .appServer,
    .kubeServer,
    .dbServer,
    .windowsDesktop,
    .nodeOpenssh,
    .nodeOpensshEice,
  ]

}

/// The kind of user a given username refers to. Usernames should always refer to
/// a valid cluster user (even if temporary, e.g. SSO), but may be Machine ID
/// bot users.
public enum Prehog_V1alpha_UserKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Indicates a legacy cluster emitting events without a defined user kind.
  /// Note that users (from PostHog's perspective) can be identified via future
  /// events if the cluster is upgraded to specify this field.
  ///
  /// PostHog property value: ""
  case unspecified // = 0

  /// Indicates the user associated with this event is human, either created
  /// locally or via SSO.
  ///
  /// PostHog property value: "human"
  case human // = 1

  /// Indicates the user associated with this event is a Machine ID bot user.
  ///
  /// PostHog property value: "bot"
  case bot // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .human
    case 2: self = .bot
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .human: return 1
    case .bot: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_UserKind] = [
    .unspecified,
    .human,
    .bot,
  ]

}

/// DiscoverResource represents a resource type.
public enum Prehog_V1alpha_DiscoverResource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case server // = 1
  case kubernetes // = 2
  case databasePostgresSelfHosted // = 3
  case databaseMysqlSelfHosted // = 4
  case databaseMongodbSelfHosted // = 5
  case databasePostgresRds // = 6
  case databaseMysqlRds // = 7
  case applicationHTTP // = 8
  case applicationTcp // = 9
  case windowsDesktop // = 10
  case databaseSqlserverRds // = 11
  case databasePostgresRedshift // = 12
  case databaseSqlserverSelfHosted // = 13
  case databaseRedisSelfHosted // = 14
  case databasePostgresGcp // = 15
  case databaseMysqlGcp // = 16
  case databaseSqlserverGcp // = 17
  case databasePostgresRedshiftServerless // = 18
  case databasePostgresAzure // = 19
  case databaseDynamodb // = 20
  case databaseCassandraKeyspaces // = 21

  /// Cassandra & ScyllaDb
  case databaseCassandraSelfHosted // = 22
  case databaseElasticsearchSelfHosted // = 23

  /// Elasticache & MemoryDb
  case databaseRedisElasticache // = 24
  case databaseRedisMemorydb // = 25
  case databaseRedisAzureCache // = 26
  case databaseRedisClusterSelfHosted // = 27
  case databaseMysqlAzure // = 28
  case databaseSqlserverAzure // = 29
  case databaseSqlserverMicrosoft // = 30
  case databaseCockroachdbSelfHosted // = 31
  case databaseMongodbAtlas // = 32
  case databaseSnowflake // = 33
  case docDatabaseRdsProxy // = 34
  case docDatabaseHighAvailability // = 35
  case docDatabaseDynamicRegistration // = 36
  case samlApplication // = 37
  case ec2Instance // = 38
  case docWindowsDesktopNonAd // = 39
  case kubernetesEks // = 40
  case applicationAwsConsole // = 41
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .server
    case 2: self = .kubernetes
    case 3: self = .databasePostgresSelfHosted
    case 4: self = .databaseMysqlSelfHosted
    case 5: self = .databaseMongodbSelfHosted
    case 6: self = .databasePostgresRds
    case 7: self = .databaseMysqlRds
    case 8: self = .applicationHTTP
    case 9: self = .applicationTcp
    case 10: self = .windowsDesktop
    case 11: self = .databaseSqlserverRds
    case 12: self = .databasePostgresRedshift
    case 13: self = .databaseSqlserverSelfHosted
    case 14: self = .databaseRedisSelfHosted
    case 15: self = .databasePostgresGcp
    case 16: self = .databaseMysqlGcp
    case 17: self = .databaseSqlserverGcp
    case 18: self = .databasePostgresRedshiftServerless
    case 19: self = .databasePostgresAzure
    case 20: self = .databaseDynamodb
    case 21: self = .databaseCassandraKeyspaces
    case 22: self = .databaseCassandraSelfHosted
    case 23: self = .databaseElasticsearchSelfHosted
    case 24: self = .databaseRedisElasticache
    case 25: self = .databaseRedisMemorydb
    case 26: self = .databaseRedisAzureCache
    case 27: self = .databaseRedisClusterSelfHosted
    case 28: self = .databaseMysqlAzure
    case 29: self = .databaseSqlserverAzure
    case 30: self = .databaseSqlserverMicrosoft
    case 31: self = .databaseCockroachdbSelfHosted
    case 32: self = .databaseMongodbAtlas
    case 33: self = .databaseSnowflake
    case 34: self = .docDatabaseRdsProxy
    case 35: self = .docDatabaseHighAvailability
    case 36: self = .docDatabaseDynamicRegistration
    case 37: self = .samlApplication
    case 38: self = .ec2Instance
    case 39: self = .docWindowsDesktopNonAd
    case 40: self = .kubernetesEks
    case 41: self = .applicationAwsConsole
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .server: return 1
    case .kubernetes: return 2
    case .databasePostgresSelfHosted: return 3
    case .databaseMysqlSelfHosted: return 4
    case .databaseMongodbSelfHosted: return 5
    case .databasePostgresRds: return 6
    case .databaseMysqlRds: return 7
    case .applicationHTTP: return 8
    case .applicationTcp: return 9
    case .windowsDesktop: return 10
    case .databaseSqlserverRds: return 11
    case .databasePostgresRedshift: return 12
    case .databaseSqlserverSelfHosted: return 13
    case .databaseRedisSelfHosted: return 14
    case .databasePostgresGcp: return 15
    case .databaseMysqlGcp: return 16
    case .databaseSqlserverGcp: return 17
    case .databasePostgresRedshiftServerless: return 18
    case .databasePostgresAzure: return 19
    case .databaseDynamodb: return 20
    case .databaseCassandraKeyspaces: return 21
    case .databaseCassandraSelfHosted: return 22
    case .databaseElasticsearchSelfHosted: return 23
    case .databaseRedisElasticache: return 24
    case .databaseRedisMemorydb: return 25
    case .databaseRedisAzureCache: return 26
    case .databaseRedisClusterSelfHosted: return 27
    case .databaseMysqlAzure: return 28
    case .databaseSqlserverAzure: return 29
    case .databaseSqlserverMicrosoft: return 30
    case .databaseCockroachdbSelfHosted: return 31
    case .databaseMongodbAtlas: return 32
    case .databaseSnowflake: return 33
    case .docDatabaseRdsProxy: return 34
    case .docDatabaseHighAvailability: return 35
    case .docDatabaseDynamicRegistration: return 36
    case .samlApplication: return 37
    case .ec2Instance: return 38
    case .docWindowsDesktopNonAd: return 39
    case .kubernetesEks: return 40
    case .applicationAwsConsole: return 41
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_DiscoverResource] = [
    .unspecified,
    .server,
    .kubernetes,
    .databasePostgresSelfHosted,
    .databaseMysqlSelfHosted,
    .databaseMongodbSelfHosted,
    .databasePostgresRds,
    .databaseMysqlRds,
    .applicationHTTP,
    .applicationTcp,
    .windowsDesktop,
    .databaseSqlserverRds,
    .databasePostgresRedshift,
    .databaseSqlserverSelfHosted,
    .databaseRedisSelfHosted,
    .databasePostgresGcp,
    .databaseMysqlGcp,
    .databaseSqlserverGcp,
    .databasePostgresRedshiftServerless,
    .databasePostgresAzure,
    .databaseDynamodb,
    .databaseCassandraKeyspaces,
    .databaseCassandraSelfHosted,
    .databaseElasticsearchSelfHosted,
    .databaseRedisElasticache,
    .databaseRedisMemorydb,
    .databaseRedisAzureCache,
    .databaseRedisClusterSelfHosted,
    .databaseMysqlAzure,
    .databaseSqlserverAzure,
    .databaseSqlserverMicrosoft,
    .databaseCockroachdbSelfHosted,
    .databaseMongodbAtlas,
    .databaseSnowflake,
    .docDatabaseRdsProxy,
    .docDatabaseHighAvailability,
    .docDatabaseDynamicRegistration,
    .samlApplication,
    .ec2Instance,
    .docWindowsDesktopNonAd,
    .kubernetesEks,
    .applicationAwsConsole,
  ]

}

/// DiscoverStatus represents a Discover Step outcome.
public enum Prehog_V1alpha_DiscoverStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// The user tried to complete the action and it succeeded.
  case success // = 1

  /// The system skipped the step.
  /// For example:
  /// When setting up a Database and there's already a Database Service proxying the DB.
  /// In this case the Database Agent installation is skipped.
  case skipped // = 2

  /// The user tried to complete the action and it failed.
  case error // = 3

  /// The user did not complete the action and left the wizard.
  case aborted // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .skipped
    case 3: self = .error
    case 4: self = .aborted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .skipped: return 2
    case .error: return 3
    case .aborted: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_DiscoverStatus] = [
    .unspecified,
    .success,
    .skipped,
    .error,
    .aborted,
  ]

}

/// CTA represents teleport web UI's call to action buttons
public enum Prehog_V1alpha_CTA: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case authConnector // = 1
  case activeSessions // = 2
  case accessRequests // = 3
  case premiumSupport // = 4
  case trustedDevices // = 5
  case upgradeBanner // = 6
  case billingSummary // = 7
  case accessList // = 8
  case accessMonitoring // = 9
  case externalAuditStorage // = 10
  case oktaUserSync // = 11
  case entraID // = 12
  case oktaScim // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .authConnector
    case 2: self = .activeSessions
    case 3: self = .accessRequests
    case 4: self = .premiumSupport
    case 5: self = .trustedDevices
    case 6: self = .upgradeBanner
    case 7: self = .billingSummary
    case 8: self = .accessList
    case 9: self = .accessMonitoring
    case 10: self = .externalAuditStorage
    case 11: self = .oktaUserSync
    case 12: self = .entraID
    case 13: self = .oktaScim
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .authConnector: return 1
    case .activeSessions: return 2
    case .accessRequests: return 3
    case .premiumSupport: return 4
    case .trustedDevices: return 5
    case .upgradeBanner: return 6
    case .billingSummary: return 7
    case .accessList: return 8
    case .accessMonitoring: return 9
    case .externalAuditStorage: return 10
    case .oktaUserSync: return 11
    case .entraID: return 12
    case .oktaScim: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_CTA] = [
    .unspecified,
    .authConnector,
    .activeSessions,
    .accessRequests,
    .premiumSupport,
    .trustedDevices,
    .upgradeBanner,
    .billingSummary,
    .accessList,
    .accessMonitoring,
    .externalAuditStorage,
    .oktaUserSync,
    .entraID,
    .oktaScim,
  ]

}

/// IntegrationEnrollKind represents the types of integration that
/// can be enrolled.
public enum Prehog_V1alpha_IntegrationEnrollKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case slack // = 1
  case awsOidc // = 2
  case pagerduty // = 3
  case email // = 4
  case jira // = 5
  case discord // = 6
  case mattermost // = 7
  case msTeams // = 8
  case opsgenie // = 9
  case okta // = 10
  case jamf // = 11
  case machineID // = 12
  case machineIDGithubActions // = 13
  case machineIDCircleci // = 14
  case machineIDGitlab // = 15
  case machineIDJenkins // = 16
  case machineIDAnsible // = 17
  case machineIDAws // = 18
  case machineIDGcp // = 19
  case machineIDAzure // = 20
  case machineIDSpacelift // = 21
  case machineIDKubernetes // = 22
  case entraID // = 23
  case datadogIncidentManagement // = 24
  case servicenow // = 25
  case awsIdentityCenter // = 26
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .slack
    case 2: self = .awsOidc
    case 3: self = .pagerduty
    case 4: self = .email
    case 5: self = .jira
    case 6: self = .discord
    case 7: self = .mattermost
    case 8: self = .msTeams
    case 9: self = .opsgenie
    case 10: self = .okta
    case 11: self = .jamf
    case 12: self = .machineID
    case 13: self = .machineIDGithubActions
    case 14: self = .machineIDCircleci
    case 15: self = .machineIDGitlab
    case 16: self = .machineIDJenkins
    case 17: self = .machineIDAnsible
    case 18: self = .machineIDAws
    case 19: self = .machineIDGcp
    case 20: self = .machineIDAzure
    case 21: self = .machineIDSpacelift
    case 22: self = .machineIDKubernetes
    case 23: self = .entraID
    case 24: self = .datadogIncidentManagement
    case 25: self = .servicenow
    case 26: self = .awsIdentityCenter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .slack: return 1
    case .awsOidc: return 2
    case .pagerduty: return 3
    case .email: return 4
    case .jira: return 5
    case .discord: return 6
    case .mattermost: return 7
    case .msTeams: return 8
    case .opsgenie: return 9
    case .okta: return 10
    case .jamf: return 11
    case .machineID: return 12
    case .machineIDGithubActions: return 13
    case .machineIDCircleci: return 14
    case .machineIDGitlab: return 15
    case .machineIDJenkins: return 16
    case .machineIDAnsible: return 17
    case .machineIDAws: return 18
    case .machineIDGcp: return 19
    case .machineIDAzure: return 20
    case .machineIDSpacelift: return 21
    case .machineIDKubernetes: return 22
    case .entraID: return 23
    case .datadogIncidentManagement: return 24
    case .servicenow: return 25
    case .awsIdentityCenter: return 26
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_IntegrationEnrollKind] = [
    .unspecified,
    .slack,
    .awsOidc,
    .pagerduty,
    .email,
    .jira,
    .discord,
    .mattermost,
    .msTeams,
    .opsgenie,
    .okta,
    .jamf,
    .machineID,
    .machineIDGithubActions,
    .machineIDCircleci,
    .machineIDGitlab,
    .machineIDJenkins,
    .machineIDAnsible,
    .machineIDAws,
    .machineIDGcp,
    .machineIDAzure,
    .machineIDSpacelift,
    .machineIDKubernetes,
    .entraID,
    .datadogIncidentManagement,
    .servicenow,
    .awsIdentityCenter,
  ]

}

/// IntegrationEnrollStep defines inner configuration steps
/// for a given integration type.
public enum Prehog_V1alpha_IntegrationEnrollStep: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// AWSIC denotes AWS Identity Center integration.
  case awsicConnectOidc // = 1
  case awsicSetAccesslistDefaultOwner // = 2
  case awsicUploadAwsSamlSpMetadata // = 3
  case awsicTestScimConnection // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .awsicConnectOidc
    case 2: self = .awsicSetAccesslistDefaultOwner
    case 3: self = .awsicUploadAwsSamlSpMetadata
    case 4: self = .awsicTestScimConnection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .awsicConnectOidc: return 1
    case .awsicSetAccesslistDefaultOwner: return 2
    case .awsicUploadAwsSamlSpMetadata: return 3
    case .awsicTestScimConnection: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_IntegrationEnrollStep] = [
    .unspecified,
    .awsicConnectOidc,
    .awsicSetAccesslistDefaultOwner,
    .awsicUploadAwsSamlSpMetadata,
    .awsicTestScimConnection,
  ]

}

/// IntegrationEnrollStatusCode defines status code for an integration enroll step.
public enum Prehog_V1alpha_IntegrationEnrollStatusCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// The user tried to complete the action and it succeeded.
  case success // = 1

  /// The user or system skipped the step.
  /// For example:
  /// When setting up an AWS IAM Identity Center integration, we allow reusing
  /// OIDC integrationn if it was previously created for the Identity Center.
  case skipped // = 2

  /// The user tried to complete the action and it failed.
  case error // = 3

  /// The user did not complete the action and left the wizard.
  case aborted // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .skipped
    case 3: self = .error
    case 4: self = .aborted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .skipped: return 2
    case .error: return 3
    case .aborted: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_IntegrationEnrollStatusCode] = [
    .unspecified,
    .success,
    .skipped,
    .error,
    .aborted,
  ]

}

/// EditorChangeStatus is the possible value of an EditorChangeEvent event status
public enum Prehog_V1alpha_EditorChangeStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Status when the editor role is granted
  case roleGranted // = 1

  /// Status when the editor role is removed
  case roleRemoved // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .roleGranted
    case 2: self = .roleRemoved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .roleGranted: return 1
    case .roleRemoved: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_EditorChangeStatus] = [
    .unspecified,
    .roleGranted,
    .roleRemoved,
  ]

}

/// Feature is name of Teleport feature
public enum Prehog_V1alpha_Feature: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case trustedDevices // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .trustedDevices
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .trustedDevices: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_Feature] = [
    .unspecified,
    .trustedDevices,
  ]

}

/// FeatureRecommendationStatus is feature recommendation status.
public enum Prehog_V1alpha_FeatureRecommendationStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// FEATURE_RECOMMENDATION_STATUS_NOTIFIED is emitted when a feature is recommended (notified in UI) to user.
  case notified // = 1

  /// FEATURE_RECOMMENDATION_STATUS_DONE is emitted when user completes the desired CTA.
  case done // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notified
    case 2: self = .done
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notified: return 1
    case .done: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_FeatureRecommendationStatus] = [
    .unspecified,
    .notified,
    .done,
  ]

}

/// LicenseLimit indicates event type that triggered LicenseLimitEvent.
public enum Prehog_V1alpha_LicenseLimit: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// LICENSE_LIMIT_DEVICE_TRUST_TEAM_JAMF is emitted if license does not
  /// allow Jamf integration (e.g. Team Plan)
  case deviceTrustTeamJamf // = 1

  /// LICENSE_LIMIT_DEVICE_TRUST_TEAM_USAGE is emitted when allowed enrolled device
  /// limit is reached
  case deviceTrustTeamUsage // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .deviceTrustTeamJamf
    case 2: self = .deviceTrustTeamUsage
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .deviceTrustTeamJamf: return 1
    case .deviceTrustTeamUsage: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Prehog_V1alpha_LicenseLimit] = [
    .unspecified,
    .deviceTrustTeamJamf,
    .deviceTrustTeamUsage,
  ]

}

/// a successful user login
///
/// PostHog event: tp.user.login
public struct Prehog_V1alpha_UserLoginEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64;
  /// should always be a real user as bots and service accounts with long-term
  /// credentials don't ever login
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// type of the auth connector used in the login, should be
  /// "local"/"github"/"saml"/"oidc"
  ///
  /// PostHog property: tp.connector_type
  public var connectorType: String = String()

  /// anonymized device ID, empty or 32 bytes (HMAC-SHA-256) encoded in base64;
  /// for logins where device trust is enabled
  ///
  /// PostHog property: tp.device_id
  public var deviceID: String = String()

  /// the required private key policy for this login.
  public var requiredPrivateKeyPolicy: String = String()

  /// UserOrigin specifies the origin of this user account.
  ///
  /// PostHog property: tp.user_origin
  public var userOrigin: Prehog_V1alpha_UserOrigin = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// MFAAuthenticationEvent is emitted when a user performs MFA authentication.
public struct Prehog_V1alpha_MFAAuthenticationEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64;
  /// should always be a real user as bots and service accounts with long-term
  /// credentials don't ever login
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// anonymized device ID, empty or 32 bytes (HMAC-SHA-256) encoded in base64;
  /// for logins where device trust is enabled
  ///
  /// PostHog property: tp.device_id
  public var deviceID: String = String()

  /// device type is the type of MFA device used
  public var deviceType: String = String()

  /// the authorization scope the MFA authentication
  public var mfaChallengeScope: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_SSOCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// github/saml/oidc
  public var connectorType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ResourceCreateEvent is emitted when a resource is created.
public struct Prehog_V1alpha_ResourceCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// resource_type is the type of resource ("node", "node.openssh", "db", "k8s", "app").
  public var resourceType: String = String()

  /// resource_origin is the origin of the resource ("cloud", "kubernetes").
  public var resourceOrigin: String = String()

  /// cloud_provider is the cloud provider the resource came from ("AWS", "Azure", "GCP")
  /// if resource_origin == "cloud".
  public var cloudProvider: String = String()

  /// database contains additional database information if resource_type == "db".
  public var database: Prehog_V1alpha_DiscoveredDatabaseMetadata {
    get {return _database ?? Prehog_V1alpha_DiscoveredDatabaseMetadata()}
    set {_database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  public var hasDatabase: Bool {return self._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  public mutating func clearDatabase() {self._database = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _database: Prehog_V1alpha_DiscoveredDatabaseMetadata? = nil
}

/// DiscoveredDatabaseMetadata contains additional database information.
public struct Prehog_V1alpha_DiscoveredDatabaseMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// database type.
  public var dbType: String = String()

  /// database protocol.
  public var dbProtocol: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// a heartbeat for a resource served by a Teleport instance outside of the
/// control plane (i.e. not auth, not proxy)
///
/// PostHog event: tp.resource.hb
public struct Prehog_V1alpha_ResourceHeartbeatEvent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized name of the resource, 32 bytes (HMAC-SHA-256); the name is the
  /// host ID for nodes but the actual user-facing name for other resources, so
  /// an app or a database served by multiple agents won't be counted multiple
  /// times
  ///
  /// PreHog property: tp.resource_name (in base64)
  public var resourceName: Data = Data()

  /// kind of the resource (node, app, db)
  ///
  /// PostHog property: tp.resource_type (as a string, see ResourceKind)
  public var resourceKind: Prehog_V1alpha_ResourceKind = .unspecified

  /// true if the heartbeat has no expiration
  ///
  /// PostHog property: tp.is_static
  public var `static`: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// an event representing one of several audit events: session.start, port,
/// app.session.start, db.session.start, windows.desktop.session.start; i.e. a
/// SSH shell or port-forward, kubectl exec or kubectl port-forward, DB, App or
/// Desktop connection
///
/// an earlier encoding (as "tp.session.start") mixed SSH sessions and kubectl
/// execs under a session type of "ssh"
///
/// PostHog event: tp.session.start
public struct Prehog_V1alpha_SessionStartEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// type of the session, should be "ssh"/"k8s"/"db"/"app"/"desktop" (matching
  /// the values for api/types.SessionKind) or "app_tcp", "ssh_port_v2" or
  /// "k8s_port" for TCP Application Access connections, SSH port forwards and
  /// kubectl port-forward respectively; a type of "ssh_port" represents either a
  /// SSH port forwarding connection or a kubectl port-forward (not used in new
  /// events)
  ///
  /// PostHog property: tp.session_type
  public var sessionType: String = String()

  /// if session_type == "db" the database struct contains additional information
  /// about database session.
  ///
  /// PostHog property: tp.database
  public var database: Prehog_V1alpha_SessionStartDatabaseMetadata {
    get {return _database ?? Prehog_V1alpha_SessionStartDatabaseMetadata()}
    set {_database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  public var hasDatabase: Bool {return self._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  public mutating func clearDatabase() {self._database = nil}

  /// if session_type == "desktop" the desktop struct contains additional
  /// information about the desktop session
  public var desktop: Prehog_V1alpha_SessionStartDesktopMetadata {
    get {return _desktop ?? Prehog_V1alpha_SessionStartDesktopMetadata()}
    set {_desktop = newValue}
  }
  /// Returns true if `desktop` has been explicitly set.
  public var hasDesktop: Bool {return self._desktop != nil}
  /// Clears the value of `desktop`. Subsequent reads from it will return its default value.
  public mutating func clearDesktop() {self._desktop = nil}

  /// Indicates this event was generated by a Machine ID bot user.
  public var userKind: Prehog_V1alpha_UserKind = .unspecified

  /// if session_type == "app_tcp" the app struct contains additional information about app session.
  ///
  /// PostHog property: tp.app
  public var app: Prehog_V1alpha_SessionStartAppMetadata {
    get {return _app ?? Prehog_V1alpha_SessionStartAppMetadata()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  /// if session_type == "git" the git struct contains additional information
  /// about git session.
  public var git: Prehog_V1alpha_SessionStartGitMetadata {
    get {return _git ?? Prehog_V1alpha_SessionStartGitMetadata()}
    set {_git = newValue}
  }
  /// Returns true if `git` has been explicitly set.
  public var hasGit: Bool {return self._git != nil}
  /// Clears the value of `git`. Subsequent reads from it will return its default value.
  public mutating func clearGit() {self._git = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _database: Prehog_V1alpha_SessionStartDatabaseMetadata? = nil
  fileprivate var _desktop: Prehog_V1alpha_SessionStartDesktopMetadata? = nil
  fileprivate var _app: Prehog_V1alpha_SessionStartAppMetadata? = nil
  fileprivate var _git: Prehog_V1alpha_SessionStartGitMetadata? = nil
}

/// SessionStartDatabaseMetadata contains additional information about database session.
public struct Prehog_V1alpha_SessionStartDatabaseMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// database type.
  public var dbType: String = String()

  /// database protocol.
  public var dbProtocol: String = String()

  /// database origin source.
  public var dbOrigin: String = String()

  /// Indicates the client used on the session.
  public var userAgent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SessionStartDesktop Metadata contains additional information about
/// a desktop session.
public struct Prehog_V1alpha_SessionStartDesktopMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// desktop type ("ad" or "non-ad")
  public var desktopType: String = String()

  /// Indicates how the desktop was enrolled in Teleport
  /// ("config-file" for statically defined hosts, or "dynamic" for
  /// hosts discovered via LDAP).
  public var origin: String = String()

  /// If desktop type is "ad" this field contains the anonymized Active
  /// Directory domain that the desktop belongs to.
  public var windowsDomain: String = String()

  /// If true, and desktop type is "non-ad" automatic user creation is
  /// enabled for the session. (This does not mean that the user will
  /// be created, as Teleport does not know whether the user already exists.)
  public var allowUserCreation: Bool = false

  /// Indicates whether network level authentication (NLA) was used to
  /// establish this RDP session.
  public var nla: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SessionStartAppMetadata contains additional information about an app session.
public struct Prehog_V1alpha_SessionStartAppMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// is_multi_port is true for multi-port TCP apps.
  public var isMultiPort: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SessionStartGitMetadata contains additional information about a git session.
public struct Prehog_V1alpha_SessionStartGitMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// git session type (equivalent to git_server.sub_kind).
  public var gitType: String = String()

  /// git_service is the type of the git request like git-upload-pack or
  /// git-receive-pack.
  public var gitService: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// the issuance of a user certificate from the user CA
///
/// PostHog event: tp.certificate.issued
public struct Prehog_V1alpha_UserCertificateIssuedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64; it
  /// can be the username of a bot user rather than of a regular user
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// the TTL of the issued certificate, typically 8 or 12 hours
  ///
  /// PostHog property: tp.ttl_minutes (in minutes, rounded up)
  public var ttl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_ttl = newValue}
  }
  /// Returns true if `ttl` has been explicitly set.
  public var hasTtl: Bool {return self._ttl != nil}
  /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
  public mutating func clearTtl() {self._ttl = nil}

  /// If true, the certificate was requested by a bot (i.e. Machine ID) user.
  /// PostHog property: tp.is_bot
  public var isBot: Bool = false

  /// If true, the certificate usage is restricted to database access.
  /// PostHog property: tp.usage_database
  public var usageDatabase: Bool = false

  /// If true, the certificate usage is restricted to app access.
  /// PostHog property: tp.usage_app
  public var usageApp: Bool = false

  /// If true, the certificate usage is restricted to Kubernetes access.
  /// PostHog property: tp.usage_kubernetes
  public var usageKubernetes: Bool = false

  /// If true, the certificate usage is restricted to desktop access.
  /// PostHog property: tp.usage_desktop
  public var usageDesktop: Bool = false

  /// the private key policy associated with these user certificates.
  public var privateKeyPolicy: String = String()

  /// bot_instance_id is the anonymized instance id of the bot, if the user is
  /// a Bot.
  public var botInstanceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// the issuance of a SPIFFE SVID
///
/// PostHog event: tp.spiffe.svid.issued
public struct Prehog_V1alpha_SPIFFESVIDIssuedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64; it
  /// can be the username of a bot user rather than of a regular user
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// Indicates this event was generated by a Machine ID bot user.
  /// PostHog property: tp.user_kind
  public var userKind: Prehog_V1alpha_UserKind = .unspecified

  /// anonymized SPIFFE ID, 32 bytes (HMAC-SHA-256) encoded in base64;
  ///
  /// PostHog property: tp.spiffe.id
  public var spiffeID: String = String()

  /// Number of IP SANs included in the SVID
  /// PostHog property: tp.spiffe.ip_sans_count
  public var ipSansCount: Int32 = 0

  /// Number of DNS SANs included in the SVID
  /// PostHog property: tp.spiffe.dns_sans_count
  public var dnsSansCount: Int32 = 0

  /// Type of SVID issued. `x509` or `jwt`
  /// PostHog property: tp.spiffe.svid_type
  public var svidType: String = String()

  /// bot_instance_id is the anonymized instance id of the bot, if the user is
  /// a Bot.
  public var botInstanceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIBannerClickEvent is a usage event sent by the UI when the upgrade
/// banner is clicked.
public struct Prehog_V1alpha_UIBannerClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  /// cluster alert name
  public var alert: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIOnboardCompleteGoToDashboardClickEvent is a UI event sent when initial
/// registration is complete.
public struct Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIOnboardAddFirstResourceClickEvent is a UI event sent when a user clicks the
/// "add first resource" button.
public struct Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIOnboardAddFirstResourceLaterClickEvent is a UI event sent when a user
/// clicks the "add first resource later" button.
public struct Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIOnboardSetCredentialSubmitEvent is a UI event sent during registration when
/// users configure their credentials.
public struct Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIOnboardRegisterChallengeSubmitEvent is a UI event sent during registration
/// when the MFA challenge is completed.
public struct Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var mfaType: String = String()

  public var loginFlow: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIOnboardQuestionnaireSubmitEvent is a UI event sent during registration when
/// user submits their onboarding questionnaire.
public struct Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIRecoveryCodesContinueClickEvent is a UI event sent during
/// registration when the user configures cluster recovery codes.
public struct Prehog_V1alpha_UIRecoveryCodesContinueClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIRecoveryCodesCopyClickEvent is a UI event sent during
/// registration when the user copies recovery codes.
public struct Prehog_V1alpha_UIRecoveryCodesCopyClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIRecoveryCodesPrintClickEvent is a UI event sent during
/// registration when the user prints recovery codes.
public struct Prehog_V1alpha_UIRecoveryCodesPrintClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DiscoverMetadata contains common metadata for Discover related events.
public struct Prehog_V1alpha_DiscoverMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Uniquely identifies Discover wizard "session". Will allow to correlate
  /// events within the same Discover wizard run.
  public var id: String = String()

  /// anonymized
  public var userName: String = String()

  /// SSO indicates whether the user is from an SSO provider.
  public var sso: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DiscoverResourceMetadata contains common metadata identifying resource type being added.
public struct Prehog_V1alpha_DiscoverResourceMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource type that is being added.
  public var resource: Prehog_V1alpha_DiscoverResource = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DiscoverStepStatus contains fields that track a particular step outcome,
/// for example connection test failed or succeeded, or user aborted the step.
public struct Prehog_V1alpha_DiscoverStepStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates the step outcome.
  public var status: Prehog_V1alpha_DiscoverStatus = .unspecified

  /// Contains error details in case of Error Status.
  /// We have to be careful to not include any identifyable infomation like server addresses here.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIDiscoverStartedEvent is emitted when the wizard opens.
public struct Prehog_V1alpha_UIDiscoverStartedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverResourceSelectionEvent is emitted when user selected resource type to add
/// and proceeded to the next step.
public struct Prehog_V1alpha_UIDiscoverResourceSelectionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverIntegrationAWSOIDCConnectEvent is emitted when a user is finished with the step
/// that asks user to setup aws integration or select from a list of existing
/// aws integrations.
public struct Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDatabaseRDSEnrollEvent is emitted when a user is finished with
/// the step that asks user to select from a list of RDS databases.
public struct Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var selectedResourcesCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverKubeEKSEnrollEvent is emitted when a user is finished with
/// the step that asks user to select from a list of EKS clusters.
public struct Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDeployServiceEvent is emitted after the user installs a Teleport Agent.
/// For SSH this is the Teleport 'install-node' script.
///
/// For Kubernetes this is the teleport-agent helm chart installation.
///
/// For Database Access this step is the installation of the teleport 'install-db' script.
/// It can be skipped if the cluster already has a Database Service capable of proxying the database.
public struct Prehog_V1alpha_UIDiscoverDeployServiceEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var deployMethod: Prehog_V1alpha_UIDiscoverDeployServiceEvent.DeployMethod = .unspecified

  public var deployType: Prehog_V1alpha_UIDiscoverDeployServiceEvent.DeployType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// DeployMethod describes the method used to deploy a service.
  public enum DeployMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// DEPLOY_METHOD_UNSPECIFIED means there was an existing service
    /// so deploying step got skipped.
    case unspecified // = 0

    /// DEPLOY_METHOD_AUTO means Teleport deployed a service for the user.
    case auto // = 1

    /// DEPLOY_METHOD_MANUAL means a user deployed a service by themselves.
    case manual // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .auto
      case 2: self = .manual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .auto: return 1
      case .manual: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Prehog_V1alpha_UIDiscoverDeployServiceEvent.DeployMethod] = [
      .unspecified,
      .auto,
      .manual,
    ]

  }

  /// DeployType describes the type of deployment.
  public enum DeployType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// DEPLOY_METHOD_UNSPECIFIED means there was an existing service
    /// so deploying step got skipped.
    case unspecified // = 0

    /// DEPLOY_TYPE_INSTALL_SCRIPT means service was deployed using an
    /// install script.
    case installScript // = 1

    /// DEPLOY_TYPE_AMAZON_ECS means service was deployed using amazon's
    /// elastic container service.
    case amazonEcs // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .installScript
      case 2: self = .amazonEcs
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .installScript: return 1
      case .amazonEcs: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Prehog_V1alpha_UIDiscoverDeployServiceEvent.DeployType] = [
      .unspecified,
      .installScript,
      .amazonEcs,
    ]

  }

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverCreateDiscoveryConfigEvent is emitted when a discovery config is successfully created.
public struct Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var configMethod: Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent.ConfigMethod = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// ConfigMethod describes how the discovery config is configured.
  public enum ConfigMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// CONFIG_METHOD_UNSPECIFIED means config method unspecified/unset.
    case unspecified // = 0

    /// CONFIG_METHOD_SSM means EC2 auto discovery configured with ssm.
    case awsEc2Ssm // = 1

    /// CONFIG_METHOD_SSM means auto discovery configured for EC2 using EICE.
    case awsEc2Eice // = 2

    /// CONFIG_METHOD_SSM means auto discovery configured for RDS using ECS.
    case awsRdsEcs // = 3

    /// CONFIG_METHOD_SSM means auto discovery configured for EKS.
    case awsEks // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .awsEc2Ssm
      case 2: self = .awsEc2Eice
      case 3: self = .awsRdsEcs
      case 4: self = .awsEks
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .awsEc2Ssm: return 1
      case .awsEc2Eice: return 2
      case .awsRdsEcs: return 3
      case .awsEks: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent.ConfigMethod] = [
      .unspecified,
      .awsEc2Ssm,
      .awsEc2Eice,
      .awsRdsEcs,
      .awsEks,
    ]

  }

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDatabaseRegisterEvent is emitted when a user is finished with the step that registers a database resource.
public struct Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDatabaseConfigureMTLSEvent is emitted when a user is finished with the step that configures mutual TLS for a self-hosted database.
public struct Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDesktopActiveDirectoryToolsInstallEvent is emitted when the user is finished with the step that asks user to run the install Active Directory tools script for the Desktop flow.
public struct Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDesktopActiveDirectoryConfigureEvent is emitted when the user is finished with the step that asks user to run the Configure Active Directory script for the Desktop flow.
public struct Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverAutoDiscoveredResourcesEvent is emitted when the user is finished with the step that auto discovers resources (waiting until resources show up).
/// resources_count field must reflect the latest amount of discovered resources (get the number after user is finished with this step).
public struct Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var resourcesCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverEC2InstanceSelectionEvent is emitted when the user is finished with the step that asks the user to select an EC2 Instance to enroll.
public struct Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDeployEICEEvent is emitted when the user deploys an EC2 Instance Connect Endpoint.
public struct Prehog_V1alpha_UIDiscoverDeployEICEEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverCreateNodeEvent is emitted when the node is created in Teleport.
public struct Prehog_V1alpha_UIDiscoverCreateNodeEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverCreateAppServerEvent is emitted when an app server is created.
public struct Prehog_V1alpha_UIDiscoverCreateAppServerEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverDatabaseConfigureIAMPolicyEvent is emitted when a user is finished with the step that configures IAM policy for an RDS database.
public struct Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverPrincipalsConfigureEvent is emitted when a user is finished with the step that allows user to update their principals (setting up access).
public struct Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverTestConnectionEvent emitted on the "Test Connection" screen
/// when the user clicked tested connection to their resource.
public struct Prehog_V1alpha_UIDiscoverTestConnectionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// UIDiscoverCompletedEvent is emitted when user completes the Discover wizard.
public struct Prehog_V1alpha_UIDiscoverCompletedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_DiscoverMetadata {
    get {return _metadata ?? Prehog_V1alpha_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var resource: Prehog_V1alpha_DiscoverResourceMetadata {
    get {return _resource ?? Prehog_V1alpha_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var status: Prehog_V1alpha_DiscoverStepStatus {
    get {return _status ?? Prehog_V1alpha_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_DiscoverMetadata? = nil
  fileprivate var _resource: Prehog_V1alpha_DiscoverResourceMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_DiscoverStepStatus? = nil
}

/// RoleCreateEvent is emitted when user creates a custom role.
public struct Prehog_V1alpha_RoleCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  /// anonymized
  public var roleName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BotCreateEvent is emitted when user creates a bot.
public struct Prehog_V1alpha_BotCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is the anonymized name of the user who created the bot
  public var userName: String = String()

  /// anonymized
  public var botUserName: String = String()

  /// role_name is the anonymized name of the bot role that was created.
  public var roleName: String = String()

  /// role_count is the number of roles that the bot role can impersonate on
  /// creation.
  public var roleCount: Int64 = 0

  /// join_method is the join method of the token associated with the bot on
  /// creation.
  public var joinMethod: String = String()

  /// bot_name is the anonymised name of the bot.
  public var botName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BotJoinEvent is emitted when a bot joins a Teleport cluster.
public struct Prehog_V1alpha_BotJoinEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// bot_name is the anonymised name of the bot.
  public var botName: String = String()

  /// join_method is the join method of the token associated with the bot on
  /// creation. This will be the string value of `api/types.JoinMethod`.
  public var joinMethod: String = String()

  /// join_token_name is the anonymised name of the token used to join
  /// the cluster.
  public var joinTokenName: String = String()

  /// user_name is the anonymised name of the Bot user.
  public var userName: String = String()

  /// bot_instance_id is the anonymized instance id of the bot.
  public var botInstanceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UICreateNewRoleClickEvent is an event that can be triggered during custom role creation
public struct Prehog_V1alpha_UICreateNewRoleClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UICreateNewRoleSaveClickEvent is an event that can be triggered during custom role creation
public struct Prehog_V1alpha_UICreateNewRoleSaveClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UICreateNewRoleCancelClickEvent is an event that can be triggered during custom role creation
public struct Prehog_V1alpha_UICreateNewRoleCancelClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UICreateNewRoleViewDocumentationClickEvent is an event that can be triggered during custom role creation
public struct Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UICallToActionClickEvent is a click in a Teleport Web UI's CTA
public struct Prehog_V1alpha_UICallToActionClickEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///anonymized
  public var userName: String = String()

  public var cta: Prehog_V1alpha_CTA = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// a request forwarded to a kube cluster's API server (other than exec and
/// port-forward)
///
/// PostHog event: tp.kube.request
public struct Prehog_V1alpha_KubeRequestEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// Indicates the kind of user (e.g. bot or human), if known.
  public var userKind: Prehog_V1alpha_UserKind = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// an sftp event, represents a single operation on a file
///
/// PostHog event: tp.sftp
public struct Prehog_V1alpha_SFTPEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// matching SFTPAction in teleport/api/types/events/events.proto
  public var action: Int32 = 0

  /// Indicates the kind of user (bot or human), if known.
  public var userKind: Prehog_V1alpha_UserKind = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_AgentMetadataEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var hostID: String = String()

  public var services: [String] = []

  public var os: String = String()

  public var osVersion: String = String()

  public var hostArchitecture: String = String()

  public var glibcVersion: String = String()

  public var installMethods: [String] = []

  public var containerRuntime: String = String()

  public var containerOrchestrator: String = String()

  public var cloudEnvironment: String = String()

  /// external_upgrader is the name of the registered external upgrader. if non-empty, this field indicates
  /// that the associated agent is enrolled in automatic upgrades.
  public var externalUpgrader: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AssistCompletionEvent is an event that is emitted
/// when a single completion occurs in the Teleport Assist,
/// i.e. a user submits a prompt, and receives an answer from the Assist
public struct Prehog_V1alpha_AssistCompletionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  /// ConversationId is the UUID that identifies a single Assist conversation
  public var conversationID: String = String()

  /// TotalTokens is the total amount of token used to satisfy this request
  public var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt
  public var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the completion response consists of
  public var completionTokens: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AssistExecutionEvent is an event that is emitted when an Assist command
/// execution is triggered by the user.
public struct Prehog_V1alpha_AssistExecutionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserName is anonymized user name
  public var userName: String = String()

  /// ConversationId is the UUID that identifies a single Assist conversation
  public var conversationID: String = String()

  /// NodeCount is the number of nodes the command was executed on
  public var nodeCount: Int64 = 0

  /// TotalTokens is the total amount of token used to generate the command summary
  public var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt to generate the command summary
  public var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the summary completion response consists of
  public var completionTokens: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AssistNewConversationEvent is an event that is emitted for each new Assist
/// conversation and contains the conversation category.
public struct Prehog_V1alpha_AssistNewConversationEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserName is anonymized user name
  public var userName: String = String()

  /// Category is the conversation category. This represents what kind of request
  /// the user is asking Assist.
  public var category: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AssistAccessRequest is an event that is emitted when a user requests access
/// to a resource via Assist.
public struct Prehog_V1alpha_AssistAccessRequestEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserName is anonymized user name
  public var userName: String = String()

  /// ResourceType describes the type of resource the user is requesting access to, e.g. "node", "db", "k8s" or "role".
  public var resourceType: String = String()

  /// TotalTokens is the total amount of token used to generate the command summary
  public var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt to generate the command summary
  public var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the summary completion response consists of
  public var completionTokens: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AssistAction is an event that is emitted when a user triggers an action (SSH command generation, output explain, etc.)
/// via Assist.
public struct Prehog_V1alpha_AssistActionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserName is anonymized user name
  public var userName: String = String()

  /// Action is the action that was triggered, e.g. "ssh-explain", "ssh-command-generate", etc.
  public var action: String = String()

  /// TotalTokens is the total amount of token used to generate the command summary
  public var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt to generate the command summary
  public var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the summary completion response consists of
  public var completionTokens: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessListMetadata contains common metadata for Access List related events.
public struct Prehog_V1alpha_AccessListMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id uniquely identifies an Access List. Will allow correlation of events within an access list.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessListCreate is an event that is emitted when an access list is created.
public struct Prehog_V1alpha_AccessListCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is the anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListUpdate is an event that is emitted when an access list is updated.
public struct Prehog_V1alpha_AccessListUpdateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is the anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListDelete is an event that is emitted when an access list is deleted.
public struct Prehog_V1alpha_AccessListDeleteEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is the anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListMemberCreate is an event that is emitted when a member is added to an access list.
public struct Prehog_V1alpha_AccessListMemberCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is the anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// member_kind is the type of membership of the created member in the parent access list.
  public var memberKind: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListMemberUpdate is an event that is emitted when a member is updated in an access list.
public struct Prehog_V1alpha_AccessListMemberUpdateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is the anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// membership_kind is the type of membership of the updated member in the parent access list.
  public var memberKind: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListMemberDelete is an event that is emitted when a member is removed from an access list.
public struct Prehog_V1alpha_AccessListMemberDeleteEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// member_kind is the type of membership of the deleted user in the parent access list.
  public var memberKind: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListGrantsToUser is an event that is emitted when access list permissions are granted to a user
/// on login.
public struct Prehog_V1alpha_AccessListGrantsToUserEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is the anonymized user name
  public var userName: String = String()

  /// count_roles_granted is the number of roles granted to a user.
  public var countRolesGranted: Int32 = 0

  /// count_traits_granted is the number of traits granted to a user.
  public var countTraitsGranted: Int32 = 0

  /// count_inherited_roles_granted is the number of roles granted to a user inherited from nested access lists.
  public var countInheritedRolesGranted: Int32 = 0

  /// count_inherited_traits_granted is the number of traits granted to a user inherited from nested access lists.
  public var countInheritedTraitsGranted: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessListReviewCreateEvent is an event that is emitted when an access list review is created.
public struct Prehog_V1alpha_AccessListReviewCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// days_past_next_audit_date is how many days past the next audit date the review came in. Can be negative.
  public var daysPastNextAuditDate: Int32 = 0

  /// membership_requirements_changed indicates that the membership requirements were changed.
  public var membershipRequirementsChanged: Bool = false

  /// review_frequency_changed indicates that the review frequency was changed.
  public var reviewFrequencyChanged: Bool = false

  /// review_day_of_month_changed indicates that the review day of month was changed.
  public var reviewDayOfMonthChanged: Bool = false

  /// number_of_removed_members is how many members were removed as part of this review.
  public var numberOfRemovedMembers: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListReviewDeleteEvent is an event that is emitted when an access list review is deleted.
public struct Prehog_V1alpha_AccessListReviewDeleteEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_name is anonymized user name
  public var userName: String = String()

  public var metadata: Prehog_V1alpha_AccessListMetadata {
    get {return _metadata ?? Prehog_V1alpha_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// access_list_review_id is the unique identifier for the access list review.
  public var accessListReviewID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_AccessListMetadata? = nil
}

/// AccessListReviewComplianceEvent is an event that is emitted periodically to indicate how many access
/// lists are past due for a review.
public struct Prehog_V1alpha_AccessListReviewComplianceEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_access_lists is the total number of access lists known to Teleport.
  public var totalAccessLists: Int32 = 0

  /// access_lists_need_review is the number of access lists that need a review.
  public var accessListsNeedReview: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IntegrationEnrollMetadata contains common metadata
/// for Integration Enroll related events.
public struct Prehog_V1alpha_IntegrationEnrollMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is used as a unique identifier to correlate events within the
  /// same enroll wizard run.
  public var id: String = String()

  /// kind identifies what type of integration the user clicked on to enroll.
  public var kind: Prehog_V1alpha_IntegrationEnrollKind = .unspecified

  /// user_name is anonymized.
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIIntegrationEnrollEvent is an event that is emitted when a user
/// clicks on a integration to enroll.
public struct Prehog_V1alpha_UIIntegrationEnrollStartEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_IntegrationEnrollMetadata {
    get {return _metadata ?? Prehog_V1alpha_IntegrationEnrollMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_IntegrationEnrollMetadata? = nil
}

/// UIIntegrationEnrollEvent is an event that is emitted when a user
/// completed enrolling an integration.
public struct Prehog_V1alpha_UIIntegrationEnrollCompleteEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Prehog_V1alpha_IntegrationEnrollMetadata {
    get {return _metadata ?? Prehog_V1alpha_IntegrationEnrollMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_IntegrationEnrollMetadata? = nil
}

/// IntegrationEnrollStepStatus defines fields that track a particular step outcome,
/// for example connection test failed or succeeded, or user aborted the step.
public struct Prehog_V1alpha_IntegrationEnrollStepStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Code indicates the step outcome.
  public var code: Prehog_V1alpha_IntegrationEnrollStatusCode = .unspecified

  /// Error contains error details in case of an error status code.
  /// Error message should not include any identifiable information
  /// like server address.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIIntegrationEnrollStepEvent defines configuration step event
/// with a status for a specific integration enroll kind.
public struct Prehog_V1alpha_UIIntegrationEnrollStepEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata is the metadata of an event.
  public var metadata: Prehog_V1alpha_IntegrationEnrollMetadata {
    get {return _metadata ?? Prehog_V1alpha_IntegrationEnrollMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// Step is the name of the step for a given integration kind.
  public var step: Prehog_V1alpha_IntegrationEnrollStep = .unspecified

  /// Status is the status of the step outcome.
  public var status: Prehog_V1alpha_IntegrationEnrollStepStatus {
    get {return _status ?? Prehog_V1alpha_IntegrationEnrollStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadata: Prehog_V1alpha_IntegrationEnrollMetadata? = nil
  fileprivate var _status: Prehog_V1alpha_IntegrationEnrollStepStatus? = nil
}

/// EditorChangeEvent is an event that is emitted when a user role set changes resulting in
/// a editor role being added on removed
public struct Prehog_V1alpha_EditorChangeEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized user name
  public var userName: String = String()

  public var status: Prehog_V1alpha_EditorChangeStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device authentication event
public struct Prehog_V1alpha_DeviceAuthenticateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized device ID, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.device_id
  public var deviceID: String = String()

  /// anonymized username, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// device OS type
  ///
  /// PostHog property: tp.device_os_type
  public var deviceOsType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Device Enrollment event
///
/// PostHost event: tp.device.enroll
public struct Prehog_V1alpha_DeviceEnrollEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized device ID, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.device_id
  public var deviceID: String = String()

  /// anonymized username, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// device OS type
  ///
  /// PostHog property: tp.device_os_type
  public var deviceOsType: String = String()

  /// device origin
  ///
  /// PostHog property: tp.device_origin
  public var deviceOrigin: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// FeatureRecommendationEvent captures event emitted when a feature is recommended to user or
/// when user completes the desired CTA for the feature.
///
/// PostHost event: tp.ui.feature.recommendation
public struct Prehog_V1alpha_FeatureRecommendationEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64;
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// feature is name of the Teleport feature.
  ///
  /// PostHog property: tp.feature
  public var feature: Prehog_V1alpha_Feature = .unspecified

  /// feature_recommendation_status records recommendation state, which can be 'NOTIFIED' (feature is recommended)
  /// OR 'DONE' (user completes desired CTA)
  ///
  /// PostHost property: tp.feature_recommendation_status
  public var featureRecommendationStatus: Prehog_V1alpha_FeatureRecommendationStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LicenseLimitEvent is emitted when access to Teleport feature
/// is denied based on license limits
///
/// PostHost event: tp.license.limit
public struct Prehog_V1alpha_LicenseLimitEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PostHost property: tp.license_limit
  public var licenseLimit: Prehog_V1alpha_LicenseLimit = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DesktopDirectoryShareEvent is emitted when directory sharing is used
/// in a Teleport desktop session.
public struct Prehog_V1alpha_DesktopDirectoryShareEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized desktop addr, used to uniquely idenfity the desktop
  ///
  /// PostHog property: tp.desktop
  public var desktop: String = String()

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64;
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// anonymized directory name
  ///
  /// PostHog property: tp.directory_name
  public var directoryName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DesktopClipboardEvent is emitted when data is transferred between a user's
/// local clipboard and a remote Windows clipboard.
public struct Prehog_V1alpha_DesktopClipboardEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized desktop addr, used to uniquely idenfity the desktop
  ///
  /// PostHog property: tp.desktop
  public var desktop: String = String()

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64;
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TAGExecuteQueryEvent is an event that is emitted
/// when a single query is executed in the Teleport Access Graph.
/// This event is emitted for both successful and failed queries. For
/// successful queries, the total number of nodes and edges is reported.
public struct Prehog_V1alpha_TAGExecuteQueryEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  /// total_nodes is the total amount of nodes returned by the query.
  public var totalNodes: Int64 = 0

  /// total_edges is the total amount of edges returned by the query.
  public var totalEdges: Int64 = 0

  /// is_success is true if the query was successful and false it if failed.
  public var isSuccess: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessGraphSecretsScanAuthorizedKeysEvent is emitted when the Access Graph
/// SSH authorized keys scan is performed.
public struct Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var hostID: String = String()

  /// total_keys is the total amount of keys found in the authorized keys file.
  public var totalKeys: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessGraphSecretsScanSSHPrivateKeysEvent is emitted when the Access Graph
/// SSH private keys scan is performed.
public struct Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var deviceID: String = String()

  /// total_keys is the total amount of keys found in the private keys file.
  public var totalKeys: UInt64 = 0

  /// device OS type
  public var deviceOsType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessGraphGitlabScanEvent is emitted when the Access Graph
/// Gitlab scan is enabled.
public struct Prehog_V1alpha_AccessGraphGitlabScanEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_projects is the total amount of projects found in the Gitlab scan.
  public var totalProjects: UInt64 = 0

  /// total_users is the total amount of users found in the Gitlab scan.
  public var totalUsers: UInt64 = 0

  /// total_groups is the total amount of groups found in the Gitlab scan.
  public var totalGroups: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessGraphAWSScanEvent is emitted when the Access Graph
/// AWS scan is enabled.
public struct Prehog_V1alpha_AccessGraphAWSScanEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// total_ec2_instances is the total amount of EC2 instances found in the AWS scan.
  public var totalEc2Instances: UInt64 = 0

  /// total_users is the total amount of users found in the AWS scan.
  public var totalUsers: UInt64 = 0

  /// total_groups is the total amount of groups found in the AWS scan.
  public var totalGroups: UInt64 = 0

  /// total_roles is the total amount of roles found in the AWS scan.
  public var totalRoles: UInt64 = 0

  /// total_policies is the total amount of policies found in the AWS scan.
  public var totalPolicies: UInt64 = 0

  /// total_eks_clusters is the total amount of EKS clusters found in the AWS scan.
  public var totalEksClusters: UInt64 = 0

  /// total_rds_instances is the total amount of RDS instances found in the AWS scan.
  public var totalRdsInstances: UInt64 = 0

  /// total_s3_buckets is the total amount of S3 buckets found in the AWS scan.
  public var totalS3Buckets: UInt64 = 0

  /// total_saml_providers is the total amount of SAML providers found in the AWS scan.
  public var totalSamlProviders: UInt64 = 0

  /// total_oidc_providers is the total amount of OIDC providers found in the AWS scan.
  public var totalOidcProviders: UInt64 = 0

  /// total_accounts is the total amount of accounts synchronized in the AWS scan.
  public var totalAccounts: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessGraphAccessPathChangedEvent is emitted when the Crown Jewel functionality
/// is enabled and the Access Graph access path is changed.
public struct Prehog_V1alpha_AccessGraphAccessPathChangedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// affected_resource_source is the source of the affected resource.
  public var affectedResourceSource: String = String()

  /// affected_resource_type is the type of the affected resource.
  public var affectedResourceType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UIAccessGraphCrownJewelDiffViewEvent is emitted when a user reviews the output of a Crown Jewel access path dff.
public struct Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// affected_resource_source is the source of the affected resource.
  public var affectedResourceSource: String = String()

  /// affected_resource_type is the type of the affected resource.
  public var affectedResourceType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessGraphCrownJewelCreateEvent is emitted when a user creates an Access Graph's
/// Crown Jewel Resource.
public struct Prehog_V1alpha_AccessGraphCrownJewelCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ExternalAuditStorageAuthenticateEvent is emitted when the External Audit
/// Storage feature authenticates to the customer AWS account via OIDC connector.
/// The purpose is to have a regularly emitted event indicating that the External
/// Audit Storage feature is still in use.
public struct Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SecurityReportGetResultEvent is emitted when the user requests a security report.
public struct Prehog_V1alpha_SecurityReportGetResultEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  /// name is the name of the security report.
  public var name: String = String()

  /// days is the time range of the security reports in days.
  public var days: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AuditQueryRunEvent is emitted when the user runs an audit query.
public struct Prehog_V1alpha_AuditQueryRunEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var userName: String = String()

  /// days is the time range of the query in days.
  public var days: Int32 = 0

  /// is_success is true if the query was successful false if execution failed.
  public var isSuccess: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DiscoveryFetchEvent is emitted when a DiscoveryService polls for new resources of a given type
public struct Prehog_V1alpha_DiscoveryFetchEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cloud_provider is the cloud provider used to fetch resources
  /// Eg, AWS, Azure, GCP, Kubernetes
  ///
  /// PostHog property: tp.cloud
  public var cloudProvider: String = String()

  /// resource_type is the type of resource that this fetch is polling.
  /// It depends on the Cloud Provider (defined above).
  /// Eg, rds, ec2, vm, aks, gce, app
  ///
  /// PostHog property: tp.resource_type
  public var resourceType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// OktaAccessListSyncEvent is an event that is emitted after the Okta service synchronizes
/// access lists from Okta.
public struct Prehog_V1alpha_OktaAccessListSyncEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NumAppFilters is the number of application filters used for this sync.
  public var numAppFilters: Int32 = 0

  /// NumGroupFilters is the number of group filters used for this sync.
  public var numGroupFilters: Int32 = 0

  /// NumApps is the number of apps that were synchronized from this sync event.
  public var numApps: Int32 = 0

  /// NumGroups is the number of groups that were synchronized from this sync event.
  public var numGroups: Int32 = 0

  /// NumRoles are the number of roles that were created/updated.
  public var numRoles: Int32 = 0

  /// NumAccessLists are the number of access lists that were created/updated.
  public var numAccessLists: Int32 = 0

  /// NumAccessListMembers are the number of access list members that were created/updated.
  public var numAccessListMembers: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DatabaseUserCreatedEvent is an event that is emitted after database service performs automatic user provisioning.
public struct Prehog_V1alpha_DatabaseUserCreatedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Database metadata.
  public var database: Prehog_V1alpha_SessionStartDatabaseMetadata {
    get {return _database ?? Prehog_V1alpha_SessionStartDatabaseMetadata()}
    set {_database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  public var hasDatabase: Bool {return self._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  public mutating func clearDatabase() {self._database = nil}

  /// Teleport user name. Anonymized.
  public var userName: String = String()

  /// Number of database roles.
  public var numRoles: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _database: Prehog_V1alpha_SessionStartDatabaseMetadata? = nil
}

/// DatabaseUserPermissionsUpdateEvent is an event that is emitted after database service updates the permissions for the database user.
public struct Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Database metadata.
  public var database: Prehog_V1alpha_SessionStartDatabaseMetadata {
    get {return _database ?? Prehog_V1alpha_SessionStartDatabaseMetadata()}
    set {_database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  public var hasDatabase: Bool {return self._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  public mutating func clearDatabase() {self._database = nil}

  /// Teleport user name. Anonymized.
  public var userName: String = String()

  /// How many tables were affected.
  public var numTables: Int32 = 0

  /// How many total table permissions were given to the user.
  /// For example {SELECT,UPDATE} on ten tables gives a total of twenty.
  public var numTablesPermissions: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _database: Prehog_V1alpha_SessionStartDatabaseMetadata? = nil
}

/// SessionRecordingAccessEvent is emitted when the user accesses a session
/// recording.
///
/// PostHog event: tp.recording.access
public struct Prehog_V1alpha_SessionRecordingAccessEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session_type is type of the session, should be
  /// "ssh"/"k8s"/"db"/"app"/"desktop" (matching the values for
  /// api/types.SessionKind).
  ///
  /// PostHog property: tp.session_type
  public var sessionType: String = String()

  /// user_name is the anonymized Teleport username, 32 bytes (HMAC-SHA-256)
  /// encoded in base64.
  ///
  /// PostHog property: tp.user_name
  public var userName: String = String()

  /// format is the format the session recording was accessed.
  /// One of text/json/yaml/pty. pty being the interactive session player.
  ///
  /// PostHog property: tp.recording.format
  public var format: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UserTaskStateEvent is emitted when a UserTask state changes.
/// This can happen when the Task is created, when it's manually
/// resolved by the user or when it changes back to being open
/// when the issue happens again.
///
/// PostHog event: tp.usertask.state
public struct Prehog_V1alpha_UserTaskStateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// task_type is the identifier for the type of task.
  /// Eg, discover-ec2
  ///
  /// PostHog property: tp.usertask.task_type
  public var taskType: String = String()

  /// issue_type is the identifier for the type of issue that occurred.
  ///
  /// PostHog property: tp.usertask.issue_type
  public var issueType: String = String()

  /// state identifies the new state for this task.
  /// One of: OPEN, RESOLVED
  ///
  /// PostHog property: tp.usertask.state
  public var state: String = String()

  /// instances_count contains the number of instances that were affected by the issue
  /// This field is only present for the following task_types:
  /// - discover-ec2
  ///
  /// PostHog property: tp.usertask.discover_ec2.instances_count
  public var instancesCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AccessRequestEvent emitted for Access Request audit events.
public struct Prehog_V1alpha_AccessRequestEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Teleport user name. Anonymized.
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_SubmitEventRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized, 32 bytes (HMAC-SHA-256) encoded in base64
  ///
  /// PostHog property: tp.cluster_name (still in base64)
  public var clusterName: String {
    get {return _storage._clusterName}
    set {_uniqueStorage()._clusterName = newValue}
  }

  /// optional, will default to the ingest time if unset
  ///
  /// PostHog timestamp
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  /// teleport_version is the version of the Teleport auth server that submitted
  /// the event, without the "v" prefix.
  /// For example: 16.4.7
  ///
  /// PostHog property: tp.teleport_version
  public var teleportVersion: String {
    get {return _storage._teleportVersion}
    set {_uniqueStorage()._teleportVersion = newValue}
  }

  /// the event being submitted
  public var event: OneOf_Event? {
    get {return _storage._event}
    set {_uniqueStorage()._event = newValue}
  }

  public var userLogin: Prehog_V1alpha_UserLoginEvent {
    get {
      if case .userLogin(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UserLoginEvent()
    }
    set {_uniqueStorage()._event = .userLogin(newValue)}
  }

  public var ssoCreate: Prehog_V1alpha_SSOCreateEvent {
    get {
      if case .ssoCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_SSOCreateEvent()
    }
    set {_uniqueStorage()._event = .ssoCreate(newValue)}
  }

  public var resourceCreate: Prehog_V1alpha_ResourceCreateEvent {
    get {
      if case .resourceCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_ResourceCreateEvent()
    }
    set {_uniqueStorage()._event = .resourceCreate(newValue)}
  }

  /// REMOVE IN V14: Use session_start_v2 instead
  public var sessionStart: Prehog_V1alpha_SessionStartEvent {
    get {
      if case .sessionStart(let v)? = _storage._event {return v}
      return Prehog_V1alpha_SessionStartEvent()
    }
    set {_uniqueStorage()._event = .sessionStart(newValue)}
  }

  public var uiBannerClick: Prehog_V1alpha_UIBannerClickEvent {
    get {
      if case .uiBannerClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIBannerClickEvent()
    }
    set {_uniqueStorage()._event = .uiBannerClick(newValue)}
  }

  public var uiOnboardCompleteGoToDashboardClick: Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent {
    get {
      if case .uiOnboardCompleteGoToDashboardClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent()
    }
    set {_uniqueStorage()._event = .uiOnboardCompleteGoToDashboardClick(newValue)}
  }

  public var uiOnboardAddFirstResourceClick: Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent {
    get {
      if case .uiOnboardAddFirstResourceClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent()
    }
    set {_uniqueStorage()._event = .uiOnboardAddFirstResourceClick(newValue)}
  }

  public var uiOnboardAddFirstResourceLaterClick: Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent {
    get {
      if case .uiOnboardAddFirstResourceLaterClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent()
    }
    set {_uniqueStorage()._event = .uiOnboardAddFirstResourceLaterClick(newValue)}
  }

  public var uiOnboardSetCredentialSubmit: Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent {
    get {
      if case .uiOnboardSetCredentialSubmit(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent()
    }
    set {_uniqueStorage()._event = .uiOnboardSetCredentialSubmit(newValue)}
  }

  public var uiOnboardRegisterChallengeSubmit: Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent {
    get {
      if case .uiOnboardRegisterChallengeSubmit(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent()
    }
    set {_uniqueStorage()._event = .uiOnboardRegisterChallengeSubmit(newValue)}
  }

  public var uiRecoveryCodesContinueClick: Prehog_V1alpha_UIRecoveryCodesContinueClickEvent {
    get {
      if case .uiRecoveryCodesContinueClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIRecoveryCodesContinueClickEvent()
    }
    set {_uniqueStorage()._event = .uiRecoveryCodesContinueClick(newValue)}
  }

  public var uiRecoveryCodesCopyClick: Prehog_V1alpha_UIRecoveryCodesCopyClickEvent {
    get {
      if case .uiRecoveryCodesCopyClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIRecoveryCodesCopyClickEvent()
    }
    set {_uniqueStorage()._event = .uiRecoveryCodesCopyClick(newValue)}
  }

  public var uiRecoveryCodesPrintClick: Prehog_V1alpha_UIRecoveryCodesPrintClickEvent {
    get {
      if case .uiRecoveryCodesPrintClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIRecoveryCodesPrintClickEvent()
    }
    set {_uniqueStorage()._event = .uiRecoveryCodesPrintClick(newValue)}
  }

  public var uiDiscoverStartedEvent: Prehog_V1alpha_UIDiscoverStartedEvent {
    get {
      if case .uiDiscoverStartedEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverStartedEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverStartedEvent(newValue)}
  }

  public var uiDiscoverResourceSelectionEvent: Prehog_V1alpha_UIDiscoverResourceSelectionEvent {
    get {
      if case .uiDiscoverResourceSelectionEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverResourceSelectionEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverResourceSelectionEvent(newValue)}
  }

  public var userCertificateIssuedEvent: Prehog_V1alpha_UserCertificateIssuedEvent {
    get {
      if case .userCertificateIssuedEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UserCertificateIssuedEvent()
    }
    set {_uniqueStorage()._event = .userCertificateIssuedEvent(newValue)}
  }

  /// Note: semantics of SessionStartEvent type values have changed to
  /// differentiate SSH from Kubernetes exec sessions (as well as adding
  /// db/app/desktop events). The structures are the same, however, so we don't
  /// need a new message type.
  public var sessionStartV2: Prehog_V1alpha_SessionStartEvent {
    get {
      if case .sessionStartV2(let v)? = _storage._event {return v}
      return Prehog_V1alpha_SessionStartEvent()
    }
    set {_uniqueStorage()._event = .sessionStartV2(newValue)}
  }

  public var uiDiscoverDeployServiceEvent: Prehog_V1alpha_UIDiscoverDeployServiceEvent {
    get {
      if case .uiDiscoverDeployServiceEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDeployServiceEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDeployServiceEvent(newValue)}
  }

  public var uiDiscoverDatabaseRegisterEvent: Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent {
    get {
      if case .uiDiscoverDatabaseRegisterEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDatabaseRegisterEvent(newValue)}
  }

  public var uiDiscoverDatabaseConfigureMtlsEvent: Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent {
    get {
      if case .uiDiscoverDatabaseConfigureMtlsEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDatabaseConfigureMtlsEvent(newValue)}
  }

  public var uiDiscoverDesktopActiveDirectoryToolsInstallEvent: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent {
    get {
      if case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(newValue)}
  }

  public var uiDiscoverDesktopActiveDirectoryConfigureEvent: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent {
    get {
      if case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDesktopActiveDirectoryConfigureEvent(newValue)}
  }

  public var uiDiscoverAutoDiscoveredResourcesEvent: Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent {
    get {
      if case .uiDiscoverAutoDiscoveredResourcesEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverAutoDiscoveredResourcesEvent(newValue)}
  }

  public var uiDiscoverDatabaseConfigureIamPolicyEvent: Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent {
    get {
      if case .uiDiscoverDatabaseConfigureIamPolicyEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDatabaseConfigureIamPolicyEvent(newValue)}
  }

  public var uiDiscoverPrincipalsConfigureEvent: Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent {
    get {
      if case .uiDiscoverPrincipalsConfigureEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverPrincipalsConfigureEvent(newValue)}
  }

  public var uiDiscoverTestConnectionEvent: Prehog_V1alpha_UIDiscoverTestConnectionEvent {
    get {
      if case .uiDiscoverTestConnectionEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverTestConnectionEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverTestConnectionEvent(newValue)}
  }

  public var uiDiscoverCompletedEvent: Prehog_V1alpha_UIDiscoverCompletedEvent {
    get {
      if case .uiDiscoverCompletedEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverCompletedEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverCompletedEvent(newValue)}
  }

  public var roleCreate: Prehog_V1alpha_RoleCreateEvent {
    get {
      if case .roleCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_RoleCreateEvent()
    }
    set {_uniqueStorage()._event = .roleCreate(newValue)}
  }

  public var uiCreateNewRoleClick: Prehog_V1alpha_UICreateNewRoleClickEvent {
    get {
      if case .uiCreateNewRoleClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UICreateNewRoleClickEvent()
    }
    set {_uniqueStorage()._event = .uiCreateNewRoleClick(newValue)}
  }

  public var uiCreateNewRoleSaveClick: Prehog_V1alpha_UICreateNewRoleSaveClickEvent {
    get {
      if case .uiCreateNewRoleSaveClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UICreateNewRoleSaveClickEvent()
    }
    set {_uniqueStorage()._event = .uiCreateNewRoleSaveClick(newValue)}
  }

  public var uiCreateNewRoleCancelClick: Prehog_V1alpha_UICreateNewRoleCancelClickEvent {
    get {
      if case .uiCreateNewRoleCancelClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UICreateNewRoleCancelClickEvent()
    }
    set {_uniqueStorage()._event = .uiCreateNewRoleCancelClick(newValue)}
  }

  public var uiCreateNewRoleViewDocumentationClick: Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent {
    get {
      if case .uiCreateNewRoleViewDocumentationClick(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent()
    }
    set {_uniqueStorage()._event = .uiCreateNewRoleViewDocumentationClick(newValue)}
  }

  public var kubeRequest: Prehog_V1alpha_KubeRequestEvent {
    get {
      if case .kubeRequest(let v)? = _storage._event {return v}
      return Prehog_V1alpha_KubeRequestEvent()
    }
    set {_uniqueStorage()._event = .kubeRequest(newValue)}
  }

  public var sftp: Prehog_V1alpha_SFTPEvent {
    get {
      if case .sftp(let v)? = _storage._event {return v}
      return Prehog_V1alpha_SFTPEvent()
    }
    set {_uniqueStorage()._event = .sftp(newValue)}
  }

  public var agentMetadataEvent: Prehog_V1alpha_AgentMetadataEvent {
    get {
      if case .agentMetadataEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AgentMetadataEvent()
    }
    set {_uniqueStorage()._event = .agentMetadataEvent(newValue)}
  }

  public var resourceHeartbeat: Prehog_V1alpha_ResourceHeartbeatEvent {
    get {
      if case .resourceHeartbeat(let v)? = _storage._event {return v}
      return Prehog_V1alpha_ResourceHeartbeatEvent()
    }
    set {_uniqueStorage()._event = .resourceHeartbeat(newValue)}
  }

  public var uiDiscoverIntegrationAwsOidcConnectEvent: Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent {
    get {
      if case .uiDiscoverIntegrationAwsOidcConnectEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverIntegrationAwsOidcConnectEvent(newValue)}
  }

  public var uiDiscoverDatabaseRdsEnrollEvent: Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent {
    get {
      if case .uiDiscoverDatabaseRdsEnrollEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDatabaseRdsEnrollEvent(newValue)}
  }

  public var uiCallToActionClickEvent: Prehog_V1alpha_UICallToActionClickEvent {
    get {
      if case .uiCallToActionClickEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UICallToActionClickEvent()
    }
    set {_uniqueStorage()._event = .uiCallToActionClickEvent(newValue)}
  }

  public var assistCompletion: Prehog_V1alpha_AssistCompletionEvent {
    get {
      if case .assistCompletion(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AssistCompletionEvent()
    }
    set {_uniqueStorage()._event = .assistCompletion(newValue)}
  }

  public var uiIntegrationEnrollStartEvent: Prehog_V1alpha_UIIntegrationEnrollStartEvent {
    get {
      if case .uiIntegrationEnrollStartEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIIntegrationEnrollStartEvent()
    }
    set {_uniqueStorage()._event = .uiIntegrationEnrollStartEvent(newValue)}
  }

  public var uiIntegrationEnrollCompleteEvent: Prehog_V1alpha_UIIntegrationEnrollCompleteEvent {
    get {
      if case .uiIntegrationEnrollCompleteEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIIntegrationEnrollCompleteEvent()
    }
    set {_uniqueStorage()._event = .uiIntegrationEnrollCompleteEvent(newValue)}
  }

  public var editorChangeEvent: Prehog_V1alpha_EditorChangeEvent {
    get {
      if case .editorChangeEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_EditorChangeEvent()
    }
    set {_uniqueStorage()._event = .editorChangeEvent(newValue)}
  }

  public var botCreate: Prehog_V1alpha_BotCreateEvent {
    get {
      if case .botCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_BotCreateEvent()
    }
    set {_uniqueStorage()._event = .botCreate(newValue)}
  }

  public var uiOnboardQuestionnaireSubmit: Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent {
    get {
      if case .uiOnboardQuestionnaireSubmit(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent()
    }
    set {_uniqueStorage()._event = .uiOnboardQuestionnaireSubmit(newValue)}
  }

  public var botJoin: Prehog_V1alpha_BotJoinEvent {
    get {
      if case .botJoin(let v)? = _storage._event {return v}
      return Prehog_V1alpha_BotJoinEvent()
    }
    set {_uniqueStorage()._event = .botJoin(newValue)}
  }

  public var assistExecution: Prehog_V1alpha_AssistExecutionEvent {
    get {
      if case .assistExecution(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AssistExecutionEvent()
    }
    set {_uniqueStorage()._event = .assistExecution(newValue)}
  }

  public var assistNewConversation: Prehog_V1alpha_AssistNewConversationEvent {
    get {
      if case .assistNewConversation(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AssistNewConversationEvent()
    }
    set {_uniqueStorage()._event = .assistNewConversation(newValue)}
  }

  public var deviceAuthenticateEvent: Prehog_V1alpha_DeviceAuthenticateEvent {
    get {
      if case .deviceAuthenticateEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_DeviceAuthenticateEvent()
    }
    set {_uniqueStorage()._event = .deviceAuthenticateEvent(newValue)}
  }

  public var featureRecommendationEvent: Prehog_V1alpha_FeatureRecommendationEvent {
    get {
      if case .featureRecommendationEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_FeatureRecommendationEvent()
    }
    set {_uniqueStorage()._event = .featureRecommendationEvent(newValue)}
  }

  public var assistAccessRequest: Prehog_V1alpha_AssistAccessRequestEvent {
    get {
      if case .assistAccessRequest(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AssistAccessRequestEvent()
    }
    set {_uniqueStorage()._event = .assistAccessRequest(newValue)}
  }

  public var assistAction: Prehog_V1alpha_AssistActionEvent {
    get {
      if case .assistAction(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AssistActionEvent()
    }
    set {_uniqueStorage()._event = .assistAction(newValue)}
  }

  public var deviceEnrollEvent: Prehog_V1alpha_DeviceEnrollEvent {
    get {
      if case .deviceEnrollEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_DeviceEnrollEvent()
    }
    set {_uniqueStorage()._event = .deviceEnrollEvent(newValue)}
  }

  public var licenseLimitEvent: Prehog_V1alpha_LicenseLimitEvent {
    get {
      if case .licenseLimitEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_LicenseLimitEvent()
    }
    set {_uniqueStorage()._event = .licenseLimitEvent(newValue)}
  }

  public var accessListCreate: Prehog_V1alpha_AccessListCreateEvent {
    get {
      if case .accessListCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListCreateEvent()
    }
    set {_uniqueStorage()._event = .accessListCreate(newValue)}
  }

  public var accessListUpdate: Prehog_V1alpha_AccessListUpdateEvent {
    get {
      if case .accessListUpdate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListUpdateEvent()
    }
    set {_uniqueStorage()._event = .accessListUpdate(newValue)}
  }

  public var accessListDelete: Prehog_V1alpha_AccessListDeleteEvent {
    get {
      if case .accessListDelete(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListDeleteEvent()
    }
    set {_uniqueStorage()._event = .accessListDelete(newValue)}
  }

  public var accessListMemberCreate: Prehog_V1alpha_AccessListMemberCreateEvent {
    get {
      if case .accessListMemberCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListMemberCreateEvent()
    }
    set {_uniqueStorage()._event = .accessListMemberCreate(newValue)}
  }

  public var accessListMemberUpdate: Prehog_V1alpha_AccessListMemberUpdateEvent {
    get {
      if case .accessListMemberUpdate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListMemberUpdateEvent()
    }
    set {_uniqueStorage()._event = .accessListMemberUpdate(newValue)}
  }

  public var accessListMemberDelete: Prehog_V1alpha_AccessListMemberDeleteEvent {
    get {
      if case .accessListMemberDelete(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListMemberDeleteEvent()
    }
    set {_uniqueStorage()._event = .accessListMemberDelete(newValue)}
  }

  public var accessListGrantsToUser: Prehog_V1alpha_AccessListGrantsToUserEvent {
    get {
      if case .accessListGrantsToUser(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListGrantsToUserEvent()
    }
    set {_uniqueStorage()._event = .accessListGrantsToUser(newValue)}
  }

  public var uiDiscoverEc2InstanceSelection: Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent {
    get {
      if case .uiDiscoverEc2InstanceSelection(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverEc2InstanceSelection(newValue)}
  }

  public var uiDiscoverDeployEice: Prehog_V1alpha_UIDiscoverDeployEICEEvent {
    get {
      if case .uiDiscoverDeployEice(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverDeployEICEEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverDeployEice(newValue)}
  }

  public var uiDiscoverCreateNode: Prehog_V1alpha_UIDiscoverCreateNodeEvent {
    get {
      if case .uiDiscoverCreateNode(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverCreateNodeEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverCreateNode(newValue)}
  }

  public var desktopDirectoryShare: Prehog_V1alpha_DesktopDirectoryShareEvent {
    get {
      if case .desktopDirectoryShare(let v)? = _storage._event {return v}
      return Prehog_V1alpha_DesktopDirectoryShareEvent()
    }
    set {_uniqueStorage()._event = .desktopDirectoryShare(newValue)}
  }

  public var desktopClipboardTransfer: Prehog_V1alpha_DesktopClipboardEvent {
    get {
      if case .desktopClipboardTransfer(let v)? = _storage._event {return v}
      return Prehog_V1alpha_DesktopClipboardEvent()
    }
    set {_uniqueStorage()._event = .desktopClipboardTransfer(newValue)}
  }

  public var tagExecuteQuery: Prehog_V1alpha_TAGExecuteQueryEvent {
    get {
      if case .tagExecuteQuery(let v)? = _storage._event {return v}
      return Prehog_V1alpha_TAGExecuteQueryEvent()
    }
    set {_uniqueStorage()._event = .tagExecuteQuery(newValue)}
  }

  public var externalAuditStorageAuthenticate: Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent {
    get {
      if case .externalAuditStorageAuthenticate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent()
    }
    set {_uniqueStorage()._event = .externalAuditStorageAuthenticate(newValue)}
  }

  public var securityReportGetResult: Prehog_V1alpha_SecurityReportGetResultEvent {
    get {
      if case .securityReportGetResult(let v)? = _storage._event {return v}
      return Prehog_V1alpha_SecurityReportGetResultEvent()
    }
    set {_uniqueStorage()._event = .securityReportGetResult(newValue)}
  }

  public var auditQueryRun: Prehog_V1alpha_AuditQueryRunEvent {
    get {
      if case .auditQueryRun(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AuditQueryRunEvent()
    }
    set {_uniqueStorage()._event = .auditQueryRun(newValue)}
  }

  public var discoveryFetchEvent: Prehog_V1alpha_DiscoveryFetchEvent {
    get {
      if case .discoveryFetchEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_DiscoveryFetchEvent()
    }
    set {_uniqueStorage()._event = .discoveryFetchEvent(newValue)}
  }

  public var accessListReviewCreate: Prehog_V1alpha_AccessListReviewCreateEvent {
    get {
      if case .accessListReviewCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListReviewCreateEvent()
    }
    set {_uniqueStorage()._event = .accessListReviewCreate(newValue)}
  }

  public var accessListReviewDelete: Prehog_V1alpha_AccessListReviewDeleteEvent {
    get {
      if case .accessListReviewDelete(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListReviewDeleteEvent()
    }
    set {_uniqueStorage()._event = .accessListReviewDelete(newValue)}
  }

  public var accessListReviewCompliance: Prehog_V1alpha_AccessListReviewComplianceEvent {
    get {
      if case .accessListReviewCompliance(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessListReviewComplianceEvent()
    }
    set {_uniqueStorage()._event = .accessListReviewCompliance(newValue)}
  }

  public var mfaAuthenticationEvent: Prehog_V1alpha_MFAAuthenticationEvent {
    get {
      if case .mfaAuthenticationEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_MFAAuthenticationEvent()
    }
    set {_uniqueStorage()._event = .mfaAuthenticationEvent(newValue)}
  }

  public var spiffeSvidIssued: Prehog_V1alpha_SPIFFESVIDIssuedEvent {
    get {
      if case .spiffeSvidIssued(let v)? = _storage._event {return v}
      return Prehog_V1alpha_SPIFFESVIDIssuedEvent()
    }
    set {_uniqueStorage()._event = .spiffeSvidIssued(newValue)}
  }

  public var oktaAccessListSync: Prehog_V1alpha_OktaAccessListSyncEvent {
    get {
      if case .oktaAccessListSync(let v)? = _storage._event {return v}
      return Prehog_V1alpha_OktaAccessListSyncEvent()
    }
    set {_uniqueStorage()._event = .oktaAccessListSync(newValue)}
  }

  public var databaseUserCreated: Prehog_V1alpha_DatabaseUserCreatedEvent {
    get {
      if case .databaseUserCreated(let v)? = _storage._event {return v}
      return Prehog_V1alpha_DatabaseUserCreatedEvent()
    }
    set {_uniqueStorage()._event = .databaseUserCreated(newValue)}
  }

  public var databaseUserPermissionsUpdated: Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent {
    get {
      if case .databaseUserPermissionsUpdated(let v)? = _storage._event {return v}
      return Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent()
    }
    set {_uniqueStorage()._event = .databaseUserPermissionsUpdated(newValue)}
  }

  public var uiDiscoverCreateDiscoveryConfig: Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent {
    get {
      if case .uiDiscoverCreateDiscoveryConfig(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverCreateDiscoveryConfig(newValue)}
  }

  public var uiDiscoverKubeEksEnrollEvent: Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent {
    get {
      if case .uiDiscoverKubeEksEnrollEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverKubeEksEnrollEvent(newValue)}
  }

  public var uiDiscoverCreateAppServerEvent: Prehog_V1alpha_UIDiscoverCreateAppServerEvent {
    get {
      if case .uiDiscoverCreateAppServerEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIDiscoverCreateAppServerEvent()
    }
    set {_uniqueStorage()._event = .uiDiscoverCreateAppServerEvent(newValue)}
  }

  public var accessGraphGitlabScan: Prehog_V1alpha_AccessGraphGitlabScanEvent {
    get {
      if case .accessGraphGitlabScan(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessGraphGitlabScanEvent()
    }
    set {_uniqueStorage()._event = .accessGraphGitlabScan(newValue)}
  }

  public var accessGraphSecretsScanAuthorizedKeys: Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent {
    get {
      if case .accessGraphSecretsScanAuthorizedKeys(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent()
    }
    set {_uniqueStorage()._event = .accessGraphSecretsScanAuthorizedKeys(newValue)}
  }

  public var accessGraphSecretsScanSshPrivateKeys: Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent {
    get {
      if case .accessGraphSecretsScanSshPrivateKeys(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent()
    }
    set {_uniqueStorage()._event = .accessGraphSecretsScanSshPrivateKeys(newValue)}
  }

  public var accessGraphAwsScan: Prehog_V1alpha_AccessGraphAWSScanEvent {
    get {
      if case .accessGraphAwsScan(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessGraphAWSScanEvent()
    }
    set {_uniqueStorage()._event = .accessGraphAwsScan(newValue)}
  }

  public var accessGraphAccessPathChanged: Prehog_V1alpha_AccessGraphAccessPathChangedEvent {
    get {
      if case .accessGraphAccessPathChanged(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessGraphAccessPathChangedEvent()
    }
    set {_uniqueStorage()._event = .accessGraphAccessPathChanged(newValue)}
  }

  public var accessGraphCrownJewelCreate: Prehog_V1alpha_AccessGraphCrownJewelCreateEvent {
    get {
      if case .accessGraphCrownJewelCreate(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessGraphCrownJewelCreateEvent()
    }
    set {_uniqueStorage()._event = .accessGraphCrownJewelCreate(newValue)}
  }

  public var uiAccessGraphCrownJewelDiffView: Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent {
    get {
      if case .uiAccessGraphCrownJewelDiffView(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent()
    }
    set {_uniqueStorage()._event = .uiAccessGraphCrownJewelDiffView(newValue)}
  }

  public var sessionRecordingAccess: Prehog_V1alpha_SessionRecordingAccessEvent {
    get {
      if case .sessionRecordingAccess(let v)? = _storage._event {return v}
      return Prehog_V1alpha_SessionRecordingAccessEvent()
    }
    set {_uniqueStorage()._event = .sessionRecordingAccess(newValue)}
  }

  public var userTaskState: Prehog_V1alpha_UserTaskStateEvent {
    get {
      if case .userTaskState(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UserTaskStateEvent()
    }
    set {_uniqueStorage()._event = .userTaskState(newValue)}
  }

  public var uiIntegrationEnrollStepEvent: Prehog_V1alpha_UIIntegrationEnrollStepEvent {
    get {
      if case .uiIntegrationEnrollStepEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_UIIntegrationEnrollStepEvent()
    }
    set {_uniqueStorage()._event = .uiIntegrationEnrollStepEvent(newValue)}
  }

  public var accessRequestCreateEvent: Prehog_V1alpha_AccessRequestEvent {
    get {
      if case .accessRequestCreateEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessRequestEvent()
    }
    set {_uniqueStorage()._event = .accessRequestCreateEvent(newValue)}
  }

  public var accessRequestReviewEvent: Prehog_V1alpha_AccessRequestEvent {
    get {
      if case .accessRequestReviewEvent(let v)? = _storage._event {return v}
      return Prehog_V1alpha_AccessRequestEvent()
    }
    set {_uniqueStorage()._event = .accessRequestReviewEvent(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// the event being submitted
  public enum OneOf_Event: Equatable, Sendable {
    case userLogin(Prehog_V1alpha_UserLoginEvent)
    case ssoCreate(Prehog_V1alpha_SSOCreateEvent)
    case resourceCreate(Prehog_V1alpha_ResourceCreateEvent)
    /// REMOVE IN V14: Use session_start_v2 instead
    case sessionStart(Prehog_V1alpha_SessionStartEvent)
    case uiBannerClick(Prehog_V1alpha_UIBannerClickEvent)
    case uiOnboardCompleteGoToDashboardClick(Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent)
    case uiOnboardAddFirstResourceClick(Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent)
    case uiOnboardAddFirstResourceLaterClick(Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent)
    case uiOnboardSetCredentialSubmit(Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent)
    case uiOnboardRegisterChallengeSubmit(Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent)
    case uiRecoveryCodesContinueClick(Prehog_V1alpha_UIRecoveryCodesContinueClickEvent)
    case uiRecoveryCodesCopyClick(Prehog_V1alpha_UIRecoveryCodesCopyClickEvent)
    case uiRecoveryCodesPrintClick(Prehog_V1alpha_UIRecoveryCodesPrintClickEvent)
    case uiDiscoverStartedEvent(Prehog_V1alpha_UIDiscoverStartedEvent)
    case uiDiscoverResourceSelectionEvent(Prehog_V1alpha_UIDiscoverResourceSelectionEvent)
    case userCertificateIssuedEvent(Prehog_V1alpha_UserCertificateIssuedEvent)
    /// Note: semantics of SessionStartEvent type values have changed to
    /// differentiate SSH from Kubernetes exec sessions (as well as adding
    /// db/app/desktop events). The structures are the same, however, so we don't
    /// need a new message type.
    case sessionStartV2(Prehog_V1alpha_SessionStartEvent)
    case uiDiscoverDeployServiceEvent(Prehog_V1alpha_UIDiscoverDeployServiceEvent)
    case uiDiscoverDatabaseRegisterEvent(Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent)
    case uiDiscoverDatabaseConfigureMtlsEvent(Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent)
    case uiDiscoverDesktopActiveDirectoryToolsInstallEvent(Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent)
    case uiDiscoverDesktopActiveDirectoryConfigureEvent(Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent)
    case uiDiscoverAutoDiscoveredResourcesEvent(Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent)
    case uiDiscoverDatabaseConfigureIamPolicyEvent(Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent)
    case uiDiscoverPrincipalsConfigureEvent(Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent)
    case uiDiscoverTestConnectionEvent(Prehog_V1alpha_UIDiscoverTestConnectionEvent)
    case uiDiscoverCompletedEvent(Prehog_V1alpha_UIDiscoverCompletedEvent)
    case roleCreate(Prehog_V1alpha_RoleCreateEvent)
    case uiCreateNewRoleClick(Prehog_V1alpha_UICreateNewRoleClickEvent)
    case uiCreateNewRoleSaveClick(Prehog_V1alpha_UICreateNewRoleSaveClickEvent)
    case uiCreateNewRoleCancelClick(Prehog_V1alpha_UICreateNewRoleCancelClickEvent)
    case uiCreateNewRoleViewDocumentationClick(Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent)
    case kubeRequest(Prehog_V1alpha_KubeRequestEvent)
    case sftp(Prehog_V1alpha_SFTPEvent)
    case agentMetadataEvent(Prehog_V1alpha_AgentMetadataEvent)
    case resourceHeartbeat(Prehog_V1alpha_ResourceHeartbeatEvent)
    case uiDiscoverIntegrationAwsOidcConnectEvent(Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent)
    case uiDiscoverDatabaseRdsEnrollEvent(Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent)
    case uiCallToActionClickEvent(Prehog_V1alpha_UICallToActionClickEvent)
    case assistCompletion(Prehog_V1alpha_AssistCompletionEvent)
    case uiIntegrationEnrollStartEvent(Prehog_V1alpha_UIIntegrationEnrollStartEvent)
    case uiIntegrationEnrollCompleteEvent(Prehog_V1alpha_UIIntegrationEnrollCompleteEvent)
    case editorChangeEvent(Prehog_V1alpha_EditorChangeEvent)
    case botCreate(Prehog_V1alpha_BotCreateEvent)
    case uiOnboardQuestionnaireSubmit(Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent)
    case botJoin(Prehog_V1alpha_BotJoinEvent)
    case assistExecution(Prehog_V1alpha_AssistExecutionEvent)
    case assistNewConversation(Prehog_V1alpha_AssistNewConversationEvent)
    case deviceAuthenticateEvent(Prehog_V1alpha_DeviceAuthenticateEvent)
    case featureRecommendationEvent(Prehog_V1alpha_FeatureRecommendationEvent)
    case assistAccessRequest(Prehog_V1alpha_AssistAccessRequestEvent)
    case assistAction(Prehog_V1alpha_AssistActionEvent)
    case deviceEnrollEvent(Prehog_V1alpha_DeviceEnrollEvent)
    case licenseLimitEvent(Prehog_V1alpha_LicenseLimitEvent)
    case accessListCreate(Prehog_V1alpha_AccessListCreateEvent)
    case accessListUpdate(Prehog_V1alpha_AccessListUpdateEvent)
    case accessListDelete(Prehog_V1alpha_AccessListDeleteEvent)
    case accessListMemberCreate(Prehog_V1alpha_AccessListMemberCreateEvent)
    case accessListMemberUpdate(Prehog_V1alpha_AccessListMemberUpdateEvent)
    case accessListMemberDelete(Prehog_V1alpha_AccessListMemberDeleteEvent)
    case accessListGrantsToUser(Prehog_V1alpha_AccessListGrantsToUserEvent)
    case uiDiscoverEc2InstanceSelection(Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent)
    case uiDiscoverDeployEice(Prehog_V1alpha_UIDiscoverDeployEICEEvent)
    case uiDiscoverCreateNode(Prehog_V1alpha_UIDiscoverCreateNodeEvent)
    case desktopDirectoryShare(Prehog_V1alpha_DesktopDirectoryShareEvent)
    case desktopClipboardTransfer(Prehog_V1alpha_DesktopClipboardEvent)
    case tagExecuteQuery(Prehog_V1alpha_TAGExecuteQueryEvent)
    case externalAuditStorageAuthenticate(Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent)
    case securityReportGetResult(Prehog_V1alpha_SecurityReportGetResultEvent)
    case auditQueryRun(Prehog_V1alpha_AuditQueryRunEvent)
    case discoveryFetchEvent(Prehog_V1alpha_DiscoveryFetchEvent)
    case accessListReviewCreate(Prehog_V1alpha_AccessListReviewCreateEvent)
    case accessListReviewDelete(Prehog_V1alpha_AccessListReviewDeleteEvent)
    case accessListReviewCompliance(Prehog_V1alpha_AccessListReviewComplianceEvent)
    case mfaAuthenticationEvent(Prehog_V1alpha_MFAAuthenticationEvent)
    case spiffeSvidIssued(Prehog_V1alpha_SPIFFESVIDIssuedEvent)
    case oktaAccessListSync(Prehog_V1alpha_OktaAccessListSyncEvent)
    case databaseUserCreated(Prehog_V1alpha_DatabaseUserCreatedEvent)
    case databaseUserPermissionsUpdated(Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent)
    case uiDiscoverCreateDiscoveryConfig(Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent)
    case uiDiscoverKubeEksEnrollEvent(Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent)
    case uiDiscoverCreateAppServerEvent(Prehog_V1alpha_UIDiscoverCreateAppServerEvent)
    case accessGraphGitlabScan(Prehog_V1alpha_AccessGraphGitlabScanEvent)
    case accessGraphSecretsScanAuthorizedKeys(Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent)
    case accessGraphSecretsScanSshPrivateKeys(Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent)
    case accessGraphAwsScan(Prehog_V1alpha_AccessGraphAWSScanEvent)
    case accessGraphAccessPathChanged(Prehog_V1alpha_AccessGraphAccessPathChangedEvent)
    case accessGraphCrownJewelCreate(Prehog_V1alpha_AccessGraphCrownJewelCreateEvent)
    case uiAccessGraphCrownJewelDiffView(Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent)
    case sessionRecordingAccess(Prehog_V1alpha_SessionRecordingAccessEvent)
    case userTaskState(Prehog_V1alpha_UserTaskStateEvent)
    case uiIntegrationEnrollStepEvent(Prehog_V1alpha_UIIntegrationEnrollStepEvent)
    case accessRequestCreateEvent(Prehog_V1alpha_AccessRequestEvent)
    case accessRequestReviewEvent(Prehog_V1alpha_AccessRequestEvent)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Prehog_V1alpha_SubmitEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_SubmitEventsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// individual events to be submitted in a batch, up to 500 at once
  public var events: [Prehog_V1alpha_SubmitEventRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_SubmitEventsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_HelloTeleportRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_HelloTeleportResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "prehog.v1alpha"

extension Prehog_V1alpha_UserOrigin: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_ORIGIN_UNSPECIFIED"),
    1: .same(proto: "USER_ORIGIN_LOCAL"),
    2: .same(proto: "USER_ORIGIN_SSO"),
    3: .same(proto: "USER_ORIGIN_OKTA"),
    4: .same(proto: "USER_ORIGIN_SCIM"),
    5: .same(proto: "USER_ORIGIN_ENTRAID"),
  ]
}

extension Prehog_V1alpha_ResourceKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESOURCE_KIND_UNSPECIFIED"),
    1: .same(proto: "RESOURCE_KIND_NODE"),
    2: .same(proto: "RESOURCE_KIND_APP_SERVER"),
    3: .same(proto: "RESOURCE_KIND_KUBE_SERVER"),
    4: .same(proto: "RESOURCE_KIND_DB_SERVER"),
    5: .same(proto: "RESOURCE_KIND_WINDOWS_DESKTOP"),
    6: .same(proto: "RESOURCE_KIND_NODE_OPENSSH"),
    7: .same(proto: "RESOURCE_KIND_NODE_OPENSSH_EICE"),
  ]
}

extension Prehog_V1alpha_UserKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_KIND_UNSPECIFIED"),
    1: .same(proto: "USER_KIND_HUMAN"),
    2: .same(proto: "USER_KIND_BOT"),
  ]
}

extension Prehog_V1alpha_DiscoverResource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISCOVER_RESOURCE_UNSPECIFIED"),
    1: .same(proto: "DISCOVER_RESOURCE_SERVER"),
    2: .same(proto: "DISCOVER_RESOURCE_KUBERNETES"),
    3: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_SELF_HOSTED"),
    4: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_SELF_HOSTED"),
    5: .same(proto: "DISCOVER_RESOURCE_DATABASE_MONGODB_SELF_HOSTED"),
    6: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_RDS"),
    7: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_RDS"),
    8: .same(proto: "DISCOVER_RESOURCE_APPLICATION_HTTP"),
    9: .same(proto: "DISCOVER_RESOURCE_APPLICATION_TCP"),
    10: .same(proto: "DISCOVER_RESOURCE_WINDOWS_DESKTOP"),
    11: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_RDS"),
    12: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_REDSHIFT"),
    13: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_SELF_HOSTED"),
    14: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_SELF_HOSTED"),
    15: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_GCP"),
    16: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_GCP"),
    17: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_GCP"),
    18: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_REDSHIFT_SERVERLESS"),
    19: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_AZURE"),
    20: .same(proto: "DISCOVER_RESOURCE_DATABASE_DYNAMODB"),
    21: .same(proto: "DISCOVER_RESOURCE_DATABASE_CASSANDRA_KEYSPACES"),
    22: .same(proto: "DISCOVER_RESOURCE_DATABASE_CASSANDRA_SELF_HOSTED"),
    23: .same(proto: "DISCOVER_RESOURCE_DATABASE_ELASTICSEARCH_SELF_HOSTED"),
    24: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_ELASTICACHE"),
    25: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_MEMORYDB"),
    26: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_AZURE_CACHE"),
    27: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_CLUSTER_SELF_HOSTED"),
    28: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_AZURE"),
    29: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_AZURE"),
    30: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_MICROSOFT"),
    31: .same(proto: "DISCOVER_RESOURCE_DATABASE_COCKROACHDB_SELF_HOSTED"),
    32: .same(proto: "DISCOVER_RESOURCE_DATABASE_MONGODB_ATLAS"),
    33: .same(proto: "DISCOVER_RESOURCE_DATABASE_SNOWFLAKE"),
    34: .same(proto: "DISCOVER_RESOURCE_DOC_DATABASE_RDS_PROXY"),
    35: .same(proto: "DISCOVER_RESOURCE_DOC_DATABASE_HIGH_AVAILABILITY"),
    36: .same(proto: "DISCOVER_RESOURCE_DOC_DATABASE_DYNAMIC_REGISTRATION"),
    37: .same(proto: "DISCOVER_RESOURCE_SAML_APPLICATION"),
    38: .same(proto: "DISCOVER_RESOURCE_EC2_INSTANCE"),
    39: .same(proto: "DISCOVER_RESOURCE_DOC_WINDOWS_DESKTOP_NON_AD"),
    40: .same(proto: "DISCOVER_RESOURCE_KUBERNETES_EKS"),
    41: .same(proto: "DISCOVER_RESOURCE_APPLICATION_AWS_CONSOLE"),
  ]
}

extension Prehog_V1alpha_DiscoverStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISCOVER_STATUS_UNSPECIFIED"),
    1: .same(proto: "DISCOVER_STATUS_SUCCESS"),
    2: .same(proto: "DISCOVER_STATUS_SKIPPED"),
    3: .same(proto: "DISCOVER_STATUS_ERROR"),
    4: .same(proto: "DISCOVER_STATUS_ABORTED"),
  ]
}

extension Prehog_V1alpha_CTA: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CTA_UNSPECIFIED"),
    1: .same(proto: "CTA_AUTH_CONNECTOR"),
    2: .same(proto: "CTA_ACTIVE_SESSIONS"),
    3: .same(proto: "CTA_ACCESS_REQUESTS"),
    4: .same(proto: "CTA_PREMIUM_SUPPORT"),
    5: .same(proto: "CTA_TRUSTED_DEVICES"),
    6: .same(proto: "CTA_UPGRADE_BANNER"),
    7: .same(proto: "CTA_BILLING_SUMMARY"),
    8: .same(proto: "CTA_ACCESS_LIST"),
    9: .same(proto: "CTA_ACCESS_MONITORING"),
    10: .same(proto: "CTA_EXTERNAL_AUDIT_STORAGE"),
    11: .same(proto: "CTA_OKTA_USER_SYNC"),
    12: .same(proto: "CTA_ENTRA_ID"),
    13: .same(proto: "CTA_OKTA_SCIM"),
  ]
}

extension Prehog_V1alpha_IntegrationEnrollKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTEGRATION_ENROLL_KIND_UNSPECIFIED"),
    1: .same(proto: "INTEGRATION_ENROLL_KIND_SLACK"),
    2: .same(proto: "INTEGRATION_ENROLL_KIND_AWS_OIDC"),
    3: .same(proto: "INTEGRATION_ENROLL_KIND_PAGERDUTY"),
    4: .same(proto: "INTEGRATION_ENROLL_KIND_EMAIL"),
    5: .same(proto: "INTEGRATION_ENROLL_KIND_JIRA"),
    6: .same(proto: "INTEGRATION_ENROLL_KIND_DISCORD"),
    7: .same(proto: "INTEGRATION_ENROLL_KIND_MATTERMOST"),
    8: .same(proto: "INTEGRATION_ENROLL_KIND_MS_TEAMS"),
    9: .same(proto: "INTEGRATION_ENROLL_KIND_OPSGENIE"),
    10: .same(proto: "INTEGRATION_ENROLL_KIND_OKTA"),
    11: .same(proto: "INTEGRATION_ENROLL_KIND_JAMF"),
    12: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID"),
    13: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_GITHUB_ACTIONS"),
    14: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_CIRCLECI"),
    15: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_GITLAB"),
    16: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_JENKINS"),
    17: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_ANSIBLE"),
    18: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_AWS"),
    19: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_GCP"),
    20: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_AZURE"),
    21: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_SPACELIFT"),
    22: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_KUBERNETES"),
    23: .same(proto: "INTEGRATION_ENROLL_KIND_ENTRA_ID"),
    24: .same(proto: "INTEGRATION_ENROLL_KIND_DATADOG_INCIDENT_MANAGEMENT"),
    25: .same(proto: "INTEGRATION_ENROLL_KIND_SERVICENOW"),
    26: .same(proto: "INTEGRATION_ENROLL_KIND_AWS_IDENTITY_CENTER"),
  ]
}

extension Prehog_V1alpha_IntegrationEnrollStep: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTEGRATION_ENROLL_STEP_UNSPECIFIED"),
    1: .same(proto: "INTEGRATION_ENROLL_STEP_AWSIC_CONNECT_OIDC"),
    2: .same(proto: "INTEGRATION_ENROLL_STEP_AWSIC_SET_ACCESSLIST_DEFAULT_OWNER"),
    3: .same(proto: "INTEGRATION_ENROLL_STEP_AWSIC_UPLOAD_AWS_SAML_SP_METADATA"),
    4: .same(proto: "INTEGRATION_ENROLL_STEP_AWSIC_TEST_SCIM_CONNECTION"),
  ]
}

extension Prehog_V1alpha_IntegrationEnrollStatusCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTEGRATION_ENROLL_STATUS_CODE_UNSPECIFIED"),
    1: .same(proto: "INTEGRATION_ENROLL_STATUS_CODE_SUCCESS"),
    2: .same(proto: "INTEGRATION_ENROLL_STATUS_CODE_SKIPPED"),
    3: .same(proto: "INTEGRATION_ENROLL_STATUS_CODE_ERROR"),
    4: .same(proto: "INTEGRATION_ENROLL_STATUS_CODE_ABORTED"),
  ]
}

extension Prehog_V1alpha_EditorChangeStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EDITOR_CHANGE_STATUS_UNSPECIFIED"),
    1: .same(proto: "EDITOR_CHANGE_STATUS_ROLE_GRANTED"),
    2: .same(proto: "EDITOR_CHANGE_STATUS_ROLE_REMOVED"),
  ]
}

extension Prehog_V1alpha_Feature: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_UNSPECIFIED"),
    1: .same(proto: "FEATURE_TRUSTED_DEVICES"),
  ]
}

extension Prehog_V1alpha_FeatureRecommendationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_RECOMMENDATION_STATUS_UNSPECIFIED"),
    1: .same(proto: "FEATURE_RECOMMENDATION_STATUS_NOTIFIED"),
    2: .same(proto: "FEATURE_RECOMMENDATION_STATUS_DONE"),
  ]
}

extension Prehog_V1alpha_LicenseLimit: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LICENSE_LIMIT_UNSPECIFIED"),
    1: .same(proto: "LICENSE_LIMIT_DEVICE_TRUST_TEAM_JAMF"),
    2: .same(proto: "LICENSE_LIMIT_DEVICE_TRUST_TEAM_USAGE"),
  ]
}

extension Prehog_V1alpha_UserLoginEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserLoginEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "connector_type"),
    3: .standard(proto: "device_id"),
    4: .standard(proto: "required_private_key_policy"),
    5: .standard(proto: "user_origin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.connectorType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requiredPrivateKeyPolicy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.userOrigin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.connectorType.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorType, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 3)
    }
    if !self.requiredPrivateKeyPolicy.isEmpty {
      try visitor.visitSingularStringField(value: self.requiredPrivateKeyPolicy, fieldNumber: 4)
    }
    if self.userOrigin != .unspecified {
      try visitor.visitSingularEnumField(value: self.userOrigin, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UserLoginEvent, rhs: Prehog_V1alpha_UserLoginEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.connectorType != rhs.connectorType {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.requiredPrivateKeyPolicy != rhs.requiredPrivateKeyPolicy {return false}
    if lhs.userOrigin != rhs.userOrigin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_MFAAuthenticationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MFAAuthenticationEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "device_id"),
    3: .standard(proto: "device_type"),
    4: .standard(proto: "mfa_challenge_scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mfaChallengeScope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    if !self.deviceType.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceType, fieldNumber: 3)
    }
    if !self.mfaChallengeScope.isEmpty {
      try visitor.visitSingularStringField(value: self.mfaChallengeScope, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_MFAAuthenticationEvent, rhs: Prehog_V1alpha_MFAAuthenticationEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.mfaChallengeScope != rhs.mfaChallengeScope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SSOCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SSOCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connector_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectorType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectorType.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SSOCreateEvent, rhs: Prehog_V1alpha_SSOCreateEvent) -> Bool {
    if lhs.connectorType != rhs.connectorType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ResourceCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_type"),
    2: .standard(proto: "resource_origin"),
    3: .standard(proto: "cloud_provider"),
    4: .same(proto: "database"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceOrigin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cloudProvider) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._database) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 1)
    }
    if !self.resourceOrigin.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceOrigin, fieldNumber: 2)
    }
    if !self.cloudProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudProvider, fieldNumber: 3)
    }
    try { if let v = self._database {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ResourceCreateEvent, rhs: Prehog_V1alpha_ResourceCreateEvent) -> Bool {
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.resourceOrigin != rhs.resourceOrigin {return false}
    if lhs.cloudProvider != rhs.cloudProvider {return false}
    if lhs._database != rhs._database {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DiscoveredDatabaseMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoveredDatabaseMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "db_type"),
    2: .standard(proto: "db_protocol"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dbType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dbProtocol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dbType.isEmpty {
      try visitor.visitSingularStringField(value: self.dbType, fieldNumber: 1)
    }
    if !self.dbProtocol.isEmpty {
      try visitor.visitSingularStringField(value: self.dbProtocol, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DiscoveredDatabaseMetadata, rhs: Prehog_V1alpha_DiscoveredDatabaseMetadata) -> Bool {
    if lhs.dbType != rhs.dbType {return false}
    if lhs.dbProtocol != rhs.dbProtocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ResourceHeartbeatEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceHeartbeatEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_name"),
    2: .standard(proto: "resource_kind"),
    3: .same(proto: "static"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.resourceName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resourceKind) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.`static`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceName.isEmpty {
      try visitor.visitSingularBytesField(value: self.resourceName, fieldNumber: 1)
    }
    if self.resourceKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.resourceKind, fieldNumber: 2)
    }
    if self.`static` != false {
      try visitor.visitSingularBoolField(value: self.`static`, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ResourceHeartbeatEvent, rhs: Prehog_V1alpha_ResourceHeartbeatEvent) -> Bool {
    if lhs.resourceName != rhs.resourceName {return false}
    if lhs.resourceKind != rhs.resourceKind {return false}
    if lhs.`static` != rhs.`static` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SessionStartEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionStartEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "session_type"),
    3: .same(proto: "database"),
    4: .same(proto: "desktop"),
    5: .standard(proto: "user_kind"),
    6: .same(proto: "app"),
    7: .same(proto: "git"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._database) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._desktop) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.userKind) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._app) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._git) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.sessionType.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionType, fieldNumber: 2)
    }
    try { if let v = self._database {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._desktop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.userKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.userKind, fieldNumber: 5)
    }
    try { if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._git {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SessionStartEvent, rhs: Prehog_V1alpha_SessionStartEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.sessionType != rhs.sessionType {return false}
    if lhs._database != rhs._database {return false}
    if lhs._desktop != rhs._desktop {return false}
    if lhs.userKind != rhs.userKind {return false}
    if lhs._app != rhs._app {return false}
    if lhs._git != rhs._git {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SessionStartDatabaseMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionStartDatabaseMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "db_type"),
    2: .standard(proto: "db_protocol"),
    3: .standard(proto: "db_origin"),
    4: .standard(proto: "user_agent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dbType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dbProtocol) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dbOrigin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dbType.isEmpty {
      try visitor.visitSingularStringField(value: self.dbType, fieldNumber: 1)
    }
    if !self.dbProtocol.isEmpty {
      try visitor.visitSingularStringField(value: self.dbProtocol, fieldNumber: 2)
    }
    if !self.dbOrigin.isEmpty {
      try visitor.visitSingularStringField(value: self.dbOrigin, fieldNumber: 3)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SessionStartDatabaseMetadata, rhs: Prehog_V1alpha_SessionStartDatabaseMetadata) -> Bool {
    if lhs.dbType != rhs.dbType {return false}
    if lhs.dbProtocol != rhs.dbProtocol {return false}
    if lhs.dbOrigin != rhs.dbOrigin {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SessionStartDesktopMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionStartDesktopMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "desktop_type"),
    2: .same(proto: "origin"),
    3: .standard(proto: "windows_domain"),
    4: .standard(proto: "allow_user_creation"),
    5: .same(proto: "nla"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.desktopType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.origin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.windowsDomain) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowUserCreation) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.nla) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.desktopType.isEmpty {
      try visitor.visitSingularStringField(value: self.desktopType, fieldNumber: 1)
    }
    if !self.origin.isEmpty {
      try visitor.visitSingularStringField(value: self.origin, fieldNumber: 2)
    }
    if !self.windowsDomain.isEmpty {
      try visitor.visitSingularStringField(value: self.windowsDomain, fieldNumber: 3)
    }
    if self.allowUserCreation != false {
      try visitor.visitSingularBoolField(value: self.allowUserCreation, fieldNumber: 4)
    }
    if self.nla != false {
      try visitor.visitSingularBoolField(value: self.nla, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SessionStartDesktopMetadata, rhs: Prehog_V1alpha_SessionStartDesktopMetadata) -> Bool {
    if lhs.desktopType != rhs.desktopType {return false}
    if lhs.origin != rhs.origin {return false}
    if lhs.windowsDomain != rhs.windowsDomain {return false}
    if lhs.allowUserCreation != rhs.allowUserCreation {return false}
    if lhs.nla != rhs.nla {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SessionStartAppMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionStartAppMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_multi_port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isMultiPort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMultiPort != false {
      try visitor.visitSingularBoolField(value: self.isMultiPort, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SessionStartAppMetadata, rhs: Prehog_V1alpha_SessionStartAppMetadata) -> Bool {
    if lhs.isMultiPort != rhs.isMultiPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SessionStartGitMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionStartGitMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "git_type"),
    2: .standard(proto: "git_service"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gitType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gitService) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gitType.isEmpty {
      try visitor.visitSingularStringField(value: self.gitType, fieldNumber: 1)
    }
    if !self.gitService.isEmpty {
      try visitor.visitSingularStringField(value: self.gitService, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SessionStartGitMetadata, rhs: Prehog_V1alpha_SessionStartGitMetadata) -> Bool {
    if lhs.gitType != rhs.gitType {return false}
    if lhs.gitService != rhs.gitService {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UserCertificateIssuedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserCertificateIssuedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "ttl"),
    3: .standard(proto: "is_bot"),
    4: .standard(proto: "usage_database"),
    5: .standard(proto: "usage_app"),
    6: .standard(proto: "usage_kubernetes"),
    7: .standard(proto: "usage_desktop"),
    8: .standard(proto: "private_key_policy"),
    9: .standard(proto: "bot_instance_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ttl) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isBot) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.usageDatabase) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.usageApp) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.usageKubernetes) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.usageDesktop) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.privateKeyPolicy) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.botInstanceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isBot != false {
      try visitor.visitSingularBoolField(value: self.isBot, fieldNumber: 3)
    }
    if self.usageDatabase != false {
      try visitor.visitSingularBoolField(value: self.usageDatabase, fieldNumber: 4)
    }
    if self.usageApp != false {
      try visitor.visitSingularBoolField(value: self.usageApp, fieldNumber: 5)
    }
    if self.usageKubernetes != false {
      try visitor.visitSingularBoolField(value: self.usageKubernetes, fieldNumber: 6)
    }
    if self.usageDesktop != false {
      try visitor.visitSingularBoolField(value: self.usageDesktop, fieldNumber: 7)
    }
    if !self.privateKeyPolicy.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKeyPolicy, fieldNumber: 8)
    }
    if !self.botInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.botInstanceID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UserCertificateIssuedEvent, rhs: Prehog_V1alpha_UserCertificateIssuedEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._ttl != rhs._ttl {return false}
    if lhs.isBot != rhs.isBot {return false}
    if lhs.usageDatabase != rhs.usageDatabase {return false}
    if lhs.usageApp != rhs.usageApp {return false}
    if lhs.usageKubernetes != rhs.usageKubernetes {return false}
    if lhs.usageDesktop != rhs.usageDesktop {return false}
    if lhs.privateKeyPolicy != rhs.privateKeyPolicy {return false}
    if lhs.botInstanceID != rhs.botInstanceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SPIFFESVIDIssuedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SPIFFESVIDIssuedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "user_kind"),
    3: .standard(proto: "spiffe_id"),
    4: .standard(proto: "ip_sans_count"),
    5: .standard(proto: "dns_sans_count"),
    6: .standard(proto: "svid_type"),
    7: .standard(proto: "bot_instance_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.userKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.spiffeID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.ipSansCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.dnsSansCount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.svidType) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.botInstanceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.userKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.userKind, fieldNumber: 2)
    }
    if !self.spiffeID.isEmpty {
      try visitor.visitSingularStringField(value: self.spiffeID, fieldNumber: 3)
    }
    if self.ipSansCount != 0 {
      try visitor.visitSingularInt32Field(value: self.ipSansCount, fieldNumber: 4)
    }
    if self.dnsSansCount != 0 {
      try visitor.visitSingularInt32Field(value: self.dnsSansCount, fieldNumber: 5)
    }
    if !self.svidType.isEmpty {
      try visitor.visitSingularStringField(value: self.svidType, fieldNumber: 6)
    }
    if !self.botInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.botInstanceID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SPIFFESVIDIssuedEvent, rhs: Prehog_V1alpha_SPIFFESVIDIssuedEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.userKind != rhs.userKind {return false}
    if lhs.spiffeID != rhs.spiffeID {return false}
    if lhs.ipSansCount != rhs.ipSansCount {return false}
    if lhs.dnsSansCount != rhs.dnsSansCount {return false}
    if lhs.svidType != rhs.svidType {return false}
    if lhs.botInstanceID != rhs.botInstanceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIBannerClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIBannerClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "alert"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.alert) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.alert.isEmpty {
      try visitor.visitSingularStringField(value: self.alert, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIBannerClickEvent, rhs: Prehog_V1alpha_UIBannerClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.alert != rhs.alert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIOnboardCompleteGoToDashboardClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent, rhs: Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIOnboardAddFirstResourceClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent, rhs: Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIOnboardAddFirstResourceLaterClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent, rhs: Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIOnboardSetCredentialSubmitEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent, rhs: Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIOnboardRegisterChallengeSubmitEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "mfa_type"),
    3: .standard(proto: "login_flow"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mfaType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.loginFlow) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.mfaType.isEmpty {
      try visitor.visitSingularStringField(value: self.mfaType, fieldNumber: 2)
    }
    if !self.loginFlow.isEmpty {
      try visitor.visitSingularStringField(value: self.loginFlow, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent, rhs: Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.mfaType != rhs.mfaType {return false}
    if lhs.loginFlow != rhs.loginFlow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIOnboardQuestionnaireSubmitEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent, rhs: Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIRecoveryCodesContinueClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIRecoveryCodesContinueClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIRecoveryCodesContinueClickEvent, rhs: Prehog_V1alpha_UIRecoveryCodesContinueClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIRecoveryCodesCopyClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIRecoveryCodesCopyClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIRecoveryCodesCopyClickEvent, rhs: Prehog_V1alpha_UIRecoveryCodesCopyClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIRecoveryCodesPrintClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIRecoveryCodesPrintClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIRecoveryCodesPrintClickEvent, rhs: Prehog_V1alpha_UIRecoveryCodesPrintClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DiscoverMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "user_name"),
    3: .same(proto: "sso"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.sso) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if self.sso != false {
      try visitor.visitSingularBoolField(value: self.sso, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DiscoverMetadata, rhs: Prehog_V1alpha_DiscoverMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.sso != rhs.sso {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DiscoverResourceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverResourceMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.resource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.resource != .unspecified {
      try visitor.visitSingularEnumField(value: self.resource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DiscoverResourceMetadata, rhs: Prehog_V1alpha_DiscoverResourceMetadata) -> Bool {
    if lhs.resource != rhs.resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DiscoverStepStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverStepStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DiscoverStepStatus, rhs: Prehog_V1alpha_DiscoverStepStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverStartedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverStartedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverStartedEvent, rhs: Prehog_V1alpha_UIDiscoverStartedEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverResourceSelectionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverResourceSelectionEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverResourceSelectionEvent, rhs: Prehog_V1alpha_UIDiscoverResourceSelectionEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverIntegrationAWSOIDCConnectEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent, rhs: Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseRDSEnrollEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
    4: .standard(proto: "selected_resources_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.selectedResourcesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.selectedResourcesCount != 0 {
      try visitor.visitSingularInt64Field(value: self.selectedResourcesCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent, rhs: Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.selectedResourcesCount != rhs.selectedResourcesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverKubeEKSEnrollEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent, rhs: Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDeployServiceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDeployServiceEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
    4: .standard(proto: "deploy_method"),
    5: .standard(proto: "deploy_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.deployMethod) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.deployType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.deployMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.deployMethod, fieldNumber: 4)
    }
    if self.deployType != .unspecified {
      try visitor.visitSingularEnumField(value: self.deployType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDeployServiceEvent, rhs: Prehog_V1alpha_UIDiscoverDeployServiceEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.deployMethod != rhs.deployMethod {return false}
    if lhs.deployType != rhs.deployType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDeployServiceEvent.DeployMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPLOY_METHOD_UNSPECIFIED"),
    1: .same(proto: "DEPLOY_METHOD_AUTO"),
    2: .same(proto: "DEPLOY_METHOD_MANUAL"),
  ]
}

extension Prehog_V1alpha_UIDiscoverDeployServiceEvent.DeployType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPLOY_TYPE_UNSPECIFIED"),
    1: .same(proto: "DEPLOY_TYPE_INSTALL_SCRIPT"),
    2: .same(proto: "DEPLOY_TYPE_AMAZON_ECS"),
  ]
}

extension Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverCreateDiscoveryConfigEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
    4: .standard(proto: "config_method"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.configMethod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.configMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.configMethod, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent, rhs: Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.configMethod != rhs.configMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent.ConfigMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONFIG_METHOD_UNSPECIFIED"),
    1: .same(proto: "CONFIG_METHOD_AWS_EC2_SSM"),
    2: .same(proto: "CONFIG_METHOD_AWS_EC2_EICE"),
    3: .same(proto: "CONFIG_METHOD_AWS_RDS_ECS"),
    4: .same(proto: "CONFIG_METHOD_AWS_EKS"),
  ]
}

extension Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseRegisterEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent, rhs: Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseConfigureMTLSEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent, rhs: Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDesktopActiveDirectoryToolsInstallEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent, rhs: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDesktopActiveDirectoryConfigureEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent, rhs: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverAutoDiscoveredResourcesEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
    4: .standard(proto: "resources_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.resourcesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.resourcesCount != 0 {
      try visitor.visitSingularInt64Field(value: self.resourcesCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent, rhs: Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.resourcesCount != rhs.resourcesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverEC2InstanceSelectionEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent, rhs: Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDeployEICEEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDeployEICEEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDeployEICEEvent, rhs: Prehog_V1alpha_UIDiscoverDeployEICEEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverCreateNodeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverCreateNodeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverCreateNodeEvent, rhs: Prehog_V1alpha_UIDiscoverCreateNodeEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverCreateAppServerEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverCreateAppServerEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverCreateAppServerEvent, rhs: Prehog_V1alpha_UIDiscoverCreateAppServerEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseConfigureIAMPolicyEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent, rhs: Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverPrincipalsConfigureEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent, rhs: Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverTestConnectionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverTestConnectionEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverTestConnectionEvent, rhs: Prehog_V1alpha_UIDiscoverTestConnectionEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIDiscoverCompletedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIDiscoverCompletedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIDiscoverCompletedEvent, rhs: Prehog_V1alpha_UIDiscoverCompletedEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_RoleCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RoleCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "role_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.roleName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.roleName.isEmpty {
      try visitor.visitSingularStringField(value: self.roleName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_RoleCreateEvent, rhs: Prehog_V1alpha_RoleCreateEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.roleName != rhs.roleName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_BotCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BotCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "bot_user_name"),
    3: .standard(proto: "role_name"),
    4: .standard(proto: "role_count"),
    5: .standard(proto: "join_method"),
    6: .standard(proto: "bot_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.botUserName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.roleName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.roleCount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.joinMethod) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.botName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.botUserName.isEmpty {
      try visitor.visitSingularStringField(value: self.botUserName, fieldNumber: 2)
    }
    if !self.roleName.isEmpty {
      try visitor.visitSingularStringField(value: self.roleName, fieldNumber: 3)
    }
    if self.roleCount != 0 {
      try visitor.visitSingularInt64Field(value: self.roleCount, fieldNumber: 4)
    }
    if !self.joinMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.joinMethod, fieldNumber: 5)
    }
    if !self.botName.isEmpty {
      try visitor.visitSingularStringField(value: self.botName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_BotCreateEvent, rhs: Prehog_V1alpha_BotCreateEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.botUserName != rhs.botUserName {return false}
    if lhs.roleName != rhs.roleName {return false}
    if lhs.roleCount != rhs.roleCount {return false}
    if lhs.joinMethod != rhs.joinMethod {return false}
    if lhs.botName != rhs.botName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_BotJoinEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BotJoinEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bot_name"),
    2: .standard(proto: "join_method"),
    3: .standard(proto: "join_token_name"),
    4: .standard(proto: "user_name"),
    5: .standard(proto: "bot_instance_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.botName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.joinMethod) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.joinTokenName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.botInstanceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.botName.isEmpty {
      try visitor.visitSingularStringField(value: self.botName, fieldNumber: 1)
    }
    if !self.joinMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.joinMethod, fieldNumber: 2)
    }
    if !self.joinTokenName.isEmpty {
      try visitor.visitSingularStringField(value: self.joinTokenName, fieldNumber: 3)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 4)
    }
    if !self.botInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.botInstanceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_BotJoinEvent, rhs: Prehog_V1alpha_BotJoinEvent) -> Bool {
    if lhs.botName != rhs.botName {return false}
    if lhs.joinMethod != rhs.joinMethod {return false}
    if lhs.joinTokenName != rhs.joinTokenName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.botInstanceID != rhs.botInstanceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UICreateNewRoleClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UICreateNewRoleClickEvent, rhs: Prehog_V1alpha_UICreateNewRoleClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UICreateNewRoleSaveClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleSaveClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UICreateNewRoleSaveClickEvent, rhs: Prehog_V1alpha_UICreateNewRoleSaveClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UICreateNewRoleCancelClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleCancelClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UICreateNewRoleCancelClickEvent, rhs: Prehog_V1alpha_UICreateNewRoleCancelClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleViewDocumentationClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent, rhs: Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UICallToActionClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UICallToActionClickEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "cta"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.cta) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.cta != .unspecified {
      try visitor.visitSingularEnumField(value: self.cta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UICallToActionClickEvent, rhs: Prehog_V1alpha_UICallToActionClickEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.cta != rhs.cta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_KubeRequestEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KubeRequestEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "user_kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.userKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.userKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.userKind, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_KubeRequestEvent, rhs: Prehog_V1alpha_KubeRequestEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.userKind != rhs.userKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SFTPEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SFTPEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "action"),
    3: .standard(proto: "user_kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.action) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.userKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.action != 0 {
      try visitor.visitSingularInt32Field(value: self.action, fieldNumber: 2)
    }
    if self.userKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.userKind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SFTPEvent, rhs: Prehog_V1alpha_SFTPEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.action != rhs.action {return false}
    if lhs.userKind != rhs.userKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AgentMetadataEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AgentMetadataEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "host_id"),
    3: .same(proto: "services"),
    4: .same(proto: "os"),
    5: .standard(proto: "os_version"),
    6: .standard(proto: "host_architecture"),
    7: .standard(proto: "glibc_version"),
    8: .standard(proto: "install_methods"),
    9: .standard(proto: "container_runtime"),
    10: .standard(proto: "container_orchestrator"),
    11: .standard(proto: "cloud_environment"),
    12: .standard(proto: "external_upgrader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.services) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hostArchitecture) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.glibcVersion) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.installMethods) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.containerRuntime) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.containerOrchestrator) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.cloudEnvironment) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.externalUpgrader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 2)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedStringField(value: self.services, fieldNumber: 3)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if !self.hostArchitecture.isEmpty {
      try visitor.visitSingularStringField(value: self.hostArchitecture, fieldNumber: 6)
    }
    if !self.glibcVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.glibcVersion, fieldNumber: 7)
    }
    if !self.installMethods.isEmpty {
      try visitor.visitRepeatedStringField(value: self.installMethods, fieldNumber: 8)
    }
    if !self.containerRuntime.isEmpty {
      try visitor.visitSingularStringField(value: self.containerRuntime, fieldNumber: 9)
    }
    if !self.containerOrchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.containerOrchestrator, fieldNumber: 10)
    }
    if !self.cloudEnvironment.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudEnvironment, fieldNumber: 11)
    }
    if !self.externalUpgrader.isEmpty {
      try visitor.visitSingularStringField(value: self.externalUpgrader, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AgentMetadataEvent, rhs: Prehog_V1alpha_AgentMetadataEvent) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.hostID != rhs.hostID {return false}
    if lhs.services != rhs.services {return false}
    if lhs.os != rhs.os {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.hostArchitecture != rhs.hostArchitecture {return false}
    if lhs.glibcVersion != rhs.glibcVersion {return false}
    if lhs.installMethods != rhs.installMethods {return false}
    if lhs.containerRuntime != rhs.containerRuntime {return false}
    if lhs.containerOrchestrator != rhs.containerOrchestrator {return false}
    if lhs.cloudEnvironment != rhs.cloudEnvironment {return false}
    if lhs.externalUpgrader != rhs.externalUpgrader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AssistCompletionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistCompletionEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "conversation_id"),
    3: .standard(proto: "total_tokens"),
    4: .standard(proto: "prompt_tokens"),
    5: .standard(proto: "completion_tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 3)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 4)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AssistCompletionEvent, rhs: Prehog_V1alpha_AssistCompletionEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AssistExecutionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistExecutionEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "conversation_id"),
    3: .standard(proto: "node_count"),
    4: .standard(proto: "total_tokens"),
    5: .standard(proto: "prompt_tokens"),
    6: .standard(proto: "completion_tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.nodeCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.nodeCount != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeCount, fieldNumber: 3)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 4)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 5)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AssistExecutionEvent, rhs: Prehog_V1alpha_AssistExecutionEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.nodeCount != rhs.nodeCount {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AssistNewConversationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistNewConversationEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "category"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.category) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AssistNewConversationEvent, rhs: Prehog_V1alpha_AssistNewConversationEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AssistAccessRequestEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistAccessRequestEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "resource_type"),
    4: .standard(proto: "total_tokens"),
    5: .standard(proto: "prompt_tokens"),
    6: .standard(proto: "completion_tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 2)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 4)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 5)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AssistAccessRequestEvent, rhs: Prehog_V1alpha_AssistAccessRequestEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AssistActionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssistActionEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "action"),
    4: .standard(proto: "total_tokens"),
    5: .standard(proto: "prompt_tokens"),
    6: .standard(proto: "completion_tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 2)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 4)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 5)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AssistActionEvent, rhs: Prehog_V1alpha_AssistActionEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.action != rhs.action {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListMetadata, rhs: Prehog_V1alpha_AccessListMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListCreateEvent, rhs: Prehog_V1alpha_AccessListCreateEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListUpdateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListUpdateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListUpdateEvent, rhs: Prehog_V1alpha_AccessListUpdateEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListDeleteEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListDeleteEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListDeleteEvent, rhs: Prehog_V1alpha_AccessListDeleteEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListMemberCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListMemberCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "member_kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.memberKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.memberKind.isEmpty {
      try visitor.visitSingularStringField(value: self.memberKind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListMemberCreateEvent, rhs: Prehog_V1alpha_AccessListMemberCreateEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.memberKind != rhs.memberKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListMemberUpdateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListMemberUpdateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "member_kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.memberKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.memberKind.isEmpty {
      try visitor.visitSingularStringField(value: self.memberKind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListMemberUpdateEvent, rhs: Prehog_V1alpha_AccessListMemberUpdateEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.memberKind != rhs.memberKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListMemberDeleteEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListMemberDeleteEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "member_kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.memberKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.memberKind.isEmpty {
      try visitor.visitSingularStringField(value: self.memberKind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListMemberDeleteEvent, rhs: Prehog_V1alpha_AccessListMemberDeleteEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.memberKind != rhs.memberKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListGrantsToUserEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListGrantsToUserEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "count_roles_granted"),
    3: .standard(proto: "count_traits_granted"),
    4: .standard(proto: "count_inherited_roles_granted"),
    5: .standard(proto: "count_inherited_traits_granted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.countRolesGranted) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.countTraitsGranted) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.countInheritedRolesGranted) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.countInheritedTraitsGranted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.countRolesGranted != 0 {
      try visitor.visitSingularInt32Field(value: self.countRolesGranted, fieldNumber: 2)
    }
    if self.countTraitsGranted != 0 {
      try visitor.visitSingularInt32Field(value: self.countTraitsGranted, fieldNumber: 3)
    }
    if self.countInheritedRolesGranted != 0 {
      try visitor.visitSingularInt32Field(value: self.countInheritedRolesGranted, fieldNumber: 4)
    }
    if self.countInheritedTraitsGranted != 0 {
      try visitor.visitSingularInt32Field(value: self.countInheritedTraitsGranted, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListGrantsToUserEvent, rhs: Prehog_V1alpha_AccessListGrantsToUserEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.countRolesGranted != rhs.countRolesGranted {return false}
    if lhs.countTraitsGranted != rhs.countTraitsGranted {return false}
    if lhs.countInheritedRolesGranted != rhs.countInheritedRolesGranted {return false}
    if lhs.countInheritedTraitsGranted != rhs.countInheritedTraitsGranted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListReviewCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListReviewCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "days_past_next_audit_date"),
    4: .standard(proto: "membership_requirements_changed"),
    5: .standard(proto: "review_frequency_changed"),
    6: .standard(proto: "review_day_of_month_changed"),
    7: .standard(proto: "number_of_removed_members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.daysPastNextAuditDate) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.membershipRequirementsChanged) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.reviewFrequencyChanged) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.reviewDayOfMonthChanged) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.numberOfRemovedMembers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.daysPastNextAuditDate != 0 {
      try visitor.visitSingularInt32Field(value: self.daysPastNextAuditDate, fieldNumber: 3)
    }
    if self.membershipRequirementsChanged != false {
      try visitor.visitSingularBoolField(value: self.membershipRequirementsChanged, fieldNumber: 4)
    }
    if self.reviewFrequencyChanged != false {
      try visitor.visitSingularBoolField(value: self.reviewFrequencyChanged, fieldNumber: 5)
    }
    if self.reviewDayOfMonthChanged != false {
      try visitor.visitSingularBoolField(value: self.reviewDayOfMonthChanged, fieldNumber: 6)
    }
    if self.numberOfRemovedMembers != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfRemovedMembers, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListReviewCreateEvent, rhs: Prehog_V1alpha_AccessListReviewCreateEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.daysPastNextAuditDate != rhs.daysPastNextAuditDate {return false}
    if lhs.membershipRequirementsChanged != rhs.membershipRequirementsChanged {return false}
    if lhs.reviewFrequencyChanged != rhs.reviewFrequencyChanged {return false}
    if lhs.reviewDayOfMonthChanged != rhs.reviewDayOfMonthChanged {return false}
    if lhs.numberOfRemovedMembers != rhs.numberOfRemovedMembers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListReviewDeleteEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListReviewDeleteEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "access_list_review_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessListReviewID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.accessListReviewID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListReviewID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListReviewDeleteEvent, rhs: Prehog_V1alpha_AccessListReviewDeleteEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.accessListReviewID != rhs.accessListReviewID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessListReviewComplianceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessListReviewComplianceEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_access_lists"),
    2: .standard(proto: "access_lists_need_review"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalAccessLists) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accessListsNeedReview) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalAccessLists != 0 {
      try visitor.visitSingularInt32Field(value: self.totalAccessLists, fieldNumber: 1)
    }
    if self.accessListsNeedReview != 0 {
      try visitor.visitSingularInt32Field(value: self.accessListsNeedReview, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessListReviewComplianceEvent, rhs: Prehog_V1alpha_AccessListReviewComplianceEvent) -> Bool {
    if lhs.totalAccessLists != rhs.totalAccessLists {return false}
    if lhs.accessListsNeedReview != rhs.accessListsNeedReview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_IntegrationEnrollMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegrationEnrollMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "kind"),
    3: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_IntegrationEnrollMetadata, rhs: Prehog_V1alpha_IntegrationEnrollMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIIntegrationEnrollStartEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIIntegrationEnrollStartEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIIntegrationEnrollStartEvent, rhs: Prehog_V1alpha_UIIntegrationEnrollStartEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIIntegrationEnrollCompleteEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIIntegrationEnrollCompleteEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIIntegrationEnrollCompleteEvent, rhs: Prehog_V1alpha_UIIntegrationEnrollCompleteEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_IntegrationEnrollStepStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegrationEnrollStepStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_IntegrationEnrollStepStatus, rhs: Prehog_V1alpha_IntegrationEnrollStepStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIIntegrationEnrollStepEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIIntegrationEnrollStepEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "step"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.step) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.step != .unspecified {
      try visitor.visitSingularEnumField(value: self.step, fieldNumber: 2)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIIntegrationEnrollStepEvent, rhs: Prehog_V1alpha_UIIntegrationEnrollStepEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.step != rhs.step {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_EditorChangeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditorChangeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_EditorChangeEvent, rhs: Prehog_V1alpha_EditorChangeEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DeviceAuthenticateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceAuthenticateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "device_os_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceOsType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.deviceOsType.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceOsType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DeviceAuthenticateEvent, rhs: Prehog_V1alpha_DeviceAuthenticateEvent) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.deviceOsType != rhs.deviceOsType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DeviceEnrollEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceEnrollEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "device_os_type"),
    4: .standard(proto: "device_origin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceOsType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceOrigin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.deviceOsType.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceOsType, fieldNumber: 3)
    }
    if !self.deviceOrigin.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceOrigin, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DeviceEnrollEvent, rhs: Prehog_V1alpha_DeviceEnrollEvent) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.deviceOsType != rhs.deviceOsType {return false}
    if lhs.deviceOrigin != rhs.deviceOrigin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_FeatureRecommendationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureRecommendationEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "feature"),
    3: .standard(proto: "feature_recommendation_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.feature) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.featureRecommendationStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.feature != .unspecified {
      try visitor.visitSingularEnumField(value: self.feature, fieldNumber: 2)
    }
    if self.featureRecommendationStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.featureRecommendationStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_FeatureRecommendationEvent, rhs: Prehog_V1alpha_FeatureRecommendationEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.feature != rhs.feature {return false}
    if lhs.featureRecommendationStatus != rhs.featureRecommendationStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_LicenseLimitEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LicenseLimitEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "license_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.licenseLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.licenseLimit != .unspecified {
      try visitor.visitSingularEnumField(value: self.licenseLimit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_LicenseLimitEvent, rhs: Prehog_V1alpha_LicenseLimitEvent) -> Bool {
    if lhs.licenseLimit != rhs.licenseLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DesktopDirectoryShareEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DesktopDirectoryShareEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "desktop"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "directory_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.desktop) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.directoryName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.desktop.isEmpty {
      try visitor.visitSingularStringField(value: self.desktop, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.directoryName.isEmpty {
      try visitor.visitSingularStringField(value: self.directoryName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DesktopDirectoryShareEvent, rhs: Prehog_V1alpha_DesktopDirectoryShareEvent) -> Bool {
    if lhs.desktop != rhs.desktop {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.directoryName != rhs.directoryName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DesktopClipboardEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DesktopClipboardEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "desktop"),
    2: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.desktop) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.desktop.isEmpty {
      try visitor.visitSingularStringField(value: self.desktop, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DesktopClipboardEvent, rhs: Prehog_V1alpha_DesktopClipboardEvent) -> Bool {
    if lhs.desktop != rhs.desktop {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_TAGExecuteQueryEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TAGExecuteQueryEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .standard(proto: "total_nodes"),
    3: .standard(proto: "total_edges"),
    4: .standard(proto: "is_success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalNodes) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalEdges) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSuccess) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.totalNodes != 0 {
      try visitor.visitSingularInt64Field(value: self.totalNodes, fieldNumber: 2)
    }
    if self.totalEdges != 0 {
      try visitor.visitSingularInt64Field(value: self.totalEdges, fieldNumber: 3)
    }
    if self.isSuccess != false {
      try visitor.visitSingularBoolField(value: self.isSuccess, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_TAGExecuteQueryEvent, rhs: Prehog_V1alpha_TAGExecuteQueryEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.totalNodes != rhs.totalNodes {return false}
    if lhs.totalEdges != rhs.totalEdges {return false}
    if lhs.isSuccess != rhs.isSuccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessGraphSecretsScanAuthorizedKeysEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "host_id"),
    2: .standard(proto: "total_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 1)
    }
    if self.totalKeys != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalKeys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent, rhs: Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent) -> Bool {
    if lhs.hostID != rhs.hostID {return false}
    if lhs.totalKeys != rhs.totalKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessGraphSecretsScanSSHPrivateKeysEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "total_keys"),
    3: .standard(proto: "device_os_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalKeys) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceOsType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.totalKeys != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalKeys, fieldNumber: 2)
    }
    if !self.deviceOsType.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceOsType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent, rhs: Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.totalKeys != rhs.totalKeys {return false}
    if lhs.deviceOsType != rhs.deviceOsType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessGraphGitlabScanEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessGraphGitlabScanEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_projects"),
    2: .standard(proto: "total_users"),
    3: .standard(proto: "total_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.totalProjects) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalUsers) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.totalGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalProjects != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalProjects, fieldNumber: 1)
    }
    if self.totalUsers != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalUsers, fieldNumber: 2)
    }
    if self.totalGroups != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalGroups, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessGraphGitlabScanEvent, rhs: Prehog_V1alpha_AccessGraphGitlabScanEvent) -> Bool {
    if lhs.totalProjects != rhs.totalProjects {return false}
    if lhs.totalUsers != rhs.totalUsers {return false}
    if lhs.totalGroups != rhs.totalGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessGraphAWSScanEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessGraphAWSScanEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_ec2_instances"),
    2: .standard(proto: "total_users"),
    3: .standard(proto: "total_groups"),
    4: .standard(proto: "total_roles"),
    5: .standard(proto: "total_policies"),
    6: .standard(proto: "total_eks_clusters"),
    7: .standard(proto: "total_rds_instances"),
    8: .standard(proto: "total_s3_buckets"),
    9: .standard(proto: "total_saml_providers"),
    10: .standard(proto: "total_oidc_providers"),
    11: .standard(proto: "total_accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.totalEc2Instances) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.totalUsers) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.totalGroups) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.totalRoles) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.totalPolicies) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.totalEksClusters) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.totalRdsInstances) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.totalS3Buckets) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.totalSamlProviders) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.totalOidcProviders) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.totalAccounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalEc2Instances != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalEc2Instances, fieldNumber: 1)
    }
    if self.totalUsers != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalUsers, fieldNumber: 2)
    }
    if self.totalGroups != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalGroups, fieldNumber: 3)
    }
    if self.totalRoles != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalRoles, fieldNumber: 4)
    }
    if self.totalPolicies != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalPolicies, fieldNumber: 5)
    }
    if self.totalEksClusters != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalEksClusters, fieldNumber: 6)
    }
    if self.totalRdsInstances != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalRdsInstances, fieldNumber: 7)
    }
    if self.totalS3Buckets != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalS3Buckets, fieldNumber: 8)
    }
    if self.totalSamlProviders != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalSamlProviders, fieldNumber: 9)
    }
    if self.totalOidcProviders != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalOidcProviders, fieldNumber: 10)
    }
    if self.totalAccounts != 0 {
      try visitor.visitSingularUInt64Field(value: self.totalAccounts, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessGraphAWSScanEvent, rhs: Prehog_V1alpha_AccessGraphAWSScanEvent) -> Bool {
    if lhs.totalEc2Instances != rhs.totalEc2Instances {return false}
    if lhs.totalUsers != rhs.totalUsers {return false}
    if lhs.totalGroups != rhs.totalGroups {return false}
    if lhs.totalRoles != rhs.totalRoles {return false}
    if lhs.totalPolicies != rhs.totalPolicies {return false}
    if lhs.totalEksClusters != rhs.totalEksClusters {return false}
    if lhs.totalRdsInstances != rhs.totalRdsInstances {return false}
    if lhs.totalS3Buckets != rhs.totalS3Buckets {return false}
    if lhs.totalSamlProviders != rhs.totalSamlProviders {return false}
    if lhs.totalOidcProviders != rhs.totalOidcProviders {return false}
    if lhs.totalAccounts != rhs.totalAccounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessGraphAccessPathChangedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessGraphAccessPathChangedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "affected_resource_source"),
    2: .standard(proto: "affected_resource_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.affectedResourceSource) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.affectedResourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.affectedResourceSource.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedResourceSource, fieldNumber: 1)
    }
    if !self.affectedResourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedResourceType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessGraphAccessPathChangedEvent, rhs: Prehog_V1alpha_AccessGraphAccessPathChangedEvent) -> Bool {
    if lhs.affectedResourceSource != rhs.affectedResourceSource {return false}
    if lhs.affectedResourceType != rhs.affectedResourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UIAccessGraphCrownJewelDiffViewEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "affected_resource_source"),
    2: .standard(proto: "affected_resource_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.affectedResourceSource) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.affectedResourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.affectedResourceSource.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedResourceSource, fieldNumber: 1)
    }
    if !self.affectedResourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedResourceType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent, rhs: Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent) -> Bool {
    if lhs.affectedResourceSource != rhs.affectedResourceSource {return false}
    if lhs.affectedResourceType != rhs.affectedResourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessGraphCrownJewelCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessGraphCrownJewelCreateEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessGraphCrownJewelCreateEvent, rhs: Prehog_V1alpha_AccessGraphCrownJewelCreateEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAuditStorageAuthenticateEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent, rhs: Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SecurityReportGetResultEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SecurityReportGetResultEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "name"),
    3: .same(proto: "days"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.days) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.days != 0 {
      try visitor.visitSingularInt32Field(value: self.days, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SecurityReportGetResultEvent, rhs: Prehog_V1alpha_SecurityReportGetResultEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.name != rhs.name {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AuditQueryRunEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditQueryRunEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "days"),
    3: .standard(proto: "is_success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.days) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isSuccess) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.days != 0 {
      try visitor.visitSingularInt32Field(value: self.days, fieldNumber: 2)
    }
    if self.isSuccess != false {
      try visitor.visitSingularBoolField(value: self.isSuccess, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AuditQueryRunEvent, rhs: Prehog_V1alpha_AuditQueryRunEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.days != rhs.days {return false}
    if lhs.isSuccess != rhs.isSuccess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DiscoveryFetchEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoveryFetchEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cloud_provider"),
    2: .standard(proto: "resource_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cloudProvider) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cloudProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudProvider, fieldNumber: 1)
    }
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DiscoveryFetchEvent, rhs: Prehog_V1alpha_DiscoveryFetchEvent) -> Bool {
    if lhs.cloudProvider != rhs.cloudProvider {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_OktaAccessListSyncEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OktaAccessListSyncEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_app_filters"),
    2: .standard(proto: "num_group_filters"),
    3: .standard(proto: "num_apps"),
    4: .standard(proto: "num_groups"),
    5: .standard(proto: "num_roles"),
    6: .standard(proto: "num_access_lists"),
    7: .standard(proto: "num_access_list_members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numAppFilters) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numGroupFilters) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numApps) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.numGroups) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.numRoles) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.numAccessLists) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.numAccessListMembers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numAppFilters != 0 {
      try visitor.visitSingularInt32Field(value: self.numAppFilters, fieldNumber: 1)
    }
    if self.numGroupFilters != 0 {
      try visitor.visitSingularInt32Field(value: self.numGroupFilters, fieldNumber: 2)
    }
    if self.numApps != 0 {
      try visitor.visitSingularInt32Field(value: self.numApps, fieldNumber: 3)
    }
    if self.numGroups != 0 {
      try visitor.visitSingularInt32Field(value: self.numGroups, fieldNumber: 4)
    }
    if self.numRoles != 0 {
      try visitor.visitSingularInt32Field(value: self.numRoles, fieldNumber: 5)
    }
    if self.numAccessLists != 0 {
      try visitor.visitSingularInt32Field(value: self.numAccessLists, fieldNumber: 6)
    }
    if self.numAccessListMembers != 0 {
      try visitor.visitSingularInt32Field(value: self.numAccessListMembers, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_OktaAccessListSyncEvent, rhs: Prehog_V1alpha_OktaAccessListSyncEvent) -> Bool {
    if lhs.numAppFilters != rhs.numAppFilters {return false}
    if lhs.numGroupFilters != rhs.numGroupFilters {return false}
    if lhs.numApps != rhs.numApps {return false}
    if lhs.numGroups != rhs.numGroups {return false}
    if lhs.numRoles != rhs.numRoles {return false}
    if lhs.numAccessLists != rhs.numAccessLists {return false}
    if lhs.numAccessListMembers != rhs.numAccessListMembers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DatabaseUserCreatedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatabaseUserCreatedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "num_roles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._database) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numRoles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._database {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if self.numRoles != 0 {
      try visitor.visitSingularInt32Field(value: self.numRoles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DatabaseUserCreatedEvent, rhs: Prehog_V1alpha_DatabaseUserCreatedEvent) -> Bool {
    if lhs._database != rhs._database {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.numRoles != rhs.numRoles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatabaseUserPermissionsUpdateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "num_tables"),
    4: .standard(proto: "num_tables_permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._database) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numTables) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.numTablesPermissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._database {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if self.numTables != 0 {
      try visitor.visitSingularInt32Field(value: self.numTables, fieldNumber: 3)
    }
    if self.numTablesPermissions != 0 {
      try visitor.visitSingularInt32Field(value: self.numTablesPermissions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent, rhs: Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent) -> Bool {
    if lhs._database != rhs._database {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.numTables != rhs.numTables {return false}
    if lhs.numTablesPermissions != rhs.numTablesPermissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SessionRecordingAccessEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionRecordingAccessEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_type"),
    2: .standard(proto: "user_name"),
    3: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionType.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionType, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SessionRecordingAccessEvent, rhs: Prehog_V1alpha_SessionRecordingAccessEvent) -> Bool {
    if lhs.sessionType != rhs.sessionType {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_UserTaskStateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserTaskStateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "task_type"),
    2: .standard(proto: "issue_type"),
    3: .same(proto: "state"),
    4: .standard(proto: "instances_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.issueType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.instancesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskType.isEmpty {
      try visitor.visitSingularStringField(value: self.taskType, fieldNumber: 1)
    }
    if !self.issueType.isEmpty {
      try visitor.visitSingularStringField(value: self.issueType, fieldNumber: 2)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 3)
    }
    if self.instancesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.instancesCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_UserTaskStateEvent, rhs: Prehog_V1alpha_UserTaskStateEvent) -> Bool {
    if lhs.taskType != rhs.taskType {return false}
    if lhs.issueType != rhs.issueType {return false}
    if lhs.state != rhs.state {return false}
    if lhs.instancesCount != rhs.instancesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_AccessRequestEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessRequestEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_AccessRequestEvent, rhs: Prehog_V1alpha_AccessRequestEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SubmitEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .same(proto: "timestamp"),
    95: .standard(proto: "teleport_version"),
    3: .standard(proto: "user_login"),
    4: .standard(proto: "sso_create"),
    5: .standard(proto: "resource_create"),
    6: .standard(proto: "session_start"),
    7: .standard(proto: "ui_banner_click"),
    9: .standard(proto: "ui_onboard_complete_go_to_dashboard_click"),
    10: .standard(proto: "ui_onboard_add_first_resource_click"),
    11: .standard(proto: "ui_onboard_add_first_resource_later_click"),
    12: .standard(proto: "ui_onboard_set_credential_submit"),
    13: .standard(proto: "ui_onboard_register_challenge_submit"),
    14: .standard(proto: "ui_recovery_codes_continue_click"),
    15: .standard(proto: "ui_recovery_codes_copy_click"),
    16: .standard(proto: "ui_recovery_codes_print_click"),
    17: .standard(proto: "ui_discover_started_event"),
    18: .standard(proto: "ui_discover_resource_selection_event"),
    19: .standard(proto: "user_certificate_issued_event"),
    20: .standard(proto: "session_start_v2"),
    21: .standard(proto: "ui_discover_deploy_service_event"),
    22: .standard(proto: "ui_discover_database_register_event"),
    23: .standard(proto: "ui_discover_database_configure_mtls_event"),
    24: .standard(proto: "ui_discover_desktop_active_directory_tools_install_event"),
    25: .standard(proto: "ui_discover_desktop_active_directory_configure_event"),
    26: .standard(proto: "ui_discover_auto_discovered_resources_event"),
    27: .standard(proto: "ui_discover_database_configure_iam_policy_event"),
    28: .standard(proto: "ui_discover_principals_configure_event"),
    29: .standard(proto: "ui_discover_test_connection_event"),
    30: .standard(proto: "ui_discover_completed_event"),
    31: .standard(proto: "role_create"),
    32: .standard(proto: "ui_create_new_role_click"),
    33: .standard(proto: "ui_create_new_role_save_click"),
    34: .standard(proto: "ui_create_new_role_cancel_click"),
    35: .standard(proto: "ui_create_new_role_view_documentation_click"),
    36: .standard(proto: "kube_request"),
    37: .same(proto: "sftp"),
    38: .standard(proto: "agent_metadata_event"),
    39: .standard(proto: "resource_heartbeat"),
    40: .standard(proto: "ui_discover_integration_aws_oidc_connect_event"),
    41: .standard(proto: "ui_discover_database_rds_enroll_event"),
    42: .standard(proto: "ui_call_to_action_click_event"),
    43: .standard(proto: "assist_completion"),
    44: .standard(proto: "ui_integration_enroll_start_event"),
    45: .standard(proto: "ui_integration_enroll_complete_event"),
    46: .standard(proto: "editor_change_event"),
    47: .standard(proto: "bot_create"),
    48: .standard(proto: "ui_onboard_questionnaire_submit"),
    49: .standard(proto: "bot_join"),
    50: .standard(proto: "assist_execution"),
    51: .standard(proto: "assist_new_conversation"),
    52: .standard(proto: "device_authenticate_event"),
    53: .standard(proto: "feature_recommendation_event"),
    54: .standard(proto: "assist_access_request"),
    55: .standard(proto: "assist_action"),
    56: .standard(proto: "device_enroll_event"),
    57: .standard(proto: "license_limit_event"),
    58: .standard(proto: "access_list_create"),
    59: .standard(proto: "access_list_update"),
    60: .standard(proto: "access_list_delete"),
    61: .standard(proto: "access_list_member_create"),
    62: .standard(proto: "access_list_member_update"),
    63: .standard(proto: "access_list_member_delete"),
    64: .standard(proto: "access_list_grants_to_user"),
    65: .standard(proto: "ui_discover_ec2_instance_selection"),
    66: .standard(proto: "ui_discover_deploy_eice"),
    67: .standard(proto: "ui_discover_create_node"),
    68: .standard(proto: "desktop_directory_share"),
    69: .standard(proto: "desktop_clipboard_transfer"),
    70: .standard(proto: "tag_execute_query"),
    71: .standard(proto: "external_audit_storage_authenticate"),
    72: .standard(proto: "security_report_get_result"),
    73: .standard(proto: "audit_query_run"),
    74: .standard(proto: "discovery_fetch_event"),
    75: .standard(proto: "access_list_review_create"),
    76: .standard(proto: "access_list_review_delete"),
    77: .standard(proto: "access_list_review_compliance"),
    78: .standard(proto: "mfa_authentication_event"),
    79: .standard(proto: "spiffe_svid_issued"),
    80: .standard(proto: "okta_access_list_sync"),
    81: .standard(proto: "database_user_created"),
    82: .standard(proto: "database_user_permissions_updated"),
    83: .standard(proto: "ui_discover_create_discovery_config"),
    84: .standard(proto: "ui_discover_kube_eks_enroll_event"),
    85: .standard(proto: "ui_discover_create_app_server_event"),
    86: .standard(proto: "access_graph_gitlab_scan"),
    87: .standard(proto: "access_graph_secrets_scan_authorized_keys"),
    88: .standard(proto: "access_graph_secrets_scan_ssh_private_keys"),
    89: .standard(proto: "access_graph_aws_scan"),
    90: .standard(proto: "access_graph_access_path_changed"),
    91: .standard(proto: "access_graph_crown_jewel_create"),
    92: .standard(proto: "ui_access_graph_crown_jewel_diff_view"),
    93: .standard(proto: "session_recording_access"),
    94: .standard(proto: "user_task_state"),
    96: .standard(proto: "ui_integration_enroll_step_event"),
    97: .standard(proto: "access_request_create_event"),
    98: .standard(proto: "access_request_review_event"),
  ]

  fileprivate class _StorageClass {
    var _clusterName: String = String()
    var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _teleportVersion: String = String()
    var _event: Prehog_V1alpha_SubmitEventRequest.OneOf_Event?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _clusterName = source._clusterName
      _timestamp = source._timestamp
      _teleportVersion = source._teleportVersion
      _event = source._event
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._clusterName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._timestamp) }()
        case 3: try {
          var v: Prehog_V1alpha_UserLoginEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .userLogin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .userLogin(v)
          }
        }()
        case 4: try {
          var v: Prehog_V1alpha_SSOCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .ssoCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .ssoCreate(v)
          }
        }()
        case 5: try {
          var v: Prehog_V1alpha_ResourceCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .resourceCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .resourceCreate(v)
          }
        }()
        case 6: try {
          var v: Prehog_V1alpha_SessionStartEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .sessionStart(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .sessionStart(v)
          }
        }()
        case 7: try {
          var v: Prehog_V1alpha_UIBannerClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiBannerClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiBannerClick(v)
          }
        }()
        case 9: try {
          var v: Prehog_V1alpha_UIOnboardCompleteGoToDashboardClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiOnboardCompleteGoToDashboardClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiOnboardCompleteGoToDashboardClick(v)
          }
        }()
        case 10: try {
          var v: Prehog_V1alpha_UIOnboardAddFirstResourceClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiOnboardAddFirstResourceClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiOnboardAddFirstResourceClick(v)
          }
        }()
        case 11: try {
          var v: Prehog_V1alpha_UIOnboardAddFirstResourceLaterClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiOnboardAddFirstResourceLaterClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiOnboardAddFirstResourceLaterClick(v)
          }
        }()
        case 12: try {
          var v: Prehog_V1alpha_UIOnboardSetCredentialSubmitEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiOnboardSetCredentialSubmit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiOnboardSetCredentialSubmit(v)
          }
        }()
        case 13: try {
          var v: Prehog_V1alpha_UIOnboardRegisterChallengeSubmitEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiOnboardRegisterChallengeSubmit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiOnboardRegisterChallengeSubmit(v)
          }
        }()
        case 14: try {
          var v: Prehog_V1alpha_UIRecoveryCodesContinueClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiRecoveryCodesContinueClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiRecoveryCodesContinueClick(v)
          }
        }()
        case 15: try {
          var v: Prehog_V1alpha_UIRecoveryCodesCopyClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiRecoveryCodesCopyClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiRecoveryCodesCopyClick(v)
          }
        }()
        case 16: try {
          var v: Prehog_V1alpha_UIRecoveryCodesPrintClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiRecoveryCodesPrintClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiRecoveryCodesPrintClick(v)
          }
        }()
        case 17: try {
          var v: Prehog_V1alpha_UIDiscoverStartedEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverStartedEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverStartedEvent(v)
          }
        }()
        case 18: try {
          var v: Prehog_V1alpha_UIDiscoverResourceSelectionEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverResourceSelectionEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverResourceSelectionEvent(v)
          }
        }()
        case 19: try {
          var v: Prehog_V1alpha_UserCertificateIssuedEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .userCertificateIssuedEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .userCertificateIssuedEvent(v)
          }
        }()
        case 20: try {
          var v: Prehog_V1alpha_SessionStartEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .sessionStartV2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .sessionStartV2(v)
          }
        }()
        case 21: try {
          var v: Prehog_V1alpha_UIDiscoverDeployServiceEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDeployServiceEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDeployServiceEvent(v)
          }
        }()
        case 22: try {
          var v: Prehog_V1alpha_UIDiscoverDatabaseRegisterEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDatabaseRegisterEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDatabaseRegisterEvent(v)
          }
        }()
        case 23: try {
          var v: Prehog_V1alpha_UIDiscoverDatabaseConfigureMTLSEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDatabaseConfigureMtlsEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDatabaseConfigureMtlsEvent(v)
          }
        }()
        case 24: try {
          var v: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryToolsInstallEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(v)
          }
        }()
        case 25: try {
          var v: Prehog_V1alpha_UIDiscoverDesktopActiveDirectoryConfigureEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDesktopActiveDirectoryConfigureEvent(v)
          }
        }()
        case 26: try {
          var v: Prehog_V1alpha_UIDiscoverAutoDiscoveredResourcesEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverAutoDiscoveredResourcesEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverAutoDiscoveredResourcesEvent(v)
          }
        }()
        case 27: try {
          var v: Prehog_V1alpha_UIDiscoverDatabaseConfigureIAMPolicyEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDatabaseConfigureIamPolicyEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDatabaseConfigureIamPolicyEvent(v)
          }
        }()
        case 28: try {
          var v: Prehog_V1alpha_UIDiscoverPrincipalsConfigureEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverPrincipalsConfigureEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverPrincipalsConfigureEvent(v)
          }
        }()
        case 29: try {
          var v: Prehog_V1alpha_UIDiscoverTestConnectionEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverTestConnectionEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverTestConnectionEvent(v)
          }
        }()
        case 30: try {
          var v: Prehog_V1alpha_UIDiscoverCompletedEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverCompletedEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverCompletedEvent(v)
          }
        }()
        case 31: try {
          var v: Prehog_V1alpha_RoleCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .roleCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .roleCreate(v)
          }
        }()
        case 32: try {
          var v: Prehog_V1alpha_UICreateNewRoleClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiCreateNewRoleClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiCreateNewRoleClick(v)
          }
        }()
        case 33: try {
          var v: Prehog_V1alpha_UICreateNewRoleSaveClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiCreateNewRoleSaveClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiCreateNewRoleSaveClick(v)
          }
        }()
        case 34: try {
          var v: Prehog_V1alpha_UICreateNewRoleCancelClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiCreateNewRoleCancelClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiCreateNewRoleCancelClick(v)
          }
        }()
        case 35: try {
          var v: Prehog_V1alpha_UICreateNewRoleViewDocumentationClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiCreateNewRoleViewDocumentationClick(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiCreateNewRoleViewDocumentationClick(v)
          }
        }()
        case 36: try {
          var v: Prehog_V1alpha_KubeRequestEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .kubeRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .kubeRequest(v)
          }
        }()
        case 37: try {
          var v: Prehog_V1alpha_SFTPEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .sftp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .sftp(v)
          }
        }()
        case 38: try {
          var v: Prehog_V1alpha_AgentMetadataEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .agentMetadataEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .agentMetadataEvent(v)
          }
        }()
        case 39: try {
          var v: Prehog_V1alpha_ResourceHeartbeatEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .resourceHeartbeat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .resourceHeartbeat(v)
          }
        }()
        case 40: try {
          var v: Prehog_V1alpha_UIDiscoverIntegrationAWSOIDCConnectEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverIntegrationAwsOidcConnectEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverIntegrationAwsOidcConnectEvent(v)
          }
        }()
        case 41: try {
          var v: Prehog_V1alpha_UIDiscoverDatabaseRDSEnrollEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDatabaseRdsEnrollEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDatabaseRdsEnrollEvent(v)
          }
        }()
        case 42: try {
          var v: Prehog_V1alpha_UICallToActionClickEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiCallToActionClickEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiCallToActionClickEvent(v)
          }
        }()
        case 43: try {
          var v: Prehog_V1alpha_AssistCompletionEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .assistCompletion(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .assistCompletion(v)
          }
        }()
        case 44: try {
          var v: Prehog_V1alpha_UIIntegrationEnrollStartEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiIntegrationEnrollStartEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiIntegrationEnrollStartEvent(v)
          }
        }()
        case 45: try {
          var v: Prehog_V1alpha_UIIntegrationEnrollCompleteEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiIntegrationEnrollCompleteEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiIntegrationEnrollCompleteEvent(v)
          }
        }()
        case 46: try {
          var v: Prehog_V1alpha_EditorChangeEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .editorChangeEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .editorChangeEvent(v)
          }
        }()
        case 47: try {
          var v: Prehog_V1alpha_BotCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .botCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .botCreate(v)
          }
        }()
        case 48: try {
          var v: Prehog_V1alpha_UIOnboardQuestionnaireSubmitEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiOnboardQuestionnaireSubmit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiOnboardQuestionnaireSubmit(v)
          }
        }()
        case 49: try {
          var v: Prehog_V1alpha_BotJoinEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .botJoin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .botJoin(v)
          }
        }()
        case 50: try {
          var v: Prehog_V1alpha_AssistExecutionEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .assistExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .assistExecution(v)
          }
        }()
        case 51: try {
          var v: Prehog_V1alpha_AssistNewConversationEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .assistNewConversation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .assistNewConversation(v)
          }
        }()
        case 52: try {
          var v: Prehog_V1alpha_DeviceAuthenticateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .deviceAuthenticateEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .deviceAuthenticateEvent(v)
          }
        }()
        case 53: try {
          var v: Prehog_V1alpha_FeatureRecommendationEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .featureRecommendationEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .featureRecommendationEvent(v)
          }
        }()
        case 54: try {
          var v: Prehog_V1alpha_AssistAccessRequestEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .assistAccessRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .assistAccessRequest(v)
          }
        }()
        case 55: try {
          var v: Prehog_V1alpha_AssistActionEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .assistAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .assistAction(v)
          }
        }()
        case 56: try {
          var v: Prehog_V1alpha_DeviceEnrollEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .deviceEnrollEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .deviceEnrollEvent(v)
          }
        }()
        case 57: try {
          var v: Prehog_V1alpha_LicenseLimitEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .licenseLimitEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .licenseLimitEvent(v)
          }
        }()
        case 58: try {
          var v: Prehog_V1alpha_AccessListCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListCreate(v)
          }
        }()
        case 59: try {
          var v: Prehog_V1alpha_AccessListUpdateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListUpdate(v)
          }
        }()
        case 60: try {
          var v: Prehog_V1alpha_AccessListDeleteEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListDelete(v)
          }
        }()
        case 61: try {
          var v: Prehog_V1alpha_AccessListMemberCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListMemberCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListMemberCreate(v)
          }
        }()
        case 62: try {
          var v: Prehog_V1alpha_AccessListMemberUpdateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListMemberUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListMemberUpdate(v)
          }
        }()
        case 63: try {
          var v: Prehog_V1alpha_AccessListMemberDeleteEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListMemberDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListMemberDelete(v)
          }
        }()
        case 64: try {
          var v: Prehog_V1alpha_AccessListGrantsToUserEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListGrantsToUser(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListGrantsToUser(v)
          }
        }()
        case 65: try {
          var v: Prehog_V1alpha_UIDiscoverEC2InstanceSelectionEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverEc2InstanceSelection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverEc2InstanceSelection(v)
          }
        }()
        case 66: try {
          var v: Prehog_V1alpha_UIDiscoverDeployEICEEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverDeployEice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverDeployEice(v)
          }
        }()
        case 67: try {
          var v: Prehog_V1alpha_UIDiscoverCreateNodeEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverCreateNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverCreateNode(v)
          }
        }()
        case 68: try {
          var v: Prehog_V1alpha_DesktopDirectoryShareEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .desktopDirectoryShare(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .desktopDirectoryShare(v)
          }
        }()
        case 69: try {
          var v: Prehog_V1alpha_DesktopClipboardEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .desktopClipboardTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .desktopClipboardTransfer(v)
          }
        }()
        case 70: try {
          var v: Prehog_V1alpha_TAGExecuteQueryEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .tagExecuteQuery(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .tagExecuteQuery(v)
          }
        }()
        case 71: try {
          var v: Prehog_V1alpha_ExternalAuditStorageAuthenticateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .externalAuditStorageAuthenticate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .externalAuditStorageAuthenticate(v)
          }
        }()
        case 72: try {
          var v: Prehog_V1alpha_SecurityReportGetResultEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .securityReportGetResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .securityReportGetResult(v)
          }
        }()
        case 73: try {
          var v: Prehog_V1alpha_AuditQueryRunEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .auditQueryRun(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .auditQueryRun(v)
          }
        }()
        case 74: try {
          var v: Prehog_V1alpha_DiscoveryFetchEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .discoveryFetchEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .discoveryFetchEvent(v)
          }
        }()
        case 75: try {
          var v: Prehog_V1alpha_AccessListReviewCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListReviewCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListReviewCreate(v)
          }
        }()
        case 76: try {
          var v: Prehog_V1alpha_AccessListReviewDeleteEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListReviewDelete(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListReviewDelete(v)
          }
        }()
        case 77: try {
          var v: Prehog_V1alpha_AccessListReviewComplianceEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessListReviewCompliance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessListReviewCompliance(v)
          }
        }()
        case 78: try {
          var v: Prehog_V1alpha_MFAAuthenticationEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .mfaAuthenticationEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .mfaAuthenticationEvent(v)
          }
        }()
        case 79: try {
          var v: Prehog_V1alpha_SPIFFESVIDIssuedEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .spiffeSvidIssued(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .spiffeSvidIssued(v)
          }
        }()
        case 80: try {
          var v: Prehog_V1alpha_OktaAccessListSyncEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .oktaAccessListSync(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .oktaAccessListSync(v)
          }
        }()
        case 81: try {
          var v: Prehog_V1alpha_DatabaseUserCreatedEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .databaseUserCreated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .databaseUserCreated(v)
          }
        }()
        case 82: try {
          var v: Prehog_V1alpha_DatabaseUserPermissionsUpdateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .databaseUserPermissionsUpdated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .databaseUserPermissionsUpdated(v)
          }
        }()
        case 83: try {
          var v: Prehog_V1alpha_UIDiscoverCreateDiscoveryConfigEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverCreateDiscoveryConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverCreateDiscoveryConfig(v)
          }
        }()
        case 84: try {
          var v: Prehog_V1alpha_UIDiscoverKubeEKSEnrollEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverKubeEksEnrollEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverKubeEksEnrollEvent(v)
          }
        }()
        case 85: try {
          var v: Prehog_V1alpha_UIDiscoverCreateAppServerEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiDiscoverCreateAppServerEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiDiscoverCreateAppServerEvent(v)
          }
        }()
        case 86: try {
          var v: Prehog_V1alpha_AccessGraphGitlabScanEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessGraphGitlabScan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessGraphGitlabScan(v)
          }
        }()
        case 87: try {
          var v: Prehog_V1alpha_AccessGraphSecretsScanAuthorizedKeysEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessGraphSecretsScanAuthorizedKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessGraphSecretsScanAuthorizedKeys(v)
          }
        }()
        case 88: try {
          var v: Prehog_V1alpha_AccessGraphSecretsScanSSHPrivateKeysEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessGraphSecretsScanSshPrivateKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessGraphSecretsScanSshPrivateKeys(v)
          }
        }()
        case 89: try {
          var v: Prehog_V1alpha_AccessGraphAWSScanEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessGraphAwsScan(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessGraphAwsScan(v)
          }
        }()
        case 90: try {
          var v: Prehog_V1alpha_AccessGraphAccessPathChangedEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessGraphAccessPathChanged(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessGraphAccessPathChanged(v)
          }
        }()
        case 91: try {
          var v: Prehog_V1alpha_AccessGraphCrownJewelCreateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessGraphCrownJewelCreate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessGraphCrownJewelCreate(v)
          }
        }()
        case 92: try {
          var v: Prehog_V1alpha_UIAccessGraphCrownJewelDiffViewEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiAccessGraphCrownJewelDiffView(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiAccessGraphCrownJewelDiffView(v)
          }
        }()
        case 93: try {
          var v: Prehog_V1alpha_SessionRecordingAccessEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .sessionRecordingAccess(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .sessionRecordingAccess(v)
          }
        }()
        case 94: try {
          var v: Prehog_V1alpha_UserTaskStateEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .userTaskState(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .userTaskState(v)
          }
        }()
        case 95: try { try decoder.decodeSingularStringField(value: &_storage._teleportVersion) }()
        case 96: try {
          var v: Prehog_V1alpha_UIIntegrationEnrollStepEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .uiIntegrationEnrollStepEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .uiIntegrationEnrollStepEvent(v)
          }
        }()
        case 97: try {
          var v: Prehog_V1alpha_AccessRequestEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessRequestCreateEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessRequestCreateEvent(v)
          }
        }()
        case 98: try {
          var v: Prehog_V1alpha_AccessRequestEvent?
          var hadOneofValue = false
          if let current = _storage._event {
            hadOneofValue = true
            if case .accessRequestReviewEvent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._event = .accessRequestReviewEvent(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._clusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterName, fieldNumber: 1)
      }
      try { if let v = _storage._timestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      switch _storage._event {
      case .userLogin?: try {
        guard case .userLogin(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .ssoCreate?: try {
        guard case .ssoCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .resourceCreate?: try {
        guard case .resourceCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .sessionStart?: try {
        guard case .sessionStart(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .uiBannerClick?: try {
        guard case .uiBannerClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .uiOnboardCompleteGoToDashboardClick?: try {
        guard case .uiOnboardCompleteGoToDashboardClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .uiOnboardAddFirstResourceClick?: try {
        guard case .uiOnboardAddFirstResourceClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .uiOnboardAddFirstResourceLaterClick?: try {
        guard case .uiOnboardAddFirstResourceLaterClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .uiOnboardSetCredentialSubmit?: try {
        guard case .uiOnboardSetCredentialSubmit(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .uiOnboardRegisterChallengeSubmit?: try {
        guard case .uiOnboardRegisterChallengeSubmit(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .uiRecoveryCodesContinueClick?: try {
        guard case .uiRecoveryCodesContinueClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .uiRecoveryCodesCopyClick?: try {
        guard case .uiRecoveryCodesCopyClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .uiRecoveryCodesPrintClick?: try {
        guard case .uiRecoveryCodesPrintClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .uiDiscoverStartedEvent?: try {
        guard case .uiDiscoverStartedEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .uiDiscoverResourceSelectionEvent?: try {
        guard case .uiDiscoverResourceSelectionEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .userCertificateIssuedEvent?: try {
        guard case .userCertificateIssuedEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .sessionStartV2?: try {
        guard case .sessionStartV2(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .uiDiscoverDeployServiceEvent?: try {
        guard case .uiDiscoverDeployServiceEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .uiDiscoverDatabaseRegisterEvent?: try {
        guard case .uiDiscoverDatabaseRegisterEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .uiDiscoverDatabaseConfigureMtlsEvent?: try {
        guard case .uiDiscoverDatabaseConfigureMtlsEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent?: try {
        guard case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .uiDiscoverDesktopActiveDirectoryConfigureEvent?: try {
        guard case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .uiDiscoverAutoDiscoveredResourcesEvent?: try {
        guard case .uiDiscoverAutoDiscoveredResourcesEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .uiDiscoverDatabaseConfigureIamPolicyEvent?: try {
        guard case .uiDiscoverDatabaseConfigureIamPolicyEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .uiDiscoverPrincipalsConfigureEvent?: try {
        guard case .uiDiscoverPrincipalsConfigureEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .uiDiscoverTestConnectionEvent?: try {
        guard case .uiDiscoverTestConnectionEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .uiDiscoverCompletedEvent?: try {
        guard case .uiDiscoverCompletedEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .roleCreate?: try {
        guard case .roleCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .uiCreateNewRoleClick?: try {
        guard case .uiCreateNewRoleClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .uiCreateNewRoleSaveClick?: try {
        guard case .uiCreateNewRoleSaveClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .uiCreateNewRoleCancelClick?: try {
        guard case .uiCreateNewRoleCancelClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .uiCreateNewRoleViewDocumentationClick?: try {
        guard case .uiCreateNewRoleViewDocumentationClick(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .kubeRequest?: try {
        guard case .kubeRequest(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .sftp?: try {
        guard case .sftp(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .agentMetadataEvent?: try {
        guard case .agentMetadataEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .resourceHeartbeat?: try {
        guard case .resourceHeartbeat(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .uiDiscoverIntegrationAwsOidcConnectEvent?: try {
        guard case .uiDiscoverIntegrationAwsOidcConnectEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .uiDiscoverDatabaseRdsEnrollEvent?: try {
        guard case .uiDiscoverDatabaseRdsEnrollEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .uiCallToActionClickEvent?: try {
        guard case .uiCallToActionClickEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .assistCompletion?: try {
        guard case .assistCompletion(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .uiIntegrationEnrollStartEvent?: try {
        guard case .uiIntegrationEnrollStartEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .uiIntegrationEnrollCompleteEvent?: try {
        guard case .uiIntegrationEnrollCompleteEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .editorChangeEvent?: try {
        guard case .editorChangeEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .botCreate?: try {
        guard case .botCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .uiOnboardQuestionnaireSubmit?: try {
        guard case .uiOnboardQuestionnaireSubmit(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .botJoin?: try {
        guard case .botJoin(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .assistExecution?: try {
        guard case .assistExecution(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .assistNewConversation?: try {
        guard case .assistNewConversation(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .deviceAuthenticateEvent?: try {
        guard case .deviceAuthenticateEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .featureRecommendationEvent?: try {
        guard case .featureRecommendationEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .assistAccessRequest?: try {
        guard case .assistAccessRequest(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case .assistAction?: try {
        guard case .assistAction(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }()
      case .deviceEnrollEvent?: try {
        guard case .deviceEnrollEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      }()
      case .licenseLimitEvent?: try {
        guard case .licenseLimitEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }()
      case .accessListCreate?: try {
        guard case .accessListCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      }()
      case .accessListUpdate?: try {
        guard case .accessListUpdate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      }()
      case .accessListDelete?: try {
        guard case .accessListDelete(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }()
      case .accessListMemberCreate?: try {
        guard case .accessListMemberCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }()
      case .accessListMemberUpdate?: try {
        guard case .accessListMemberUpdate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }()
      case .accessListMemberDelete?: try {
        guard case .accessListMemberDelete(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      }()
      case .accessListGrantsToUser?: try {
        guard case .accessListGrantsToUser(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      }()
      case .uiDiscoverEc2InstanceSelection?: try {
        guard case .uiDiscoverEc2InstanceSelection(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
      }()
      case .uiDiscoverDeployEice?: try {
        guard case .uiDiscoverDeployEice(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      }()
      case .uiDiscoverCreateNode?: try {
        guard case .uiDiscoverCreateNode(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      }()
      case .desktopDirectoryShare?: try {
        guard case .desktopDirectoryShare(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      }()
      case .desktopClipboardTransfer?: try {
        guard case .desktopClipboardTransfer(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      }()
      case .tagExecuteQuery?: try {
        guard case .tagExecuteQuery(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      }()
      case .externalAuditStorageAuthenticate?: try {
        guard case .externalAuditStorageAuthenticate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      }()
      case .securityReportGetResult?: try {
        guard case .securityReportGetResult(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      }()
      case .auditQueryRun?: try {
        guard case .auditQueryRun(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
      }()
      case .discoveryFetchEvent?: try {
        guard case .discoveryFetchEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
      }()
      case .accessListReviewCreate?: try {
        guard case .accessListReviewCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
      }()
      case .accessListReviewDelete?: try {
        guard case .accessListReviewDelete(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
      }()
      case .accessListReviewCompliance?: try {
        guard case .accessListReviewCompliance(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
      }()
      case .mfaAuthenticationEvent?: try {
        guard case .mfaAuthenticationEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
      }()
      case .spiffeSvidIssued?: try {
        guard case .spiffeSvidIssued(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
      }()
      case .oktaAccessListSync?: try {
        guard case .oktaAccessListSync(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      }()
      case .databaseUserCreated?: try {
        guard case .databaseUserCreated(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      }()
      case .databaseUserPermissionsUpdated?: try {
        guard case .databaseUserPermissionsUpdated(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      }()
      case .uiDiscoverCreateDiscoveryConfig?: try {
        guard case .uiDiscoverCreateDiscoveryConfig(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
      }()
      case .uiDiscoverKubeEksEnrollEvent?: try {
        guard case .uiDiscoverKubeEksEnrollEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
      }()
      case .uiDiscoverCreateAppServerEvent?: try {
        guard case .uiDiscoverCreateAppServerEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
      }()
      case .accessGraphGitlabScan?: try {
        guard case .accessGraphGitlabScan(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
      }()
      case .accessGraphSecretsScanAuthorizedKeys?: try {
        guard case .accessGraphSecretsScanAuthorizedKeys(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
      }()
      case .accessGraphSecretsScanSshPrivateKeys?: try {
        guard case .accessGraphSecretsScanSshPrivateKeys(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
      }()
      case .accessGraphAwsScan?: try {
        guard case .accessGraphAwsScan(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
      }()
      case .accessGraphAccessPathChanged?: try {
        guard case .accessGraphAccessPathChanged(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      }()
      case .accessGraphCrownJewelCreate?: try {
        guard case .accessGraphCrownJewelCreate(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      }()
      case .uiAccessGraphCrownJewelDiffView?: try {
        guard case .uiAccessGraphCrownJewelDiffView(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
      }()
      case .sessionRecordingAccess?: try {
        guard case .sessionRecordingAccess(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
      }()
      case .userTaskState?: try {
        guard case .userTaskState(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
      }()
      default: break
      }
      if !_storage._teleportVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._teleportVersion, fieldNumber: 95)
      }
      switch _storage._event {
      case .uiIntegrationEnrollStepEvent?: try {
        guard case .uiIntegrationEnrollStepEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 96)
      }()
      case .accessRequestCreateEvent?: try {
        guard case .accessRequestCreateEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
      }()
      case .accessRequestReviewEvent?: try {
        guard case .accessRequestReviewEvent(let v)? = _storage._event else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SubmitEventRequest, rhs: Prehog_V1alpha_SubmitEventRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clusterName != rhs_storage._clusterName {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._teleportVersion != rhs_storage._teleportVersion {return false}
        if _storage._event != rhs_storage._event {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SubmitEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SubmitEventResponse, rhs: Prehog_V1alpha_SubmitEventResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SubmitEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SubmitEventsRequest, rhs: Prehog_V1alpha_SubmitEventsRequest) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SubmitEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitEventsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SubmitEventsResponse, rhs: Prehog_V1alpha_SubmitEventsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_HelloTeleportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HelloTeleportRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_HelloTeleportRequest, rhs: Prehog_V1alpha_HelloTeleportRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_HelloTeleportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HelloTeleportResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_HelloTeleportResponse, rhs: Prehog_V1alpha_HelloTeleportResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
