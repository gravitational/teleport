// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: prehog/v1alpha/connect.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Prehog_V1alpha_ConnectClusterLoginEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  /// local/github/saml/oidc/passwordless
  public var connectorType: String = String()

  public var arch: String = String()

  public var os: String = String()

  public var osVersion: String = String()

  public var appVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectProtocolUseEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  /// one of ssh/db/kube
  public var `protocol`: String = String()

  /// origin denotes which part of Connect UI was used to access a resource.
  /// One of resource_table/search_bar/connection_list/reopened_session/vnet (optional for backwards
  /// compatibility).
  public var origin: String = String()

  /// access_through describes whether a resource was accessed by speaking to the proxy service
  /// directly, through a local proxy or through VNet.
  /// One of proxy_service/local_proxy/vnet (optional for backwards compatibility).
  public var accessThrough: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectAccessRequestCreateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  /// one of role/resource
  public var kind: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectAccessRequestReviewEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectFileTransferRunEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  public var isUpload: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectUserJobRoleUpdateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Software Engineer, DevOps Engineer etc.
  public var jobRole: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectConnectMyComputerSetup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  public var success: Bool = false

  /// empty when success is true
  public var failedStep: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_ConnectConnectMyComputerAgentStart: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized
  public var clusterName: String = String()

  /// anonymized
  public var userName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Prehog_V1alpha_SubmitConnectEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UUID
  public var distinctID: String = String()

  /// optional, will default to the ingest time if unset
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var event: Prehog_V1alpha_SubmitConnectEventRequest.OneOf_Event? = nil

  public var clusterLogin: Prehog_V1alpha_ConnectClusterLoginEvent {
    get {
      if case .clusterLogin(let v)? = event {return v}
      return Prehog_V1alpha_ConnectClusterLoginEvent()
    }
    set {event = .clusterLogin(newValue)}
  }

  public var protocolUse: Prehog_V1alpha_ConnectProtocolUseEvent {
    get {
      if case .protocolUse(let v)? = event {return v}
      return Prehog_V1alpha_ConnectProtocolUseEvent()
    }
    set {event = .protocolUse(newValue)}
  }

  public var accessRequestCreate: Prehog_V1alpha_ConnectAccessRequestCreateEvent {
    get {
      if case .accessRequestCreate(let v)? = event {return v}
      return Prehog_V1alpha_ConnectAccessRequestCreateEvent()
    }
    set {event = .accessRequestCreate(newValue)}
  }

  public var accessRequestReview: Prehog_V1alpha_ConnectAccessRequestReviewEvent {
    get {
      if case .accessRequestReview(let v)? = event {return v}
      return Prehog_V1alpha_ConnectAccessRequestReviewEvent()
    }
    set {event = .accessRequestReview(newValue)}
  }

  public var accessRequestAssumeRole: Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent {
    get {
      if case .accessRequestAssumeRole(let v)? = event {return v}
      return Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent()
    }
    set {event = .accessRequestAssumeRole(newValue)}
  }

  public var fileTransferRun: Prehog_V1alpha_ConnectFileTransferRunEvent {
    get {
      if case .fileTransferRun(let v)? = event {return v}
      return Prehog_V1alpha_ConnectFileTransferRunEvent()
    }
    set {event = .fileTransferRun(newValue)}
  }

  public var userJobRoleUpdate: Prehog_V1alpha_ConnectUserJobRoleUpdateEvent {
    get {
      if case .userJobRoleUpdate(let v)? = event {return v}
      return Prehog_V1alpha_ConnectUserJobRoleUpdateEvent()
    }
    set {event = .userJobRoleUpdate(newValue)}
  }

  public var connectMyComputerSetup: Prehog_V1alpha_ConnectConnectMyComputerSetup {
    get {
      if case .connectMyComputerSetup(let v)? = event {return v}
      return Prehog_V1alpha_ConnectConnectMyComputerSetup()
    }
    set {event = .connectMyComputerSetup(newValue)}
  }

  public var connectMyComputerAgentStart: Prehog_V1alpha_ConnectConnectMyComputerAgentStart {
    get {
      if case .connectMyComputerAgentStart(let v)? = event {return v}
      return Prehog_V1alpha_ConnectConnectMyComputerAgentStart()
    }
    set {event = .connectMyComputerAgentStart(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable, Sendable {
    case clusterLogin(Prehog_V1alpha_ConnectClusterLoginEvent)
    case protocolUse(Prehog_V1alpha_ConnectProtocolUseEvent)
    case accessRequestCreate(Prehog_V1alpha_ConnectAccessRequestCreateEvent)
    case accessRequestReview(Prehog_V1alpha_ConnectAccessRequestReviewEvent)
    case accessRequestAssumeRole(Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent)
    case fileTransferRun(Prehog_V1alpha_ConnectFileTransferRunEvent)
    case userJobRoleUpdate(Prehog_V1alpha_ConnectUserJobRoleUpdateEvent)
    case connectMyComputerSetup(Prehog_V1alpha_ConnectConnectMyComputerSetup)
    case connectMyComputerAgentStart(Prehog_V1alpha_ConnectConnectMyComputerAgentStart)

  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Prehog_V1alpha_SubmitConnectEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "prehog.v1alpha"

extension Prehog_V1alpha_ConnectClusterLoginEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectClusterLoginEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "connector_type"),
    4: .same(proto: "arch"),
    5: .same(proto: "os"),
    6: .standard(proto: "os_version"),
    7: .standard(proto: "app_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.connectorType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.arch) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.connectorType.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorType, fieldNumber: 3)
    }
    if !self.arch.isEmpty {
      try visitor.visitSingularStringField(value: self.arch, fieldNumber: 4)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 5)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 6)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectClusterLoginEvent, rhs: Prehog_V1alpha_ConnectClusterLoginEvent) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.connectorType != rhs.connectorType {return false}
    if lhs.arch != rhs.arch {return false}
    if lhs.os != rhs.os {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectProtocolUseEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectProtocolUseEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
    3: .same(proto: "protocol"),
    4: .same(proto: "origin"),
    5: .standard(proto: "access_through"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.origin) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.accessThrough) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 3)
    }
    if !self.origin.isEmpty {
      try visitor.visitSingularStringField(value: self.origin, fieldNumber: 4)
    }
    if !self.accessThrough.isEmpty {
      try visitor.visitSingularStringField(value: self.accessThrough, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectProtocolUseEvent, rhs: Prehog_V1alpha_ConnectProtocolUseEvent) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.origin != rhs.origin {return false}
    if lhs.accessThrough != rhs.accessThrough {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectAccessRequestCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectAccessRequestCreateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
    3: .same(proto: "kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectAccessRequestCreateEvent, rhs: Prehog_V1alpha_ConnectAccessRequestCreateEvent) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectAccessRequestReviewEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectAccessRequestReviewEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectAccessRequestReviewEvent, rhs: Prehog_V1alpha_ConnectAccessRequestReviewEvent) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectAccessRequestAssumeRoleEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent, rhs: Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectFileTransferRunEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectFileTransferRunEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
    3: .standard(proto: "is_upload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isUpload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if self.isUpload != false {
      try visitor.visitSingularBoolField(value: self.isUpload, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectFileTransferRunEvent, rhs: Prehog_V1alpha_ConnectFileTransferRunEvent) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.isUpload != rhs.isUpload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectUserJobRoleUpdateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectUserJobRoleUpdateEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobRole) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobRole.isEmpty {
      try visitor.visitSingularStringField(value: self.jobRole, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectUserJobRoleUpdateEvent, rhs: Prehog_V1alpha_ConnectUserJobRoleUpdateEvent) -> Bool {
    if lhs.jobRole != rhs.jobRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectConnectMyComputerSetup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectConnectMyComputerSetup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
    3: .same(proto: "success"),
    4: .standard(proto: "failed_step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.failedStep) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    if !self.failedStep.isEmpty {
      try visitor.visitSingularStringField(value: self.failedStep, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectConnectMyComputerSetup, rhs: Prehog_V1alpha_ConnectConnectMyComputerSetup) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.success != rhs.success {return false}
    if lhs.failedStep != rhs.failedStep {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_ConnectConnectMyComputerAgentStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectConnectMyComputerAgentStart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "user_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_ConnectConnectMyComputerAgentStart, rhs: Prehog_V1alpha_ConnectConnectMyComputerAgentStart) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SubmitConnectEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitConnectEventRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distinct_id"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "cluster_login"),
    4: .standard(proto: "protocol_use"),
    5: .standard(proto: "access_request_create"),
    6: .standard(proto: "access_request_review"),
    7: .standard(proto: "access_request_assume_role"),
    8: .standard(proto: "file_transfer_run"),
    9: .standard(proto: "user_job_role_update"),
    10: .standard(proto: "connect_my_computer_setup"),
    11: .standard(proto: "connect_my_computer_agent_start"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.distinctID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try {
        var v: Prehog_V1alpha_ConnectClusterLoginEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .clusterLogin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .clusterLogin(v)
        }
      }()
      case 4: try {
        var v: Prehog_V1alpha_ConnectProtocolUseEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .protocolUse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .protocolUse(v)
        }
      }()
      case 5: try {
        var v: Prehog_V1alpha_ConnectAccessRequestCreateEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessRequestCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessRequestCreate(v)
        }
      }()
      case 6: try {
        var v: Prehog_V1alpha_ConnectAccessRequestReviewEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessRequestReview(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessRequestReview(v)
        }
      }()
      case 7: try {
        var v: Prehog_V1alpha_ConnectAccessRequestAssumeRoleEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessRequestAssumeRole(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessRequestAssumeRole(v)
        }
      }()
      case 8: try {
        var v: Prehog_V1alpha_ConnectFileTransferRunEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .fileTransferRun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .fileTransferRun(v)
        }
      }()
      case 9: try {
        var v: Prehog_V1alpha_ConnectUserJobRoleUpdateEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userJobRoleUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userJobRoleUpdate(v)
        }
      }()
      case 10: try {
        var v: Prehog_V1alpha_ConnectConnectMyComputerSetup?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .connectMyComputerSetup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .connectMyComputerSetup(v)
        }
      }()
      case 11: try {
        var v: Prehog_V1alpha_ConnectConnectMyComputerAgentStart?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .connectMyComputerAgentStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .connectMyComputerAgentStart(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.distinctID.isEmpty {
      try visitor.visitSingularStringField(value: self.distinctID, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.event {
    case .clusterLogin?: try {
      guard case .clusterLogin(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .protocolUse?: try {
      guard case .protocolUse(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .accessRequestCreate?: try {
      guard case .accessRequestCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .accessRequestReview?: try {
      guard case .accessRequestReview(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .accessRequestAssumeRole?: try {
      guard case .accessRequestAssumeRole(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .fileTransferRun?: try {
      guard case .fileTransferRun(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .userJobRoleUpdate?: try {
      guard case .userJobRoleUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .connectMyComputerSetup?: try {
      guard case .connectMyComputerSetup(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .connectMyComputerAgentStart?: try {
      guard case .connectMyComputerAgentStart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SubmitConnectEventRequest, rhs: Prehog_V1alpha_SubmitConnectEventRequest) -> Bool {
    if lhs.distinctID != rhs.distinctID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SubmitConnectEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitConnectEventResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Prehog_V1alpha_SubmitConnectEventResponse, rhs: Prehog_V1alpha_SubmitConnectEventResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
