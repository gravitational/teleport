// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/lib/teleterm/v1/service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PasswordlessPrompt describes different prompts we need from users
/// during the passwordless login flow.
public enum Teleport_Lib_Teleterm_V1_PasswordlessPrompt: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// PASSWORDLESS_PROMPT_PIN is used when we need a user's pin.
  case pin // = 1

  /// PASSWORDLESS_PROMPT_TAP is used when we require a user to tap their device.
  case tap // = 2

  /// PASSWORDLESS_PROMPT_CREDENTIAL is used when we require a user to select a username
  /// associated with their account.
  case credential // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pin
    case 2: self = .tap
    case 3: self = .credential
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pin: return 1
    case .tap: return 2
    case .credential: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Teleport_Lib_Teleterm_V1_PasswordlessPrompt] = [
    .unspecified,
    .pin,
    .tap,
    .credential,
  ]

}

/// FileTransferDirection describes directions of a file transfer
public enum Teleport_Lib_Teleterm_V1_FileTransferDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case download // = 1
  case upload // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .download
    case 2: self = .upload
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .download: return 1
    case .upload: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Teleport_Lib_Teleterm_V1_FileTransferDirection] = [
    .unspecified,
    .download,
    .upload,
  ]

}

/// HeadlessAuthenticationState is a headless authentication state.
public enum Teleport_Lib_Teleterm_V1_HeadlessAuthenticationState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case pending // = 1
  case denied // = 2
  case approved // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .denied
    case 3: self = .approved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .denied: return 2
    case .approved: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Teleport_Lib_Teleterm_V1_HeadlessAuthenticationState] = [
    .unspecified,
    .pending,
    .denied,
    .approved,
  ]

}

public struct Teleport_Lib_Teleterm_V1_EmptyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// RemoveClusterRequest describes RemoveClusterRequest
public struct Teleport_Lib_Teleterm_V1_RemoveClusterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetClusterRequest describes GetClusterRequest
public struct Teleport_Lib_Teleterm_V1_GetClusterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LogoutRequest describes LogoutRequest
public struct Teleport_Lib_Teleterm_V1_LogoutRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_StartHeadlessWatcherRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_StartHeadlessWatcherResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetAccessRequestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  /// specifcies a specific request id
  public var accessRequestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetAccessRequestsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cluster_uri is the cluster uri
  public var clusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetAccessRequestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Teleport_Lib_Teleterm_V1_AccessRequest {
    get {return _request ?? Teleport_Lib_Teleterm_V1_AccessRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: Teleport_Lib_Teleterm_V1_AccessRequest? = nil
}

public struct Teleport_Lib_Teleterm_V1_GetAccessRequestsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requests: [Teleport_Lib_Teleterm_V1_AccessRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_DeleteAccessRequestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var accessRequestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_CreateAccessRequestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var reason: String = String()

  /// a list of roles requested
  public var roles: [String] = []

  /// suggested_reviewers is a suggested list of reviewers that can review a request.
  public var suggestedReviewers: [String] = []

  /// TODO(avatus) remove the resource_ids field once the changes to rely on resources instead is merged
  /// a list of resourceIDs requested in the AccessRequest
  public var resourceIds: [Teleport_Lib_Teleterm_V1_ResourceID] = []

  /// assume_start_time is the time after which the requested access can be assumed.
  public var assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _assumeStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_assumeStartTime = newValue}
  }
  /// Returns true if `assumeStartTime` has been explicitly set.
  public var hasAssumeStartTime: Bool {return self._assumeStartTime != nil}
  /// Clears the value of `assumeStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearAssumeStartTime() {self._assumeStartTime = nil}

  /// dry_run is a flag that indicates whether the request is a dry run to check and set defaults,
  /// and return before actually creating the request in the backend.
  public var dryRun: Bool = false

  /// max_duration is the maximum duration for which the request is valid.
  public var maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _maxDuration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_maxDuration = newValue}
  }
  /// Returns true if `maxDuration` has been explicitly set.
  public var hasMaxDuration: Bool {return self._maxDuration != nil}
  /// Clears the value of `maxDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxDuration() {self._maxDuration = nil}

  /// request_ttl is the expiration time of the request (how long it will await
  /// approval).
  public var requestTtl: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _requestTtl ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_requestTtl = newValue}
  }
  /// Returns true if `requestTtl` has been explicitly set.
  public var hasRequestTtl: Bool {return self._requestTtl != nil}
  /// Clears the value of `requestTtl`. Subsequent reads from it will return its default value.
  public mutating func clearRequestTtl() {self._requestTtl = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _requestTtl: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Teleport_Lib_Teleterm_V1_CreateAccessRequestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Teleport_Lib_Teleterm_V1_AccessRequest {
    get {return _request ?? Teleport_Lib_Teleterm_V1_AccessRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: Teleport_Lib_Teleterm_V1_AccessRequest? = nil
}

public struct Teleport_Lib_Teleterm_V1_AssumeRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var accessRequestIds: [String] = []

  public var dropRequestIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetRequestableRolesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var resourceIds: [Teleport_Lib_Teleterm_V1_ResourceID] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetRequestableRolesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var roles: [String] = []

  public var applicableRoles: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ReviewAccessRequestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var state: String = String()

  public var reason: String = String()

  public var roles: [String] = []

  public var accessRequestID: String = String()

  /// Overwrites the requested start time (optional).
  public var assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _assumeStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_assumeStartTime = newValue}
  }
  /// Returns true if `assumeStartTime` has been explicitly set.
  public var hasAssumeStartTime: Bool {return self._assumeStartTime != nil}
  /// Clears the value of `assumeStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearAssumeStartTime() {self._assumeStartTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Teleport_Lib_Teleterm_V1_ReviewAccessRequestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Teleport_Lib_Teleterm_V1_AccessRequest {
    get {return _request ?? Teleport_Lib_Teleterm_V1_AccessRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: Teleport_Lib_Teleterm_V1_AccessRequest? = nil
}

public struct Teleport_Lib_Teleterm_V1_PromoteAccessRequestRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var accessListID: String = String()

  public var reason: String = String()

  public var accessRequestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_PromoteAccessRequestResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Teleport_Lib_Teleterm_V1_AccessRequest {
    get {return _request ?? Teleport_Lib_Teleterm_V1_AccessRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: Teleport_Lib_Teleterm_V1_AccessRequest? = nil
}

public struct Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var accessRequestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accessLists: [Teleport_Accesslist_V1_AccessList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListKubernetesResourcesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  /// ResourceType is the Kubernetes resource that is going to be retrieved.
  public var resourceType: String = String()

  /// Limit is the maximum amount of resources to retrieve.
  public var limit: Int32 = 0

  /// NextKey is used to start listing resources from a specific spot. It
  /// should be set to the previous NextKey value if using pagination, or
  /// left empty.
  public var nextKey: String = String()

  /// PredicateExpression defines boolean conditions that will be matched against the resource.
  public var predicateExpression: String = String()

  /// SearchKeywords is a string containing search keywords to match against resource field values.
  public var searchKeywords: String = String()

  /// UseSearchAsRoles indicates that the response should include all resources
  /// the caller is able to request access to using search_as_roles
  public var useSearchAsRoles: Bool = false

  /// Cluster is the Kubernetes Cluster to request the resources.
  public var kubernetesCluster: String = String()

  /// Namespace is the Kubernetes namespace where the resources must be located.
  /// To search on every Kubernetes Namespace, do not define the value.
  public var kubernetesNamespace: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListKubernetesResourcesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resources: [Teleport_Lib_Teleterm_V1_KubeResource] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CredentialInfo holds fields related to a user's WebAuthn credential.
public struct Teleport_Lib_Teleterm_V1_CredentialInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LoginPasswordlessResponse is a message sent by the server during the
/// passwordless login flow.
public struct Teleport_Lib_Teleterm_V1_LoginPasswordlessResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var prompt: Teleport_Lib_Teleterm_V1_PasswordlessPrompt = .unspecified

  public var credentials: [Teleport_Lib_Teleterm_V1_CredentialInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LoginPasswordlessRequest is a message sent by the client during the passwordless login flow.
public struct Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.OneOf_Request? = nil

  public var init_p: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessRequestInit {
    get {
      if case .init_p(let v)? = request {return v}
      return Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessRequestInit()
    }
    set {request = .init_p(newValue)}
  }

  public var pin: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessPINResponse {
    get {
      if case .pin(let v)? = request {return v}
      return Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessPINResponse()
    }
    set {request = .pin(newValue)}
  }

  public var credential: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessCredentialResponse {
    get {
      if case .credential(let v)? = request {return v}
      return Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessCredentialResponse()
    }
    set {request = .credential(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case init_p(Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessRequestInit)
    case pin(Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessPINResponse)
    case credential(Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessCredentialResponse)

  }

  /// LoginPasswordlessRequestInit contains fields needed to init the stream request.
  public struct LoginPasswordlessRequestInit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// cluster_uri is needed to resolve cluster by its uri.
    public var clusterUri: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// LoginPasswordlessPINResponse contains fields related to request from webauthncli.PromptPIN.
  public struct LoginPasswordlessPINResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// pin is the user's device's pin.
    public var pin: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// LoginPasswordlessPINResponse contains fields related to request from
  /// webauthncli.PromptCredential.
  public struct LoginPasswordlessCredentialResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// index is the associated number in the list of credentials that the user selected to log
    /// in as.
    public var index: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_FileTransferRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// login is the SSH username to use for the transfer.
  public var login: String = String()

  /// source path of the transferred file.
  public var source: String = String()

  /// destination path of the transferred file.
  public var destination: String = String()

  /// direction indicates whether the file is uploaded/downloaded.
  public var direction: Teleport_Lib_Teleterm_V1_FileTransferDirection = .unspecified

  public var serverUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_FileTransferProgress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var percentage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LoginRequest describes cluster login request
public struct Teleport_Lib_Teleterm_V1_LoginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cluster_uri is the cluster uri
  public var clusterUri: String = String()

  public var params: Teleport_Lib_Teleterm_V1_LoginRequest.OneOf_Params? = nil

  /// local holds parameters for local logins
  public var local: Teleport_Lib_Teleterm_V1_LoginRequest.LocalParams {
    get {
      if case .local(let v)? = params {return v}
      return Teleport_Lib_Teleterm_V1_LoginRequest.LocalParams()
    }
    set {params = .local(newValue)}
  }

  /// sso holds parameters for sso logins
  public var sso: Teleport_Lib_Teleterm_V1_LoginRequest.SsoParams {
    get {
      if case .sso(let v)? = params {return v}
      return Teleport_Lib_Teleterm_V1_LoginRequest.SsoParams()
    }
    set {params = .sso(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Params: Equatable, Sendable {
    /// local holds parameters for local logins
    case local(Teleport_Lib_Teleterm_V1_LoginRequest.LocalParams)
    /// sso holds parameters for sso logins
    case sso(Teleport_Lib_Teleterm_V1_LoginRequest.SsoParams)

  }

  /// LocalParams describes parameters for local user logins
  public struct LocalParams: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// user is the user name
    public var user: String = String()

    /// password is the user password
    public var password: String = String()

    /// token is the 2FA token
    public var token: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// SsoParams describes SSO parameters
  public struct SsoParams: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// provider_type is the provider type
    public var providerType: String = String()

    /// provider_name is the provider name
    public var providerName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_AddClusterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListClustersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListClustersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusters: [Teleport_Lib_Teleterm_V1_Cluster] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListLeafClustersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListDatabaseUsersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dbUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListDatabaseUsersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var users: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_CreateGatewayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetUri: String = String()

  public var targetUser: String = String()

  public var localPort: String = String()

  public var targetSubresourceName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListGatewaysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListGatewaysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gateways: [Teleport_Lib_Teleterm_V1_Gateway] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_RemoveGatewayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gatewayUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_SetGatewayTargetSubresourceNameRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gatewayUri: String = String()

  public var targetSubresourceName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_SetGatewayLocalPortRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gatewayUri: String = String()

  public var localPort: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetServersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var limit: Int32 = 0

  public var startKey: String = String()

  public var search: String = String()

  public var query: String = String()

  public var sortBy: String = String()

  public var searchAsRoles: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetServersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var agents: [Teleport_Lib_Teleterm_V1_Server] = []

  public var totalCount: Int32 = 0

  public var startKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetAuthSettingsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var headlessAuthenticationID: String = String()

  public var state: Teleport_Lib_Teleterm_V1_HeadlessAuthenticationState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// certs_reloaded signals to the Electron app that tshd has reloaded the certs in order to refresh
  /// the role list. The Electron app should refresh the details from the user cert as well.
  public var certsReloaded: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var server: Teleport_Lib_Teleterm_V1_Server {
    get {return _server ?? Teleport_Lib_Teleterm_V1_Server()}
    set {_server = newValue}
  }
  /// Returns true if `server` has been explicitly set.
  public var hasServer: Bool {return self._server != nil}
  /// Clears the value of `server`. Subsequent reads from it will return its default value.
  public mutating func clearServer() {self._server = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _server: Teleport_Lib_Teleterm_V1_Server? = nil
}

public struct Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListUnifiedResourcesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  /// A list of kinds to match against a resource's kind. This can be used in a
  /// unified resource request that can include multiple types.
  public var kinds: [String] = []

  /// The maximum number of resources to retrieve.
  public var limit: Int32 = 0

  /// Starts listing resources from a specific spot.
  /// It should be set to the next_key from ListUnifiedResourcesResponse if
  /// using pagination, or left empty.
  public var startKey: String = String()

  /// If defined, the advanced search is used. The search field should be left empty.
  public var query: String = String()

  /// If defined, the regular search is used. The query field should be left empty.
  public var search: String = String()

  /// SortBy describes which resource field and which direction to sort by.
  public var sortBy: Teleport_Lib_Teleterm_V1_SortBy {
    get {return _sortBy ?? Teleport_Lib_Teleterm_V1_SortBy()}
    set {_sortBy = newValue}
  }
  /// Returns true if `sortBy` has been explicitly set.
  public var hasSortBy: Bool {return self._sortBy != nil}
  /// Clears the value of `sortBy`. Subsequent reads from it will return its default value.
  public mutating func clearSortBy() {self._sortBy = nil}

  /// When true, all resources that the user can request access to are returned.
  public var searchAsRoles: Bool = false

  /// Only the pinned resources will be returned for the requesting user.
  public var pinnedOnly: Bool = false

  /// include_requestable indicates that the response should include resources that the user must request access to.
  public var includeRequestable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sortBy: Teleport_Lib_Teleterm_V1_SortBy? = nil
}

public struct Teleport_Lib_Teleterm_V1_SortBy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sort direction flag where if true the direction is descending, else ascending.
  public var isDesc: Bool = false

  /// Name of an object's field to sort by. Resources can be sorted by name and kind.
  public var field: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_ListUnifiedResourcesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resources: [Teleport_Lib_Teleterm_V1_PaginatedResource] = []

  /// A key to use as start_key in a ListResourcesRequest to continue retrieving
  /// the next pages. If it is empty, there are no more pages.
  public var nextKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_PaginatedResource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resource: Teleport_Lib_Teleterm_V1_PaginatedResource.OneOf_Resource? = nil

  public var database: Teleport_Lib_Teleterm_V1_Database {
    get {
      if case .database(let v)? = resource {return v}
      return Teleport_Lib_Teleterm_V1_Database()
    }
    set {resource = .database(newValue)}
  }

  public var server: Teleport_Lib_Teleterm_V1_Server {
    get {
      if case .server(let v)? = resource {return v}
      return Teleport_Lib_Teleterm_V1_Server()
    }
    set {resource = .server(newValue)}
  }

  public var kube: Teleport_Lib_Teleterm_V1_Kube {
    get {
      if case .kube(let v)? = resource {return v}
      return Teleport_Lib_Teleterm_V1_Kube()
    }
    set {resource = .kube(newValue)}
  }

  public var app: Teleport_Lib_Teleterm_V1_App {
    get {
      if case .app(let v)? = resource {return v}
      return Teleport_Lib_Teleterm_V1_App()
    }
    set {resource = .app(newValue)}
  }

  public var requiresRequest: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Resource: Equatable, Sendable {
    case database(Teleport_Lib_Teleterm_V1_Database)
    case server(Teleport_Lib_Teleterm_V1_Server)
    case kube(Teleport_Lib_Teleterm_V1_Kube)
    case app(Teleport_Lib_Teleterm_V1_App)

  }

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetUserPreferencesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetUserPreferencesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userPreferences: Teleport_Lib_Teleterm_V1_UserPreferences {
    get {return _userPreferences ?? Teleport_Lib_Teleterm_V1_UserPreferences()}
    set {_userPreferences = newValue}
  }
  /// Returns true if `userPreferences` has been explicitly set.
  public var hasUserPreferences: Bool {return self._userPreferences != nil}
  /// Clears the value of `userPreferences`. Subsequent reads from it will return its default value.
  public mutating func clearUserPreferences() {self._userPreferences = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userPreferences: Teleport_Lib_Teleterm_V1_UserPreferences? = nil
}

public struct Teleport_Lib_Teleterm_V1_UpdateUserPreferencesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterUri: String = String()

  public var userPreferences: Teleport_Lib_Teleterm_V1_UserPreferences {
    get {return _userPreferences ?? Teleport_Lib_Teleterm_V1_UserPreferences()}
    set {_userPreferences = newValue}
  }
  /// Returns true if `userPreferences` has been explicitly set.
  public var hasUserPreferences: Bool {return self._userPreferences != nil}
  /// Clears the value of `userPreferences`. Subsequent reads from it will return its default value.
  public mutating func clearUserPreferences() {self._userPreferences = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userPreferences: Teleport_Lib_Teleterm_V1_UserPreferences? = nil
}

public struct Teleport_Lib_Teleterm_V1_UpdateUserPreferencesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userPreferences: Teleport_Lib_Teleterm_V1_UserPreferences {
    get {return _userPreferences ?? Teleport_Lib_Teleterm_V1_UserPreferences()}
    set {_userPreferences = newValue}
  }
  /// Returns true if `userPreferences` has been explicitly set.
  public var hasUserPreferences: Bool {return self._userPreferences != nil}
  /// Clears the value of `userPreferences`. Subsequent reads from it will return its default value.
  public mutating func clearUserPreferences() {self._userPreferences = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userPreferences: Teleport_Lib_Teleterm_V1_UserPreferences? = nil
}

/// UserPreferences is a subset of teleport.userpreferences.v1.UserPreferences.
/// It contains preferences that are relevant to Connect.
public struct Teleport_Lib_Teleterm_V1_UserPreferences: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterPreferences: Teleport_Userpreferences_V1_ClusterUserPreferences {
    get {return _clusterPreferences ?? Teleport_Userpreferences_V1_ClusterUserPreferences()}
    set {_clusterPreferences = newValue}
  }
  /// Returns true if `clusterPreferences` has been explicitly set.
  public var hasClusterPreferences: Bool {return self._clusterPreferences != nil}
  /// Clears the value of `clusterPreferences`. Subsequent reads from it will return its default value.
  public mutating func clearClusterPreferences() {self._clusterPreferences = nil}

  public var unifiedResourcePreferences: Teleport_Userpreferences_V1_UnifiedResourcePreferences {
    get {return _unifiedResourcePreferences ?? Teleport_Userpreferences_V1_UnifiedResourcePreferences()}
    set {_unifiedResourcePreferences = newValue}
  }
  /// Returns true if `unifiedResourcePreferences` has been explicitly set.
  public var hasUnifiedResourcePreferences: Bool {return self._unifiedResourcePreferences != nil}
  /// Clears the value of `unifiedResourcePreferences`. Subsequent reads from it will return its default value.
  public mutating func clearUnifiedResourcePreferences() {self._unifiedResourcePreferences = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clusterPreferences: Teleport_Userpreferences_V1_ClusterUserPreferences? = nil
  fileprivate var _unifiedResourcePreferences: Teleport_Userpreferences_V1_UnifiedResourcePreferences? = nil
}

/// Request for AuthenticateWebDevice.
public struct Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device web token to be spent in exchange for the device authentication
  /// attempt.
  public var deviceWebToken: Teleport_Devicetrust_V1_DeviceWebToken {
    get {return _deviceWebToken ?? Teleport_Devicetrust_V1_DeviceWebToken()}
    set {_deviceWebToken = newValue}
  }
  /// Returns true if `deviceWebToken` has been explicitly set.
  public var hasDeviceWebToken: Bool {return self._deviceWebToken != nil}
  /// Clears the value of `deviceWebToken`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceWebToken() {self._deviceWebToken = nil}

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceWebToken: Teleport_Devicetrust_V1_DeviceWebToken? = nil
}

/// Response for AuthenticateWebDevice.
public struct Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device confirmation token to be sent to the browser that originated the
  /// authentication attempt.
  public var confirmationToken: Teleport_Devicetrust_V1_DeviceConfirmationToken {
    get {return _confirmationToken ?? Teleport_Devicetrust_V1_DeviceConfirmationToken()}
    set {_confirmationToken = newValue}
  }
  /// Returns true if `confirmationToken` has been explicitly set.
  public var hasConfirmationToken: Bool {return self._confirmationToken != nil}
  /// Clears the value of `confirmationToken`. Subsequent reads from it will return its default value.
  public mutating func clearConfirmationToken() {self._confirmationToken = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _confirmationToken: Teleport_Devicetrust_V1_DeviceConfirmationToken? = nil
}

public struct Teleport_Lib_Teleterm_V1_GetAppRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Teleport_Lib_Teleterm_V1_GetAppResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var app: Teleport_Lib_Teleterm_V1_App {
    get {return _app ?? Teleport_Lib_Teleterm_V1_App()}
    set {_app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return self._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {self._app = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _app: Teleport_Lib_Teleterm_V1_App? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.lib.teleterm.v1"

extension Teleport_Lib_Teleterm_V1_PasswordlessPrompt: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PASSWORDLESS_PROMPT_UNSPECIFIED"),
    1: .same(proto: "PASSWORDLESS_PROMPT_PIN"),
    2: .same(proto: "PASSWORDLESS_PROMPT_TAP"),
    3: .same(proto: "PASSWORDLESS_PROMPT_CREDENTIAL"),
  ]
}

extension Teleport_Lib_Teleterm_V1_FileTransferDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILE_TRANSFER_DIRECTION_UNSPECIFIED"),
    1: .same(proto: "FILE_TRANSFER_DIRECTION_DOWNLOAD"),
    2: .same(proto: "FILE_TRANSFER_DIRECTION_UPLOAD"),
  ]
}

extension Teleport_Lib_Teleterm_V1_HeadlessAuthenticationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED"),
    1: .same(proto: "HEADLESS_AUTHENTICATION_STATE_PENDING"),
    2: .same(proto: "HEADLESS_AUTHENTICATION_STATE_DENIED"),
    3: .same(proto: "HEADLESS_AUTHENTICATION_STATE_APPROVED"),
  ]
}

extension Teleport_Lib_Teleterm_V1_EmptyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmptyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_EmptyResponse, rhs: Teleport_Lib_Teleterm_V1_EmptyResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_RemoveClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_RemoveClusterRequest, rhs: Teleport_Lib_Teleterm_V1_RemoveClusterRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetClusterRequest, rhs: Teleport_Lib_Teleterm_V1_GetClusterRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LogoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LogoutRequest, rhs: Teleport_Lib_Teleterm_V1_LogoutRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_StartHeadlessWatcherRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartHeadlessWatcherRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_StartHeadlessWatcherRequest, rhs: Teleport_Lib_Teleterm_V1_StartHeadlessWatcherRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_StartHeadlessWatcherResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartHeadlessWatcherResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_StartHeadlessWatcherResponse, rhs: Teleport_Lib_Teleterm_V1_StartHeadlessWatcherResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetAccessRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccessRequestRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
    2: .standard(proto: "access_request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessRequestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    if !self.accessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetAccessRequestRequest, rhs: Teleport_Lib_Teleterm_V1_GetAccessRequestRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.accessRequestID != rhs.accessRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetAccessRequestsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccessRequestsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetAccessRequestsRequest, rhs: Teleport_Lib_Teleterm_V1_GetAccessRequestsRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetAccessRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccessRequestResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetAccessRequestResponse, rhs: Teleport_Lib_Teleterm_V1_GetAccessRequestResponse) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetAccessRequestsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccessRequestsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetAccessRequestsResponse, rhs: Teleport_Lib_Teleterm_V1_GetAccessRequestsResponse) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_DeleteAccessRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAccessRequestRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "access_request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessRequestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.accessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_DeleteAccessRequestRequest, rhs: Teleport_Lib_Teleterm_V1_DeleteAccessRequestRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.accessRequestID != rhs.accessRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CreateAccessRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAccessRequestRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .same(proto: "reason"),
    3: .same(proto: "roles"),
    4: .standard(proto: "suggested_reviewers"),
    5: .standard(proto: "resource_ids"),
    6: .standard(proto: "assume_start_time"),
    7: .standard(proto: "dry_run"),
    8: .standard(proto: "max_duration"),
    9: .standard(proto: "request_ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.suggestedReviewers) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.resourceIds) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._assumeStartTime) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._maxDuration) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._requestTtl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 3)
    }
    if !self.suggestedReviewers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.suggestedReviewers, fieldNumber: 4)
    }
    if !self.resourceIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceIds, fieldNumber: 5)
    }
    try { if let v = self._assumeStartTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 7)
    }
    try { if let v = self._maxDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._requestTtl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CreateAccessRequestRequest, rhs: Teleport_Lib_Teleterm_V1_CreateAccessRequestRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.suggestedReviewers != rhs.suggestedReviewers {return false}
    if lhs.resourceIds != rhs.resourceIds {return false}
    if lhs._assumeStartTime != rhs._assumeStartTime {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs._maxDuration != rhs._maxDuration {return false}
    if lhs._requestTtl != rhs._requestTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CreateAccessRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAccessRequestResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CreateAccessRequestResponse, rhs: Teleport_Lib_Teleterm_V1_CreateAccessRequestResponse) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_AssumeRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssumeRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "access_request_ids"),
    3: .standard(proto: "drop_request_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.accessRequestIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.dropRequestIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.accessRequestIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accessRequestIds, fieldNumber: 2)
    }
    if !self.dropRequestIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dropRequestIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_AssumeRoleRequest, rhs: Teleport_Lib_Teleterm_V1_AssumeRoleRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.accessRequestIds != rhs.accessRequestIds {return false}
    if lhs.dropRequestIds != rhs.dropRequestIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetRequestableRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRequestableRolesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
    2: .standard(proto: "resource_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.resourceIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    if !self.resourceIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetRequestableRolesRequest, rhs: Teleport_Lib_Teleterm_V1_GetRequestableRolesRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.resourceIds != rhs.resourceIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetRequestableRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRequestableRolesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .standard(proto: "applicable_roles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.applicableRoles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.applicableRoles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.applicableRoles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetRequestableRolesResponse, rhs: Teleport_Lib_Teleterm_V1_GetRequestableRolesResponse) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.applicableRoles != rhs.applicableRoles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ReviewAccessRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReviewAccessRequestRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .same(proto: "state"),
    3: .same(proto: "reason"),
    4: .same(proto: "roles"),
    5: .standard(proto: "access_request_id"),
    6: .standard(proto: "assume_start_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.accessRequestID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._assumeStartTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 4)
    }
    if !self.accessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequestID, fieldNumber: 5)
    }
    try { if let v = self._assumeStartTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ReviewAccessRequestRequest, rhs: Teleport_Lib_Teleterm_V1_ReviewAccessRequestRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.state != rhs.state {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.accessRequestID != rhs.accessRequestID {return false}
    if lhs._assumeStartTime != rhs._assumeStartTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ReviewAccessRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReviewAccessRequestResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ReviewAccessRequestResponse, rhs: Teleport_Lib_Teleterm_V1_ReviewAccessRequestResponse) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromoteAccessRequestRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromoteAccessRequestRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "access_list_id"),
    3: .same(proto: "reason"),
    4: .standard(proto: "access_request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessListID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.accessRequestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.accessListID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListID, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if !self.accessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequestID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromoteAccessRequestRequest, rhs: Teleport_Lib_Teleterm_V1_PromoteAccessRequestRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.accessListID != rhs.accessListID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.accessRequestID != rhs.accessRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromoteAccessRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromoteAccessRequestResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromoteAccessRequestResponse, rhs: Teleport_Lib_Teleterm_V1_PromoteAccessRequestResponse) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSuggestedAccessListsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "access_request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessRequestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.accessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsRequest, rhs: Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.accessRequestID != rhs.accessRequestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSuggestedAccessListsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_lists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessLists) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsResponse, rhs: Teleport_Lib_Teleterm_V1_GetSuggestedAccessListsResponse) -> Bool {
    if lhs.accessLists != rhs.accessLists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListKubernetesResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKubernetesResourcesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
    2: .standard(proto: "resource_type"),
    3: .same(proto: "limit"),
    4: .standard(proto: "next_key"),
    5: .standard(proto: "predicate_expression"),
    6: .standard(proto: "search_keywords"),
    7: .standard(proto: "use_search_as_roles"),
    8: .standard(proto: "kubernetes_cluster"),
    9: .standard(proto: "kubernetes_namespace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.predicateExpression) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.searchKeywords) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.useSearchAsRoles) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.kubernetesCluster) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.kubernetesNamespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 4)
    }
    if !self.predicateExpression.isEmpty {
      try visitor.visitSingularStringField(value: self.predicateExpression, fieldNumber: 5)
    }
    if !self.searchKeywords.isEmpty {
      try visitor.visitSingularStringField(value: self.searchKeywords, fieldNumber: 6)
    }
    if self.useSearchAsRoles != false {
      try visitor.visitSingularBoolField(value: self.useSearchAsRoles, fieldNumber: 7)
    }
    if !self.kubernetesCluster.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesCluster, fieldNumber: 8)
    }
    if !self.kubernetesNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.kubernetesNamespace, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListKubernetesResourcesRequest, rhs: Teleport_Lib_Teleterm_V1_ListKubernetesResourcesRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.predicateExpression != rhs.predicateExpression {return false}
    if lhs.searchKeywords != rhs.searchKeywords {return false}
    if lhs.useSearchAsRoles != rhs.useSearchAsRoles {return false}
    if lhs.kubernetesCluster != rhs.kubernetesCluster {return false}
    if lhs.kubernetesNamespace != rhs.kubernetesNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListKubernetesResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKubernetesResourcesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resources"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListKubernetesResourcesResponse, rhs: Teleport_Lib_Teleterm_V1_ListKubernetesResourcesResponse) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CredentialInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CredentialInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CredentialInfo, rhs: Teleport_Lib_Teleterm_V1_CredentialInfo) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginPasswordlessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginPasswordlessResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prompt"),
    2: .same(proto: "credentials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.prompt) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.credentials) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.prompt != .unspecified {
      try visitor.visitSingularEnumField(value: self.prompt, fieldNumber: 1)
    }
    if !self.credentials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credentials, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessResponse, rhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessResponse) -> Bool {
    if lhs.prompt != rhs.prompt {return false}
    if lhs.credentials != rhs.credentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginPasswordlessRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "pin"),
    3: .same(proto: "credential"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessRequestInit?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .init_p(v)
        }
      }()
      case 2: try {
        var v: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessPINResponse?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .pin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .pin(v)
        }
      }()
      case 3: try {
        var v: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessCredentialResponse?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .credential(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .credential(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .init_p?: try {
      guard case .init_p(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pin?: try {
      guard case .pin(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .credential?: try {
      guard case .credential(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest, rhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessRequestInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.protoMessageName + ".LoginPasswordlessRequestInit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessRequestInit, rhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessRequestInit) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessPINResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.protoMessageName + ".LoginPasswordlessPINResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessPINResponse, rhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessPINResponse) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessCredentialResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.protoMessageName + ".LoginPasswordlessCredentialResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessCredentialResponse, rhs: Teleport_Lib_Teleterm_V1_LoginPasswordlessRequest.LoginPasswordlessCredentialResponse) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_FileTransferRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileTransferRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "login"),
    4: .same(proto: "source"),
    5: .same(proto: "destination"),
    6: .same(proto: "direction"),
    7: .standard(proto: "server_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.login) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.serverUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.login.isEmpty {
      try visitor.visitSingularStringField(value: self.login, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 4)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 5)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 6)
    }
    if !self.serverUri.isEmpty {
      try visitor.visitSingularStringField(value: self.serverUri, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_FileTransferRequest, rhs: Teleport_Lib_Teleterm_V1_FileTransferRequest) -> Bool {
    if lhs.login != rhs.login {return false}
    if lhs.source != rhs.source {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.serverUri != rhs.serverUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_FileTransferProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileTransferProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.percentage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percentage != 0 {
      try visitor.visitSingularUInt32Field(value: self.percentage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_FileTransferProgress, rhs: Teleport_Lib_Teleterm_V1_FileTransferProgress) -> Bool {
    if lhs.percentage != rhs.percentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
    2: .same(proto: "local"),
    3: .same(proto: "sso"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 2: try {
        var v: Teleport_Lib_Teleterm_V1_LoginRequest.LocalParams?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .local(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .local(v)
        }
      }()
      case 3: try {
        var v: Teleport_Lib_Teleterm_V1_LoginRequest.SsoParams?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .sso(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .sso(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    switch self.params {
    case .local?: try {
      guard case .local(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sso?: try {
      guard case .sso(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginRequest, rhs: Teleport_Lib_Teleterm_V1_LoginRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginRequest.LocalParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Teleport_Lib_Teleterm_V1_LoginRequest.protoMessageName + ".LocalParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "password"),
    3: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginRequest.LocalParams, rhs: Teleport_Lib_Teleterm_V1_LoginRequest.LocalParams) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.password != rhs.password {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoginRequest.SsoParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Teleport_Lib_Teleterm_V1_LoginRequest.protoMessageName + ".SsoParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_type"),
    2: .standard(proto: "provider_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.providerType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.providerName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providerType.isEmpty {
      try visitor.visitSingularStringField(value: self.providerType, fieldNumber: 1)
    }
    if !self.providerName.isEmpty {
      try visitor.visitSingularStringField(value: self.providerName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoginRequest.SsoParams, rhs: Teleport_Lib_Teleterm_V1_LoginRequest.SsoParams) -> Bool {
    if lhs.providerType != rhs.providerType {return false}
    if lhs.providerName != rhs.providerName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_AddClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_AddClusterRequest, rhs: Teleport_Lib_Teleterm_V1_AddClusterRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListClustersRequest, rhs: Teleport_Lib_Teleterm_V1_ListClustersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListClustersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListClustersResponse, rhs: Teleport_Lib_Teleterm_V1_ListClustersResponse) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListLeafClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListLeafClustersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListLeafClustersRequest, rhs: Teleport_Lib_Teleterm_V1_ListLeafClustersRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListDatabaseUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatabaseUsersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "db_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dbUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dbUri.isEmpty {
      try visitor.visitSingularStringField(value: self.dbUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListDatabaseUsersRequest, rhs: Teleport_Lib_Teleterm_V1_ListDatabaseUsersRequest) -> Bool {
    if lhs.dbUri != rhs.dbUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListDatabaseUsersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatabaseUsersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedStringField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListDatabaseUsersResponse, rhs: Teleport_Lib_Teleterm_V1_ListDatabaseUsersResponse) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CreateGatewayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGatewayRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_uri"),
    2: .standard(proto: "target_user"),
    3: .standard(proto: "local_port"),
    4: .standard(proto: "target_subresource_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetUser) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.localPort) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetSubresourceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetUri.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUri, fieldNumber: 1)
    }
    if !self.targetUser.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUser, fieldNumber: 2)
    }
    if !self.localPort.isEmpty {
      try visitor.visitSingularStringField(value: self.localPort, fieldNumber: 3)
    }
    if !self.targetSubresourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.targetSubresourceName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CreateGatewayRequest, rhs: Teleport_Lib_Teleterm_V1_CreateGatewayRequest) -> Bool {
    if lhs.targetUri != rhs.targetUri {return false}
    if lhs.targetUser != rhs.targetUser {return false}
    if lhs.localPort != rhs.localPort {return false}
    if lhs.targetSubresourceName != rhs.targetSubresourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListGatewaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGatewaysRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListGatewaysRequest, rhs: Teleport_Lib_Teleterm_V1_ListGatewaysRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListGatewaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGatewaysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gateways"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gateways) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gateways.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gateways, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListGatewaysResponse, rhs: Teleport_Lib_Teleterm_V1_ListGatewaysResponse) -> Bool {
    if lhs.gateways != rhs.gateways {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_RemoveGatewayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveGatewayRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gateway_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gatewayUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gatewayUri.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_RemoveGatewayRequest, rhs: Teleport_Lib_Teleterm_V1_RemoveGatewayRequest) -> Bool {
    if lhs.gatewayUri != rhs.gatewayUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SetGatewayTargetSubresourceNameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetGatewayTargetSubresourceNameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gateway_uri"),
    2: .standard(proto: "target_subresource_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gatewayUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetSubresourceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gatewayUri.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayUri, fieldNumber: 1)
    }
    if !self.targetSubresourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.targetSubresourceName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SetGatewayTargetSubresourceNameRequest, rhs: Teleport_Lib_Teleterm_V1_SetGatewayTargetSubresourceNameRequest) -> Bool {
    if lhs.gatewayUri != rhs.gatewayUri {return false}
    if lhs.targetSubresourceName != rhs.targetSubresourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SetGatewayLocalPortRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetGatewayLocalPortRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gateway_uri"),
    2: .standard(proto: "local_port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gatewayUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localPort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gatewayUri.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayUri, fieldNumber: 1)
    }
    if !self.localPort.isEmpty {
      try visitor.visitSingularStringField(value: self.localPort, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SetGatewayLocalPortRequest, rhs: Teleport_Lib_Teleterm_V1_SetGatewayLocalPortRequest) -> Bool {
    if lhs.gatewayUri != rhs.gatewayUri {return false}
    if lhs.localPort != rhs.localPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetServersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
    2: .same(proto: "limit"),
    3: .standard(proto: "start_key"),
    4: .same(proto: "search"),
    5: .same(proto: "query"),
    6: .standard(proto: "sort_by"),
    7: .standard(proto: "search_as_roles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.startKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.search) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sortBy) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.searchAsRoles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.startKey.isEmpty {
      try visitor.visitSingularStringField(value: self.startKey, fieldNumber: 3)
    }
    if !self.search.isEmpty {
      try visitor.visitSingularStringField(value: self.search, fieldNumber: 4)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 5)
    }
    if !self.sortBy.isEmpty {
      try visitor.visitSingularStringField(value: self.sortBy, fieldNumber: 6)
    }
    if !self.searchAsRoles.isEmpty {
      try visitor.visitSingularStringField(value: self.searchAsRoles, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetServersRequest, rhs: Teleport_Lib_Teleterm_V1_GetServersRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.startKey != rhs.startKey {return false}
    if lhs.search != rhs.search {return false}
    if lhs.query != rhs.query {return false}
    if lhs.sortBy != rhs.sortBy {return false}
    if lhs.searchAsRoles != rhs.searchAsRoles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetServersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "agents"),
    2: .standard(proto: "total_count"),
    3: .standard(proto: "start_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.agents) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalCount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.startKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.agents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.agents, fieldNumber: 1)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalCount, fieldNumber: 2)
    }
    if !self.startKey.isEmpty {
      try visitor.visitSingularStringField(value: self.startKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetServersResponse, rhs: Teleport_Lib_Teleterm_V1_GetServersResponse) -> Bool {
    if lhs.agents != rhs.agents {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.startKey != rhs.startKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetAuthSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAuthSettingsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetAuthSettingsRequest, rhs: Teleport_Lib_Teleterm_V1_GetAuthSettingsRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTshdEventsServerAddressRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressRequest, rhs: Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTshdEventsServerAddressResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressResponse, rhs: Teleport_Lib_Teleterm_V1_UpdateTshdEventsServerAddressResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateHeadlessAuthenticationStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "headless_authentication_id"),
    3: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.headlessAuthenticationID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.headlessAuthenticationID.isEmpty {
      try visitor.visitSingularStringField(value: self.headlessAuthenticationID, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateRequest, rhs: Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.headlessAuthenticationID != rhs.headlessAuthenticationID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateHeadlessAuthenticationStateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateResponse, rhs: Teleport_Lib_Teleterm_V1_UpdateHeadlessAuthenticationStateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConnectMyComputerRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleRequest, rhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConnectMyComputerRoleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "certs_reloaded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.certsReloaded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.certsReloaded != false {
      try visitor.visitSingularBoolField(value: self.certsReloaded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleResponse, rhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerRoleResponse) -> Bool {
    if lhs.certsReloaded != rhs.certsReloaded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConnectMyComputerNodeTokenRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenRequest, rhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConnectMyComputerNodeTokenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenResponse, rhs: Teleport_Lib_Teleterm_V1_CreateConnectMyComputerNodeTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitForConnectMyComputerNodeJoinRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinRequest, rhs: Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitForConnectMyComputerNodeJoinResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "server"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._server) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._server {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinResponse, rhs: Teleport_Lib_Teleterm_V1_WaitForConnectMyComputerNodeJoinResponse) -> Bool {
    if lhs._server != rhs._server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConnectMyComputerNodeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeRequest, rhs: Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConnectMyComputerNodeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeResponse, rhs: Teleport_Lib_Teleterm_V1_DeleteConnectMyComputerNodeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectMyComputerNodeNameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameRequest, rhs: Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectMyComputerNodeNameResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameResponse, rhs: Teleport_Lib_Teleterm_V1_GetConnectMyComputerNodeNameResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListUnifiedResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUnifiedResourcesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
    2: .same(proto: "kinds"),
    3: .same(proto: "limit"),
    4: .standard(proto: "start_key"),
    5: .same(proto: "query"),
    6: .same(proto: "search"),
    7: .standard(proto: "sort_by"),
    8: .standard(proto: "search_as_roles"),
    9: .standard(proto: "pinned_only"),
    10: .standard(proto: "include_requestable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.kinds) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.startKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.search) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._sortBy) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.searchAsRoles) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.pinnedOnly) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.includeRequestable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kinds, fieldNumber: 2)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 3)
    }
    if !self.startKey.isEmpty {
      try visitor.visitSingularStringField(value: self.startKey, fieldNumber: 4)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 5)
    }
    if !self.search.isEmpty {
      try visitor.visitSingularStringField(value: self.search, fieldNumber: 6)
    }
    try { if let v = self._sortBy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.searchAsRoles != false {
      try visitor.visitSingularBoolField(value: self.searchAsRoles, fieldNumber: 8)
    }
    if self.pinnedOnly != false {
      try visitor.visitSingularBoolField(value: self.pinnedOnly, fieldNumber: 9)
    }
    if self.includeRequestable != false {
      try visitor.visitSingularBoolField(value: self.includeRequestable, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListUnifiedResourcesRequest, rhs: Teleport_Lib_Teleterm_V1_ListUnifiedResourcesRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.startKey != rhs.startKey {return false}
    if lhs.query != rhs.query {return false}
    if lhs.search != rhs.search {return false}
    if lhs._sortBy != rhs._sortBy {return false}
    if lhs.searchAsRoles != rhs.searchAsRoles {return false}
    if lhs.pinnedOnly != rhs.pinnedOnly {return false}
    if lhs.includeRequestable != rhs.includeRequestable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SortBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SortBy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_desc"),
    2: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isDesc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isDesc != false {
      try visitor.visitSingularBoolField(value: self.isDesc, fieldNumber: 1)
    }
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SortBy, rhs: Teleport_Lib_Teleterm_V1_SortBy) -> Bool {
    if lhs.isDesc != rhs.isDesc {return false}
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ListUnifiedResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUnifiedResourcesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resources"),
    2: .standard(proto: "next_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 1)
    }
    if !self.nextKey.isEmpty {
      try visitor.visitSingularStringField(value: self.nextKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ListUnifiedResourcesResponse, rhs: Teleport_Lib_Teleterm_V1_ListUnifiedResourcesResponse) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.nextKey != rhs.nextKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PaginatedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaginatedResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "server"),
    3: .same(proto: "kube"),
    4: .same(proto: "app"),
    5: .standard(proto: "requires_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Lib_Teleterm_V1_Database?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .database(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .database(v)
        }
      }()
      case 2: try {
        var v: Teleport_Lib_Teleterm_V1_Server?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .server(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .server(v)
        }
      }()
      case 3: try {
        var v: Teleport_Lib_Teleterm_V1_Kube?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .kube(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .kube(v)
        }
      }()
      case 4: try {
        var v: Teleport_Lib_Teleterm_V1_App?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .app(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .app(v)
        }
      }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.requiresRequest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.resource {
    case .database?: try {
      guard case .database(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .server?: try {
      guard case .server(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .kube?: try {
      guard case .kube(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .app?: try {
      guard case .app(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.requiresRequest != false {
      try visitor.visitSingularBoolField(value: self.requiresRequest, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PaginatedResource, rhs: Teleport_Lib_Teleterm_V1_PaginatedResource) -> Bool {
    if lhs.resource != rhs.resource {return false}
    if lhs.requiresRequest != rhs.requiresRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetUserPreferencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserPreferencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetUserPreferencesRequest, rhs: Teleport_Lib_Teleterm_V1_GetUserPreferencesRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetUserPreferencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserPreferencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_preferences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userPreferences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userPreferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetUserPreferencesResponse, rhs: Teleport_Lib_Teleterm_V1_GetUserPreferencesResponse) -> Bool {
    if lhs._userPreferences != rhs._userPreferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UpdateUserPreferencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserPreferencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_uri"),
    2: .standard(proto: "user_preferences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userPreferences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 1)
    }
    try { if let v = self._userPreferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UpdateUserPreferencesRequest, rhs: Teleport_Lib_Teleterm_V1_UpdateUserPreferencesRequest) -> Bool {
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs._userPreferences != rhs._userPreferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UpdateUserPreferencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserPreferencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_preferences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userPreferences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userPreferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UpdateUserPreferencesResponse, rhs: Teleport_Lib_Teleterm_V1_UpdateUserPreferencesResponse) -> Bool {
    if lhs._userPreferences != rhs._userPreferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UserPreferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPreferences"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_preferences"),
    2: .standard(proto: "unified_resource_preferences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clusterPreferences) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._unifiedResourcePreferences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clusterPreferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unifiedResourcePreferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UserPreferences, rhs: Teleport_Lib_Teleterm_V1_UserPreferences) -> Bool {
    if lhs._clusterPreferences != rhs._clusterPreferences {return false}
    if lhs._unifiedResourcePreferences != rhs._unifiedResourcePreferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateWebDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_web_token"),
    2: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceWebToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceWebToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceRequest, rhs: Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceRequest) -> Bool {
    if lhs._deviceWebToken != rhs._deviceWebToken {return false}
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticateWebDeviceResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confirmation_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._confirmationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._confirmationToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceResponse, rhs: Teleport_Lib_Teleterm_V1_AuthenticateWebDeviceResponse) -> Bool {
    if lhs._confirmationToken != rhs._confirmationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetAppRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAppRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appUri.isEmpty {
      try visitor.visitSingularStringField(value: self.appUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetAppRequest, rhs: Teleport_Lib_Teleterm_V1_GetAppRequest) -> Bool {
    if lhs.appUri != rhs.appUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetAppResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAppResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "app"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._app) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._app {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetAppResponse, rhs: Teleport_Lib_Teleterm_V1_GetAppResponse) -> Bool {
    if lhs._app != rhs._app {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
