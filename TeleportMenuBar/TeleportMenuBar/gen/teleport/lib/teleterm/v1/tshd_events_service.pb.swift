// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/lib/teleterm/v1/tshd_events_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request for Relogin.
public struct Teleport_Lib_Teleterm_V1_ReloginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var reason: Teleport_Lib_Teleterm_V1_ReloginRequest.OneOf_Reason? = nil

  public var gatewayCertExpired: Teleport_Lib_Teleterm_V1_GatewayCertExpired {
    get {
      if case .gatewayCertExpired(let v)? = reason {return v}
      return Teleport_Lib_Teleterm_V1_GatewayCertExpired()
    }
    set {reason = .gatewayCertExpired(newValue)}
  }

  public var vnetCertExpired: Teleport_Lib_Teleterm_V1_VnetCertExpired {
    get {
      if case .vnetCertExpired(let v)? = reason {return v}
      return Teleport_Lib_Teleterm_V1_VnetCertExpired()
    }
    set {reason = .vnetCertExpired(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Reason: Equatable, Sendable {
    case gatewayCertExpired(Teleport_Lib_Teleterm_V1_GatewayCertExpired)
    case vnetCertExpired(Teleport_Lib_Teleterm_V1_VnetCertExpired)

  }

  public init() {}
}

/// GatewayCertExpired is given as the reason when a database client attempts to make a connection
/// through the gateway, the gateway middleware notices that the db cert has expired and tries to
/// connect to the cluster to reissue the cert, but fails because the user cert has expired as well.
///
/// At that point in order to let the connection through, tshd needs the Electron app to refresh the
/// user cert by asking the user to log in again.
public struct Teleport_Lib_Teleterm_V1_GatewayCertExpired: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gatewayUri: String = String()

  public var targetUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// VnetCertExpired describes which app the user was trying to reach with an expired cert.
public struct Teleport_Lib_Teleterm_V1_VnetCertExpired: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// target_uri for now points solely at apps, but it's not called app_uri to make it future-proof.
  public var targetUri: String = String()

  /// route_to_app is the metadata associated with the app that the user was trying to reach.
  public var routeToApp: Teleport_Lib_Teleterm_V1_RouteToApp {
    get {return _routeToApp ?? Teleport_Lib_Teleterm_V1_RouteToApp()}
    set {_routeToApp = newValue}
  }
  /// Returns true if `routeToApp` has been explicitly set.
  public var hasRouteToApp: Bool {return self._routeToApp != nil}
  /// Clears the value of `routeToApp`. Subsequent reads from it will return its default value.
  public mutating func clearRouteToApp() {self._routeToApp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _routeToApp: Teleport_Lib_Teleterm_V1_RouteToApp? = nil
}

/// Response for Relogin.
public struct Teleport_Lib_Teleterm_V1_ReloginResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SendNotificationRequest includes details behind a notification.
///
/// Rather than including arbitrary text strings, SendNotificationRequest should contain minimal
/// details. The Electron app can then consume and format them as needed, without having to change
/// what is sent over the wire.
public struct Teleport_Lib_Teleterm_V1_SendNotificationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subject: Teleport_Lib_Teleterm_V1_SendNotificationRequest.OneOf_Subject? = nil

  public var cannotProxyGatewayConnection: Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection {
    get {
      if case .cannotProxyGatewayConnection(let v)? = subject {return v}
      return Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection()
    }
    set {subject = .cannotProxyGatewayConnection(newValue)}
  }

  public var cannotProxyVnetConnection: Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection {
    get {
      if case .cannotProxyVnetConnection(let v)? = subject {return v}
      return Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection()
    }
    set {subject = .cannotProxyVnetConnection(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Subject: Equatable, Sendable {
    case cannotProxyGatewayConnection(Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection)
    case cannotProxyVnetConnection(Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection)

  }

  public init() {}
}

/// CannotProxyGatewayConnection is the subject when the middleware used by the gateway encounters an
/// unrecoverable error and cannot let the connection through. The middleware code is executed within
/// a separate goroutine so if the error wasn't passed to the Electron app, it would have been
/// visible only in the logs.
public struct Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gatewayUri: String = String()

  public var targetUri: String = String()

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CannotProxyVnetConnection describes which app couldn't have been proxied through VNet and why.
public struct Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetUri: String = String()

  /// route_to_app is the metadata associated with the app that the user was trying to reach.
  public var routeToApp: Teleport_Lib_Teleterm_V1_RouteToApp {
    get {return _routeToApp ?? Teleport_Lib_Teleterm_V1_RouteToApp()}
    set {_routeToApp = newValue}
  }
  /// Returns true if `routeToApp` has been explicitly set.
  public var hasRouteToApp: Bool {return self._routeToApp != nil}
  /// Clears the value of `routeToApp`. Subsequent reads from it will return its default value.
  public mutating func clearRouteToApp() {self._routeToApp = nil}

  public var reason: Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection.OneOf_Reason? = nil

  public var certReissueError: Teleport_Lib_Teleterm_V1_CertReissueError {
    get {
      if case .certReissueError(let v)? = reason {return v}
      return Teleport_Lib_Teleterm_V1_CertReissueError()
    }
    set {reason = .certReissueError(newValue)}
  }

  public var invalidLocalPort: Teleport_Lib_Teleterm_V1_InvalidLocalPort {
    get {
      if case .invalidLocalPort(let v)? = reason {return v}
      return Teleport_Lib_Teleterm_V1_InvalidLocalPort()
    }
    set {reason = .invalidLocalPort(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Reason: Equatable, Sendable {
    case certReissueError(Teleport_Lib_Teleterm_V1_CertReissueError)
    case invalidLocalPort(Teleport_Lib_Teleterm_V1_InvalidLocalPort)

  }

  public init() {}

  fileprivate var _routeToApp: Teleport_Lib_Teleterm_V1_RouteToApp? = nil
}

/// CertReissueError is sent as reason in CannotProxyVnetConnection when VNet wasn't able to reissue
/// a cert for a local proxy.
public struct Teleport_Lib_Teleterm_V1_CertReissueError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// InvalidLocalPort is sent as reason in CannotProxyVnetConnection when VNet refused a connection
/// because its local port did not match any TCP ports in the spec of the app. The port is included
/// in route_to_app as target_port.
public struct Teleport_Lib_Teleterm_V1_InvalidLocalPort: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tcp_ports represents valid port ranges for the app. Sent only if there's less than 10 port
  /// ranges to keep the UI clean and to limit how much data is sent on each failed attempt.
  public var tcpPorts: [Teleport_Lib_Teleterm_V1_PortRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for SendNotification.
public struct Teleport_Lib_Teleterm_V1_SendNotificationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for SendPendingHeadlessAuthentication.
public struct Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var headlessAuthenticationID: String = String()

  public var headlessAuthenticationClientIp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for SendPendingHeadlessAuthentication.
public struct Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for PromptMFA.
public struct Teleport_Lib_Teleterm_V1_PromptMFARequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var totp: Bool = false

  public var webauthn: Bool = false

  public var clusterUri: String = String()

  public var sso: Teleport_Lib_Teleterm_V1_SSOChallenge {
    get {return _sso ?? Teleport_Lib_Teleterm_V1_SSOChallenge()}
    set {_sso = newValue}
  }
  /// Returns true if `sso` has been explicitly set.
  public var hasSso: Bool {return self._sso != nil}
  /// Clears the value of `sso`. Subsequent reads from it will return its default value.
  public mutating func clearSso() {self._sso = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sso: Teleport_Lib_Teleterm_V1_SSOChallenge? = nil
}

/// SSOChallenge contains SSO challenge details.
public struct Teleport_Lib_Teleterm_V1_SSOChallenge: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var connectorID: String = String()

  public var connectorType: String = String()

  public var displayName: String = String()

  public var redirectURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for PromptMFA.
public struct Teleport_Lib_Teleterm_V1_PromptMFAResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totpCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for PromptHardwareKeyPIN.
public struct Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  /// Specifies if a PIN is optional, allowing the user to set it up if left empty.
  public var pinOptional: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for PromptHardwareKeyPIN.
public struct Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pin as inputted by the user in the Electron app.
  public var pin: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for PromptHardwareKeyTouchRequest.
public struct Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for PromptHardwareKeyTouch.
public struct Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for PromptHardwareKeyPINChange.
public struct Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for PromptHardwareKeyPINChange.
public struct Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// New pin set by the user.
  public var pin: String = String()

  /// PUK is needed to change the PIN.
  /// This is a new PUK if it has not been changed from the default PUK.
  public var puk: String = String()

  /// puk_changed is true if the user changed the default PUK.
  public var pukChanged: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for ConfirmHardwareKeySlotOverwrite.
public struct Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootClusterUri: String = String()

  /// Message to display in the prompt.
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for ConfirmHardwareKeySlotOverwrite.
public struct Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, the slot will be overridden.
  public var confirmed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for GetUsageReportingSettings.
public struct Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for GetUsageReportingSettings.
public struct Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var usageReportingSettings: Teleport_Lib_Teleterm_V1_UsageReportingSettings {
    get {return _usageReportingSettings ?? Teleport_Lib_Teleterm_V1_UsageReportingSettings()}
    set {_usageReportingSettings = newValue}
  }
  /// Returns true if `usageReportingSettings` has been explicitly set.
  public var hasUsageReportingSettings: Bool {return self._usageReportingSettings != nil}
  /// Clears the value of `usageReportingSettings`. Subsequent reads from it will return its default value.
  public mutating func clearUsageReportingSettings() {self._usageReportingSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usageReportingSettings: Teleport_Lib_Teleterm_V1_UsageReportingSettings? = nil
}

/// UsageReportingSettings contains information about usage reporting as understood by the Electron
/// app.
public struct Teleport_Lib_Teleterm_V1_UsageReportingSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for ReportUnexpectedVnetShutdown.
public struct Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// error is the error message with which VNet was shut down. Technically it can be empty, so
  /// consumers should account for that.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for ReportUnexpectedVnetShutdown.
public struct Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.lib.teleterm.v1"

extension Teleport_Lib_Teleterm_V1_ReloginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReloginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "gateway_cert_expired"),
    3: .standard(proto: "vnet_cert_expired"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try {
        var v: Teleport_Lib_Teleterm_V1_GatewayCertExpired?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .gatewayCertExpired(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .gatewayCertExpired(v)
        }
      }()
      case 3: try {
        var v: Teleport_Lib_Teleterm_V1_VnetCertExpired?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .vnetCertExpired(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .vnetCertExpired(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    switch self.reason {
    case .gatewayCertExpired?: try {
      guard case .gatewayCertExpired(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .vnetCertExpired?: try {
      guard case .vnetCertExpired(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ReloginRequest, rhs: Teleport_Lib_Teleterm_V1_ReloginRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GatewayCertExpired: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatewayCertExpired"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gateway_uri"),
    2: .standard(proto: "target_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gatewayUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gatewayUri.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayUri, fieldNumber: 1)
    }
    if !self.targetUri.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUri, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GatewayCertExpired, rhs: Teleport_Lib_Teleterm_V1_GatewayCertExpired) -> Bool {
    if lhs.gatewayUri != rhs.gatewayUri {return false}
    if lhs.targetUri != rhs.targetUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_VnetCertExpired: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VnetCertExpired"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_uri"),
    3: .standard(proto: "route_to_app"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetUri) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._routeToApp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetUri.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUri, fieldNumber: 1)
    }
    try { if let v = self._routeToApp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_VnetCertExpired, rhs: Teleport_Lib_Teleterm_V1_VnetCertExpired) -> Bool {
    if lhs.targetUri != rhs.targetUri {return false}
    if lhs._routeToApp != rhs._routeToApp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ReloginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReloginResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ReloginResponse, rhs: Teleport_Lib_Teleterm_V1_ReloginResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SendNotificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendNotificationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cannot_proxy_gateway_connection"),
    2: .standard(proto: "cannot_proxy_vnet_connection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection?
        var hadOneofValue = false
        if let current = self.subject {
          hadOneofValue = true
          if case .cannotProxyGatewayConnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subject = .cannotProxyGatewayConnection(v)
        }
      }()
      case 2: try {
        var v: Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection?
        var hadOneofValue = false
        if let current = self.subject {
          hadOneofValue = true
          if case .cannotProxyVnetConnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subject = .cannotProxyVnetConnection(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subject {
    case .cannotProxyGatewayConnection?: try {
      guard case .cannotProxyGatewayConnection(let v)? = self.subject else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cannotProxyVnetConnection?: try {
      guard case .cannotProxyVnetConnection(let v)? = self.subject else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SendNotificationRequest, rhs: Teleport_Lib_Teleterm_V1_SendNotificationRequest) -> Bool {
    if lhs.subject != rhs.subject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CannotProxyGatewayConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gateway_uri"),
    2: .standard(proto: "target_uri"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gatewayUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetUri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gatewayUri.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayUri, fieldNumber: 1)
    }
    if !self.targetUri.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUri, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection, rhs: Teleport_Lib_Teleterm_V1_CannotProxyGatewayConnection) -> Bool {
    if lhs.gatewayUri != rhs.gatewayUri {return false}
    if lhs.targetUri != rhs.targetUri {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CannotProxyVnetConnection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_uri"),
    4: .standard(proto: "route_to_app"),
    5: .standard(proto: "cert_reissue_error"),
    6: .standard(proto: "invalid_local_port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetUri) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._routeToApp) }()
      case 5: try {
        var v: Teleport_Lib_Teleterm_V1_CertReissueError?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .certReissueError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .certReissueError(v)
        }
      }()
      case 6: try {
        var v: Teleport_Lib_Teleterm_V1_InvalidLocalPort?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidLocalPort(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidLocalPort(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetUri.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUri, fieldNumber: 1)
    }
    try { if let v = self._routeToApp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.reason {
    case .certReissueError?: try {
      guard case .certReissueError(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .invalidLocalPort?: try {
      guard case .invalidLocalPort(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection, rhs: Teleport_Lib_Teleterm_V1_CannotProxyVnetConnection) -> Bool {
    if lhs.targetUri != rhs.targetUri {return false}
    if lhs._routeToApp != rhs._routeToApp {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_CertReissueError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertReissueError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_CertReissueError, rhs: Teleport_Lib_Teleterm_V1_CertReissueError) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_InvalidLocalPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvalidLocalPort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tcp_ports"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tcpPorts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tcpPorts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tcpPorts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_InvalidLocalPort, rhs: Teleport_Lib_Teleterm_V1_InvalidLocalPort) -> Bool {
    if lhs.tcpPorts != rhs.tcpPorts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SendNotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendNotificationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SendNotificationResponse, rhs: Teleport_Lib_Teleterm_V1_SendNotificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendPendingHeadlessAuthenticationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "headless_authentication_id"),
    3: .standard(proto: "headless_authentication_client_ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.headlessAuthenticationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.headlessAuthenticationClientIp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.headlessAuthenticationID.isEmpty {
      try visitor.visitSingularStringField(value: self.headlessAuthenticationID, fieldNumber: 2)
    }
    if !self.headlessAuthenticationClientIp.isEmpty {
      try visitor.visitSingularStringField(value: self.headlessAuthenticationClientIp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest, rhs: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.headlessAuthenticationID != rhs.headlessAuthenticationID {return false}
    if lhs.headlessAuthenticationClientIp != rhs.headlessAuthenticationClientIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendPendingHeadlessAuthenticationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse, rhs: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptMFARequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptMFARequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "reason"),
    3: .same(proto: "totp"),
    4: .same(proto: "webauthn"),
    5: .standard(proto: "cluster_uri"),
    6: .same(proto: "sso"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.totp) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.webauthn) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.clusterUri) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sso) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if self.totp != false {
      try visitor.visitSingularBoolField(value: self.totp, fieldNumber: 3)
    }
    if self.webauthn != false {
      try visitor.visitSingularBoolField(value: self.webauthn, fieldNumber: 4)
    }
    if !self.clusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterUri, fieldNumber: 5)
    }
    try { if let v = self._sso {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptMFARequest, rhs: Teleport_Lib_Teleterm_V1_PromptMFARequest) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.totp != rhs.totp {return false}
    if lhs.webauthn != rhs.webauthn {return false}
    if lhs.clusterUri != rhs.clusterUri {return false}
    if lhs._sso != rhs._sso {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_SSOChallenge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SSOChallenge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connector_id"),
    2: .standard(proto: "connector_type"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "redirect_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.connectorType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.redirectURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectorID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorID, fieldNumber: 1)
    }
    if !self.connectorType.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorType, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.redirectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.redirectURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_SSOChallenge, rhs: Teleport_Lib_Teleterm_V1_SSOChallenge) -> Bool {
    if lhs.connectorID != rhs.connectorID {return false}
    if lhs.connectorType != rhs.connectorType {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.redirectURL != rhs.redirectURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptMFAResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptMFAResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "totp_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.totpCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.totpCode.isEmpty {
      try visitor.visitSingularStringField(value: self.totpCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptMFAResponse, rhs: Teleport_Lib_Teleterm_V1_PromptMFAResponse) -> Bool {
    if lhs.totpCode != rhs.totpCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHardwareKeyPINRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .standard(proto: "pin_optional"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.pinOptional) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if self.pinOptional != false {
      try visitor.visitSingularBoolField(value: self.pinOptional, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest, rhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.pinOptional != rhs.pinOptional {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHardwareKeyPINResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse, rhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHardwareKeyTouchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest, rhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHardwareKeyTouchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse, rhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHardwareKeyPINChangeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest, rhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHardwareKeyPINChangeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
    2: .same(proto: "puk"),
    3: .standard(proto: "puk_changed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.puk) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.pukChanged) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    if !self.puk.isEmpty {
      try visitor.visitSingularStringField(value: self.puk, fieldNumber: 2)
    }
    if self.pukChanged != false {
      try visitor.visitSingularBoolField(value: self.pukChanged, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse, rhs: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.puk != rhs.puk {return false}
    if lhs.pukChanged != rhs.pukChanged {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmHardwareKeySlotOverwriteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_cluster_uri"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rootClusterUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootClusterUri.isEmpty {
      try visitor.visitSingularStringField(value: self.rootClusterUri, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest, rhs: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest) -> Bool {
    if lhs.rootClusterUri != rhs.rootClusterUri {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfirmHardwareKeySlotOverwriteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confirmed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.confirmed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confirmed != false {
      try visitor.visitSingularBoolField(value: self.confirmed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse, rhs: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse) -> Bool {
    if lhs.confirmed != rhs.confirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUsageReportingSettingsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest, rhs: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUsageReportingSettingsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "usage_reporting_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._usageReportingSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._usageReportingSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse, rhs: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse) -> Bool {
    if lhs._usageReportingSettings != rhs._usageReportingSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_UsageReportingSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsageReportingSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_UsageReportingSettings, rhs: Teleport_Lib_Teleterm_V1_UsageReportingSettings) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportUnexpectedVnetShutdownRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest, rhs: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportUnexpectedVnetShutdownResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse, rhs: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
