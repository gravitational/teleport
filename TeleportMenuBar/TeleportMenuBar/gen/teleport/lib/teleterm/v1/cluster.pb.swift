// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/lib/teleterm/v1/cluster.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ShowResources tells if the cluster can show requestable resources on the resources page.
public enum Teleport_Lib_Teleterm_V1_ShowResources: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case requestable // = 1
  case accessibleOnly // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .requestable
    case 2: self = .accessibleOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .requestable: return 1
    case .accessibleOnly: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Teleport_Lib_Teleterm_V1_ShowResources] = [
    .unspecified,
    .requestable,
    .accessibleOnly,
  ]

}

/// Cluster describes cluster fields.
public struct Teleport_Lib_Teleterm_V1_Cluster: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uri is the cluster resource URI.
  /// For root clusters, it has the form of /clusters/:rootClusterId where rootClusterId is the
  /// name of the profile, that is the hostname of the proxy used to connect to the root cluster.
  /// rootClusterId is not equal to the name of the root cluster.
  ///
  /// For leaf clusters, it has the form of /clusters/:rootClusterId/leaves/:leafClusterId where
  /// leafClusterId is equal to the name property of the cluster.
  public var uri: String {
    get {return _storage._uri}
    set {_uniqueStorage()._uri = newValue}
  }

  /// name is used throughout the Teleport Connect codebase as the cluster name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// proxy_host is address of the proxy used to connect to this cluster.
  /// Always includes port number. Present only for root clusters.
  ///
  /// Example: "teleport-14-ent.example.com:3090"
  public var proxyHost: String {
    get {return _storage._proxyHost}
    set {_uniqueStorage()._proxyHost = newValue}
  }

  /// connected indicates if connection to the cluster can be established, that is if we have a
  /// cert for the cluster that hasn't expired
  public var connected: Bool {
    get {return _storage._connected}
    set {_uniqueStorage()._connected = newValue}
  }

  /// leaf indicates if this is a leaf cluster
  public var leaf: Bool {
    get {return _storage._leaf}
    set {_uniqueStorage()._leaf = newValue}
  }

  /// logged_in_user is present if the user has logged in to the cluster at least once, even
  /// if the cert has since expired. If the cluster was added to the app but the
  /// user is yet to log in, logged_in_user is not present.
  public var loggedInUser: Teleport_Lib_Teleterm_V1_LoggedInUser {
    get {return _storage._loggedInUser ?? Teleport_Lib_Teleterm_V1_LoggedInUser()}
    set {_uniqueStorage()._loggedInUser = newValue}
  }
  /// Returns true if `loggedInUser` has been explicitly set.
  public var hasLoggedInUser: Bool {return _storage._loggedInUser != nil}
  /// Clears the value of `loggedInUser`. Subsequent reads from it will return its default value.
  public mutating func clearLoggedInUser() {_uniqueStorage()._loggedInUser = nil}

  /// features describes the auth servers features.
  /// Only present when detailed information is queried from the auth server.
  public var features: Teleport_Lib_Teleterm_V1_Features {
    get {return _storage._features ?? Teleport_Lib_Teleterm_V1_Features()}
    set {_uniqueStorage()._features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  public var hasFeatures: Bool {return _storage._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  public mutating func clearFeatures() {_uniqueStorage()._features = nil}

  /// auth_cluster_id is the unique cluster ID that is set once
  /// during the first auth server startup.
  /// Only present when detailed information is queried from the auth server.
  public var authClusterID: String {
    get {return _storage._authClusterID}
    set {_uniqueStorage()._authClusterID = newValue}
  }

  /// ProxyVersion is the cluster proxy's service version.
  /// Only present when detailed information is queried from the proxy server.
  public var proxyVersion: String {
    get {return _storage._proxyVersion}
    set {_uniqueStorage()._proxyVersion = newValue}
  }

  /// show_resources tells if the cluster can show requestable resources on the resources page.
  /// Controlled by the cluster config.
  public var showResources: Teleport_Lib_Teleterm_V1_ShowResources {
    get {return _storage._showResources}
    set {_uniqueStorage()._showResources = newValue}
  }

  /// profile_status_error is set if there was an error when reading the profile.
  /// This allows the app to be usable, when one or more profiles cannot be read.
  public var profileStatusError: String {
    get {return _storage._profileStatusError}
    set {_uniqueStorage()._profileStatusError = newValue}
  }

  /// sso_host is the host of the SSO provider used to log in.
  public var ssoHost: String {
    get {return _storage._ssoHost}
    set {_uniqueStorage()._ssoHost = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LoggedInUser describes a logged-in user
public struct Teleport_Lib_Teleterm_V1_LoggedInUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the user name
  public var name: String = String()

  /// roles is the user roles
  public var roles: [String] = []

  /// ssh_logins is the user ssh logins
  public var sshLogins: [String] = []

  /// acl is a user access control list.
  /// It is available only after the cluster details are fetched, as it is not stored on disk.
  public var acl: Teleport_Lib_Teleterm_V1_ACL {
    get {return _acl ?? Teleport_Lib_Teleterm_V1_ACL()}
    set {_acl = newValue}
  }
  /// Returns true if `acl` has been explicitly set.
  public var hasAcl: Bool {return self._acl != nil}
  /// Clears the value of `acl`. Subsequent reads from it will return its default value.
  public mutating func clearAcl() {self._acl = nil}

  /// active_requests is an array of request-id strings of active requests
  public var activeRequests: [String] = []

  /// suggested_reviewers for the given user.
  /// Only present when detailed information is queried from the auth server.
  public var suggestedReviewers: [String] = []

  /// requestable_roles for the given user.
  /// Only present when detailed information is queried from the auth server.
  public var requestableRoles: [String] = []

  public var userType: Teleport_Lib_Teleterm_V1_LoggedInUser.UserType = .unspecified

  /// Indicates if the profile contains all required device extensions.
  public var isDeviceTrusted: Bool = false

  /// Indicates whether access may be hindered by the lack of a trusted device.
  public var trustedDeviceRequirement: Types_TrustedDeviceRequirement = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// UserType indicates whether the user was created through an SSO provider or in Teleport itself.
  /// Only present when detailed information is queried from the auth server.
  public enum UserType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case local // = 1
    case sso // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .local
      case 2: self = .sso
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .local: return 1
      case .sso: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Teleport_Lib_Teleterm_V1_LoggedInUser.UserType] = [
      .unspecified,
      .local,
      .sso,
    ]

  }

  public init() {}

  fileprivate var _acl: Teleport_Lib_Teleterm_V1_ACL? = nil
}

/// ACL is the access control list of the user
public struct Teleport_Lib_Teleterm_V1_ACL: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// auth_connectors defines access to auth.connectors
  public var authConnectors: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._authConnectors ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._authConnectors = newValue}
  }
  /// Returns true if `authConnectors` has been explicitly set.
  public var hasAuthConnectors: Bool {return _storage._authConnectors != nil}
  /// Clears the value of `authConnectors`. Subsequent reads from it will return its default value.
  public mutating func clearAuthConnectors() {_uniqueStorage()._authConnectors = nil}

  /// Roles defines access to roles
  public var roles: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._roles ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._roles = newValue}
  }
  /// Returns true if `roles` has been explicitly set.
  public var hasRoles: Bool {return _storage._roles != nil}
  /// Clears the value of `roles`. Subsequent reads from it will return its default value.
  public mutating func clearRoles() {_uniqueStorage()._roles = nil}

  /// Users defines access to users.
  public var users: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._users ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._users = newValue}
  }
  /// Returns true if `users` has been explicitly set.
  public var hasUsers: Bool {return _storage._users != nil}
  /// Clears the value of `users`. Subsequent reads from it will return its default value.
  public mutating func clearUsers() {_uniqueStorage()._users = nil}

  /// trusted_clusters defines access to trusted clusters
  public var trustedClusters: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._trustedClusters ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._trustedClusters = newValue}
  }
  /// Returns true if `trustedClusters` has been explicitly set.
  public var hasTrustedClusters: Bool {return _storage._trustedClusters != nil}
  /// Clears the value of `trustedClusters`. Subsequent reads from it will return its default value.
  public mutating func clearTrustedClusters() {_uniqueStorage()._trustedClusters = nil}

  /// Events defines access to audit logs
  public var events: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._events ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._events = newValue}
  }
  /// Returns true if `events` has been explicitly set.
  public var hasEvents: Bool {return _storage._events != nil}
  /// Clears the value of `events`. Subsequent reads from it will return its default value.
  public mutating func clearEvents() {_uniqueStorage()._events = nil}

  /// Tokens defines access to tokens.
  public var tokens: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._tokens ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._tokens = newValue}
  }
  /// Returns true if `tokens` has been explicitly set.
  public var hasTokens: Bool {return _storage._tokens != nil}
  /// Clears the value of `tokens`. Subsequent reads from it will return its default value.
  public mutating func clearTokens() {_uniqueStorage()._tokens = nil}

  /// Servers defines access to servers.
  public var servers: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._servers ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._servers = newValue}
  }
  /// Returns true if `servers` has been explicitly set.
  public var hasServers: Bool {return _storage._servers != nil}
  /// Clears the value of `servers`. Subsequent reads from it will return its default value.
  public mutating func clearServers() {_uniqueStorage()._servers = nil}

  /// apps defines access to application servers
  public var apps: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._apps ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._apps = newValue}
  }
  /// Returns true if `apps` has been explicitly set.
  public var hasApps: Bool {return _storage._apps != nil}
  /// Clears the value of `apps`. Subsequent reads from it will return its default value.
  public mutating func clearApps() {_uniqueStorage()._apps = nil}

  /// dbs defines access to database servers.
  public var dbs: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._dbs ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._dbs = newValue}
  }
  /// Returns true if `dbs` has been explicitly set.
  public var hasDbs: Bool {return _storage._dbs != nil}
  /// Clears the value of `dbs`. Subsequent reads from it will return its default value.
  public mutating func clearDbs() {_uniqueStorage()._dbs = nil}

  /// kubeservers defines access to kubernetes servers.
  public var kubeservers: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._kubeservers ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._kubeservers = newValue}
  }
  /// Returns true if `kubeservers` has been explicitly set.
  public var hasKubeservers: Bool {return _storage._kubeservers != nil}
  /// Clears the value of `kubeservers`. Subsequent reads from it will return its default value.
  public mutating func clearKubeservers() {_uniqueStorage()._kubeservers = nil}

  /// access_requests defines access to access requests
  public var accessRequests: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._accessRequests ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._accessRequests = newValue}
  }
  /// Returns true if `accessRequests` has been explicitly set.
  public var hasAccessRequests: Bool {return _storage._accessRequests != nil}
  /// Clears the value of `accessRequests`. Subsequent reads from it will return its default value.
  public mutating func clearAccessRequests() {_uniqueStorage()._accessRequests = nil}

  /// recorded_sessions defines access to recorded sessions.
  public var recordedSessions: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._recordedSessions ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._recordedSessions = newValue}
  }
  /// Returns true if `recordedSessions` has been explicitly set.
  public var hasRecordedSessions: Bool {return _storage._recordedSessions != nil}
  /// Clears the value of `recordedSessions`. Subsequent reads from it will return its default value.
  public mutating func clearRecordedSessions() {_uniqueStorage()._recordedSessions = nil}

  /// active_sessions defines access to active sessions.
  public var activeSessions: Teleport_Lib_Teleterm_V1_ResourceAccess {
    get {return _storage._activeSessions ?? Teleport_Lib_Teleterm_V1_ResourceAccess()}
    set {_uniqueStorage()._activeSessions = newValue}
  }
  /// Returns true if `activeSessions` has been explicitly set.
  public var hasActiveSessions: Bool {return _storage._activeSessions != nil}
  /// Clears the value of `activeSessions`. Subsequent reads from it will return its default value.
  public mutating func clearActiveSessions() {_uniqueStorage()._activeSessions = nil}

  /// review_requests defines the ability to review requests
  public var reviewRequests: Bool {
    get {return _storage._reviewRequests}
    set {_uniqueStorage()._reviewRequests = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ResourceAccess describes access verbs
public struct Teleport_Lib_Teleterm_V1_ResourceAccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list determines "list" access
  public var list: Bool = false

  /// read determines "read" access
  public var read: Bool = false

  /// edit determines "edit" access
  public var edit: Bool = false

  /// create determines "create" access
  public var create: Bool = false

  /// delete determines "delete" access
  public var delete: Bool = false

  /// use determines "use" access
  public var use: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Features describes the auth servers features
public struct Teleport_Lib_Teleterm_V1_Features: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// advanced_access_workflows enables search-based access requests
  public var advancedAccessWorkflows: Bool = false

  /// is_usage_based_billing determines if the cloud user subscription is usage-based (pay-as-you-go).
  public var isUsageBasedBilling: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.lib.teleterm.v1"

extension Teleport_Lib_Teleterm_V1_ShowResources: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW_RESOURCES_UNSPECIFIED"),
    1: .same(proto: "SHOW_RESOURCES_REQUESTABLE"),
    2: .same(proto: "SHOW_RESOURCES_ACCESSIBLE_ONLY"),
  ]
}

extension Teleport_Lib_Teleterm_V1_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "name"),
    3: .standard(proto: "proxy_host"),
    4: .same(proto: "connected"),
    5: .same(proto: "leaf"),
    7: .standard(proto: "logged_in_user"),
    8: .same(proto: "features"),
    9: .standard(proto: "auth_cluster_id"),
    10: .standard(proto: "proxy_version"),
    11: .standard(proto: "show_resources"),
    12: .standard(proto: "profile_status_error"),
    13: .standard(proto: "sso_host"),
  ]

  fileprivate class _StorageClass {
    var _uri: String = String()
    var _name: String = String()
    var _proxyHost: String = String()
    var _connected: Bool = false
    var _leaf: Bool = false
    var _loggedInUser: Teleport_Lib_Teleterm_V1_LoggedInUser? = nil
    var _features: Teleport_Lib_Teleterm_V1_Features? = nil
    var _authClusterID: String = String()
    var _proxyVersion: String = String()
    var _showResources: Teleport_Lib_Teleterm_V1_ShowResources = .unspecified
    var _profileStatusError: String = String()
    var _ssoHost: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _uri = source._uri
      _name = source._name
      _proxyHost = source._proxyHost
      _connected = source._connected
      _leaf = source._leaf
      _loggedInUser = source._loggedInUser
      _features = source._features
      _authClusterID = source._authClusterID
      _proxyVersion = source._proxyVersion
      _showResources = source._showResources
      _profileStatusError = source._profileStatusError
      _ssoHost = source._ssoHost
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._uri) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._proxyHost) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._connected) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._leaf) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._loggedInUser) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._features) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._authClusterID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._proxyVersion) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._showResources) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._profileStatusError) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._ssoHost) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uri, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._proxyHost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proxyHost, fieldNumber: 3)
      }
      if _storage._connected != false {
        try visitor.visitSingularBoolField(value: _storage._connected, fieldNumber: 4)
      }
      if _storage._leaf != false {
        try visitor.visitSingularBoolField(value: _storage._leaf, fieldNumber: 5)
      }
      try { if let v = _storage._loggedInUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._features {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._authClusterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authClusterID, fieldNumber: 9)
      }
      if !_storage._proxyVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proxyVersion, fieldNumber: 10)
      }
      if _storage._showResources != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._showResources, fieldNumber: 11)
      }
      if !_storage._profileStatusError.isEmpty {
        try visitor.visitSingularStringField(value: _storage._profileStatusError, fieldNumber: 12)
      }
      if !_storage._ssoHost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ssoHost, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_Cluster, rhs: Teleport_Lib_Teleterm_V1_Cluster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uri != rhs_storage._uri {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._proxyHost != rhs_storage._proxyHost {return false}
        if _storage._connected != rhs_storage._connected {return false}
        if _storage._leaf != rhs_storage._leaf {return false}
        if _storage._loggedInUser != rhs_storage._loggedInUser {return false}
        if _storage._features != rhs_storage._features {return false}
        if _storage._authClusterID != rhs_storage._authClusterID {return false}
        if _storage._proxyVersion != rhs_storage._proxyVersion {return false}
        if _storage._showResources != rhs_storage._showResources {return false}
        if _storage._profileStatusError != rhs_storage._profileStatusError {return false}
        if _storage._ssoHost != rhs_storage._ssoHost {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoggedInUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoggedInUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "roles"),
    3: .standard(proto: "ssh_logins"),
    4: .same(proto: "acl"),
    5: .standard(proto: "active_requests"),
    6: .standard(proto: "suggested_reviewers"),
    7: .standard(proto: "requestable_roles"),
    8: .standard(proto: "user_type"),
    9: .standard(proto: "is_device_trusted"),
    10: .standard(proto: "trusted_device_requirement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.sshLogins) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._acl) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.activeRequests) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.suggestedReviewers) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.requestableRoles) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.userType) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isDeviceTrusted) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.trustedDeviceRequirement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    if !self.sshLogins.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sshLogins, fieldNumber: 3)
    }
    try { if let v = self._acl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.activeRequests.isEmpty {
      try visitor.visitRepeatedStringField(value: self.activeRequests, fieldNumber: 5)
    }
    if !self.suggestedReviewers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.suggestedReviewers, fieldNumber: 6)
    }
    if !self.requestableRoles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestableRoles, fieldNumber: 7)
    }
    if self.userType != .unspecified {
      try visitor.visitSingularEnumField(value: self.userType, fieldNumber: 8)
    }
    if self.isDeviceTrusted != false {
      try visitor.visitSingularBoolField(value: self.isDeviceTrusted, fieldNumber: 9)
    }
    if self.trustedDeviceRequirement != .unspecified {
      try visitor.visitSingularEnumField(value: self.trustedDeviceRequirement, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_LoggedInUser, rhs: Teleport_Lib_Teleterm_V1_LoggedInUser) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.sshLogins != rhs.sshLogins {return false}
    if lhs._acl != rhs._acl {return false}
    if lhs.activeRequests != rhs.activeRequests {return false}
    if lhs.suggestedReviewers != rhs.suggestedReviewers {return false}
    if lhs.requestableRoles != rhs.requestableRoles {return false}
    if lhs.userType != rhs.userType {return false}
    if lhs.isDeviceTrusted != rhs.isDeviceTrusted {return false}
    if lhs.trustedDeviceRequirement != rhs.trustedDeviceRequirement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_LoggedInUser.UserType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_TYPE_UNSPECIFIED"),
    1: .same(proto: "USER_TYPE_LOCAL"),
    2: .same(proto: "USER_TYPE_SSO"),
  ]
}

extension Teleport_Lib_Teleterm_V1_ACL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ACL"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "auth_connectors"),
    3: .same(proto: "roles"),
    4: .same(proto: "users"),
    5: .standard(proto: "trusted_clusters"),
    6: .same(proto: "events"),
    7: .same(proto: "tokens"),
    8: .same(proto: "servers"),
    9: .same(proto: "apps"),
    10: .same(proto: "dbs"),
    11: .same(proto: "kubeservers"),
    12: .standard(proto: "access_requests"),
    13: .standard(proto: "recorded_sessions"),
    14: .standard(proto: "active_sessions"),
    15: .standard(proto: "review_requests"),
  ]

  fileprivate class _StorageClass {
    var _authConnectors: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _roles: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _users: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _trustedClusters: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _events: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _tokens: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _servers: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _apps: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _dbs: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _kubeservers: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _accessRequests: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _recordedSessions: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _activeSessions: Teleport_Lib_Teleterm_V1_ResourceAccess? = nil
    var _reviewRequests: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _authConnectors = source._authConnectors
      _roles = source._roles
      _users = source._users
      _trustedClusters = source._trustedClusters
      _events = source._events
      _tokens = source._tokens
      _servers = source._servers
      _apps = source._apps
      _dbs = source._dbs
      _kubeservers = source._kubeservers
      _accessRequests = source._accessRequests
      _recordedSessions = source._recordedSessions
      _activeSessions = source._activeSessions
      _reviewRequests = source._reviewRequests
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._authConnectors) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._roles) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._users) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._trustedClusters) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._events) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._tokens) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._servers) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._apps) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._dbs) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._kubeservers) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._accessRequests) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._recordedSessions) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._activeSessions) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._reviewRequests) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._authConnectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._roles {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._users {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._trustedClusters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._events {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._tokens {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._servers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._apps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._dbs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._kubeservers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._accessRequests {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._recordedSessions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._activeSessions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._reviewRequests != false {
        try visitor.visitSingularBoolField(value: _storage._reviewRequests, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ACL, rhs: Teleport_Lib_Teleterm_V1_ACL) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._authConnectors != rhs_storage._authConnectors {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._users != rhs_storage._users {return false}
        if _storage._trustedClusters != rhs_storage._trustedClusters {return false}
        if _storage._events != rhs_storage._events {return false}
        if _storage._tokens != rhs_storage._tokens {return false}
        if _storage._servers != rhs_storage._servers {return false}
        if _storage._apps != rhs_storage._apps {return false}
        if _storage._dbs != rhs_storage._dbs {return false}
        if _storage._kubeservers != rhs_storage._kubeservers {return false}
        if _storage._accessRequests != rhs_storage._accessRequests {return false}
        if _storage._recordedSessions != rhs_storage._recordedSessions {return false}
        if _storage._activeSessions != rhs_storage._activeSessions {return false}
        if _storage._reviewRequests != rhs_storage._reviewRequests {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ResourceAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceAccess"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
    2: .same(proto: "read"),
    3: .same(proto: "edit"),
    4: .same(proto: "create"),
    5: .same(proto: "delete"),
    6: .same(proto: "use"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.list) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.read) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.edit) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.create) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.delete) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.use) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.list != false {
      try visitor.visitSingularBoolField(value: self.list, fieldNumber: 1)
    }
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 2)
    }
    if self.edit != false {
      try visitor.visitSingularBoolField(value: self.edit, fieldNumber: 3)
    }
    if self.create != false {
      try visitor.visitSingularBoolField(value: self.create, fieldNumber: 4)
    }
    if self.delete != false {
      try visitor.visitSingularBoolField(value: self.delete, fieldNumber: 5)
    }
    if self.use != false {
      try visitor.visitSingularBoolField(value: self.use, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_ResourceAccess, rhs: Teleport_Lib_Teleterm_V1_ResourceAccess) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.read != rhs.read {return false}
    if lhs.edit != rhs.edit {return false}
    if lhs.create != rhs.create {return false}
    if lhs.delete != rhs.delete {return false}
    if lhs.use != rhs.use {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_Features: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Features"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "advanced_access_workflows"),
    2: .standard(proto: "is_usage_based_billing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.advancedAccessWorkflows) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isUsageBasedBilling) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.advancedAccessWorkflows != false {
      try visitor.visitSingularBoolField(value: self.advancedAccessWorkflows, fieldNumber: 1)
    }
    if self.isUsageBasedBilling != false {
      try visitor.visitSingularBoolField(value: self.isUsageBasedBilling, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Teleterm_V1_Features, rhs: Teleport_Lib_Teleterm_V1_Features) -> Bool {
    if lhs.advancedAccessWorkflows != rhs.advancedAccessWorkflows {return false}
    if lhs.isUsageBasedBilling != rhs.isUsageBasedBilling {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
