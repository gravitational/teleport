// Code generated by protoc-gen-connect-swift. DO NOT EDIT.
//
// Source: teleport/lib/teleterm/v1/tshd_events_service.proto
//

import Connect
import Foundation
import SwiftProtobuf

/// TshdEventsService is served by the Electron app. The tsh daemon calls this service to notify the
/// app about actions that happen outside of the app itself.
public protocol Teleport_Lib_Teleterm_V1_TshdEventsServiceClientInterface: Sendable {

    /// Relogin makes the Electron app display a login modal for the specific root cluster. The request
    /// returns a response after the relogin procedure has been successfully finished.
    @discardableResult
    func `relogin`(request: Teleport_Lib_Teleterm_V1_ReloginRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_ReloginResponse>) -> Void) -> Connect.Cancelable

    /// Relogin makes the Electron app display a login modal for the specific root cluster. The request
    /// returns a response after the relogin procedure has been successfully finished.
    @available(iOS 13, *)
    func `relogin`(request: Teleport_Lib_Teleterm_V1_ReloginRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_ReloginResponse>

    /// SendNotification causes the Electron app to display a notification in the UI. The request
    /// accepts a specific message rather than a generic string so that the Electron is in control as
    /// to what message is displayed and how exactly it looks.
    @discardableResult
    func `sendNotification`(request: Teleport_Lib_Teleterm_V1_SendNotificationRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_SendNotificationResponse>) -> Void) -> Connect.Cancelable

    /// SendNotification causes the Electron app to display a notification in the UI. The request
    /// accepts a specific message rather than a generic string so that the Electron is in control as
    /// to what message is displayed and how exactly it looks.
    @available(iOS 13, *)
    func `sendNotification`(request: Teleport_Lib_Teleterm_V1_SendNotificationRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_SendNotificationResponse>

    /// SendPendingHeadlessAuthentication notifies the Electron app of a pending headless authentication,
    /// which it can use to initiate headless authentication resolution in the UI.
    @discardableResult
    func `sendPendingHeadlessAuthentication`(request: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse>) -> Void) -> Connect.Cancelable

    /// SendPendingHeadlessAuthentication notifies the Electron app of a pending headless authentication,
    /// which it can use to initiate headless authentication resolution in the UI.
    @available(iOS 13, *)
    func `sendPendingHeadlessAuthentication`(request: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse>

    /// PromptMFA notifies the Electron app that the daemon wants to prompt for MFA.
    /// If TOTP is supported, the Electron app can return a totp code to complete the ceremony.
    /// If Webauthn or SSO are supported, tsh daemon waits for the Electron App to choose
    /// an option in the response before prompting for either.
    ///
    /// In order for the WebAuthn and SSO prompts to be reflected in the Electron App, the
    /// Electron app can display a waiting screen and listen for the tsh daemon to send a
    /// notification to close the screen.
    @discardableResult
    func `promptMfa`(request: Teleport_Lib_Teleterm_V1_PromptMFARequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptMFAResponse>) -> Void) -> Connect.Cancelable

    /// PromptMFA notifies the Electron app that the daemon wants to prompt for MFA.
    /// If TOTP is supported, the Electron app can return a totp code to complete the ceremony.
    /// If Webauthn or SSO are supported, tsh daemon waits for the Electron App to choose
    /// an option in the response before prompting for either.
    ///
    /// In order for the WebAuthn and SSO prompts to be reflected in the Electron App, the
    /// Electron app can display a waiting screen and listen for the tsh daemon to send a
    /// notification to close the screen.
    @available(iOS 13, *)
    func `promptMfa`(request: Teleport_Lib_Teleterm_V1_PromptMFARequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptMFAResponse>

    /// PromptHardwareKeyPIN notifies the Electron app that the daemon is waiting for the user to
    /// provide the hardware key PIN.
    @discardableResult
    func `promptHardwareKeyPin`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse>) -> Void) -> Connect.Cancelable

    /// PromptHardwareKeyPIN notifies the Electron app that the daemon is waiting for the user to
    /// provide the hardware key PIN.
    @available(iOS 13, *)
    func `promptHardwareKeyPin`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse>

    /// PromptHardwareKeyTouch notifies the Electron app that the daemon is waiting for the user to touch the hardware key.
    /// When the daemon detects the touch, it cancels the prompt.
    @discardableResult
    func `promptHardwareKeyTouch`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse>) -> Void) -> Connect.Cancelable

    /// PromptHardwareKeyTouch notifies the Electron app that the daemon is waiting for the user to touch the hardware key.
    /// When the daemon detects the touch, it cancels the prompt.
    @available(iOS 13, *)
    func `promptHardwareKeyTouch`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse>

    /// PromptHardwareKeyPINChange notifies the Electron app that the daemon is waiting for the user to
    /// change the hardware key PIN.
    @discardableResult
    func `promptHardwareKeyPinchange`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse>) -> Void) -> Connect.Cancelable

    /// PromptHardwareKeyPINChange notifies the Electron app that the daemon is waiting for the user to
    /// change the hardware key PIN.
    @available(iOS 13, *)
    func `promptHardwareKeyPinchange`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse>

    /// ConfirmHardwareKeySlotOverwrite displays a dialog prompting the user to confirm whether
    /// the slot's private key and certificate should be overwritten.
    @discardableResult
    func `confirmHardwareKeySlotOverwrite`(request: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse>) -> Void) -> Connect.Cancelable

    /// ConfirmHardwareKeySlotOverwrite displays a dialog prompting the user to confirm whether
    /// the slot's private key and certificate should be overwritten.
    @available(iOS 13, *)
    func `confirmHardwareKeySlotOverwrite`(request: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse>

    /// GetUsageReportingSettings returns the current state of usage reporting.
    /// At the moment, the user cannot toggle usage reporting on and off without shutting down the app,
    /// with the only exception being the first start of the app when they're prompted about telemetry.
    /// Hence why this is an RPC and not information passed over argv to tsh daemon.
    @discardableResult
    func `getUsageReportingSettings`(request: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse>) -> Void) -> Connect.Cancelable

    /// GetUsageReportingSettings returns the current state of usage reporting.
    /// At the moment, the user cannot toggle usage reporting on and off without shutting down the app,
    /// with the only exception being the first start of the app when they're prompted about telemetry.
    /// Hence why this is an RPC and not information passed over argv to tsh daemon.
    @available(iOS 13, *)
    func `getUsageReportingSettings`(request: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse>

    /// ReportUnexpectedVnetShutdown is sent by tsh daemon when VNet exits outside of the
    /// request-response cycle of Start and Stop RPCs of VnetService. The Electron app is then able to
    /// update the state of VNet in the UI.
    @discardableResult
    func `reportUnexpectedVnetShutdown`(request: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse>) -> Void) -> Connect.Cancelable

    /// ReportUnexpectedVnetShutdown is sent by tsh daemon when VNet exits outside of the
    /// request-response cycle of Start and Stop RPCs of VnetService. The Electron app is then able to
    /// update the state of VNet in the UI.
    @available(iOS 13, *)
    func `reportUnexpectedVnetShutdown`(request: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse>
}

/// Concrete implementation of `Teleport_Lib_Teleterm_V1_TshdEventsServiceClientInterface`.
public final class Teleport_Lib_Teleterm_V1_TshdEventsServiceClient: Teleport_Lib_Teleterm_V1_TshdEventsServiceClientInterface, Sendable {
    private let client: Connect.ProtocolClientInterface

    public init(client: Connect.ProtocolClientInterface) {
        self.client = client
    }

    @discardableResult
    public func `relogin`(request: Teleport_Lib_Teleterm_V1_ReloginRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_ReloginResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/Relogin", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `relogin`(request: Teleport_Lib_Teleterm_V1_ReloginRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_ReloginResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/Relogin", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `sendNotification`(request: Teleport_Lib_Teleterm_V1_SendNotificationRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_SendNotificationResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/SendNotification", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `sendNotification`(request: Teleport_Lib_Teleterm_V1_SendNotificationRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_SendNotificationResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/SendNotification", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `sendPendingHeadlessAuthentication`(request: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/SendPendingHeadlessAuthentication", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `sendPendingHeadlessAuthentication`(request: Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_SendPendingHeadlessAuthenticationResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/SendPendingHeadlessAuthentication", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `promptMfa`(request: Teleport_Lib_Teleterm_V1_PromptMFARequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptMFAResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptMFA", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `promptMfa`(request: Teleport_Lib_Teleterm_V1_PromptMFARequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptMFAResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptMFA", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `promptHardwareKeyPin`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptHardwareKeyPIN", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `promptHardwareKeyPin`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptHardwareKeyPIN", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `promptHardwareKeyTouch`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptHardwareKeyTouch", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `promptHardwareKeyTouch`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyTouchResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptHardwareKeyTouch", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `promptHardwareKeyPinchange`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptHardwareKeyPINChange", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `promptHardwareKeyPinchange`(request: Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_PromptHardwareKeyPINChangeResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/PromptHardwareKeyPINChange", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `confirmHardwareKeySlotOverwrite`(request: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/ConfirmHardwareKeySlotOverwrite", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `confirmHardwareKeySlotOverwrite`(request: Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_ConfirmHardwareKeySlotOverwriteResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/ConfirmHardwareKeySlotOverwrite", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `getUsageReportingSettings`(request: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/GetUsageReportingSettings", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `getUsageReportingSettings`(request: Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_GetUsageReportingSettingsResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/GetUsageReportingSettings", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `reportUnexpectedVnetShutdown`(request: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/ReportUnexpectedVnetShutdown", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `reportUnexpectedVnetShutdown`(request: Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_V1_ReportUnexpectedVnetShutdownResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.v1.TshdEventsService/ReportUnexpectedVnetShutdown", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    public enum Metadata {
        public enum Methods {
            public static let relogin = Connect.MethodSpec(name: "Relogin", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let sendNotification = Connect.MethodSpec(name: "SendNotification", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let sendPendingHeadlessAuthentication = Connect.MethodSpec(name: "SendPendingHeadlessAuthentication", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let promptMfa = Connect.MethodSpec(name: "PromptMFA", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let promptHardwareKeyPin = Connect.MethodSpec(name: "PromptHardwareKeyPIN", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let promptHardwareKeyTouch = Connect.MethodSpec(name: "PromptHardwareKeyTouch", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let promptHardwareKeyPinchange = Connect.MethodSpec(name: "PromptHardwareKeyPINChange", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let confirmHardwareKeySlotOverwrite = Connect.MethodSpec(name: "ConfirmHardwareKeySlotOverwrite", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let getUsageReportingSettings = Connect.MethodSpec(name: "GetUsageReportingSettings", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
            public static let reportUnexpectedVnetShutdown = Connect.MethodSpec(name: "ReportUnexpectedVnetShutdown", service: "teleport.lib.teleterm.v1.TshdEventsService", type: .unary)
        }
    }
}
