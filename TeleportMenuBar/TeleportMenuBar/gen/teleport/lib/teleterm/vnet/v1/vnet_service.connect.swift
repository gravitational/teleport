// Code generated by protoc-gen-connect-swift. DO NOT EDIT.
//
// Source: teleport/lib/teleterm/vnet/v1/vnet_service.proto
//

import Connect
import Foundation
import SwiftProtobuf

/// VnetService provides methods to manage a VNet instance.
public protocol Teleport_Lib_Teleterm_Vnet_V1_VnetServiceClientInterface: Sendable {

    /// Start starts VNet.
    @discardableResult
    func `start`(request: Teleport_Lib_Teleterm_Vnet_V1_StartRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StartResponse>) -> Void) -> Connect.Cancelable

    /// Start starts VNet.
    @available(iOS 13, *)
    func `start`(request: Teleport_Lib_Teleterm_Vnet_V1_StartRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StartResponse>

    /// Stop stops VNet.
    @discardableResult
    func `stop`(request: Teleport_Lib_Teleterm_Vnet_V1_StopRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StopResponse>) -> Void) -> Connect.Cancelable

    /// Stop stops VNet.
    @available(iOS 13, *)
    func `stop`(request: Teleport_Lib_Teleterm_Vnet_V1_StopRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StopResponse>

    /// ListDNSZones returns DNS zones of all root and leaf clusters with non-expired user certs. This
    /// includes the proxy service hostnames and custom DNS zones configured in vnet_config.
    ///
    /// This is fetched independently of what the Electron app thinks the current state of the cluster
    /// looks like, since the VNet admin process also fetches this data independently of the Electron
    /// app.
    ///
    /// Just like the admin process, it skips root and leaf clusters for which the vnet_config couldn't
    /// be fetched (due to e.g., a network error or an expired cert).
    @discardableResult
    func `listDnszones`(request: Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesResponse>) -> Void) -> Connect.Cancelable

    /// ListDNSZones returns DNS zones of all root and leaf clusters with non-expired user certs. This
    /// includes the proxy service hostnames and custom DNS zones configured in vnet_config.
    ///
    /// This is fetched independently of what the Electron app thinks the current state of the cluster
    /// looks like, since the VNet admin process also fetches this data independently of the Electron
    /// app.
    ///
    /// Just like the admin process, it skips root and leaf clusters for which the vnet_config couldn't
    /// be fetched (due to e.g., a network error or an expired cert).
    @available(iOS 13, *)
    func `listDnszones`(request: Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesResponse>

    /// GetBackgroundItemStatus returns the status of the background item responsible for launching
    /// VNet daemon. macOS only. tsh must be compiled with the vnetdaemon build tag.
    @discardableResult
    func `getBackgroundItemStatus`(request: Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusResponse>) -> Void) -> Connect.Cancelable

    /// GetBackgroundItemStatus returns the status of the background item responsible for launching
    /// VNet daemon. macOS only. tsh must be compiled with the vnetdaemon build tag.
    @available(iOS 13, *)
    func `getBackgroundItemStatus`(request: Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusResponse>

    /// RunDiagnostics runs a set of heuristics to determine if VNet actually works on the device, that
    /// is receives network traffic and DNS queries. RunDiagnostics requires VNet to be started.
    @discardableResult
    func `runDiagnostics`(request: Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsRequest, headers: Connect.Headers, completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsResponse>) -> Void) -> Connect.Cancelable

    /// RunDiagnostics runs a set of heuristics to determine if VNet actually works on the device, that
    /// is receives network traffic and DNS queries. RunDiagnostics requires VNet to be started.
    @available(iOS 13, *)
    func `runDiagnostics`(request: Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsRequest, headers: Connect.Headers) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsResponse>
}

/// Concrete implementation of `Teleport_Lib_Teleterm_Vnet_V1_VnetServiceClientInterface`.
public final class Teleport_Lib_Teleterm_Vnet_V1_VnetServiceClient: Teleport_Lib_Teleterm_Vnet_V1_VnetServiceClientInterface, Sendable {
    private let client: Connect.ProtocolClientInterface

    public init(client: Connect.ProtocolClientInterface) {
        self.client = client
    }

    @discardableResult
    public func `start`(request: Teleport_Lib_Teleterm_Vnet_V1_StartRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StartResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/Start", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `start`(request: Teleport_Lib_Teleterm_Vnet_V1_StartRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StartResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/Start", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `stop`(request: Teleport_Lib_Teleterm_Vnet_V1_StopRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StopResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/Stop", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `stop`(request: Teleport_Lib_Teleterm_Vnet_V1_StopRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_StopResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/Stop", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `listDnszones`(request: Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/ListDNSZones", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `listDnszones`(request: Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_ListDNSZonesResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/ListDNSZones", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `getBackgroundItemStatus`(request: Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/GetBackgroundItemStatus", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `getBackgroundItemStatus`(request: Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_GetBackgroundItemStatusResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/GetBackgroundItemStatus", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    @discardableResult
    public func `runDiagnostics`(request: Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsRequest, headers: Connect.Headers = [:], completion: @escaping @Sendable (ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsResponse>) -> Void) -> Connect.Cancelable {
        return self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/RunDiagnostics", idempotencyLevel: .unknown, request: request, headers: headers, completion: completion)
    }

    @available(iOS 13, *)
    public func `runDiagnostics`(request: Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsRequest, headers: Connect.Headers = [:]) async -> ResponseMessage<Teleport_Lib_Teleterm_Vnet_V1_RunDiagnosticsResponse> {
        return await self.client.unary(path: "/teleport.lib.teleterm.vnet.v1.VnetService/RunDiagnostics", idempotencyLevel: .unknown, request: request, headers: headers)
    }

    public enum Metadata {
        public enum Methods {
            public static let start = Connect.MethodSpec(name: "Start", service: "teleport.lib.teleterm.vnet.v1.VnetService", type: .unary)
            public static let stop = Connect.MethodSpec(name: "Stop", service: "teleport.lib.teleterm.vnet.v1.VnetService", type: .unary)
            public static let listDnszones = Connect.MethodSpec(name: "ListDNSZones", service: "teleport.lib.teleterm.vnet.v1.VnetService", type: .unary)
            public static let getBackgroundItemStatus = Connect.MethodSpec(name: "GetBackgroundItemStatus", service: "teleport.lib.teleterm.vnet.v1.VnetService", type: .unary)
            public static let runDiagnostics = Connect.MethodSpec(name: "RunDiagnostics", service: "teleport.lib.teleterm.vnet.v1.VnetService", type: .unary)
        }
    }
}
