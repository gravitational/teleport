// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/lib/vnet/diag/v1/diag.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Teleport
// Copyright (C) 2025 Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// CheckAttemptStatus describes whether CheckAttempt finished successfully. This is different from
/// CheckReportStatus, which describes whether a successful attempt at running a check has found any
/// issues. See the comment for CheckAttempt for an example.
public enum Teleport_Lib_Vnet_Diag_V1_CheckAttemptStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// CHECK_ATTEMPT_STATUS_OK indicates that the check ran successfully.
  case ok // = 1

  /// CHECK_ATTEMPT_STATUS_ERROR indicates that the check failed to run.
  case error // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ok
    case 2: self = .error
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ok: return 1
    case .error: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Teleport_Lib_Vnet_Diag_V1_CheckAttemptStatus] = [
    .unspecified,
    .ok,
    .error,
  ]

}

/// CheckReportStatus describes the outcome of a successful attempt at running a check.
public enum Teleport_Lib_Vnet_Diag_V1_CheckReportStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// CHECK_REPORT_STATUS_OK indicates that the check has not found any issues.
  case ok // = 1

  /// CHECK_REPORT_STATUS_ISSUES_FOUND indicates that the check has found at least one issue.
  case issuesFound // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ok
    case 2: self = .issuesFound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ok: return 1
    case .issuesFound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Teleport_Lib_Vnet_Diag_V1_CheckReportStatus] = [
    .unspecified,
    .ok,
    .issuesFound,
  ]

}

/// CommandAttemptStatus describes the status of CommandAttempt.
public enum Teleport_Lib_Vnet_Diag_V1_CommandAttemptStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case ok // = 1
  case error // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ok
    case 2: self = .error
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ok: return 1
    case .error: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Teleport_Lib_Vnet_Diag_V1_CommandAttemptStatus] = [
    .unspecified,
    .ok,
    .error,
  ]

}

/// Report represents the attempts at running individual checks. It also includes general information
/// about the network stack managed by VNet. It assumes that each individual check as well as getting
/// info about the network stack can fail.
public struct Teleport_Lib_Vnet_Diag_V1_Report: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// created_at is the UTC timestamp at which the report was generated.
  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var networkStackAttempt: Teleport_Lib_Vnet_Diag_V1_NetworkStackAttempt {
    get {return _networkStackAttempt ?? Teleport_Lib_Vnet_Diag_V1_NetworkStackAttempt()}
    set {_networkStackAttempt = newValue}
  }
  /// Returns true if `networkStackAttempt` has been explicitly set.
  public var hasNetworkStackAttempt: Bool {return self._networkStackAttempt != nil}
  /// Clears the value of `networkStackAttempt`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkStackAttempt() {self._networkStackAttempt = nil}

  public var checks: [Teleport_Lib_Vnet_Diag_V1_CheckAttempt] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _networkStackAttempt: Teleport_Lib_Vnet_Diag_V1_NetworkStackAttempt? = nil
}

/// NetworkStackAttempt represents the attempt at getting information about the network stack managed
/// by VNet.
public struct Teleport_Lib_Vnet_Diag_V1_NetworkStackAttempt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Teleport_Lib_Vnet_Diag_V1_CheckAttemptStatus = .unspecified

  /// error is present if status is CHECK_ATTEMPT_STATUS_ERROR.
  public var error: String = String()

  public var networkStack: Teleport_Lib_Vnet_Diag_V1_NetworkStack {
    get {return _networkStack ?? Teleport_Lib_Vnet_Diag_V1_NetworkStack()}
    set {_networkStack = newValue}
  }
  /// Returns true if `networkStack` has been explicitly set.
  public var hasNetworkStack: Bool {return self._networkStack != nil}
  /// Clears the value of `networkStack`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkStack() {self._networkStack = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _networkStack: Teleport_Lib_Vnet_Diag_V1_NetworkStack? = nil
}

/// NetworkStack describes the network stack managed by VNet.
public struct Teleport_Lib_Vnet_Diag_V1_NetworkStack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// interface_name is the name of the interface set up and used by VNet.
  public var interfaceName: String = String()

  /// ipv4_cidr_ranges are all the possible ranges under which VNet is going to assign IPv4 addresses
  /// for apps. The first IP of the first range is used for the TUN device.
  /// Each root cluster can specify its own CIDR range to be used for apps within that profile.
  public var ipv4CidrRanges: [String] = []

  /// ipv6_prefix is the IPv6 prefix under which VNet creates IPv6 addresses for apps and its DNS
  /// server.
  public var ipv6Prefix: String = String()

  /// dns_zones lists domains for which DNS queries are supposed to be captured by VNet.
  public var dnsZones: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CheckAttempt describes the attempt at running a particular diagnostic check. If it succeeds
/// (status is CHECK_ATTEMPT_STATUS_OK), check_report can be inspected to see if the check has found
/// any issues.
///
/// For example, a check that inspects network routes can succeed (CHECK_ATTEMPT_STATUS_OK) and it
/// might or might not find conflicting routes (CHECK_REPORT_STATUS_ISSUES_FOUND or
/// CHECK_REPORT_STATUS_OK). But it can also fail to run (CHECK_ATTEMPT_STATUS_ERROR) because the
/// syscall to list routes has failed.
public struct Teleport_Lib_Vnet_Diag_V1_CheckAttempt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status represents the status of an attempt at running a particular diagnostic check. This is
  /// not the same as the status of CheckReport.
  public var status: Teleport_Lib_Vnet_Diag_V1_CheckAttemptStatus = .unspecified

  /// error is present if the check failed to run (status is CHECK_ATTEMPT_STATUS_ERROR).
  public var error: String = String()

  /// check_report is the output of a particular check.
  ///
  /// If check failed to run (status is CHECK_ATTEMPT_STATUS_ERROR), the report oneof in check_report
  /// is set to a specific member while the member itself is empty. This means that a particular
  /// CheckAttempt can be distinguished from other attempts describing other checks even if the check
  /// failed to run.
  public var checkReport: Teleport_Lib_Vnet_Diag_V1_CheckReport {
    get {return _checkReport ?? Teleport_Lib_Vnet_Diag_V1_CheckReport()}
    set {_checkReport = newValue}
  }
  /// Returns true if `checkReport` has been explicitly set.
  public var hasCheckReport: Bool {return self._checkReport != nil}
  /// Clears the value of `checkReport`. Subsequent reads from it will return its default value.
  public mutating func clearCheckReport() {self._checkReport = nil}

  /// commands are the outputs from additional diagnostic commands executed by the diagnostic
  /// check. They are meant to help inspect the general state of the OS related to the given check.
  /// Unless a callsite specifically requests commands to be skipped, commands are present even if
  /// status is CHECK_ATTEMPT_STATUS_ERROR, as they are useful even if the check failed.
  public var commands: [Teleport_Lib_Vnet_Diag_V1_CommandAttempt] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _checkReport: Teleport_Lib_Vnet_Diag_V1_CheckReport? = nil
}

/// CheckReport is the output of a successful attempt at running a particular check.
public struct Teleport_Lib_Vnet_Diag_V1_CheckReport: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// status indicates if the check has found any issues. This is so that a callsite operating on
  /// a CheckReport can understand the outcome of the check without having to understand the
  /// semantics of the output included under report.
  public var status: Teleport_Lib_Vnet_Diag_V1_CheckReportStatus = .unspecified

  public var report: Teleport_Lib_Vnet_Diag_V1_CheckReport.OneOf_Report? = nil

  /// route_conflict reports whether there are routes that might conflict with routes set up by
  /// VNet.
  public var routeConflictReport: Teleport_Lib_Vnet_Diag_V1_RouteConflictReport {
    get {
      if case .routeConflictReport(let v)? = report {return v}
      return Teleport_Lib_Vnet_Diag_V1_RouteConflictReport()
    }
    set {report = .routeConflictReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Report: Equatable, Sendable {
    /// route_conflict reports whether there are routes that might conflict with routes set up by
    /// VNet.
    case routeConflictReport(Teleport_Lib_Vnet_Diag_V1_RouteConflictReport)

  }

  public init() {}
}

/// CommandAttempt describes the attempt at running a particular command associated with a diagnostic
/// check.
public struct Teleport_Lib_Vnet_Diag_V1_CommandAttempt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Teleport_Lib_Vnet_Diag_V1_CommandAttemptStatus = .unspecified

  /// error is present if status is COMMAND_ATTEMPT_STATUS_ERROR.
  public var error: String = String()

  /// command shows which command was executed along with its arguments, e.g., "netstat -rn -f inet".
  public var command: String = String()

  /// output is stdout from the command if status is COMMAND_ATTEMPT_STATUS_OK.
  public var output: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// RouteConflictReport describes conflicting routes found by RouteConflictDiag.
public struct Teleport_Lib_Vnet_Diag_V1_RouteConflictReport: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var routeConflicts: [Teleport_Lib_Vnet_Diag_V1_RouteConflict] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// RouteConflict describes a conflict between a route set up by a 3rd-party app where the
/// destination overlaps with a destination in a route set up by VNet.
public struct Teleport_Lib_Vnet_Diag_V1_RouteConflict: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// dest is the destination of the conflicting route.
  public var dest: String = String()

  /// vnet_dest is the destination of a VNet route that Dest overlaps with.
  public var vnetDest: String = String()

  /// interface_name is the name of the interface the route uses, e.g. "utun4".
  public var interfaceName: String = String()

  /// interface_app may contain the name of the application responsible for setting up the interface.
  /// At the moment, the only source of this information is NetworkExtension description included in
  /// the output of `ifconfig -v <interface name>`. Not all VPN applications use this framework, so
  /// it's likely to be empty.
  public var interfaceApp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.lib.vnet.diag.v1"

extension Teleport_Lib_Vnet_Diag_V1_CheckAttemptStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHECK_ATTEMPT_STATUS_UNSPECIFIED"),
    1: .same(proto: "CHECK_ATTEMPT_STATUS_OK"),
    2: .same(proto: "CHECK_ATTEMPT_STATUS_ERROR"),
  ]
}

extension Teleport_Lib_Vnet_Diag_V1_CheckReportStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHECK_REPORT_STATUS_UNSPECIFIED"),
    1: .same(proto: "CHECK_REPORT_STATUS_OK"),
    2: .same(proto: "CHECK_REPORT_STATUS_ISSUES_FOUND"),
  ]
}

extension Teleport_Lib_Vnet_Diag_V1_CommandAttemptStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_ATTEMPT_STATUS_UNSPECIFIED"),
    1: .same(proto: "COMMAND_ATTEMPT_STATUS_OK"),
    2: .same(proto: "COMMAND_ATTEMPT_STATUS_ERROR"),
  ]
}

extension Teleport_Lib_Vnet_Diag_V1_Report: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Report"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .standard(proto: "network_stack_attempt"),
    3: .same(proto: "checks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._networkStackAttempt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.checks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._networkStackAttempt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.checks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.checks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_Report, rhs: Teleport_Lib_Vnet_Diag_V1_Report) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._networkStackAttempt != rhs._networkStackAttempt {return false}
    if lhs.checks != rhs.checks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Vnet_Diag_V1_NetworkStackAttempt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkStackAttempt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
    3: .standard(proto: "network_stack"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._networkStack) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try { if let v = self._networkStack {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_NetworkStackAttempt, rhs: Teleport_Lib_Vnet_Diag_V1_NetworkStackAttempt) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.error != rhs.error {return false}
    if lhs._networkStack != rhs._networkStack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Vnet_Diag_V1_NetworkStack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkStack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "interface_name"),
    2: .standard(proto: "ipv4_cidr_ranges"),
    3: .standard(proto: "ipv6_prefix"),
    4: .standard(proto: "dns_zones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.ipv4CidrRanges) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipv6Prefix) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.dnsZones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 1)
    }
    if !self.ipv4CidrRanges.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipv4CidrRanges, fieldNumber: 2)
    }
    if !self.ipv6Prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv6Prefix, fieldNumber: 3)
    }
    if !self.dnsZones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dnsZones, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_NetworkStack, rhs: Teleport_Lib_Vnet_Diag_V1_NetworkStack) -> Bool {
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.ipv4CidrRanges != rhs.ipv4CidrRanges {return false}
    if lhs.ipv6Prefix != rhs.ipv6Prefix {return false}
    if lhs.dnsZones != rhs.dnsZones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Vnet_Diag_V1_CheckAttempt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckAttempt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
    3: .standard(proto: "check_report"),
    4: .same(proto: "commands"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._checkReport) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.commands) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try { if let v = self._checkReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.commands.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commands, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_CheckAttempt, rhs: Teleport_Lib_Vnet_Diag_V1_CheckAttempt) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.error != rhs.error {return false}
    if lhs._checkReport != rhs._checkReport {return false}
    if lhs.commands != rhs.commands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Vnet_Diag_V1_CheckReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "route_conflict_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try {
        var v: Teleport_Lib_Vnet_Diag_V1_RouteConflictReport?
        var hadOneofValue = false
        if let current = self.report {
          hadOneofValue = true
          if case .routeConflictReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.report = .routeConflictReport(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if case .routeConflictReport(let v)? = self.report {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_CheckReport, rhs: Teleport_Lib_Vnet_Diag_V1_CheckReport) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.report != rhs.report {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Vnet_Diag_V1_CommandAttempt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandAttempt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
    3: .same(proto: "command"),
    4: .same(proto: "output"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.output) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 3)
    }
    if !self.output.isEmpty {
      try visitor.visitSingularStringField(value: self.output, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_CommandAttempt, rhs: Teleport_Lib_Vnet_Diag_V1_CommandAttempt) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.error != rhs.error {return false}
    if lhs.command != rhs.command {return false}
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Vnet_Diag_V1_RouteConflictReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteConflictReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_conflicts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.routeConflicts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routeConflicts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routeConflicts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_RouteConflictReport, rhs: Teleport_Lib_Vnet_Diag_V1_RouteConflictReport) -> Bool {
    if lhs.routeConflicts != rhs.routeConflicts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Vnet_Diag_V1_RouteConflict: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteConflict"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .standard(proto: "vnet_dest"),
    3: .standard(proto: "interface_name"),
    4: .standard(proto: "interface_app"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.vnetDest) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.interfaceName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.interfaceApp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dest.isEmpty {
      try visitor.visitSingularStringField(value: self.dest, fieldNumber: 1)
    }
    if !self.vnetDest.isEmpty {
      try visitor.visitSingularStringField(value: self.vnetDest, fieldNumber: 2)
    }
    if !self.interfaceName.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceName, fieldNumber: 3)
    }
    if !self.interfaceApp.isEmpty {
      try visitor.visitSingularStringField(value: self.interfaceApp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Teleport_Lib_Vnet_Diag_V1_RouteConflict, rhs: Teleport_Lib_Vnet_Diag_V1_RouteConflict) -> Bool {
    if lhs.dest != rhs.dest {return false}
    if lhs.vnetDest != rhs.vnetDest {return false}
    if lhs.interfaceName != rhs.interfaceName {return false}
    if lhs.interfaceApp != rhs.interfaceApp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
