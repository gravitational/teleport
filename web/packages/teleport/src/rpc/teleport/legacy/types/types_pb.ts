// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.1.0 with parameter "target=ts"
// @generated from file teleport/legacy/types/types.proto (package types, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_gogoproto_gogo } from "../../../gogoproto/gogo_pb";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { AttestationStatement } from "../../attestation/v1/attestation_pb";
import { file_teleport_attestation_v1_attestation } from "../../attestation/v1/attestation_pb";
import type { CustomType, LabelValues, StringValues } from "./wrappers/wrappers_pb";
import { file_teleport_legacy_types_wrappers_wrappers } from "./wrappers/wrappers_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file teleport/legacy/types/types.proto.
 */
export const file_teleport_legacy_types_types: GenFile = /*@__PURE__*/
  fileDesc("CiF0ZWxlcG9ydC9sZWdhY3kvdHlwZXMvdHlwZXMucHJvdG8SBXR5cGVzIvYCCglLZWVwQWxpdmUSHQoETmFtZRgBIAEoCUIP6t4fC3NlcnZlcl9uYW1lEiAKCU5hbWVzcGFjZRgCIAEoCUIN6t4fCW5hbWVzcGFjZRJACgdFeHBpcmVzGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEITyN4fAOreHwdleHBpcmVzkN8fARI2CgRUeXBlGAkgASgOMh4udHlwZXMuS2VlcEFsaXZlLktlZXBBbGl2ZVR5cGVCCOreHwR0eXBlEiUKBkhvc3RJRBgKIAEoCUIV6t4fEWhvc3RfaWQsb21pdGVtcHR5IngKDUtlZXBBbGl2ZVR5cGUSCwoHVU5LTk9XThAAEggKBE5PREUQARIHCgNBUFAQAhIMCghEQVRBQkFTRRADEhMKD1dJTkRPV1NfREVTS1RPUBAEEg4KCktVQkVSTkVURVMQBRIUChBEQVRBQkFTRV9TRVJWSUNFEAZKBAgDEARSB0xlYXNlSUQi3gIKCE1ldGFkYXRhEhYKBE5hbWUYASABKAlCCOreHwRuYW1lEhgKCU5hbWVzcGFjZRgCIAEoCUIF6t4fAS0SLgoLRGVzY3JpcHRpb24YAyABKAlCGereHxVkZXNjcmlwdGlvbixvbWl0ZW1wdHkSQQoGTGFiZWxzGAUgAygLMhsudHlwZXMuTWV0YWRhdGEuTGFiZWxzRW50cnlCFOreHxBsYWJlbHMsb21pdGVtcHR5EkoKB0V4cGlyZXMYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8B6t4fEWV4cGlyZXMsb21pdGVtcHR5kN8fARIoCghSZXZpc2lvbhgIIAEoCUIW6t4fEnJldmlzaW9uLG9taXRlbXB0eRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBSgQIBxAIUgJJRCLGAwoIUm90YXRpb24SIgoFU3RhdGUYASABKAlCE+reHw9zdGF0ZSxvbWl0ZW1wdHkSIgoFUGhhc2UYAiABKAlCE+reHw9waGFzZSxvbWl0ZW1wdHkSIAoETW9kZRgDIAEoCUIS6t4fDm1vZGUsb21pdGVtcHR5EiEKCUN1cnJlbnRJRBgEIAEoCUIO6t4fCmN1cnJlbnRfaWQSSgoHU3RhcnRlZBgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCHcjeHwDq3h8Rc3RhcnRlZCxvbWl0ZW1wdHmQ3x8BEjsKC0dyYWNlUGVyaW9kGAYgASgDQibq3h8WZ3JhY2VfcGVyaW9kLG9taXRlbXB0efreHwhEdXJhdGlvbhJTCgtMYXN0Um90YXRlZBgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCIsjeHwDq3h8WbGFzdF9yb3RhdGVkLG9taXRlbXB0eZDfHwESRQoIU2NoZWR1bGUYCCABKAsyFy50eXBlcy5Sb3RhdGlvblNjaGVkdWxlQhrI3h8A6t4fEnNjaGVkdWxlLG9taXRlbXB0eToImKAfAIDcIAAikAIKEFJvdGF0aW9uU2NoZWR1bGUSVwoNVXBkYXRlQ2xpZW50cxgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCJMjeHwDq3h8YdXBkYXRlX2NsaWVudHMsb21pdGVtcHR5kN8fARJXCg1VcGRhdGVTZXJ2ZXJzGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIkyN4fAOreHxh1cGRhdGVfc2VydmVycyxvbWl0ZW1wdHmQ3x8BEkoKB1N0YW5kYnkYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEXN0YW5kYnksb21pdGVtcHR5kN8fASLCAQoOUmVzb3VyY2VIZWFkZXISIAoES2luZBgBIAEoCUIS6t4fDmtpbmQsb21pdGVtcHR5EicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSJgoHVmVyc2lvbhgDIAEoCUIV6t4fEXZlcnNpb24sb21pdGVtcHR5Ej0KCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCGsjeHwDq3h8SbWV0YWRhdGEsb21pdGVtcHR5IukBChBEYXRhYmFzZVNlcnZlclYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI3CgRTcGVjGAUgASgLMhsudHlwZXMuRGF0YWJhc2VTZXJ2ZXJTcGVjVjNCDMjeHwDq3h8Ec3BlYzoImKAfAIDcIAAi/wIKFERhdGFiYXNlU2VydmVyU3BlY1YzEhwKB1ZlcnNpb24YBiABKAlCC+reHwd2ZXJzaW9uEh4KCEhvc3RuYW1lGAcgASgJQgzq3h8IaG9zdG5hbWUSGwoGSG9zdElEGAggASgJQgvq3h8HaG9zdF9pZBI9CghSb3RhdGlvbhgKIAEoCzIPLnR5cGVzLlJvdGF0aW9uQhrI3h8A6t4fEnJvdGF0aW9uLG9taXRlbXB0eRI7CghEYXRhYmFzZRgMIAEoCzIRLnR5cGVzLkRhdGFiYXNlVjNCFureHxJkYXRhYmFzZSxvbWl0ZW1wdHkSKQoIUHJveHlJRHMYDSADKAlCF+reHxNwcm94eV9pZHMsb21pdGVtcHR5SgQIARACSgQIAhADSgQIAxAESgQIBBAFSgQIBRAGSgQICRAKSgQICxAMUgtEZXNjcmlwdGlvblIIUHJvdG9jb2xSA1VSSVIGQ0FDZXJ0UgNBV1NSDUR5bmFtaWNMYWJlbHNSA0dDUCI2Cg5EYXRhYmFzZVYzTGlzdBIkCglEYXRhYmFzZXMYASADKAsyES50eXBlcy5EYXRhYmFzZVYzIpYCCgpEYXRhYmFzZVYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRIxCgRTcGVjGAUgASgLMhUudHlwZXMuRGF0YWJhc2VTcGVjVjNCDMjeHwDq3h8Ec3BlYxI3CgZTdGF0dXMYBiABKAsyFy50eXBlcy5EYXRhYmFzZVN0YXR1c1YzQg7I3h8A6t4fBnN0YXR1czoImKAfAIDcIAAirAYKDkRhdGFiYXNlU3BlY1YzEh4KCFByb3RvY29sGAEgASgJQgzq3h8IcHJvdG9jb2wSFAoDVVJJGAIgASgJQgfq3h8DdXJpEicKBkNBQ2VydBgDIAEoCUIXGAHq3h8RY2FfY2VydCxvbWl0ZW1wdHkSYQoNRHluYW1pY0xhYmVscxgEIAMoCzIoLnR5cGVzLkRhdGFiYXNlU3BlY1YzLkR5bmFtaWNMYWJlbHNFbnRyeUIgyN4fAOreHxhkeW5hbWljX2xhYmVscyxvbWl0ZW1wdHkSLgoDQVdTGAUgASgLMgoudHlwZXMuQVdTQhXI3h8A6t4fDWF3cyxvbWl0ZW1wdHkSNgoDR0NQGAYgASgLMhIudHlwZXMuR0NQQ2xvdWRTUUxCFcjeHwDq3h8NZ2NwLG9taXRlbXB0eRI0CgVBenVyZRgHIAEoCzIMLnR5cGVzLkF6dXJlQhfI3h8A6t4fD2F6dXJlLG9taXRlbXB0eRI2CgNUTFMYCCABKAsyEi50eXBlcy5EYXRhYmFzZVRMU0IVyN4fAOreHw10bHMsb21pdGVtcHR5EisKAkFEGAkgASgLMgkudHlwZXMuQURCFMjeHwDq3h8MYWQsb21pdGVtcHR5EjsKBU15U1FMGAogASgLMhMudHlwZXMuTXlTUUxPcHRpb25zQhfI3h8A6t4fD215c3FsLG9taXRlbXB0eRJFCglBZG1pblVzZXIYCyABKAsyGC50eXBlcy5EYXRhYmFzZUFkbWluVXNlckIY6t4fFGFkbWluX3VzZXIsb21pdGVtcHR5EkQKCk1vbmdvQXRsYXMYDCABKAsyES50eXBlcy5Nb25nb0F0bGFzQh3I3h8A6t4fFW1vbmdvX2F0bGFzLG9taXRlbXB0eRI+CgZPcmFjbGUYDSABKAsyFC50eXBlcy5PcmFjbGVPcHRpb25zQhjI3h8A6t4fEG9yYWNsZSxvbWl0ZW1wdHkaSwoSRHluYW1pY0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRIkCgV2YWx1ZRgCIAEoCzIVLnR5cGVzLkNvbW1hbmRMYWJlbFYyOgI4ASJaChFEYXRhYmFzZUFkbWluVXNlchIWCgROYW1lGAEgASgJQgjq3h8EbmFtZRItCg9EZWZhdWx0RGF0YWJhc2UYAiABKAlCFOreHxBkZWZhdWx0X2RhdGFiYXNlIjIKDU9yYWNsZU9wdGlvbnMSIQoJQXVkaXRVc2VyGAEgASgJQg7q3h8KYXVkaXRfdXNlciL7AQoQRGF0YWJhc2VTdGF0dXNWMxIlCgZDQUNlcnQYASABKAlCFereHxFjYV9jZXJ0LG9taXRlbXB0eRIkCgNBV1MYAiABKAsyCi50eXBlcy5BV1NCC8jeHwDq3h8DYXdzEjsKBU15U1FMGAMgASgLMhMudHlwZXMuTXlTUUxPcHRpb25zQhfI3h8A6t4fD215c3FsLG9taXRlbXB0eRIxCgxNYW5hZ2VkVXNlcnMYBCADKAlCG+reHxdtYW5hZ2VkX3VzZXJzLG9taXRlbXB0eRIqCgVBenVyZRgFIAEoCzIMLnR5cGVzLkF6dXJlQg3I3h8A6t4fBWF6dXJlIv8HCgNBV1MSJAoGUmVnaW9uGAEgASgJQhTq3h8QcmVnaW9uLG9taXRlbXB0eRI9CghSZWRzaGlmdBgCIAEoCzIPLnR5cGVzLlJlZHNoaWZ0QhrI3h8A6t4fEnJlZHNoaWZ0LG9taXRlbXB0eRIuCgNSRFMYAyABKAsyCi50eXBlcy5SRFNCFcjeHwDq3h8NcmRzLG9taXRlbXB0eRIrCglBY2NvdW50SUQYBCABKAlCGOreHxRhY2NvdW50X2lkLG9taXRlbXB0eRJGCgtFbGFzdGlDYWNoZRgFIAEoCzISLnR5cGVzLkVsYXN0aUNhY2hlQh3I3h8A6t4fFWVsYXN0aWNhY2hlLG9taXRlbXB0eRJHCgtTZWNyZXRTdG9yZRgGIAEoCzISLnR5cGVzLlNlY3JldFN0b3JlQh7I3h8A6t4fFnNlY3JldF9zdG9yZSxvbWl0ZW1wdHkSPQoITWVtb3J5REIYByABKAsyDy50eXBlcy5NZW1vcnlEQkIayN4fAOreHxJtZW1vcnlkYixvbWl0ZW1wdHkSPQoIUkRTUHJveHkYCCABKAsyDy50eXBlcy5SRFNQcm94eUIayN4fAOreHxJyZHNwcm94eSxvbWl0ZW1wdHkSXAoSUmVkc2hpZnRTZXJ2ZXJsZXNzGAkgASgLMhkudHlwZXMuUmVkc2hpZnRTZXJ2ZXJsZXNzQiXI3h8A6t4fHXJlZHNoaWZ0X3NlcnZlcmxlc3Msb21pdGVtcHR5Ei0KCkV4dGVybmFsSUQYCiABKAlCGereHxVleHRlcm5hbF9pZCxvbWl0ZW1wdHkSNAoNQXNzdW1lUm9sZUFSThgLIAEoCUId6t4fGWFzc3VtZV9yb2xlX2FybixvbWl0ZW1wdHkSQwoKT3BlblNlYXJjaBgMIAEoCzIRLnR5cGVzLk9wZW5TZWFyY2hCHMjeHwDq3h8Ub3BlbnNlYXJjaCxvbWl0ZW1wdHkSRgoPSUFNUG9saWN5U3RhdHVzGA4gASgOMhYudHlwZXMuSUFNUG9saWN5U3RhdHVzQhXq3h8RaWFtX3BvbGljeV9zdGF0dXMSTAoLU2Vzc2lvblRhZ3MYDyADKAsyGy50eXBlcy5BV1MuU2Vzc2lvblRhZ3NFbnRyeUIa6t4fFnNlc3Npb25fdGFncyxvbWl0ZW1wdHkSPgoKRG9jdW1lbnREQhgQIAEoCzIRLnR5cGVzLkRvY3VtZW50REJCF8jeHwDq3h8PZG9jZGIsb21pdGVtcHR5GjIKEFNlc3Npb25UYWdzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUoECA0QDlIPSUFNUG9saWN5RXhpc3RzImYKC1NlY3JldFN0b3JlEisKCUtleVByZWZpeBgBIAEoCUIY6t4fFGtleV9wcmVmaXgsb21pdGVtcHR5EioKCEtNU0tleUlEGAIgASgJQhjq3h8Ua21zX2tleV9pZCxvbWl0ZW1wdHkiNwoIUmVkc2hpZnQSKwoJQ2x1c3RlcklEGAEgASgJQhjq3h8UY2x1c3Rlcl9pZCxvbWl0ZW1wdHki/AEKA1JEUxItCgpJbnN0YW5jZUlEGAEgASgJQhnq3h8VaW5zdGFuY2VfaWQsb21pdGVtcHR5EisKCUNsdXN0ZXJJRBgCIAEoCUIY6t4fFGNsdXN0ZXJfaWQsb21pdGVtcHR5Ei0KClJlc291cmNlSUQYAyABKAlCGereHxVyZXNvdXJjZV9pZCxvbWl0ZW1wdHkSHQoHSUFNQXV0aBgEIAEoCEIM6t4fCGlhbV9hdXRoEiYKB1N1Ym5ldHMYBSADKAlCFereHxFzdWJuZXRzLG9taXRlbXB0eRIjCgVWUENJRBgGIAEoCUIU6t4fEHZwY19pZCxvbWl0ZW1wdHkimwEKCFJEU1Byb3h5EiAKBE5hbWUYASABKAlCEureHw5uYW1lLG9taXRlbXB0eRI+ChJDdXN0b21FbmRwb2ludE5hbWUYAiABKAlCIureHx5jdXN0b21fZW5kcG9pbnRfbmFtZSxvbWl0ZW1wdHkSLQoKUmVzb3VyY2VJRBgDIAEoCUIZ6t4fFXJlc291cmNlX2lkLG9taXRlbXB0eSKAAgoLRWxhc3RpQ2FjaGUSPgoSUmVwbGljYXRpb25Hcm91cElEGAEgASgJQiLq3h8ecmVwbGljYXRpb25fZ3JvdXBfaWQsb21pdGVtcHR5EjIKDFVzZXJHcm91cElEcxgCIAMoCUIc6t4fGHVzZXJfZ3JvdXBfaWRzLG9taXRlbXB0eRJKChhUcmFuc2l0RW5jcnlwdGlvbkVuYWJsZWQYAyABKAhCKOreHyR0cmFuc2l0X2VuY3J5cHRpb25fZW5hYmxlZCxvbWl0ZW1wdHkSMQoMRW5kcG9pbnRUeXBlGAQgASgJQhvq3h8XZW5kcG9pbnRfdHlwZSxvbWl0ZW1wdHkixgEKCE1lbW9yeURCEi8KC0NsdXN0ZXJOYW1lGAEgASgJQhrq3h8WY2x1c3Rlcl9uYW1lLG9taXRlbXB0eRInCgdBQ0xOYW1lGAIgASgJQhbq3h8SYWNsX25hbWUsb21pdGVtcHR5Ei0KClRMU0VuYWJsZWQYAyABKAhCGereHxV0bHNfZW5hYmxlZCxvbWl0ZW1wdHkSMQoMRW5kcG9pbnRUeXBlGAQgASgJQhvq3h8XZW5kcG9pbnRfdHlwZSxvbWl0ZW1wdHkirQEKElJlZHNoaWZ0U2VydmVybGVzcxIzCg1Xb3JrZ3JvdXBOYW1lGAEgASgJQhzq3h8Yd29ya2dyb3VwX25hbWUsb21pdGVtcHR5EjEKDEVuZHBvaW50TmFtZRgCIAEoCUIb6t4fF2VuZHBvaW50X25hbWUsb21pdGVtcHR5Ei8KC1dvcmtncm91cElEGAMgASgJQhrq3h8Wd29ya2dyb3VwX2lkLG9taXRlbXB0eSKZAQoKT3BlblNlYXJjaBItCgpEb21haW5OYW1lGAEgASgJQhnq3h8VZG9tYWluX25hbWUsb21pdGVtcHR5EikKCERvbWFpbklEGAIgASgJQhfq3h8TZG9tYWluX2lkLG9taXRlbXB0eRIxCgxFbmRwb2ludFR5cGUYAyABKAlCG+reHxdlbmRwb2ludF90eXBlLG9taXRlbXB0eSKbAQoKRG9jdW1lbnREQhIrCglDbHVzdGVySUQYASABKAlCGOreHxRjbHVzdGVyX2lkLG9taXRlbXB0eRItCgpJbnN0YW5jZUlEGAIgASgJQhnq3h8VaW5zdGFuY2VfaWQsb21pdGVtcHR5EjEKDEVuZHBvaW50VHlwZRgDIAEoCUIb6t4fF2VuZHBvaW50X3R5cGUsb21pdGVtcHR5ImkKC0dDUENsb3VkU1FMEisKCVByb2plY3RJRBgBIAEoCUIY6t4fFHByb2plY3RfaWQsb21pdGVtcHR5Ei0KCkluc3RhbmNlSUQYAiABKAlCGereHxVpbnN0YW5jZV9pZCxvbWl0ZW1wdHkiyQEKBUF6dXJlEiAKBE5hbWUYASABKAlCEureHw5uYW1lLG9taXRlbXB0eRItCgpSZXNvdXJjZUlEGAIgASgJQhnq3h8VcmVzb3VyY2VfaWQsb21pdGVtcHR5EjkKBVJlZGlzGAMgASgLMhEudHlwZXMuQXp1cmVSZWRpc0IXyN4fAOreHw9yZWRpcyxvbWl0ZW1wdHkSNAoNSXNGbGV4aVNlcnZlchgEIAEoCEId6t4fGWlzX2ZsZXhpX3NlcnZlcixvbWl0ZW1wdHkiRwoKQXp1cmVSZWRpcxI5ChBDbHVzdGVyaW5nUG9saWN5GAEgASgJQh/q3h8bY2x1c3RlcmluZ19wb2xpY3ksb21pdGVtcHR5Iu0BCgJBRBItCgpLZXl0YWJGaWxlGAEgASgJQhnq3h8Va2V5dGFiX2ZpbGUsb21pdGVtcHR5EikKCEtyYjVGaWxlGAIgASgJQhfq3h8Ta3JiNV9maWxlLG9taXRlbXB0eRIaCgZEb21haW4YAyABKAlCCureHwZkb21haW4SFAoDU1BOGAQgASgJQgfq3h8Dc3BuEikKCExEQVBDZXJ0GAUgASgJQhfq3h8TbGRhcF9jZXJ0LG9taXRlbXB0eRIwCgtLRENIb3N0TmFtZRgGIAEoCUIb6t4fF2tkY19ob3N0X25hbWUsb21pdGVtcHR5ItYBCgtEYXRhYmFzZVRMUxIuCgRNb2RlGAEgASgOMhYudHlwZXMuRGF0YWJhc2VUTFNNb2RlQgjq3h8EbW9kZRIlCgZDQUNlcnQYAiABKAlCFereHxFjYV9jZXJ0LG9taXRlbXB0eRItCgpTZXJ2ZXJOYW1lGAMgASgJQhnq3h8Vc2VydmVyX25hbWUsb21pdGVtcHR5EkEKE1RydXN0U3lzdGVtQ2VydFBvb2wYBCABKAhCJOreHyB0cnVzdF9zeXN0ZW1fY2VydF9wb29sLG9taXRlbXB0eSJDCgxNeVNRTE9wdGlvbnMSMwoNU2VydmVyVmVyc2lvbhgBIAEoCUIc6t4fGHNlcnZlcl92ZXJzaW9uLG9taXRlbXB0eSIuCgpNb25nb0F0bGFzEiAKBE5hbWUYASABKAlCEureHw5uYW1lLG9taXRlbXB0eSJ0CgpJbnN0YW5jZVYxEjMKBkhlYWRlchgBIAEoCzIVLnR5cGVzLlJlc291cmNlSGVhZGVyQgzI3h8A0N4fAereHwASMQoEU3BlYxgCIAEoCzIVLnR5cGVzLkluc3RhbmNlU3BlY1YxQgzI3h8A6t4fBHNwZWMi3gMKDkluc3RhbmNlU3BlY1YxEiYKB1ZlcnNpb24YASABKAlCFereHxF2ZXJzaW9uLG9taXRlbXB0eRI2CghTZXJ2aWNlcxgCIAMoCUIk6t4fEnNlcnZpY2VzLG9taXRlbXB0efreHwpTeXN0ZW1Sb2xlEigKCEhvc3RuYW1lGAMgASgJQhbq3h8SaG9zdG5hbWUsb21pdGVtcHR5EiUKBkF1dGhJRBgEIAEoCUIV6t4fEWF1dGhfaWQsb21pdGVtcHR5Ek0KCExhc3RTZWVuGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIfyN4fAOreHxNsYXN0X3NlZW4sb21pdGVtcHR5kN8fARJRCgpDb250cm9sTG9nGAYgAygLMh4udHlwZXMuSW5zdGFuY2VDb250cm9sTG9nRW50cnlCHcjeHwDq3h8VY29udHJvbF9sb2csb21pdGVtcHR5EjQKEEV4dGVybmFsVXBncmFkZXIYByABKAlCGureHxZleHRfdXBncmFkZXIsb21pdGVtcHR5EkMKF0V4dGVybmFsVXBncmFkZXJWZXJzaW9uGAggASgJQiLq3h8eZXh0X3VwZ3JhZGVyX3ZlcnNpb24sb21pdGVtcHR5ItECChdJbnN0YW5jZUNvbnRyb2xMb2dFbnRyeRIgCgRUeXBlGAEgASgJQhLq3h8OdHlwZSxvbWl0ZW1wdHkSHAoCSUQYAiABKARCEOreHwxpZCxvbWl0ZW1wdHkSRAoEVGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCGsjeHwDq3h8OdGltZSxvbWl0ZW1wdHmQ3x8BEi8KA1RUTBgEIAEoA0Ii6t4fDXR0bCxvbWl0ZW1wdHn63h8NdGltZS5EdXJhdGlvbhJQCgZMYWJlbHMYBSADKAsyKi50eXBlcy5JbnN0YW5jZUNvbnRyb2xMb2dFbnRyeS5MYWJlbHNFbnRyeUIU6t4fEGxhYmVscyxvbWl0ZW1wdHkaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASK6AQoOSW5zdGFuY2VGaWx0ZXISEAoIU2VydmVySUQYASABKAkSDwoHVmVyc2lvbhgCIAEoCRIgCghTZXJ2aWNlcxgDIAMoCUIO+t4fClN5c3RlbVJvbGUSGAoQRXh0ZXJuYWxVcGdyYWRlchgEIAEoCRIVCg1Ob0V4dFVwZ3JhZGVyGAUgASgIEhgKEE9sZGVyVGhhblZlcnNpb24YBiABKAkSGAoQTmV3ZXJUaGFuVmVyc2lvbhgHIAEoCSLZAQoIU2VydmVyVjISFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEi8KBFNwZWMYBSABKAsyEy50eXBlcy5TZXJ2ZXJTcGVjVjJCDMjeHwDq3h8Ec3BlYzoImKAfAIDcIAAi4wQKDFNlcnZlclNwZWNWMhIWCgRBZGRyGAEgASgJQgjq3h8EYWRkchIeCghIb3N0bmFtZRgDIAEoCUIM6t4fCGhvc3RuYW1lElMKCUNtZExhYmVscxgEIAMoCzIiLnR5cGVzLlNlcnZlclNwZWNWMi5DbWRMYWJlbHNFbnRyeUIcyN4fAOreHxRjbWRfbGFiZWxzLG9taXRlbXB0eRI9CghSb3RhdGlvbhgFIAEoCzIPLnR5cGVzLlJvdGF0aW9uQhrI3h8A6t4fEnJvdGF0aW9uLG9taXRlbXB0eRIrCglVc2VUdW5uZWwYBiABKAhCGOreHxR1c2VfdHVubmVsLG9taXRlbXB0eRIcCgdWZXJzaW9uGAcgASgJQgvq3h8HdmVyc2lvbhIpCghQZWVyQWRkchgLIAEoCUIX6t4fE3BlZXJfYWRkcixvbWl0ZW1wdHkSKQoIUHJveHlJRHMYDCADKAlCF+reHxNwcm94eV9pZHMsb21pdGVtcHR5EhQKDHB1YmxpY19hZGRycxgNIAMoCRJJCg1DbG91ZE1ldGFkYXRhGA4gASgLMhQudHlwZXMuQ2xvdWRNZXRhZGF0YUIc6t4fGGNsb3VkX21ldGFkYXRhLG9taXRlbXB0eRpHCg5DbWRMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSJAoFdmFsdWUYAiABKAsyFS50eXBlcy5Db21tYW5kTGFiZWxWMjoCOAFKBAgCEANKBAgIEAlKBAgKEAtKBAgJEApSClB1YmxpY0FkZHJSEkt1YmVybmV0ZXNDbHVzdGVyc1IEQXBwcyL3AQoHQVdTSW5mbxIhCglBY2NvdW50SUQYASABKAlCDureHwphY2NvdW50X2lkEiMKCkluc3RhbmNlSUQYAiABKAlCD+reHwtpbnN0YW5jZV9pZBIkCgZSZWdpb24YAyABKAlCFOreHxByZWdpb24sb21pdGVtcHR5EiMKBVZQQ0lEGAQgASgJQhTq3h8QdnBjX2lkLG9taXRlbXB0eRIuCgtJbnRlZ3JhdGlvbhgFIAEoCUIZ6t4fFWludGVncmF0aW9uLG9taXRlbXB0eRIpCghTdWJuZXRJRBgGIAEoCUIX6t4fE3N1Ym5ldF9pZCxvbWl0ZW1wdHkiPwoNQ2xvdWRNZXRhZGF0YRIuCgNBV1MYASABKAsyDi50eXBlcy5BV1NJbmZvQhHq3h8NYXdzLG9taXRlbXB0eSLfAQoLQXBwU2VydmVyVjMSFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjIKBFNwZWMYBSABKAsyFi50eXBlcy5BcHBTZXJ2ZXJTcGVjVjNCDMjeHwDq3h8Ec3BlYzoImKAfAIDcIAAi+gEKD0FwcFNlcnZlclNwZWNWMxIcCgdWZXJzaW9uGAEgASgJQgvq3h8HdmVyc2lvbhIeCghIb3N0bmFtZRgCIAEoCUIM6t4fCGhvc3RuYW1lEhsKBkhvc3RJRBgDIAEoCUIL6t4fB2hvc3RfaWQSPQoIUm90YXRpb24YBCABKAsyDy50eXBlcy5Sb3RhdGlvbkIayN4fAOreHxJyb3RhdGlvbixvbWl0ZW1wdHkSIgoDQXBwGAUgASgLMgwudHlwZXMuQXBwVjNCB+reHwNhcHASKQoIUHJveHlJRHMYBiADKAlCF+reHxNwcm94eV9pZHMsb21pdGVtcHR5IicKCUFwcFYzTGlzdBIaCgRBcHBzGAEgAygLMgwudHlwZXMuQXBwVjMi0wEKBUFwcFYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRIsCgRTcGVjGAUgASgLMhAudHlwZXMuQXBwU3BlY1YzQgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAItACCgpDT1JTUG9saWN5EjYKD2FsbG93ZWRfb3JpZ2lucxgBIAMoCUId6t4fGWFsbG93ZWRfb3JpZ2lucyxvbWl0ZW1wdHkSNgoPYWxsb3dlZF9tZXRob2RzGAIgAygJQh3q3h8ZYWxsb3dlZF9tZXRob2RzLG9taXRlbXB0eRI2Cg9hbGxvd2VkX2hlYWRlcnMYAyADKAlCHereHxlhbGxvd2VkX2hlYWRlcnMsb21pdGVtcHR5EjoKEWFsbG93X2NyZWRlbnRpYWxzGAQgASgIQh/q3h8bYWxsb3dfY3JlZGVudGlhbHMsb21pdGVtcHR5EiYKB21heF9hZ2UYBSABKA1CFereHxFtYXhfYWdlLG9taXRlbXB0eRI2Cg9leHBvc2VkX2hlYWRlcnMYBiADKAlCHereHxlleHBvc2VkX2hlYWRlcnMsb21pdGVtcHR5IvEECglBcHBTcGVjVjMSFAoDVVJJGAEgASgJQgfq3h8DdXJpEi0KClB1YmxpY0FkZHIYAiABKAlCGereHxVwdWJsaWNfYWRkcixvbWl0ZW1wdHkSXAoNRHluYW1pY0xhYmVscxgDIAMoCzIjLnR5cGVzLkFwcFNwZWNWMy5EeW5hbWljTGFiZWxzRW50cnlCIMjeHwDq3h8YZHluYW1pY19sYWJlbHMsb21pdGVtcHR5EjQKEkluc2VjdXJlU2tpcFZlcmlmeRgEIAEoCEIY6t4fFGluc2VjdXJlX3NraXBfdmVyaWZ5EjYKB1Jld3JpdGUYBSABKAsyDi50eXBlcy5SZXdyaXRlQhXq3h8RcmV3cml0ZSxvbWl0ZW1wdHkSLQoDQVdTGAYgASgLMg0udHlwZXMuQXBwQVdTQhHq3h8NYXdzLG9taXRlbXB0eRIiCgVDbG91ZBgHIAEoCUIT6t4fD2Nsb3VkLG9taXRlbXB0eRISCgpVc2VyR3JvdXBzGAggAygJEi4KC0ludGVncmF0aW9uGAkgASgJQhnq3h8VaW50ZWdyYXRpb24sb21pdGVtcHR5EjoKEFJlcXVpcmVkQXBwTmFtZXMYCiADKAlCIOreHxxyZXF1aXJlZF9hcHBfbmFtZXMsb21pdGVtcHR5EjMKBENPUlMYCyABKAsyES50eXBlcy5DT1JTUG9saWN5QhLq3h8OY29ycyxvbWl0ZW1wdHkaSwoSRHluYW1pY0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRIkCgV2YWx1ZRgCIAEoCzIVLnR5cGVzLkNvbW1hbmRMYWJlbFYyOgI4ASKEAgojQXBwU2VydmVyT3JTQU1MSWRQU2VydmljZVByb3ZpZGVyVjESFgoES2luZBgBIAEoCUII6t4fBGtpbmQSQQoJQXBwU2VydmVyGAIgASgLMhIudHlwZXMuQXBwU2VydmVyVjNCGOreHxRhcHBfc2VydmVyLG9taXRlbXB0eUgAEmoKFlNBTUxJZFBTZXJ2aWNlUHJvdmlkZXIYAyABKAsyHy50eXBlcy5TQU1MSWRQU2VydmljZVByb3ZpZGVyVjFCJ+reHyNzYW1sX2lkcF9zZXJ2aWNlX3Byb3ZpZGVyLG9taXRlbXB0eUgAOgoYAZigHwCA3CAAQgoKCFJlc291cmNlIpcBCgdSZXdyaXRlEigKCFJlZGlyZWN0GAEgAygJQhbq3h8ScmVkaXJlY3Qsb21pdGVtcHR5EjUKB0hlYWRlcnMYAiADKAsyDS50eXBlcy5IZWFkZXJCFereHxFoZWFkZXJzLG9taXRlbXB0eRIrCglKV1RDbGFpbXMYAyABKAlCGOreHxRqd3RfY2xhaW1zLG9taXRlbXB0eSI6CgZIZWFkZXISFgoETmFtZRgBIAEoCUII6t4fBG5hbWUSGAoFVmFsdWUYAiABKAlCCereHwV2YWx1ZSJyCg5Db21tYW5kTGFiZWxWMhImCgZQZXJpb2QYASABKANCFureHwZwZXJpb2T63h8IRHVyYXRpb24SHAoHQ29tbWFuZBgCIAMoCUIL6t4fB2NvbW1hbmQSGgoGUmVzdWx0GAMgASgJQgrq3h8GcmVzdWx0IjcKBkFwcEFXUxItCgpFeHRlcm5hbElEGAEgASgJQhnq3h8VZXh0ZXJuYWxfaWQsb21pdGVtcHR5IrcBCgpTU0hLZXlQYWlyEisKCVB1YmxpY0tleRgBIAEoDEIY6t4fFHB1YmxpY19rZXksb21pdGVtcHR5Ei0KClByaXZhdGVLZXkYAiABKAxCGereHxVwcml2YXRlX2tleSxvbWl0ZW1wdHkSTQoOUHJpdmF0ZUtleVR5cGUYAyABKA4yFS50eXBlcy5Qcml2YXRlS2V5VHlwZUIe6t4fGnByaXZhdGVfa2V5X3R5cGUsb21pdGVtcHR5Io4BCgpUTFNLZXlQYWlyEiAKBENlcnQYASABKAxCEureHw5jZXJ0LG9taXRlbXB0eRIeCgNLZXkYAiABKAxCEereHw1rZXksb21pdGVtcHR5Ej4KB0tleVR5cGUYAyABKA4yFS50eXBlcy5Qcml2YXRlS2V5VHlwZUIW6t4fEmtleV90eXBlLG9taXRlbXB0eSK3AQoKSldUS2V5UGFpchIrCglQdWJsaWNLZXkYASABKAxCGOreHxRwdWJsaWNfa2V5LG9taXRlbXB0eRItCgpQcml2YXRlS2V5GAIgASgMQhnq3h8VcHJpdmF0ZV9rZXksb21pdGVtcHR5Ek0KDlByaXZhdGVLZXlUeXBlGAMgASgOMhUudHlwZXMuUHJpdmF0ZUtleVR5cGVCHureHxpwcml2YXRlX2tleV90eXBlLG9taXRlbXB0eSLnAQoPQ2VydEF1dGhvcml0eVYyEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI2CgRTcGVjGAUgASgLMhoudHlwZXMuQ2VydEF1dGhvcml0eVNwZWNWMkIMyN4fAOreHwRzcGVjOgiYoB8AgNwgACLwBAoTQ2VydEF1dGhvcml0eVNwZWNWMhImCgRUeXBlGAEgASgJQhjq3h8EdHlwZfreHwxDZXJ0QXV0aFR5cGUSJQoLQ2x1c3Rlck5hbWUYAiABKAlCEOreHwxjbHVzdGVyX25hbWUSIgoFUm9sZXMYBSADKAlCE+reHw9yb2xlcyxvbWl0ZW1wdHkSPwoHUm9sZU1hcBgGIAMoCzISLnR5cGVzLlJvbGVNYXBwaW5nQhrI3h8A6t4fEnJvbGVfbWFwLG9taXRlbXB0eRI9CghSb3RhdGlvbhgIIAEoCzIPLnR5cGVzLlJvdGF0aW9uQhrI3h8B6t4fEnJvdGF0aW9uLG9taXRlbXB0eRJaCgpTaWduaW5nQWxnGAkgASgOMikudHlwZXMuQ2VydEF1dGhvcml0eVNwZWNWMi5TaWduaW5nQWxnVHlwZUIbGAHq3h8Vc2lnbmluZ19hbGcsb21pdGVtcHR5EkIKCkFjdGl2ZUtleXMYCyABKAsyDy50eXBlcy5DQUtleVNldEIdyN4fAOreHxVhY3RpdmVfa2V5cyxvbWl0ZW1wdHkSWQoVQWRkaXRpb25hbFRydXN0ZWRLZXlzGAwgASgLMg8udHlwZXMuQ0FLZXlTZXRCKcjeHwDq3h8hYWRkaXRpb25hbF90cnVzdGVkX2tleXMsb21pdGVtcHR5IlMKDlNpZ25pbmdBbGdUeXBlEgsKB1VOS05PV04QABIMCghSU0FfU0hBMRABEhAKDFJTQV9TSEEyXzI1NhACEhAKDFJTQV9TSEEyXzUxMhADGgIYAUoECAMQBEoECAQQBUoECAcQCEoECAoQCyKjAQoIQ0FLZXlTZXQSMQoDU1NIGAEgAygLMhEudHlwZXMuU1NIS2V5UGFpckIR6t4fDXNzaCxvbWl0ZW1wdHkSMQoDVExTGAIgAygLMhEudHlwZXMuVExTS2V5UGFpckIR6t4fDXRscyxvbWl0ZW1wdHkSMQoDSldUGAMgAygLMhEudHlwZXMuSldUS2V5UGFpckIR6t4fDWp3dCxvbWl0ZW1wdHkiQwoLUm9sZU1hcHBpbmcSGgoGUmVtb3RlGAEgASgJQgrq3h8GcmVtb3RlEhgKBUxvY2FsGAIgAygJQgnq3h8FbG9jYWwiqgEKEFByb3Zpc2lvblRva2VuVjESJgoFUm9sZXMYASADKAlCF+reHwVyb2xlc/reHwpTeXN0ZW1Sb2xlEkoKB0V4cGlyZXMYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEWV4cGlyZXMsb21pdGVtcHR5kN8fARIYCgVUb2tlbhgDIAEoCUIJ6t4fBXRva2VuOgiYoB8AgNwgACLpAQoQUHJvdmlzaW9uVG9rZW5WMhIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESNwoEU3BlYxgFIAEoCzIbLnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyQgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAIkgKFFByb3Zpc2lvblRva2VuVjJMaXN0EjAKD1Byb3Zpc2lvblRva2VucxgBIAMoCzIXLnR5cGVzLlByb3Zpc2lvblRva2VuVjIiuQEKCVRva2VuUnVsZRItCgpBV1NBY2NvdW50GAEgASgJQhnq3h8VYXdzX2FjY291bnQsb21pdGVtcHR5Ei0KCkFXU1JlZ2lvbnMYAiADKAlCGereHxVhd3NfcmVnaW9ucyxvbWl0ZW1wdHkSJwoHQVdTUm9sZRgDIAEoCUIW6t4fEmF3c19yb2xlLG9taXRlbXB0eRIlCgZBV1NBUk4YBCABKAlCFereHxFhd3NfYXJuLG9taXRlbXB0eSKQCQoUUHJvdmlzaW9uVG9rZW5TcGVjVjISJgoFUm9sZXMYASADKAlCF+reHwVyb2xlc/reHwpTeXN0ZW1Sb2xlEjQKBUFsbG93GAIgAygLMhAudHlwZXMuVG9rZW5SdWxlQhPq3h8PYWxsb3csb21pdGVtcHR5EjgKCUFXU0lJRFRUTBgDIAEoA0Il6t4fFWF3c19paWRfdHRsLG9taXRlbXB0efreHwhEdXJhdGlvbhIxCgpKb2luTWV0aG9kGAQgASgJQh3q3h8Lam9pbl9tZXRob2T63h8KSm9pbk1ldGhvZBInCgdCb3ROYW1lGAUgASgJQhbq3h8SYm90X25hbWUsb21pdGVtcHR5ElwKD1N1Z2dlc3RlZExhYmVscxgGIAEoCzIVLndyYXBwZXJzLkxhYmVsVmFsdWVzQizI3h8A2t4fBkxhYmVsc+reHxpzdWdnZXN0ZWRfbGFiZWxzLG9taXRlbXB0eRJHCgZHaXRIdWIYByABKAsyIS50eXBlcy5Qcm92aXNpb25Ub2tlblNwZWNWMkdpdEh1YkIU6t4fEGdpdGh1YixvbWl0ZW1wdHkSTQoIQ2lyY2xlQ0kYCCABKAsyIy50eXBlcy5Qcm92aXNpb25Ub2tlblNwZWNWMkNpcmNsZUNJQhbq3h8SY2lyY2xlY2ksb21pdGVtcHR5EnYKG1N1Z2dlc3RlZEFnZW50TWF0Y2hlckxhYmVscxgJIAEoCzIVLndyYXBwZXJzLkxhYmVsVmFsdWVzQjrI3h8A2t4fBkxhYmVsc+reHyhzdWdnZXN0ZWRfYWdlbnRfbWF0Y2hlcl9sYWJlbHMsb21pdGVtcHR5ElMKCkt1YmVybmV0ZXMYCiABKAsyJS50eXBlcy5Qcm92aXNpb25Ub2tlblNwZWNWMkt1YmVybmV0ZXNCGOreHxRrdWJlcm5ldGVzLG9taXRlbXB0eRJECgVBenVyZRgLIAEoCzIgLnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyQXp1cmVCE+reHw9henVyZSxvbWl0ZW1wdHkSRwoGR2l0TGFiGAwgASgLMiEudHlwZXMuUHJvdmlzaW9uVG9rZW5TcGVjVjJHaXRMYWJCFOreHxBnaXRsYWIsb21pdGVtcHR5Ej4KA0dDUBgNIAEoCzIeLnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyR0NQQhHq3h8NZ2NwLG9taXRlbXB0eRJQCglTcGFjZWxpZnQYDiABKAsyJC50eXBlcy5Qcm92aXNpb25Ub2tlblNwZWNWMlNwYWNlbGlmdEIX6t4fE3NwYWNlbGlmdCxvbWl0ZW1wdHkSPgoDVFBNGA8gASgLMh4udHlwZXMuUHJvdmlzaW9uVG9rZW5TcGVjVjJUUE1CEereHw10cG0sb21pdGVtcHR5EmAKDlRlcnJhZm9ybUNsb3VkGBAgASgLMikudHlwZXMuUHJvdmlzaW9uVG9rZW5TcGVjVjJUZXJyYWZvcm1DbG91ZEId6t4fGXRlcnJhZm9ybV9jbG91ZCxvbWl0ZW1wdHki8gIKF1Byb3Zpc2lvblRva2VuU3BlY1YyVFBNEkcKBUFsbG93GAEgAygLMiMudHlwZXMuUHJvdmlzaW9uVG9rZW5TcGVjVjJUUE0uUnVsZUIT6t4fD2FsbG93LG9taXRlbXB0eRI6ChBFS0NlcnRBbGxvd2VkQ0FzGAIgAygJQiDq3h8cZWtjZXJ0X2FsbG93ZWRfY2FzLG9taXRlbXB0eRrRAQoEUnVsZRIuCgtEZXNjcmlwdGlvbhgBIAEoCUIZ6t4fFWRlc2NyaXB0aW9uLG9taXRlbXB0eRIyCgxFS1B1YmxpY0hhc2gYBCABKAlCHOreHxhla19wdWJsaWNfaGFzaCxvbWl0ZW1wdHkSQAoTRUtDZXJ0aWZpY2F0ZVNlcmlhbBgFIAEoCUIj6t4fH2VrX2NlcnRpZmljYXRlX3NlcmlhbCxvbWl0ZW1wdHlKBAgCEANKBAgDEARSCUVLUHViSGFzaFIMRUtDZXJ0U2VyaWFsIroEChpQcm92aXNpb25Ub2tlblNwZWNWMkdpdEh1YhJKCgVBbGxvdxgBIAMoCzImLnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyR2l0SHViLlJ1bGVCE+reHw9hbGxvdyxvbWl0ZW1wdHkSQgoURW50ZXJwcmlzZVNlcnZlckhvc3QYAiABKAlCJOreHyBlbnRlcnByaXNlX3NlcnZlcl9ob3N0LG9taXRlbXB0eRI1Cg5FbnRlcnByaXNlU2x1ZxgDIAEoCUId6t4fGWVudGVycHJpc2Vfc2x1ZyxvbWl0ZW1wdHka1AIKBFJ1bGUSHgoDU3ViGAEgASgJQhHq3h8Nc3ViLG9taXRlbXB0eRIsCgpSZXBvc2l0b3J5GAIgASgJQhjq3h8UcmVwb3NpdG9yeSxvbWl0ZW1wdHkSNwoPUmVwb3NpdG9yeU93bmVyGAMgASgJQh7q3h8acmVwb3NpdG9yeV9vd25lcixvbWl0ZW1wdHkSKAoIV29ya2Zsb3cYBCABKAlCFureHxJ3b3JrZmxvdyxvbWl0ZW1wdHkSLgoLRW52aXJvbm1lbnQYBSABKAlCGereHxVlbnZpcm9ubWVudCxvbWl0ZW1wdHkSIgoFQWN0b3IYBiABKAlCE+reHw9hY3RvcixvbWl0ZW1wdHkSHgoDUmVmGAcgASgJQhHq3h8NcmVmLG9taXRlbXB0eRInCgdSZWZUeXBlGAggASgJQhbq3h8ScmVmX3R5cGUsb21pdGVtcHR5IusHChpQcm92aXNpb25Ub2tlblNwZWNWMkdpdExhYhJKCgVBbGxvdxgBIAMoCzImLnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyR2l0TGFiLlJ1bGVCE+reHw9hbGxvdyxvbWl0ZW1wdHkSJAoGRG9tYWluGAIgASgJQhTq3h8QZG9tYWluLG9taXRlbXB0eRraBgoEUnVsZRIeCgNTdWIYASABKAlCEereHw1zdWIsb21pdGVtcHR5Eh4KA1JlZhgCIAEoCUIR6t4fDXJlZixvbWl0ZW1wdHkSJwoHUmVmVHlwZRgDIAEoCUIW6t4fEnJlZl90eXBlLG9taXRlbXB0eRIzCg1OYW1lc3BhY2VQYXRoGAQgASgJQhzq3h8YbmFtZXNwYWNlX3BhdGgsb21pdGVtcHR5Ei8KC1Byb2plY3RQYXRoGAUgASgJQhrq3h8WcHJvamVjdF9wYXRoLG9taXRlbXB0eRI1Cg5QaXBlbGluZVNvdXJjZRgGIAEoCUId6t4fGXBpcGVsaW5lX3NvdXJjZSxvbWl0ZW1wdHkSLgoLRW52aXJvbm1lbnQYByABKAlCGereHxVlbnZpcm9ubWVudCxvbWl0ZW1wdHkSKwoJVXNlckxvZ2luGAggASgJQhjq3h8UdXNlcl9sb2dpbixvbWl0ZW1wdHkSJQoGVXNlcklEGAkgASgJQhXq3h8RdXNlcl9pZCxvbWl0ZW1wdHkSKwoJVXNlckVtYWlsGAogASgJQhjq3h8UdXNlcl9lbWFpbCxvbWl0ZW1wdHkSVQoMUmVmUHJvdGVjdGVkGAsgASgLMhAudHlwZXMuQm9vbFZhbHVlQi3I3h8B2t4fCkJvb2xPcHRpb27q3h8XcmVmX3Byb3RlY3RlZCxvbWl0ZW1wdHkSZQoURW52aXJvbm1lbnRQcm90ZWN0ZWQYDCABKAsyEC50eXBlcy5Cb29sVmFsdWVCNcjeHwHa3h8KQm9vbE9wdGlvbureHx9lbnZpcm9ubWVudF9wcm90ZWN0ZWQsb21pdGVtcHR5EjAKC0NJQ29uZmlnU0hBGA0gASgJQhvq3h8XY2lfY29uZmlnX3NoYSxvbWl0ZW1wdHkSNwoOQ0lDb25maWdSZWZVUkkYDiABKAlCH+reHxtjaV9jb25maWdfcmVmX3VyaSxvbWl0ZW1wdHkSNQoORGVwbG95bWVudFRpZXIYDyABKAlCHereHxlkZXBsb3ltZW50X3RpZXIsb21pdGVtcHR5EjsKEVByb2plY3RWaXNpYmlsaXR5GBAgASgJQiDq3h8ccHJvamVjdF92aXNpYmlsaXR5LG9taXRlbXB0eSKFAgocUHJvdmlzaW9uVG9rZW5TcGVjVjJDaXJjbGVDSRJMCgVBbGxvdxgBIAMoCzIoLnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyQ2lyY2xlQ0kuUnVsZUIT6t4fD2FsbG93LG9taXRlbXB0eRI1Cg5Pcmdhbml6YXRpb25JRBgCIAEoCUId6t4fGW9yZ2FuaXphdGlvbl9pZCxvbWl0ZW1wdHkaYAoEUnVsZRIrCglQcm9qZWN0SUQYASABKAlCGOreHxRwcm9qZWN0X2lkLG9taXRlbXB0eRIrCglDb250ZXh0SUQYAiABKAlCGOreHxRjb250ZXh0X2lkLG9taXRlbXB0eSLIAgodUHJvdmlzaW9uVG9rZW5TcGVjVjJTcGFjZWxpZnQSTQoFQWxsb3cYASADKAsyKS50eXBlcy5Qcm92aXNpb25Ub2tlblNwZWNWMlNwYWNlbGlmdC5SdWxlQhPq3h8PYWxsb3csb21pdGVtcHR5EigKCEhvc3RuYW1lGAIgASgJQhbq3h8SaG9zdG5hbWUsb21pdGVtcHR5Gq0BCgRSdWxlEicKB1NwYWNlSUQYASABKAlCFureHxJzcGFjZV9pZCxvbWl0ZW1wdHkSKQoIQ2FsbGVySUQYAiABKAlCF+reHxNjYWxsZXJfaWQsb21pdGVtcHR5Ei0KCkNhbGxlclR5cGUYAyABKAlCGereHxVjYWxsZXJfdHlwZSxvbWl0ZW1wdHkSIgoFU2NvcGUYBCABKAlCE+reHw9zY29wZSxvbWl0ZW1wdHkihAMKHlByb3Zpc2lvblRva2VuU3BlY1YyS3ViZXJuZXRlcxJOCgVBbGxvdxgBIAMoCzIqLnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyS3ViZXJuZXRlcy5SdWxlQhPq3h8PYWxsb3csb21pdGVtcHR5EjYKBFR5cGUYAiABKAlCKOreHw50eXBlLG9taXRlbXB0efreHxJLdWJlcm5ldGVzSm9pblR5cGUSZQoKU3RhdGljSldLUxgDIAEoCzI2LnR5cGVzLlByb3Zpc2lvblRva2VuU3BlY1YyS3ViZXJuZXRlcy5TdGF0aWNKV0tTQ29uZmlnQhnq3h8Vc3RhdGljX2p3a3Msb21pdGVtcHR5GjQKEFN0YXRpY0pXS1NDb25maWcSIAoESldLUxgBIAEoCUIS6t4fDmp3a3Msb21pdGVtcHR5Gj0KBFJ1bGUSNQoOU2VydmljZUFjY291bnQYASABKAlCHereHxlzZXJ2aWNlX2FjY291bnQsb21pdGVtcHR5ItcBChlQcm92aXNpb25Ub2tlblNwZWNWMkF6dXJlEkkKBUFsbG93GAEgAygLMiUudHlwZXMuUHJvdmlzaW9uVG9rZW5TcGVjVjJBenVyZS5SdWxlQhPq3h8PYWxsb3csb21pdGVtcHR5Gm8KBFJ1bGUSMAoMU3Vic2NyaXB0aW9uGAEgASgJQhrq3h8Wc3Vic2NyaXB0aW9uLG9taXRlbXB0eRI1Cg5SZXNvdXJjZUdyb3VwcxgCIAMoCUId6t4fGXJlc291cmNlX2dyb3VwcyxvbWl0ZW1wdHki/wEKF1Byb3Zpc2lvblRva2VuU3BlY1YyR0NQEkcKBUFsbG93GAEgAygLMiMudHlwZXMuUHJvdmlzaW9uVG9rZW5TcGVjVjJHQ1AuUnVsZUIT6t4fD2FsbG93LG9taXRlbXB0eRqaAQoEUnVsZRItCgpQcm9qZWN0SURzGAEgAygJQhnq3h8VcHJvamVjdF9pZHMsb21pdGVtcHR5EioKCUxvY2F0aW9ucxgCIAMoCUIX6t4fE2xvY2F0aW9ucyxvbWl0ZW1wdHkSNwoPU2VydmljZUFjY291bnRzGAMgAygJQh7q3h8ac2VydmljZV9hY2NvdW50cyxvbWl0ZW1wdHkitgQKIlByb3Zpc2lvblRva2VuU3BlY1YyVGVycmFmb3JtQ2xvdWQSUgoFQWxsb3cYASADKAsyLi50eXBlcy5Qcm92aXNpb25Ub2tlblNwZWNWMlRlcnJhZm9ybUNsb3VkLlJ1bGVCE+reHw9hbGxvdyxvbWl0ZW1wdHkSKAoIQXVkaWVuY2UYAiABKAlCFureHxJhdWRpZW5jZSxvbWl0ZW1wdHkSKAoISG9zdG5hbWUYAyABKAlCFureHxJob3N0bmFtZSxvbWl0ZW1wdHka5wIKBFJ1bGUSNQoOT3JnYW5pemF0aW9uSUQYASABKAlCHereHxlvcmdhbml6YXRpb25faWQsb21pdGVtcHR5EjkKEE9yZ2FuaXphdGlvbk5hbWUYAiABKAlCH+reHxtvcmdhbml6YXRpb25fbmFtZSxvbWl0ZW1wdHkSKwoJUHJvamVjdElEGAMgASgJQhjq3h8UcHJvamVjdF9pZCxvbWl0ZW1wdHkSLwoLUHJvamVjdE5hbWUYBCABKAlCGureHxZwcm9qZWN0X25hbWUsb21pdGVtcHR5Ei8KC1dvcmtzcGFjZUlEGAUgASgJQhrq3h8Wd29ya3NwYWNlX2lkLG9taXRlbXB0eRIzCg1Xb3Jrc3BhY2VOYW1lGAYgASgJQhzq3h8Yd29ya3NwYWNlX25hbWUsb21pdGVtcHR5EikKCFJ1blBoYXNlGAcgASgJQhfq3h8TcnVuX3BoYXNlLG9taXRlbXB0eSLlAQoOU3RhdGljVG9rZW5zVjISFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjUKBFNwZWMYBSABKAsyGS50eXBlcy5TdGF0aWNUb2tlbnNTcGVjVjJCDMjeHwDq3h8Ec3BlYzoImKAfAIDcIAAiWgoSU3RhdGljVG9rZW5zU3BlY1YyEkQKDFN0YXRpY1Rva2VucxgBIAMoCzIXLnR5cGVzLlByb3Zpc2lvblRva2VuVjFCFcjeHwDq3h8Nc3RhdGljX3Rva2VucyLjAQoNQ2x1c3Rlck5hbWVWMhIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESNAoEU3BlYxgFIAEoCzIYLnR5cGVzLkNsdXN0ZXJOYW1lU3BlY1YyQgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAIl0KEUNsdXN0ZXJOYW1lU3BlY1YyEiUKC0NsdXN0ZXJOYW1lGAEgASgJQhDq3h8MY2x1c3Rlcl9uYW1lEiEKCUNsdXN0ZXJJRBgCIAEoCUIO6t4fCmNsdXN0ZXJfaWQi5wEKFENsdXN0ZXJBdWRpdENvbmZpZ1YyEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI7CgRTcGVjGAUgASgLMh8udHlwZXMuQ2x1c3RlckF1ZGl0Q29uZmlnU3BlY1YyQgzI3h8A6t4fBHNwZWMinQgKGENsdXN0ZXJBdWRpdENvbmZpZ1NwZWNWMhIgCgRUeXBlGAEgASgJQhLq3h8OdHlwZSxvbWl0ZW1wdHkSJAoGUmVnaW9uGAIgASgJQhTq3h8QcmVnaW9uLG9taXRlbXB0eRI6ChBBdWRpdFNlc3Npb25zVVJJGAMgASgJQiDq3h8cYXVkaXRfc2Vzc2lvbnNfdXJpLG9taXRlbXB0eRKSAQoOQXVkaXRFdmVudHNVUkkYBCABKAsyFi53cmFwcGVycy5TdHJpbmdWYWx1ZXNCYsjeHwDa3h88Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS90eXBlcy93cmFwcGVycy5TdHJpbmdz6t4fGmF1ZGl0X2V2ZW50c191cmksb21pdGVtcHR5EkEKF0VuYWJsZUNvbnRpbnVvdXNCYWNrdXBzGAYgASgIQiDq3h8cY29udGludW91c19iYWNrdXBzLG9taXRlbXB0eRI1ChFFbmFibGVBdXRvU2NhbGluZxgHIAEoCEIa6t4fFmF1dG9fc2NhbGluZyxvbWl0ZW1wdHkSOAoPUmVhZE1heENhcGFjaXR5GAggASgDQh/q3h8bcmVhZF9tYXhfY2FwYWNpdHksb21pdGVtcHR5EjgKD1JlYWRNaW5DYXBhY2l0eRgJIAEoA0If6t4fG3JlYWRfbWluX2NhcGFjaXR5LG9taXRlbXB0eRI4Cg9SZWFkVGFyZ2V0VmFsdWUYCiABKAFCH+reHxtyZWFkX3RhcmdldF92YWx1ZSxvbWl0ZW1wdHkSOgoQV3JpdGVNYXhDYXBhY2l0eRgLIAEoA0Ig6t4fHHdyaXRlX21heF9jYXBhY2l0eSxvbWl0ZW1wdHkSOgoQV3JpdGVNaW5DYXBhY2l0eRgMIAEoA0Ig6t4fHHdyaXRlX21pbl9jYXBhY2l0eSxvbWl0ZW1wdHkSOgoQV3JpdGVUYXJnZXRWYWx1ZRgNIAEoAUIg6t4fHHdyaXRlX3RhcmdldF92YWx1ZSxvbWl0ZW1wdHkSPQoPUmV0ZW50aW9uUGVyaW9kGA4gASgDQiTI3h8B6t4fEHJldGVudGlvbl9wZXJpb2T63h8IRHVyYXRpb24SawoPVXNlRklQU0VuZHBvaW50GA8gASgOMjEudHlwZXMuQ2x1c3RlckF1ZGl0Q29uZmlnU3BlY1YyLkZJUFNFbmRwb2ludFN0YXRlQh/q3h8bdXNlX2ZpcHNfZW5kcG9pbnQsb21pdGVtcHR5IkgKEUZJUFNFbmRwb2ludFN0YXRlEg4KCkZJUFNfVU5TRVQQABIQCgxGSVBTX0VOQUJMRUQQARIRCg1GSVBTX0RJU0FCTEVEEAJKBAgFEAZSEGF1ZGl0X3RhYmxlX25hbWUi8QEKGUNsdXN0ZXJOZXR3b3JraW5nQ29uZmlnVjISFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEkAKBFNwZWMYBSABKAsyJC50eXBlcy5DbHVzdGVyTmV0d29ya2luZ0NvbmZpZ1NwZWNWMkIMyN4fAOreHwRzcGVjIrgHCh1DbHVzdGVyTmV0d29ya2luZ0NvbmZpZ1NwZWNWMhI+ChFDbGllbnRJZGxlVGltZW91dBgBIAEoA0Ij6t4fE2NsaWVudF9pZGxlX3RpbWVvdXT63h8IRHVyYXRpb24SPgoRS2VlcEFsaXZlSW50ZXJ2YWwYAiABKANCI+reHxNrZWVwX2FsaXZlX2ludGVydmFs+t4fCER1cmF0aW9uEjMKEUtlZXBBbGl2ZUNvdW50TWF4GAMgASgDQhjq3h8Ua2VlcF9hbGl2ZV9jb3VudF9tYXgSRgoVU2Vzc2lvbkNvbnRyb2xUaW1lb3V0GAQgASgDQifq3h8Xc2Vzc2lvbl9jb250cm9sX3RpbWVvdXT63h8IRHVyYXRpb24SOgoYQ2xpZW50SWRsZVRpbWVvdXRNZXNzYWdlGAUgASgJQhjq3h8UaWRsZV90aW1lb3V0X21lc3NhZ2USOAoOV2ViSWRsZVRpbWVvdXQYBiABKANCIOreHxB3ZWJfaWRsZV90aW1lb3V0+t4fCER1cmF0aW9uElYKEVByb3h5TGlzdGVuZXJNb2RlGAcgASgOMhgudHlwZXMuUHJveHlMaXN0ZW5lck1vZGVCIereHx1wcm94eV9saXN0ZW5lcl9tb2RlLG9taXRlbXB0eRJPCg9Sb3V0aW5nU3RyYXRlZ3kYCCABKA4yFi50eXBlcy5Sb3V0aW5nU3RyYXRlZ3lCHureHxpyb3V0aW5nX3N0cmF0ZWd5LG9taXRlbXB0eRJOCg5UdW5uZWxTdHJhdGVneRgJIAEoCzIXLnR5cGVzLlR1bm5lbFN0cmF0ZWd5VjFCHereHxl0dW5uZWxfc3RyYXRlZ3ksb21pdGVtcHR5EkgKEVByb3h5UGluZ0ludGVydmFsGAogASgDQi3q3h8dcHJveHlfcGluZ19pbnRlcnZhbCxvbWl0ZW1wdHn63h8IRHVyYXRpb24SVQodQXNzaXN0Q29tbWFuZEV4ZWN1dGlvbldvcmtlcnMYCyABKAVCLureHyphc3Npc3RfY29tbWFuZF9leGVjdXRpb25fd29ya2VycyxvbWl0ZW1wdHkSRgoWQ2FzZUluc2Vuc2l0aXZlUm91dGluZxgMIAEoCEIm6t4fImNhc2VfaW5zZW5zaXRpdmVfcm91dGluZyxvbWl0ZW1wdHkSQgoOU1NIRGlhbFRpbWVvdXQYDSABKANCKureHxpzc2hfZGlhbF90aW1lb3V0LG9taXRlbXB0efreHwhEdXJhdGlvbiLFAQoQVHVubmVsU3RyYXRlZ3lWMRJNCglBZ2VudE1lc2gYASABKAsyHi50eXBlcy5BZ2VudE1lc2hUdW5uZWxTdHJhdGVneUIY6t4fFGFnZW50X21lc2gsb21pdGVtcHR5SAASVgoMUHJveHlQZWVyaW5nGAIgASgLMiEudHlwZXMuUHJveHlQZWVyaW5nVHVubmVsU3RyYXRlZ3lCG+reHxdwcm94eV9wZWVyaW5nLG9taXRlbXB0eUgAQgoKCFN0cmF0ZWd5IhkKF0FnZW50TWVzaFR1bm5lbFN0cmF0ZWd5ImAKGlByb3h5UGVlcmluZ1R1bm5lbFN0cmF0ZWd5EkIKFEFnZW50Q29ubmVjdGlvbkNvdW50GAEgASgDQiTq3h8gYWdlbnRfY29ubmVjdGlvbl9jb3VudCxvbWl0ZW1wdHki7wEKGFNlc3Npb25SZWNvcmRpbmdDb25maWdWMhIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESPwoEU3BlYxgFIAEoCzIjLnR5cGVzLlNlc3Npb25SZWNvcmRpbmdDb25maWdTcGVjVjJCDMjeHwDq3h8Ec3BlYyKTAQocU2Vzc2lvblJlY29yZGluZ0NvbmZpZ1NwZWNWMhIWCgRNb2RlGAEgASgJQgjq3h8EbW9kZRJbChNQcm94eUNoZWNrc0hvc3RLZXlzGAIgASgLMhAudHlwZXMuQm9vbFZhbHVlQizI3h8B2t4fCkJvb2xPcHRpb27q3h8WcHJveHlfY2hlY2tzX2hvc3Rfa2V5cyLpAQoQQXV0aFByZWZlcmVuY2VWMhIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESNwoEU3BlYxgFIAEoCzIbLnR5cGVzLkF1dGhQcmVmZXJlbmNlU3BlY1YyQgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAIoYLChRBdXRoUHJlZmVyZW5jZVNwZWNWMhIWCgRUeXBlGAEgASgJQgjq3h8EdHlwZRJ1CgxTZWNvbmRGYWN0b3IYAiABKAlCX+reHxdzZWNvbmRfZmFjdG9yLG9taXRlbXB0efreH0BnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL2NvbnN0YW50cy5TZWNvbmRGYWN0b3JUeXBlEjMKDUNvbm5lY3Rvck5hbWUYAyABKAlCHOreHxhjb25uZWN0b3JfbmFtZSxvbWl0ZW1wdHkSLgoDVTJGGAQgASgLMgoudHlwZXMuVTJGQhXI3h8B6t4fDXUyZixvbWl0ZW1wdHkSaAoVRGlzY29ubmVjdEV4cGlyZWRDZXJ0GAYgASgLMhAudHlwZXMuQm9vbFZhbHVlQjfI3h8B2t4fCkJvb2xPcHRpb27q3h8hZGlzY29ubmVjdF9leHBpcmVkX2NlcnQsb21pdGVtcHR5EloKDkFsbG93TG9jYWxBdXRoGAcgASgLMhAudHlwZXMuQm9vbFZhbHVlQjDI3h8B2t4fCkJvb2xPcHRpb27q3h8aYWxsb3dfbG9jYWxfYXV0aCxvbWl0ZW1wdHkSOQoPTWVzc2FnZU9mVGhlRGF5GAggASgJQiDq3h8cbWVzc2FnZV9vZl90aGVfZGF5LG9taXRlbXB0eRJuCgtMb2NraW5nTW9kZRgJIAEoCUJZ6t4fFmxvY2tpbmdfbW9kZSxvbWl0ZW1wdHn63h87Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS9jb25zdGFudHMuTG9ja2luZ01vZGUSOQoIV2ViYXV0aG4YCiABKAsyDy50eXBlcy5XZWJhdXRobkIW6t4fEndlYmF1dGhuLG9taXRlbXB0eRJfChFBbGxvd1Bhc3N3b3JkbGVzcxgLIAEoCzIQLnR5cGVzLkJvb2xWYWx1ZUIyyN4fAdreHwpCb29sT3B0aW9u6t4fHGFsbG93X3Bhc3N3b3JkbGVzcyxvbWl0ZW1wdHkSUAoOUmVxdWlyZU1GQVR5cGUYDCABKA4yFS50eXBlcy5SZXF1aXJlTUZBVHlwZUIh6t4fHXJlcXVpcmVfc2Vzc2lvbl9tZmEsb21pdGVtcHR5EkMKC0RldmljZVRydXN0GA0gASgLMhIudHlwZXMuRGV2aWNlVHJ1c3RCGureHxZkZXZpY2VfdHJ1c3Qsb21pdGVtcHR5EjEKA0lEUBgOIAEoCzIRLnR5cGVzLklkUE9wdGlvbnNCEereHw1pZHAsb21pdGVtcHR5ElcKDUFsbG93SGVhZGxlc3MYDyABKAsyEC50eXBlcy5Cb29sVmFsdWVCLsjeHwHa3h8KQm9vbE9wdGlvbureHxhhbGxvd19oZWFkbGVzcyxvbWl0ZW1wdHkSSAoRRGVmYXVsdFNlc3Npb25UVEwYECABKANCLereHx1kZWZhdWx0X3Nlc3Npb25fdHRsLG9taXRlbXB0efreHwhEdXJhdGlvbhI0CgRPa3RhGBEgASgLMhIudHlwZXMuT2t0YU9wdGlvbnNCEureHw5va3RhLG9taXRlbXB0eRIpCgdQSVZTbG90GBIgASgJQhgYAereHxJwaXZfc2xvdCxvbWl0ZW1wdHkSQwoLSGFyZHdhcmVLZXkYEyABKAsyEi50eXBlcy5IYXJkd2FyZUtleUIa6t4fFmhhcmR3YXJlX2tleSxvbWl0ZW1wdHkSQQoZc2lnbmF0dXJlX2FsZ29yaXRobV9zdWl0ZRgUIAEoDjIeLnR5cGVzLlNpZ25hdHVyZUFsZ29yaXRobVN1aXRlSgQIBRAGUhFSZXF1aXJlU2Vzc2lvbk1GQSKUAQoDVTJGEiMKBUFwcElEGAEgASgJQhTq3h8QYXBwX2lkLG9taXRlbXB0eRIkCgZGYWNldHMYAiADKAlCFOreHxBmYWNldHMsb21pdGVtcHR5EkIKFERldmljZUF0dGVzdGF0aW9uQ0FzGAMgAygJQiTq3h8gZGV2aWNlX2F0dGVzdGF0aW9uX2NhcyxvbWl0ZW1wdHkivQEKCFdlYmF1dGhuEiEKBFJQSUQYASABKAlCE+reHw9ycF9pZCxvbWl0ZW1wdHkSRAoVQXR0ZXN0YXRpb25BbGxvd2VkQ0FzGAIgAygJQiXq3h8hYXR0ZXN0YXRpb25fYWxsb3dlZF9jYXMsb21pdGVtcHR5EkIKFEF0dGVzdGF0aW9uRGVuaWVkQ0FzGAMgAygJQiTq3h8gYXR0ZXN0YXRpb25fZGVuaWVkX2NhcyxvbWl0ZW1wdHlKBAgEEAUimgEKC0RldmljZVRydXN0EiAKBE1vZGUYASABKAlCEureHw5tb2RlLG9taXRlbXB0eRItCgpBdXRvRW5yb2xsGAIgASgIQhnq3h8VYXV0b19lbnJvbGwsb21pdGVtcHR5EjoKEEVLQ2VydEFsbG93ZWRDQXMYAyADKAlCIOreHxxla2NlcnRfYWxsb3dlZF9jYXMsb21pdGVtcHR5IqgBCgtIYXJkd2FyZUtleRInCgdQSVZTbG90GAEgASgJQhbq3h8ScGl2X3Nsb3Qsb21pdGVtcHR5EnAKFlNlcmlhbE51bWJlclZhbGlkYXRpb24YAiABKAsyKC50eXBlcy5IYXJkd2FyZUtleVNlcmlhbE51bWJlclZhbGlkYXRpb25CJureHyJzZXJpYWxfbnVtYmVyX3ZhbGlkYXRpb24sb21pdGVtcHR5IpIBCiFIYXJkd2FyZUtleVNlcmlhbE51bWJlclZhbGlkYXRpb24SJgoHRW5hYmxlZBgBIAEoCEIV6t4fEWVuYWJsZWQsb21pdGVtcHR5EkUKFVNlcmlhbE51bWJlclRyYWl0TmFtZRgCIAEoCUIm6t4fInNlcmlhbF9udW1iZXJfdHJhaXRfbmFtZSxvbWl0ZW1wdHki0QEKCU5hbWVzcGFjZRIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESMAoEU3BlYxgFIAEoCzIULnR5cGVzLk5hbWVzcGFjZVNwZWNCDMjeHwDq3h8Ec3BlYyIPCg1OYW1lc3BhY2VTcGVjIt8BCgtVc2VyVG9rZW5WMxIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESMgoEU3BlYxgFIAEoCzIWLnR5cGVzLlVzZXJUb2tlblNwZWNWM0IMyN4fAOreHwRzcGVjOgiYoB8AgNwgACLGAQoPVXNlclRva2VuU3BlY1YzEhYKBFVzZXIYASABKAlCCOreHwR1c2VyEhQKA1VSTBgCIAEoCUIH6t4fA3VybBI5CgVVc2FnZRgDIAEoDjIVLnR5cGVzLlVzZXJUb2tlblVzYWdlQhPq3h8PdXNhZ2Usb21pdGVtcHR5EkoKB0NyZWF0ZWQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEWNyZWF0ZWQsb21pdGVtcHR5kN8fASLtAQoSVXNlclRva2VuU2VjcmV0c1YzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI5CgRTcGVjGAUgASgLMh0udHlwZXMuVXNlclRva2VuU2VjcmV0c1NwZWNWM0IMyN4fAOreHwRzcGVjOgiYoB8AgNwgACKoAQoWVXNlclRva2VuU2VjcmV0c1NwZWNWMxIbCgZPVFBLZXkYASABKAlCC+reHwdvcHRfa2V5EiUKBlFSQ29kZRgCIAEoCUIV6t4fEXFyX2NvZGUsb21pdGVtcHR5EkoKB0NyZWF0ZWQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEWNyZWF0ZWQsb21pdGVtcHR5kN8fASLnAQoPQWNjZXNzUmVxdWVzdFYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI2CgRTcGVjGAUgASgLMhoudHlwZXMuQWNjZXNzUmVxdWVzdFNwZWNWM0IMyN4fAOreHwRzcGVjOgiYoB8AgNwgACKpAQoVQWNjZXNzUmV2aWV3VGhyZXNob2xkEiAKBE5hbWUYASABKAlCEureHw5uYW1lLG9taXRlbXB0eRIkCgZGaWx0ZXIYAiABKAlCFOreHxBmaWx0ZXIsb21pdGVtcHR5EiYKB0FwcHJvdmUYAyABKA1CFereHxFhcHByb3ZlLG9taXRlbXB0eRIgCgREZW55GAQgASgNQhLq3h8OZGVueSxvbWl0ZW1wdHkiRgoSUHJvbW90ZWRBY2Nlc3NMaXN0EhYKBE5hbWUYASABKAlCCOreHwRuYW1lEhgKBVRpdGxlGAIgASgJQgnq3h8FdGl0bGUihwUKDEFjY2Vzc1JldmlldxIaCgZBdXRob3IYASABKAlCCureHwZhdXRob3ISIgoFUm9sZXMYAiADKAlCE+reHw9yb2xlcyxvbWl0ZW1wdHkSSAoNUHJvcG9zZWRTdGF0ZRgDIAEoDjITLnR5cGVzLlJlcXVlc3RTdGF0ZUIc6t4fGHByb3Bvc2VkX3N0YXRlLG9taXRlbXB0eRIkCgZSZWFzb24YBCABKAlCFOreHxByZWFzb24sb21pdGVtcHR5EkoKB0NyZWF0ZWQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEWNyZWF0ZWQsb21pdGVtcHR5kN8fARKIAQoLQW5ub3RhdGlvbnMYBiABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0JcyN4fANreHztnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL3R5cGVzL3dyYXBwZXJzLlRyYWl0c+reHxVhbm5vdGF0aW9ucyxvbWl0ZW1wdHkSKQoQVGhyZXNob2xkSW5kZXhlcxgHIAMoDUIP6t4fC2ksb21pdGVtcHR5EkgKCmFjY2Vzc0xpc3QYCSABKAsyGS50eXBlcy5Qcm9tb3RlZEFjY2Vzc0xpc3RCGereHxVhY2Nlc3NfbGlzdCxvbWl0ZW1wdHkSXAoPQXNzdW1lU3RhcnRUaW1lGAogASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEInyN4fAereHxthc3N1bWVfc3RhcnRfdGltZSxvbWl0ZW1wdHmQ3x8BSgQICBAJUhdQcm9tb3RlZEFjY2Vzc0xpc3RUaXRsZSJ8ChZBY2Nlc3NSZXZpZXdTdWJtaXNzaW9uEiMKCVJlcXVlc3RJRBgBIAEoCUIQ6t4fDGlkLG9taXRlbXB0eRI9CgZSZXZpZXcYAiABKAsyEy50eXBlcy5BY2Nlc3NSZXZpZXdCGMjeHwDq3h8QcmV2aWV3LG9taXRlbXB0eSI1ChFUaHJlc2hvbGRJbmRleFNldBIgCgdJbmRleGVzGAEgAygNQg/q3h8LaSxvbWl0ZW1wdHkiUQoSVGhyZXNob2xkSW5kZXhTZXRzEjsKBFNldHMYASADKAsyGC50eXBlcy5UaHJlc2hvbGRJbmRleFNldEITyN4fAOreHwtzLG9taXRlbXB0eSLbDAoTQWNjZXNzUmVxdWVzdFNwZWNWMxIWCgRVc2VyGAEgASgJQgjq3h8EdXNlchIYCgVSb2xlcxgCIAMoCUIJ6t4fBXJvbGVzEjcKBVN0YXRlGAMgASgOMhMudHlwZXMuUmVxdWVzdFN0YXRlQhPq3h8Pc3RhdGUsb21pdGVtcHR5EkoKB0NyZWF0ZWQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEWNyZWF0ZWQsb21pdGVtcHR5kN8fARJKCgdFeHBpcmVzGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIdyN4fAOreHxFleHBpcmVzLG9taXRlbXB0eZDfHwESMwoNUmVxdWVzdFJlYXNvbhgGIAEoCUIc6t4fGHJlcXVlc3RfcmVhc29uLG9taXRlbXB0eRIzCg1SZXNvbHZlUmVhc29uGAcgASgJQhzq3h8YcmVzb2x2ZV9yZWFzb24sb21pdGVtcHR5EpcBChJSZXNvbHZlQW5ub3RhdGlvbnMYCCABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0JkyN4fANreHztnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL3R5cGVzL3dyYXBwZXJzLlRyYWl0c+reHx1yZXNvbHZlX2Fubm90YXRpb25zLG9taXRlbXB0eRKVAQoRU3lzdGVtQW5ub3RhdGlvbnMYCSABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0JjyN4fANreHztnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL3R5cGVzL3dyYXBwZXJzLlRyYWl0c+reHxxzeXN0ZW1fYW5ub3RhdGlvbnMsb21pdGVtcHR5Ek4KClRocmVzaG9sZHMYCiADKAsyHC50eXBlcy5BY2Nlc3NSZXZpZXdUaHJlc2hvbGRCHMjeHwDq3h8UdGhyZXNob2xkcyxvbWl0ZW1wdHkSaQoUUm9sZVRocmVzaG9sZE1hcHBpbmcYCyADKAsyNC50eXBlcy5BY2Nlc3NSZXF1ZXN0U3BlY1YzLlJvbGVUaHJlc2hvbGRNYXBwaW5nRW50cnlCFcjeHwDq3h8NcnRtLG9taXRlbXB0eRI/CgdSZXZpZXdzGAwgAygLMhMudHlwZXMuQWNjZXNzUmV2aWV3QhnI3h8A6t4fEXJldmlld3Msb21pdGVtcHR5Ej0KElN1Z2dlc3RlZFJldmlld2VycxgNIAMoCUIh6t4fHXN1Z2dlc3RlZF9yZXZpZXdlcnMsb21pdGVtcHR5Ek8KFFJlcXVlc3RlZFJlc291cmNlSURzGA4gAygLMhEudHlwZXMuUmVzb3VyY2VJREIeyN4fAOreHxZyZXNvdXJjZV9pZHMsb21pdGVtcHR5EisKCUxvZ2luSGludBgPIAEoCUIY6t4fFGxvZ2luX2hpbnQsb21pdGVtcHR5EiUKBkRyeVJ1bhgQIAEoCEIV6t4fEWRyeV9ydW4sb21pdGVtcHR5ElMKC01heER1cmF0aW9uGBEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIiyN4fAOreHxZtYXhfZHVyYXRpb24sb21pdGVtcHR5kN8fARJRCgpTZXNzaW9uVFRMGBIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIhyN4fAOreHxVzZXNzaW9uX3R0bCxvbWl0ZW1wdHmQ3x8BEkgKCmFjY2Vzc0xpc3QYFCABKAsyGS50eXBlcy5Qcm9tb3RlZEFjY2Vzc0xpc3RCGereHxVhY2Nlc3NfbGlzdCxvbWl0ZW1wdHkSXAoPQXNzdW1lU3RhcnRUaW1lGBUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEInyN4fAereHxthc3N1bWVfc3RhcnRfdGltZSxvbWl0ZW1wdHmQ3x8BGlYKGVJvbGVUaHJlc2hvbGRNYXBwaW5nRW50cnkSCwoDa2V5GAEgASgJEigKBXZhbHVlGAIgASgLMhkudHlwZXMuVGhyZXNob2xkSW5kZXhTZXRzOgI4AUoECBMQFFIXUHJvbW90ZWRBY2Nlc3NMaXN0VGl0bGUipwIKE0FjY2Vzc1JlcXVlc3RGaWx0ZXISHAoCSUQYASABKAlCEOreHwxpZCxvbWl0ZW1wdHkSIAoEVXNlchgCIAEoCUIS6t4fDnVzZXIsb21pdGVtcHR5EjcKBVN0YXRlGAMgASgOMhMudHlwZXMuUmVxdWVzdFN0YXRlQhPq3h8Pc3RhdGUsb21pdGVtcHR5EiwKDlNlYXJjaEtleXdvcmRzGAQgAygJQhTq3h8Qc2VhcmNoLG9taXRlbXB0eRI9CgVTY29wZRgFIAEoDjIZLnR5cGVzLkFjY2Vzc1JlcXVlc3RTY29wZUIT6t4fD3Njb3BlLG9taXRlbXB0eRIqCglSZXF1ZXN0ZXIYBiABKAlCF+reHxNyZXF1ZXN0ZXIsb21pdGVtcHR5Iu4CChJBY2Nlc3NDYXBhYmlsaXRpZXMSOQoQUmVxdWVzdGFibGVSb2xlcxgBIAMoCUIf6t4fG3JlcXVlc3RhYmxlX3JvbGVzLG9taXRlbXB0eRI9ChJTdWdnZXN0ZWRSZXZpZXdlcnMYAiADKAlCIereHx1zdWdnZXN0ZWRfcmV2aWV3ZXJzLG9taXRlbXB0eRJDChtBcHBsaWNhYmxlUm9sZXNGb3JSZXNvdXJjZXMYAyADKAlCHureHxphcHBsaWNhYmxlX3JvbGVzLG9taXRlbXB0eRIzCg1SZXF1ZXN0UHJvbXB0GAQgASgJQhzq3h8YcmVxdWVzdF9wcm9tcHQsb21pdGVtcHR5EjMKDVJlcXVpcmVSZWFzb24YBSABKAhCHOreHxhyZXF1aXJlX3JlYXNvbixvbWl0ZW1wdHkSLwoLQXV0b1JlcXVlc3QYBiABKAhCGureHxZhdXRvX3JlcXVlc3Qsb21pdGVtcHR5IoEDChlBY2Nlc3NDYXBhYmlsaXRpZXNSZXF1ZXN0EiAKBFVzZXIYASABKAlCEureHw51c2VyLG9taXRlbXB0eRI5ChBSZXF1ZXN0YWJsZVJvbGVzGAIgASgIQh/q3h8bcmVxdWVzdGFibGVfcm9sZXMsb21pdGVtcHR5Ej0KElN1Z2dlc3RlZFJldmlld2VycxgDIAEoCEIh6t4fHXN1Z2dlc3RlZF9yZXZpZXdlcnMsb21pdGVtcHR5EkYKC1Jlc291cmNlSURzGAQgAygLMhEudHlwZXMuUmVzb3VyY2VJREIeyN4fAOreHxZyZXNvdXJjZV9pZHMsb21pdGVtcHR5EiIKBUxvZ2luGAUgASgJQhPq3h8PbG9naW4sb21pdGVtcHR5ElwKIEZpbHRlclJlcXVlc3RhYmxlUm9sZXNCeVJlc291cmNlGAYgASgIQjLq3h8uZmlsdGVyX3JlcXVlc3RhYmxlX3JvbGVzX2J5X3Jlc291cmNlLG9taXRlbXB0eSKTAQoKUmVzb3VyY2VJRBIgCgtDbHVzdGVyTmFtZRgBIAEoCUIL6t4fB2NsdXN0ZXISFgoES2luZBgCIAEoCUII6t4fBGtpbmQSFgoETmFtZRgDIAEoCUII6t4fBG5hbWUSMwoPU3ViUmVzb3VyY2VOYW1lGAQgASgJQhrq3h8Wc3ViX3Jlc291cmNlLG9taXRlbXB0eSLhAQoMUGx1Z2luRGF0YVYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRIzCgRTcGVjGAUgASgLMhcudHlwZXMuUGx1Z2luRGF0YVNwZWNWM0IMyN4fAOreHwRzcGVjOgiYoB8AgNwgACKCAQoPUGx1Z2luRGF0YUVudHJ5EkIKBERhdGEYASADKAsyIC50eXBlcy5QbHVnaW5EYXRhRW50cnkuRGF0YUVudHJ5QhLq3h8OZGF0YSxvbWl0ZW1wdHkaKwoJRGF0YUVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEingEKEFBsdWdpbkRhdGFTcGVjVjMSQgoHRW50cmllcxgBIAMoCzIkLnR5cGVzLlBsdWdpbkRhdGFTcGVjVjMuRW50cmllc0VudHJ5Qgvq3h8HZW50cmllcxpGCgxFbnRyaWVzRW50cnkSCwoDa2V5GAEgASgJEiUKBXZhbHVlGAIgASgLMhYudHlwZXMuUGx1Z2luRGF0YUVudHJ5OgI4ASKEAQoQUGx1Z2luRGF0YUZpbHRlchIgCgRLaW5kGAEgASgJQhLq3h8Oa2luZCxvbWl0ZW1wdHkSKAoIUmVzb3VyY2UYAiABKAlCFureHxJyZXNvdXJjZSxvbWl0ZW1wdHkSJAoGUGx1Z2luGAMgASgJQhTq3h8QcGx1Z2luLG9taXRlbXB0eSLgAgoWUGx1Z2luRGF0YVVwZGF0ZVBhcmFtcxIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBIeCghSZXNvdXJjZRgCIAEoCUIM6t4fCHJlc291cmNlEhoKBlBsdWdpbhgDIAEoCUIK6t4fBnBsdWdpbhJGCgNTZXQYBCADKAsyJi50eXBlcy5QbHVnaW5EYXRhVXBkYXRlUGFyYW1zLlNldEVudHJ5QhHq3h8Nc2V0LG9taXRlbXB0eRJPCgZFeHBlY3QYBSADKAsyKS50eXBlcy5QbHVnaW5EYXRhVXBkYXRlUGFyYW1zLkV4cGVjdEVudHJ5QhTq3h8QZXhwZWN0LG9taXRlbXB0eRoqCghTZXRFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGi0KC0V4cGVjdEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEifQoKUm9sZUZpbHRlchI1Cg5TZWFyY2hLZXl3b3JkcxgBIAMoCUId6t4fGXNlYXJjaF9rZXl3b3JkcyxvbWl0ZW1wdHkSOAoPU2tpcFN5c3RlbVJvbGVzGAIgASgIQh/q3h8bc2tpcF9zeXN0ZW1fcm9sZXMsb21pdGVtcHR5ItUBCgZSb2xlVjYSFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEi0KBFNwZWMYBSABKAsyES50eXBlcy5Sb2xlU3BlY1Y2QgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAIsgBCgpSb2xlU3BlY1Y2Ej4KB09wdGlvbnMYASABKAsyEi50eXBlcy5Sb2xlT3B0aW9uc0IZyN4fAOreHxFvcHRpb25zLG9taXRlbXB0eRI9CgVBbGxvdxgCIAEoCzIVLnR5cGVzLlJvbGVDb25kaXRpb25zQhfI3h8A6t4fD2FsbG93LG9taXRlbXB0eRI7CgREZW55GAMgASgLMhUudHlwZXMuUm9sZUNvbmRpdGlvbnNCFsjeHwDq3h8OZGVueSxvbWl0ZW1wdHki0hEKC1JvbGVPcHRpb25zEi8KDEZvcndhcmRBZ2VudBgBIAEoCEIZ6t4fDWZvcndhcmRfYWdlbnT63h8EQm9vbBJACg1NYXhTZXNzaW9uVFRMGAIgASgDQinq3h8ZbWF4X3Nlc3Npb25fdHRsLG9taXRlbXB0efreHwhEdXJhdGlvbhJZCg5Qb3J0Rm9yd2FyZGluZxgDIAEoCzIQLnR5cGVzLkJvb2xWYWx1ZUIvyN4fAdreHwpCb29sT3B0aW9u6t4fGXBvcnRfZm9yd2FyZGluZyxvbWl0ZW1wdHkSKgoRQ2VydGlmaWNhdGVGb3JtYXQYBCABKAlCD+reHwtjZXJ0X2Zvcm1hdBJIChFDbGllbnRJZGxlVGltZW91dBgFIAEoA0It6t4fHWNsaWVudF9pZGxlX3RpbWVvdXQsb21pdGVtcHR5+t4fCER1cmF0aW9uElAKFURpc2Nvbm5lY3RFeHBpcmVkQ2VydBgGIAEoCEIxyN4fAereHyFkaXNjb25uZWN0X2V4cGlyZWRfY2VydCxvbWl0ZW1wdHn63h8EQm9vbBItCgNCUEYYByADKAlCIOreHxxlbmhhbmNlZF9yZWNvcmRpbmcsb21pdGVtcHR5EkwKE1Blcm1pdFgxMUZvcndhcmRpbmcYCCABKAhCL8jeHwHq3h8fcGVybWl0X3gxMV9mb3J3YXJkaW5nLG9taXRlbXB0efreHwRCb29sEjUKDk1heENvbm5lY3Rpb25zGAkgASgDQh3q3h8ZbWF4X2Nvbm5lY3Rpb25zLG9taXRlbXB0eRIvCgtNYXhTZXNzaW9ucxgKIAEoA0Ia6t4fFm1heF9zZXNzaW9ucyxvbWl0ZW1wdHkSRgoNUmVxdWVzdEFjY2VzcxgLIAEoCUIv6t4fGHJlcXVlc3RfYWNjZXNzLG9taXRlbXB0efreHw9SZXF1ZXN0U3RyYXRlZ3kSMwoNUmVxdWVzdFByb21wdBgMIAEoCUIc6t4fGHJlcXVlc3RfcHJvbXB0LG9taXRlbXB0eRJfCgRMb2NrGA4gASgJQlHq3h8ObG9jayxvbWl0ZW1wdHn63h87Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS9jb25zdGFudHMuTG9ja2luZ01vZGUSPwoNUmVjb3JkU2Vzc2lvbhgPIAEoCzIULnR5cGVzLlJlY29yZFNlc3Npb25CEureHw5yZWNvcmRfc2Vzc2lvbhJTChBEZXNrdG9wQ2xpcGJvYXJkGBAgASgLMhAudHlwZXMuQm9vbFZhbHVlQifI3h8B2t4fCkJvb2xPcHRpb27q3h8RZGVza3RvcF9jbGlwYm9hcmQSSwoOQ2VydEV4dGVuc2lvbnMYESADKAsyFC50eXBlcy5DZXJ0RXh0ZW5zaW9uQh3q3h8ZY2VydF9leHRlbnNpb25zLG9taXRlbXB0eRJKChhNYXhLdWJlcm5ldGVzQ29ubmVjdGlvbnMYEiABKANCKOreHyRtYXhfa3ViZXJuZXRlc19jb25uZWN0aW9ucyxvbWl0ZW1wdHkSYgoXRGVza3RvcERpcmVjdG9yeVNoYXJpbmcYEyABKAsyEC50eXBlcy5Cb29sVmFsdWVCL8jeHwHa3h8KQm9vbE9wdGlvbureHxlkZXNrdG9wX2RpcmVjdG9yeV9zaGFyaW5nEloKDkNyZWF0ZUhvc3RVc2VyGBQgASgLMhAudHlwZXMuQm9vbFZhbHVlQjDI3h8B2t4fCkJvb2xPcHRpb27q3h8aY3JlYXRlX2hvc3RfdXNlcixvbWl0ZW1wdHkSLgoLUGluU291cmNlSVAYFSABKAhCGereHw1waW5fc291cmNlX2lw+t4fBEJvb2wSSgoLU1NIRmlsZUNvcHkYFiABKAsyEC50eXBlcy5Cb29sVmFsdWVCI8jeHwHa3h8KQm9vbE9wdGlvbureHw1zc2hfZmlsZV9jb3B5ElAKDlJlcXVpcmVNRkFUeXBlGBcgASgOMhUudHlwZXMuUmVxdWlyZU1GQVR5cGVCIereHx1yZXF1aXJlX3Nlc3Npb25fbWZhLG9taXRlbXB0eRI4Cg9EZXZpY2VUcnVzdE1vZGUYGCABKAlCH+reHxtkZXZpY2VfdHJ1c3RfbW9kZSxvbWl0ZW1wdHkSMQoDSURQGBkgASgLMhEudHlwZXMuSWRQT3B0aW9uc0IR6t4fDWlkcCxvbWl0ZW1wdHkSVgoRQ3JlYXRlRGVza3RvcFVzZXIYGiABKAsyEC50eXBlcy5Cb29sVmFsdWVCKcjeHwHa3h8KQm9vbE9wdGlvbureHxNjcmVhdGVfZGVza3RvcF91c2VyElIKEkNyZWF0ZURhdGFiYXNlVXNlchgbIAEoCzIQLnR5cGVzLkJvb2xWYWx1ZUIkyN4fAdreHwpCb29sT3B0aW9u6t4fDmNyZWF0ZV9kYl91c2VyEloKEkNyZWF0ZUhvc3RVc2VyTW9kZRgcIAEoDjIZLnR5cGVzLkNyZWF0ZUhvc3RVc2VyTW9kZUIj6t4fH2NyZWF0ZV9ob3N0X3VzZXJfbW9kZSxvbWl0ZW1wdHkSYAoWQ3JlYXRlRGF0YWJhc2VVc2VyTW9kZRgdIAEoDjIdLnR5cGVzLkNyZWF0ZURhdGFiYXNlVXNlck1vZGVCIereHx1jcmVhdGVfZGJfdXNlcl9tb2RlLG9taXRlbXB0eRJrChdNRkFWZXJpZmljYXRpb25JbnRlcnZhbBgeIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIvyN4fAOreHyNtZmFfdmVyaWZpY2F0aW9uX2ludGVydmFsLG9taXRlbXB0eZjfHwESUAoaQ3JlYXRlSG9zdFVzZXJEZWZhdWx0U2hlbGwYHyABKAlCLOreHyhjcmVhdGVfaG9zdF91c2VyX2RlZmF1bHRfc2hlbGwsb21pdGVtcHR5SgQIDRAOUhFSZXF1aXJlU2Vzc2lvbk1GQSKpAgoNUmVjb3JkU2Vzc2lvbhJACgdEZXNrdG9wGAEgASgLMhAudHlwZXMuQm9vbFZhbHVlQh3I3h8B2t4fCkJvb2xPcHRpb27q3h8HZGVza3RvcBJuCgdEZWZhdWx0GAIgASgJQl3q3h8RZGVmYXVsdCxvbWl0ZW1wdHn63h9EZ2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS9jb25zdGFudHMuU2Vzc2lvblJlY29yZGluZ01vZGUSZgoDU1NIGAMgASgJQlnq3h8Nc3NoLG9taXRlbXB0efreH0RnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL2NvbnN0YW50cy5TZXNzaW9uUmVjb3JkaW5nTW9kZSKlAQoNQ2VydEV4dGVuc2lvbhIwCgRUeXBlGAEgASgOMhgudHlwZXMuQ2VydEV4dGVuc2lvblR5cGVCCOreHwR0eXBlEjAKBE1vZGUYAiABKA4yGC50eXBlcy5DZXJ0RXh0ZW5zaW9uTW9kZUII6t4fBG1vZGUSFgoETmFtZRgDIAEoCUII6t4fBG5hbWUSGAoFVmFsdWUYBCABKAlCCereHwV2YWx1ZSKXFgoOUm9sZUNvbmRpdGlvbnMSJAoGTG9naW5zGAEgAygJQhTq3h8QbG9naW5zLG9taXRlbXB0eRIZCgpOYW1lc3BhY2VzGAIgAygJQgXq3h8BLRJSCgpOb2RlTGFiZWxzGAMgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCJ8jeHwDa3h8GTGFiZWxz6t4fFW5vZGVfbGFiZWxzLG9taXRlbXB0eRIzCgVSdWxlcxgEIAMoCzILLnR5cGVzLlJ1bGVCF8jeHwDq3h8PcnVsZXMsb21pdGVtcHR5EjMKCkt1YmVHcm91cHMYBSADKAlCH+reHxtrdWJlcm5ldGVzX2dyb3VwcyxvbWl0ZW1wdHkSRgoHUmVxdWVzdBgGIAEoCzIeLnR5cGVzLkFjY2Vzc1JlcXVlc3RDb25kaXRpb25zQhXq3h8RcmVxdWVzdCxvbWl0ZW1wdHkSMQoJS3ViZVVzZXJzGAcgAygJQh7q3h8aa3ViZXJuZXRlc191c2VycyxvbWl0ZW1wdHkSUAoJQXBwTGFiZWxzGAggASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCJsjeHwDa3h8GTGFiZWxz6t4fFGFwcF9sYWJlbHMsb21pdGVtcHR5ElgKDUNsdXN0ZXJMYWJlbHMYCSABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0IqyN4fANreHwZMYWJlbHPq3h8YY2x1c3Rlcl9sYWJlbHMsb21pdGVtcHR5El4KEEt1YmVybmV0ZXNMYWJlbHMYCiABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0ItyN4fANreHwZMYWJlbHPq3h8ba3ViZXJuZXRlc19sYWJlbHMsb21pdGVtcHR5ElQKDkRhdGFiYXNlTGFiZWxzGAsgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCJcjeHwDa3h8GTGFiZWxz6t4fE2RiX2xhYmVscyxvbWl0ZW1wdHkSLQoNRGF0YWJhc2VOYW1lcxgMIAMoCUIW6t4fEmRiX25hbWVzLG9taXRlbXB0eRItCg1EYXRhYmFzZVVzZXJzGA0gAygJQhbq3h8SZGJfdXNlcnMsb21pdGVtcHR5EkwKC0ltcGVyc29uYXRlGA4gASgLMhwudHlwZXMuSW1wZXJzb25hdGVDb25kaXRpb25zQhnq3h8VaW1wZXJzb25hdGUsb21pdGVtcHR5ElQKDlJldmlld1JlcXVlc3RzGA8gASgLMh0udHlwZXMuQWNjZXNzUmV2aWV3Q29uZGl0aW9uc0Id6t4fGXJldmlld19yZXF1ZXN0cyxvbWl0ZW1wdHkSMAoLQVdTUm9sZUFSTnMYECADKAlCG+reHxdhd3Nfcm9sZV9hcm5zLG9taXRlbXB0eRJCChRXaW5kb3dzRGVza3RvcExvZ2lucxgRIAMoCUIk6t4fIHdpbmRvd3NfZGVza3RvcF9sb2dpbnMsb21pdGVtcHR5EmcKFFdpbmRvd3NEZXNrdG9wTGFiZWxzGBIgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCMsjeHwDa3h8GTGFiZWxz6t4fIHdpbmRvd3NfZGVza3RvcF9sYWJlbHMsb21pdGVtcHR5ElsKElJlcXVpcmVTZXNzaW9uSm9pbhgTIAMoCzIbLnR5cGVzLlNlc3Npb25SZXF1aXJlUG9saWN5QiLq3h8ecmVxdWlyZV9zZXNzaW9uX2pvaW4sb21pdGVtcHR5EksKDEpvaW5TZXNzaW9ucxgUIAMoCzIYLnR5cGVzLlNlc3Npb25Kb2luUG9saWN5Qhvq3h8Xam9pbl9zZXNzaW9ucyxvbWl0ZW1wdHkSLQoKSG9zdEdyb3VwcxgVIAMoCUIZ6t4fFWhvc3RfZ3JvdXBzLG9taXRlbXB0eRIvCgtIb3N0U3Vkb2VycxgWIAMoCUIa6t4fFmhvc3Rfc3Vkb2VycyxvbWl0ZW1wdHkSNwoPQXp1cmVJZGVudGl0aWVzGBcgAygJQh7q3h8aYXp1cmVfaWRlbnRpdGllcyxvbWl0ZW1wdHkSXgoTS3ViZXJuZXRlc1Jlc291cmNlcxgYIAMoCzIZLnR5cGVzLkt1YmVybmV0ZXNSZXNvdXJjZUImyN4fAOreHx5rdWJlcm5ldGVzX3Jlc291cmNlcyxvbWl0ZW1wdHkSPgoSR0NQU2VydmljZUFjY291bnRzGBkgAygJQiLq3h8eZ2NwX3NlcnZpY2VfYWNjb3VudHMsb21pdGVtcHR5EmMKFURhdGFiYXNlU2VydmljZUxhYmVscxgaIAEoCzIVLndyYXBwZXJzLkxhYmVsVmFsdWVzQi3I3h8A2t4fBkxhYmVsc+reHxtkYl9zZXJ2aWNlX2xhYmVscyxvbWl0ZW1wdHkSVAoLR3JvdXBMYWJlbHMYGyABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0IoyN4fANreHwZMYWJlbHPq3h8WZ3JvdXBfbGFiZWxzLG9taXRlbXB0eRIzCg1EZXNrdG9wR3JvdXBzGBwgAygJQhzq3h8YZGVza3RvcF9ncm91cHMsb21pdGVtcHR5Ei0KDURhdGFiYXNlUm9sZXMYHSADKAlCFureHxJkYl9yb2xlcyxvbWl0ZW1wdHkSQgoUTm9kZUxhYmVsc0V4cHJlc3Npb24YHiABKAlCJOreHyBub2RlX2xhYmVsc19leHByZXNzaW9uLG9taXRlbXB0eRJAChNBcHBMYWJlbHNFeHByZXNzaW9uGB8gASgJQiPq3h8fYXBwX2xhYmVsc19leHByZXNzaW9uLG9taXRlbXB0eRJIChdDbHVzdGVyTGFiZWxzRXhwcmVzc2lvbhggIAEoCUIn6t4fI2NsdXN0ZXJfbGFiZWxzX2V4cHJlc3Npb24sb21pdGVtcHR5Ek4KGkt1YmVybmV0ZXNMYWJlbHNFeHByZXNzaW9uGCEgASgJQirq3h8ma3ViZXJuZXRlc19sYWJlbHNfZXhwcmVzc2lvbixvbWl0ZW1wdHkSRAoYRGF0YWJhc2VMYWJlbHNFeHByZXNzaW9uGCIgASgJQiLq3h8eZGJfbGFiZWxzX2V4cHJlc3Npb24sb21pdGVtcHR5ElMKH0RhdGFiYXNlU2VydmljZUxhYmVsc0V4cHJlc3Npb24YIyABKAlCKureHyZkYl9zZXJ2aWNlX2xhYmVsc19leHByZXNzaW9uLG9taXRlbXB0eRJXCh5XaW5kb3dzRGVza3RvcExhYmVsc0V4cHJlc3Npb24YJCABKAlCL+reHyt3aW5kb3dzX2Rlc2t0b3BfbGFiZWxzX2V4cHJlc3Npb24sb21pdGVtcHR5EkQKFUdyb3VwTGFiZWxzRXhwcmVzc2lvbhglIAEoCUIl6t4fIWdyb3VwX2xhYmVsc19leHByZXNzaW9uLG9taXRlbXB0eRJYChNEYXRhYmFzZVBlcm1pc3Npb25zGCYgAygLMhkudHlwZXMuRGF0YWJhc2VQZXJtaXNzaW9uQiDI3h8A6t4fGGRiX3Blcm1pc3Npb25zLG9taXRlbXB0eRJACgZTUElGRkUYJyADKAsyGi50eXBlcy5TUElGRkVSb2xlQ29uZGl0aW9uQhTq3h8Qc3BpZmZlLG9taXRlbXB0eUoECCgQKUoECCkQKlIcU0FNTElkUFNlcnZpY2VQcm92aWRlckxhYmVsc1ImU0FNTElkUFNlcnZpY2VQcm92aWRlckxhYmVsc0V4cHJlc3Npb24ihwEKE1NQSUZGRVJvbGVDb25kaXRpb24SIAoEUGF0aBgBIAEoCUIS6t4fDnBhdGgsb21pdGVtcHR5EicKB0ROU1NBTnMYAiADKAlCFureHxJkbnNfc2FucyxvbWl0ZW1wdHkSJQoGSVBTQU5zGAMgAygJQhXq3h8RaXBfc2FucyxvbWl0ZW1wdHkieQoSRGF0YWJhc2VQZXJtaXNzaW9uEiQKC1Blcm1pc3Npb25zGAEgAygJQg/q3h8LcGVybWlzc2lvbnMSPQoFTWF0Y2gYAiABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0IXyN4fANreHwZMYWJlbHPq3h8FbWF0Y2giqAEKEkt1YmVybmV0ZXNSZXNvdXJjZRIgCgRLaW5kGAEgASgJQhLq3h8Oa2luZCxvbWl0ZW1wdHkSKgoJTmFtZXNwYWNlGAIgASgJQhfq3h8TbmFtZXNwYWNlLG9taXRlbXB0eRIgCgROYW1lGAMgASgJQhLq3h8ObmFtZSxvbWl0ZW1wdHkSIgoFVmVyYnMYBCADKAlCE+reHw92ZXJicyxvbWl0ZW1wdHkitwEKFFNlc3Npb25SZXF1aXJlUG9saWN5EhYKBE5hbWUYASABKAlCCOreHwRuYW1lEhoKBkZpbHRlchgCIAEoCUIK6t4fBmZpbHRlchIYCgVLaW5kcxgDIAMoCUIJ6t4fBWtpbmRzEhgKBUNvdW50GAQgASgFQgnq3h8FY291bnQSGAoFTW9kZXMYBSADKAlCCereHwVtb2RlcxIdCgdPbkxlYXZlGAYgASgJQgzq3h8Ib25fbGVhdmUieQoRU2Vzc2lvbkpvaW5Qb2xpY3kSFgoETmFtZRgBIAEoCUII6t4fBG5hbWUSGAoFUm9sZXMYAiADKAlCCereHwVyb2xlcxIYCgVLaW5kcxgDIAMoCUIJ6t4fBWtpbmRzEhgKBU1vZGVzGAQgAygJQgnq3h8FbW9kZXMimQQKF0FjY2Vzc1JlcXVlc3RDb25kaXRpb25zEiIKBVJvbGVzGAEgAygJQhPq3h8Pcm9sZXMsb21pdGVtcHR5Ek0KDUNsYWltc1RvUm9sZXMYAiADKAsyEy50eXBlcy5DbGFpbU1hcHBpbmdCIcjeHwDq3h8ZY2xhaW1zX3RvX3JvbGVzLG9taXRlbXB0eRKIAQoLQW5ub3RhdGlvbnMYAyABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0JcyN4fANreHztnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL3R5cGVzL3dyYXBwZXJzLlRyYWl0c+reHxVhbm5vdGF0aW9ucyxvbWl0ZW1wdHkSTgoKVGhyZXNob2xkcxgEIAMoCzIcLnR5cGVzLkFjY2Vzc1Jldmlld1RocmVzaG9sZEIcyN4fAOreHxR0aHJlc2hvbGRzLG9taXRlbXB0eRI9ChJTdWdnZXN0ZWRSZXZpZXdlcnMYBSADKAlCIereHx1zdWdnZXN0ZWRfcmV2aWV3ZXJzLG9taXRlbXB0eRI0Cg1TZWFyY2hBc1JvbGVzGAYgAygJQh3q3h8Zc2VhcmNoX2FzX3JvbGVzLG9taXRlbXB0eRI7CgtNYXhEdXJhdGlvbhgHIAEoA0Im6t4fFm1heF9kdXJhdGlvbixvbWl0ZW1wdHn63h8IRHVyYXRpb24i5wEKFkFjY2Vzc1Jldmlld0NvbmRpdGlvbnMSIgoFUm9sZXMYASADKAlCE+reHw9yb2xlcyxvbWl0ZW1wdHkSTQoNQ2xhaW1zVG9Sb2xlcxgCIAMoCzITLnR5cGVzLkNsYWltTWFwcGluZ0IhyN4fAOreHxljbGFpbXNfdG9fcm9sZXMsb21pdGVtcHR5EiIKBVdoZXJlGAMgASgJQhPq3h8Pd2hlcmUsb21pdGVtcHR5EjYKDlByZXZpZXdBc1JvbGVzGAQgAygJQh7q3h8acHJldmlld19hc19yb2xlcyxvbWl0ZW1wdHkiNwodQWNjZXNzUmVxdWVzdEFsbG93ZWRQcm9tb3Rpb24SFgoOYWNjZXNzTGlzdE5hbWUYASABKAkiWgoeQWNjZXNzUmVxdWVzdEFsbG93ZWRQcm9tb3Rpb25zEjgKCnByb21vdGlvbnMYASADKAsyJC50eXBlcy5BY2Nlc3NSZXF1ZXN0QWxsb3dlZFByb21vdGlvbiJmCgxDbGFpbU1hcHBpbmcSGAoFQ2xhaW0YASABKAlCCereHwVjbGFpbRIYCgVWYWx1ZRgCIAEoCUIJ6t4fBXZhbHVlEiIKBVJvbGVzGAMgAygJQhPq3h8Pcm9sZXMsb21pdGVtcHR5ImYKDFRyYWl0TWFwcGluZxIYCgVUcmFpdBgBIAEoCUIJ6t4fBXRyYWl0EhgKBVZhbHVlGAIgASgJQgnq3h8FdmFsdWUSIgoFUm9sZXMYAyADKAlCE+reHw9yb2xlcyxvbWl0ZW1wdHkiogEKBFJ1bGUSKgoJUmVzb3VyY2VzGAEgAygJQhfq3h8TcmVzb3VyY2VzLG9taXRlbXB0eRIiCgVWZXJicxgCIAMoCUIT6t4fD3ZlcmJzLG9taXRlbXB0eRIiCgVXaGVyZRgDIAEoCUIT6t4fD3doZXJlLG9taXRlbXB0eRImCgdBY3Rpb25zGAQgAygJQhXq3h8RYWN0aW9ucyxvbWl0ZW1wdHkigwEKFUltcGVyc29uYXRlQ29uZGl0aW9ucxIiCgVVc2VycxgBIAMoCUIT6t4fD3VzZXJzLG9taXRlbXB0eRIiCgVSb2xlcxgCIAMoCUIT6t4fD3JvbGVzLG9taXRlbXB0eRIiCgVXaGVyZRgDIAEoCUIT6t4fD3doZXJlLG9taXRlbXB0eSIaCglCb29sVmFsdWUSDQoFVmFsdWUYASABKAgiQwoKVXNlckZpbHRlchI1Cg5TZWFyY2hLZXl3b3JkcxgBIAMoCUId6t4fGXNlYXJjaF9rZXl3b3JkcyxvbWl0ZW1wdHkilAIKBlVzZXJWMhIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESLQoEU3BlYxgFIAEoCzIRLnR5cGVzLlVzZXJTcGVjVjJCDMjeHwDq3h8Ec3BlYxI9CgZTdGF0dXMYBiABKAsyEy50eXBlcy5Vc2VyU3RhdHVzVjJCGMjeHwDq3h8Qc3RhdHVzLG9taXRlbXB0eToImKAfAIDcIAAiWgoMVXNlclN0YXR1c1YyEkoKDnBhc3N3b3JkX3N0YXRlGAEgASgOMhQudHlwZXMuUGFzc3dvcmRTdGF0ZUIc6t4fGHBhc3N3b3JkX3N0YXRlLG9taXRlbXB0eSL1BQoKVXNlclNwZWNWMhJSCg5PSURDSWRlbnRpdGllcxgBIAMoCzIXLnR5cGVzLkV4dGVybmFsSWRlbnRpdHlCIcjeHwDq3h8Zb2lkY19pZGVudGl0aWVzLG9taXRlbXB0eRJSCg5TQU1MSWRlbnRpdGllcxgCIAMoCzIXLnR5cGVzLkV4dGVybmFsSWRlbnRpdHlCIcjeHwDq3h8Zc2FtbF9pZGVudGl0aWVzLG9taXRlbXB0eRJWChBHaXRodWJJZGVudGl0aWVzGAMgAygLMhcudHlwZXMuRXh0ZXJuYWxJZGVudGl0eUIjyN4fAOreHxtnaXRodWJfaWRlbnRpdGllcyxvbWl0ZW1wdHkSIgoFUm9sZXMYBCADKAlCE+reHw9yb2xlcyxvbWl0ZW1wdHkSfgoGVHJhaXRzGAUgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCV8jeHwDa3h87Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS90eXBlcy93cmFwcGVycy5UcmFpdHPq3h8QdHJhaXRzLG9taXRlbXB0eRI8CgZTdGF0dXMYBiABKAsyEi50eXBlcy5Mb2dpblN0YXR1c0IYyN4fAOreHxBzdGF0dXMsb21pdGVtcHR5EkAKB0V4cGlyZXMYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhPI3h8A6t4fB2V4cGlyZXOQ3x8BEkEKCUNyZWF0ZWRCeRgIIAEoCzIQLnR5cGVzLkNyZWF0ZWRCeUIcyN4fAOreHxRjcmVhdGVkX2J5LG9taXRlbXB0eRJECglMb2NhbEF1dGgYCSABKAsyFy50eXBlcy5Mb2NhbEF1dGhTZWNyZXRzQhjq3h8UbG9jYWxfYXV0aCxvbWl0ZW1wdHkSOgoQVHJ1c3RlZERldmljZUlEcxgKIAMoCUIg6t4fHHRydXN0ZWRfZGV2aWNlX2lkcyxvbWl0ZW1wdHkitwEKEEV4dGVybmFsSWRlbnRpdHkSLwoLQ29ubmVjdG9ySUQYASABKAlCGureHxZjb25uZWN0b3JfaWQsb21pdGVtcHR5EigKCFVzZXJuYW1lGAIgASgJQhbq3h8SdXNlcm5hbWUsb21pdGVtcHR5Ej4KE1NBTUxTaW5nbGVMb2dvdXRVUkwYAyABKAlCIereHx1zYW1sU2luZ2xlTG9nb3V0VXJsLG9taXRlbXB0eToImKAfAIDcIAAirQIKC0xvZ2luU3RhdHVzEh8KCElzTG9ja2VkGAEgASgIQg3q3h8JaXNfbG9ja2VkEjMKDUxvY2tlZE1lc3NhZ2UYAiABKAlCHOreHxhsb2NrZWRfbWVzc2FnZSxvbWl0ZW1wdHkSUQoKTG9ja2VkVGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCIcjeHwDq3h8VbG9ja2VkX3RpbWUsb21pdGVtcHR5kN8fARJTCgtMb2NrRXhwaXJlcxgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCIsjeHwDq3h8WbG9ja19leHBpcmVzLG9taXRlbXB0eZDfHwFKBAgFEAZSGlJlY292ZXJ5QXR0ZW1wdExvY2tFeHBpcmVzIsIBCglDcmVhdGVkQnkSQwoJQ29ubmVjdG9yGAEgASgLMhMudHlwZXMuQ29ubmVjdG9yUmVmQhvI3h8B6t4fE2Nvbm5lY3RvcixvbWl0ZW1wdHkSOgoEVGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCEMjeHwDq3h8EdGltZZDfHwESKgoEVXNlchgDIAEoCzIOLnR5cGVzLlVzZXJSZWZCDMjeHwDq3h8EdXNlcjoImKAfAIDcIAAi8AEKEExvY2FsQXV0aFNlY3JldHMSMQoMUGFzc3dvcmRIYXNoGAEgASgMQhvq3h8XcGFzc3dvcmRfaGFzaCxvbWl0ZW1wdHkSJwoHVE9UUEtleRgCIAEoCUIW6t4fEnRvdHBfa2V5LG9taXRlbXB0eRIwCgNNRkEYBSADKAsyEC50eXBlcy5NRkFEZXZpY2VCEereHw1tZmEsb21pdGVtcHR5EkIKCFdlYmF1dGhuGAYgASgLMhgudHlwZXMuV2ViYXV0aG5Mb2NhbEF1dGhCFureHxJ3ZWJhdXRobixvbWl0ZW1wdHlKBAgDEARKBAgEEAUi2wIKCU1GQURldmljZRIMCgRraW5kGAEgASgJEhAKCHN1Yl9raW5kGAIgASgJEg8KB3ZlcnNpb24YAyABKAkSJwoIbWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIEyN4fABIKCgJpZBgFIAEoCRI2CghhZGRlZF9hdBgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCCMjeHwCQ3x8BEjcKCWxhc3RfdXNlZBgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCCMjeHwCQ3x8BEiEKBHRvdHAYCCABKAsyES50eXBlcy5UT1RQRGV2aWNlSAASHwoDdTJmGAkgASgLMhAudHlwZXMuVTJGRGV2aWNlSAASKQoId2ViYXV0aG4YCiABKAsyFS50eXBlcy5XZWJhdXRobkRldmljZUgAQggKBmRldmljZSIZCgpUT1RQRGV2aWNlEgsKA2tleRgBIAEoCSJBCglVMkZEZXZpY2USEgoKa2V5X2hhbmRsZRgBIAEoDBIPCgdwdWJfa2V5GAIgASgMEg8KB2NvdW50ZXIYAyABKA0iywIKDldlYmF1dGhuRGV2aWNlEhUKDWNyZWRlbnRpYWxfaWQYASABKAwSFwoPcHVibGljX2tleV9jYm9yGAIgASgMEhgKEGF0dGVzdGF0aW9uX3R5cGUYAyABKAkSDgoGYWFndWlkGAQgASgMEhkKEXNpZ25hdHVyZV9jb3VudGVyGAUgASgNEhoKEmF0dGVzdGF0aW9uX29iamVjdBgGIAEoDBIUCgxyZXNpZGVudF9rZXkYByABKAgSGAoQY3JlZGVudGlhbF9ycF9pZBgIIAEoCRI+ChpjcmVkZW50aWFsX2JhY2t1cF9lbGlnaWJsZRgJIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSOAoUY3JlZGVudGlhbF9iYWNrZWRfdXAYCiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlIjoKEVdlYmF1dGhuTG9jYWxBdXRoEiUKBlVzZXJJRBgBIAEoDEIV6t4fEXVzZXJfaWQsb21pdGVtcHR5IloKDENvbm5lY3RvclJlZhIWCgRUeXBlGAEgASgJQgjq3h8EdHlwZRISCgJJRBgCIAEoCUIG6t4fAmlkEh4KCElkZW50aXR5GAMgASgJQgzq3h8IaWRlbnRpdHkiIQoHVXNlclJlZhIWCgROYW1lGAEgASgJQgjq3h8EbmFtZSLdAQoPUmV2ZXJzZVR1bm5lbFYyEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI2CgRTcGVjGAUgASgLMhoudHlwZXMuUmV2ZXJzZVR1bm5lbFNwZWNWMkIMyN4fAOreHwRzcGVjIo8BChNSZXZlcnNlVHVubmVsU3BlY1YyEiUKC0NsdXN0ZXJOYW1lGAEgASgJQhDq3h8MY2x1c3Rlcl9uYW1lEisKCURpYWxBZGRycxgCIAMoCUIY6t4fFGRpYWxfYWRkcnMsb21pdGVtcHR5EiQKBFR5cGUYAyABKAlCFureHwR0eXBl+t4fClR1bm5lbFR5cGUi7QEKElR1bm5lbENvbm5lY3Rpb25WMhIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESOQoEU3BlYxgFIAEoCzIdLnR5cGVzLlR1bm5lbENvbm5lY3Rpb25TcGVjVjJCDMjeHwDq3h8Ec3BlYzoImKAfAIDcIAAi4QEKFlR1bm5lbENvbm5lY3Rpb25TcGVjVjISJQoLQ2x1c3Rlck5hbWUYASABKAlCEOreHwxjbHVzdGVyX25hbWUSIQoJUHJveHlOYW1lGAIgASgJQg7q3h8KcHJveHlfbmFtZRJXCg1MYXN0SGVhcnRiZWF0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIkyN4fAOreHxhsYXN0X2hlYXJ0YmVhdCxvbWl0ZW1wdHmQ3x8BEiQKBFR5cGUYBCABKAlCFureHwR0eXBl+t4fClR1bm5lbFR5cGUiUwoPU2VtYXBob3JlRmlsdGVyEh8KDVNlbWFwaG9yZUtpbmQYASABKAlCCOreHwRraW5kEh8KDVNlbWFwaG9yZU5hbWUYAiABKAlCCOreHwRuYW1lIt8BChdBY3F1aXJlU2VtYXBob3JlUmVxdWVzdBIfCg1TZW1hcGhvcmVLaW5kGAEgASgJQgjq3h8Ea2luZBIfCg1TZW1hcGhvcmVOYW1lGAIgASgJQgjq3h8EbmFtZRIkCglNYXhMZWFzZXMYAyABKANCEereHw1tYXhfcmVzb3VyY2VzEkAKB0V4cGlyZXMYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhPI3h8A6t4fB2V4cGlyZXOQ3x8BEhoKBkhvbGRlchgFIAEoCUIK6t4fBmhvbGRlciKzAQoOU2VtYXBob3JlTGVhc2USHwoNU2VtYXBob3JlS2luZBgBIAEoCUII6t4fBGtpbmQSHwoNU2VtYXBob3JlTmFtZRgCIAEoCUII6t4fBG5hbWUSHQoHTGVhc2VJRBgDIAEoCUIM6t4fCGxlYXNlX2lkEkAKB0V4cGlyZXMYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhPI3h8A6t4fB2V4cGlyZXOQ3x8BIpABChFTZW1hcGhvcmVMZWFzZVJlZhIdCgdMZWFzZUlEGAEgASgJQgzq3h8IbGVhc2VfaWQSQAoHRXhwaXJlcxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCE8jeHwDq3h8HZXhwaXJlc5DfHwESGgoGSG9sZGVyGAMgASgJQgrq3h8GaG9sZGVyIt8BCgtTZW1hcGhvcmVWMxIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESMgoEU3BlYxgFIAEoCzIWLnR5cGVzLlNlbWFwaG9yZVNwZWNWM0IMyN4fAOreHwRzcGVjOgiYoB8AgNwgACJLCg9TZW1hcGhvcmVTcGVjVjMSOAoGTGVhc2VzGAEgAygLMhgudHlwZXMuU2VtYXBob3JlTGVhc2VSZWZCDsjeHwDq3h8GbGVhc2VzIuEBCgxXZWJTZXNzaW9uVjISFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjMKBFNwZWMYBSABKAsyFy50eXBlcy5XZWJTZXNzaW9uU3BlY1YyQgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAIoMHChBXZWJTZXNzaW9uU3BlY1YyEhYKBFVzZXIYASABKAlCCOreHwR1c2VyEhQKA1B1YhgCIAEoDEIH6t4fA3B1YhIgCgRQcml2GAMgASgMQhLq3h8OcHJpdixvbWl0ZW1wdHkSJwoHVExTQ2VydBgEIAEoDEIW6t4fEnRsc19jZXJ0LG9taXRlbXB0eRIlCgtCZWFyZXJUb2tlbhgFIAEoCUIQ6t4fDGJlYXJlcl90b2tlbhJYChJCZWFyZXJUb2tlbkV4cGlyZXMYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQiDI3h8A6t4fFGJlYXJlcl90b2tlbl9leHBpcmVzkN8fARJACgdFeHBpcmVzGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEITyN4fAOreHwdleHBpcmVzkN8fARJFCglMb2dpblRpbWUYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhbI3h8A6t4fCmxvZ2luX3RpbWWQ3x8BEjEKC0lkbGVUaW1lb3V0GAkgASgDQhzq3h8MaWRsZV90aW1lb3V0+t4fCER1cmF0aW9uEkkKF0NvbnN1bWVkQWNjZXNzUmVxdWVzdElEGAogASgJQijq3h8kY29uc3VtZWRfYWNjZXNzX3JlcXVlc3RfaWQsb21pdGVtcHR5EkcKC1NBTUxTZXNzaW9uGAsgASgLMhYudHlwZXMuU0FNTFNlc3Npb25EYXRhQhrq3h8Wc2FtbF9zZXNzaW9uLG9taXRlbXB0eRJNCg5EZXZpY2VXZWJUb2tlbhgMIAEoCzIVLnR5cGVzLkRldmljZVdlYlRva2VuQh7q3h8aZGV2aWNlX3dlYl90b2tlbixvbWl0ZW1wdHkSQAoTSGFzRGV2aWNlRXh0ZW5zaW9ucxgNIAEoCEIj6t4fH2hhc19kZXZpY2VfZXh0ZW5zaW9ucyxvbWl0ZW1wdHkSawoYVHJ1c3RlZERldmljZVJlcXVpcmVtZW50GA4gASgOMh8udHlwZXMuVHJ1c3RlZERldmljZVJlcXVpcmVtZW50Qijq3h8kdHJ1c3RlZF9kZXZpY2VfcmVxdWlyZW1lbnQsb21pdGVtcHR5EicKB1RMU1ByaXYYDyABKAxCFureHxJ0bHNfcHJpdixvbWl0ZW1wdHkiKwoORGV2aWNlV2ViVG9rZW4SCgoCaWQYASABKAkSDQoFdG9rZW4YAiABKAkiKgoQV2ViU2Vzc2lvbkZpbHRlchIWCgRVc2VyGAEgASgJQgjq3h8EdXNlciKfBQoPU0FNTFNlc3Npb25EYXRhEhIKAklEGAEgASgJQgbq3h8CaWQSRwoKQ3JlYXRlVGltZRgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCF8jeHwDq3h8LY3JlYXRlX3RpbWWQ3x8BEkcKCkV4cGlyZVRpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhfI3h8A6t4fC2V4cGlyZV90aW1lkN8fARIYCgVJbmRleBgEIAEoCUIJ6t4fBWluZGV4EhsKBk5hbWVJRBgFIAEoCUIL6t4fB25hbWVfaWQSKAoMTmFtZUlERm9ybWF0GAYgASgJQhLq3h8ObmFtZV9pZF9mb3JtYXQSIQoJU3ViamVjdElEGAcgASgJQg7q3h8Kc3ViamVjdF9pZBIaCgZHcm91cHMYCCADKAlCCureHwZncm91cHMSHwoIVXNlck5hbWUYCSABKAlCDereHwl1c2VyX25hbWUSIQoJVXNlckVtYWlsGAogASgJQg7q3h8KdXNlcl9lbWFpbBIsCg5Vc2VyQ29tbW9uTmFtZRgLIAEoCUIU6t4fEHVzZXJfY29tbW9uX25hbWUSJQoLVXNlclN1cm5hbWUYDCABKAlCEOreHwx1c2VyX3N1cm5hbWUSKgoNVXNlckdpdmVuTmFtZRgNIAEoCUIT6t4fD3VzZXJfZ2l2ZW5fbmFtZRI6ChVVc2VyU2NvcGVkQWZmaWxpYXRpb24YDiABKAlCG+reHxd1c2VyX3Njb3BlZF9hZmZpbGlhdGlvbhJFChBDdXN0b21BdHRyaWJ1dGVzGA8gAygLMhQudHlwZXMuU0FNTEF0dHJpYnV0ZUIV6t4fEWN1c3RvbV9hdHRyaWJ1dGVzIqwBCg1TQU1MQXR0cmlidXRlEicKDEZyaWVuZGx5TmFtZRgBIAEoCUIR6t4fDWZyaWVuZGx5X25hbWUSFgoETmFtZRgCIAEoCUII6t4fBG5hbWUSIwoKTmFtZUZvcm1hdBgDIAEoCUIP6t4fC25hbWVfZm9ybWF0EjUKBlZhbHVlcxgEIAMoCzIZLnR5cGVzLlNBTUxBdHRyaWJ1dGVWYWx1ZUIK6t4fBnZhbHVlcyKAAQoSU0FNTEF0dHJpYnV0ZVZhbHVlEhYKBFR5cGUYASABKAlCCOreHwR0eXBlEhgKBVZhbHVlGAIgASgJQgnq3h8FdmFsdWUSOAoGTmFtZUlEGAMgASgLMhEudHlwZXMuU0FNTE5hbWVJREIV6t4fEW5hbWVfaWQsb21pdGVtcHR5IscBCgpTQU1MTmFtZUlEEikKDU5hbWVRdWFsaWZpZXIYASABKAlCEureHw5uYW1lX3F1YWxpZmllchIuCg9TUE5hbWVRdWFsaWZpZXIYAiABKAlCFereHxFzcF9uYW1lX3F1YWxpZmllchIaCgZGb3JtYXQYAyABKAlCCureHwZmb3JtYXQSKAoMU1BQcm92aWRlZElEGAQgASgJQhLq3h8Oc3BfcHJvdmlkZXJfaWQSGAoFVmFsdWUYBSABKAlCCereHwV2YWx1ZSLtAQoPUmVtb3RlQ2x1c3RlclYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI8CgZTdGF0dXMYBSABKAsyHC50eXBlcy5SZW1vdGVDbHVzdGVyU3RhdHVzVjNCDsjeHwDq3h8Gc3RhdHVzOgiYoB8AgNwgACKKAQoVUmVtb3RlQ2x1c3RlclN0YXR1c1YzEiIKCkNvbm5lY3Rpb24YASABKAlCDureHwpjb25uZWN0aW9uEk0KDUxhc3RIZWFydGJlYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhrI3h8A6t4fDmxhc3RfaGVhcnRiZWF0kN8fASLyAgoRS3ViZXJuZXRlc0NsdXN0ZXISFgoETmFtZRgBIAEoCUII6t4fBG5hbWUSXQoMU3RhdGljTGFiZWxzGAIgAygLMioudHlwZXMuS3ViZXJuZXRlc0NsdXN0ZXIuU3RhdGljTGFiZWxzRW50cnlCG+reHxdzdGF0aWNfbGFiZWxzLG9taXRlbXB0eRJkCg1EeW5hbWljTGFiZWxzGAMgAygLMisudHlwZXMuS3ViZXJuZXRlc0NsdXN0ZXIuRHluYW1pY0xhYmVsc0VudHJ5QiDI3h8A6t4fGGR5bmFtaWNfbGFiZWxzLG9taXRlbXB0eRozChFTdGF0aWNMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGksKEkR5bmFtaWNMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSJAoFdmFsdWUYAiABKAsyFS50eXBlcy5Db21tYW5kTGFiZWxWMjoCOAEi7wEKE0t1YmVybmV0ZXNDbHVzdGVyVjMSFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjoKBFNwZWMYBSABKAsyHi50eXBlcy5LdWJlcm5ldGVzQ2x1c3RlclNwZWNWM0IMyN4fAOreHwRzcGVjOgiYoB8AgNwgACKiAwoXS3ViZXJuZXRlc0NsdXN0ZXJTcGVjVjMSagoNRHluYW1pY0xhYmVscxgBIAMoCzIxLnR5cGVzLkt1YmVybmV0ZXNDbHVzdGVyU3BlY1YzLkR5bmFtaWNMYWJlbHNFbnRyeUIgyN4fAOreHxhkeW5hbWljX2xhYmVscyxvbWl0ZW1wdHkSLAoKS3ViZWNvbmZpZxgCIAEoDEIY6t4fFGt1YmVjb25maWcsb21pdGVtcHR5EjgKBUF6dXJlGAMgASgLMhAudHlwZXMuS3ViZUF6dXJlQhfI3h8A6t4fD2F6dXJlLG9taXRlbXB0eRIyCgNBV1MYBCABKAsyDi50eXBlcy5LdWJlQVdTQhXI3h8A6t4fDWF3cyxvbWl0ZW1wdHkSMgoDR0NQGAUgASgLMg4udHlwZXMuS3ViZUdDUEIVyN4fAOreHw1nY3Asb21pdGVtcHR5GksKEkR5bmFtaWNMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSJAoFdmFsdWUYAiABKAsyFS50eXBlcy5Db21tYW5kTGFiZWxWMjoCOAEi1QEKCUt1YmVBenVyZRIxCgxSZXNvdXJjZU5hbWUYASABKAlCG+reHxdyZXNvdXJjZV9uYW1lLG9taXRlbXB0eRIzCg1SZXNvdXJjZUdyb3VwGAIgASgJQhzq3h8YcmVzb3VyY2VfZ3JvdXAsb21pdGVtcHR5EikKCFRlbmFudElEGAMgASgJQhfq3h8TdGVuYW50X2lkLG9taXRlbXB0eRI1Cg5TdWJzY3JpcHRpb25JRBgEIAEoCUId6t4fGXN1YnNjcmlwdGlvbl9pZCxvbWl0ZW1wdHkifgoHS3ViZUFXUxIkCgZSZWdpb24YASABKAlCFOreHxByZWdpb24sb21pdGVtcHR5EisKCUFjY291bnRJRBgCIAEoCUIY6t4fFGFjY291bnRfaWQsb21pdGVtcHR5EiAKBE5hbWUYAyABKAlCEureHw5uYW1lLG9taXRlbXB0eSKCAQoHS3ViZUdDUBIoCghMb2NhdGlvbhgBIAEoCUIW6t4fEmxvY2F0aW9uLG9taXRlbXB0eRIrCglQcm9qZWN0SUQYAiABKAlCGOreHxRwcm9qZWN0X2lkLG9taXRlbXB0eRIgCgROYW1lGAMgASgJQhLq3h8ObmFtZSxvbWl0ZW1wdHkiUQoXS3ViZXJuZXRlc0NsdXN0ZXJWM0xpc3QSNgoSS3ViZXJuZXRlc0NsdXN0ZXJzGAEgAygLMhoudHlwZXMuS3ViZXJuZXRlc0NsdXN0ZXJWMyLtAQoSS3ViZXJuZXRlc1NlcnZlclYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI5CgRTcGVjGAUgASgLMh0udHlwZXMuS3ViZXJuZXRlc1NlcnZlclNwZWNWM0IMyN4fAOreHwRzcGVjOgiYoB8AgNwgACKXAgoWS3ViZXJuZXRlc1NlcnZlclNwZWNWMxIcCgdWZXJzaW9uGAEgASgJQgvq3h8HdmVyc2lvbhIeCghIb3N0bmFtZRgCIAEoCUIM6t4fCGhvc3RuYW1lEhsKBkhvc3RJRBgDIAEoCUIL6t4fB2hvc3RfaWQSPQoIUm90YXRpb24YBCABKAsyDy50eXBlcy5Sb3RhdGlvbkIayN4fAOreHxJyb3RhdGlvbixvbWl0ZW1wdHkSOAoHQ2x1c3RlchgFIAEoCzIaLnR5cGVzLkt1YmVybmV0ZXNDbHVzdGVyVjNCC+reHwdjbHVzdGVyEikKCFByb3h5SURzGAYgAygJQhfq3h8TcHJveHlfaWRzLG9taXRlbXB0eSLdAQoKV2ViVG9rZW5WMxIWCgRLaW5kGAEgASgJQgjq3h8Ea2luZBInCgdTdWJLaW5kGAIgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EhwKB1ZlcnNpb24YAyABKAlCC+reHwd2ZXJzaW9uEjMKCE1ldGFkYXRhGAQgASgLMg8udHlwZXMuTWV0YWRhdGFCEMjeHwDq3h8IbWV0YWRhdGESMQoEU3BlYxgFIAEoCzIVLnR5cGVzLldlYlRva2VuU3BlY1YzQgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAIkIKDldlYlRva2VuU3BlY1YzEhYKBFVzZXIYASABKAlCCOreHwR1c2VyEhgKBVRva2VuGAIgASgJQgnq3h8FdG9rZW4iUQoUR2V0V2ViU2Vzc2lvblJlcXVlc3QSFgoEVXNlchgBIAEoCUII6t4fBHVzZXISIQoJU2Vzc2lvbklEGAIgASgJQg7q3h8Kc2Vzc2lvbl9pZCJUChdEZWxldGVXZWJTZXNzaW9uUmVxdWVzdBIWCgRVc2VyGAEgASgJQgjq3h8EdXNlchIhCglTZXNzaW9uSUQYAiABKAlCDureHwpzZXNzaW9uX2lkIkYKEkdldFdlYlRva2VuUmVxdWVzdBIWCgRVc2VyGAEgASgJQgjq3h8EdXNlchIYCgVUb2tlbhgCIAEoCUIJ6t4fBXRva2VuIkkKFURlbGV0ZVdlYlRva2VuUmVxdWVzdBIWCgRVc2VyGAEgASgJQgjq3h8EdXNlchIYCgVUb2tlbhgCIAEoCUIJ6t4fBXRva2VuIikKD1Jlc291cmNlUmVxdWVzdBIWCgROYW1lGAEgASgJQgjq3h8EbmFtZSJlChpSZXNvdXJjZVdpdGhTZWNyZXRzUmVxdWVzdBIWCgROYW1lGAEgASgJQgjq3h8EbmFtZRIvCgtXaXRoU2VjcmV0cxgCIAEoCEIa6t4fFndpdGhfc2VjcmV0cyxvbWl0ZW1wdHkiTgobUmVzb3VyY2VzV2l0aFNlY3JldHNSZXF1ZXN0Ei8KC1dpdGhTZWNyZXRzGAEgASgIQhrq3h8Wd2l0aF9zZWNyZXRzLG9taXRlbXB0eSI9ChpSZXNvdXJjZUluTmFtZXNwYWNlUmVxdWVzdBIMCgROYW1lGAEgASgJEhEKCU5hbWVzcGFjZRgCIAEoCSIwChtSZXNvdXJjZXNJbk5hbWVzcGFjZVJlcXVlc3QSEQoJTmFtZXNwYWNlGAEgASgJIt0BCg9PSURDQ29ubmVjdG9yVjMSFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjYKBFNwZWMYBSABKAsyGi50eXBlcy5PSURDQ29ubmVjdG9yU3BlY1YzQgzI3h8A6t4fBHNwZWMiRQoTT0lEQ0Nvbm5lY3RvclYzTGlzdBIuCg5PSURDQ29ubmVjdG9ycxgBIAMoCzIWLnR5cGVzLk9JRENDb25uZWN0b3JWMyL2BwoTT0lEQ0Nvbm5lY3RvclNwZWNWMxIhCglJc3N1ZXJVUkwYASABKAlCDureHwppc3N1ZXJfdXJsEh8KCENsaWVudElEGAIgASgJQg3q3h8JY2xpZW50X2lkEicKDENsaWVudFNlY3JldBgDIAEoCUIR6t4fDWNsaWVudF9zZWNyZXQSJQoDQUNSGAUgASgJQhjq3h8UYWNyX3ZhbHVlcyxvbWl0ZW1wdHkSKAoIUHJvdmlkZXIYBiABKAlCFureHxJwcm92aWRlcixvbWl0ZW1wdHkSJgoHRGlzcGxheRgHIAEoCUIV6t4fEWRpc3BsYXksb21pdGVtcHR5EiIKBVNjb3BlGAggAygJQhPq3h8Pc2NvcGUsb21pdGVtcHR5EiQKBlByb21wdBgJIAEoCUIU6t4fEHByb21wdCxvbWl0ZW1wdHkSTQoNQ2xhaW1zVG9Sb2xlcxgKIAMoCzITLnR5cGVzLkNsYWltTWFwcGluZ0IhyN4fAOreHxljbGFpbXNfdG9fcm9sZXMsb21pdGVtcHR5EkkKF0dvb2dsZVNlcnZpY2VBY2NvdW50VVJJGAsgASgJQijq3h8kZ29vZ2xlX3NlcnZpY2VfYWNjb3VudF91cmksb21pdGVtcHR5EkIKFEdvb2dsZVNlcnZpY2VBY2NvdW50GAwgASgJQiTq3h8gZ29vZ2xlX3NlcnZpY2VfYWNjb3VudCxvbWl0ZW1wdHkSOgoQR29vZ2xlQWRtaW5FbWFpbBgNIAEoCUIg6t4fHGdvb2dsZV9hZG1pbl9lbWFpbCxvbWl0ZW1wdHkSggEKDFJlZGlyZWN0VVJMcxgOIAEoCzIWLndyYXBwZXJzLlN0cmluZ1ZhbHVlc0JUyN4fANreHzxnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL3R5cGVzL3dyYXBwZXJzLlN0cmluZ3Pq3h8McmVkaXJlY3RfdXJsEkIKFEFsbG93VW52ZXJpZmllZEVtYWlsGA8gASgIQiTq3h8gYWxsb3dfdW52ZXJpZmllZF9lbWFpbCxvbWl0ZW1wdHkSMwoNVXNlcm5hbWVDbGFpbRgQIAEoCUIc6t4fGHVzZXJuYW1lX2NsYWltLG9taXRlbXB0eRInCgZNYXhBZ2UYESABKAsyDS50eXBlcy5NYXhBZ2VCCNDeHwHq3h8AEmgKFkNsaWVudFJlZGlyZWN0U2V0dGluZ3MYEiABKAsyIC50eXBlcy5TU09DbGllbnRSZWRpcmVjdFNldHRpbmdzQibq3h8iY2xpZW50X3JlZGlyZWN0X3NldHRpbmdzLG9taXRlbXB0eUoECAQQBSIwCgZNYXhBZ2USJgoFVmFsdWUYASABKANCF+reHwdtYXhfYWdl+t4fCER1cmF0aW9uImIKGVNTT0NsaWVudFJlZGlyZWN0U2V0dGluZ3MSHwoXYWxsb3dlZF9odHRwc19ob3N0bmFtZXMYASADKAkSJAocaW5zZWN1cmVfYWxsb3dlZF9jaWRyX3JhbmdlcxgCIAMoCSKzCgoPT0lEQ0F1dGhSZXF1ZXN0EiUKC0Nvbm5lY3RvcklEGAEgASgJQhDq3h8MY29ubmVjdG9yX2lkEhYKBFR5cGUYAiABKAlCCOreHwR0eXBlEiEKCUNoZWNrVXNlchgDIAEoCEIO6t4fCmNoZWNrX3VzZXISIwoKU3RhdGVUb2tlbhgEIAEoCUIP6t4fC3N0YXRlX3Rva2VuEiEKCUNTUkZUb2tlbhgFIAEoCUIO6t4fCmNzcmZfdG9rZW4SJQoLUmVkaXJlY3RVUkwYBiABKAlCEOreHwxyZWRpcmVjdF91cmwSIwoJUHVibGljS2V5GAcgASgMQhAYAereHwpwdWJsaWNfa2V5Ei4KB0NlcnRUVEwYCCABKANCHereHwhjZXJ0X3R0bPreHw10aW1lLkR1cmF0aW9uEjAKEENyZWF0ZVdlYlNlc3Npb24YCSABKAhCFureHxJjcmVhdGVfd2ViX3Nlc3Npb24SMgoRQ2xpZW50UmVkaXJlY3RVUkwYCiABKAlCF+reHxNjbGllbnRfcmVkaXJlY3RfdXJsEjIKDUNvbXBhdGliaWxpdHkYCyABKAlCG+reHxdjb21wYXRpYmlsaXR5LG9taXRlbXB0eRI2Cg5Sb3V0ZVRvQ2x1c3RlchgMIAEoCUIe6t4fGnJvdXRlX3RvX2NsdXN0ZXIsb21pdGVtcHR5EjsKEUt1YmVybmV0ZXNDbHVzdGVyGA0gASgJQiDq3h8ca3ViZXJuZXRlc19jbHVzdGVyLG9taXRlbXB0eRImCgtTU09UZXN0RmxvdxgOIAEoCEIR6t4fDXNzb190ZXN0X2Zsb3cSTwoNQ29ubmVjdG9yU3BlYxgPIAEoCzIaLnR5cGVzLk9JRENDb25uZWN0b3JTcGVjVjNCHOreHxhjb25uZWN0b3Jfc3BlYyxvbWl0ZW1wdHkSMQoMUHJveHlBZGRyZXNzGBAgASgJQhvq3h8XcHJveHlfYWRkcmVzcyxvbWl0ZW1wdHkScwoVYXR0ZXN0YXRpb25fc3RhdGVtZW50GBEgASgLMi0udGVsZXBvcnQuYXR0ZXN0YXRpb24udjEuQXR0ZXN0YXRpb25TdGF0ZW1lbnRCJRgB6t4fH2F0dGVzdGF0aW9uX3N0YXRlbWVudCxvbWl0ZW1wdHkSNAoNQ2xpZW50TG9naW5JUBgSIAEoCUId6t4fGWNsaWVudF9sb2dpbl9pcCxvbWl0ZW1wdHkSOAoPQ2xpZW50VXNlckFnZW50GBMgASgJQh/q3h8bY2xpZW50X3VzZXJfYWdlbnQsb21pdGVtcHR5EjEKDnNzaF9wdWJsaWNfa2V5GBQgASgMQhnq3h8Vc3NoX3B1Yl9rZXksb21pdGVtcHR5EjEKDnRsc19wdWJsaWNfa2V5GBUgASgMQhnq3h8VdGxzX3B1Yl9rZXksb21pdGVtcHR5EnkKGXNzaF9hdHRlc3RhdGlvbl9zdGF0ZW1lbnQYFiABKAsyLS50ZWxlcG9ydC5hdHRlc3RhdGlvbi52MS5BdHRlc3RhdGlvblN0YXRlbWVudEIn6t4fI3NzaF9hdHRlc3RhdGlvbl9zdGF0ZW1lbnQsb21pdGVtcHR5EnkKGXRsc19hdHRlc3RhdGlvbl9zdGF0ZW1lbnQYFyABKAsyLS50ZWxlcG9ydC5hdHRlc3RhdGlvbi52MS5BdHRlc3RhdGlvblN0YXRlbWVudEIn6t4fI3Rsc19hdHRlc3RhdGlvbl9zdGF0ZW1lbnQsb21pdGVtcHR5It0BCg9TQU1MQ29ubmVjdG9yVjISFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjYKBFNwZWMYBSABKAsyGi50eXBlcy5TQU1MQ29ubmVjdG9yU3BlY1YyQgzI3h8A6t4fBHNwZWMiRQoTU0FNTENvbm5lY3RvclYyTGlzdBIuCg5TQU1MQ29ubmVjdG9ycxgBIAMoCzIWLnR5cGVzLlNBTUxDb25uZWN0b3JWMiL/BgoTU0FNTENvbm5lY3RvclNwZWNWMhIaCgZJc3N1ZXIYASABKAlCCureHwZpc3N1ZXISFAoDU1NPGAIgASgJQgfq3h8Dc3NvEhYKBENlcnQYAyABKAlCCOreHwRjZXJ0EhwKB0Rpc3BsYXkYBCABKAlCC+reHwdkaXNwbGF5EikKGEFzc2VydGlvbkNvbnN1bWVyU2VydmljZRgFIAEoCUIH6t4fA2FjcxIeCghBdWRpZW5jZRgGIAEoCUIM6t4fCGF1ZGllbmNlEjoKFVNlcnZpY2VQcm92aWRlcklzc3VlchgHIAEoCUIb6t4fF3NlcnZpY2VfcHJvdmlkZXJfaXNzdWVyEi8KEEVudGl0eURlc2NyaXB0b3IYCCABKAlCFereHxFlbnRpdHlfZGVzY3JpcHRvchI2ChNFbnRpdHlEZXNjcmlwdG9yVVJMGAkgASgJQhnq3h8VZW50aXR5X2Rlc2NyaXB0b3JfdXJsEk8KEUF0dHJpYnV0ZXNUb1JvbGVzGAogAygLMhcudHlwZXMuQXR0cmlidXRlTWFwcGluZ0IbyN4fAOreHxNhdHRyaWJ1dGVzX3RvX3JvbGVzElQKDlNpZ25pbmdLZXlQYWlyGAsgASgLMhgudHlwZXMuQXN5bW1ldHJpY0tleVBhaXJCIsjeHwHq3h8ac2lnbmluZ19rZXlfcGFpcixvbWl0ZW1wdHkSKAoIUHJvdmlkZXIYDCABKAlCFureHxJwcm92aWRlcixvbWl0ZW1wdHkSWQoRRW5jcnlwdGlvbktleVBhaXIYDSABKAsyGC50eXBlcy5Bc3ltbWV0cmljS2V5UGFpckIkyN4fAereHxxhc3NlcnRpb25fa2V5X3BhaXIsb21pdGVtcHR5EkAKEUFsbG93SURQSW5pdGlhdGVkGA4gASgIQiXI3h8B6t4fHWFsbG93X2lkcF9pbml0aWF0ZWQsb21pdGVtcHR5EmgKFkNsaWVudFJlZGlyZWN0U2V0dGluZ3MYDyABKAsyIC50eXBlcy5TU09DbGllbnRSZWRpcmVjdFNldHRpbmdzQibq3h8iY2xpZW50X3JlZGlyZWN0X3NldHRpbmdzLG9taXRlbXB0eRI4Cg9TaW5nbGVMb2dvdXRVUkwYECABKAlCH+reHxtzaW5nbGVfbG9nb3V0X3VybCxvbWl0ZW1wdHki7QkKD1NBTUxBdXRoUmVxdWVzdBISCgJJRBgBIAEoCUIG6t4fAmlkEiUKC0Nvbm5lY3RvcklEGAIgASgJQhDq3h8MY29ubmVjdG9yX2lkEhYKBFR5cGUYAyABKAlCCOreHwR0eXBlEiEKCUNoZWNrVXNlchgEIAEoCEIO6t4fCmNoZWNrX3VzZXISJQoLUmVkaXJlY3RVUkwYBSABKAlCEOreHwxyZWRpcmVjdF91cmwSIwoJUHVibGljS2V5GAYgASgMQhAYAereHwpwdWJsaWNfa2V5Ei4KB0NlcnRUVEwYByABKANCHereHwhjZXJ0X3R0bPreHw10aW1lLkR1cmF0aW9uEiEKCUNTUkZUb2tlbhgIIAEoCUIO6t4fCmNzcmZfdG9rZW4SMAoQQ3JlYXRlV2ViU2Vzc2lvbhgJIAEoCEIW6t4fEmNyZWF0ZV93ZWJfc2Vzc2lvbhIyChFDbGllbnRSZWRpcmVjdFVSTBgKIAEoCUIX6t4fE2NsaWVudF9yZWRpcmVjdF91cmwSMgoNQ29tcGF0aWJpbGl0eRgLIAEoCUIb6t4fF2NvbXBhdGliaWxpdHksb21pdGVtcHR5EjYKDlJvdXRlVG9DbHVzdGVyGAwgASgJQh7q3h8acm91dGVfdG9fY2x1c3RlcixvbWl0ZW1wdHkSOwoRS3ViZXJuZXRlc0NsdXN0ZXIYDSABKAlCIOreHxxrdWJlcm5ldGVzX2NsdXN0ZXIsb21pdGVtcHR5EiYKC1NTT1Rlc3RGbG93GA4gASgIQhHq3h8Nc3NvX3Rlc3RfZmxvdxJPCg1Db25uZWN0b3JTcGVjGA8gASgLMhoudHlwZXMuU0FNTENvbm5lY3RvclNwZWNWMkIc6t4fGGNvbm5lY3Rvcl9zcGVjLG9taXRlbXB0eRJxChVhdHRlc3RhdGlvbl9zdGF0ZW1lbnQYECABKAsyLS50ZWxlcG9ydC5hdHRlc3RhdGlvbi52MS5BdHRlc3RhdGlvblN0YXRlbWVudEIj6t4fH2F0dGVzdGF0aW9uX3N0YXRlbWVudCxvbWl0ZW1wdHkSNAoNQ2xpZW50TG9naW5JUBgRIAEoCUId6t4fGWNsaWVudF9sb2dpbl9pcCxvbWl0ZW1wdHkSOAoPQ2xpZW50VXNlckFnZW50GBIgASgJQh/q3h8bY2xpZW50X3VzZXJfYWdlbnQsb21pdGVtcHR5EjEKDnNzaF9wdWJsaWNfa2V5GBMgASgMQhnq3h8Vc3NoX3B1Yl9rZXksb21pdGVtcHR5EjEKDnRsc19wdWJsaWNfa2V5GBQgASgMQhnq3h8VdGxzX3B1Yl9rZXksb21pdGVtcHR5EnkKGXNzaF9hdHRlc3RhdGlvbl9zdGF0ZW1lbnQYFSABKAsyLS50ZWxlcG9ydC5hdHRlc3RhdGlvbi52MS5BdHRlc3RhdGlvblN0YXRlbWVudEIn6t4fI3NzaF9hdHRlc3RhdGlvbl9zdGF0ZW1lbnQsb21pdGVtcHR5EnkKGXRsc19hdHRlc3RhdGlvbl9zdGF0ZW1lbnQYFiABKAsyLS50ZWxlcG9ydC5hdHRlc3RhdGlvbi52MS5BdHRlc3RhdGlvblN0YXRlbWVudEIn6t4fI3Rsc19hdHRlc3RhdGlvbl9zdGF0ZW1lbnQsb21pdGVtcHR5ImgKEEF0dHJpYnV0ZU1hcHBpbmcSFgoETmFtZRgBIAEoCUII6t4fBG5hbWUSGAoFVmFsdWUYAiABKAlCCereHwV2YWx1ZRIiCgVSb2xlcxgDIAMoCUIT6t4fD3JvbGVzLG9taXRlbXB0eSJQChFBc3ltbWV0cmljS2V5UGFpchIjCgpQcml2YXRlS2V5GAEgASgJQg/q3h8LcHJpdmF0ZV9rZXkSFgoEQ2VydBgCIAEoCUII6t4fBGNlcnQi4QEKEUdpdGh1YkNvbm5lY3RvclYzEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI4CgRTcGVjGAUgASgLMhwudHlwZXMuR2l0aHViQ29ubmVjdG9yU3BlY1YzQgzI3h8A6t4fBHNwZWMiSwoVR2l0aHViQ29ubmVjdG9yVjNMaXN0EjIKEEdpdGh1YkNvbm5lY3RvcnMYASADKAsyGC50eXBlcy5HaXRodWJDb25uZWN0b3JWMyLwAwoVR2l0aHViQ29ubmVjdG9yU3BlY1YzEh8KCENsaWVudElEGAEgASgJQg3q3h8JY2xpZW50X2lkEicKDENsaWVudFNlY3JldBgCIAEoCUIR6t4fDWNsaWVudF9zZWNyZXQSJQoLUmVkaXJlY3RVUkwYAyABKAlCEOreHwxyZWRpcmVjdF91cmwSQgoNVGVhbXNUb0xvZ2lucxgEIAMoCzISLnR5cGVzLlRlYW1NYXBwaW5nQhfI3h8A6t4fD3RlYW1zX3RvX2xvZ2lucxIcCgdEaXNwbGF5GAUgASgJQgvq3h8HZGlzcGxheRJFCgxUZWFtc1RvUm9sZXMYBiADKAsyFy50eXBlcy5UZWFtUm9sZXNNYXBwaW5nQhbI3h8A6t4fDnRlYW1zX3RvX3JvbGVzEiUKC0VuZHBvaW50VVJMGAcgASgJQhDq3h8MZW5kcG9pbnRfdXJsEiwKDkFQSUVuZHBvaW50VVJMGAggASgJQhTq3h8QYXBpX2VuZHBvaW50X3VybBJoChZDbGllbnRSZWRpcmVjdFNldHRpbmdzGAkgASgLMiAudHlwZXMuU1NPQ2xpZW50UmVkaXJlY3RTZXR0aW5nc0Im6t4fImNsaWVudF9yZWRpcmVjdF9zZXR0aW5ncyxvbWl0ZW1wdHkirQoKEUdpdGh1YkF1dGhSZXF1ZXN0EiUKC0Nvbm5lY3RvcklEGAEgASgJQhDq3h8MY29ubmVjdG9yX2lkEhYKBFR5cGUYAiABKAlCCOreHwR0eXBlEiMKClN0YXRlVG9rZW4YAyABKAlCD+reHwtzdGF0ZV90b2tlbhIhCglDU1JGVG9rZW4YBCABKAlCDureHwpjc3JmX3Rva2VuEiMKCVB1YmxpY0tleRgFIAEoDEIQGAHq3h8KcHVibGljX2tleRIuCgdDZXJ0VFRMGAYgASgDQh3q3h8IY2VydF90dGz63h8NdGltZS5EdXJhdGlvbhIwChBDcmVhdGVXZWJTZXNzaW9uGAcgASgIQhbq3h8SY3JlYXRlX3dlYl9zZXNzaW9uEiUKC1JlZGlyZWN0VVJMGAggASgJQhDq3h8McmVkaXJlY3RfdXJsEjIKEUNsaWVudFJlZGlyZWN0VVJMGAkgASgJQhfq3h8TY2xpZW50X3JlZGlyZWN0X3VybBIyCg1Db21wYXRpYmlsaXR5GAogASgJQhvq3h8XY29tcGF0aWJpbGl0eSxvbWl0ZW1wdHkSSgoHRXhwaXJlcxgLIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCHcjeHwHq3h8RZXhwaXJlcyxvbWl0ZW1wdHmQ3x8BEjYKDlJvdXRlVG9DbHVzdGVyGAwgASgJQh7q3h8acm91dGVfdG9fY2x1c3RlcixvbWl0ZW1wdHkSOwoRS3ViZXJuZXRlc0NsdXN0ZXIYDSABKAlCIOreHxxrdWJlcm5ldGVzX2NsdXN0ZXIsb21pdGVtcHR5EiYKC1NTT1Rlc3RGbG93GA4gASgIQhHq3h8Nc3NvX3Rlc3RfZmxvdxJRCg1Db25uZWN0b3JTcGVjGA8gASgLMhwudHlwZXMuR2l0aHViQ29ubmVjdG9yU3BlY1YzQhzq3h8YY29ubmVjdG9yX3NwZWMsb21pdGVtcHR5EnMKFWF0dGVzdGF0aW9uX3N0YXRlbWVudBgQIAEoCzItLnRlbGVwb3J0LmF0dGVzdGF0aW9uLnYxLkF0dGVzdGF0aW9uU3RhdGVtZW50QiUYAereHx9hdHRlc3RhdGlvbl9zdGF0ZW1lbnQsb21pdGVtcHR5EjQKDUNsaWVudExvZ2luSVAYESABKAlCHereHxljbGllbnRfbG9naW5faXAsb21pdGVtcHR5EjgKD0NsaWVudFVzZXJBZ2VudBgSIAEoCUIf6t4fG2NsaWVudF91c2VyX2FnZW50LG9taXRlbXB0eRIxCg5zc2hfcHVibGljX2tleRgTIAEoDEIZ6t4fFXNzaF9wdWJfa2V5LG9taXRlbXB0eRIxCg50bHNfcHVibGljX2tleRgUIAEoDEIZ6t4fFXRsc19wdWJfa2V5LG9taXRlbXB0eRJ5Chlzc2hfYXR0ZXN0YXRpb25fc3RhdGVtZW50GBUgASgLMi0udGVsZXBvcnQuYXR0ZXN0YXRpb24udjEuQXR0ZXN0YXRpb25TdGF0ZW1lbnRCJ+reHyNzc2hfYXR0ZXN0YXRpb25fc3RhdGVtZW50LG9taXRlbXB0eRJ5Chl0bHNfYXR0ZXN0YXRpb25fc3RhdGVtZW50GBYgASgLMi0udGVsZXBvcnQuYXR0ZXN0YXRpb24udjEuQXR0ZXN0YXRpb25TdGF0ZW1lbnRCJ+reHyN0bHNfYXR0ZXN0YXRpb25fc3RhdGVtZW50LG9taXRlbXB0eSJfCgtTU09XYXJuaW5ncxImCgdNZXNzYWdlGAEgASgJQhXq3h8RbWVzc2FnZSxvbWl0ZW1wdHkSKAoIV2FybmluZ3MYAiADKAlCFureHxJ3YXJuaW5ncyxvbWl0ZW1wdHki0gMKEENyZWF0ZVVzZXJQYXJhbXMSMwoNQ29ubmVjdG9yTmFtZRgBIAEoCUIc6t4fGGNvbm5lY3Rvcl9uYW1lLG9taXRlbXB0eRIoCghVc2VybmFtZRgCIAEoCUIW6t4fEnVzZXJuYW1lLG9taXRlbXB0eRIkCgZMb2dpbnMYAyADKAlCFOreHxBsb2dpbnMsb21pdGVtcHR5Ei0KCkt1YmVHcm91cHMYBCADKAlCGereHxVrdWJlX2dyb3VwcyxvbWl0ZW1wdHkSKwoJS3ViZVVzZXJzGAUgAygJQhjq3h8Ua3ViZV91c2VycyxvbWl0ZW1wdHkSIgoFUm9sZXMYBiADKAlCE+reHw9yb2xlcyxvbWl0ZW1wdHkSfgoGVHJhaXRzGAcgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCV8jeHwDa3h87Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS90eXBlcy93cmFwcGVycy5UcmFpdHPq3h8QdHJhaXRzLG9taXRlbXB0eRI5CgpTZXNzaW9uVFRMGAggASgDQiXq3h8Vc2Vzc2lvbl90dGwsb21pdGVtcHR5+t4fCER1cmF0aW9uIrAPChFTU09EaWFnbm9zdGljSW5mbxIfCghUZXN0RmxvdxgBIAEoCEIN6t4fCXRlc3RfZmxvdxIYCgVFcnJvchgCIAEoCUIJ6t4fBWVycm9yEhwKB1N1Y2Nlc3MYAyABKAhCC+reHwdzdWNjZXNzElMKEENyZWF0ZVVzZXJQYXJhbXMYBCABKAsyFy50eXBlcy5DcmVhdGVVc2VyUGFyYW1zQiDq3h8cY3JlYXRlX3VzZXJfcGFyYW1zLG9taXRlbXB0eRJiChVTQU1MQXR0cmlidXRlc1RvUm9sZXMYCiADKAsyFy50eXBlcy5BdHRyaWJ1dGVNYXBwaW5nQirI3h8A6t4fInNhbWxfYXR0cmlidXRlc190b19yb2xlcyxvbWl0ZW1wdHkSagodU0FNTEF0dHJpYnV0ZXNUb1JvbGVzV2FybmluZ3MYCyABKAsyEi50eXBlcy5TU09XYXJuaW5nc0Iv6t4fK3NhbWxfYXR0cmlidXRlc190b19yb2xlc193YXJuaW5ncyxvbWl0ZW1wdHkSogEKF1NBTUxBdHRyaWJ1dGVTdGF0ZW1lbnRzGAwgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCasjeHwDa3h87Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS90eXBlcy93cmFwcGVycy5UcmFpdHPq3h8jc2FtbF9hdHRyaWJ1dGVfc3RhdGVtZW50cyxvbWl0ZW1wdHkSYwoRU0FNTEFzc2VydGlvbkluZm8YDSABKAsyFC53cmFwcGVycy5DdXN0b21UeXBlQjLa3h8NQXNzZXJ0aW9uSW5mb+reHx1zYW1sX2Fzc2VydGlvbl9pbmZvLG9taXRlbXB0eRKlAQoYU0FNTFRyYWl0c0Zyb21Bc3NlcnRpb25zGA4gASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCbMjeHwDa3h87Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS90eXBlcy93cmFwcGVycy5UcmFpdHPq3h8lc2FtbF90cmFpdHNfZnJvbV9hc3NlcnRpb25zLG9taXRlbXB0eRJmChlTQU1MQ29ubmVjdG9yVHJhaXRNYXBwaW5nGA8gAygLMhMudHlwZXMuVHJhaXRNYXBwaW5nQi7I3h8A6t4fJnNhbWxfY29ubmVjdG9yX3RyYWl0X21hcHBpbmcsb21pdGVtcHR5ElYKEU9JRENDbGFpbXNUb1JvbGVzGBQgAygLMhMudHlwZXMuQ2xhaW1NYXBwaW5nQibI3h8A6t4fHm9pZGNfY2xhaW1zX3RvX3JvbGVzLG9taXRlbXB0eRJiChlPSURDQ2xhaW1zVG9Sb2xlc1dhcm5pbmdzGBUgASgLMhIudHlwZXMuU1NPV2FybmluZ3NCK+reHydvaWRjX2NsYWltc190b19yb2xlc193YXJuaW5ncyxvbWl0ZW1wdHkSVQoKT0lEQ0NsYWltcxgWIAEoCzIULndyYXBwZXJzLkN1c3RvbVR5cGVCK8jeHwDa3h8KT0lEQ0NsYWltc+reHxVvaWRjX2NsYWltcyxvbWl0ZW1wdHkSVwoMT0lEQ0lkZW50aXR5GBcgASgLMhQud3JhcHBlcnMuQ3VzdG9tVHlwZUIr2t4fDE9JRENJZGVudGl0eereHxdvaWRjX2lkZW50aXR5LG9taXRlbXB0eRKdAQoUT0lEQ1RyYWl0c0Zyb21DbGFpbXMYGCABKAsyFS53cmFwcGVycy5MYWJlbFZhbHVlc0JoyN4fANreHztnaXRodWIuY29tL2dyYXZpdGF0aW9uYWwvdGVsZXBvcnQvYXBpL3R5cGVzL3dyYXBwZXJzLlRyYWl0c+reHyFvaWRjX3RyYWl0c19mcm9tX2NsYWltcyxvbWl0ZW1wdHkSZgoZT0lEQ0Nvbm5lY3RvclRyYWl0TWFwcGluZxgZIAMoCzITLnR5cGVzLlRyYWl0TWFwcGluZ0IuyN4fAOreHyZvaWRjX2Nvbm5lY3Rvcl90cmFpdF9tYXBwaW5nLG9taXRlbXB0eRJGCgxHaXRodWJDbGFpbXMYHiABKAsyEy50eXBlcy5HaXRodWJDbGFpbXNCG+reHxdnaXRodWJfY2xhaW1zLG9taXRlbXB0eRJZChNHaXRodWJUZWFtc1RvTG9naW5zGB8gAygLMhIudHlwZXMuVGVhbU1hcHBpbmdCKMjeHwDq3h8gZ2l0aHViX3RlYW1zX3RvX2xvZ2lucyxvbWl0ZW1wdHkSXAoSR2l0aHViVGVhbXNUb1JvbGVzGCAgAygLMhcudHlwZXMuVGVhbVJvbGVzTWFwcGluZ0InyN4fAOreHx9naXRodWJfdGVhbXNfdG9fcm9sZXMsb21pdGVtcHR5ElAKD0dpdGh1YlRva2VuSW5mbxghIAEoCzIWLnR5cGVzLkdpdGh1YlRva2VuSW5mb0If6t4fG2dpdGh1Yl90b2tlbl9pbmZvLG9taXRlbXB0eRI8ChFBcHBsaWVkTG9naW5SdWxlcxgiIAMoCUIh6t4fHWFwcGxpZWRfbG9naW5fcnVsZXMsb21pdGVtcHR5ImwKD0dpdGh1YlRva2VuSW5mbxIhCglUb2tlblR5cGUYASABKAlCDureHwp0b2tlbl90eXBlEhwKB0V4cGlyZXMYAiABKANCC+reHwdleHBpcmVzEhgKBVNjb3BlGAMgASgJQgnq3h8Fc2NvcGUi2wEKDEdpdGh1YkNsYWltcxIeCghVc2VybmFtZRgBIAEoCUIM6t4fCHVzZXJuYW1lEpABChNPcmdhbml6YXRpb25Ub1RlYW1zGAIgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCXMjeHwDa3h87Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS90eXBlcy93cmFwcGVycy5UcmFpdHPq3h8Vb3JnYW5pemF0aW9uX3RvX3RlYW1zEhgKBVRlYW1zGAMgAygJQgnq3h8FdGVhbXMi2wEKC1RlYW1NYXBwaW5nEiYKDE9yZ2FuaXphdGlvbhgBIAEoCUIQ6t4fDG9yZ2FuaXphdGlvbhIWCgRUZWFtGAIgASgJQgjq3h8EdGVhbRIkCgZMb2dpbnMYAyADKAlCFOreHxBsb2dpbnMsb21pdGVtcHR5EjMKCkt1YmVHcm91cHMYBCADKAlCH+reHxtrdWJlcm5ldGVzX2dyb3VwcyxvbWl0ZW1wdHkSMQoJS3ViZVVzZXJzGAUgAygJQh7q3h8aa3ViZXJuZXRlc191c2VycyxvbWl0ZW1wdHkidgoQVGVhbVJvbGVzTWFwcGluZxImCgxPcmdhbml6YXRpb24YASABKAlCEOreHwxvcmdhbml6YXRpb24SFgoEVGVhbRgCIAEoCUII6t4fBHRlYW0SIgoFUm9sZXMYAyADKAlCE+reHw9yb2xlcyxvbWl0ZW1wdHki5QEKEFRydXN0ZWRDbHVzdGVyVjISFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjcKBFNwZWMYBSABKAsyGy50eXBlcy5UcnVzdGVkQ2x1c3RlclNwZWNWMkIMyN4fAOreHwRzcGVjOgSYoB8AIkgKFFRydXN0ZWRDbHVzdGVyVjJMaXN0EjAKD1RydXN0ZWRDbHVzdGVycxgBIAMoCzIXLnR5cGVzLlRydXN0ZWRDbHVzdGVyVjIijAIKFFRydXN0ZWRDbHVzdGVyU3BlY1YyEhwKB0VuYWJsZWQYASABKAhCC+reHwdlbmFibGVkEiIKBVJvbGVzGAIgAygJQhPq3h8Pcm9sZXMsb21pdGVtcHR5EhgKBVRva2VuGAMgASgJQgnq3h8FdG9rZW4SKAoMUHJveHlBZGRyZXNzGAQgASgJQhLq3h8Od2ViX3Byb3h5X2FkZHISLQoUUmV2ZXJzZVR1bm5lbEFkZHJlc3MYBSABKAlCD+reHwt0dW5uZWxfYWRkchI/CgdSb2xlTWFwGAYgAygLMhIudHlwZXMuUm9sZU1hcHBpbmdCGsjeHwDq3h8Scm9sZV9tYXAsb21pdGVtcHR5IssBCgZMb2NrVjISFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEi0KBFNwZWMYBSABKAsyES50eXBlcy5Mb2NrU3BlY1YyQgzI3h8A6t4fBHNwZWMisQIKCkxvY2tTcGVjVjISMQoGVGFyZ2V0GAEgASgLMhEudHlwZXMuTG9ja1RhcmdldEIOyN4fAOreHwZ0YXJnZXQSJgoHTWVzc2FnZRgCIAEoCUIV6t4fEW1lc3NhZ2Usb21pdGVtcHR5EkoKB0V4cGlyZXMYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8B6t4fEWV4cGlyZXMsb21pdGVtcHR5kN8fARJPCglDcmVhdGVkQXQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQiDI3h8A6t4fFGNyZWF0ZWRfYXQsb21pdGVtcHR5kN8fARIrCglDcmVhdGVkQnkYBSABKAlCGOreHxRjcmVhdGVkX2J5LG9taXRlbXB0eSKMAwoKTG9ja1RhcmdldBIgCgRVc2VyGAEgASgJQhLq3h8OdXNlcixvbWl0ZW1wdHkSIAoEUm9sZRgCIAEoCUIS6t4fDnJvbGUsb21pdGVtcHR5EiIKBUxvZ2luGAMgASgJQhPq3h8PbG9naW4sb21pdGVtcHR5EiIKBE5vZGUYBCABKAlCFBgB6t4fDm5vZGUsb21pdGVtcHR5EisKCU1GQURldmljZRgFIAEoCUIY6t4fFG1mYV9kZXZpY2Usb21pdGVtcHR5EjUKDldpbmRvd3NEZXNrdG9wGAYgASgJQh3q3h8Zd2luZG93c19kZXNrdG9wLG9taXRlbXB0eRIzCg1BY2Nlc3NSZXF1ZXN0GAcgASgJQhzq3h8YYWNjZXNzX3JlcXVlc3Qsb21pdGVtcHR5EiQKBkRldmljZRgIIAEoCUIU6t4fEGRldmljZSxvbWl0ZW1wdHkSKQoIU2VydmVySUQYCSABKAlCF+reHxNzZXJ2ZXJfaWQsb21pdGVtcHR5OgiYoB8AgNwgACIqChBBZGRyZXNzQ29uZGl0aW9uEhYKBENJRFIYASABKAlCCOreHwRjaWRyIocBChlOZXR3b3JrUmVzdHJpY3Rpb25zU3BlY1Y0EjUKBUFsbG93GAEgAygLMhcudHlwZXMuQWRkcmVzc0NvbmRpdGlvbkINyN4fAOreHwVhbGxvdxIzCgREZW55GAIgAygLMhcudHlwZXMuQWRkcmVzc0NvbmRpdGlvbkIMyN4fAOreHwRkZW55IukBChVOZXR3b3JrUmVzdHJpY3Rpb25zVjQSFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjwKBFNwZWMYBSABKAsyIC50eXBlcy5OZXR3b3JrUmVzdHJpY3Rpb25zU3BlY1Y0QgzI3h8A6t4fBHNwZWMijgEKF1dpbmRvd3NEZXNrdG9wU2VydmljZVYzEjMKBkhlYWRlchgBIAEoCzIVLnR5cGVzLlJlc291cmNlSGVhZGVyQgzI3h8A0N4fAereHwASPgoEU3BlYxgCIAEoCzIiLnR5cGVzLldpbmRvd3NEZXNrdG9wU2VydmljZVNwZWNWM0IMyN4fAOreHwRzcGVjIq8BChtXaW5kb3dzRGVza3RvcFNlcnZpY2VTcGVjVjMSFgoEQWRkchgBIAEoCUII6t4fBGFkZHISLQoPVGVsZXBvcnRWZXJzaW9uGAIgASgJQhTq3h8QdGVsZXBvcnRfdmVyc2lvbhIeCghIb3N0bmFtZRgDIAEoCUIM6t4fCGhvc3RuYW1lEikKCFByb3h5SURzGAQgAygJQhfq3h8TcHJveHlfaWRzLG9taXRlbXB0eSJLChRXaW5kb3dzRGVza3RvcEZpbHRlchIbCgZIb3N0SUQYASABKAlCC+reHwdob3N0X2lkEhYKBE5hbWUYAiABKAlCCOreHwRuYW1lIoABChBXaW5kb3dzRGVza3RvcFYzEjMKBkhlYWRlchgBIAEoCzIVLnR5cGVzLlJlc291cmNlSGVhZGVyQgzI3h8A0N4fAereHwASNwoEU3BlYxgCIAEoCzIbLnR5cGVzLldpbmRvd3NEZXNrdG9wU3BlY1YzQgzI3h8A6t4fBHNwZWMixAEKFFdpbmRvd3NEZXNrdG9wU3BlY1YzEhYKBEFkZHIYASABKAlCCOreHwRhZGRyEhoKBkRvbWFpbhgCIAEoCUIK6t4fBmRvbWFpbhIbCgZIb3N0SUQYAyABKAlCC+reHwdob3N0X2lkEhkKBU5vbkFEGAQgASgIQgrq3h8Gbm9uX2FkEkAKClNjcmVlblNpemUYBSABKAsyES50eXBlcy5SZXNvbHV0aW9uQhnq3h8Vc2NyZWVuX3NpemUsb21pdGVtcHR5IlYKClJlc29sdXRpb24SIgoFV2lkdGgYASABKA1CE+reHw93aWR0aCxvbWl0ZW1wdHkSJAoGSGVpZ2h0GAIgASgNQhTq3h8QaGVpZ2h0LG9taXRlbXB0eSLSBAoZUmVnaXN0ZXJVc2luZ1Rva2VuUmVxdWVzdBIaCgZIb3N0SUQYASABKAlCCureHwZob3N0SUQSHwoITm9kZU5hbWUYAiABKAlCDereHwlub2RlX25hbWUSJAoEUm9sZRgDIAEoCUIW6t4fBHJvbGX63h8KU3lzdGVtUm9sZRIYCgVUb2tlbhgEIAEoCUIJ6t4fBXRva2VuEjcKFEFkZGl0aW9uYWxQcmluY2lwYWxzGAUgAygJQhnq3h8VYWRkaXRpb25hbF9wcmluY2lwYWxzEh8KCEROU05hbWVzGAYgAygJQg3q3h8JZG5zX25hbWVzEigKDFB1YmxpY1RMU0tleRgHIAEoDEIS6t4fDnB1YmxpY190bHNfa2V5EigKDFB1YmxpY1NTSEtleRgIIAEoDEIS6t4fDnB1YmxpY19zc2hfa2V5EiMKClJlbW90ZUFkZHIYCSABKAlCD+reHwtyZW1vdGVfYWRkchInChNFQzJJZGVudGl0eURvY3VtZW50GAogASgMQgrq3h8GZWMyX2lkEh0KB0lEVG9rZW4YCyABKAlCDOreHwhpZF90b2tlbhJGCgdFeHBpcmVzGAwgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIZ6t4fEWV4cGlyZXMsb21pdGVtcHR5kN8fARIqCg1Cb3RJbnN0YW5jZUlEGA0gASgJQhPq3h8PYm90X2luc3RhbmNlX2lkEikKDUJvdEdlbmVyYXRpb24YDiABKAVCEureHw5ib3RfZ2VuZXJhdGlvbiLdAQoPUmVjb3ZlcnlDb2Rlc1YxEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI2CgRTcGVjGAUgASgLMhoudHlwZXMuUmVjb3ZlcnlDb2Rlc1NwZWNWMUIMyN4fAOreHwRzcGVjIooBChNSZWNvdmVyeUNvZGVzU3BlY1YxEjEKBUNvZGVzGAEgAygLMhMudHlwZXMuUmVjb3ZlcnlDb2RlQg3I3h8A6t4fBWNvZGVzEkAKB0NyZWF0ZWQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhPI3h8A6t4fB2NyZWF0ZWSQ3x8BIlAKDFJlY292ZXJ5Q29kZRIjCgpIYXNoZWRDb2RlGAEgASgMQg/q3h8LaGFzaGVkX2NvZGUSGwoGSXNVc2VkGAIgASgIQgvq3h8HaXNfdXNlZCJTChROdWxsYWJsZVNlc3Npb25TdGF0ZRI7CgVTdGF0ZRgBIAEoDjITLnR5cGVzLlNlc3Npb25TdGF0ZUIXyN4fAereHw9zdGF0ZSxvbWl0ZW1wdHkirgEKFFNlc3Npb25UcmFja2VyRmlsdGVyEiAKBEtpbmQYASABKAlCEureHw5raW5kLG9taXRlbXB0eRJDCgVTdGF0ZRgCIAEoCzIbLnR5cGVzLk51bGxhYmxlU2Vzc2lvblN0YXRlQhfI3h8B6t4fD3N0YXRlLG9taXRlbXB0eRIvCgtEZXNrdG9wTmFtZRgDIAEoCUIa6t4fFmRlc2t0b3BfbmFtZSxvbWl0ZW1wdHkigAEKEFNlc3Npb25UcmFja2VyVjESMwoGSGVhZGVyGAEgASgLMhUudHlwZXMuUmVzb3VyY2VIZWFkZXJCDMjeHwDQ3h8B6t4fABI3CgRTcGVjGAIgASgLMhsudHlwZXMuU2Vzc2lvblRyYWNrZXJTcGVjVjFCDMjeHwDq3h8Ec3BlYyK+CQoUU2Vzc2lvblRyYWNrZXJTcGVjVjESKwoJU2Vzc2lvbklEGAEgASgJQhjq3h8Uc2Vzc2lvbl9pZCxvbWl0ZW1wdHkSIAoES2luZBgCIAEoCUIS6t4fDmtpbmQsb21pdGVtcHR5EjcKBVN0YXRlGAMgASgOMhMudHlwZXMuU2Vzc2lvblN0YXRlQhPq3h8Pc3RhdGUsb21pdGVtcHR5EkoKB0NyZWF0ZWQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEWNyZWF0ZWQsb21pdGVtcHR5kN8fARJKCgdFeHBpcmVzGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIdyN4fAOreHxFleHBpcmVzLG9taXRlbXB0eZDfHwESLAoMQXR0YWNoZWREYXRhGAYgASgJQhbq3h8SYXR0YWNoZWQsb21pdGVtcHR5EiQKBlJlYXNvbhgHIAEoCUIU6t4fEHJlYXNvbixvbWl0ZW1wdHkSJgoHSW52aXRlZBgIIAMoCUIV6t4fEWludml0ZWQsb21pdGVtcHR5Ei8KCEhvc3RuYW1lGAkgASgJQh3q3h8ZdGFyZ2V0X2hvc3RuYW1lLG9taXRlbXB0eRItCgdBZGRyZXNzGAogASgJQhzq3h8YdGFyZ2V0X2FkZHJlc3Msb21pdGVtcHR5Ei8KC0NsdXN0ZXJOYW1lGAsgASgJQhrq3h8WY2x1c3Rlcl9uYW1lLG9taXRlbXB0eRIiCgVMb2dpbhgMIAEoCUIT6t4fD2xvZ2luLG9taXRlbXB0eRJICgxQYXJ0aWNpcGFudHMYDSADKAsyEi50eXBlcy5QYXJ0aWNpcGFudEIeyN4fAOreHxZwYXJ0aWNpcGFudHMsb21pdGVtcHR5EjsKEUt1YmVybmV0ZXNDbHVzdGVyGA4gASgJQiDq3h8ca3ViZXJuZXRlc19jbHVzdGVyLG9taXRlbXB0eRIpCghIb3N0VXNlchgPIAEoCUIX6t4fE2hvc3RfdXNlcixvbWl0ZW1wdHkSTgoMSG9zdFBvbGljaWVzGBAgAygLMh4udHlwZXMuU2Vzc2lvblRyYWNrZXJQb2xpY3lTZXRCGOreHxRob3N0X3JvbGVzLG9taXRlbXB0eRIxCgxEYXRhYmFzZU5hbWUYESABKAlCG+reHxdkYXRhYmFzZV9uYW1lLG9taXRlbXB0eRInCgdBcHBOYW1lGBIgASgJQhbq3h8SYXBwX25hbWUsb21pdGVtcHR5EjIKDEFwcFNlc3Npb25JRBgTIAEoCUIc6t4fGGFwcF9zZXNzaW9uX2lkLG9taXRlbXB0eRIvCgtEZXNrdG9wTmFtZRgUIAEoCUIa6t4fFmRlc2t0b3BfbmFtZSxvbWl0ZW1wdHkSJQoGSG9zdElEGBUgASgJQhXq3h8RaG9zdF9pZCxvbWl0ZW1wdHkSNAoNVGFyZ2V0U3ViS2luZBgWIAEoCUId6t4fGXRhcmdldF9zdWJfa2luZCxvbWl0ZW1wdHkSNQoOSW5pdGlhbENvbW1hbmQYFyADKAlCHereHxlpbml0aWFsX2NvbW1hbmQsb21pdGVtcHR5IsABChdTZXNzaW9uVHJhY2tlclBvbGljeVNldBIgCgROYW1lGAEgASgJQhLq3h8ObmFtZSxvbWl0ZW1wdHkSJgoHVmVyc2lvbhgCIAEoCUIV6t4fEXZlcnNpb24sb21pdGVtcHR5ElsKElJlcXVpcmVTZXNzaW9uSm9pbhgDIAMoCzIbLnR5cGVzLlNlc3Npb25SZXF1aXJlUG9saWN5QiLq3h8ecmVxdWlyZV9zZXNzaW9uX2pvaW4sb21pdGVtcHR5IsIBCgtQYXJ0aWNpcGFudBIcCgJJRBgBIAEoCUIQ6t4fDGlkLG9taXRlbXB0eRIgCgRVc2VyGAIgASgJQhLq3h8OdXNlcixvbWl0ZW1wdHkSIAoETW9kZRgDIAEoCUIS6t4fDm1vZGUsb21pdGVtcHR5ElEKCkxhc3RBY3RpdmUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQiHI3h8A6t4fFWxhc3RfYWN0aXZlLG9taXRlbXB0eZDfHwEidAoKVUlDb25maWdWMRIzCgZIZWFkZXIYASABKAsyFS50eXBlcy5SZXNvdXJjZUhlYWRlckIMyN4fANDeHwHq3h8AEjEKBFNwZWMYBSABKAsyFS50eXBlcy5VSUNvbmZpZ1NwZWNWMUIMyN4fAOreHwRzcGVjIrUBCg5VSUNvbmZpZ1NwZWNWMRItCg9TY3JvbGxiYWNrTGluZXMYASABKAVCFOreHxBzY3JvbGxiYWNrX2xpbmVzEnQKDVNob3dSZXNvdXJjZXMYAiABKAlCXereHxhzaG93X3Jlc291cmNlcyxvbWl0ZW1wdHn63h89Z2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS9jb25zdGFudHMuU2hvd1Jlc291cmNlcyLVAQoLSW5zdGFsbGVyVjESFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJwoHU3ViS2luZBgCIAEoCUIW6t4fEnN1Yl9raW5kLG9taXRlbXB0eRIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjIKBFNwZWMYBSABKAsyFi50eXBlcy5JbnN0YWxsZXJTcGVjVjFCDMjeHwDq3h8Ec3BlYyItCg9JbnN0YWxsZXJTcGVjVjESGgoGU2NyaXB0GAEgASgJQgrq3h8Gc2NyaXB0IjkKD0luc3RhbGxlclYxTGlzdBImCgppbnN0YWxsZXJzGAEgAygLMhIudHlwZXMuSW5zdGFsbGVyVjEiPwoGU29ydEJ5EhsKBklzRGVzYxgBIAEoCEIL6t4fB2lzX2Rlc2MSGAoFRmllbGQYAiABKAlCCereHwVmaWVsZCKMAQoWQ29ubmVjdGlvbkRpYWdub3N0aWNWMRIzCgZIZWFkZXIYASABKAsyFS50eXBlcy5SZXNvdXJjZUhlYWRlckIMyN4fANDeHwHq3h8AEj0KBFNwZWMYBSABKAsyIS50eXBlcy5Db25uZWN0aW9uRGlhZ25vc3RpY1NwZWNWMUIMyN4fAOreHwRzcGVjIpYBChpDb25uZWN0aW9uRGlhZ25vc3RpY1NwZWNWMRIcCgdTdWNjZXNzGAEgASgIQgvq3h8Hc3VjY2VzcxIcCgdNZXNzYWdlGAIgASgJQgvq3h8HbWVzc2FnZRI8CgZUcmFjZXMYAyADKAsyIC50eXBlcy5Db25uZWN0aW9uRGlhZ25vc3RpY1RyYWNlQgrq3h8GdHJhY2VzIqAEChlDb25uZWN0aW9uRGlhZ25vc3RpY1RyYWNlEkIKBFR5cGUYASABKA4yKi50eXBlcy5Db25uZWN0aW9uRGlhZ25vc3RpY1RyYWNlLlRyYWNlVHlwZUII6t4fBHR5cGUSRwoGU3RhdHVzGAIgASgOMisudHlwZXMuQ29ubmVjdGlvbkRpYWdub3N0aWNUcmFjZS5TdGF0dXNUeXBlQgrq3h8Gc3RhdHVzEhwKB0RldGFpbHMYAyABKAlCC+reHwdkZXRhaWxzEhgKBUVycm9yGAQgASgJQgnq3h8FZXJyb3Ii/gEKCVRyYWNlVHlwZRIaChZUUkFDRV9UWVBFX1VOU1BFQ0lGSUVEEAASEQoNVU5LTk9XTl9FUlJPUhABEg0KCVJCQUNfTk9ERRACEhAKDENPTk5FQ1RJVklUWRADEhIKDlJCQUNfUFJJTkNJUEFMEAQSEgoOTk9ERV9QUklOQ0lQQUwQBRINCglSQkFDX0tVQkUQBhISCg5LVUJFX1BSSU5DSVBBTBAHEhEKDVJCQUNfREFUQUJBU0UQCBIXChNSQkFDX0RBVEFCQVNFX0xPR0lOEAkSFAoQREFUQUJBU0VfREJfVVNFUhAKEhQKEERBVEFCQVNFX0RCX05BTUUQCyI9CgpTdGF0dXNUeXBlEhYKElNUQVRVU19VTlNQRUNJRklFRBAAEgsKB1NVQ0NFU1MQARIKCgZGQUlMRUQQAiKCAQoRRGF0YWJhc2VTZXJ2aWNlVjESMwoGSGVhZGVyGAEgASgLMhUudHlwZXMuUmVzb3VyY2VIZWFkZXJCDMjeHwDQ3h8B6t4fABI4CgRTcGVjGAIgASgLMhwudHlwZXMuRGF0YWJhc2VTZXJ2aWNlU3BlY1YxQgzI3h8A6t4fBHNwZWMigAEKFURhdGFiYXNlU2VydmljZVNwZWNWMRJHChBSZXNvdXJjZU1hdGNoZXJzGAEgAygLMh4udHlwZXMuRGF0YWJhc2VSZXNvdXJjZU1hdGNoZXJCDereHwlyZXNvdXJjZXMSHgoISG9zdG5hbWUYAiABKAlCDOreHwhob3N0bmFtZSKLAQoXRGF0YWJhc2VSZXNvdXJjZU1hdGNoZXISOwoGTGFiZWxzGAEgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCFNreHwZMYWJlbHPq3h8GbGFiZWxzEjMKA0FXUxgCIAEoCzIZLnR5cGVzLlJlc291cmNlTWF0Y2hlckFXU0ILyN4fAOreHwNhd3MieQoSUmVzb3VyY2VNYXRjaGVyQVdTEjQKDUFzc3VtZVJvbGVBUk4YASABKAlCHereHxlhc3N1bWVfcm9sZV9hcm4sb21pdGVtcHR5Ei0KCkV4dGVybmFsSUQYAiABKAlCGereHxVleHRlcm5hbF9pZCxvbWl0ZW1wdHkieAoMQ2x1c3RlckFsZXJ0EjMKBkhlYWRlchgBIAEoCzIVLnR5cGVzLlJlc291cmNlSGVhZGVyQgzI3h8A0N4fAereHwASMwoEU3BlYxgCIAEoCzIXLnR5cGVzLkNsdXN0ZXJBbGVydFNwZWNCDMjeHwDq3h8Ec3BlYyKyAQoQQ2x1c3RlckFsZXJ0U3BlYxI0CghTZXZlcml0eRgBIAEoDjIULnR5cGVzLkFsZXJ0U2V2ZXJpdHlCDOreHwhzZXZlcml0eRIcCgdNZXNzYWdlGAIgASgJQgvq3h8HbWVzc2FnZRJKCgdDcmVhdGVkGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIdyN4fAOreHxFjcmVhdGVkLG9taXRlbXB0eZDfHwEihwIKF0dldENsdXN0ZXJBbGVydHNSZXF1ZXN0EiYKCFNldmVyaXR5GAEgASgOMhQudHlwZXMuQWxlcnRTZXZlcml0eRIPCgdBbGVydElEGAIgASgJEjoKBkxhYmVscxgDIAMoCzIqLnR5cGVzLkdldENsdXN0ZXJBbGVydHNSZXF1ZXN0LkxhYmVsc0VudHJ5EhYKDldpdGhTdXBlcnNlZGVkGAQgASgIEhgKEFdpdGhBY2tub3dsZWRnZWQYBSABKAgSFgoOV2l0aFVudGFyZ2V0ZWQYBiABKAgaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASLBAQoUQWxlcnRBY2tub3dsZWRnZW1lbnQSJwoHQWxlcnRJRBgBIAEoCUIW6t4fEmFsZXJ0X2lkLG9taXRlbXB0eRIkCgZSZWFzb24YAiABKAlCFOreHxByZWFzb24sb21pdGVtcHR5EkoKB0V4cGlyZXMYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQh3I3h8A6t4fEWV4cGlyZXMsb21pdGVtcHR5kN8fAUoECAMQBFIIU2V2ZXJpdHkizQEKB1JlbGVhc2USHQoHTm90ZXNNRBgBIAEoCUIM6t4fCG5vdGVzX21kEhwKB1Byb2R1Y3QYAiABKAlCC+reHwdwcm9kdWN0EiEKCVJlbGVhc2VJRBgDIAEoCUIO6t4fCnJlbGVhc2VfaWQSGgoGU3RhdHVzGAQgASgJQgrq3h8Gc3RhdHVzEhwKB1ZlcnNpb24YBSABKAlCC+reHwd2ZXJzaW9uEigKBkFzc2V0cxgGIAMoCzIMLnR5cGVzLkFzc2V0Qgrq3h8GYXNzZXRzIp8CCgVBc3NldBIWCgRBcmNoGAEgASgJQgjq3h8EYXJjaBIkCgtEZXNjcmlwdGlvbhgCIAEoCUIP6t4fC2Rlc2NyaXB0aW9uEhYKBE5hbWUYAyABKAlCCOreHwRuYW1lEhIKAk9TGAQgASgJQgbq3h8Cb3MSGgoGU0hBMjU2GAUgASgJQgrq3h8Gc2hhMjU2EiEKCUFzc2V0U2l6ZRgGIAEoA0IO6t4fCmFzc2V0X3NpemUSJQoLRGlzcGxheVNpemUYByABKAlCEOreHwxkaXNwbGF5X3NpemUSIwoKUmVsZWFzZUlEcxgIIAMoCUIP6t4fC3JlbGVhc2VfaWRzEiEKCVB1YmxpY1VSTBgJIAEoCUIO6t4fCnB1YmxpY191cmwi6wEKCFBsdWdpblYxEgwKBGtpbmQYASABKAkSEAoIc3ViX2tpbmQYAiABKAkSDwoHdmVyc2lvbhgDIAEoCRInCghtZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQgTI3h8AEicKBHNwZWMYBSABKAsyEy50eXBlcy5QbHVnaW5TcGVjVjFCBMjeHwASKwoGc3RhdHVzGAYgASgLMhUudHlwZXMuUGx1Z2luU3RhdHVzVjFCBMjeHwASLwoLY3JlZGVudGlhbHMYByABKAsyGi50eXBlcy5QbHVnaW5DcmVkZW50aWFsc1YxIvYFCgxQbHVnaW5TcGVjVjESPwoTc2xhY2tfYWNjZXNzX3BsdWdpbhgBIAEoCzIgLnR5cGVzLlBsdWdpblNsYWNrQWNjZXNzU2V0dGluZ3NIABI3CghvcHNnZW5pZRgCIAEoCzIjLnR5cGVzLlBsdWdpbk9wc2dlbmllQWNjZXNzU2V0dGluZ3NIABItCgZvcGVuYWkYAyABKAsyGy50eXBlcy5QbHVnaW5PcGVuQUlTZXR0aW5nc0gAEikKBG9rdGEYBCABKAsyGS50eXBlcy5QbHVnaW5Pa3RhU2V0dGluZ3NIABIpCgRqYW1mGAUgASgLMhkudHlwZXMuUGx1Z2luSmFtZlNldHRpbmdzSAASNAoKcGFnZXJfZHV0eRgGIAEoCzIeLnR5cGVzLlBsdWdpblBhZ2VyRHV0eVNldHRpbmdzSAASNQoKbWF0dGVybW9zdBgHIAEoCzIfLnR5cGVzLlBsdWdpbk1hdHRlcm1vc3RTZXR0aW5nc0gAEikKBGppcmEYCCABKAsyGS50eXBlcy5QbHVnaW5KaXJhU2V0dGluZ3NIABIvCgdkaXNjb3JkGAkgASgLMhwudHlwZXMuUGx1Z2luRGlzY29yZFNldHRpbmdzSAASNQoKc2VydmljZU5vdxgKIAEoCzIfLnR5cGVzLlBsdWdpblNlcnZpY2VOb3dTZXR0aW5nc0gAEi0KBmdpdGxhYhgMIAEoCzIbLnR5cGVzLlBsdWdpbkdpdGxhYlNldHRpbmdzSAASMAoIZW50cmFfaWQYDSABKAsyHC50eXBlcy5QbHVnaW5FbnRyYUlEU2V0dGluZ3NIABIpCgRzY2ltGA4gASgLMhkudHlwZXMuUGx1Z2luU0NJTVNldHRpbmdzSAASNQoHZGF0YWRvZxgPIAEoCzIiLnR5cGVzLlBsdWdpbkRhdGFkb2dBY2Nlc3NTZXR0aW5nc0gAEhIKCmdlbmVyYXRpb24YCyABKAk6BOigHwFCCgoIc2V0dGluZ3MiOwoZUGx1Z2luU2xhY2tBY2Nlc3NTZXR0aW5ncxIYChBmYWxsYmFja19jaGFubmVsGAEgASgJOgTooB8BIjIKFFBsdWdpbkdpdGxhYlNldHRpbmdzEhQKDGFwaV9lbmRwb2ludBgBIAEoCToE6KAfASKHAQocUGx1Z2luT3BzZ2VuaWVBY2Nlc3NTZXR0aW5ncxIQCghwcmlvcml0eRgCIAEoCRISCgphbGVydF90YWdzGAMgAygJEhkKEWRlZmF1bHRfc2NoZWR1bGVzGAQgAygJEhQKDGFwaV9lbmRwb2ludBgFIAEoCToE6KAfAUoECAEQAlIEYWRkciLUAQoYUGx1Z2luU2VydmljZU5vd1NldHRpbmdzEjAKDGFwaV9lbmRwb2ludBgBIAEoCUIa6t4fFmFwaV9lbmRwb2ludCxvbWl0ZW1wdHkSKAoIdXNlcm5hbWUYAiABKAlCFureHxJ1c2VybmFtZSxvbWl0ZW1wdHkSKAoIcGFzc3dvcmQYAyABKAlCFureHxJwYXNzd29yZCxvbWl0ZW1wdHkSLAoKY2xvc2VfY29kZRgEIAEoCUIY6t4fFGNsb3NlX2NvZGUsb21pdGVtcHR5OgTooB8BIkkKF1BsdWdpblBhZ2VyRHV0eVNldHRpbmdzEhIKCnVzZXJfZW1haWwYASABKAkSFAoMYXBpX2VuZHBvaW50GAIgASgJOgTooB8BIlcKElBsdWdpbkppcmFTZXR0aW5ncxISCgpzZXJ2ZXJfdXJsGAEgASgJEhMKC3Byb2plY3Rfa2V5GAIgASgJEhIKCmlzc3VlX3R5cGUYAyABKAk6BOigHwEiHAoUUGx1Z2luT3BlbkFJU2V0dGluZ3M6BOigHwEibAoYUGx1Z2luTWF0dGVybW9zdFNldHRpbmdzEhIKCnNlcnZlcl91cmwYASABKAkSDAoEdGVhbRgCIAEoCRIPCgdjaGFubmVsGAMgASgJEhcKD3JlcG9ydF90b19lbWFpbBgEIAEoCToE6KAfASJAChJQbHVnaW5KYW1mU2V0dGluZ3MSJAoJamFtZl9zcGVjGAEgASgLMhEudHlwZXMuSmFtZlNwZWNWMToE6KAfASKVAQoSUGx1Z2luT2t0YVNldHRpbmdzEg8KB29yZ191cmwYASABKAkSGAoQZW5hYmxlX3VzZXJfc3luYxgCIAEoCBIYChBzc29fY29ubmVjdG9yX2lkGAMgASgJEjQKDXN5bmNfc2V0dGluZ3MYBCABKAsyHS50eXBlcy5QbHVnaW5Pa3RhU3luY1NldHRpbmdzOgTooB8BIu4BChZQbHVnaW5Pa3RhU3luY1NldHRpbmdzEhIKCnN5bmNfdXNlcnMYASABKAgSGAoQc3NvX2Nvbm5lY3Rvcl9pZBgCIAEoCRIZChFzeW5jX2FjY2Vzc19saXN0cxgDIAEoCBIWCg5kZWZhdWx0X293bmVycxgEIAMoCRIOCgZhcHBfaWQYBSABKAkSFQoNZ3JvdXBfZmlsdGVycxgGIAMoCRITCgthcHBfZmlsdGVycxgHIAMoCRIQCghhcHBfbmFtZRgIIAEoCRIfChdkaXNhYmxlX3N5bmNfYXBwX2dyb3VwcxgJIAEoCDoE6KAfASIsCg9EaXNjb3JkQ2hhbm5lbHMSEwoLY2hhbm5lbF9pZHMYASADKAk6BOigHwEivgEKFVBsdWdpbkRpc2NvcmRTZXR0aW5ncxJOChJyb2xlX3RvX3JlY2lwaWVudHMYASADKAsyMi50eXBlcy5QbHVnaW5EaXNjb3JkU2V0dGluZ3MuUm9sZVRvUmVjaXBpZW50c0VudHJ5Gk8KFVJvbGVUb1JlY2lwaWVudHNFbnRyeRILCgNrZXkYASABKAkSJQoFdmFsdWUYAiABKAsyFi50eXBlcy5EaXNjb3JkQ2hhbm5lbHM6AjgBOgTooB8BIp4BChVQbHVnaW5FbnRyYUlEU2V0dGluZ3MSNwoNc3luY19zZXR0aW5ncxgBIAEoCzIgLnR5cGVzLlBsdWdpbkVudHJhSURTeW5jU2V0dGluZ3MSRgoVYWNjZXNzX2dyYXBoX3NldHRpbmdzGAIgASgLMicudHlwZXMuUGx1Z2luRW50cmFJREFjY2Vzc0dyYXBoU2V0dGluZ3M6BOigHwEiUwoZUGx1Z2luRW50cmFJRFN5bmNTZXR0aW5ncxIWCg5kZWZhdWx0X293bmVycxgBIAMoCRIYChBzc29fY29ubmVjdG9yX2lkGAIgASgJOgTooB8BImwKIFBsdWdpbkVudHJhSURBY2Nlc3NHcmFwaFNldHRpbmdzEkIKFmFwcF9zc29fc2V0dGluZ3NfY2FjaGUYASADKAsyIi50eXBlcy5QbHVnaW5FbnRyYUlEQXBwU1NPU2V0dGluZ3M6BOigHwEiTQobUGx1Z2luRW50cmFJREFwcFNTT1NldHRpbmdzEg4KBmFwcF9pZBgBIAEoCRIYChBmZWRlcmF0ZWRfc3NvX3YyGAIgASgMOgTooB8BIk0KElBsdWdpblNDSU1TZXR0aW5ncxIbChNzYW1sX2Nvbm5lY3Rvcl9uYW1lGAEgASgJEhQKDGRlZmF1bHRfcm9sZRgCIAEoCToE6KAfASJVChtQbHVnaW5EYXRhZG9nQWNjZXNzU2V0dGluZ3MSFAoMYXBpX2VuZHBvaW50GAEgASgJEhoKEmZhbGxiYWNrX3JlY2lwaWVudBgCIAEoCToE6KAfASL2AQocUGx1Z2luQm9vdHN0cmFwQ3JlZGVudGlhbHNWMRJUChlvYXV0aDJfYXV0aG9yaXphdGlvbl9jb2RlGAEgASgLMi8udHlwZXMuUGx1Z2luT0F1dGgyQXV0aG9yaXphdGlvbkNvZGVDcmVkZW50aWFsc0gAEjsKDGJlYXJlcl90b2tlbhgCIAEoCzIjLnR5cGVzLlBsdWdpbkJlYXJlclRva2VuQ3JlZGVudGlhbHNIABI0CglpZF9zZWNyZXQYAyABKAsyHy50eXBlcy5QbHVnaW5JZFNlY3JldENyZWRlbnRpYWxIAEINCgtjcmVkZW50aWFscyI2ChhQbHVnaW5JZFNlY3JldENyZWRlbnRpYWwSCgoCaWQYASABKAkSDgoGc2VjcmV0GAIgASgJIlwKKFBsdWdpbk9BdXRoMkF1dGhvcml6YXRpb25Db2RlQ3JlZGVudGlhbHMSGgoSYXV0aG9yaXphdGlvbl9jb2RlGAEgASgJEhQKDHJlZGlyZWN0X3VyaRgCIAEoCSK7AgoOUGx1Z2luU3RhdHVzVjESJQoEY29kZRgBIAEoDjIXLnR5cGVzLlBsdWdpblN0YXR1c0NvZGUSFQoNZXJyb3JfbWVzc2FnZRgCIAEoCRI8Cg5sYXN0X3N5bmNfdGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCCMjeHwCQ3x8BEi0KBmdpdGxhYhgEIAEoCzIbLnR5cGVzLlBsdWdpbkdpdGxhYlN0YXR1c1YxSAASMAoIZW50cmFfaWQYBSABKAsyHC50eXBlcy5QbHVnaW5FbnRyYUlEU3RhdHVzVjFIABIpCgRva3RhGAcgASgLMhkudHlwZXMuUGx1Z2luT2t0YVN0YXR1c1YxSAASFgoObGFzdF9yYXdfZXJyb3IYBiABKAlCCQoHZGV0YWlscyJiChRQbHVnaW5HaXRsYWJTdGF0dXNWMRIWCg5pbXBvcnRlZF91c2VycxgBIAEoDRIXCg9pbXBvcnRlZF9ncm91cHMYAiABKA0SGQoRaW1wb3J0ZWRfcHJvamVjdHMYAyABKA0iSAoVUGx1Z2luRW50cmFJRFN0YXR1c1YxEhYKDmltcG9ydGVkX3VzZXJzGAEgASgNEhcKD2ltcG9ydGVkX2dyb3VwcxgCIAEoDSLpAgoSUGx1Z2luT2t0YVN0YXR1c1YxEjYKC3Nzb19kZXRhaWxzGAEgASgLMiEudHlwZXMuUGx1Z2luT2t0YVN0YXR1c0RldGFpbHNTU08SSgoWYXBwX2dyb3VwX3N5bmNfZGV0YWlscxgCIAEoCzIqLnR5cGVzLlBsdWdpbk9rdGFTdGF0dXNEZXRhaWxzQXBwR3JvdXBTeW5jEkMKEnVzZXJzX3N5bmNfZGV0YWlscxgDIAEoCzInLnR5cGVzLlBsdWdpbk9rdGFTdGF0dXNEZXRhaWxzVXNlcnNTeW5jEjgKDHNjaW1fZGV0YWlscxgEIAEoCzIiLnR5cGVzLlBsdWdpbk9rdGFTdGF0dXNEZXRhaWxzU0NJTRJQChlhY2Nlc3NfbGlzdHNfc3luY19kZXRhaWxzGAUgASgLMi0udHlwZXMuUGx1Z2luT2t0YVN0YXR1c0RldGFpbHNBY2Nlc3NMaXN0c1N5bmMiTwoaUGx1Z2luT2t0YVN0YXR1c0RldGFpbHNTU08SDwoHZW5hYmxlZBgBIAEoCBIOCgZhcHBfaWQYAiABKAkSEAoIYXBwX25hbWUYAyABKAkiywIKI1BsdWdpbk9rdGFTdGF0dXNEZXRhaWxzQXBwR3JvdXBTeW5jEg8KB2VuYWJsZWQYASABKAgSNAoLc3RhdHVzX2NvZGUYAiABKA4yHy50eXBlcy5Pa3RhUGx1Z2luU3luY1N0YXR1c0NvZGUSUAoPbGFzdF9zdWNjZXNzZnVsGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIbyN4fAereHw9sYXN0X3N1Y2Nlc3NmdWyQ3x8BEkgKC2xhc3RfZmFpbGVkGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIXyN4fAereHwtsYXN0X2ZhaWxlZJDfHwESFwoPbnVtX2FwcHNfc3luY2VkGAUgASgFEhkKEW51bV9ncm91cHNfc3luY2VkGAYgASgFEg0KBWVycm9yGAcgASgJIq4CCiBQbHVnaW5Pa3RhU3RhdHVzRGV0YWlsc1VzZXJzU3luYxIPCgdlbmFibGVkGAEgASgIEjQKC3N0YXR1c19jb2RlGAIgASgOMh8udHlwZXMuT2t0YVBsdWdpblN5bmNTdGF0dXNDb2RlElAKD2xhc3Rfc3VjY2Vzc2Z1bBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCG8jeHwHq3h8PbGFzdF9zdWNjZXNzZnVskN8fARJICgtsYXN0X2ZhaWxlZBgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCF8jeHwHq3h8LbGFzdF9mYWlsZWSQ3x8BEhgKEG51bV91c2Vyc19zeW5jZWQYBSABKAUSDQoFZXJyb3IYBiABKAkiLgobUGx1Z2luT2t0YVN0YXR1c0RldGFpbHNTQ0lNEg8KB2VuYWJsZWQYASABKAgi+gIKJlBsdWdpbk9rdGFTdGF0dXNEZXRhaWxzQWNjZXNzTGlzdHNTeW5jEg8KB2VuYWJsZWQYASABKAgSNAoLc3RhdHVzX2NvZGUYAiABKA4yHy50eXBlcy5Pa3RhUGx1Z2luU3luY1N0YXR1c0NvZGUSUAoPbGFzdF9zdWNjZXNzZnVsGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIbyN4fAereHw9sYXN0X3N1Y2Nlc3NmdWyQ3x8BEkgKC2xhc3RfZmFpbGVkGAQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIXyN4fAereHwtsYXN0X2ZhaWxlZJDfHwESEwoLYXBwX2ZpbHRlcnMYBSADKAkSFwoPbnVtX2FwcHNfc3luY2VkGAYgASgFEhUKDWdyb3VwX2ZpbHRlcnMYByADKAkSGQoRbnVtX2dyb3Vwc19zeW5jZWQYCCABKAUSDQoFZXJyb3IYCSABKAkipgIKE1BsdWdpbkNyZWRlbnRpYWxzVjESSAoTb2F1dGgyX2FjY2Vzc190b2tlbhgBIAEoCzIpLnR5cGVzLlBsdWdpbk9BdXRoMkFjY2Vzc1Rva2VuQ3JlZGVudGlhbHNIABI7CgxiZWFyZXJfdG9rZW4YAiABKAsyIy50eXBlcy5QbHVnaW5CZWFyZXJUb2tlbkNyZWRlbnRpYWxzSAASNAoJaWRfc2VjcmV0GAMgASgLMh8udHlwZXMuUGx1Z2luSWRTZWNyZXRDcmVkZW50aWFsSAASQwoWc3RhdGljX2NyZWRlbnRpYWxzX3JlZhgEIAEoCzIhLnR5cGVzLlBsdWdpblN0YXRpY0NyZWRlbnRpYWxzUmVmSABCDQoLY3JlZGVudGlhbHMiiAEKIlBsdWdpbk9BdXRoMkFjY2Vzc1Rva2VuQ3JlZGVudGlhbHMSFAoMYWNjZXNzX3Rva2VuGAEgASgJEhUKDXJlZnJlc2hfdG9rZW4YAiABKAkSNQoHZXhwaXJlcxgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCCMjeHwCQ3x8BIj8KHFBsdWdpbkJlYXJlclRva2VuQ3JlZGVudGlhbHMSDQoFdG9rZW4YASABKAlKBAgCEANSCnRva2VuX2ZpbGUioAEKGlBsdWdpblN0YXRpY0NyZWRlbnRpYWxzUmVmElMKBkxhYmVscxgBIAMoCzItLnR5cGVzLlBsdWdpblN0YXRpY0NyZWRlbnRpYWxzUmVmLkxhYmVsc0VudHJ5QhTq3h8QbGFiZWxzLG9taXRlbXB0eRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIjAKDFBsdWdpbkxpc3RWMRIgCgdwbHVnaW5zGAEgAygLMg8udHlwZXMuUGx1Z2luVjEiigEKGVBsdWdpblN0YXRpY0NyZWRlbnRpYWxzVjESLwoGSGVhZGVyGAEgASgLMhUudHlwZXMuUmVzb3VyY2VIZWFkZXJCCMjeHwDQ3h8BEjIKBFNwZWMYAiABKAsyJC50eXBlcy5QbHVnaW5TdGF0aWNDcmVkZW50aWFsc1NwZWNWMToImKAfAIDcIAAizgEKHVBsdWdpblN0YXRpY0NyZWRlbnRpYWxzU3BlY1YxEhIKCEFQSVRva2VuGAEgASgJSAASPAoJQmFzaWNBdXRoGAIgASgLMicudHlwZXMuUGx1Z2luU3RhdGljQ3JlZGVudGlhbHNCYXNpY0F1dGhIABJMChFPQXV0aENsaWVudFNlY3JldBgDIAEoCzIvLnR5cGVzLlBsdWdpblN0YXRpY0NyZWRlbnRpYWxzT0F1dGhDbGllbnRTZWNyZXRIAEINCgtjcmVkZW50aWFscyJiCiBQbHVnaW5TdGF0aWNDcmVkZW50aWFsc0Jhc2ljQXV0aBIeCghVc2VybmFtZRgBIAEoCUIM6t4fCHVzZXJuYW1lEh4KCFBhc3N3b3JkGAIgASgJQgzq3h8IcGFzc3dvcmQidAooUGx1Z2luU3RhdGljQ3JlZGVudGlhbHNPQXV0aENsaWVudFNlY3JldBIfCghDbGllbnRJZBgBIAEoCUIN6t4fCWNsaWVudF9pZBInCgxDbGllbnRTZWNyZXQYAiABKAlCEereHw1jbGllbnRfc2VjcmV0IpoBChhTQU1MSWRQU2VydmljZVByb3ZpZGVyVjESMwoGSGVhZGVyGAEgASgLMhUudHlwZXMuUmVzb3VyY2VIZWFkZXJCDMjeHwDQ3h8B6t4fABI/CgRTcGVjGAIgASgLMiMudHlwZXMuU0FNTElkUFNlcnZpY2VQcm92aWRlclNwZWNWMUIMyN4fAOreHwRzcGVjOgiYoB8AgNwgACLBAgocU0FNTElkUFNlcnZpY2VQcm92aWRlclNwZWNWMRIvChBFbnRpdHlEZXNjcmlwdG9yGAEgASgJQhXq3h8RZW50aXR5X2Rlc2NyaXB0b3ISHwoIRW50aXR5SUQYAiABKAlCDereHwllbnRpdHlfaWQSGwoGQUNTVVJMGAMgASgJQgvq3h8HYWNzX3VybBJMChBBdHRyaWJ1dGVNYXBwaW5nGAQgAygLMhsudHlwZXMuU0FNTEF0dHJpYnV0ZU1hcHBpbmdCFereHxFhdHRyaWJ1dGVfbWFwcGluZxIaCgZQcmVzZXQYBSABKAlCCureHwZwcmVzZXQSIwoKUmVsYXlTdGF0ZRgGIAEoCUIP6t4fC3JlbGF5X3N0YXRlEiMKCkxhdW5jaFVSTHMYByADKAlCD+reHwtsYXVuY2hfdXJscyJuChRTQU1MQXR0cmlidXRlTWFwcGluZxIWCgRuYW1lGAEgASgJQgjq3h8EbmFtZRIkCgtuYW1lX2Zvcm1hdBgCIAEoCUIP6t4fC25hbWVfZm9ybWF0EhgKBXZhbHVlGAMgASgJQgnq3h8FdmFsdWUiOwoKSWRQT3B0aW9ucxItCgRTQU1MGAEgASgLMhUudHlwZXMuSWRQU0FNTE9wdGlvbnNCCOreHwRzYW1sIk4KDklkUFNBTUxPcHRpb25zEjwKB0VuYWJsZWQYASABKAsyEC50eXBlcy5Cb29sVmFsdWVCGdreHwpCb29sT3B0aW9u6t4fB2VuYWJsZWQi5wEKFEt1YmVybmV0ZXNSZXNvdXJjZVYxEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI7CgRTcGVjGAUgASgLMh8udHlwZXMuS3ViZXJuZXRlc1Jlc291cmNlU3BlY1YxQgzI3h8A6t4fBHNwZWMiPAoYS3ViZXJuZXRlc1Jlc291cmNlU3BlY1YxEiAKCU5hbWVzcGFjZRgBIAEoCUIN6t4fCW5hbWVzcGFjZSK4AQoaQ2x1c3Rlck1haW50ZW5hbmNlQ29uZmlnVjESMwoGSGVhZGVyGAEgASgLMhUudHlwZXMuUmVzb3VyY2VIZWFkZXJCDMjeHwDQ3h8B6t4fABJBCgRTcGVjGAIgASgLMiUudHlwZXMuQ2x1c3Rlck1haW50ZW5hbmNlQ29uZmlnU3BlY1YxQgzI3h8A6t4fBHNwZWMSIgoFTm9uY2UYAyABKARCE+reHw9ub25jZSxvbWl0ZW1wdHkicAoeQ2x1c3Rlck1haW50ZW5hbmNlQ29uZmlnU3BlY1YxEk4KDUFnZW50VXBncmFkZXMYASABKAsyGS50eXBlcy5BZ2VudFVwZ3JhZGVXaW5kb3dCHOreHxhhZ2VudF91cGdyYWRlcyxvbWl0ZW1wdHkiaAoSQWdlbnRVcGdyYWRlV2luZG93EigKDFVUQ1N0YXJ0SG91chgBIAEoDUIS6t4fDnV0Y19zdGFydF9ob3VyEigKCFdlZWtkYXlzGAIgAygJQhbq3h8Sd2Vla2RheXMsb21pdGVtcHR5IpcBChtTY2hlZHVsZWRBZ2VudFVwZ3JhZGVXaW5kb3cSPAoFU3RhcnQYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQhHI3h8A6t4fBXN0YXJ0kN8fARI6CgRTdG9wGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEIQyN4fAOreHwRzdG9wkN8fASJcChRBZ2VudFVwZ3JhZGVTY2hlZHVsZRJECgdXaW5kb3dzGAEgAygLMiIudHlwZXMuU2NoZWR1bGVkQWdlbnRVcGdyYWRlV2luZG93Qg/I3h8A6t4fB3dpbmRvd3MigAEKC1VzZXJHcm91cFYxEjMKBkhlYWRlchgBIAEoCzIVLnR5cGVzLlJlc291cmNlSGVhZGVyQgzI3h8A0N4fAereHwASMgoEU3BlYxgCIAEoCzIWLnR5cGVzLlVzZXJHcm91cFNwZWNWMUIMyN4fAOreHwRzcGVjOgiYoB8AgNwgACInCg9Vc2VyR3JvdXBTcGVjVjESFAoMQXBwbGljYXRpb25zGAEgAygJInYKFE9rdGFJbXBvcnRSdWxlU3BlY1YxEh4KCFByaW9yaXR5GAEgASgFQgzq3h8IcHJpb3JpdHkSPgoITWFwcGluZ3MYAiADKAsyHi50eXBlcy5Pa3RhSW1wb3J0UnVsZU1hcHBpbmdWMUIM6t4fCG1hcHBpbmdzItUBChdPa3RhSW1wb3J0UnVsZU1hcHBpbmdWMRI2CgVNYXRjaBgBIAMoCzIcLnR5cGVzLk9rdGFJbXBvcnRSdWxlTWF0Y2hWMUIJ6t4fBW1hdGNoElAKCUFkZExhYmVscxgCIAMoCzItLnR5cGVzLk9rdGFJbXBvcnRSdWxlTWFwcGluZ1YxLkFkZExhYmVsc0VudHJ5Qg7q3h8KYWRkX2xhYmVscxowCg5BZGRMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIooBChBPa3RhSW1wb3J0UnVsZVYxEjMKBkhlYWRlchgBIAEoCzIVLnR5cGVzLlJlc291cmNlSGVhZGVyQgzI3h8A0N4fAereHwASNwoEU3BlYxgCIAEoCzIbLnR5cGVzLk9rdGFJbXBvcnRSdWxlU3BlY1YxQgzI3h8A6t4fBHNwZWM6CJigHwCA3CAAIt0BChVPa3RhSW1wb3J0UnVsZU1hdGNoVjESJQoGQXBwSURzGAEgAygJQhXq3h8RYXBwX2lkcyxvbWl0ZW1wdHkSKQoIR3JvdXBJRHMYAiADKAlCF+reHxNncm91cF9pZHMsb21pdGVtcHR5EjYKDkFwcE5hbWVSZWdleGVzGAMgAygJQh7q3h8aYXBwX25hbWVfcmVnZXhlcyxvbWl0ZW1wdHkSOgoQR3JvdXBOYW1lUmVnZXhlcxgEIAMoCUIg6t4fHGdyb3VwX25hbWVfcmVnZXhlcyxvbWl0ZW1wdHkiigEKEE9rdGFBc3NpZ25tZW50VjESMwoGSGVhZGVyGAEgASgLMhUudHlwZXMuUmVzb3VyY2VIZWFkZXJCDMjeHwDQ3h8B6t4fABI3CgRTcGVjGAIgASgLMhsudHlwZXMuT2t0YUFzc2lnbm1lbnRTcGVjVjFCDMjeHwDq3h8Ec3BlYzoImKAfAIDcIAAi1QMKFE9rdGFBc3NpZ25tZW50U3BlY1YxEhYKBFVzZXIYASABKAlCCOreHwR1c2VyEjsKB1RhcmdldHMYAiADKAsyHS50eXBlcy5Pa3RhQXNzaWdubWVudFRhcmdldFYxQgvq3h8HdGFyZ2V0cxJJCgtDbGVhbnVwVGltZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCGMjeHwDq3h8MY2xlYW51cF90aW1lkN8fARJMCgZzdGF0dXMYBCABKA4yMC50eXBlcy5Pa3RhQXNzaWdubWVudFNwZWNWMS5Pa3RhQXNzaWdubWVudFN0YXR1c0IK6t4fBnN0YXR1cxJPCg5MYXN0VHJhbnNpdGlvbhgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCG8jeHwDq3h8PbGFzdF90cmFuc2l0aW9ukN8fARIgCglGaW5hbGl6ZWQYBiABKAhCDereHwlmaW5hbGl6ZWQiXAoUT2t0YUFzc2lnbm1lbnRTdGF0dXMSCwoHVU5LTk9XThAAEgsKB1BFTkRJTkcQARIOCgpQUk9DRVNTSU5HEAISDgoKU1VDQ0VTU0ZVTBADEgoKBkZBSUxFRBAEIsEBChZPa3RhQXNzaWdubWVudFRhcmdldFYxEk4KBHR5cGUYASABKA4yNi50eXBlcy5Pa3RhQXNzaWdubWVudFRhcmdldFYxLk9rdGFBc3NpZ25tZW50VGFyZ2V0VHlwZUII6t4fBHR5cGUSEgoCaWQYAiABKAlCBureHwJpZCJDChhPa3RhQXNzaWdubWVudFRhcmdldFR5cGUSCwoHVU5LTk9XThAAEg8KC0FQUExJQ0FUSU9OEAESCQoFR1JPVVAQAiKEAQoNSW50ZWdyYXRpb25WMRIzCgZIZWFkZXIYASABKAsyFS50eXBlcy5SZXNvdXJjZUhlYWRlckIMyN4fANDeHwHq3h8AEjQKBFNwZWMYAiABKAsyGC50eXBlcy5JbnRlZ3JhdGlvblNwZWNWMUIMyN4fAOreHwRzcGVjOgiYoB8AgNwgACLAAQoRSW50ZWdyYXRpb25TcGVjVjESSgoHQVdTT0lEQxgBIAEoCzIfLnR5cGVzLkFXU09JRENJbnRlZ3JhdGlvblNwZWNWMUIW6t4fEmF3c19vaWRjLG9taXRlbXB0eUgAElAKCUF6dXJlT0lEQxgCIAEoCzIhLnR5cGVzLkF6dXJlT0lEQ0ludGVncmF0aW9uU3BlY1YxQhjq3h8UYXp1cmVfb2lkYyxvbWl0ZW1wdHlIAEINCgtTdWJLaW5kU3BlYyJ3ChhBV1NPSURDSW50ZWdyYXRpb25TcGVjVjESJwoHUm9sZUFSThgBIAEoCUIW6t4fEnJvbGVfYXJuLG9taXRlbXB0eRIyCgtJc3N1ZXJTM1VSSRgCIAEoCUIdGAHq3h8XaXNzdWVyX3MzX3VyaSxvbWl0ZW1wdHkicgoaQXp1cmVPSURDSW50ZWdyYXRpb25TcGVjVjESKQoIVGVuYW50SUQYASABKAlCF+reHxN0ZW5hbnRfaWQsb21pdGVtcHR5EikKCENsaWVudElEGAIgASgJQhfq3h8TY2xpZW50X2lkLG9taXRlbXB0eSKTAgoWSGVhZGxlc3NBdXRoZW50aWNhdGlvbhIvCgZoZWFkZXIYASABKAsyFS50eXBlcy5SZXNvdXJjZUhlYWRlckIIyN4fANDeHwESDAoEdXNlchgCIAEoCRIWCgpwdWJsaWNfa2V5GAMgASgMQgIYARIxCgVzdGF0ZRgEIAEoDjIiLnR5cGVzLkhlYWRsZXNzQXV0aGVudGljYXRpb25TdGF0ZRIkCgptZmFfZGV2aWNlGAUgASgLMhAudHlwZXMuTUZBRGV2aWNlEhkKEWNsaWVudF9pcF9hZGRyZXNzGAYgASgJEhYKDnNzaF9wdWJsaWNfa2V5GAcgASgMEhYKDnRsc19wdWJsaWNfa2V5GAggASgMIqYCCglXYXRjaEtpbmQSFgoES2luZBgBIAEoCUII6t4fBGtpbmQSJQoLTG9hZFNlY3JldHMYAiABKAhCEOreHwxsb2FkX3NlY3JldHMSFgoETmFtZRgDIAEoCUII6t4fBG5hbWUSQgoGRmlsdGVyGAQgAygLMhwudHlwZXMuV2F0Y2hLaW5kLkZpbHRlckVudHJ5QhTq3h8QZmlsdGVyLG9taXRlbXB0eRInCgdTdWJLaW5kGAUgASgJQhbq3h8Sc3ViX2tpbmQsb21pdGVtcHR5EiYKB1ZlcnNpb24YBiABKAlCFereHxF2ZXJzaW9uLG9taXRlbXB0eRotCgtGaWx0ZXJFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBItkBCg1XYXRjaFN0YXR1c1YxEhYKBEtpbmQYASABKAlCCOreHwRraW5kEicKB1N1YktpbmQYAiABKAlCFureHxJzdWJfa2luZCxvbWl0ZW1wdHkSHAoHVmVyc2lvbhgDIAEoCUIL6t4fB3ZlcnNpb24SMwoITWV0YWRhdGEYBCABKAsyDy50eXBlcy5NZXRhZGF0YUIQyN4fAOreHwhtZXRhZGF0YRI0CgRTcGVjGAUgASgLMhgudHlwZXMuV2F0Y2hTdGF0dXNTcGVjVjFCDMjeHwDq3h8Ec3BlYyJDChFXYXRjaFN0YXR1c1NwZWNWMRIuCgVLaW5kcxgBIAMoCzIQLnR5cGVzLldhdGNoS2luZEINyN4fAOreHwVraW5kcyLNAQoMU2VydmVySW5mb1YxEhYKBEtpbmQYASABKAlCCOreHwRraW5kEh0KB1N1YktpbmQYAiABKAlCDOreHwhzdWJfa2luZBIcCgdWZXJzaW9uGAMgASgJQgvq3h8HdmVyc2lvbhIzCghNZXRhZGF0YRgEIAEoCzIPLnR5cGVzLk1ldGFkYXRhQhDI3h8A6t4fCG1ldGFkYXRhEjMKBFNwZWMYBSABKAsyFy50eXBlcy5TZXJ2ZXJJbmZvU3BlY1YxQgzI3h8A6t4fBHNwZWMipAEKEFNlcnZlckluZm9TcGVjVjESUwoJTmV3TGFiZWxzGAIgAygLMiYudHlwZXMuU2VydmVySW5mb1NwZWNWMS5OZXdMYWJlbHNFbnRyeUIY6t4fFG5ld19sYWJlbHMsb21pdGVtcHR5GjAKDk5ld0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFKBAgBEAJSA0FXUyLVAgoKSmFtZlNwZWNWMRImCgdlbmFibGVkGAEgASgIQhXq3h8RZW5hYmxlZCxvbWl0ZW1wdHkSIAoEbmFtZRgCIAEoCUIS6t4fDm5hbWUsb21pdGVtcHR5EjgKCnN5bmNfZGVsYXkYAyABKANCJOreHxRzeW5jX2RlbGF5LG9taXRlbXB0efreHwhEdXJhdGlvbhIwCgxhcGlfZW5kcG9pbnQYBCABKAlCGureHxZhcGlfZW5kcG9pbnQsb21pdGVtcHR5EkUKCWludmVudG9yeRgHIAMoCzIZLnR5cGVzLkphbWZJbnZlbnRvcnlFbnRyeUIX6t4fE2ludmVudG9yeSxvbWl0ZW1wdHk6BOigHwFKBAgFEAZKBAgGEAdKBAgIEAlKBAgJEApSCHVzZXJuYW1lUghwYXNzd29yZFIJY2xpZW50X2lkUg1jbGllbnRfc2VjcmV0IrYCChJKYW1mSW52ZW50b3J5RW50cnkSLgoLZmlsdGVyX3JzcWwYASABKAlCGereHxVmaWx0ZXJfcnNxbCxvbWl0ZW1wdHkSSgoTc3luY19wZXJpb2RfcGFydGlhbBgCIAEoA0It6t4fHXN5bmNfcGVyaW9kX3BhcnRpYWwsb21pdGVtcHR5+t4fCER1cmF0aW9uEkQKEHN5bmNfcGVyaW9kX2Z1bGwYAyABKANCKureHxpzeW5jX3BlcmlvZF9mdWxsLG9taXRlbXB0efreHwhEdXJhdGlvbhIsCgpvbl9taXNzaW5nGAQgASgJQhjq3h8Ub25fbWlzc2luZyxvbWl0ZW1wdHkSKgoJcGFnZV9zaXplGAUgASgFQhfq3h8TcGFnZV9zaXplLG9taXRlbXB0eToE6KAfASJSChFNZXNzYWdlV2l0aEhlYWRlchIzCgZIZWFkZXIYASABKAsyFS50eXBlcy5SZXNvdXJjZUhlYWRlckIMyN4fANDeHwHq3h8AOgiYoB8AgNwgACL6AwoKQVdTTWF0Y2hlchIiCgVUeXBlcxgBIAMoCUIT6t4fD3R5cGVzLG9taXRlbXB0eRImCgdSZWdpb25zGAIgAygJQhXq3h8RcmVnaW9ucyxvbWl0ZW1wdHkSQAoKQXNzdW1lUm9sZRgDIAEoCzIRLnR5cGVzLkFzc3VtZVJvbGVCGereHxVhc3N1bWVfcm9sZSxvbWl0ZW1wdHkSRQoEVGFncxgEIAEoCzIVLndyYXBwZXJzLkxhYmVsVmFsdWVzQiDI3h8A2t4fBkxhYmVsc+reHw50YWdzLG9taXRlbXB0eRI9CgZQYXJhbXMYBSABKAsyFi50eXBlcy5JbnN0YWxsZXJQYXJhbXNCFereHxFpbnN0YWxsLG9taXRlbXB0eRItCgNTU00YBiABKAsyDS50eXBlcy5BV1NTU01CEereHw1zc20sb21pdGVtcHR5Ei4KC0ludGVncmF0aW9uGAcgASgJQhnq3h8VaW50ZWdyYXRpb24sb21pdGVtcHR5EjoKEEt1YmVBcHBEaXNjb3ZlcnkYCCABKAhCIOreHxxrdWJlX2FwcF9kaXNjb3Zlcnksb21pdGVtcHR5Ej0KEVNldHVwQWNjZXNzRm9yQVJOGAkgASgJQiLq3h8ec2V0dXBfYWNjZXNzX2Zvcl9hcm4sb21pdGVtcHR5IlAKCkFzc3VtZVJvbGUSHQoHUm9sZUFSThgBIAEoCUIM6t4fCHJvbGVfYXJuEiMKCkV4dGVybmFsSUQYAiABKAlCD+reHwtleHRlcm5hbF9pZCLAAwoPSW5zdGFsbGVyUGFyYW1zEjEKCkpvaW5NZXRob2QYASABKAlCHereHwtqb2luX21ldGhvZPreHwpKb2luTWV0aG9kEiEKCUpvaW5Ub2tlbhgCIAEoCUIO6t4fCmpvaW5fdG9rZW4SLQoKU2NyaXB0TmFtZRgDIAEoCUIZ6t4fFXNjcmlwdF9uYW1lLG9taXRlbXB0eRI3Cg9JbnN0YWxsVGVsZXBvcnQYBCABKAhCHureHxppbnN0YWxsX3RlbGVwb3J0LG9taXRlbXB0eRItCgpTU0hEQ29uZmlnGAUgASgJQhnq3h8Vc3NoZF9jb25maWcsb21pdGVtcHR5EjEKD1B1YmxpY1Byb3h5QWRkchgGIAEoCUIY6t4fFHByb3h5X2FkZHIsb21pdGVtcHR5Ej8KBUF6dXJlGAcgASgLMhsudHlwZXMuQXp1cmVJbnN0YWxsZXJQYXJhbXNCE+reHw9henVyZSxvbWl0ZW1wdHkSTAoKRW5yb2xsTW9kZRgIIAEoDjIdLnR5cGVzLkluc3RhbGxQYXJhbUVucm9sbE1vZGVCGereHxVlbnJvbGxfbW9kZSxvbWl0ZW1wdHkiOwoGQVdTU1NNEjEKDERvY3VtZW50TmFtZRgBIAEoCUIb6t4fF2RvY3VtZW50X25hbWUsb21pdGVtcHR5IkEKFEF6dXJlSW5zdGFsbGVyUGFyYW1zEikKCENsaWVudElEGAEgASgJQhfq3h8TY2xpZW50X2lkLG9taXRlbXB0eSLaAgoMQXp1cmVNYXRjaGVyEjIKDVN1YnNjcmlwdGlvbnMYASADKAlCG+reHxdzdWJzY3JpcHRpb25zLG9taXRlbXB0eRI1Cg5SZXNvdXJjZUdyb3VwcxgCIAMoCUId6t4fGXJlc291cmNlX2dyb3VwcyxvbWl0ZW1wdHkSIgoFVHlwZXMYAyADKAlCE+reHw90eXBlcyxvbWl0ZW1wdHkSJgoHUmVnaW9ucxgEIAMoCUIV6t4fEXJlZ2lvbnMsb21pdGVtcHR5Ek0KDFJlc291cmNlVGFncxgFIAEoCzIVLndyYXBwZXJzLkxhYmVsVmFsdWVzQiDI3h8A2t4fBkxhYmVsc+reHw50YWdzLG9taXRlbXB0eRJECgZQYXJhbXMYBiABKAsyFi50eXBlcy5JbnN0YWxsZXJQYXJhbXNCHOreHxhpbnN0YWxsX3BhcmFtcyxvbWl0ZW1wdHkinAMKCkdDUE1hdGNoZXISIgoFVHlwZXMYASADKAlCE+reHw90eXBlcyxvbWl0ZW1wdHkSKgoJTG9jYXRpb25zGAIgAygJQhfq3h8TbG9jYXRpb25zLG9taXRlbXB0eRJFCgRUYWdzGAMgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCIMjeHwDa3h8GTGFiZWxz6t4fDnRhZ3Msb21pdGVtcHR5Ei0KClByb2plY3RJRHMYBCADKAlCGereHxVwcm9qZWN0X2lkcyxvbWl0ZW1wdHkSNwoPU2VydmljZUFjY291bnRzGAUgAygJQh7q3h8ac2VydmljZV9hY2NvdW50cyxvbWl0ZW1wdHkSRAoGUGFyYW1zGAYgASgLMhYudHlwZXMuSW5zdGFsbGVyUGFyYW1zQhzq3h8YaW5zdGFsbF9wYXJhbXMsb21pdGVtcHR5EkkKBkxhYmVscxgHIAEoCzIVLndyYXBwZXJzLkxhYmVsVmFsdWVzQiLI3h8A2t4fBkxhYmVsc+reHxBsYWJlbHMsb21pdGVtcHR5IrABChFLdWJlcm5ldGVzTWF0Y2hlchIiCgVUeXBlcxgBIAMoCUIT6t4fD3R5cGVzLG9taXRlbXB0eRIsCgpOYW1lc3BhY2VzGAIgAygJQhjq3h8UbmFtZXNwYWNlcyxvbWl0ZW1wdHkSSQoGTGFiZWxzGAMgASgLMhUud3JhcHBlcnMuTGFiZWxWYWx1ZXNCIsjeHwDa3h8GTGFiZWxz6t4fEGxhYmVscyxvbWl0ZW1wdHkiSAoLT2t0YU9wdGlvbnMSOQoKU3luY1BlcmlvZBgBIAEoA0Il6t4fFXN5bmNfcGVyaW9kLG9taXRlbXB0efreHwhEdXJhdGlvbiJMCg9BY2Nlc3NHcmFwaFN5bmMSOQoDQVdTGAEgAygLMhkudHlwZXMuQWNjZXNzR3JhcGhBV1NTeW5jQhHq3h8NYXdzLG9taXRlbXB0eSKuAQoSQWNjZXNzR3JhcGhBV1NTeW5jEiYKB1JlZ2lvbnMYASADKAlCFereHxFyZWdpb25zLG9taXRlbXB0eRJACgpBc3N1bWVSb2xlGAMgASgLMhEudHlwZXMuQXNzdW1lUm9sZUIZ6t4fFWFzc3VtZV9yb2xlLG9taXRlbXB0eRIuCgtJbnRlZ3JhdGlvbhgEIAEoCUIZ6t4fFWludGVncmF0aW9uLG9taXRlbXB0eSqQAQoPSUFNUG9saWN5U3RhdHVzEiEKHUlBTV9QT0xJQ1lfU1RBVFVTX1VOU1BFQ0lGSUVEEAASHQoZSUFNX1BPTElDWV9TVEFUVVNfUEVORElORxABEhwKGElBTV9QT0xJQ1lfU1RBVFVTX0ZBSUxFRBACEh0KGUlBTV9QT0xJQ1lfU1RBVFVTX1NVQ0NFU1MQAyo/Cg9EYXRhYmFzZVRMU01vZGUSDwoLVkVSSUZZX0ZVTEwQABINCglWRVJJRllfQ0EQARIMCghJTlNFQ1VSRRACKj8KDlByaXZhdGVLZXlUeXBlEgcKA1JBVxAAEgoKBlBLQ1MxMRABEgsKB0dDUF9LTVMQAhILCgdBV1NfS01TEAMqMAoRUHJveHlMaXN0ZW5lck1vZGUSDAoIU2VwYXJhdGUQABINCglNdWx0aXBsZXgQASo5Cg9Sb3V0aW5nU3RyYXRlZ3kSFQoRVU5BTUJJR1VPVVNfTUFUQ0gQABIPCgtNT1NUX1JFQ0VOVBABKosBCg5Vc2VyVG9rZW5Vc2FnZRIgChxVU0VSX1RPS0VOX1VTQUdFX1VOU1BFQ0lGSUVEEAASHwobVVNFUl9UT0tFTl9SRUNPVkVSX1BBU1NXT1JEEAESGgoWVVNFUl9UT0tFTl9SRUNPVkVSX01GQRACEhoKFlVTRVJfVE9LRU5fUkVORVdBTF9CT1QQAypNCgxSZXF1ZXN0U3RhdGUSCAoETk9ORRAAEgsKB1BFTkRJTkcQARIMCghBUFBST1ZFRBACEgoKBkRFTklFRBADEgwKCFBST01PVEVEEAQqUgoSQWNjZXNzUmVxdWVzdFNjb3BlEgsKB0RFRkFVTFQQABIPCgtNWV9SRVFVRVNUUxABEhAKDE5FRURTX1JFVklFVxACEgwKCFJFVklFV0VEEAMqpAEKEkNyZWF0ZUhvc3RVc2VyTW9kZRIeChpIT1NUX1VTRVJfTU9ERV9VTlNQRUNJRklFRBAAEhYKEkhPU1RfVVNFUl9NT0RFX09GRhABEhsKE0hPU1RfVVNFUl9NT0RFX0RST1AQAhoCCAESFwoTSE9TVF9VU0VSX01PREVfS0VFUBADEiAKHEhPU1RfVVNFUl9NT0RFX0lOU0VDVVJFX0RST1AQBCqGAQoWQ3JlYXRlRGF0YWJhc2VVc2VyTW9kZRIcChhEQl9VU0VSX01PREVfVU5TUEVDSUZJRUQQABIUChBEQl9VU0VSX01PREVfT0ZGEAESFQoRREJfVVNFUl9NT0RFX0tFRVAQAhIhCh1EQl9VU0VSX01PREVfQkVTVF9FRkZPUlRfRFJPUBADKiIKEUNlcnRFeHRlbnNpb25Nb2RlEg0KCUVYVEVOU0lPThAAKhwKEUNlcnRFeHRlbnNpb25UeXBlEgcKA1NTSBAAKmEKDVBhc3N3b3JkU3RhdGUSHgoaUEFTU1dPUkRfU1RBVEVfVU5TUEVDSUZJRUQQABIYChRQQVNTV09SRF9TVEFURV9VTlNFVBABEhYKElBBU1NXT1JEX1NUQVRFX1NFVBACKpwBChhUcnVzdGVkRGV2aWNlUmVxdWlyZW1lbnQSKgomVFJVU1RFRF9ERVZJQ0VfUkVRVUlSRU1FTlRfVU5TUEVDSUZJRUQQABIrCidUUlVTVEVEX0RFVklDRV9SRVFVSVJFTUVOVF9OT1RfUkVRVUlSRUQQARInCiNUUlVTVEVEX0RFVklDRV9SRVFVSVJFTUVOVF9SRVFVSVJFRBACKlwKDFNlc3Npb25TdGF0ZRIXChNTZXNzaW9uU3RhdGVQZW5kaW5nEAASFwoTU2Vzc2lvblN0YXRlUnVubmluZxABEhoKFlNlc3Npb25TdGF0ZVRlcm1pbmF0ZWQQAiouCg1BbGVydFNldmVyaXR5EgcKA0xPVxAAEgoKBk1FRElVTRAFEggKBEhJR0gQCiqSAQoOUmVxdWlyZU1GQVR5cGUSBwoDT0ZGEAASCwoHU0VTU0lPThABEhwKGFNFU1NJT05fQU5EX0hBUkRXQVJFX0tFWRACEhYKEkhBUkRXQVJFX0tFWV9UT1VDSBADEhQKEEhBUkRXQVJFX0tFWV9QSU4QBBIeChpIQVJEV0FSRV9LRVlfVE9VQ0hfQU5EX1BJThAFKuIBChdTaWduYXR1cmVBbGdvcml0aG1TdWl0ZRIpCiVTSUdOQVRVUkVfQUxHT1JJVEhNX1NVSVRFX1VOU1BFQ0lGSUVEEAASJAogU0lHTkFUVVJFX0FMR09SSVRITV9TVUlURV9MRUdBQ1kQARIpCiVTSUdOQVRVUkVfQUxHT1JJVEhNX1NVSVRFX0JBTEFOQ0VEX1YxEAISJQohU0lHTkFUVVJFX0FMR09SSVRITV9TVUlURV9GSVBTX1YxEAMSJAogU0lHTkFUVVJFX0FMR09SSVRITV9TVUlURV9IU01fVjEQBCppChBQbHVnaW5TdGF0dXNDb2RlEgsKB1VOS05PV04QABILCgdSVU5OSU5HEAESDwoLT1RIRVJfRVJST1IQAhIQCgxVTkFVVEhPUklaRUQQAxIYChRTTEFDS19OT1RfSU5fQ0hBTk5FTBAKKpoBChhPa3RhUGx1Z2luU3luY1N0YXR1c0NvZGUSLAooT0tUQV9QTFVHSU5fU1lOQ19TVEFUVVNfQ09ERV9VTlNQRUNJRklFRBAAEigKJE9LVEFfUExVR0lOX1NZTkNfU1RBVFVTX0NPREVfU1VDQ0VTUxABEiYKIk9LVEFfUExVR0lOX1NZTkNfU1RBVFVTX0NPREVfRVJST1IQAirNAQobSGVhZGxlc3NBdXRoZW50aWNhdGlvblN0YXRlEi0KKUhFQURMRVNTX0FVVEhFTlRJQ0FUSU9OX1NUQVRFX1VOU1BFQ0lGSUVEEAASKQolSEVBRExFU1NfQVVUSEVOVElDQVRJT05fU1RBVEVfUEVORElORxABEigKJEhFQURMRVNTX0FVVEhFTlRJQ0FUSU9OX1NUQVRFX0RFTklFRBACEioKJkhFQURMRVNTX0FVVEhFTlRJQ0FUSU9OX1NUQVRFX0FQUFJPVkVEEAMqjQEKFkluc3RhbGxQYXJhbUVucm9sbE1vZGUSKQolSU5TVEFMTF9QQVJBTV9FTlJPTExfTU9ERV9VTlNQRUNJRklFRBAAEiQKIElOU1RBTExfUEFSQU1fRU5ST0xMX01PREVfU0NSSVBUEAESIgoeSU5TVEFMTF9QQVJBTV9FTlJPTExfTU9ERV9FSUNFEAJCPVorZ2l0aHViLmNvbS9ncmF2aXRhdGlvbmFsL3RlbGVwb3J0L2FwaS90eXBlc8jhHgDI4h4B0OIeAcDjHgFiBnByb3RvMw", [file_gogoproto_gogo, file_google_protobuf_duration, file_google_protobuf_timestamp, file_google_protobuf_wrappers, file_teleport_attestation_v1_attestation, file_teleport_legacy_types_wrappers_wrappers]);

/**
 * @generated from message types.KeepAlive
 */
export type KeepAlive = Message<"types.KeepAlive"> & {
  /**
   * Name of the resource to keep alive.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Namespace is the namespace of the resource.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace: string;

  /**
   * Expires is set to update expiry time of the resource.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 4;
   */
  Expires?: Timestamp;

  /**
   * Type is the type (or kind) of the resource that's being kept alive.
   *
   * @generated from field: types.KeepAlive.KeepAliveType Type = 9;
   */
  Type: KeepAlive_KeepAliveType;

  /**
   * HostID is an optional UUID of the host the resource belongs to.
   *
   * @generated from field: string HostID = 10;
   */
  HostID: string;
};

/**
 * Describes the message types.KeepAlive.
 * Use `create(KeepAliveSchema)` to create a new message.
 */
export const KeepAliveSchema: GenMessage<KeepAlive> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 0);

/**
 * The type of a KeepAlive. When adding a new type, please double-check
 * lib/usagereporter/teleport to see if we need any change in the resource
 * heartbeat event.
 *
 * @generated from enum types.KeepAlive.KeepAliveType
 */
export enum KeepAlive_KeepAliveType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * "node", KindNode. For the sake of correct usage reporting, it shouldn't
   * be used for OpenSSH nodes.
   *
   * @generated from enum value: NODE = 1;
   */
  NODE = 1,

  /**
   * "app_server", KindAppServer
   *
   * @generated from enum value: APP = 2;
   */
  APP = 2,

  /**
   * "db_server", KindDatabaseServer
   *
   * @generated from enum value: DATABASE = 3;
   */
  DATABASE = 3,

  /**
   * "windows_desktop_service", KindWindowsDesktopService
   *
   * @generated from enum value: WINDOWS_DESKTOP = 4;
   */
  WINDOWS_DESKTOP = 4,

  /**
   * "kube_server", KindKubeServer
   *
   * @generated from enum value: KUBERNETES = 5;
   */
  KUBERNETES = 5,

  /**
   * "db_service", KindDatabaseService
   *
   * @generated from enum value: DATABASE_SERVICE = 6;
   */
  DATABASE_SERVICE = 6,
}

/**
 * Describes the enum types.KeepAlive.KeepAliveType.
 */
export const KeepAlive_KeepAliveTypeSchema: GenEnum<KeepAlive_KeepAliveType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 0, 0);

/**
 * Metadata is resource metadata
 *
 * @generated from message types.Metadata
 */
export type Metadata = Message<"types.Metadata"> & {
  /**
   * Name is an object name
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Namespace is object namespace. The field should be called "namespace"
   * when it returns in Teleport 2.4.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace: string;

  /**
   * Description is object description
   *
   * @generated from field: string Description = 3;
   */
  Description: string;

  /**
   * Labels is a set of labels
   *
   * @generated from field: map<string, string> Labels = 5;
   */
  Labels: { [key: string]: string };

  /**
   * Expires is a global expiry time header can be set on any resource in the
   * system.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 6;
   */
  Expires?: Timestamp;

  /**
   * Revision is an opaque identifier which tracks the versions of a resource
   * over time. Clients should ignore and not alter its value but must return
   * the revision in any updates of a resource.
   *
   * @generated from field: string Revision = 8;
   */
  Revision: string;
};

/**
 * Describes the message types.Metadata.
 * Use `create(MetadataSchema)` to create a new message.
 */
export const MetadataSchema: GenMessage<Metadata> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 1);

/**
 * Rotation is a status of the rotation of the certificate authority
 *
 * @generated from message types.Rotation
 */
export type Rotation = Message<"types.Rotation"> & {
  /**
   * State could be one of "init" or "in_progress".
   *
   * @generated from field: string State = 1;
   */
  State: string;

  /**
   * Phase is the current rotation phase.
   *
   * @generated from field: string Phase = 2;
   */
  Phase: string;

  /**
   * Mode sets manual or automatic rotation mode.
   *
   * @generated from field: string Mode = 3;
   */
  Mode: string;

  /**
   * CurrentID is the ID of the rotation operation
   * to differentiate between rotation attempts.
   *
   * @generated from field: string CurrentID = 4;
   */
  CurrentID: string;

  /**
   * Started is set to the time when rotation has been started
   * in case if the state of the rotation is "in_progress".
   *
   * @generated from field: google.protobuf.Timestamp Started = 5;
   */
  Started?: Timestamp;

  /**
   * GracePeriod is a period during which old and new CA
   * are valid for checking purposes, but only new CA is issuing certificates.
   *
   * @generated from field: int64 GracePeriod = 6;
   */
  GracePeriod: bigint;

  /**
   * LastRotated specifies the last time of the completed rotation.
   *
   * @generated from field: google.protobuf.Timestamp LastRotated = 7;
   */
  LastRotated?: Timestamp;

  /**
   * Schedule is a rotation schedule - used in
   * automatic mode to switch between phases.
   *
   * @generated from field: types.RotationSchedule Schedule = 8;
   */
  Schedule?: RotationSchedule;
};

/**
 * Describes the message types.Rotation.
 * Use `create(RotationSchema)` to create a new message.
 */
export const RotationSchema: GenMessage<Rotation> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 2);

/**
 * RotationSchedule is a rotation schedule setting time switches
 * for different phases.
 *
 * @generated from message types.RotationSchedule
 */
export type RotationSchedule = Message<"types.RotationSchedule"> & {
  /**
   * UpdateClients specifies time to switch to the "Update clients" phase
   *
   * @generated from field: google.protobuf.Timestamp UpdateClients = 1;
   */
  UpdateClients?: Timestamp;

  /**
   * UpdateServers specifies time to switch to the "Update servers" phase.
   *
   * @generated from field: google.protobuf.Timestamp UpdateServers = 2;
   */
  UpdateServers?: Timestamp;

  /**
   * Standby specifies time to switch to the "Standby" phase.
   *
   * @generated from field: google.protobuf.Timestamp Standby = 3;
   */
  Standby?: Timestamp;
};

/**
 * Describes the message types.RotationSchedule.
 * Use `create(RotationScheduleSchema)` to create a new message.
 */
export const RotationScheduleSchema: GenMessage<RotationSchedule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 3);

/**
 * ResourceHeader is a shared resource header
 * used in cases when only type and name is known
 *
 * @generated from message types.ResourceHeader
 */
export type ResourceHeader = Message<"types.ResourceHeader"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the API version used to create the resource. It must be
   * specified. Based on this version, Teleport will apply different defaults on
   * resource creation or deletion. It must be an integer prefixed by "v".
   * For example: `v1`
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;
};

/**
 * Describes the message types.ResourceHeader.
 * Use `create(ResourceHeaderSchema)` to create a new message.
 */
export const ResourceHeaderSchema: GenMessage<ResourceHeader> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 4);

/**
 * DatabaseServerV3 represents a database access server.
 *
 * @generated from message types.DatabaseServerV3
 */
export type DatabaseServerV3 = Message<"types.DatabaseServerV3"> & {
  /**
   * Kind is the database server resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the database server metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the database server spec.
   *
   * @generated from field: types.DatabaseServerSpecV3 Spec = 5;
   */
  Spec?: DatabaseServerSpecV3;
};

/**
 * Describes the message types.DatabaseServerV3.
 * Use `create(DatabaseServerV3Schema)` to create a new message.
 */
export const DatabaseServerV3Schema: GenMessage<DatabaseServerV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 5);

/**
 * DatabaseServerSpecV3 is the database server spec.
 *
 * @generated from message types.DatabaseServerSpecV3
 */
export type DatabaseServerSpecV3 = Message<"types.DatabaseServerSpecV3"> & {
  /**
   * Version is the Teleport version that the server is running.
   *
   * @generated from field: string Version = 6;
   */
  Version: string;

  /**
   * Hostname is the database server hostname.
   *
   * @generated from field: string Hostname = 7;
   */
  Hostname: string;

  /**
   * HostID is the ID of the host the database server is running on.
   *
   * @generated from field: string HostID = 8;
   */
  HostID: string;

  /**
   * Rotation contains the server CA rotation information.
   *
   * @generated from field: types.Rotation Rotation = 10;
   */
  Rotation?: Rotation;

  /**
   * Database is the database proxied by this database server.
   *
   * @generated from field: types.DatabaseV3 Database = 12;
   */
  Database?: DatabaseV3;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 13;
   */
  ProxyIDs: string[];
};

/**
 * Describes the message types.DatabaseServerSpecV3.
 * Use `create(DatabaseServerSpecV3Schema)` to create a new message.
 */
export const DatabaseServerSpecV3Schema: GenMessage<DatabaseServerSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 6);

/**
 * DatabaseV3List represents a list of databases.
 *
 * @generated from message types.DatabaseV3List
 */
export type DatabaseV3List = Message<"types.DatabaseV3List"> & {
  /**
   * Databases is a list of database resources.
   *
   * @generated from field: repeated types.DatabaseV3 Databases = 1;
   */
  Databases: DatabaseV3[];
};

/**
 * Describes the message types.DatabaseV3List.
 * Use `create(DatabaseV3ListSchema)` to create a new message.
 */
export const DatabaseV3ListSchema: GenMessage<DatabaseV3List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 7);

/**
 * DatabaseV3 represents a single proxied database.
 *
 * @generated from message types.DatabaseV3
 */
export type DatabaseV3 = Message<"types.DatabaseV3"> & {
  /**
   * Kind is the database resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the database metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the database spec.
   *
   * @generated from field: types.DatabaseSpecV3 Spec = 5;
   */
  Spec?: DatabaseSpecV3;

  /**
   * Status is the database runtime information.
   *
   * @generated from field: types.DatabaseStatusV3 Status = 6;
   */
  Status?: DatabaseStatusV3;
};

/**
 * Describes the message types.DatabaseV3.
 * Use `create(DatabaseV3Schema)` to create a new message.
 */
export const DatabaseV3Schema: GenMessage<DatabaseV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 8);

/**
 * DatabaseSpecV3 is the database spec.
 *
 * @generated from message types.DatabaseSpecV3
 */
export type DatabaseSpecV3 = Message<"types.DatabaseSpecV3"> & {
  /**
   * Protocol is the database protocol: postgres, mysql, mongodb, etc.
   *
   * @generated from field: string Protocol = 1;
   */
  Protocol: string;

  /**
   * URI is the database connection endpoint.
   *
   * @generated from field: string URI = 2;
   */
  URI: string;

  /**
   * CACert is the PEM-encoded database CA certificate.
   *
   * DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
   *
   * @generated from field: string CACert = 3 [deprecated = true];
   * @deprecated
   */
  CACert: string;

  /**
   * DynamicLabels is the database dynamic labels.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 4;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 };

  /**
   * AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
   *
   * @generated from field: types.AWS AWS = 5;
   */
  AWS?: AWS;

  /**
   * GCP contains parameters specific to GCP Cloud SQL databases.
   *
   * @generated from field: types.GCPCloudSQL GCP = 6;
   */
  GCP?: GCPCloudSQL;

  /**
   * Azure contains Azure specific database metadata.
   *
   * @generated from field: types.Azure Azure = 7;
   */
  Azure?: Azure;

  /**
   * TLS is the TLS configuration used when establishing connection to target database.
   * Allows to provide custom CA cert or override server name.
   *
   * @generated from field: types.DatabaseTLS TLS = 8;
   */
  TLS?: DatabaseTLS;

  /**
   * AD is the Active Directory configuration for the database.
   *
   * @generated from field: types.AD AD = 9;
   */
  AD?: AD;

  /**
   * MySQL is an additional section with MySQL database options.
   *
   * @generated from field: types.MySQLOptions MySQL = 10;
   */
  MySQL?: MySQLOptions;

  /**
   * AdminUser is the database admin user for automatic user provisioning.
   *
   * @generated from field: types.DatabaseAdminUser AdminUser = 11;
   */
  AdminUser?: DatabaseAdminUser;

  /**
   * MongoAtlas contains Atlas metadata about the database.
   *
   * @generated from field: types.MongoAtlas MongoAtlas = 12;
   */
  MongoAtlas?: MongoAtlas;

  /**
   * Oracle is an additional Oracle configuration options.
   *
   * @generated from field: types.OracleOptions Oracle = 13;
   */
  Oracle?: OracleOptions;
};

/**
 * Describes the message types.DatabaseSpecV3.
 * Use `create(DatabaseSpecV3Schema)` to create a new message.
 */
export const DatabaseSpecV3Schema: GenMessage<DatabaseSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 9);

/**
 * DatabaseAdminUser contains information about privileged database user used
 * for automatic user provisioning.
 *
 * @generated from message types.DatabaseAdminUser
 */
export type DatabaseAdminUser = Message<"types.DatabaseAdminUser"> & {
  /**
   * Name is the username of the privileged database user.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * DefaultDatabase is the database that the privileged database user logs
   * into by default.
   *
   * Depending on the database type, this database may be used to store
   * procedures or data for managing database users.
   *
   * @generated from field: string DefaultDatabase = 2;
   */
  DefaultDatabase: string;
};

/**
 * Describes the message types.DatabaseAdminUser.
 * Use `create(DatabaseAdminUserSchema)` to create a new message.
 */
export const DatabaseAdminUserSchema: GenMessage<DatabaseAdminUser> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 10);

/**
 * OracleOptions contains information about privileged database user used
 * for database audit.
 *
 * @generated from message types.OracleOptions
 */
export type OracleOptions = Message<"types.OracleOptions"> & {
  /**
   * AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
   *
   * @generated from field: string AuditUser = 1;
   */
  AuditUser: string;
};

/**
 * Describes the message types.OracleOptions.
 * Use `create(OracleOptionsSchema)` to create a new message.
 */
export const OracleOptionsSchema: GenMessage<OracleOptions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 11);

/**
 * DatabaseStatusV3 contains runtime information about the database.
 *
 * @generated from message types.DatabaseStatusV3
 */
export type DatabaseStatusV3 = Message<"types.DatabaseStatusV3"> & {
  /**
   * CACert is the auto-downloaded cloud database CA certificate.
   *
   * @generated from field: string CACert = 1;
   */
  CACert: string;

  /**
   * AWS is the auto-discovered AWS cloud database metadata.
   *
   * @generated from field: types.AWS AWS = 2;
   */
  AWS?: AWS;

  /**
   * MySQL is an additional section with MySQL runtime database information.
   *
   * @generated from field: types.MySQLOptions MySQL = 3;
   */
  MySQL?: MySQLOptions;

  /**
   * ManagedUsers is a list of database users that are managed by Teleport.
   *
   * @generated from field: repeated string ManagedUsers = 4;
   */
  ManagedUsers: string[];

  /**
   * Azure is the auto-discovered Azure cloud database metadata.
   *
   * @generated from field: types.Azure Azure = 5;
   */
  Azure?: Azure;
};

/**
 * Describes the message types.DatabaseStatusV3.
 * Use `create(DatabaseStatusV3Schema)` to create a new message.
 */
export const DatabaseStatusV3Schema: GenMessage<DatabaseStatusV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 12);

/**
 * AWS contains AWS metadata about the database.
 *
 * @generated from message types.AWS
 */
export type AWS = Message<"types.AWS"> & {
  /**
   * Region is a AWS cloud region.
   *
   * @generated from field: string Region = 1;
   */
  Region: string;

  /**
   * Redshift contains Redshift specific metadata.
   *
   * @generated from field: types.Redshift Redshift = 2;
   */
  Redshift?: Redshift;

  /**
   * RDS contains RDS specific metadata.
   *
   * @generated from field: types.RDS RDS = 3;
   */
  RDS?: RDS;

  /**
   * AccountID is the AWS account ID this database belongs to.
   *
   * @generated from field: string AccountID = 4;
   */
  AccountID: string;

  /**
   * ElastiCache contains AWS ElastiCache Redis specific metadata.
   *
   * @generated from field: types.ElastiCache ElastiCache = 5;
   */
  ElastiCache?: ElastiCache;

  /**
   * SecretStore contains secret store configurations.
   *
   * @generated from field: types.SecretStore SecretStore = 6;
   */
  SecretStore?: SecretStore;

  /**
   * MemoryDB contains AWS MemoryDB specific metadata.
   *
   * @generated from field: types.MemoryDB MemoryDB = 7;
   */
  MemoryDB?: MemoryDB;

  /**
   * RDSProxy contains AWS Proxy specific metadata.
   *
   * @generated from field: types.RDSProxy RDSProxy = 8;
   */
  RDSProxy?: RDSProxy;

  /**
   * RedshiftServerless contains AWS Redshift Serverless specific metadata.
   *
   * @generated from field: types.RedshiftServerless RedshiftServerless = 9;
   */
  RedshiftServerless?: RedshiftServerless;

  /**
   * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
   *
   * @generated from field: string ExternalID = 10;
   */
  ExternalID: string;

  /**
   * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
   * Set this field and ExternalID to enable access across AWS accounts.
   *
   * @generated from field: string AssumeRoleARN = 11;
   */
  AssumeRoleARN: string;

  /**
   * OpenSearch contains AWS OpenSearch specific metadata.
   *
   * @generated from field: types.OpenSearch OpenSearch = 12;
   */
  OpenSearch?: OpenSearch;

  /**
   * IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access.
   * If not, the user must update the AWS profile identity to allow access to the Database.
   * Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
   *
   * @generated from field: types.IAMPolicyStatus IAMPolicyStatus = 14;
   */
  IAMPolicyStatus: IAMPolicyStatus;

  /**
   * SessionTags is a list of AWS STS session tags.
   *
   * @generated from field: map<string, string> SessionTags = 15;
   */
  SessionTags: { [key: string]: string };

  /**
   * DocumentDB contains AWS DocumentDB specific metadata.
   *
   * @generated from field: types.DocumentDB DocumentDB = 16;
   */
  DocumentDB?: DocumentDB;
};

/**
 * Describes the message types.AWS.
 * Use `create(AWSSchema)` to create a new message.
 */
export const AWSSchema: GenMessage<AWS> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 13);

/**
 * SecretStore contains secret store configurations.
 *
 * @generated from message types.SecretStore
 */
export type SecretStore = Message<"types.SecretStore"> & {
  /**
   * KeyPrefix specifies the secret key prefix.
   *
   * @generated from field: string KeyPrefix = 1;
   */
  KeyPrefix: string;

  /**
   * KMSKeyID specifies the AWS KMS key for encryption.
   *
   * @generated from field: string KMSKeyID = 2;
   */
  KMSKeyID: string;
};

/**
 * Describes the message types.SecretStore.
 * Use `create(SecretStoreSchema)` to create a new message.
 */
export const SecretStoreSchema: GenMessage<SecretStore> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 14);

/**
 * Redshift contains AWS Redshift specific database metadata.
 *
 * @generated from message types.Redshift
 */
export type Redshift = Message<"types.Redshift"> & {
  /**
   * ClusterID is the Redshift cluster identifier.
   *
   * @generated from field: string ClusterID = 1;
   */
  ClusterID: string;
};

/**
 * Describes the message types.Redshift.
 * Use `create(RedshiftSchema)` to create a new message.
 */
export const RedshiftSchema: GenMessage<Redshift> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 15);

/**
 * RDS contains AWS RDS specific database metadata.
 *
 * @generated from message types.RDS
 */
export type RDS = Message<"types.RDS"> & {
  /**
   * InstanceID is the RDS instance identifier.
   *
   * @generated from field: string InstanceID = 1;
   */
  InstanceID: string;

  /**
   * ClusterID is the RDS cluster (Aurora) identifier.
   *
   * @generated from field: string ClusterID = 2;
   */
  ClusterID: string;

  /**
   * ResourceID is the RDS instance resource identifier (db-xxx).
   *
   * @generated from field: string ResourceID = 3;
   */
  ResourceID: string;

  /**
   * IAMAuth indicates whether database IAM authentication is enabled.
   *
   * @generated from field: bool IAMAuth = 4;
   */
  IAMAuth: boolean;

  /**
   * Subnets is a list of subnets for the RDS instance.
   *
   * @generated from field: repeated string Subnets = 5;
   */
  Subnets: string[];

  /**
   * VPCID is the VPC where the RDS is running.
   *
   * @generated from field: string VPCID = 6;
   */
  VPCID: string;
};

/**
 * Describes the message types.RDS.
 * Use `create(RDSSchema)` to create a new message.
 */
export const RDSSchema: GenMessage<RDS> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 16);

/**
 * RDSProxy contains AWS RDS Proxy specific database metadata.
 *
 * @generated from message types.RDSProxy
 */
export type RDSProxy = Message<"types.RDSProxy"> & {
  /**
   * Name is the identifier of an RDS Proxy.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
   *
   * @generated from field: string CustomEndpointName = 2;
   */
  CustomEndpointName: string;

  /**
   * ResourceID is the RDS instance resource identifier (prx-xxx).
   *
   * @generated from field: string ResourceID = 3;
   */
  ResourceID: string;
};

/**
 * Describes the message types.RDSProxy.
 * Use `create(RDSProxySchema)` to create a new message.
 */
export const RDSProxySchema: GenMessage<RDSProxy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 17);

/**
 * ElastiCache contains AWS ElastiCache Redis specific metadata.
 *
 * @generated from message types.ElastiCache
 */
export type ElastiCache = Message<"types.ElastiCache"> & {
  /**
   * ReplicationGroupID is the Redis replication group ID.
   *
   * @generated from field: string ReplicationGroupID = 1;
   */
  ReplicationGroupID: string;

  /**
   * UserGroupIDs is a list of user group IDs.
   *
   * @generated from field: repeated string UserGroupIDs = 2;
   */
  UserGroupIDs: string[];

  /**
   * TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
   *
   * @generated from field: bool TransitEncryptionEnabled = 3;
   */
  TransitEncryptionEnabled: boolean;

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 4;
   */
  EndpointType: string;
};

/**
 * Describes the message types.ElastiCache.
 * Use `create(ElastiCacheSchema)` to create a new message.
 */
export const ElastiCacheSchema: GenMessage<ElastiCache> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 18);

/**
 * MemoryDB contains AWS MemoryDB specific metadata.
 *
 * @generated from message types.MemoryDB
 */
export type MemoryDB = Message<"types.MemoryDB"> & {
  /**
   * ClusterName is the name of the MemoryDB cluster.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName: string;

  /**
   * ACLName is the name of the ACL associated with the cluster.
   *
   * @generated from field: string ACLName = 2;
   */
  ACLName: string;

  /**
   * TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
   *
   * @generated from field: bool TLSEnabled = 3;
   */
  TLSEnabled: boolean;

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 4;
   */
  EndpointType: string;
};

/**
 * Describes the message types.MemoryDB.
 * Use `create(MemoryDBSchema)` to create a new message.
 */
export const MemoryDBSchema: GenMessage<MemoryDB> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 19);

/**
 * RedshiftServerless contains AWS Redshift Serverless specific metadata.
 *
 * @generated from message types.RedshiftServerless
 */
export type RedshiftServerless = Message<"types.RedshiftServerless"> & {
  /**
   * WorkgroupName is the workgroup name.
   *
   * @generated from field: string WorkgroupName = 1;
   */
  WorkgroupName: string;

  /**
   * EndpointName is the VPC endpoint name.
   *
   * @generated from field: string EndpointName = 2;
   */
  EndpointName: string;

  /**
   * WorkgroupID is the workgroup ID.
   *
   * @generated from field: string WorkgroupID = 3;
   */
  WorkgroupID: string;
};

/**
 * Describes the message types.RedshiftServerless.
 * Use `create(RedshiftServerlessSchema)` to create a new message.
 */
export const RedshiftServerlessSchema: GenMessage<RedshiftServerless> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 20);

/**
 * OpenSearch contains AWS OpenSearch specific metadata.
 *
 * @generated from message types.OpenSearch
 */
export type OpenSearch = Message<"types.OpenSearch"> & {
  /**
   * DomainName is the name of the domain.
   *
   * @generated from field: string DomainName = 1;
   */
  DomainName: string;

  /**
   * DomainID is the ID of the domain.
   *
   * @generated from field: string DomainID = 2;
   */
  DomainID: string;

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 3;
   */
  EndpointType: string;
};

/**
 * Describes the message types.OpenSearch.
 * Use `create(OpenSearchSchema)` to create a new message.
 */
export const OpenSearchSchema: GenMessage<OpenSearch> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 21);

/**
 * DocumentDB contains AWS DocumentDB specific metadata.
 *
 * @generated from message types.DocumentDB
 */
export type DocumentDB = Message<"types.DocumentDB"> & {
  /**
   * ClusterID is the cluster identifier.
   *
   * @generated from field: string ClusterID = 1;
   */
  ClusterID: string;

  /**
   * InstanceID is the instance identifier.
   *
   * @generated from field: string InstanceID = 2;
   */
  InstanceID: string;

  /**
   * EndpointType is the type of the endpoint.
   *
   * @generated from field: string EndpointType = 3;
   */
  EndpointType: string;
};

/**
 * Describes the message types.DocumentDB.
 * Use `create(DocumentDBSchema)` to create a new message.
 */
export const DocumentDBSchema: GenMessage<DocumentDB> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 22);

/**
 * GCPCloudSQL contains parameters specific to GCP Cloud SQL databases.
 *
 * @generated from message types.GCPCloudSQL
 */
export type GCPCloudSQL = Message<"types.GCPCloudSQL"> & {
  /**
   * ProjectID is the GCP project ID the Cloud SQL instance resides in.
   *
   * @generated from field: string ProjectID = 1;
   */
  ProjectID: string;

  /**
   * InstanceID is the Cloud SQL instance ID.
   *
   * @generated from field: string InstanceID = 2;
   */
  InstanceID: string;
};

/**
 * Describes the message types.GCPCloudSQL.
 * Use `create(GCPCloudSQLSchema)` to create a new message.
 */
export const GCPCloudSQLSchema: GenMessage<GCPCloudSQL> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 23);

/**
 * Azure contains Azure specific database metadata.
 *
 * @generated from message types.Azure
 */
export type Azure = Message<"types.Azure"> & {
  /**
   * Name is the Azure database server name.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * ResourceID is the Azure fully qualified ID for the resource.
   *
   * @generated from field: string ResourceID = 2;
   */
  ResourceID: string;

  /**
   * Redis contains Azure Cache for Redis specific database metadata.
   *
   * @generated from field: types.AzureRedis Redis = 3;
   */
  Redis?: AzureRedis;

  /**
   * IsFlexiServer is true if the database is an Azure Flexible server.
   *
   * @generated from field: bool IsFlexiServer = 4;
   */
  IsFlexiServer: boolean;
};

/**
 * Describes the message types.Azure.
 * Use `create(AzureSchema)` to create a new message.
 */
export const AzureSchema: GenMessage<Azure> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 24);

/**
 * AzureRedis contains Azure Cache for Redis specific database metadata.
 *
 * @generated from message types.AzureRedis
 */
export type AzureRedis = Message<"types.AzureRedis"> & {
  /**
   * ClusteringPolicy is the clustering policy for Redis Enterprise.
   *
   * @generated from field: string ClusteringPolicy = 1;
   */
  ClusteringPolicy: string;
};

/**
 * Describes the message types.AzureRedis.
 * Use `create(AzureRedisSchema)` to create a new message.
 */
export const AzureRedisSchema: GenMessage<AzureRedis> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 25);

/**
 * AD contains Active Directory specific database configuration.
 *
 * @generated from message types.AD
 */
export type AD = Message<"types.AD"> & {
  /**
   * KeytabFile is the path to the Kerberos keytab file.
   *
   * @generated from field: string KeytabFile = 1;
   */
  KeytabFile: string;

  /**
   * Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
   *
   * @generated from field: string Krb5File = 2;
   */
  Krb5File: string;

  /**
   * Domain is the Active Directory domain the database resides in.
   *
   * @generated from field: string Domain = 3;
   */
  Domain: string;

  /**
   * SPN is the service principal name for the database.
   *
   * @generated from field: string SPN = 4;
   */
  SPN: string;

  /**
   * LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
   *
   * @generated from field: string LDAPCert = 5;
   */
  LDAPCert: string;

  /**
   * KDCHostName is the host name for a KDC for x509 Authentication.
   *
   * @generated from field: string KDCHostName = 6;
   */
  KDCHostName: string;
};

/**
 * Describes the message types.AD.
 * Use `create(ADSchema)` to create a new message.
 */
export const ADSchema: GenMessage<AD> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 26);

/**
 * DatabaseTLS contains TLS configuration options.
 *
 * @generated from message types.DatabaseTLS
 */
export type DatabaseTLS = Message<"types.DatabaseTLS"> & {
  /**
   * Mode is a TLS connection mode.
   * 0 is "verify-full"; 1 is "verify-ca", 2 is "insecure".
   *
   * @generated from field: types.DatabaseTLSMode Mode = 1;
   */
  Mode: DatabaseTLSMode;

  /**
   * CACert is an optional user provided CA certificate used for verifying
   * database TLS connection.
   *
   * @generated from field: string CACert = 2;
   */
  CACert: string;

  /**
   * ServerName allows to provide custom hostname. This value will override the
   * servername/hostname on a certificate during validation.
   *
   * @generated from field: string ServerName = 3;
   */
  ServerName: string;

  /**
   * TrustSystemCertPool allows Teleport to trust certificate authorities
   * available on the host system. If not set (by default), Teleport only
   * trusts self-signed databases with TLS certificates signed by Teleport's
   * Database Server CA or the ca_cert specified in this TLS setting. For
   * cloud-hosted databases, Teleport downloads the corresponding required CAs
   * for validation.
   *
   * @generated from field: bool TrustSystemCertPool = 4;
   */
  TrustSystemCertPool: boolean;
};

/**
 * Describes the message types.DatabaseTLS.
 * Use `create(DatabaseTLSSchema)` to create a new message.
 */
export const DatabaseTLSSchema: GenMessage<DatabaseTLS> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 27);

/**
 * MySQLOptions are additional MySQL database options.
 *
 * @generated from message types.MySQLOptions
 */
export type MySQLOptions = Message<"types.MySQLOptions"> & {
  /**
   * ServerVersion is the server version reported by DB proxy if the runtime information is
   * not available.
   *
   * @generated from field: string ServerVersion = 1;
   */
  ServerVersion: string;
};

/**
 * Describes the message types.MySQLOptions.
 * Use `create(MySQLOptionsSchema)` to create a new message.
 */
export const MySQLOptionsSchema: GenMessage<MySQLOptions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 28);

/**
 * MongoAtlas contains Atlas metadata about the database.
 *
 * @generated from message types.MongoAtlas
 */
export type MongoAtlas = Message<"types.MongoAtlas"> & {
  /**
   * Name is the Atlas database instance name.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;
};

/**
 * Describes the message types.MongoAtlas.
 * Use `create(MongoAtlasSchema)` to create a new message.
 */
export const MongoAtlasSchema: GenMessage<MongoAtlas> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 29);

/**
 * InstanceV1 represents the state of a running teleport instance independent
 * of the specific services that instance exposes.
 *
 * @generated from message types.InstanceV1
 */
export type InstanceV1 = Message<"types.InstanceV1"> & {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * @generated from field: types.InstanceSpecV1 Spec = 2;
   */
  Spec?: InstanceSpecV1;
};

/**
 * Describes the message types.InstanceV1.
 * Use `create(InstanceV1Schema)` to create a new message.
 */
export const InstanceV1Schema: GenMessage<InstanceV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 30);

/**
 * @generated from message types.InstanceSpecV1
 */
export type InstanceSpecV1 = Message<"types.InstanceSpecV1"> & {
  /**
   * Version is the version of teleport this instance most recently advertised.
   *
   * @generated from field: string Version = 1;
   */
  Version: string;

  /**
   * Services is the list of active services this instance most recently advertised.
   *
   * @generated from field: repeated string Services = 2;
   */
  Services: string[];

  /**
   * Hostname is the hostname this instance most recently advertised.
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname: string;

  /**
   * AuthID is the ID of the auth server that most recently observed this instance.
   *
   * @generated from field: string AuthID = 4;
   */
  AuthID: string;

  /**
   * LastSeen is the last time an auth server reported observing this instance.
   *
   * @generated from field: google.protobuf.Timestamp LastSeen = 5;
   */
  LastSeen?: Timestamp;

  /**
   * ControlLog is the log of recent important instance control events related to this instance. See comments
   * on the InstanceControlLogEntry type for details.
   *
   * @generated from field: repeated types.InstanceControlLogEntry ControlLog = 6;
   */
  ControlLog: InstanceControlLogEntry[];

  /**
   * ExternalUpgrader identifies the external upgrader that the instance is configured to
   * export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
   *
   * @generated from field: string ExternalUpgrader = 7;
   */
  ExternalUpgrader: string;

  /**
   * ExternalUpgraderVersion identifies the external upgrader version. Empty if no upgrader is defined.
   *
   * @generated from field: string ExternalUpgraderVersion = 8;
   */
  ExternalUpgraderVersion: string;
};

/**
 * Describes the message types.InstanceSpecV1.
 * Use `create(InstanceSpecV1Schema)` to create a new message.
 */
export const InstanceSpecV1Schema: GenMessage<InstanceSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 31);

/**
 * InstanceControlLogEntry represents an entry in a given instance's control log. The control log of
 * an instance is protected by CompareAndSwap semantics, allowing entries to function as a means of
 * synchronization as well as recordkeeping. For example, an auth server intending to trigger an upgrade
 * for a given instance can check its control log for 'upgrade-attempt' entries. If no such entry exists,
 * it can attempt to write an 'upgrade-attempt' entry of its own. If that entry successfully writes without
 * hitting a CompareFailed, the auth server knows that no other auth servers will make concurrent upgrade
 * attempts while that entry persists.
 *
 * NOTE: Due to resource size and backend throughput limitations, care should be taken to minimize the
 * use and size of instance control log entries.
 *
 *
 * @generated from message types.InstanceControlLogEntry
 */
export type InstanceControlLogEntry = Message<"types.InstanceControlLogEntry"> & {
  /**
   * Type represents the type of control log entry this is (e.g. 'upgrade-attempt').
   *
   * @generated from field: string Type = 1;
   */
  Type: string;

  /**
   * ID is a random identifier used to assist in uniquely identifying entries. This value may
   * be unique, or it may be used to associate a collection of related entries (e.g. an upgrade
   * attempt entry may use the same ID as an associated upgrade failure entry if appropriate).
   *
   * @generated from field: uint64 ID = 2;
   */
  ID: bigint;

  /**
   * Time is the time at which the event represented by this entry occurred (used in determining
   * ordering and expiry).
   *
   * @generated from field: google.protobuf.Timestamp Time = 3;
   */
  Time?: Timestamp;

  /**
   * TTL is an optional custom time to live for this control log entry. Some control log entries
   * (e.g. an upgrade failure) may require longer than normal TTLs in order to ensure visibility.
   * If a log entry's TTL results in it having an intended expiry further in the future than the
   * expiry of the enclosing Instance resource, the instance resource's expiry will be bumped
   * to accommodate preservation of the log. Because of this fact, custom entry TTLs should be
   * used sparingly, as excess usage could result in unexpected backend growth for high churn
   * clusters.
   *
   * @generated from field: int64 TTL = 4;
   */
  TTL: bigint;

  /**
   * Labels is an arbitrary collection of key-value pairs. The expected labels are determined by the
   * type of the entry. Use of labels is preferable to adding new fields in some cases in order to
   * preserve fields across auth downgrades (this is mostly relevant for the version-control system).
   *
   * @generated from field: map<string, string> Labels = 5;
   */
  Labels: { [key: string]: string };
};

/**
 * Describes the message types.InstanceControlLogEntry.
 * Use `create(InstanceControlLogEntrySchema)` to create a new message.
 */
export const InstanceControlLogEntrySchema: GenMessage<InstanceControlLogEntry> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 32);

/**
 * InstanceFilter matches instance resources.
 *
 * @generated from message types.InstanceFilter
 */
export type InstanceFilter = Message<"types.InstanceFilter"> & {
  /**
   * ServerID matches exactly one instance by server ID if specified.
   *
   * @generated from field: string ServerID = 1;
   */
  ServerID: string;

  /**
   * Version matches instance version if specified.
   *
   * @generated from field: string Version = 2;
   */
  Version: string;

  /**
   * Services matches the instance services if specified. Note that this field matches all instances which
   * expose *at least* one of the listed services. This is in contrast to service matching in version
   * directives which match instances that expose a *at most* the listed services.
   *
   * @generated from field: repeated string Services = 3;
   */
  Services: string[];

  /**
   * ExternalUpgrader matches instance upgrader if specified.
   *
   * @generated from field: string ExternalUpgrader = 4;
   */
  ExternalUpgrader: string;

  /**
   * NoExtUpgrader explicitly matches instances for which no upgrader is defined.
   *
   * @generated from field: bool NoExtUpgrader = 5;
   */
  NoExtUpgrader: boolean;

  /**
   * OlderThanVersion is an optional exclusive upper version bound.
   *
   * @generated from field: string OlderThanVersion = 6;
   */
  OlderThanVersion: string;

  /**
   * NewerThanVersion is an optional exclusive lower version bound.
   *
   * @generated from field: string NewerThanVersion = 7;
   */
  NewerThanVersion: string;
};

/**
 * Describes the message types.InstanceFilter.
 * Use `create(InstanceFilterSchema)` to create a new message.
 */
export const InstanceFilterSchema: GenMessage<InstanceFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 33);

/**
 * ServerV2 represents a Node, App, Database, Proxy or Auth server in a Teleport cluster.
 *
 * @generated from message types.ServerV2
 */
export type ServerV2 = Message<"types.ServerV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a server spec
   *
   * @generated from field: types.ServerSpecV2 Spec = 5;
   */
  Spec?: ServerSpecV2;
};

/**
 * Describes the message types.ServerV2.
 * Use `create(ServerV2Schema)` to create a new message.
 */
export const ServerV2Schema: GenMessage<ServerV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 34);

/**
 * ServerSpecV2 is a specification for V2 Server
 *
 * @generated from message types.ServerSpecV2
 */
export type ServerSpecV2 = Message<"types.ServerSpecV2"> & {
  /**
   * Addr is a host:port address where this server can be reached.
   *
   * @generated from field: string Addr = 1;
   */
  Addr: string;

  /**
   * Hostname is server hostname
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname: string;

  /**
   * CmdLabels is server dynamic labels
   *
   * @generated from field: map<string, types.CommandLabelV2> CmdLabels = 4;
   */
  CmdLabels: { [key: string]: CommandLabelV2 };

  /**
   * Rotation specifies server rotation
   *
   * @generated from field: types.Rotation Rotation = 5;
   */
  Rotation?: Rotation;

  /**
   * UseTunnel indicates that connections to this server should occur over a
   * reverse tunnel.
   *
   * @generated from field: bool UseTunnel = 6;
   */
  UseTunnel: boolean;

  /**
   * TeleportVersion is the teleport version that the server is running on
   *
   * @generated from field: string Version = 7;
   */
  Version: string;

  /**
   * PeerAddr is the address a proxy server is reachable at by its peer proxies.
   *
   * @generated from field: string PeerAddr = 11;
   */
  PeerAddr: string;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 12;
   */
  ProxyIDs: string[];

  /**
   * PublicAddrs is a list of public addresses where this server can be reached.
   *
   * @generated from field: repeated string public_addrs = 13;
   */
  publicAddrs: string[];

  /**
   * CloudMetadata contains info about the cloud instance the server is running
   * on, if any.
   *
   * @generated from field: types.CloudMetadata CloudMetadata = 14;
   */
  CloudMetadata?: CloudMetadata;
};

/**
 * Describes the message types.ServerSpecV2.
 * Use `create(ServerSpecV2Schema)` to create a new message.
 */
export const ServerSpecV2Schema: GenMessage<ServerSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 35);

/**
 * AWSInfo contains attributes to match to an EC2 instance.
 *
 * @generated from message types.AWSInfo
 */
export type AWSInfo = Message<"types.AWSInfo"> & {
  /**
   * AccountID is an AWS account ID.
   *
   * @generated from field: string AccountID = 1;
   */
  AccountID: string;

  /**
   * InstanceID is an EC2 instance ID.
   *
   * @generated from field: string InstanceID = 2;
   */
  InstanceID: string;

  /**
   * Region is the AWS EC2 Instance Region.
   *
   * @generated from field: string Region = 3;
   */
  Region: string;

  /**
   * VPCID is the AWS VPC ID where the Instance is running.
   *
   * @generated from field: string VPCID = 4;
   */
  VPCID: string;

  /**
   * Integration is the integration name that added this Node.
   * When connecting to it, it will use this integration to issue AWS API calls in order to set up the connection.
   * This includes sending an SSH Key and then opening a tunnel (EC2 Instance Connect Endpoint) so Teleport can connect to it.
   *
   * @generated from field: string Integration = 5;
   */
  Integration: string;

  /**
   * SubnetID is the Subnet ID in use by the instance.
   *
   * @generated from field: string SubnetID = 6;
   */
  SubnetID: string;
};

/**
 * Describes the message types.AWSInfo.
 * Use `create(AWSInfoSchema)` to create a new message.
 */
export const AWSInfoSchema: GenMessage<AWSInfo> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 36);

/**
 * CloudMetadata contains info about the cloud instance a server is running
 * on, if any.
 *
 * @generated from message types.CloudMetadata
 */
export type CloudMetadata = Message<"types.CloudMetadata"> & {
  /**
   * AWSInfo contains attributes to match to an EC2 instance.
   *
   * @generated from field: types.AWSInfo AWS = 1;
   */
  AWS?: AWSInfo;
};

/**
 * Describes the message types.CloudMetadata.
 * Use `create(CloudMetadataSchema)` to create a new message.
 */
export const CloudMetadataSchema: GenMessage<CloudMetadata> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 37);

/**
 * AppServerV3 represents a single proxied web app.
 *
 * @generated from message types.AppServerV3
 */
export type AppServerV3 = Message<"types.AppServerV3"> & {
  /**
   * Kind is the app server resource kind. Always "app_server".
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the app server metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the app server spec.
   *
   * @generated from field: types.AppServerSpecV3 Spec = 5;
   */
  Spec?: AppServerSpecV3;
};

/**
 * Describes the message types.AppServerV3.
 * Use `create(AppServerV3Schema)` to create a new message.
 */
export const AppServerV3Schema: GenMessage<AppServerV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 38);

/**
 * AppServerSpecV3 is the app access server spec.
 *
 * @generated from message types.AppServerSpecV3
 */
export type AppServerSpecV3 = Message<"types.AppServerSpecV3"> & {
  /**
   * Version is the Teleport version that the server is running.
   *
   * @generated from field: string Version = 1;
   */
  Version: string;

  /**
   * Hostname is the app server hostname.
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname: string;

  /**
   * HostID is the app server host uuid.
   *
   * @generated from field: string HostID = 3;
   */
  HostID: string;

  /**
   * Rotation contains the app server CA rotation information.
   *
   * @generated from field: types.Rotation Rotation = 4;
   */
  Rotation?: Rotation;

  /**
   * App is the app proxied by this app server.
   *
   * @generated from field: types.AppV3 App = 5;
   */
  App?: AppV3;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 6;
   */
  ProxyIDs: string[];
};

/**
 * Describes the message types.AppServerSpecV3.
 * Use `create(AppServerSpecV3Schema)` to create a new message.
 */
export const AppServerSpecV3Schema: GenMessage<AppServerSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 39);

/**
 * AppV3List represents a list of app resources.
 *
 * @generated from message types.AppV3List
 */
export type AppV3List = Message<"types.AppV3List"> & {
  /**
   * Apps is a list of app resources.
   *
   * @generated from field: repeated types.AppV3 Apps = 1;
   */
  Apps: AppV3[];
};

/**
 * Describes the message types.AppV3List.
 * Use `create(AppV3ListSchema)` to create a new message.
 */
export const AppV3ListSchema: GenMessage<AppV3List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 40);

/**
 * AppV3 represents an app resource.
 *
 * @generated from message types.AppV3
 */
export type AppV3 = Message<"types.AppV3"> & {
  /**
   * Kind is the app resource kind. Always "app".
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the app resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the app resource spec.
   *
   * @generated from field: types.AppSpecV3 Spec = 5;
   */
  Spec?: AppSpecV3;
};

/**
 * Describes the message types.AppV3.
 * Use `create(AppV3Schema)` to create a new message.
 */
export const AppV3Schema: GenMessage<AppV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 41);

/**
 * CORSPolicy defines the CORS policy for AppSpecV3
 *
 * @generated from message types.CORSPolicy
 */
export type CORSPolicy = Message<"types.CORSPolicy"> & {
  /**
   * allowed_origins specifies which origins are allowed to access the app.
   *
   * @generated from field: repeated string allowed_origins = 1;
   */
  allowedOrigins: string[];

  /**
   * allowed_methods specifies which methods are allowed when accessing the app.
   *
   * @generated from field: repeated string allowed_methods = 2;
   */
  allowedMethods: string[];

  /**
   * allowed_headers specifies which headers can be used when accessing the app.
   *
   * @generated from field: repeated string allowed_headers = 3;
   */
  allowedHeaders: string[];

  /**
   * allow_credentials indicates whether credentials are allowed.
   *
   * @generated from field: bool allow_credentials = 4;
   */
  allowCredentials: boolean;

  /**
   * max_age indicates how long (in seconds) the results of a preflight request can be cached.
   *
   * @generated from field: uint32 max_age = 5;
   */
  maxAge: number;

  /**
   * exposed_headers indicates which headers are made available to scripts via the browser.
   *
   * @generated from field: repeated string exposed_headers = 6;
   */
  exposedHeaders: string[];
};

/**
 * Describes the message types.CORSPolicy.
 * Use `create(CORSPolicySchema)` to create a new message.
 */
export const CORSPolicySchema: GenMessage<CORSPolicy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 42);

/**
 * AppSpecV3 is the AppV3 resource spec.
 *
 * @generated from message types.AppSpecV3
 */
export type AppSpecV3 = Message<"types.AppSpecV3"> & {
  /**
   * URI is the web app endpoint.
   *
   * @generated from field: string URI = 1;
   */
  URI: string;

  /**
   * PublicAddr is the public address the application is accessible at.
   *
   * @generated from field: string PublicAddr = 2;
   */
  PublicAddr: string;

  /**
   * DynamicLabels are the app's command labels.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 3;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 };

  /**
   * InsecureSkipVerify disables app's TLS certificate verification.
   *
   * @generated from field: bool InsecureSkipVerify = 4;
   */
  InsecureSkipVerify: boolean;

  /**
   * Rewrite is a list of rewriting rules to apply to requests and responses.
   *
   * @generated from field: types.Rewrite Rewrite = 5;
   */
  Rewrite?: Rewrite;

  /**
   * AWS contains additional options for AWS applications.
   *
   * @generated from field: types.AppAWS AWS = 6;
   */
  AWS?: AppAWS;

  /**
   * Cloud identifies the cloud instance the app represents.
   *
   * @generated from field: string Cloud = 7;
   */
  Cloud: string;

  /**
   * UserGroups are a list of user group IDs that this app is associated with.
   *
   * @generated from field: repeated string UserGroups = 8;
   */
  UserGroups: string[];

  /**
   * Integration is the integration name that must be used to access this Application.
   * Only applicable to AWS App Access.
   * If present, the Application must use the Integration's credentials instead of ambient credentials to access Cloud APIs.
   *
   * @generated from field: string Integration = 9;
   */
  Integration: string;

  /**
   * RequiredAppNames is a list of app names that are required for this app to function. Any app listed here will
   * be part of the authentication redirect flow and authenticate along side this app.
   *
   * @generated from field: repeated string RequiredAppNames = 10;
   */
  RequiredAppNames: string[];

  /**
   * CORSPolicy defines the Cross-Origin Resource Sharing settings for the app.
   *
   * @generated from field: types.CORSPolicy CORS = 11;
   */
  CORS?: CORSPolicy;
};

/**
 * Describes the message types.AppSpecV3.
 * Use `create(AppSpecV3Schema)` to create a new message.
 */
export const AppSpecV3Schema: GenMessage<AppSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 43);

/**
 * AppServerOrSAMLIdPServiceProviderV1 holds either an AppServerV3 or a SAMLIdPServiceProviderV1 resource (never both).
 * Used in application listings that request both app servers and saml apps.
 *
 * DEPRECATED: Use AppServer and SAMLIdPServiceProvider type individually.
 *
 * @generated from message types.AppServerOrSAMLIdPServiceProviderV1
 * @deprecated
 */
export type AppServerOrSAMLIdPServiceProviderV1 = Message<"types.AppServerOrSAMLIdPServiceProviderV1"> & {
  /**
   * Kind is the resource kind. Always "app_server_saml_idp_sp".
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * The AppServer or SAMLIdPServiceProvider resource.
   *
   * @generated from oneof types.AppServerOrSAMLIdPServiceProviderV1.Resource
   * @deprecated
   */
  Resource: {
    /**
     * AppServer is the AppServer resource.
     *
     * @generated from field: types.AppServerV3 AppServer = 2;
     */
    value: AppServerV3;
    case: "AppServer";
  } | {
    /**
     * SAMLIdPServiceProvider is the SAMLIdPServiceProvider resource.
     *
     * @generated from field: types.SAMLIdPServiceProviderV1 SAMLIdPServiceProvider = 3;
     */
    value: SAMLIdPServiceProviderV1;
    case: "SAMLIdPServiceProvider";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message types.AppServerOrSAMLIdPServiceProviderV1.
 * Use `create(AppServerOrSAMLIdPServiceProviderV1Schema)` to create a new message.
 * @deprecated
 */
export const AppServerOrSAMLIdPServiceProviderV1Schema: GenMessage<AppServerOrSAMLIdPServiceProviderV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 44);

/**
 * Rewrite is a list of rewriting rules to apply to requests and responses.
 *
 * @generated from message types.Rewrite
 */
export type Rewrite = Message<"types.Rewrite"> & {
  /**
   * Redirect defines a list of hosts which will be rewritten to the public
   * address of the application if they occur in the "Location" header.
   *
   * @generated from field: repeated string Redirect = 1;
   */
  Redirect: string[];

  /**
   * Headers is a list of headers to inject when passing the request over
   * to the application.
   *
   * @generated from field: repeated types.Header Headers = 2;
   */
  Headers: Header[];

  /**
   * JWTClaims configures whether roles/traits are included in the JWT token.
   *
   * @generated from field: string JWTClaims = 3;
   */
  JWTClaims: string;
};

/**
 * Describes the message types.Rewrite.
 * Use `create(RewriteSchema)` to create a new message.
 */
export const RewriteSchema: GenMessage<Rewrite> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 45);

/**
 * Header represents a single http header passed over to the proxied application.
 *
 * @generated from message types.Header
 */
export type Header = Message<"types.Header"> & {
  /**
   * Name is the http header name.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Value is the http header value.
   *
   * @generated from field: string Value = 2;
   */
  Value: string;
};

/**
 * Describes the message types.Header.
 * Use `create(HeaderSchema)` to create a new message.
 */
export const HeaderSchema: GenMessage<Header> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 46);

/**
 * CommandLabelV2 is a label that has a value as a result of the
 * output generated by running command, e.g. hostname
 *
 * @generated from message types.CommandLabelV2
 */
export type CommandLabelV2 = Message<"types.CommandLabelV2"> & {
  /**
   * Period is a time between command runs
   *
   * @generated from field: int64 Period = 1;
   */
  Period: bigint;

  /**
   * Command is a command to run
   *
   * @generated from field: repeated string Command = 2;
   */
  Command: string[];

  /**
   * Result captures standard output
   *
   * @generated from field: string Result = 3;
   */
  Result: string;
};

/**
 * Describes the message types.CommandLabelV2.
 * Use `create(CommandLabelV2Schema)` to create a new message.
 */
export const CommandLabelV2Schema: GenMessage<CommandLabelV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 47);

/**
 * AppAWS contains additional options for AWS applications.
 *
 * @generated from message types.AppAWS
 */
export type AppAWS = Message<"types.AppAWS"> & {
  /**
   * ExternalID is the AWS External ID used when assuming roles in this app.
   *
   * @generated from field: string ExternalID = 1;
   */
  ExternalID: string;
};

/**
 * Describes the message types.AppAWS.
 * Use `create(AppAWSSchema)` to create a new message.
 */
export const AppAWSSchema: GenMessage<AppAWS> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 48);

/**
 * SSHKeyPair is an SSH CA key pair.
 *
 * @generated from message types.SSHKeyPair
 */
export type SSHKeyPair = Message<"types.SSHKeyPair"> & {
  /**
   * PublicKey is the SSH public key.
   *
   * @generated from field: bytes PublicKey = 1;
   */
  PublicKey: Uint8Array;

  /**
   * PrivateKey is the SSH private key.
   *
   * @generated from field: bytes PrivateKey = 2;
   */
  PrivateKey: Uint8Array;

  /**
   * PrivateKeyType is the type of the PrivateKey.
   *
   * @generated from field: types.PrivateKeyType PrivateKeyType = 3;
   */
  PrivateKeyType: PrivateKeyType;
};

/**
 * Describes the message types.SSHKeyPair.
 * Use `create(SSHKeyPairSchema)` to create a new message.
 */
export const SSHKeyPairSchema: GenMessage<SSHKeyPair> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 49);

/**
 * TLSKeyPair is a TLS key pair
 *
 * @generated from message types.TLSKeyPair
 */
export type TLSKeyPair = Message<"types.TLSKeyPair"> & {
  /**
   * Cert is a PEM encoded TLS cert
   *
   * @generated from field: bytes Cert = 1;
   */
  Cert: Uint8Array;

  /**
   * Key is a PEM encoded TLS key
   *
   * @generated from field: bytes Key = 2;
   */
  Key: Uint8Array;

  /**
   * KeyType is the type of the Key.
   *
   * @generated from field: types.PrivateKeyType KeyType = 3;
   */
  KeyType: PrivateKeyType;
};

/**
 * Describes the message types.TLSKeyPair.
 * Use `create(TLSKeyPairSchema)` to create a new message.
 */
export const TLSKeyPairSchema: GenMessage<TLSKeyPair> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 50);

/**
 * JWTKeyPair is a PEM encoded keypair used for signing JWT tokens.
 *
 * @generated from message types.JWTKeyPair
 */
export type JWTKeyPair = Message<"types.JWTKeyPair"> & {
  /**
   * PublicKey is a PEM encoded public key.
   *
   * @generated from field: bytes PublicKey = 1;
   */
  PublicKey: Uint8Array;

  /**
   * PrivateKey is a PEM encoded private key.
   *
   * @generated from field: bytes PrivateKey = 2;
   */
  PrivateKey: Uint8Array;

  /**
   * PrivateKeyType is the type of the PrivateKey.
   *
   * @generated from field: types.PrivateKeyType PrivateKeyType = 3;
   */
  PrivateKeyType: PrivateKeyType;
};

/**
 * Describes the message types.JWTKeyPair.
 * Use `create(JWTKeyPairSchema)` to create a new message.
 */
export const JWTKeyPairSchema: GenMessage<JWTKeyPair> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 51);

/**
 * CertAuthorityV2 is version 2 resource spec for Cert Authority
 *
 * @generated from message types.CertAuthorityV2
 */
export type CertAuthorityV2 = Message<"types.CertAuthorityV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is connector metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec contains cert authority specification
   *
   * @generated from field: types.CertAuthoritySpecV2 Spec = 5;
   */
  Spec?: CertAuthoritySpecV2;
};

/**
 * Describes the message types.CertAuthorityV2.
 * Use `create(CertAuthorityV2Schema)` to create a new message.
 */
export const CertAuthorityV2Schema: GenMessage<CertAuthorityV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 52);

/**
 * CertAuthoritySpecV2 is a host or user certificate authority that
 * can check and if it has private key stored as well, sign it too
 *
 * @generated from message types.CertAuthoritySpecV2
 */
export type CertAuthoritySpecV2 = Message<"types.CertAuthoritySpecV2"> & {
  /**
   * Type is either user or host certificate authority
   *
   * @generated from field: string Type = 1;
   */
  Type: string;

  /**
   * ClusterName identifies the cluster name this authority serves.
   *
   * @generated from field: string ClusterName = 2;
   */
  ClusterName: string;

  /**
   * Roles is a list of roles assumed by users signed by this CA
   *
   * @generated from field: repeated string Roles = 5;
   */
  Roles: string[];

  /**
   * RoleMap specifies role mappings to remote roles
   *
   * @generated from field: repeated types.RoleMapping RoleMap = 6;
   */
  RoleMap: RoleMapping[];

  /**
   * Rotation is a status of the certificate authority rotation
   *
   * @generated from field: types.Rotation Rotation = 8;
   */
  Rotation?: Rotation;

  /**
   * SigningAlg is unused.
   *
   * Deprecated: SigningAlg is unused.
   *
   * @generated from field: types.CertAuthoritySpecV2.SigningAlgType SigningAlg = 9 [deprecated = true];
   * @deprecated
   */
  SigningAlg: CertAuthoritySpecV2_SigningAlgType;

  /**
   * ActiveKeys are the CA key sets used to sign any new certificates.
   *
   * @generated from field: types.CAKeySet ActiveKeys = 11;
   */
  ActiveKeys?: CAKeySet;

  /**
   * AdditionalTrustedKeys are additional CA key sets that can be used to
   * verify certificates. Certificates should be verified with
   * AdditionalTrustedKeys and ActiveKeys combined.
   *
   * @generated from field: types.CAKeySet AdditionalTrustedKeys = 12;
   */
  AdditionalTrustedKeys?: CAKeySet;
};

/**
 * Describes the message types.CertAuthoritySpecV2.
 * Use `create(CertAuthoritySpecV2Schema)` to create a new message.
 */
export const CertAuthoritySpecV2Schema: GenMessage<CertAuthoritySpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 53);

/**
 * SigningAlgType is unused.
 *
 * Deprecated: SigningAlgType is unused.
 *
 * @generated from enum types.CertAuthoritySpecV2.SigningAlgType
 * @deprecated
 */
export enum CertAuthoritySpecV2_SigningAlgType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: RSA_SHA1 = 1;
   */
  RSA_SHA1 = 1,

  /**
   * @generated from enum value: RSA_SHA2_256 = 2;
   */
  RSA_SHA2_256 = 2,

  /**
   * @generated from enum value: RSA_SHA2_512 = 3;
   */
  RSA_SHA2_512 = 3,
}

/**
 * Describes the enum types.CertAuthoritySpecV2.SigningAlgType.
 * @deprecated
 */
export const CertAuthoritySpecV2_SigningAlgTypeSchema: GenEnum<CertAuthoritySpecV2_SigningAlgType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 53, 0);

/**
 * CAKeySet is the set of CA keys.
 *
 * @generated from message types.CAKeySet
 */
export type CAKeySet = Message<"types.CAKeySet"> & {
  /**
   * SSH contains SSH CA key pairs.
   *
   * @generated from field: repeated types.SSHKeyPair SSH = 1;
   */
  SSH: SSHKeyPair[];

  /**
   * TLS contains TLS CA key/cert pairs.
   *
   * @generated from field: repeated types.TLSKeyPair TLS = 2;
   */
  TLS: TLSKeyPair[];

  /**
   * JWT contains JWT signing key pairs.
   *
   * @generated from field: repeated types.JWTKeyPair JWT = 3;
   */
  JWT: JWTKeyPair[];
};

/**
 * Describes the message types.CAKeySet.
 * Use `create(CAKeySetSchema)` to create a new message.
 */
export const CAKeySetSchema: GenMessage<CAKeySet> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 54);

/**
 * RoleMapping provides mapping of remote roles to local roles
 * for trusted clusters
 *
 * @generated from message types.RoleMapping
 */
export type RoleMapping = Message<"types.RoleMapping"> & {
  /**
   * Remote specifies remote role name to map from
   *
   * @generated from field: string Remote = 1;
   */
  Remote: string;

  /**
   * Local specifies local roles to map to
   *
   * @generated from field: repeated string Local = 2;
   */
  Local: string[];
};

/**
 * Describes the message types.RoleMapping.
 * Use `create(RoleMappingSchema)` to create a new message.
 */
export const RoleMappingSchema: GenMessage<RoleMapping> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 55);

/**
 * ProvisionTokenV1 is a provisioning token V1
 *
 * @generated from message types.ProvisionTokenV1
 */
export type ProvisionTokenV1 = Message<"types.ProvisionTokenV1"> & {
  /**
   * Roles is a list of roles associated with the token,
   * that will be converted to metadata in the SSH and X509
   * certificates issued to the user of the token
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[];

  /**
   * Expires is a global expiry time header can be set on any resource in the
   * system.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 2;
   */
  Expires?: Timestamp;

  /**
   * Token is a token name
   *
   * @generated from field: string Token = 3;
   */
  Token: string;
};

/**
 * Describes the message types.ProvisionTokenV1.
 * Use `create(ProvisionTokenV1Schema)` to create a new message.
 */
export const ProvisionTokenV1Schema: GenMessage<ProvisionTokenV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 56);

/**
 * ProvisionTokenV2 specifies provisioning token
 *
 * @generated from message types.ProvisionTokenV2
 */
export type ProvisionTokenV2 = Message<"types.ProvisionTokenV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a provisioning token V2 spec
   *
   * @generated from field: types.ProvisionTokenSpecV2 Spec = 5;
   */
  Spec?: ProvisionTokenSpecV2;
};

/**
 * Describes the message types.ProvisionTokenV2.
 * Use `create(ProvisionTokenV2Schema)` to create a new message.
 */
export const ProvisionTokenV2Schema: GenMessage<ProvisionTokenV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 57);

/**
 * ProvisionTokenV2List is a list of provisioning tokens.
 *
 * @generated from message types.ProvisionTokenV2List
 */
export type ProvisionTokenV2List = Message<"types.ProvisionTokenV2List"> & {
  /**
   * ProvisionTokens is a list of provisioning tokens.
   *
   * @generated from field: repeated types.ProvisionTokenV2 ProvisionTokens = 1;
   */
  ProvisionTokens: ProvisionTokenV2[];
};

/**
 * Describes the message types.ProvisionTokenV2List.
 * Use `create(ProvisionTokenV2ListSchema)` to create a new message.
 */
export const ProvisionTokenV2ListSchema: GenMessage<ProvisionTokenV2List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 58);

/**
 * TokenRule is a rule that a joining node must match in order to use the
 * associated token.
 *
 * @generated from message types.TokenRule
 */
export type TokenRule = Message<"types.TokenRule"> & {
  /**
   * AWSAccount is the AWS account ID.
   *
   * @generated from field: string AWSAccount = 1;
   */
  AWSAccount: string;

  /**
   * AWSRegions is used for the EC2 join method and is a list of AWS regions a
   * node is allowed to join from.
   *
   * @generated from field: repeated string AWSRegions = 2;
   */
  AWSRegions: string[];

  /**
   * AWSRole is used for the EC2 join method and is the ARN of the AWS
   * role that the auth server will assume in order to call the ec2 API.
   *
   * @generated from field: string AWSRole = 3;
   */
  AWSRole: string;

  /**
   * AWSARN is used for the IAM join method, the AWS identity of joining nodes
   * must match this ARN. Supports wildcards "*" and "?".
   *
   * @generated from field: string AWSARN = 4;
   */
  AWSARN: string;
};

/**
 * Describes the message types.TokenRule.
 * Use `create(TokenRuleSchema)` to create a new message.
 */
export const TokenRuleSchema: GenMessage<TokenRule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 59);

/**
 * ProvisionTokenSpecV2 is a specification for V2 token
 *
 * @generated from message types.ProvisionTokenSpecV2
 */
export type ProvisionTokenSpecV2 = Message<"types.ProvisionTokenSpecV2"> & {
  /**
   * Roles is a list of roles associated with the token,
   * that will be converted to metadata in the SSH and X509
   * certificates issued to the user of the token
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[];

  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.TokenRule Allow = 2;
   */
  Allow: TokenRule[];

  /**
   * AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used
   * to join the cluster with this token.
   *
   * @generated from field: int64 AWSIIDTTL = 3;
   */
  AWSIIDTTL: bigint;

  /**
   * JoinMethod is the joining method required in order to use this token.
   * Supported joining methods include: azure, circleci, ec2, gcp, github, gitlab, iam, kubernetes, spacelift, token, tpm
   *
   * @generated from field: string JoinMethod = 4;
   */
  JoinMethod: string;

  /**
   * BotName is the name of the bot this token grants access to, if any
   *
   * @generated from field: string BotName = 5;
   */
  BotName: string;

  /**
   * SuggestedLabels is a set of labels that resources should set when using this token to enroll
   * themselves in the cluster.
   * Currently, only node-join scripts create a configuration according to the suggestion.
   *
   * @generated from field: wrappers.LabelValues SuggestedLabels = 6;
   */
  SuggestedLabels?: LabelValues;

  /**
   * GitHub allows the configuration of options specific to the "github" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2GitHub GitHub = 7;
   */
  GitHub?: ProvisionTokenSpecV2GitHub;

  /**
   * CircleCI allows the configuration of options specific to the "circleci" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2CircleCI CircleCI = 8;
   */
  CircleCI?: ProvisionTokenSpecV2CircleCI;

  /**
   * SuggestedAgentMatcherLabels is a set of labels to be used by agents to match on resources.
   * When an agent uses this token, the agent should monitor resources that match those labels.
   * For databases, this means adding the labels to `db_service.resources.labels`.
   * Currently, only node-join scripts create a configuration according to the suggestion.
   *
   * @generated from field: wrappers.LabelValues SuggestedAgentMatcherLabels = 9;
   */
  SuggestedAgentMatcherLabels?: LabelValues;

  /**
   * Kubernetes allows the configuration of options specific to the "kubernetes" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2Kubernetes Kubernetes = 10;
   */
  Kubernetes?: ProvisionTokenSpecV2Kubernetes;

  /**
   * Azure allows the configuration of options specific to the "azure" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2Azure Azure = 11;
   */
  Azure?: ProvisionTokenSpecV2Azure;

  /**
   * GitLab allows the configuration of options specific to the "gitlab" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2GitLab GitLab = 12;
   */
  GitLab?: ProvisionTokenSpecV2GitLab;

  /**
   * GCP allows the configuration of options specific to the "gcp" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2GCP GCP = 13;
   */
  GCP?: ProvisionTokenSpecV2GCP;

  /**
   * Spacelift allows the configuration of options specific to the "spacelift" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2Spacelift Spacelift = 14;
   */
  Spacelift?: ProvisionTokenSpecV2Spacelift;

  /**
   * TPM allows the configuration of options specific to the "tpm" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2TPM TPM = 15;
   */
  TPM?: ProvisionTokenSpecV2TPM;

  /**
   * TerraformCloud allows the configuration of options specific to the "terraform_cloud" join method.
   *
   * @generated from field: types.ProvisionTokenSpecV2TerraformCloud TerraformCloud = 16;
   */
  TerraformCloud?: ProvisionTokenSpecV2TerraformCloud;
};

/**
 * Describes the message types.ProvisionTokenSpecV2.
 * Use `create(ProvisionTokenSpecV2Schema)` to create a new message.
 */
export const ProvisionTokenSpecV2Schema: GenMessage<ProvisionTokenSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 60);

/**
 * ProvisionTokenSpecV2TPM contains the TPM-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2TPM
 */
export type ProvisionTokenSpecV2TPM = Message<"types.ProvisionTokenSpecV2TPM"> & {
  /**
   * Allow is a list of Rules, the presented delegated identity must match one
   * allow rule to permit joining.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2TPM.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2TPM_Rule[];

  /**
   * EKCertAllowedCAs is a list of CA certificates that will be used to validate
   * TPM EKCerts.
   * When specified, joining TPMs must present an EKCert signed by one of the
   * specified CAs. TPMs that do not present an EKCert will be not permitted to
   * join.
   * When unspecified, TPMs will be allowed to join with either an EKCert or an
   * EKPubHash.
   *
   * @generated from field: repeated string EKCertAllowedCAs = 2;
   */
  EKCertAllowedCAs: string[];
};

/**
 * Describes the message types.ProvisionTokenSpecV2TPM.
 * Use `create(ProvisionTokenSpecV2TPMSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2TPMSchema: GenMessage<ProvisionTokenSpecV2TPM> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 61);

/**
 * @generated from message types.ProvisionTokenSpecV2TPM.Rule
 */
export type ProvisionTokenSpecV2TPM_Rule = Message<"types.ProvisionTokenSpecV2TPM.Rule"> & {
  /**
   * Description is a human-readable description of the rule. It has no
   * bearing on whether or not a TPM is allowed to join, but can be used
   * to associate a rule with a specific host (e.g the asset tag of the server
   * in which the TPM resides).
   * Example: "build-server-100"
   *
   * @generated from field: string Description = 1;
   */
  Description: string;

  /**
   * EKPublicHash is the SHA256 hash of the EKPub marshaled in PKIX format
   * and encoded in hexadecimal. This value will also be checked when a TPM
   * has submitted an EKCert, and the public key in the EKCert will be used
   * for this check.
   * Example: d4b45864d9d6fabfc568d74f26c35ababde2105337d7af9a6605e1c56c891aa6
   *
   * @generated from field: string EKPublicHash = 4;
   */
  EKPublicHash: string;

  /**
   * EKCertificateSerial is the serial number of the EKCert in hexadecimal
   * with colon separated nibbles. This value will not be checked when a TPM
   * does not have an EKCert configured.
   * Example: 73:df:dc:bd:af:ef:8a:d8:15:2e:96:71:7a:3e:7f:a4
   *
   * @generated from field: string EKCertificateSerial = 5;
   */
  EKCertificateSerial: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2TPM.Rule.
 * Use `create(ProvisionTokenSpecV2TPM_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2TPM_RuleSchema: GenMessage<ProvisionTokenSpecV2TPM_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 61, 0);

/**
 * ProvisionTokenSpecV2Github contains the GitHub-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2GitHub
 */
export type ProvisionTokenSpecV2GitHub = Message<"types.ProvisionTokenSpecV2GitHub"> & {
  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2GitHub.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2GitHub_Rule[];

  /**
   * EnterpriseServerHost allows joining from runners associated with a
   * GitHub Enterprise Server instance. When unconfigured, tokens will be
   * validated against github.com, but when configured to the host of a GHES
   * instance, then the tokens will be validated against host.
   *
   * This value should be the hostname of the GHES instance, and should not
   * include the scheme or a path. The instance must be accessible over HTTPS
   * at this hostname and the certificate must be trusted by the Auth Server.
   *
   * @generated from field: string EnterpriseServerHost = 2;
   */
  EnterpriseServerHost: string;

  /**
   * EnterpriseSlug allows the slug of a GitHub Enterprise organisation to be
   * included in the expected issuer of the OIDC tokens. This is for
   * compatibility with the `include_enterprise_slug` option in GHE.
   *
   * This field should be set to the slug of your enterprise if this is enabled. If
   * this is not enabled, then this field must be left empty. This field cannot
   * be specified if `enterprise_server_host` is specified.
   *
   * See https://docs.github.com/en/enterprise-cloud@latest/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-issuer-value-for-an-enterprise
   * for more information about customized issuer values.
   *
   * @generated from field: string EnterpriseSlug = 3;
   */
  EnterpriseSlug: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2GitHub.
 * Use `create(ProvisionTokenSpecV2GitHubSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2GitHubSchema: GenMessage<ProvisionTokenSpecV2GitHub> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 62);

/**
 * Rule includes fields mapped from `lib/githubactions.IDToken`
 * Not all fields should be included, only ones that we expect to be useful
 * when trying to create rules around which workflows should be allowed to
 * authenticate against a cluster.
 *
 * @generated from message types.ProvisionTokenSpecV2GitHub.Rule
 */
export type ProvisionTokenSpecV2GitHub_Rule = Message<"types.ProvisionTokenSpecV2GitHub.Rule"> & {
  /**
   * Sub also known as Subject is a string that roughly uniquely identifies
   * the workload. The format of this varies depending on the type of
   * github action run.
   *
   * @generated from field: string Sub = 1;
   */
  Sub: string;

  /**
   * The repository from where the workflow is running.
   * This includes the name of the owner e.g `gravitational/teleport`
   *
   * @generated from field: string Repository = 2;
   */
  Repository: string;

  /**
   * The name of the organization in which the repository is stored.
   *
   * @generated from field: string RepositoryOwner = 3;
   */
  RepositoryOwner: string;

  /**
   * The name of the workflow.
   *
   * @generated from field: string Workflow = 4;
   */
  Workflow: string;

  /**
   * The name of the environment used by the job.
   *
   * @generated from field: string Environment = 5;
   */
  Environment: string;

  /**
   * The personal account that initiated the workflow run.
   *
   * @generated from field: string Actor = 6;
   */
  Actor: string;

  /**
   * The git ref that triggered the workflow run.
   *
   * @generated from field: string Ref = 7;
   */
  Ref: string;

  /**
   * The type of ref, for example: "branch".
   *
   * @generated from field: string RefType = 8;
   */
  RefType: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2GitHub.Rule.
 * Use `create(ProvisionTokenSpecV2GitHub_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2GitHub_RuleSchema: GenMessage<ProvisionTokenSpecV2GitHub_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 62, 0);

/**
 * ProvisionTokenSpecV2GitLab contains the GitLab-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2GitLab
 */
export type ProvisionTokenSpecV2GitLab = Message<"types.ProvisionTokenSpecV2GitLab"> & {
  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2GitLab.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2GitLab_Rule[];

  /**
   * Domain is the domain of your GitLab instance. This will default to
   * `gitlab.com` - but can be set to the domain of your self-hosted GitLab
   * e.g `gitlab.example.com`.
   *
   * @generated from field: string Domain = 2;
   */
  Domain: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2GitLab.
 * Use `create(ProvisionTokenSpecV2GitLabSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2GitLabSchema: GenMessage<ProvisionTokenSpecV2GitLab> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 63);

/**
 * @generated from message types.ProvisionTokenSpecV2GitLab.Rule
 */
export type ProvisionTokenSpecV2GitLab_Rule = Message<"types.ProvisionTokenSpecV2GitLab.Rule"> & {
  /**
   * Sub roughly uniquely identifies the workload. Example:
   * `project_path:mygroup/my-project:ref_type:branch:ref:main`
   * project_path:GROUP/PROJECT:ref_type:TYPE:ref:BRANCH_NAME
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string Sub = 1;
   */
  Sub: string;

  /**
   * Ref allows access to be limited to jobs triggered by a specific git ref.
   * Ensure this is used in combination with ref_type.
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string Ref = 2;
   */
  Ref: string;

  /**
   * RefType allows access to be limited to jobs triggered by a specific git
   * ref type. Example:
   * `branch` or `tag`
   *
   * @generated from field: string RefType = 3;
   */
  RefType: string;

  /**
   * NamespacePath is used to limit access to jobs in a group or user's
   * projects.
   * Example:
   * `mygroup`
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string NamespacePath = 4;
   */
  NamespacePath: string;

  /**
   * ProjectPath is used to limit access to jobs belonging to an individual
   * project. Example:
   * `mygroup/myproject`
   *
   * This field supports simple "glob-style" matching:
   * - Use '*' to match zero or more characters.
   * - Use '?' to match any single character.
   *
   * @generated from field: string ProjectPath = 5;
   */
  ProjectPath: string;

  /**
   * PipelineSource limits access by the job pipeline source type.
   * https://docs.gitlab.com/ee/ci/jobs/job_control.html#common-if-clauses-for-rules
   * Example: `web`
   *
   * @generated from field: string PipelineSource = 6;
   */
  PipelineSource: string;

  /**
   * Environment limits access by the environment the job deploys to
   * (if one is associated)
   *
   * @generated from field: string Environment = 7;
   */
  Environment: string;

  /**
   * UserLogin is the username of the user executing the job
   *
   * @generated from field: string UserLogin = 8;
   */
  UserLogin: string;

  /**
   * UserID is the ID of the user executing the job
   *
   * @generated from field: string UserID = 9;
   */
  UserID: string;

  /**
   * UserEmail is the email of the user executing the job
   *
   * @generated from field: string UserEmail = 10;
   */
  UserEmail: string;

  /**
   * RefProtected is true if the Git ref is protected, false otherwise.
   *
   * @generated from field: types.BoolValue RefProtected = 11;
   */
  RefProtected?: BoolValue;

  /**
   * EnvironmentProtected is true if the Git ref is protected, false otherwise.
   *
   * @generated from field: types.BoolValue EnvironmentProtected = 12;
   */
  EnvironmentProtected?: BoolValue;

  /**
   * CIConfigSHA is the git commit SHA for the ci_config_ref_uri.
   *
   * @generated from field: string CIConfigSHA = 13;
   */
  CIConfigSHA: string;

  /**
   * CIConfigRefURI is the ref path to the top-level pipeline definition, for example,
   * gitlab.example.com/my-group/my-project//.gitlab-ci.yml@refs/heads/main.
   *
   * @generated from field: string CIConfigRefURI = 14;
   */
  CIConfigRefURI: string;

  /**
   * DeploymentTier is the deployment tier of the environment the job specifies
   *
   * @generated from field: string DeploymentTier = 15;
   */
  DeploymentTier: string;

  /**
   * ProjectVisibility is the visibility of the project where the pipeline is running.
   * Can be internal, private, or public.
   *
   * @generated from field: string ProjectVisibility = 16;
   */
  ProjectVisibility: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2GitLab.Rule.
 * Use `create(ProvisionTokenSpecV2GitLab_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2GitLab_RuleSchema: GenMessage<ProvisionTokenSpecV2GitLab_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 63, 0);

/**
 * ProvisionTokenSpecV2CircleCI contains the CircleCI-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2CircleCI
 */
export type ProvisionTokenSpecV2CircleCI = Message<"types.ProvisionTokenSpecV2CircleCI"> & {
  /**
   * Allow is a list of TokenRules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2CircleCI.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2CircleCI_Rule[];

  /**
   * @generated from field: string OrganizationID = 2;
   */
  OrganizationID: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2CircleCI.
 * Use `create(ProvisionTokenSpecV2CircleCISchema)` to create a new message.
 */
export const ProvisionTokenSpecV2CircleCISchema: GenMessage<ProvisionTokenSpecV2CircleCI> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 64);

/**
 * @generated from message types.ProvisionTokenSpecV2CircleCI.Rule
 */
export type ProvisionTokenSpecV2CircleCI_Rule = Message<"types.ProvisionTokenSpecV2CircleCI.Rule"> & {
  /**
   * @generated from field: string ProjectID = 1;
   */
  ProjectID: string;

  /**
   * @generated from field: string ContextID = 2;
   */
  ContextID: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2CircleCI.Rule.
 * Use `create(ProvisionTokenSpecV2CircleCI_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2CircleCI_RuleSchema: GenMessage<ProvisionTokenSpecV2CircleCI_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 64, 0);

/**
 * ProvisionTokenSpecV2Spacelift contains the Spacelift-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2Spacelift
 */
export type ProvisionTokenSpecV2Spacelift = Message<"types.ProvisionTokenSpecV2Spacelift"> & {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2Spacelift.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2Spacelift_Rule[];

  /**
   * Hostname is the hostname of the Spacelift tenant that tokens
   * will originate from. E.g `example.app.spacelift.io`
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2Spacelift.
 * Use `create(ProvisionTokenSpecV2SpaceliftSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2SpaceliftSchema: GenMessage<ProvisionTokenSpecV2Spacelift> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 65);

/**
 * @generated from message types.ProvisionTokenSpecV2Spacelift.Rule
 */
export type ProvisionTokenSpecV2Spacelift_Rule = Message<"types.ProvisionTokenSpecV2Spacelift.Rule"> & {
  /**
   * SpaceID is the ID of the space in which the run that owns the token was
   * executed.
   *
   * @generated from field: string SpaceID = 1;
   */
  SpaceID: string;

  /**
   * CallerID is the ID of the caller, ie. the stack or module that generated
   * the run.
   *
   * @generated from field: string CallerID = 2;
   */
  CallerID: string;

  /**
   * CallerType is the type of the caller, ie. the entity that owns the run -
   * either `stack` or `module`.
   *
   * @generated from field: string CallerType = 3;
   */
  CallerType: string;

  /**
   * Scope is the scope of the token - either `read` or `write`.
   * See https://docs.spacelift.io/integrations/cloud-providers/oidc/#about-scopes
   *
   * @generated from field: string Scope = 4;
   */
  Scope: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2Spacelift.Rule.
 * Use `create(ProvisionTokenSpecV2Spacelift_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2Spacelift_RuleSchema: GenMessage<ProvisionTokenSpecV2Spacelift_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 65, 0);

/**
 * ProvisionTokenSpecV2Kubernetes contains the Kubernetes-specific part of the
 * ProvisionTokenSpecV2
 *
 * @generated from message types.ProvisionTokenSpecV2Kubernetes
 */
export type ProvisionTokenSpecV2Kubernetes = Message<"types.ProvisionTokenSpecV2Kubernetes"> & {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2Kubernetes.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2Kubernetes_Rule[];

  /**
   * Type controls which behavior should be used for validating the Kubernetes
   * Service Account token. Support values:
   * - `in_cluster`
   * - `static_jwks`
   * If unset, this defaults to `in_cluster`.
   *
   * @generated from field: string Type = 2;
   */
  Type: string;

  /**
   * StaticJWKS is the configuration specific to the `static_jwks` type.
   *
   * @generated from field: types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig StaticJWKS = 3;
   */
  StaticJWKS?: ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig;
};

/**
 * Describes the message types.ProvisionTokenSpecV2Kubernetes.
 * Use `create(ProvisionTokenSpecV2KubernetesSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2KubernetesSchema: GenMessage<ProvisionTokenSpecV2Kubernetes> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 66);

/**
 * @generated from message types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig
 */
export type ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig = Message<"types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig"> & {
  /**
   * JWKS should be the JSON Web Key Set formatted public keys of that the
   * Kubernetes Cluster uses to sign service account tokens.
   * This can be fetched from /openid/v1/jwks on the Kubernetes API Server.
   *
   * @generated from field: string JWKS = 1;
   */
  JWKS: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig.
 * Use `create(ProvisionTokenSpecV2Kubernetes_StaticJWKSConfigSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2Kubernetes_StaticJWKSConfigSchema: GenMessage<ProvisionTokenSpecV2Kubernetes_StaticJWKSConfig> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 66, 0);

/**
 * Rule is a set of properties the Kubernetes-issued token might have to be
 * allowed to use this ProvisionToken
 *
 * @generated from message types.ProvisionTokenSpecV2Kubernetes.Rule
 */
export type ProvisionTokenSpecV2Kubernetes_Rule = Message<"types.ProvisionTokenSpecV2Kubernetes.Rule"> & {
  /**
   * ServiceAccount is the namespaced name of the Kubernetes service account.
   * Its format is "namespace:service-account".
   *
   * @generated from field: string ServiceAccount = 1;
   */
  ServiceAccount: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2Kubernetes.Rule.
 * Use `create(ProvisionTokenSpecV2Kubernetes_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2Kubernetes_RuleSchema: GenMessage<ProvisionTokenSpecV2Kubernetes_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 66, 1);

/**
 * ProvisionTokenSpecV2Azure contains the Azure-specific part of the
 * ProvisionTokenSpecV2.
 *
 * @generated from message types.ProvisionTokenSpecV2Azure
 */
export type ProvisionTokenSpecV2Azure = Message<"types.ProvisionTokenSpecV2Azure"> & {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2Azure.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2Azure_Rule[];
};

/**
 * Describes the message types.ProvisionTokenSpecV2Azure.
 * Use `create(ProvisionTokenSpecV2AzureSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2AzureSchema: GenMessage<ProvisionTokenSpecV2Azure> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 67);

/**
 * Rule is a set of properties the Azure-issued token might have to be
 * allowed to use this ProvisionToken.
 *
 * @generated from message types.ProvisionTokenSpecV2Azure.Rule
 */
export type ProvisionTokenSpecV2Azure_Rule = Message<"types.ProvisionTokenSpecV2Azure.Rule"> & {
  /**
   * Subscription is the Azure subscription.
   *
   * @generated from field: string Subscription = 1;
   */
  Subscription: string;

  /**
   * ResourceGroups is a list of Azure resource groups the node is allowed
   * to join from.
   *
   * @generated from field: repeated string ResourceGroups = 2;
   */
  ResourceGroups: string[];
};

/**
 * Describes the message types.ProvisionTokenSpecV2Azure.Rule.
 * Use `create(ProvisionTokenSpecV2Azure_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2Azure_RuleSchema: GenMessage<ProvisionTokenSpecV2Azure_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 67, 0);

/**
 * ProvisionTokenSpecV2GCP contains the GCP-specific part of the
 * ProvisionTokenSpecV2.
 *
 * @generated from message types.ProvisionTokenSpecV2GCP
 */
export type ProvisionTokenSpecV2GCP = Message<"types.ProvisionTokenSpecV2GCP"> & {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2GCP.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2GCP_Rule[];
};

/**
 * Describes the message types.ProvisionTokenSpecV2GCP.
 * Use `create(ProvisionTokenSpecV2GCPSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2GCPSchema: GenMessage<ProvisionTokenSpecV2GCP> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 68);

/**
 * Rule is a set of properties the GCP-ussued token might have to be allowed
 * to use this ProvisionToken.
 *
 * @generated from message types.ProvisionTokenSpecV2GCP.Rule
 */
export type ProvisionTokenSpecV2GCP_Rule = Message<"types.ProvisionTokenSpecV2GCP.Rule"> & {
  /**
   * ProjectIDs is a list of project IDs (e.g. `<example-id-123456>`).
   *
   * @generated from field: repeated string ProjectIDs = 1;
   */
  ProjectIDs: string[];

  /**
   * Locations is a list of regions (e.g. "us-west1") and/or zones (e.g.
   * "us-west1-b").
   *
   * @generated from field: repeated string Locations = 2;
   */
  Locations: string[];

  /**
   * ServiceAccounts is a list of service account emails (e.g.
   * `<project-number>-compute@developer.gserviceaccount.com`).
   *
   * @generated from field: repeated string ServiceAccounts = 3;
   */
  ServiceAccounts: string[];
};

/**
 * Describes the message types.ProvisionTokenSpecV2GCP.Rule.
 * Use `create(ProvisionTokenSpecV2GCP_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2GCP_RuleSchema: GenMessage<ProvisionTokenSpecV2GCP_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 68, 0);

/**
 * ProvisionTokenSpecV2Terraform contains Terraform-specific parts of the
 * ProvisionTokenSpecV2.
 *
 * @generated from message types.ProvisionTokenSpecV2TerraformCloud
 */
export type ProvisionTokenSpecV2TerraformCloud = Message<"types.ProvisionTokenSpecV2TerraformCloud"> & {
  /**
   * Allow is a list of Rules, nodes using this token must match one
   * allow rule to use this token.
   *
   * @generated from field: repeated types.ProvisionTokenSpecV2TerraformCloud.Rule Allow = 1;
   */
  Allow: ProvisionTokenSpecV2TerraformCloud_Rule[];

  /**
   * Audience is the JWT audience as configured in the
   * TFC_WORKLOAD_IDENTITY_AUDIENCE(_$TAG) variable in Terraform Cloud. If
   * unset, defaults to the Teleport cluster name.
   * For example, if `TFC_WORKLOAD_IDENTITY_AUDIENCE_TELEPORT=foo` is set in
   * Terraform Cloud, this value should be `foo`. If the variable is set to
   * match the cluster name, it does not need to be set here.
   *
   * @generated from field: string Audience = 2;
   */
  Audience: string;

  /**
   * Hostname is the hostname of the Terraform Enterprise instance expected to
   * issue JWTs allowed by this token. This may be unset for regular Terraform
   * Cloud use, in which case it will be assumed to be `app.terraform.io`.
   * Otherwise, it must both match the `iss` (issuer) field included in JWTs,
   * and provide standard JWKS endpoints.
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2TerraformCloud.
 * Use `create(ProvisionTokenSpecV2TerraformCloudSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2TerraformCloudSchema: GenMessage<ProvisionTokenSpecV2TerraformCloud> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 69);

/**
 * Rule is a set of properties the Terraform-issued token might have to be
 * allowed to use this ProvisionToken.
 *
 * @generated from message types.ProvisionTokenSpecV2TerraformCloud.Rule
 */
export type ProvisionTokenSpecV2TerraformCloud_Rule = Message<"types.ProvisionTokenSpecV2TerraformCloud.Rule"> & {
  /**
   * OrganizationID is the ID of the HCP Terraform organization. At least
   * one organization value is required, either ID or name.
   *
   * @generated from field: string OrganizationID = 1;
   */
  OrganizationID: string;

  /**
   * OrganizationName is the human-readable name of the HCP Terraform
   * organization. At least one organization value is required, either ID or
   * name.
   *
   * @generated from field: string OrganizationName = 2;
   */
  OrganizationName: string;

  /**
   * ProjectID is the ID of the HCP Terraform project. At least one project or
   * workspace value is required, either ID or name.
   *
   * @generated from field: string ProjectID = 3;
   */
  ProjectID: string;

  /**
   * ProjectName is the human-readable name for the HCP Terraform project. At
   * least one project or workspace value is required, either ID or name.
   *
   * @generated from field: string ProjectName = 4;
   */
  ProjectName: string;

  /**
   * WorkspaceID is the ID of the HCP Terraform workspace. At least one
   * project or workspace value is required, either ID or name.
   *
   * @generated from field: string WorkspaceID = 5;
   */
  WorkspaceID: string;

  /**
   * WorkspaceName is the human-readable name of the HCP Terraform workspace.
   * At least one project or workspace value is required, either ID or name.
   *
   * @generated from field: string WorkspaceName = 6;
   */
  WorkspaceName: string;

  /**
   * RunPhase is the phase of the run the token was issued for, e.g. `plan` or
   * `apply`
   *
   * @generated from field: string RunPhase = 7;
   */
  RunPhase: string;
};

/**
 * Describes the message types.ProvisionTokenSpecV2TerraformCloud.Rule.
 * Use `create(ProvisionTokenSpecV2TerraformCloud_RuleSchema)` to create a new message.
 */
export const ProvisionTokenSpecV2TerraformCloud_RuleSchema: GenMessage<ProvisionTokenSpecV2TerraformCloud_Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 69, 0);

/**
 * StaticTokensV2 implements the StaticTokens interface.
 *
 * @generated from message types.StaticTokensV2
 */
export type StaticTokensV2 = Message<"types.StaticTokensV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a provisioning token V2 spec
   *
   * @generated from field: types.StaticTokensSpecV2 Spec = 5;
   */
  Spec?: StaticTokensSpecV2;
};

/**
 * Describes the message types.StaticTokensV2.
 * Use `create(StaticTokensV2Schema)` to create a new message.
 */
export const StaticTokensV2Schema: GenMessage<StaticTokensV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 70);

/**
 * StaticTokensSpecV2 is the actual data we care about for StaticTokensSpecV2.
 *
 * @generated from message types.StaticTokensSpecV2
 */
export type StaticTokensSpecV2 = Message<"types.StaticTokensSpecV2"> & {
  /**
   * StaticTokens is a list of tokens that can be used to add nodes to the
   * cluster.
   *
   * @generated from field: repeated types.ProvisionTokenV1 StaticTokens = 1;
   */
  StaticTokens: ProvisionTokenV1[];
};

/**
 * Describes the message types.StaticTokensSpecV2.
 * Use `create(StaticTokensSpecV2Schema)` to create a new message.
 */
export const StaticTokensSpecV2Schema: GenMessage<StaticTokensSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 71);

/**
 * ClusterNameV2 implements the ClusterName interface.
 *
 * @generated from message types.ClusterNameV2
 */
export type ClusterNameV2 = Message<"types.ClusterNameV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a cluster name V2 spec
   *
   * @generated from field: types.ClusterNameSpecV2 Spec = 5;
   */
  Spec?: ClusterNameSpecV2;
};

/**
 * Describes the message types.ClusterNameV2.
 * Use `create(ClusterNameV2Schema)` to create a new message.
 */
export const ClusterNameV2Schema: GenMessage<ClusterNameV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 72);

/**
 * ClusterNameSpecV2 is the actual data we care about for ClusterName.
 *
 * @generated from message types.ClusterNameSpecV2
 */
export type ClusterNameSpecV2 = Message<"types.ClusterNameSpecV2"> & {
  /**
   * ClusterName is the name of the cluster. Changing this value once the
   * cluster is setup can and will cause catastrophic problems.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName: string;

  /**
   * ClusterID is the unique cluster ID that is set once during the first
   * auth server startup.
   *
   * @generated from field: string ClusterID = 2;
   */
  ClusterID: string;
};

/**
 * Describes the message types.ClusterNameSpecV2.
 * Use `create(ClusterNameSpecV2Schema)` to create a new message.
 */
export const ClusterNameSpecV2Schema: GenMessage<ClusterNameSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 73);

/**
 * ClusterAuditConfigV2 represents audit log settings in the cluster.
 *
 * @generated from message types.ClusterAuditConfigV2
 */
export type ClusterAuditConfigV2 = Message<"types.ClusterAuditConfigV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is a resource version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a ClusterAuditConfig specification
   *
   * @generated from field: types.ClusterAuditConfigSpecV2 Spec = 5;
   */
  Spec?: ClusterAuditConfigSpecV2;
};

/**
 * Describes the message types.ClusterAuditConfigV2.
 * Use `create(ClusterAuditConfigV2Schema)` to create a new message.
 */
export const ClusterAuditConfigV2Schema: GenMessage<ClusterAuditConfigV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 74);

/**
 * ClusterAuditConfigSpecV2 is the actual data we care about
 * for ClusterAuditConfig.
 *
 * @generated from message types.ClusterAuditConfigSpecV2
 */
export type ClusterAuditConfigSpecV2 = Message<"types.ClusterAuditConfigSpecV2"> & {
  /**
   * Type is audit backend type
   *
   * @generated from field: string Type = 1;
   */
  Type: string;

  /**
   * Region is a region setting for audit sessions used by cloud providers
   *
   * @generated from field: string Region = 2;
   */
  Region: string;

  /**
   * AuditSessionsURI is a parameter where to upload sessions
   *
   * @generated from field: string AuditSessionsURI = 3;
   */
  AuditSessionsURI: string;

  /**
   * AuditEventsURI is a parameter with all supported outputs
   * for audit events
   *
   * @generated from field: wrappers.StringValues AuditEventsURI = 4;
   */
  AuditEventsURI?: StringValues;

  /**
   * EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
   *
   * @generated from field: bool EnableContinuousBackups = 6;
   */
  EnableContinuousBackups: boolean;

  /**
   * EnableAutoScaling is used to enable (or disable) auto scaling policy.
   *
   * @generated from field: bool EnableAutoScaling = 7;
   */
  EnableAutoScaling: boolean;

  /**
   * ReadMaxCapacity is the maximum provisioned read capacity.
   *
   * @generated from field: int64 ReadMaxCapacity = 8;
   */
  ReadMaxCapacity: bigint;

  /**
   * ReadMinCapacity is the minimum provisioned read capacity.
   *
   * @generated from field: int64 ReadMinCapacity = 9;
   */
  ReadMinCapacity: bigint;

  /**
   * ReadTargetValue is the ratio of consumed read to provisioned capacity.
   *
   * @generated from field: double ReadTargetValue = 10;
   */
  ReadTargetValue: number;

  /**
   * WriteMaxCapacity is the maximum provisioned write capacity.
   *
   * @generated from field: int64 WriteMaxCapacity = 11;
   */
  WriteMaxCapacity: bigint;

  /**
   * WriteMinCapacity is the minimum provisioned write capacity.
   *
   * @generated from field: int64 WriteMinCapacity = 12;
   */
  WriteMinCapacity: bigint;

  /**
   * WriteTargetValue is the ratio of consumed write to provisioned capacity.
   *
   * @generated from field: double WriteTargetValue = 13;
   */
  WriteTargetValue: number;

  /**
   * RetentionPeriod is the retention period for audit events.
   *
   * @generated from field: int64 RetentionPeriod = 14;
   */
  RetentionPeriod: bigint;

  /**
   * UseFIPSEndpoint configures AWS endpoints to use FIPS.
   *
   * @generated from field: types.ClusterAuditConfigSpecV2.FIPSEndpointState UseFIPSEndpoint = 15;
   */
  UseFIPSEndpoint: ClusterAuditConfigSpecV2_FIPSEndpointState;
};

/**
 * Describes the message types.ClusterAuditConfigSpecV2.
 * Use `create(ClusterAuditConfigSpecV2Schema)` to create a new message.
 */
export const ClusterAuditConfigSpecV2Schema: GenMessage<ClusterAuditConfigSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 75);

/**
 * FIPSEndpointState represents an AWS FIPS endpoint state.
 *
 * @generated from enum types.ClusterAuditConfigSpecV2.FIPSEndpointState
 */
export enum ClusterAuditConfigSpecV2_FIPSEndpointState {
  /**
   * FIPS_UNSET allows setting FIPS state for AWS S3/Dynamo using configuration files or
   * environment variables
   *
   * @generated from enum value: FIPS_UNSET = 0;
   */
  FIPS_UNSET = 0,

  /**
   * FIPS_ENABLED explicitly enables FIPS support for AWS S3/Dynamo
   *
   * @generated from enum value: FIPS_ENABLED = 1;
   */
  FIPS_ENABLED = 1,

  /**
   * FIPS_DISABLED explicitly disables FIPS support for AWS S3/Dynamo
   *
   * @generated from enum value: FIPS_DISABLED = 2;
   */
  FIPS_DISABLED = 2,
}

/**
 * Describes the enum types.ClusterAuditConfigSpecV2.FIPSEndpointState.
 */
export const ClusterAuditConfigSpecV2_FIPSEndpointStateSchema: GenEnum<ClusterAuditConfigSpecV2_FIPSEndpointState> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 75, 0);

/**
 * ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
 *
 * @generated from message types.ClusterNetworkingConfigV2
 */
export type ClusterNetworkingConfigV2 = Message<"types.ClusterNetworkingConfigV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a ClusterNetworkingConfig specification
   *
   * @generated from field: types.ClusterNetworkingConfigSpecV2 Spec = 5;
   */
  Spec?: ClusterNetworkingConfigSpecV2;
};

/**
 * Describes the message types.ClusterNetworkingConfigV2.
 * Use `create(ClusterNetworkingConfigV2Schema)` to create a new message.
 */
export const ClusterNetworkingConfigV2Schema: GenMessage<ClusterNetworkingConfigV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 76);

/**
 * ClusterNetworkingConfigSpecV2 is the actual data we care about
 * for ClusterNetworkingConfig.
 *
 * @generated from message types.ClusterNetworkingConfigSpecV2
 */
export type ClusterNetworkingConfigSpecV2 = Message<"types.ClusterNetworkingConfigSpecV2"> & {
  /**
   * ClientIdleTimeout sets global cluster default setting for client idle
   * timeouts.
   *
   * @generated from field: int64 ClientIdleTimeout = 1;
   */
  ClientIdleTimeout: bigint;

  /**
   * KeepAliveInterval is the interval at which the server sends keep-alive messages
   * to the client.
   *
   * @generated from field: int64 KeepAliveInterval = 2;
   */
  KeepAliveInterval: bigint;

  /**
   * KeepAliveCountMax is the number of keep-alive messages that can be
   * missed before the server disconnects the connection to the client.
   *
   * @generated from field: int64 KeepAliveCountMax = 3;
   */
  KeepAliveCountMax: bigint;

  /**
   * SessionControlTimeout is the session control lease expiry and defines
   * the upper limit of how long a node may be out of contact with the auth
   * server before it begins terminating controlled sessions.
   *
   * @generated from field: int64 SessionControlTimeout = 4;
   */
  SessionControlTimeout: bigint;

  /**
   * ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
   *
   * @generated from field: string ClientIdleTimeoutMessage = 5;
   */
  ClientIdleTimeoutMessage: string;

  /**
   * WebIdleTimeout sets global cluster default setting for the web UI idle
   * timeouts.
   *
   * @generated from field: int64 WebIdleTimeout = 6;
   */
  WebIdleTimeout: bigint;

  /**
   * ProxyListenerMode is proxy listener mode used by Teleport Proxies.
   * 0 is "separate"; 1 is "multiplex".
   *
   * @generated from field: types.ProxyListenerMode ProxyListenerMode = 7;
   */
  ProxyListenerMode: ProxyListenerMode;

  /**
   * RoutingStrategy determines the strategy used to route to nodes.
   * 0 is "unambiguous_match"; 1 is "most_recent".
   *
   * @generated from field: types.RoutingStrategy RoutingStrategy = 8;
   */
  RoutingStrategy: RoutingStrategy;

  /**
   * TunnelStrategyV1 determines the tunnel strategy used in the cluster.
   *
   * @generated from field: types.TunnelStrategyV1 TunnelStrategy = 9;
   */
  TunnelStrategy?: TunnelStrategyV1;

  /**
   * ProxyPingInterval defines in which interval the TLS routing ping message
   * should be sent. This is applicable only when using ping-wrapped
   * connections, regular TLS routing connections are not affected.
   *
   * @generated from field: int64 ProxyPingInterval = 10;
   */
  ProxyPingInterval: bigint;

  /**
   * AssistCommandExecutionWorkers determines the number of workers that will
   * execute arbitrary Assist commands on servers in parallel
   *
   * @generated from field: int32 AssistCommandExecutionWorkers = 11;
   */
  AssistCommandExecutionWorkers: number;

  /**
   * CaseInsensitiveRouting causes proxies to use case-insensitive hostname matching.
   *
   * @generated from field: bool CaseInsensitiveRouting = 12;
   */
  CaseInsensitiveRouting: boolean;

  /**
   * SSHDialTimeout is a custom dial timeout used when establishing
   * SSH connections. If not set, the default timeout of 30s will be used.
   *
   * @generated from field: int64 SSHDialTimeout = 13;
   */
  SSHDialTimeout: bigint;
};

/**
 * Describes the message types.ClusterNetworkingConfigSpecV2.
 * Use `create(ClusterNetworkingConfigSpecV2Schema)` to create a new message.
 */
export const ClusterNetworkingConfigSpecV2Schema: GenMessage<ClusterNetworkingConfigSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 77);

/**
 * TunnelStrategyV1 defines possible tunnel strategy types.
 *
 * @generated from message types.TunnelStrategyV1
 */
export type TunnelStrategyV1 = Message<"types.TunnelStrategyV1"> & {
  /**
   * @generated from oneof types.TunnelStrategyV1.Strategy
   */
  Strategy: {
    /**
     * @generated from field: types.AgentMeshTunnelStrategy AgentMesh = 1;
     */
    value: AgentMeshTunnelStrategy;
    case: "AgentMesh";
  } | {
    /**
     * @generated from field: types.ProxyPeeringTunnelStrategy ProxyPeering = 2;
     */
    value: ProxyPeeringTunnelStrategy;
    case: "ProxyPeering";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message types.TunnelStrategyV1.
 * Use `create(TunnelStrategyV1Schema)` to create a new message.
 */
export const TunnelStrategyV1Schema: GenMessage<TunnelStrategyV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 78);

/**
 * AgentMeshTunnelStrategy requires reverse tunnels to dial every proxy.
 *
 * @generated from message types.AgentMeshTunnelStrategy
 */
export type AgentMeshTunnelStrategy = Message<"types.AgentMeshTunnelStrategy"> & {
};

/**
 * Describes the message types.AgentMeshTunnelStrategy.
 * Use `create(AgentMeshTunnelStrategySchema)` to create a new message.
 */
export const AgentMeshTunnelStrategySchema: GenMessage<AgentMeshTunnelStrategy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 79);

/**
 * ProxyPeeringTunnelStrategy requires reverse tunnels to dial a fixed number of proxies.
 *
 * @generated from message types.ProxyPeeringTunnelStrategy
 */
export type ProxyPeeringTunnelStrategy = Message<"types.ProxyPeeringTunnelStrategy"> & {
  /**
   * @generated from field: int64 AgentConnectionCount = 1;
   */
  AgentConnectionCount: bigint;
};

/**
 * Describes the message types.ProxyPeeringTunnelStrategy.
 * Use `create(ProxyPeeringTunnelStrategySchema)` to create a new message.
 */
export const ProxyPeeringTunnelStrategySchema: GenMessage<ProxyPeeringTunnelStrategy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 80);

/**
 * SessionRecordingConfigV2 contains session recording configuration.
 *
 * @generated from message types.SessionRecordingConfigV2
 */
export type SessionRecordingConfigV2 = Message<"types.SessionRecordingConfigV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are:`v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a SessionRecordingConfig specification
   *
   * @generated from field: types.SessionRecordingConfigSpecV2 Spec = 5;
   */
  Spec?: SessionRecordingConfigSpecV2;
};

/**
 * Describes the message types.SessionRecordingConfigV2.
 * Use `create(SessionRecordingConfigV2Schema)` to create a new message.
 */
export const SessionRecordingConfigV2Schema: GenMessage<SessionRecordingConfigV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 81);

/**
 * SessionRecordingConfigSpecV2 is the actual data we care about
 * for SessionRecordingConfig.
 *
 * @generated from message types.SessionRecordingConfigSpecV2
 */
export type SessionRecordingConfigSpecV2 = Message<"types.SessionRecordingConfigSpecV2"> & {
  /**
   * Mode controls where (or if) the session is recorded.
   *
   * @generated from field: string Mode = 1;
   */
  Mode: string;

  /**
   * ProxyChecksHostKeys is used to control if the proxy will check host keys
   * when in recording mode.
   *
   * @generated from field: types.BoolValue ProxyChecksHostKeys = 2;
   */
  ProxyChecksHostKeys?: BoolValue;
};

/**
 * Describes the message types.SessionRecordingConfigSpecV2.
 * Use `create(SessionRecordingConfigSpecV2Schema)` to create a new message.
 */
export const SessionRecordingConfigSpecV2Schema: GenMessage<SessionRecordingConfigSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 82);

/**
 * AuthPreferenceV2 implements the AuthPreference interface.
 *
 * @generated from message types.AuthPreferenceV2
 */
export type AuthPreferenceV2 = Message<"types.AuthPreferenceV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an AuthPreference specification
   *
   * @generated from field: types.AuthPreferenceSpecV2 Spec = 5;
   */
  Spec?: AuthPreferenceSpecV2;
};

/**
 * Describes the message types.AuthPreferenceV2.
 * Use `create(AuthPreferenceV2Schema)` to create a new message.
 */
export const AuthPreferenceV2Schema: GenMessage<AuthPreferenceV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 83);

/**
 * AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.
 *
 * @generated from message types.AuthPreferenceSpecV2
 */
export type AuthPreferenceSpecV2 = Message<"types.AuthPreferenceSpecV2"> & {
  /**
   * Type is the type of authentication.
   *
   * @generated from field: string Type = 1;
   */
  Type: string;

  /**
   * SecondFactor is the type of second factor.
   *
   * @generated from field: string SecondFactor = 2;
   */
  SecondFactor: string;

  /**
   * ConnectorName is the name of the OIDC or SAML connector. If this value is
   * not set the first connector in the backend will be used.
   *
   * @generated from field: string ConnectorName = 3;
   */
  ConnectorName: string;

  /**
   * U2F are the settings for the U2F device.
   *
   * @generated from field: types.U2F U2F = 4;
   */
  U2F?: U2F;

  /**
   * DisconnectExpiredCert provides disconnect expired certificate setting -
   * if true, connections with expired client certificates will get disconnected
   *
   * @generated from field: types.BoolValue DisconnectExpiredCert = 6;
   */
  DisconnectExpiredCert?: BoolValue;

  /**
   * AllowLocalAuth is true if local authentication is enabled.
   *
   * @generated from field: types.BoolValue AllowLocalAuth = 7;
   */
  AllowLocalAuth?: BoolValue;

  /**
   * @generated from field: string MessageOfTheDay = 8;
   */
  MessageOfTheDay: string;

  /**
   * LockingMode is the cluster-wide locking mode default.
   *
   * @generated from field: string LockingMode = 9;
   */
  LockingMode: string;

  /**
   * Webauthn are the settings for server-side Web Authentication support.
   *
   * @generated from field: types.Webauthn Webauthn = 10;
   */
  Webauthn?: Webauthn;

  /**
   * AllowPasswordless enables/disables passwordless support.
   * Passwordless requires Webauthn to work.
   * Defaults to true if the Webauthn is configured, defaults to false
   * otherwise.
   *
   * @generated from field: types.BoolValue AllowPasswordless = 11;
   */
  AllowPasswordless?: BoolValue;

  /**
   * RequireMFAType is the type of MFA requirement enforced for this cluster.
   * 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
   * 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
   *
   * @generated from field: types.RequireMFAType RequireMFAType = 12;
   */
  RequireMFAType: RequireMFAType;

  /**
   * DeviceTrust holds settings related to trusted device verification.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.DeviceTrust DeviceTrust = 13;
   */
  DeviceTrust?: DeviceTrust;

  /**
   * IDP is a set of options related to accessing IdPs within Teleport.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.IdPOptions IDP = 14;
   */
  IDP?: IdPOptions;

  /**
   * AllowHeadless enables/disables headless support.
   * Headless authentication requires Webauthn to work.
   * Defaults to true if the Webauthn is configured, defaults to false
   * otherwise.
   *
   * @generated from field: types.BoolValue AllowHeadless = 15;
   */
  AllowHeadless?: BoolValue;

  /**
   * DefaultSessionTTL is the TTL to use for user certs when
   * an explicit TTL is not requested.
   *
   * @generated from field: int64 DefaultSessionTTL = 16;
   */
  DefaultSessionTTL: bigint;

  /**
   * Okta is a set of options related to the Okta service in Teleport.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.OktaOptions Okta = 17;
   */
  Okta?: OktaOptions;

  /**
   * TODO(Joerger): DELETE IN 17.0.0
   * Deprecated, replaced by HardwareKey settings.
   *
   * @generated from field: string PIVSlot = 18 [deprecated = true];
   * @deprecated
   */
  PIVSlot: string;

  /**
   * HardwareKey are the settings for hardware key support.
   *
   * @generated from field: types.HardwareKey HardwareKey = 19;
   */
  HardwareKey?: HardwareKey;

  /**
   * SignatureAlgorithmSuite is the configured signature algorithm suite for the cluster.
   * The current default value is "legacy". This field is not yet fully supported.
   *
   * @generated from field: types.SignatureAlgorithmSuite signature_algorithm_suite = 20;
   */
  signatureAlgorithmSuite: SignatureAlgorithmSuite;
};

/**
 * Describes the message types.AuthPreferenceSpecV2.
 * Use `create(AuthPreferenceSpecV2Schema)` to create a new message.
 */
export const AuthPreferenceSpecV2Schema: GenMessage<AuthPreferenceSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 84);

/**
 * U2F defines settings for U2F device.
 * Deprecated: U2F is transparently converted to WebAuthn by Teleport. Prefer
 * using WebAuthn instead.
 *
 * @generated from message types.U2F
 */
export type U2F = Message<"types.U2F"> & {
  /**
   * AppID returns the application ID for universal second factor.
   *
   * @generated from field: string AppID = 1;
   */
  AppID: string;

  /**
   * Facets returns the facets for universal second factor.
   * Deprecated: Kept for backwards compatibility reasons, but Facets have no
   * effect since Teleport v10, when Webauthn replaced the U2F implementation.
   *
   * @generated from field: repeated string Facets = 2;
   */
  Facets: string[];

  /**
   * DeviceAttestationCAs contains the trusted attestation CAs for U2F
   * devices.
   *
   * @generated from field: repeated string DeviceAttestationCAs = 3;
   */
  DeviceAttestationCAs: string[];
};

/**
 * Describes the message types.U2F.
 * Use `create(U2FSchema)` to create a new message.
 */
export const U2FSchema: GenMessage<U2F> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 85);

/**
 * Webauthn defines user-visible settings for server-side Web Authentication
 * support.
 *
 * @generated from message types.Webauthn
 */
export type Webauthn = Message<"types.Webauthn"> & {
  /**
   * RPID is the ID of the Relying Party.
   * It should be set to the domain name of the Teleport installation.
   *
   * IMPORTANT: RPID must never change in the lifetime of the cluster, because
   * it's recorded in the registration data on the WebAuthn device. If the
   * RPID changes, all existing WebAuthn key registrations will become invalid
   * and all users who use WebAuthn as the second factor will need to
   * re-register.
   *
   * @generated from field: string RPID = 1;
   */
  RPID: string;

  /**
   * Allow list of device attestation CAs in PEM format.
   * If present, only devices whose attestation certificates match the
   * certificates specified here may be registered (existing registrations are
   * unchanged).
   * If supplied in conjunction with AttestationDeniedCAs, then both
   * conditions need to be true for registration to be allowed (the device
   * MUST match an allowed CA and MUST NOT match a denied CA).
   * By default all devices are allowed.
   *
   * @generated from field: repeated string AttestationAllowedCAs = 2;
   */
  AttestationAllowedCAs: string[];

  /**
   * Deny list of device attestation CAs in PEM format.
   * If present, only devices whose attestation certificates don't match the
   * certificates specified here may be registered (existing registrations are
   * unchanged).
   * If supplied in conjunction with AttestationAllowedCAs, then both
   * conditions need to be true for registration to be allowed (the device
   * MUST match an allowed CA and MUST NOT match a denied CA).
   * By default no devices are denied.
   *
   * @generated from field: repeated string AttestationDeniedCAs = 3;
   */
  AttestationDeniedCAs: string[];
};

/**
 * Describes the message types.Webauthn.
 * Use `create(WebauthnSchema)` to create a new message.
 */
export const WebauthnSchema: GenMessage<Webauthn> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 86);

/**
 * DeviceTrust holds settings related to trusted device verification.
 * Requires Teleport Enterprise.
 *
 * @generated from message types.DeviceTrust
 */
export type DeviceTrust = Message<"types.DeviceTrust"> & {
  /**
   * Mode of verification for trusted devices.
   *
   * The following modes are supported:
   *
   * - "off": disables both device authentication and authorization.
   * - "optional": allows both device authentication and authorization, but
   *   doesn't enforce the presence of device extensions for sensitive
   *   endpoints.
   * - "required": enforces the presence of device extensions for sensitive
   *   endpoints.
   *
   * Mode is always "off" for OSS.
   * Defaults to "optional" for Enterprise.
   *
   * @generated from field: string Mode = 1;
   */
  Mode: string;

  /**
   * Enable device auto-enroll.
   * Auto-enroll lets any user issue a device enrollment token for a known
   * device that is not already enrolled.
   * `tsh` takes advantage of auto-enroll to automatically enroll devices on
   * user login, when appropriate.
   * The effective cluster Mode still applies: AutoEnroll=true is meaningless if
   * Mode="off".
   *
   * @generated from field: bool AutoEnroll = 2;
   */
  AutoEnroll: boolean;

  /**
   * Allow list of EKCert CAs in PEM format.
   * If present, only TPM devices that present an EKCert that is signed by a
   * CA specified here may be enrolled (existing enrollments are
   * unchanged).
   *
   * If not present, then the CA of TPM EKCerts will not be checked during
   * enrollment, this allows any device to enroll.
   *
   * @generated from field: repeated string EKCertAllowedCAs = 3;
   */
  EKCertAllowedCAs: string[];
};

/**
 * Describes the message types.DeviceTrust.
 * Use `create(DeviceTrustSchema)` to create a new message.
 */
export const DeviceTrustSchema: GenMessage<DeviceTrust> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 87);

/**
 * HardwareKey holds settings related to hardware key support.
 * Requires Teleport Enterprise.
 *
 * @generated from message types.HardwareKey
 */
export type HardwareKey = Message<"types.HardwareKey"> & {
  /**
   * PIVSlot is a PIV slot that Teleport clients should use instead of the
   * default based on private key policy. For example, "9a" or "9e".
   *
   * @generated from field: string PIVSlot = 1;
   */
  PIVSlot: string;

  /**
   * SerialNumberValidation holds settings for hardware key serial number validation.
   * By default, serial number validation is disabled.
   *
   * @generated from field: types.HardwareKeySerialNumberValidation SerialNumberValidation = 2;
   */
  SerialNumberValidation?: HardwareKeySerialNumberValidation;
};

/**
 * Describes the message types.HardwareKey.
 * Use `create(HardwareKeySchema)` to create a new message.
 */
export const HardwareKeySchema: GenMessage<HardwareKey> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 88);

/**
 * @generated from message types.HardwareKeySerialNumberValidation
 */
export type HardwareKeySerialNumberValidation = Message<"types.HardwareKeySerialNumberValidation"> & {
  /**
   * Enabled indicates whether hardware key serial number validation is enabled.
   *
   * @generated from field: bool Enabled = 1;
   */
  Enabled: boolean;

  /**
   * SerialNumberTraitName is an optional custom user trait name for hardware key
   * serial numbers to replace the default: "hardware_key_serial_numbers".
   *
   * Note: Values for this user trait should be a comma-separated list of serial numbers,
   * or a list of comm-separated lists. e.g ["123", "345,678"]
   *
   * @generated from field: string SerialNumberTraitName = 2;
   */
  SerialNumberTraitName: string;
};

/**
 * Describes the message types.HardwareKeySerialNumberValidation.
 * Use `create(HardwareKeySerialNumberValidationSchema)` to create a new message.
 */
export const HardwareKeySerialNumberValidationSchema: GenMessage<HardwareKeySerialNumberValidation> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 89);

/**
 * Namespace represents namespace resource specification
 *
 * @generated from message types.Namespace
 */
export type Namespace = Message<"types.Namespace"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a namespace spec
   *
   * @generated from field: types.NamespaceSpec Spec = 5;
   */
  Spec?: NamespaceSpec;
};

/**
 * Describes the message types.Namespace.
 * Use `create(NamespaceSchema)` to create a new message.
 */
export const NamespaceSchema: GenMessage<Namespace> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 90);

/**
 * NamespaceSpec is a namespace specification
 *
 * @generated from message types.NamespaceSpec
 */
export type NamespaceSpec = Message<"types.NamespaceSpec"> & {
};

/**
 * Describes the message types.NamespaceSpec.
 * Use `create(NamespaceSpecSchema)` to create a new message.
 */
export const NamespaceSpecSchema: GenMessage<NamespaceSpec> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 91);

/**
 * @generated from message types.UserTokenV3
 */
export type UserTokenV3 = Message<"types.UserTokenV3"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is a resource sub kind, used to define the type of user token.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an resource specification
   *
   * @generated from field: types.UserTokenSpecV3 Spec = 5;
   */
  Spec?: UserTokenSpecV3;
};

/**
 * Describes the message types.UserTokenV3.
 * Use `create(UserTokenV3Schema)` to create a new message.
 */
export const UserTokenV3Schema: GenMessage<UserTokenV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 92);

/**
 * @generated from message types.UserTokenSpecV3
 */
export type UserTokenSpecV3 = Message<"types.UserTokenSpecV3"> & {
  /**
   * User is user name associated with this token
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * URL is this token URL
   *
   * @generated from field: string URL = 2;
   */
  URL: string;

  /**
   * Usage is an optional field that provides more information about how this token will be used.
   *
   * @generated from field: types.UserTokenUsage Usage = 3;
   */
  Usage: UserTokenUsage;

  /**
   * Created holds information about when the token was created
   *
   * @generated from field: google.protobuf.Timestamp Created = 4;
   */
  Created?: Timestamp;
};

/**
 * Describes the message types.UserTokenSpecV3.
 * Use `create(UserTokenSpecV3Schema)` to create a new message.
 */
export const UserTokenSpecV3Schema: GenMessage<UserTokenSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 93);

/**
 * @generated from message types.UserTokenSecretsV3
 */
export type UserTokenSecretsV3 = Message<"types.UserTokenSecretsV3"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an resource specification
   *
   * @generated from field: types.UserTokenSecretsSpecV3 Spec = 5;
   */
  Spec?: UserTokenSecretsSpecV3;
};

/**
 * Describes the message types.UserTokenSecretsV3.
 * Use `create(UserTokenSecretsV3Schema)` to create a new message.
 */
export const UserTokenSecretsV3Schema: GenMessage<UserTokenSecretsV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 94);

/**
 * @generated from message types.UserTokenSecretsSpecV3
 */
export type UserTokenSecretsSpecV3 = Message<"types.UserTokenSecretsSpecV3"> & {
  /**
   * OTPKey is is a secret value of one time password secret generator
   *
   * @generated from field: string OTPKey = 1;
   */
  OTPKey: string;

  /**
   * OTPKey is is a secret value of one time password secret generator
   *
   * @generated from field: string QRCode = 2;
   */
  QRCode: string;

  /**
   * Created holds information about when the token was created
   *
   * @generated from field: google.protobuf.Timestamp Created = 3;
   */
  Created?: Timestamp;
};

/**
 * Describes the message types.UserTokenSecretsSpecV3.
 * Use `create(UserTokenSecretsSpecV3Schema)` to create a new message.
 */
export const UserTokenSecretsSpecV3Schema: GenMessage<UserTokenSecretsSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 95);

/**
 * AccessRequest represents an access request resource specification
 *
 * @generated from message types.AccessRequestV3
 */
export type AccessRequestV3 = Message<"types.AccessRequestV3"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is AccessRequest metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an AccessRequest specification
   *
   * @generated from field: types.AccessRequestSpecV3 Spec = 5;
   */
  Spec?: AccessRequestSpecV3;
};

/**
 * Describes the message types.AccessRequestV3.
 * Use `create(AccessRequestV3Schema)` to create a new message.
 */
export const AccessRequestV3Schema: GenMessage<AccessRequestV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 96);

/**
 * AccessReviewThreshold describes a filter used to match access reviews,
 * as well as approval/denial counts which trigger state-transitions.  This type
 * can be used to describe policies such as "can be approved by 2 admins"
 * or "can be denied by any non-contractor".
 *
 * @generated from message types.AccessReviewThreshold
 */
export type AccessReviewThreshold = Message<"types.AccessReviewThreshold"> & {
  /**
   * Name is the optional human-readable name of the threshold.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Filter is an optional predicate used to determine which reviews
   * count toward this threshold.
   *
   * @generated from field: string Filter = 2;
   */
  Filter: string;

  /**
   * Approve is the number of matching approvals needed for state-transition.
   *
   * @generated from field: uint32 Approve = 3;
   */
  Approve: number;

  /**
   * Deny is the number of denials needed for state-transition.
   *
   * @generated from field: uint32 Deny = 4;
   */
  Deny: number;
};

/**
 * Describes the message types.AccessReviewThreshold.
 * Use `create(AccessReviewThresholdSchema)` to create a new message.
 */
export const AccessReviewThresholdSchema: GenMessage<AccessReviewThreshold> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 97);

/**
 * PromotedAccessList is a minimal access list representation used for
 * promoting access requests to access lists.
 *
 * @generated from message types.PromotedAccessList
 */
export type PromotedAccessList = Message<"types.PromotedAccessList"> & {
  /**
   * Name is the name of the access list.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Title is the title of the access list.
   *
   * @generated from field: string Title = 2;
   */
  Title: string;
};

/**
 * Describes the message types.PromotedAccessList.
 * Use `create(PromotedAccessListSchema)` to create a new message.
 */
export const PromotedAccessListSchema: GenMessage<PromotedAccessList> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 98);

/**
 * AccessReview is a review to be applied to an access request.
 *
 * @generated from message types.AccessReview
 */
export type AccessReview = Message<"types.AccessReview"> & {
  /**
   * Author is the teleport username of the review author.
   *
   * @generated from field: string Author = 1;
   */
  Author: string;

  /**
   * Roles is a list used for role-subselection (not yet fully supported).
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[];

  /**
   * ProposedState is the proposed state (must be APPROVED or DENIED).
   *
   * @generated from field: types.RequestState ProposedState = 3;
   */
  ProposedState: RequestState;

  /**
   * Reason is an optional human-readable reason for why the above state
   * is being proposed.
   *
   * @generated from field: string Reason = 4;
   */
  Reason: string;

  /**
   * Created is the time at which the review was created.
   *
   * @generated from field: google.protobuf.Timestamp Created = 5;
   */
  Created?: Timestamp;

  /**
   * Annotations is the proposed value of the request's resolve_annotations field.
   *
   * @generated from field: wrappers.LabelValues Annotations = 6;
   */
  Annotations?: LabelValues;

  /**
   * ThresholdIndexes stores the indexes of thresholds which this review matches
   * (internal use only).
   *
   * @generated from field: repeated uint32 ThresholdIndexes = 7;
   */
  ThresholdIndexes: number[];

  /**
   * AccessList is the access list that this request was promoted to.
   * This field is only populated when the request is in the PROMOTED state.
   *
   * @generated from field: types.PromotedAccessList accessList = 9;
   */
  accessList?: PromotedAccessList;

  /**
   * AssumeStartTime is the time the requested roles can be assumed.
   *
   * @generated from field: google.protobuf.Timestamp AssumeStartTime = 10;
   */
  AssumeStartTime?: Timestamp;
};

/**
 * Describes the message types.AccessReview.
 * Use `create(AccessReviewSchema)` to create a new message.
 */
export const AccessReviewSchema: GenMessage<AccessReview> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 99);

/**
 * AccessReviewSubmission encodes the necessary parameters for submitting
 * a new access review.
 *
 * @generated from message types.AccessReviewSubmission
 */
export type AccessReviewSubmission = Message<"types.AccessReviewSubmission"> & {
  /**
   * RequestID is the unique ID of the request to be reviewed.
   *
   * @generated from field: string RequestID = 1;
   */
  RequestID: string;

  /**
   * Review is the review to be applied.
   *
   * @generated from field: types.AccessReview Review = 2;
   */
  Review?: AccessReview;
};

/**
 * Describes the message types.AccessReviewSubmission.
 * Use `create(AccessReviewSubmissionSchema)` to create a new message.
 */
export const AccessReviewSubmissionSchema: GenMessage<AccessReviewSubmission> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 100);

/**
 * ThresholdIndexSet encodes a list of threshold indexes. One of the listed thresholds
 * must pass for the set to be considered to have passed (i.e. this is an `or` operator).
 *
 * @generated from message types.ThresholdIndexSet
 */
export type ThresholdIndexSet = Message<"types.ThresholdIndexSet"> & {
  /**
   * Indexes are the indexes of thresholds which relate to the role.
   *
   * @generated from field: repeated uint32 Indexes = 1;
   */
  Indexes: number[];
};

/**
 * Describes the message types.ThresholdIndexSet.
 * Use `create(ThresholdIndexSetSchema)` to create a new message.
 */
export const ThresholdIndexSetSchema: GenMessage<ThresholdIndexSet> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 101);

/**
 * ThresholdIndexSets is a list of threshold index sets.  Each of the individual
 * sets must pass (i.e. this is an `and` operator).
 *
 * @generated from message types.ThresholdIndexSets
 */
export type ThresholdIndexSets = Message<"types.ThresholdIndexSets"> & {
  /**
   * Sets are the sets that make up this group.
   *
   * @generated from field: repeated types.ThresholdIndexSet Sets = 1;
   */
  Sets: ThresholdIndexSet[];
};

/**
 * Describes the message types.ThresholdIndexSets.
 * Use `create(ThresholdIndexSetsSchema)` to create a new message.
 */
export const ThresholdIndexSetsSchema: GenMessage<ThresholdIndexSets> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 102);

/**
 * AccessRequestSpec is the specification for AccessRequest
 *
 * @generated from message types.AccessRequestSpecV3
 */
export type AccessRequestSpecV3 = Message<"types.AccessRequestSpecV3"> & {
  /**
   * User is the name of the user to whom the roles will be applied.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * Roles is the name of the roles being requested.
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[];

  /**
   * State is the current state of this access request.
   *
   * @generated from field: types.RequestState State = 3;
   */
  State: RequestState;

  /**
   * Created encodes the time at which the request was registered with the auth
   * server.
   *
   * @generated from field: google.protobuf.Timestamp Created = 4;
   */
  Created?: Timestamp;

  /**
   * Expires constrains the maximum lifetime of any login session for which this
   * request is active.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 5;
   */
  Expires?: Timestamp;

  /**
   * RequestReason is an optional message explaining the reason for the request.
   *
   * @generated from field: string RequestReason = 6;
   */
  RequestReason: string;

  /**
   * ResolveReason is an optional message explaining the reason for the resolution
   * of the request (approval, denial, etc...).
   *
   * @generated from field: string ResolveReason = 7;
   */
  ResolveReason: string;

  /**
   * ResolveAnnotations is a set of arbitrary values received from plugins or other
   * resolving parties during approval/denial.  Importantly, these annotations are
   * included in the access_request.update event, allowing plugins to propagate
   * arbitrary structured data to the audit log.
   *
   * @generated from field: wrappers.LabelValues ResolveAnnotations = 8;
   */
  ResolveAnnotations?: LabelValues;

  /**
   * SystemAnnotations is a set of programmatically generated annotations attached
   * to pending access requests by teleport.  These annotations are generated by
   * applying variable interpolation to the RoleConditions.Request.Annotations block
   * of a user's role(s).  These annotations serve as a mechanism for administrators
   * to pass extra information to plugins when they process pending access requests.
   *
   * @generated from field: wrappers.LabelValues SystemAnnotations = 9;
   */
  SystemAnnotations?: LabelValues;

  /**
   * Thresholds is a list of review thresholds relevant to this request.  Order must be
   * preserved, as thresholds are referenced by index (internal use only).
   *
   * @generated from field: repeated types.AccessReviewThreshold Thresholds = 10;
   */
  Thresholds: AccessReviewThreshold[];

  /**
   * RoleThresholdMapping encodes the relationship between the requested roles and
   * the review threshold requirements for the given role (internal use only).
   * By storing a representation of which thresholds must pass for each requested role, we
   * both eliminate the need to cache the requestor's roles directly, and allow future
   * versions of teleport to become smarter about calculating more granular requirements
   * in a backwards-compatible manner (i.e. calculation can become smarter in minor releases).
   * Storing this relationship on the request is necessary in order to avoid unexpected or
   * inconsistent behavior due to review submission timing.
   *
   * @generated from field: map<string, types.ThresholdIndexSets> RoleThresholdMapping = 11;
   */
  RoleThresholdMapping: { [key: string]: ThresholdIndexSets };

  /**
   * Reviews is a list of reviews applied to this request (internal use only).
   *
   * @generated from field: repeated types.AccessReview Reviews = 12;
   */
  Reviews: AccessReview[];

  /**
   * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
   * that is not a requirement.
   *
   * @generated from field: repeated string SuggestedReviewers = 13;
   */
  SuggestedReviewers: string[];

  /**
   * RequestedResourceIDs is a set of resources to which access is being requested.
   *
   * @generated from field: repeated types.ResourceID RequestedResourceIDs = 14;
   */
  RequestedResourceIDs: ResourceID[];

  /**
   * LoginHint is used as a hint for search-based access requests to select
   * roles based on the login the user is attempting.
   *
   * @generated from field: string LoginHint = 15;
   */
  LoginHint: string;

  /**
   * DryRun indicates that the request should not actually be created, the
   * auth server should only validate the access request.
   *
   * @generated from field: bool DryRun = 16;
   */
  DryRun: boolean;

  /**
   * MaxDuration indicates how long the access should be granted for.
   *
   * @generated from field: google.protobuf.Timestamp MaxDuration = 17;
   */
  MaxDuration?: Timestamp;

  /**
   * SessionTLL indicated how long a certificate for a session should be valid for.
   *
   * @generated from field: google.protobuf.Timestamp SessionTTL = 18;
   */
  SessionTTL?: Timestamp;

  /**
   * PromotedAccessListTitle is the title of the access list that this request
   * was promoted to. Used by WebUI to display the title of the access list.
   * This field is only populated when the request is in the PROMOTED state.
   *
   * @generated from field: types.PromotedAccessList accessList = 20;
   */
  accessList?: PromotedAccessList;

  /**
   * AssumeStartTime is the time the requested roles can be assumed.
   *
   * @generated from field: google.protobuf.Timestamp AssumeStartTime = 21;
   */
  AssumeStartTime?: Timestamp;
};

/**
 * Describes the message types.AccessRequestSpecV3.
 * Use `create(AccessRequestSpecV3Schema)` to create a new message.
 */
export const AccessRequestSpecV3Schema: GenMessage<AccessRequestSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 103);

/**
 * AccessRequestFilter encodes filter params for access requests.
 *
 * @generated from message types.AccessRequestFilter
 */
export type AccessRequestFilter = Message<"types.AccessRequestFilter"> & {
  /**
   * ID specifies a request ID if set.
   *
   * @generated from field: string ID = 1;
   */
  ID: string;

  /**
   * User specifies a username if set.
   *
   * @generated from field: string User = 2;
   */
  User: string;

  /**
   * RequestState filters for requests in a specific state.
   *
   * @generated from field: types.RequestState State = 3;
   */
  State: RequestState;

  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   * The matcher goes through select field values from a resource
   * and tries to match against the list of search values, ignoring case and order.
   * Returns true if all search vals were matched (or if nil search vals).
   * Returns false if no or partial match (or nil field values).
   *
   * @generated from field: repeated string SearchKeywords = 4;
   */
  SearchKeywords: string[];

  /**
   * Scope is an aditional filter to view requests based on needs review, reviewed, my requests
   *
   * @generated from field: types.AccessRequestScope Scope = 5;
   */
  Scope: AccessRequestScope;

  /**
   * Requester is the requester of the api call. This is set by the auth server
   * Use User for the requester of the request.
   *
   * @generated from field: string Requester = 6;
   */
  Requester: string;
};

/**
 * Describes the message types.AccessRequestFilter.
 * Use `create(AccessRequestFilterSchema)` to create a new message.
 */
export const AccessRequestFilterSchema: GenMessage<AccessRequestFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 104);

/**
 * AccessCapabilities is a summary of capabilities that a user
 * is granted via their dynamic access privileges which may not be
 * calculable by directly examining the user's own static roles.
 *
 * @generated from message types.AccessCapabilities
 */
export type AccessCapabilities = Message<"types.AccessCapabilities"> & {
  /**
   * RequestableRoles is a list of existent roles which the user is allowed to request.
   *
   * @generated from field: repeated string RequestableRoles = 1;
   */
  RequestableRoles: string[];

  /**
   * SuggestedReviewers is a list of all reviewers which are suggested by the user's roles.
   *
   * @generated from field: repeated string SuggestedReviewers = 2;
   */
  SuggestedReviewers: string[];

  /**
   * ApplicableRolesForResources is a list of the roles applicable for access to a given set of resources.
   *
   * @generated from field: repeated string ApplicableRolesForResources = 3;
   */
  ApplicableRolesForResources: string[];

  /**
   * RequestPrompt is an optional message which tells users what they aught to request.
   *
   * @generated from field: string RequestPrompt = 4;
   */
  RequestPrompt: string;

  /**
   * RequireReason indicates whether the request strategy is one that requires
   * users to always supply reasons with their requests.
   *
   * @generated from field: bool RequireReason = 5;
   */
  RequireReason: boolean;

  /**
   * AutoRequest indicates whether the request strategy indicates that a
   * request should be automatically generated on login.
   *
   * @generated from field: bool AutoRequest = 6;
   */
  AutoRequest: boolean;
};

/**
 * Describes the message types.AccessCapabilities.
 * Use `create(AccessCapabilitiesSchema)` to create a new message.
 */
export const AccessCapabilitiesSchema: GenMessage<AccessCapabilities> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 105);

/**
 * AccessCapabilitiesRequest encodes parameters for the GetAccessCapabilities method.
 *
 * @generated from message types.AccessCapabilitiesRequest
 */
export type AccessCapabilitiesRequest = Message<"types.AccessCapabilitiesRequest"> & {
  /**
   * User is the name of the user whose capabilities we are interested in (defaults to
   * the caller's own username).
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * RequestableRoles is a flag indicating that we would like to view the list of roles
   * that the user is able to request.
   *
   * @generated from field: bool RequestableRoles = 2;
   */
  RequestableRoles: boolean;

  /**
   * SuggestedReviewers is a flag indicating that we would like to view the list of all
   * reviewers which are suggested by the user's roles.
   *
   * @generated from field: bool SuggestedReviewers = 3;
   */
  SuggestedReviewers: boolean;

  /**
   * ResourceIDs is the list of the ResourceIDs of the resources we would like to view
   * the necessary roles for.
   *
   * @generated from field: repeated types.ResourceID ResourceIDs = 4;
   */
  ResourceIDs: ResourceID[];

  /**
   * Login is the host login the user is requesting access for.
   *
   * @generated from field: string Login = 5;
   */
  Login: string;

  /**
   * FilterRequestableRolesByResource is a flag indicating that the returned
   * list of roles that the user can request should be filtered to only include
   * roles that allow access to the provided ResourceIDs.
   *
   * @generated from field: bool FilterRequestableRolesByResource = 6;
   */
  FilterRequestableRolesByResource: boolean;
};

/**
 * Describes the message types.AccessCapabilitiesRequest.
 * Use `create(AccessCapabilitiesRequestSchema)` to create a new message.
 */
export const AccessCapabilitiesRequestSchema: GenMessage<AccessCapabilitiesRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 106);

/**
 * ResourceID is a unique identifier for a teleport resource.
 *
 * @generated from message types.ResourceID
 */
export type ResourceID = Message<"types.ResourceID"> & {
  /**
   * ClusterName is the name of the cluster the resource is in.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName: string;

  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 2;
   */
  Kind: string;

  /**
   * Name is the name of the specific resource.
   *
   * @generated from field: string Name = 3;
   */
  Name: string;

  /**
   * SubResourceName is the resource belonging to resource identified by "Name"
   * that the user is allowed to access to.
   * When granting access to a subresource, access to other resources is limited.
   * Currently it just supports resources of Kind=pod and the format is the following
   * "<kube_namespace>/<kube_pod>".
   *
   * @generated from field: string SubResourceName = 4;
   */
  SubResourceName: string;
};

/**
 * Describes the message types.ResourceID.
 * Use `create(ResourceIDSchema)` to create a new message.
 */
export const ResourceIDSchema: GenMessage<ResourceID> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 107);

/**
 * PluginData stores a collection of values associated with a specific resource.
 *
 * @generated from message types.PluginDataV3
 */
export type PluginDataV3 = Message<"types.PluginDataV3"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is PluginData metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a PluginData specification
   *
   * @generated from field: types.PluginDataSpecV3 Spec = 5;
   */
  Spec?: PluginDataSpecV3;
};

/**
 * Describes the message types.PluginDataV3.
 * Use `create(PluginDataV3Schema)` to create a new message.
 */
export const PluginDataV3Schema: GenMessage<PluginDataV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 108);

/**
 * PluginDataEntry wraps a mapping of arbitrary string values used by
 * plugins to store per-resource information.
 *
 * @generated from message types.PluginDataEntry
 */
export type PluginDataEntry = Message<"types.PluginDataEntry"> & {
  /**
   * Data is a mapping of arbitrary string values.
   *
   * @generated from field: map<string, string> Data = 1;
   */
  Data: { [key: string]: string };
};

/**
 * Describes the message types.PluginDataEntry.
 * Use `create(PluginDataEntrySchema)` to create a new message.
 */
export const PluginDataEntrySchema: GenMessage<PluginDataEntry> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 109);

/**
 * PluginData stores a collection of values associated with a specific resource.
 *
 * @generated from message types.PluginDataSpecV3
 */
export type PluginDataSpecV3 = Message<"types.PluginDataSpecV3"> & {
  /**
   * Entries is a collection of PluginData values organized by plugin name.
   *
   * @generated from field: map<string, types.PluginDataEntry> Entries = 1;
   */
  Entries: { [key: string]: PluginDataEntry };
};

/**
 * Describes the message types.PluginDataSpecV3.
 * Use `create(PluginDataSpecV3Schema)` to create a new message.
 */
export const PluginDataSpecV3Schema: GenMessage<PluginDataSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 110);

/**
 * PluginDataFilter encodes filter params for plugin data.
 *
 * @generated from message types.PluginDataFilter
 */
export type PluginDataFilter = Message<"types.PluginDataFilter"> & {
  /**
   * Kind is the kind of resource that the target plugin data
   * is associated with.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * Resource matches a specific resource name if set.
   *
   * @generated from field: string Resource = 2;
   */
  Resource: string;

  /**
   * Plugin matches a specific plugin name if set.
   *
   * @generated from field: string Plugin = 3;
   */
  Plugin: string;
};

/**
 * Describes the message types.PluginDataFilter.
 * Use `create(PluginDataFilterSchema)` to create a new message.
 */
export const PluginDataFilterSchema: GenMessage<PluginDataFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 111);

/**
 * PluginDataUpdateParams encodes parameters for updating a PluginData field.
 *
 * @generated from message types.PluginDataUpdateParams
 */
export type PluginDataUpdateParams = Message<"types.PluginDataUpdateParams"> & {
  /**
   * Kind is the kind of resource that the target plugin data
   * is associated with.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * Resource indicates the name of the target resource.
   *
   * @generated from field: string Resource = 2;
   */
  Resource: string;

  /**
   * Plugin is the name of the plugin that owns the data.
   *
   * @generated from field: string Plugin = 3;
   */
  Plugin: string;

  /**
   * Set indicates the fields which should be set by this operation.
   *
   * @generated from field: map<string, string> Set = 4;
   */
  Set: { [key: string]: string };

  /**
   * Expect optionally indicates the expected state of fields prior to this update.
   *
   * @generated from field: map<string, string> Expect = 5;
   */
  Expect: { [key: string]: string };
};

/**
 * Describes the message types.PluginDataUpdateParams.
 * Use `create(PluginDataUpdateParamsSchema)` to create a new message.
 */
export const PluginDataUpdateParamsSchema: GenMessage<PluginDataUpdateParams> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 112);

/**
 * RoleFilter matches role resources.
 *
 * @generated from message types.RoleFilter
 */
export type RoleFilter = Message<"types.RoleFilter"> & {
  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   *
   * @generated from field: repeated string SearchKeywords = 1;
   */
  SearchKeywords: string[];

  /**
   * SkipSystemRoles filters out teleport system roles from the results.
   *
   * @generated from field: bool SkipSystemRoles = 2;
   */
  SkipSystemRoles: boolean;
};

/**
 * Describes the message types.RoleFilter.
 * Use `create(RoleFilterSchema)` to create a new message.
 */
export const RoleFilterSchema: GenMessage<RoleFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 113);

/**
 * RoleV6 represents role resource specification
 *
 * @generated from message types.RoleV6
 */
export type RoleV6 = Message<"types.RoleV6"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`, `v4`, `v5`, `v6`, `v7`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a role specification
   *
   * @generated from field: types.RoleSpecV6 Spec = 5;
   */
  Spec?: RoleSpecV6;
};

/**
 * Describes the message types.RoleV6.
 * Use `create(RoleV6Schema)` to create a new message.
 */
export const RoleV6Schema: GenMessage<RoleV6> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 114);

/**
 * RoleSpecV6 is role specification for RoleV6.
 *
 * @generated from message types.RoleSpecV6
 */
export type RoleSpecV6 = Message<"types.RoleSpecV6"> & {
  /**
   * Options is for OpenSSH options like agent forwarding.
   *
   * @generated from field: types.RoleOptions Options = 1;
   */
  Options?: RoleOptions;

  /**
   * Allow is the set of conditions evaluated to grant access.
   *
   * @generated from field: types.RoleConditions Allow = 2;
   */
  Allow?: RoleConditions;

  /**
   * Deny is the set of conditions evaluated to deny access. Deny takes priority
   * over allow.
   *
   * @generated from field: types.RoleConditions Deny = 3;
   */
  Deny?: RoleConditions;
};

/**
 * Describes the message types.RoleSpecV6.
 * Use `create(RoleSpecV6Schema)` to create a new message.
 */
export const RoleSpecV6Schema: GenMessage<RoleSpecV6> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 115);

/**
 * RoleOptions is a set of role options
 *
 * @generated from message types.RoleOptions
 */
export type RoleOptions = Message<"types.RoleOptions"> & {
  /**
   * ForwardAgent is SSH agent forwarding.
   *
   * @generated from field: bool ForwardAgent = 1;
   */
  ForwardAgent: boolean;

  /**
   * MaxSessionTTL defines how long a SSH session can last for.
   *
   * @generated from field: int64 MaxSessionTTL = 2;
   */
  MaxSessionTTL: bigint;

  /**
   * PortForwarding defines if the certificate will have
   * "permit-port-forwarding"
   * in the certificate. PortForwarding is "yes" if not set,
   * that's why this is a pointer
   *
   * @generated from field: types.BoolValue PortForwarding = 3;
   */
  PortForwarding?: BoolValue;

  /**
   * CertificateFormat defines the format of the user certificate to allow
   * compatibility with older versions of OpenSSH.
   *
   * @generated from field: string CertificateFormat = 4;
   */
  CertificateFormat: string;

  /**
   * ClientIdleTimeout sets disconnect clients on idle timeout behavior,
   * if set to 0 means do not disconnect, otherwise is set to the idle
   * duration.
   *
   * @generated from field: int64 ClientIdleTimeout = 5;
   */
  ClientIdleTimeout: bigint;

  /**
   * DisconnectExpiredCert sets disconnect clients on expired certificates.
   *
   * @generated from field: bool DisconnectExpiredCert = 6;
   */
  DisconnectExpiredCert: boolean;

  /**
   * BPF defines what events to record for the BPF-based session recorder.
   *
   * @generated from field: repeated string BPF = 7;
   */
  BPF: string[];

  /**
   * PermitX11Forwarding authorizes use of X11 forwarding.
   *
   * @generated from field: bool PermitX11Forwarding = 8;
   */
  PermitX11Forwarding: boolean;

  /**
   * MaxConnections defines the maximum number of
   * concurrent connections a user may hold.
   *
   * @generated from field: int64 MaxConnections = 9;
   */
  MaxConnections: bigint;

  /**
   * MaxSessions defines the maximum number of
   * concurrent sessions per connection.
   *
   * @generated from field: int64 MaxSessions = 10;
   */
  MaxSessions: bigint;

  /**
   * RequestAccess defines the request strategy (optional|note|always)
   * where optional is the default.
   *
   * @generated from field: string RequestAccess = 11;
   */
  RequestAccess: string;

  /**
   * RequestPrompt is an optional message which tells users what they aught to request.
   *
   * @generated from field: string RequestPrompt = 12;
   */
  RequestPrompt: string;

  /**
   * Lock specifies the locking mode (strict|best_effort) to be applied with
   * the role.
   *
   * @generated from field: string Lock = 14;
   */
  Lock: string;

  /**
   * RecordDesktopSession indicates whether desktop access sessions should be recorded.
   * It defaults to true unless explicitly set to false.
   *
   * @generated from field: types.RecordSession RecordSession = 15;
   */
  RecordSession?: RecordSession;

  /**
   * DesktopClipboard indicates whether clipboard sharing is allowed between the user's
   * workstation and the remote desktop. It defaults to true unless explicitly set to
   * false.
   *
   * @generated from field: types.BoolValue DesktopClipboard = 16;
   */
  DesktopClipboard?: BoolValue;

  /**
   * CertExtensions specifies the key/values
   *
   * @generated from field: repeated types.CertExtension CertExtensions = 17;
   */
  CertExtensions: CertExtension[];

  /**
   * MaxKubernetesConnections defines the maximum number of concurrent
   * Kubernetes sessions a user may hold.
   *
   * @generated from field: int64 MaxKubernetesConnections = 18;
   */
  MaxKubernetesConnections: bigint;

  /**
   * DesktopDirectorySharing indicates whether directory sharing is allowed between the user's
   * workstation and the remote desktop. It defaults to false unless explicitly set to
   * true.
   *
   * @generated from field: types.BoolValue DesktopDirectorySharing = 19;
   */
  DesktopDirectorySharing?: BoolValue;

  /**
   * CreateHostUser allows users to be automatically created on a host
   *
   * @generated from field: types.BoolValue CreateHostUser = 20;
   */
  CreateHostUser?: BoolValue;

  /**
   * PinSourceIP forces the same client IP for certificate generation and usage
   *
   * @generated from field: bool PinSourceIP = 21;
   */
  PinSourceIP: boolean;

  /**
   * SSHFileCopy indicates whether remote file operations via SCP or SFTP are allowed
   * over an SSH session. It defaults to true unless explicitly set to false.
   *
   * @generated from field: types.BoolValue SSHFileCopy = 22;
   */
  SSHFileCopy?: BoolValue;

  /**
   * RequireMFAType is the type of MFA requirement enforced for this user.
   * 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH",
   * 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
   *
   * @generated from field: types.RequireMFAType RequireMFAType = 23;
   */
  RequireMFAType: RequireMFAType;

  /**
   * DeviceTrustMode is the device authorization mode used for the resources
   * associated with the role.
   * See DeviceTrust.Mode.
   *
   * @generated from field: string DeviceTrustMode = 24;
   */
  DeviceTrustMode: string;

  /**
   * IDP is a set of options related to accessing IdPs within Teleport.
   * Requires Teleport Enterprise.
   *
   * @generated from field: types.IdPOptions IDP = 25;
   */
  IDP?: IdPOptions;

  /**
   * CreateDesktopUser allows users to be automatically created on a Windows desktop
   *
   * @generated from field: types.BoolValue CreateDesktopUser = 26;
   */
  CreateDesktopUser?: BoolValue;

  /**
   * CreateDatabaseUser enabled automatic database user creation.
   *
   * @generated from field: types.BoolValue CreateDatabaseUser = 27;
   */
  CreateDatabaseUser?: BoolValue;

  /**
   * CreateHostUserMode allows users to be automatically created on a
   * host when not set to off.
   * 0 is "unspecified"; 1 is "off"; 2 is "drop" (removed for v15 and above),
   * 3 is "keep"; 4 is "insecure-drop".
   *
   * @generated from field: types.CreateHostUserMode CreateHostUserMode = 28;
   */
  CreateHostUserMode: CreateHostUserMode;

  /**
   * CreateDatabaseUserMode allows users to be automatically created on a
   * database when not set to off.
   * 0 is "unspecified", 1 is "off", 2 is "keep", 3 is "best_effort_drop".
   *
   * @generated from field: types.CreateDatabaseUserMode CreateDatabaseUserMode = 29;
   */
  CreateDatabaseUserMode: CreateDatabaseUserMode;

  /**
   * MFAVerificationInterval optionally defines the maximum duration that can elapse
   * between successive MFA verifications. This variable is used to ensure
   * that users are periodically prompted to verify their identity, enhancing
   * security by preventing prolonged sessions without re-authentication when using
   * tsh proxy * derivatives.
   * It's only effective if the session requires MFA.
   * If not set, defaults to `max_session_ttl`.
   *
   * @generated from field: google.protobuf.Duration MFAVerificationInterval = 30;
   */
  MFAVerificationInterval?: Duration;

  /**
   * CreateHostUserDefaultShell is used to configure the default shell for newly provisioned host users.
   *
   * @generated from field: string CreateHostUserDefaultShell = 31;
   */
  CreateHostUserDefaultShell: string;
};

/**
 * Describes the message types.RoleOptions.
 * Use `create(RoleOptionsSchema)` to create a new message.
 */
export const RoleOptionsSchema: GenMessage<RoleOptions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 116);

/**
 * @generated from message types.RecordSession
 */
export type RecordSession = Message<"types.RecordSession"> & {
  /**
   * Desktop indicates whether desktop sessions should be recorded.
   * It defaults to true unless explicitly set to false.
   *
   * @generated from field: types.BoolValue Desktop = 1;
   */
  Desktop?: BoolValue;

  /**
   * Default indicates the default value for the services.
   *
   * @generated from field: string Default = 2;
   */
  Default: string;

  /**
   * SSH indicates the session mode used on SSH sessions.
   *
   * @generated from field: string SSH = 3;
   */
  SSH: string;
};

/**
 * Describes the message types.RecordSession.
 * Use `create(RecordSessionSchema)` to create a new message.
 */
export const RecordSessionSchema: GenMessage<RecordSession> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 117);

/**
 * CertExtension represents a key/value for a certificate extension
 *
 * @generated from message types.CertExtension
 */
export type CertExtension = Message<"types.CertExtension"> & {
  /**
   * Type represents the certificate type being extended, only ssh
   * is supported at this time.
   * 0 is "ssh".
   *
   * @generated from field: types.CertExtensionType Type = 1;
   */
  Type: CertExtensionType;

  /**
   * Mode is the type of extension to be used -- currently
   * critical-option is not supported.
   * 0 is "extension".
   *
   * @generated from field: types.CertExtensionMode Mode = 2;
   */
  Mode: CertExtensionMode;

  /**
   * Name specifies the key to be used in the cert extension.
   *
   * @generated from field: string Name = 3;
   */
  Name: string;

  /**
   * Value specifies the value to be used in the cert extension.
   *
   * @generated from field: string Value = 4;
   */
  Value: string;
};

/**
 * Describes the message types.CertExtension.
 * Use `create(CertExtensionSchema)` to create a new message.
 */
export const CertExtensionSchema: GenMessage<CertExtension> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 118);

/**
 * RoleConditions is a set of conditions that must all match to be allowed or
 * denied access.
 *
 * @generated from message types.RoleConditions
 */
export type RoleConditions = Message<"types.RoleConditions"> & {
  /**
   * Logins is a list of *nix system logins.
   *
   * @generated from field: repeated string Logins = 1;
   */
  Logins: string[];

  /**
   * Namespaces is a list of namespaces (used to partition a cluster). The
   * field should be called "namespaces" when it returns in Teleport 2.4.
   *
   * @generated from field: repeated string Namespaces = 2;
   */
  Namespaces: string[];

  /**
   * NodeLabels is a map of node labels (used to dynamically grant access to
   * nodes).
   *
   * @generated from field: wrappers.LabelValues NodeLabels = 3;
   */
  NodeLabels?: LabelValues;

  /**
   * Rules is a list of rules and their access levels. Rules are a high level
   * construct used for access control.
   *
   * @generated from field: repeated types.Rule Rules = 4;
   */
  Rules: Rule[];

  /**
   * KubeGroups is a list of kubernetes groups
   *
   * @generated from field: repeated string KubeGroups = 5;
   */
  KubeGroups: string[];

  /**
   * @generated from field: types.AccessRequestConditions Request = 6;
   */
  Request?: AccessRequestConditions;

  /**
   * KubeUsers is an optional kubernetes users to impersonate
   *
   * @generated from field: repeated string KubeUsers = 7;
   */
  KubeUsers: string[];

  /**
   * AppLabels is a map of labels used as part of the RBAC system.
   *
   * @generated from field: wrappers.LabelValues AppLabels = 8;
   */
  AppLabels?: LabelValues;

  /**
   * ClusterLabels is a map of node labels (used to dynamically grant access to
   * clusters).
   *
   * @generated from field: wrappers.LabelValues ClusterLabels = 9;
   */
  ClusterLabels?: LabelValues;

  /**
   * KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
   *
   * @generated from field: wrappers.LabelValues KubernetesLabels = 10;
   */
  KubernetesLabels?: LabelValues;

  /**
   * DatabaseLabels are used in RBAC system to allow/deny access to databases.
   *
   * @generated from field: wrappers.LabelValues DatabaseLabels = 11;
   */
  DatabaseLabels?: LabelValues;

  /**
   * DatabaseNames is a list of database names this role is allowed to connect to.
   *
   * @generated from field: repeated string DatabaseNames = 12;
   */
  DatabaseNames: string[];

  /**
   * DatabaseUsers is a list of databases users this role is allowed to connect as.
   *
   * @generated from field: repeated string DatabaseUsers = 13;
   */
  DatabaseUsers: string[];

  /**
   * Impersonate specifies what users and roles this role is allowed to impersonate
   * by issuing certificates or other possible means.
   *
   * @generated from field: types.ImpersonateConditions Impersonate = 14;
   */
  Impersonate?: ImpersonateConditions;

  /**
   * ReviewRequests defines conditions for submitting access reviews.
   *
   * @generated from field: types.AccessReviewConditions ReviewRequests = 15;
   */
  ReviewRequests?: AccessReviewConditions;

  /**
   * AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
   *
   * @generated from field: repeated string AWSRoleARNs = 16;
   */
  AWSRoleARNs: string[];

  /**
   * WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
   *
   * @generated from field: repeated string WindowsDesktopLogins = 17;
   */
  WindowsDesktopLogins: string[];

  /**
   * WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
   *
   * @generated from field: wrappers.LabelValues WindowsDesktopLabels = 18;
   */
  WindowsDesktopLabels?: LabelValues;

  /**
   * RequireSessionJoin specifies policies for required users to start a session.
   *
   * @generated from field: repeated types.SessionRequirePolicy RequireSessionJoin = 19;
   */
  RequireSessionJoin: SessionRequirePolicy[];

  /**
   * JoinSessions specifies policies to allow users to join other sessions.
   *
   * @generated from field: repeated types.SessionJoinPolicy JoinSessions = 20;
   */
  JoinSessions: SessionJoinPolicy[];

  /**
   * HostGroups is a list of groups for created users to be added to
   *
   * @generated from field: repeated string HostGroups = 21;
   */
  HostGroups: string[];

  /**
   * HostSudoers is a list of entries to include in a users sudoer file
   *
   * @generated from field: repeated string HostSudoers = 22;
   */
  HostSudoers: string[];

  /**
   * AzureIdentities is a list of Azure identities this role is allowed to assume.
   *
   * @generated from field: repeated string AzureIdentities = 23;
   */
  AzureIdentities: string[];

  /**
   * KubernetesResources is the Kubernetes Resources this Role grants access to.
   *
   * @generated from field: repeated types.KubernetesResource KubernetesResources = 24;
   */
  KubernetesResources: KubernetesResource[];

  /**
   * GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
   *
   * @generated from field: repeated string GCPServiceAccounts = 25;
   */
  GCPServiceAccounts: string[];

  /**
   * DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
   *
   * @generated from field: wrappers.LabelValues DatabaseServiceLabels = 26;
   */
  DatabaseServiceLabels?: LabelValues;

  /**
   * GroupLabels is a map of labels used as part of the RBAC system.
   *
   * @generated from field: wrappers.LabelValues GroupLabels = 27;
   */
  GroupLabels?: LabelValues;

  /**
   * DesktopGroups is a list of groups for created desktop users to be added to
   *
   * @generated from field: repeated string DesktopGroups = 28;
   */
  DesktopGroups: string[];

  /**
   * DatabaseRoles is a list of databases roles for automatic user creation.
   *
   * @generated from field: repeated string DatabaseRoles = 29;
   */
  DatabaseRoles: string[];

  /**
   * NodeLabelsExpression is a predicate expression used to allow/deny access to
   * SSH nodes.
   *
   * @generated from field: string NodeLabelsExpression = 30;
   */
  NodeLabelsExpression: string;

  /**
   * AppLabelsExpression is a predicate expression used to allow/deny access to
   * Apps.
   *
   * @generated from field: string AppLabelsExpression = 31;
   */
  AppLabelsExpression: string;

  /**
   * ClusterLabelsExpression is a predicate expression used to allow/deny access
   * to remote Teleport clusters.
   *
   * @generated from field: string ClusterLabelsExpression = 32;
   */
  ClusterLabelsExpression: string;

  /**
   * KubernetesLabelsExpression is a predicate expression used to allow/deny
   * access to kubernetes clusters.
   *
   * @generated from field: string KubernetesLabelsExpression = 33;
   */
  KubernetesLabelsExpression: string;

  /**
   * DatabaseLabelsExpression is a predicate expression used to allow/deny
   * access to Databases.
   *
   * @generated from field: string DatabaseLabelsExpression = 34;
   */
  DatabaseLabelsExpression: string;

  /**
   * DatabaseServiceLabelsExpression is a predicate expression used to
   * allow/deny access to Database Services.
   *
   * @generated from field: string DatabaseServiceLabelsExpression = 35;
   */
  DatabaseServiceLabelsExpression: string;

  /**
   * WindowsDesktopLabelsExpression is a predicate expression used to allow/deny
   * access to Windows desktops.
   *
   * @generated from field: string WindowsDesktopLabelsExpression = 36;
   */
  WindowsDesktopLabelsExpression: string;

  /**
   * GroupLabelsExpression is a predicate expression used to allow/deny
   * access to user groups.
   *
   * @generated from field: string GroupLabelsExpression = 37;
   */
  GroupLabelsExpression: string;

  /**
   * DatabasePermissions specifies a set of permissions that will be granted
   * to the database user when using automatic database user provisioning.
   *
   * @generated from field: repeated types.DatabasePermission DatabasePermissions = 38;
   */
  DatabasePermissions: DatabasePermission[];

  /**
   * SPIFFE is used to allow or deny access to a role holder to generating a
   * SPIFFE SVID.
   *
   * @generated from field: repeated types.SPIFFERoleCondition SPIFFE = 39;
   */
  SPIFFE: SPIFFERoleCondition[];
};

/**
 * Describes the message types.RoleConditions.
 * Use `create(RoleConditionsSchema)` to create a new message.
 */
export const RoleConditionsSchema: GenMessage<RoleConditions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 119);

/**
 * SPIFFERoleCondition sets out which SPIFFE identities this role is allowed or
 * denied to generate. The Path matcher is required, and is evaluated first. If,
 * the Path does not match then the other matcher fields are not evaluated.
 *
 * @generated from message types.SPIFFERoleCondition
 */
export type SPIFFERoleCondition = Message<"types.SPIFFERoleCondition"> & {
  /**
   * Path specifies a matcher for the SPIFFE ID path. It should not include the
   * trust domain and should start with a leading slash.
   *
   * The matcher by default allows '*' to be used to indicate zero or more of
   * any character. Prepend '^' and append '$' to instead switch to matching
   * using the Go regex syntax.
   *
   * Example:
   * - /svc/foo/*\/bar would match /svc/foo/baz/bar
   * - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
   *
   * @generated from field: string Path = 1;
   */
  Path: string;

  /**
   * DNSSANs specifies matchers for the SPIFFE ID DNS SANs.
   *
   * Each requested DNS SAN is compared against all matchers configured and if
   * any match, the condition is considered to be met.
   *
   * The matcher by default allows '*' to be used to indicate zero or more of
   * any character. Prepend '^' and append '$' to instead switch to matching
   * using the Go regex syntax.
   *
   * Example: *.example.com would match foo.example.com
   *
   * @generated from field: repeated string DNSSANs = 2;
   */
  DNSSANs: string[];

  /**
   * IPSANs specifies matchers for the SPIFFE ID IP SANs.
   *
   * Each requested IP SAN is compared against all matchers configured and if
   * any match, the condition is considered to be met.
   *
   * The matchers should be specified using CIDR notation, it supports IPv4 and
   * IPv6.
   *
   * Examples:
   * - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255
   * - 10.0.0.42/32 would match only 10.0.0.42
   *
   * @generated from field: repeated string IPSANs = 3;
   */
  IPSANs: string[];
};

/**
 * Describes the message types.SPIFFERoleCondition.
 * Use `create(SPIFFERoleConditionSchema)` to create a new message.
 */
export const SPIFFERoleConditionSchema: GenMessage<SPIFFERoleCondition> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 120);

/**
 * DatabasePermission specifies the database object permission for the user.
 *
 * @generated from message types.DatabasePermission
 */
export type DatabasePermission = Message<"types.DatabasePermission"> & {
  /**
   * Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
   *
   * @generated from field: repeated string Permissions = 1;
   */
  Permissions: string[];

  /**
   * Match is a list of object labels that must be matched for the permission to be granted.
   *
   * @generated from field: wrappers.LabelValues Match = 2;
   */
  Match?: LabelValues;
};

/**
 * Describes the message types.DatabasePermission.
 * Use `create(DatabasePermissionSchema)` to create a new message.
 */
export const DatabasePermissionSchema: GenMessage<DatabasePermission> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 121);

/**
 * KubernetesResource is the Kubernetes resource identifier.
 *
 * @generated from message types.KubernetesResource
 */
export type KubernetesResource = Message<"types.KubernetesResource"> & {
  /**
   * Kind specifies the Kubernetes Resource type.
   * At the moment only "pod" is supported.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * Namespace is the resource namespace.
   * It supports wildcards.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace: string;

  /**
   * Name is the resource name.
   * It supports wildcards.
   *
   * @generated from field: string Name = 3;
   */
  Name: string;

  /**
   * Verbs are the allowed Kubernetes verbs for the following resource.
   *
   * @generated from field: repeated string Verbs = 4;
   */
  Verbs: string[];
};

/**
 * Describes the message types.KubernetesResource.
 * Use `create(KubernetesResourceSchema)` to create a new message.
 */
export const KubernetesResourceSchema: GenMessage<KubernetesResource> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 122);

/**
 * SessionRequirePolicy a requirement policy that needs to be fulfilled to grant access.
 *
 * @generated from message types.SessionRequirePolicy
 */
export type SessionRequirePolicy = Message<"types.SessionRequirePolicy"> & {
  /**
   * Name is the name of the policy.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Filter is a predicate that determines what users count towards this policy.
   *
   * @generated from field: string Filter = 2;
   */
  Filter: string;

  /**
   * Kinds are the session kinds this policy applies to.
   *
   * @generated from field: repeated string Kinds = 3;
   */
  Kinds: string[];

  /**
   * Count is the amount of people that need to be matched for this policy to be fulfilled.
   *
   * @generated from field: int32 Count = 4;
   */
  Count: number;

  /**
   * Modes is the list of modes that may be used to fulfill this policy.
   *
   * @generated from field: repeated string Modes = 5;
   */
  Modes: string[];

  /**
   * OnLeave is the behaviour that's used when the policy is no longer fulfilled
   * for a live session.
   *
   * @generated from field: string OnLeave = 6;
   */
  OnLeave: string;
};

/**
 * Describes the message types.SessionRequirePolicy.
 * Use `create(SessionRequirePolicySchema)` to create a new message.
 */
export const SessionRequirePolicySchema: GenMessage<SessionRequirePolicy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 123);

/**
 * SessionJoinPolicy defines a policy that allows a user to join sessions.
 *
 * @generated from message types.SessionJoinPolicy
 */
export type SessionJoinPolicy = Message<"types.SessionJoinPolicy"> & {
  /**
   * Name is the name of the policy.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Roles is a list of roles that you can join the session of.
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[];

  /**
   * Kinds are the session kinds this policy applies to.
   *
   * @generated from field: repeated string Kinds = 3;
   */
  Kinds: string[];

  /**
   * Modes is a list of permitted participant modes for this policy.
   *
   * @generated from field: repeated string Modes = 4;
   */
  Modes: string[];
};

/**
 * Describes the message types.SessionJoinPolicy.
 * Use `create(SessionJoinPolicySchema)` to create a new message.
 */
export const SessionJoinPolicySchema: GenMessage<SessionJoinPolicy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 124);

/**
 * AccessRequestConditions is a matcher for allow/deny restrictions on
 * access-requests.
 * Please remember to update IsEmpty when updating this message.
 *
 * @generated from message types.AccessRequestConditions
 */
export type AccessRequestConditions = Message<"types.AccessRequestConditions"> & {
  /**
   * Roles is the name of roles which will match the request rule.
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[];

  /**
   * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
   *
   * @generated from field: repeated types.ClaimMapping ClaimsToRoles = 2;
   */
  ClaimsToRoles: ClaimMapping[];

  /**
   * Annotations is a collection of annotations to be programmatically
   * appended to pending access requests at the time of their creation.
   * These annotations serve as a mechanism to propagate extra information
   * to plugins.  Since these annotations support variable interpolation
   * syntax, they also offer a mechanism for forwarding claims from an
   * external identity provider, to a plugin via `{{external.trait_name}}`
   * style substitutions.
   *
   * @generated from field: wrappers.LabelValues Annotations = 3;
   */
  Annotations?: LabelValues;

  /**
   * Thresholds is a list of thresholds, one of which must be met in order for reviews
   * to trigger a state-transition.  If no thresholds are provided, a default threshold
   * of 1 for approval and denial is used.
   *
   * @generated from field: repeated types.AccessReviewThreshold Thresholds = 4;
   */
  Thresholds: AccessReviewThreshold[];

  /**
   * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
   * that is not a requirement.
   *
   * @generated from field: repeated string SuggestedReviewers = 5;
   */
  SuggestedReviewers: string[];

  /**
   * SearchAsRoles is a list of extra roles which should apply to a user while
   * they are searching for resources as part of a Resource Access Request, and
   * defines the underlying roles which will be requested as part of any
   * Resource Access Request.
   *
   * @generated from field: repeated string SearchAsRoles = 6;
   */
  SearchAsRoles: string[];

  /**
   * MaxDuration is the amount of time the access will be granted for.
   * If this is zero, the default duration is used.
   *
   * @generated from field: int64 MaxDuration = 7;
   */
  MaxDuration: bigint;
};

/**
 * Describes the message types.AccessRequestConditions.
 * Use `create(AccessRequestConditionsSchema)` to create a new message.
 */
export const AccessRequestConditionsSchema: GenMessage<AccessRequestConditions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 125);

/**
 * AccessReviewConditions is a matcher for allow/deny restrictions on
 * access reviews.
 * Please remember to update IsEmpty when updating this message.
 *
 * @generated from message types.AccessReviewConditions
 */
export type AccessReviewConditions = Message<"types.AccessReviewConditions"> & {
  /**
   * Roles is the name of roles which may be reviewed.
   *
   * @generated from field: repeated string Roles = 1;
   */
  Roles: string[];

  /**
   * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
   *
   * @generated from field: repeated types.ClaimMapping ClaimsToRoles = 2;
   */
  ClaimsToRoles: ClaimMapping[];

  /**
   * Where is an optional predicate which further limits which requests are
   * reviewable.
   *
   * @generated from field: string Where = 3;
   */
  Where: string;

  /**
   * PreviewAsRoles is a list of extra roles which should apply to a reviewer
   * while they are viewing a Resource Access Request for the purposes of
   * viewing details such as the hostname and labels of requested resources.
   *
   * @generated from field: repeated string PreviewAsRoles = 4;
   */
  PreviewAsRoles: string[];
};

/**
 * Describes the message types.AccessReviewConditions.
 * Use `create(AccessReviewConditionsSchema)` to create a new message.
 */
export const AccessReviewConditionsSchema: GenMessage<AccessReviewConditions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 126);

/**
 * AccessRequestAllowedPromotion describes an allowed promotion to an access list.
 *
 * @generated from message types.AccessRequestAllowedPromotion
 */
export type AccessRequestAllowedPromotion = Message<"types.AccessRequestAllowedPromotion"> & {
  /**
   * associated access list
   *
   * @generated from field: string accessListName = 1;
   */
  accessListName: string;
};

/**
 * Describes the message types.AccessRequestAllowedPromotion.
 * Use `create(AccessRequestAllowedPromotionSchema)` to create a new message.
 */
export const AccessRequestAllowedPromotionSchema: GenMessage<AccessRequestAllowedPromotion> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 127);

/**
 * AccessRequestAllowedPromotions describes an valid promotion from an access request
 * to an access list.
 *
 * @generated from message types.AccessRequestAllowedPromotions
 */
export type AccessRequestAllowedPromotions = Message<"types.AccessRequestAllowedPromotions"> & {
  /**
   * suggestions is a list of allowed access lists promotions.
   *
   * @generated from field: repeated types.AccessRequestAllowedPromotion promotions = 1;
   */
  promotions: AccessRequestAllowedPromotion[];
};

/**
 * Describes the message types.AccessRequestAllowedPromotions.
 * Use `create(AccessRequestAllowedPromotionsSchema)` to create a new message.
 */
export const AccessRequestAllowedPromotionsSchema: GenMessage<AccessRequestAllowedPromotions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 128);

/**
 * ClaimMapping maps a claim to teleport roles.
 *
 * @generated from message types.ClaimMapping
 */
export type ClaimMapping = Message<"types.ClaimMapping"> & {
  /**
   * Claim is a claim name.
   *
   * @generated from field: string Claim = 1;
   */
  Claim: string;

  /**
   * Value is a claim value to match.
   *
   * @generated from field: string Value = 2;
   */
  Value: string;

  /**
   * Roles is a list of static teleport roles to match.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[];
};

/**
 * Describes the message types.ClaimMapping.
 * Use `create(ClaimMappingSchema)` to create a new message.
 */
export const ClaimMappingSchema: GenMessage<ClaimMapping> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 129);

/**
 * TraitMapping maps a trait to teleport roles.
 *
 * @generated from message types.TraitMapping
 */
export type TraitMapping = Message<"types.TraitMapping"> & {
  /**
   * Trait is a trait name.
   *
   * @generated from field: string Trait = 1;
   */
  Trait: string;

  /**
   * Value is a trait value to match.
   *
   * @generated from field: string Value = 2;
   */
  Value: string;

  /**
   * Roles is a list of static teleport roles to match.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[];
};

/**
 * Describes the message types.TraitMapping.
 * Use `create(TraitMappingSchema)` to create a new message.
 */
export const TraitMappingSchema: GenMessage<TraitMapping> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 130);

/**
 * Rule represents allow or deny rule that is executed to check
 * if user or service have access to resource
 *
 * @generated from message types.Rule
 */
export type Rule = Message<"types.Rule"> & {
  /**
   * Resources is a list of resources
   *
   * @generated from field: repeated string Resources = 1;
   */
  Resources: string[];

  /**
   * Verbs is a list of verbs
   *
   * @generated from field: repeated string Verbs = 2;
   */
  Verbs: string[];

  /**
   * Where specifies optional advanced matcher
   *
   * @generated from field: string Where = 3;
   */
  Where: string;

  /**
   * Actions specifies optional actions taken when this rule matches
   *
   * @generated from field: repeated string Actions = 4;
   */
  Actions: string[];
};

/**
 * Describes the message types.Rule.
 * Use `create(RuleSchema)` to create a new message.
 */
export const RuleSchema: GenMessage<Rule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 131);

/**
 * ImpersonateConditions specifies whether users are allowed
 * to issue certificates for other users or groups.
 *
 * @generated from message types.ImpersonateConditions
 */
export type ImpersonateConditions = Message<"types.ImpersonateConditions"> & {
  /**
   * Users is a list of resources this role is allowed to impersonate,
   * could be an empty list or a Wildcard pattern
   *
   * @generated from field: repeated string Users = 1;
   */
  Users: string[];

  /**
   * Roles is a list of resources this role is allowed to impersonate
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[];

  /**
   * Where specifies optional advanced matcher
   *
   * @generated from field: string Where = 3;
   */
  Where: string;
};

/**
 * Describes the message types.ImpersonateConditions.
 * Use `create(ImpersonateConditionsSchema)` to create a new message.
 */
export const ImpersonateConditionsSchema: GenMessage<ImpersonateConditions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 132);

/**
 * BoolValue is a wrapper around bool, used in cases
 * whenever bool value can have different default value when missing
 *
 * @generated from message types.BoolValue
 */
export type BoolValue = Message<"types.BoolValue"> & {
  /**
   * @generated from field: bool Value = 1;
   */
  Value: boolean;
};

/**
 * Describes the message types.BoolValue.
 * Use `create(BoolValueSchema)` to create a new message.
 */
export const BoolValueSchema: GenMessage<BoolValue> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 133);

/**
 * UserFilter matches user resources.
 *
 * @generated from message types.UserFilter
 */
export type UserFilter = Message<"types.UserFilter"> & {
  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   *
   * @generated from field: repeated string SearchKeywords = 1;
   */
  SearchKeywords: string[];
};

/**
 * Describes the message types.UserFilter.
 * Use `create(UserFilterSchema)` to create a new message.
 */
export const UserFilterSchema: GenMessage<UserFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 134);

/**
 * UserV2 is version 2 resource spec of the user
 *
 * @generated from message types.UserV2
 */
export type UserV2 = Message<"types.UserV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a user specification
   *
   * @generated from field: types.UserSpecV2 Spec = 5;
   */
  Spec?: UserSpecV2;

  /**
   * @generated from field: types.UserStatusV2 Status = 6;
   */
  Status?: UserStatusV2;
};

/**
 * Describes the message types.UserV2.
 * Use `create(UserV2Schema)` to create a new message.
 */
export const UserV2Schema: GenMessage<UserV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 135);

/**
 * UserStatusV2 is a dynamic state of UserV2.
 *
 * @generated from message types.UserStatusV2
 */
export type UserStatusV2 = Message<"types.UserStatusV2"> & {
  /**
   * password_state reflects what the system knows about the user's password.
   * Note that this is a "best effort" property, in that it can be UNSPECIFIED
   * for users who were created before this property was introduced and didn't
   * perform any password-related activity since then. See RFD 0159 for
   * details. Do NOT use this value for authentication purposes!
   *
   * @generated from field: types.PasswordState password_state = 1;
   */
  passwordState: PasswordState;
};

/**
 * Describes the message types.UserStatusV2.
 * Use `create(UserStatusV2Schema)` to create a new message.
 */
export const UserStatusV2Schema: GenMessage<UserStatusV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 136);

/**
 * UserSpecV2 is a specification for V2 user
 *
 * @generated from message types.UserSpecV2
 */
export type UserSpecV2 = Message<"types.UserSpecV2"> & {
  /**
   * OIDCIdentities lists associated OpenID Connect identities
   * that let user log in using externally verified identity
   *
   * @generated from field: repeated types.ExternalIdentity OIDCIdentities = 1;
   */
  OIDCIdentities: ExternalIdentity[];

  /**
   * SAMLIdentities lists associated SAML identities
   * that let user log in using externally verified identity
   *
   * @generated from field: repeated types.ExternalIdentity SAMLIdentities = 2;
   */
  SAMLIdentities: ExternalIdentity[];

  /**
   * GithubIdentities list associated Github OAuth2 identities
   * that let user log in using externally verified identity
   *
   * @generated from field: repeated types.ExternalIdentity GithubIdentities = 3;
   */
  GithubIdentities: ExternalIdentity[];

  /**
   * Roles is a list of roles assigned to user
   *
   * @generated from field: repeated string Roles = 4;
   */
  Roles: string[];

  /**
   * Traits are key/value pairs received from an identity provider (through
   * OIDC claims or SAML assertions) or from a system administrator for local
   * accounts. Traits are used to populate role variables.
   *
   * @generated from field: wrappers.LabelValues Traits = 5;
   */
  Traits?: LabelValues;

  /**
   * Status is a login status of the user
   *
   * @generated from field: types.LoginStatus Status = 6;
   */
  Status?: LoginStatus;

  /**
   * Expires if set sets TTL on the user
   *
   * @generated from field: google.protobuf.Timestamp Expires = 7;
   */
  Expires?: Timestamp;

  /**
   * CreatedBy holds information about agent or person created this user
   *
   * @generated from field: types.CreatedBy CreatedBy = 8;
   */
  CreatedBy?: CreatedBy;

  /**
   * LocalAuth holds sensitive data necessary for performing local
   * authentication
   *
   * @generated from field: types.LocalAuthSecrets LocalAuth = 9;
   */
  LocalAuth?: LocalAuthSecrets;

  /**
   * TrustedDeviceIDs contains the IDs of trusted devices enrolled by the user.
   *
   * Note that SSO users are transient and thus may contain an empty
   * TrustedDeviceIDs field, even though the user->device association exists
   * under the Device Trust subsystem. Do not rely on this field to determine
   * device associations or ownership, it exists for legacy/informative purposes
   * only.
   *
   * Managed by the Device Trust subsystem, avoid manual edits.
   *
   * @generated from field: repeated string TrustedDeviceIDs = 10;
   */
  TrustedDeviceIDs: string[];
};

/**
 * Describes the message types.UserSpecV2.
 * Use `create(UserSpecV2Schema)` to create a new message.
 */
export const UserSpecV2Schema: GenMessage<UserSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 137);

/**
 * ExternalIdentity is OpenID Connect/SAML or Github identity that is linked
 * to particular user and connector and lets user to log in using external
 * credentials, e.g. google
 *
 * @generated from message types.ExternalIdentity
 */
export type ExternalIdentity = Message<"types.ExternalIdentity"> & {
  /**
   * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
   *
   * @generated from field: string ConnectorID = 1;
   */
  ConnectorID: string;

  /**
   * Username is username supplied by external identity provider
   *
   * @generated from field: string Username = 2;
   */
  Username: string;

  /**
   * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
   *
   * @generated from field: string SAMLSingleLogoutURL = 3;
   */
  SAMLSingleLogoutURL: string;
};

/**
 * Describes the message types.ExternalIdentity.
 * Use `create(ExternalIdentitySchema)` to create a new message.
 */
export const ExternalIdentitySchema: GenMessage<ExternalIdentity> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 138);

/**
 * LoginStatus is a login status of the user
 *
 * @generated from message types.LoginStatus
 */
export type LoginStatus = Message<"types.LoginStatus"> & {
  /**
   * IsLocked tells us if user is locked
   *
   * @generated from field: bool IsLocked = 1;
   */
  IsLocked: boolean;

  /**
   * LockedMessage contains the message in case if user is locked
   *
   * @generated from field: string LockedMessage = 2;
   */
  LockedMessage: string;

  /**
   * LockedTime contains time when user was locked
   *
   * @generated from field: google.protobuf.Timestamp LockedTime = 3;
   */
  LockedTime?: Timestamp;

  /**
   * LockExpires contains time when this lock will expire
   *
   * @generated from field: google.protobuf.Timestamp LockExpires = 4;
   */
  LockExpires?: Timestamp;
};

/**
 * Describes the message types.LoginStatus.
 * Use `create(LoginStatusSchema)` to create a new message.
 */
export const LoginStatusSchema: GenMessage<LoginStatus> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 139);

/**
 * CreatedBy holds information about the person or agent who created the user
 *
 * @generated from message types.CreatedBy
 */
export type CreatedBy = Message<"types.CreatedBy"> & {
  /**
   * Identity if present means that user was automatically created by identity
   *
   * @generated from field: types.ConnectorRef Connector = 1;
   */
  Connector?: ConnectorRef;

  /**
   * Time specifies when user was created
   *
   * @generated from field: google.protobuf.Timestamp Time = 2;
   */
  Time?: Timestamp;

  /**
   * User holds information about user
   *
   * @generated from field: types.UserRef User = 3;
   */
  User?: UserRef;
};

/**
 * Describes the message types.CreatedBy.
 * Use `create(CreatedBySchema)` to create a new message.
 */
export const CreatedBySchema: GenMessage<CreatedBy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 140);

/**
 * LocalAuthSecrets holds sensitive data used to authenticate a local user.
 *
 * @generated from message types.LocalAuthSecrets
 */
export type LocalAuthSecrets = Message<"types.LocalAuthSecrets"> & {
  /**
   * PasswordHash encodes a combined salt & hash for password verification.
   *
   * @generated from field: bytes PasswordHash = 1;
   */
  PasswordHash: Uint8Array;

  /**
   * Deprecated 2nd factor fields, use MFA below instead.
   *
   * @generated from field: string TOTPKey = 2;
   */
  TOTPKey: string;

  /**
   * @generated from field: repeated types.MFADevice MFA = 5;
   */
  MFA: MFADevice[];

  /**
   * Webauthn holds settings necessary for webauthn local auth.
   * May be null for legacy users or users that haven't yet used webauthn as
   * their second factor.
   *
   * @generated from field: types.WebauthnLocalAuth Webauthn = 6;
   */
  Webauthn?: WebauthnLocalAuth;
};

/**
 * Describes the message types.LocalAuthSecrets.
 * Use `create(LocalAuthSecretsSchema)` to create a new message.
 */
export const LocalAuthSecretsSchema: GenMessage<LocalAuthSecrets> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 141);

/**
 * MFADevice is a multi-factor authentication device, such as a security key or
 * an OTP app.
 *
 * @generated from message types.MFADevice
 */
export type MFADevice = Message<"types.MFADevice"> & {
  /**
   * Boilerplate for implementing the Resource interface.
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * @generated from field: string sub_kind = 2;
   */
  subKind: string;

  /**
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * @generated from field: types.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * ID is a UUID of this device.
   *
   * @generated from field: string id = 5;
   */
  id: string;

  /**
   * @generated from field: google.protobuf.Timestamp added_at = 6;
   */
  addedAt?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp last_used = 7;
   */
  lastUsed?: Timestamp;

  /**
   * @generated from oneof types.MFADevice.device
   */
  device: {
    /**
     * @generated from field: types.TOTPDevice totp = 8;
     */
    value: TOTPDevice;
    case: "totp";
  } | {
    /**
     * @generated from field: types.U2FDevice u2f = 9;
     */
    value: U2FDevice;
    case: "u2f";
  } | {
    /**
     * @generated from field: types.WebauthnDevice webauthn = 10;
     */
    value: WebauthnDevice;
    case: "webauthn";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message types.MFADevice.
 * Use `create(MFADeviceSchema)` to create a new message.
 */
export const MFADeviceSchema: GenMessage<MFADevice> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 142);

/**
 * TOTPDevice holds the TOTP-specific fields of MFADevice.
 *
 * @generated from message types.TOTPDevice
 */
export type TOTPDevice = Message<"types.TOTPDevice"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;
};

/**
 * Describes the message types.TOTPDevice.
 * Use `create(TOTPDeviceSchema)` to create a new message.
 */
export const TOTPDeviceSchema: GenMessage<TOTPDevice> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 143);

/**
 * U2FDevice holds the U2F-specific fields of MFADevice.
 *
 * @generated from message types.U2FDevice
 */
export type U2FDevice = Message<"types.U2FDevice"> & {
  /**
   * KeyHandle uniquely identifies a key on a device
   *
   * @generated from field: bytes key_handle = 1;
   */
  keyHandle: Uint8Array;

  /**
   * PubKey is an DER encoded ecdsa public key
   *
   * @generated from field: bytes pub_key = 2;
   */
  pubKey: Uint8Array;

  /**
   * Counter is the latest seen value of the U2F usage counter.
   *
   * @generated from field: uint32 counter = 3;
   */
  counter: number;
};

/**
 * Describes the message types.U2FDevice.
 * Use `create(U2FDeviceSchema)` to create a new message.
 */
export const U2FDeviceSchema: GenMessage<U2FDevice> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 144);

/**
 * WebauthnDevice holds Webauthn-specific fields of MFADevice.
 *
 * @generated from message types.WebauthnDevice
 */
export type WebauthnDevice = Message<"types.WebauthnDevice"> & {
  /**
   * Credential ID for the authenticator.
   *
   * @generated from field: bytes credential_id = 1;
   */
  credentialId: Uint8Array;

  /**
   * Public key encoded in CBOR format.
   * Webauthn support various key algorithms; CBOR encoding is used to reflect
   * those choices.
   * See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
   * reference.
   *
   * @generated from field: bytes public_key_cbor = 2;
   */
  publicKeyCbor: Uint8Array;

  /**
   * Attestation format used by the authenticator, if any.
   *
   * @generated from field: string attestation_type = 3;
   */
  attestationType: string;

  /**
   * AAGUID is the globally unique identifier of the authenticator model.
   * Zeroed for U2F devices.
   *
   * @generated from field: bytes aaguid = 4;
   */
  aaguid: Uint8Array;

  /**
   * Signature counter for login operations.
   * Actual counter values received from the authenticator are expected to be
   * higher than the previously-stored value.
   *
   * @generated from field: uint32 signature_counter = 5;
   */
  signatureCounter: number;

  /**
   * Raw attestation object, as returned by the authentication during
   * registration.
   * Absent for legacy entries (Teleport 8.x).
   *
   * @generated from field: bytes attestation_object = 6;
   */
  attestationObject: Uint8Array;

  /**
   * True if a resident key was requested during registration.
   * Marks passwordless-capable devices.
   * (Note that resident_key=true represents the server-side / Relying Party
   * view of the registration process; the authenticator alone can determine
   * if a key is truly resident.)
   *
   * @generated from field: bool resident_key = 7;
   */
  residentKey: boolean;

  /**
   * Relying Party ID used by the credential.
   * Recorded on registration for new credentials, or on first successful
   * authentication for "old" credentials (created before the field existed).
   * Ideally, this is always the same as the configured RPID.
   * If an RPID change does happen, this helps Teleport detect it and react
   * accordingly.
   *
   * @generated from field: string credential_rp_id = 8;
   */
  credentialRpId: string;

  /**
   * Authenticator Backup Eligibility (BE) bit, recorded during registration or
   * backfill (for older authenticators).
   * https://w3c.github.io/webauthn/#authdata-flags-be
   *
   * @generated from field: google.protobuf.BoolValue credential_backup_eligible = 9;
   */
  credentialBackupEligible?: boolean;

  /**
   * Authenticator Backup State (BS) bit, recorded during registration or
   * backfill (for older authenticators).
   * https://w3c.github.io/webauthn/#authdata-flags-bs
   *
   * @generated from field: google.protobuf.BoolValue credential_backed_up = 10;
   */
  credentialBackedUp?: boolean;
};

/**
 * Describes the message types.WebauthnDevice.
 * Use `create(WebauthnDeviceSchema)` to create a new message.
 */
export const WebauthnDeviceSchema: GenMessage<WebauthnDevice> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 145);

/**
 * WebauthnLocalAuth holds settings necessary for local webauthn use.
 *
 * @generated from message types.WebauthnLocalAuth
 */
export type WebauthnLocalAuth = Message<"types.WebauthnLocalAuth"> & {
  /**
   * UserID is the random user handle generated for the user.
   * See https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy.
   *
   * @generated from field: bytes UserID = 1;
   */
  UserID: Uint8Array;
};

/**
 * Describes the message types.WebauthnLocalAuth.
 * Use `create(WebauthnLocalAuthSchema)` to create a new message.
 */
export const WebauthnLocalAuthSchema: GenMessage<WebauthnLocalAuth> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 146);

/**
 * ConnectorRef holds information about OIDC connector
 *
 * @generated from message types.ConnectorRef
 */
export type ConnectorRef = Message<"types.ConnectorRef"> & {
  /**
   * Type is connector type
   *
   * @generated from field: string Type = 1;
   */
  Type: string;

  /**
   * ID is connector ID
   *
   * @generated from field: string ID = 2;
   */
  ID: string;

  /**
   * Identity is external identity of the user
   *
   * @generated from field: string Identity = 3;
   */
  Identity: string;
};

/**
 * Describes the message types.ConnectorRef.
 * Use `create(ConnectorRefSchema)` to create a new message.
 */
export const ConnectorRefSchema: GenMessage<ConnectorRef> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 147);

/**
 * UserRef holds references to user
 *
 * @generated from message types.UserRef
 */
export type UserRef = Message<"types.UserRef"> & {
  /**
   * Name is name of the user
   *
   * @generated from field: string Name = 1;
   */
  Name: string;
};

/**
 * Describes the message types.UserRef.
 * Use `create(UserRefSchema)` to create a new message.
 */
export const UserRefSchema: GenMessage<UserRef> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 148);

/**
 * ReverseTunnelV2 is version 2 of the resource spec of the reverse tunnel
 *
 * @generated from message types.ReverseTunnelV2
 */
export type ReverseTunnelV2 = Message<"types.ReverseTunnelV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is a resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a reverse tunnel specification
   *
   * @generated from field: types.ReverseTunnelSpecV2 Spec = 5;
   */
  Spec?: ReverseTunnelSpecV2;
};

/**
 * Describes the message types.ReverseTunnelV2.
 * Use `create(ReverseTunnelV2Schema)` to create a new message.
 */
export const ReverseTunnelV2Schema: GenMessage<ReverseTunnelV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 149);

/**
 * ReverseTunnelSpecV2 is a specification for V2 reverse tunnel
 *
 * @generated from message types.ReverseTunnelSpecV2
 */
export type ReverseTunnelSpecV2 = Message<"types.ReverseTunnelSpecV2"> & {
  /**
   * ClusterName is a domain name of remote cluster we are connecting to
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName: string;

  /**
   * DialAddrs is a list of remote address to establish a connection to
   * it's always SSH over TCP
   *
   * @generated from field: repeated string DialAddrs = 2;
   */
  DialAddrs: string[];

  /**
   * Type is the type of reverse tunnel, either proxy or node.
   *
   * @generated from field: string Type = 3;
   */
  Type: string;
};

/**
 * Describes the message types.ReverseTunnelSpecV2.
 * Use `create(ReverseTunnelSpecV2Schema)` to create a new message.
 */
export const ReverseTunnelSpecV2Schema: GenMessage<ReverseTunnelSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 150);

/**
 * TunnelConnectionV2 is version 2 of the resource spec of the tunnel connection
 *
 * @generated from message types.TunnelConnectionV2
 */
export type TunnelConnectionV2 = Message<"types.TunnelConnectionV2"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is a resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a tunnel specification
   *
   * @generated from field: types.TunnelConnectionSpecV2 Spec = 5;
   */
  Spec?: TunnelConnectionSpecV2;
};

/**
 * Describes the message types.TunnelConnectionV2.
 * Use `create(TunnelConnectionV2Schema)` to create a new message.
 */
export const TunnelConnectionV2Schema: GenMessage<TunnelConnectionV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 151);

/**
 * TunnelConnectionSpecV2 is a specification for V2 tunnel connection
 *
 * @generated from message types.TunnelConnectionSpecV2
 */
export type TunnelConnectionSpecV2 = Message<"types.TunnelConnectionSpecV2"> & {
  /**
   * ClusterName is a name of the cluster
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName: string;

  /**
   * ProxyName is the name of the proxy server
   *
   * @generated from field: string ProxyName = 2;
   */
  ProxyName: string;

  /**
   * LastHeartbeat is a time of the last heartbeat
   *
   * @generated from field: google.protobuf.Timestamp LastHeartbeat = 3;
   */
  LastHeartbeat?: Timestamp;

  /**
   * Type is the type of reverse tunnel, either proxy or node.
   *
   * @generated from field: string Type = 4;
   */
  Type: string;
};

/**
 * Describes the message types.TunnelConnectionSpecV2.
 * Use `create(TunnelConnectionSpecV2Schema)` to create a new message.
 */
export const TunnelConnectionSpecV2Schema: GenMessage<TunnelConnectionSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 152);

/**
 * SemaphoreFilter encodes semaphore filtering params.
 * A semaphore filter matches a semaphore if all nonzero fields
 * match the corresponding semaphore fields (e.g. a filter which
 * specifies only `kind=foo` would match all semaphores of
 * kind `foo`).
 *
 * @generated from message types.SemaphoreFilter
 */
export type SemaphoreFilter = Message<"types.SemaphoreFilter"> & {
  /**
   * SemaphoreKind is the kind of the semaphore.
   *
   * @generated from field: string SemaphoreKind = 1;
   */
  SemaphoreKind: string;

  /**
   * SemaphoreName is the name of the semaphore.
   *
   * @generated from field: string SemaphoreName = 2;
   */
  SemaphoreName: string;
};

/**
 * Describes the message types.SemaphoreFilter.
 * Use `create(SemaphoreFilterSchema)` to create a new message.
 */
export const SemaphoreFilterSchema: GenMessage<SemaphoreFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 153);

/**
 * AcquireSemaphoreRequest holds semaphore lease acquisition parameters.
 *
 * @generated from message types.AcquireSemaphoreRequest
 */
export type AcquireSemaphoreRequest = Message<"types.AcquireSemaphoreRequest"> & {
  /**
   * SemaphoreKind is the kind of the semaphore.
   *
   * @generated from field: string SemaphoreKind = 1;
   */
  SemaphoreKind: string;

  /**
   * SemaphoreName is the name of the semaphore.
   *
   * @generated from field: string SemaphoreName = 2;
   */
  SemaphoreName: string;

  /**
   * MaxLeases is the maximum number of concurrent leases.  If acquisition
   * would cause more than MaxLeases to exist, acquisition must fail.
   *
   * @generated from field: int64 MaxLeases = 3;
   */
  MaxLeases: bigint;

  /**
   * Expires is the time at which this lease expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 4;
   */
  Expires?: Timestamp;

  /**
   * Holder identifies the entity holding the lease.
   *
   * @generated from field: string Holder = 5;
   */
  Holder: string;
};

/**
 * Describes the message types.AcquireSemaphoreRequest.
 * Use `create(AcquireSemaphoreRequestSchema)` to create a new message.
 */
export const AcquireSemaphoreRequestSchema: GenMessage<AcquireSemaphoreRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 154);

/**
 * SemaphoreLease represents lease acquired for semaphore
 *
 * @generated from message types.SemaphoreLease
 */
export type SemaphoreLease = Message<"types.SemaphoreLease"> & {
  /**
   * SemaphoreKind is the kind of the semaphore.
   *
   * @generated from field: string SemaphoreKind = 1;
   */
  SemaphoreKind: string;

  /**
   * SemaphoreName is the name of the semaphore.
   *
   * @generated from field: string SemaphoreName = 2;
   */
  SemaphoreName: string;

  /**
   * LeaseID uniquely identifies this lease.
   *
   * @generated from field: string LeaseID = 3;
   */
  LeaseID: string;

  /**
   * Expires is the time at which this lease expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 5;
   */
  Expires?: Timestamp;
};

/**
 * Describes the message types.SemaphoreLease.
 * Use `create(SemaphoreLeaseSchema)` to create a new message.
 */
export const SemaphoreLeaseSchema: GenMessage<SemaphoreLease> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 155);

/**
 * SemaphoreLeaseRef identifies an existent lease.
 *
 * @generated from message types.SemaphoreLeaseRef
 */
export type SemaphoreLeaseRef = Message<"types.SemaphoreLeaseRef"> & {
  /**
   * LeaseID is the unique ID of the lease.
   *
   * @generated from field: string LeaseID = 1;
   */
  LeaseID: string;

  /**
   * Expires is the time at which the lease expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 2;
   */
  Expires?: Timestamp;

  /**
   * Holder identifies the lease holder.
   *
   * @generated from field: string Holder = 3;
   */
  Holder: string;
};

/**
 * Describes the message types.SemaphoreLeaseRef.
 * Use `create(SemaphoreLeaseRefSchema)` to create a new message.
 */
export const SemaphoreLeaseRefSchema: GenMessage<SemaphoreLeaseRef> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 156);

/**
 * SemaphoreV3 implements Semaphore interface
 *
 * @generated from message types.SemaphoreV3
 */
export type SemaphoreV3 = Message<"types.SemaphoreV3"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is Semaphore metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a lease V3 spec
   *
   * @generated from field: types.SemaphoreSpecV3 Spec = 5;
   */
  Spec?: SemaphoreSpecV3;
};

/**
 * Describes the message types.SemaphoreV3.
 * Use `create(SemaphoreV3Schema)` to create a new message.
 */
export const SemaphoreV3Schema: GenMessage<SemaphoreV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 157);

/**
 * SemaphoreSpecV3 contains the data about lease
 *
 * @generated from message types.SemaphoreSpecV3
 */
export type SemaphoreSpecV3 = Message<"types.SemaphoreSpecV3"> & {
  /**
   * Leases is a list of all currently acquired leases.
   *
   * @generated from field: repeated types.SemaphoreLeaseRef Leases = 1;
   */
  Leases: SemaphoreLeaseRef[];
};

/**
 * Describes the message types.SemaphoreSpecV3.
 * Use `create(SemaphoreSpecV3Schema)` to create a new message.
 */
export const SemaphoreSpecV3Schema: GenMessage<SemaphoreSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 158);

/**
 * WebSessionV2 represents an application or UI web session.
 *
 * @generated from message types.WebSessionV2
 */
export type WebSessionV2 = Message<"types.WebSessionV2"> & {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is a resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a tunnel specification.
   *
   * @generated from field: types.WebSessionSpecV2 Spec = 5;
   */
  Spec?: WebSessionSpecV2;
};

/**
 * Describes the message types.WebSessionV2.
 * Use `create(WebSessionV2Schema)` to create a new message.
 */
export const WebSessionV2Schema: GenMessage<WebSessionV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 159);

/**
 * WebSessionSpecV2 is a specification for web session.
 *
 * @generated from message types.WebSessionSpecV2
 */
export type WebSessionSpecV2 = Message<"types.WebSessionSpecV2"> & {
  /**
   * User is the identity of the user to which the web session belongs.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * Pub is the SSH certificate for the user, marshaled in the authorized key
   * format.
   *
   * @generated from field: bytes Pub = 2;
   */
  Pub: Uint8Array;

  /**
   * Priv is the SSH private key for the user, in PEM-encoded PKCS#1 or PKCS#8
   * format. If TLSPriv is unset, this is also the TLS private key.
   *
   * @generated from field: bytes Priv = 3;
   */
  Priv: Uint8Array;

  /**
   * TLSCert is the X.509 certificate for the user (PEM-encoded).
   *
   * @generated from field: bytes TLSCert = 4;
   */
  TLSCert: Uint8Array;

  /**
   * BearerToken is a token that is paired with the session cookie for
   * authentication. It is periodically rotated so a stolen cookie itself
   * is not enough to steal a session. In addition it is used for CSRF
   * mitigation.
   *
   * @generated from field: string BearerToken = 5;
   */
  BearerToken: string;

  /**
   * BearerTokenExpires is the absolute time when the token expires.
   *
   * @generated from field: google.protobuf.Timestamp BearerTokenExpires = 6;
   */
  BearerTokenExpires?: Timestamp;

  /**
   * Expires is the absolute time when the session expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 7;
   */
  Expires?: Timestamp;

  /**
   * LoginTime is the time this user recently logged in.
   *
   * @generated from field: google.protobuf.Timestamp LoginTime = 8;
   */
  LoginTime?: Timestamp;

  /**
   * IdleTimeout is the max time a user can be inactive in a session.
   *
   * @generated from field: int64 IdleTimeout = 9;
   */
  IdleTimeout: bigint;

  /**
   * ConsumedAccessRequestID is the ID of the access request from which additional roles to assume
   * were obtained.
   *
   * @generated from field: string ConsumedAccessRequestID = 10;
   */
  ConsumedAccessRequestID: string;

  /**
   * SAMLSession is data associated with a SAML IdP session.
   *
   * @generated from field: types.SAMLSessionData SAMLSession = 11;
   */
  SAMLSession?: SAMLSessionData;

  /**
   * Device trust web authentication token.
   * May be exchanged for a single on-behalf-of device authentication attempt
   * (typically performed by Connect).
   * Only present if on-behalf-of device authentication is possible.
   *
   * @generated from field: types.DeviceWebToken DeviceWebToken = 12;
   */
  DeviceWebToken?: DeviceWebToken;

  /**
   * HasDeviceExtensions is true if the session's TLS and SSH certificates are
   * augmented with device extensions.
   *
   * @generated from field: bool HasDeviceExtensions = 13;
   */
  HasDeviceExtensions: boolean;

  /**
   * TrustedDeviceRequirement indicates whether access may be hindered by the
   * lack of a trusted device.
   *
   * If during login a device is required and DeviceWebToken is nil, then it's
   * likely the user needs to enroll their device to avoid impacting access.
   *
   * @generated from field: types.TrustedDeviceRequirement TrustedDeviceRequirement = 14;
   */
  TrustedDeviceRequirement: TrustedDeviceRequirement;

  /**
   * TLSPriv is the TLS private key for the user, in PEM-encoded PKCS#1 or PKCS#8
   * format. If unset, then Priv is used as both the SSH and TLS private key.
   *
   * @generated from field: bytes TLSPriv = 15;
   */
  TLSPriv: Uint8Array;
};

/**
 * Describes the message types.WebSessionSpecV2.
 * Use `create(WebSessionSpecV2Schema)` to create a new message.
 */
export const WebSessionSpecV2Schema: GenMessage<WebSessionSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 160);

/**
 * Web-focused view of teleport.devicetrust.v1.DeviceWebToken.
 *
 * @generated from message types.DeviceWebToken
 */
export type DeviceWebToken = Message<"types.DeviceWebToken"> & {
  /**
   * Opaque token identifier.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Opaque device web token, in plaintext, encoded in base64.RawURLEncoding
   * (so it is inherently safe for URl use).
   *
   * @generated from field: string token = 2;
   */
  token: string;
};

/**
 * Describes the message types.DeviceWebToken.
 * Use `create(DeviceWebTokenSchema)` to create a new message.
 */
export const DeviceWebTokenSchema: GenMessage<DeviceWebToken> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 161);

/**
 * WebSessionFilter encodes cache watch parameters for filtering web sessions.
 *
 * @generated from message types.WebSessionFilter
 */
export type WebSessionFilter = Message<"types.WebSessionFilter"> & {
  /**
   * User is the username to filter web sessions for.
   *
   * @generated from field: string User = 1;
   */
  User: string;
};

/**
 * Describes the message types.WebSessionFilter.
 * Use `create(WebSessionFilterSchema)` to create a new message.
 */
export const WebSessionFilterSchema: GenMessage<WebSessionFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 162);

/**
 * SAMLSessionData contains data for a SAML session.
 * Based on crewjam/saml's session object: https://github.com/crewjam/saml/blob/main/identity_provider.go
 *
 * @generated from message types.SAMLSessionData
 */
export type SAMLSessionData = Message<"types.SAMLSessionData"> & {
  /**
   * ID is the identifier for the SAML session.
   *
   * @generated from field: string ID = 1;
   */
  ID: string;

  /**
   * CreateTime is the time that the session was created.
   *
   * @generated from field: google.protobuf.Timestamp CreateTime = 2;
   */
  CreateTime?: Timestamp;

  /**
   * ExpireTime is the time that the session will expire.
   *
   * @generated from field: google.protobuf.Timestamp ExpireTime = 3;
   */
  ExpireTime?: Timestamp;

  /**
   * Index is the session index that allows the IdP to uniquely identify a session.
   *
   * @generated from field: string Index = 4;
   */
  Index: string;

  /**
   * NameID an identifier for the session.
   *
   * @generated from field: string NameID = 5;
   */
  NameID: string;

  /**
   * NameIDFormat is the format of the Name ID.
   *
   * @generated from field: string NameIDFormat = 6;
   */
  NameIDFormat: string;

  /**
   * SubjectID is the identifier for the subject of the session.
   *
   * @generated from field: string SubjectID = 7;
   */
  SubjectID: string;

  /**
   * Groups is a list of groups that the user has access to.
   *
   * @generated from field: repeated string Groups = 8;
   */
  Groups: string[];

  /**
   * UserName is the user's name.
   *
   * @generated from field: string UserName = 9;
   */
  UserName: string;

  /**
   * UserEmail is the user's e-mail.
   *
   * @generated from field: string UserEmail = 10;
   */
  UserEmail: string;

  /**
   * UserCommonName is the user's common name.
   *
   * @generated from field: string UserCommonName = 11;
   */
  UserCommonName: string;

  /**
   * UserSurname is the user's surname.
   *
   * @generated from field: string UserSurname = 12;
   */
  UserSurname: string;

  /**
   * UserGivenName is the user's given name.
   *
   * @generated from field: string UserGivenName = 13;
   */
  UserGivenName: string;

  /**
   * UserScopedAffiliation is the user's scoped affiliation.
   *
   * @generated from field: string UserScopedAffiliation = 14;
   */
  UserScopedAffiliation: string;

  /**
   * CustomAttributes are any custom attributes associated with the request.
   *
   * @generated from field: repeated types.SAMLAttribute CustomAttributes = 15;
   */
  CustomAttributes: SAMLAttribute[];
};

/**
 * Describes the message types.SAMLSessionData.
 * Use `create(SAMLSessionDataSchema)` to create a new message.
 */
export const SAMLSessionDataSchema: GenMessage<SAMLSessionData> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 163);

/**
 * SAMLAttribute contains an attribute name and associated values.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from message types.SAMLAttribute
 */
export type SAMLAttribute = Message<"types.SAMLAttribute"> & {
  /**
   * FriendlyName is a user readable name for the attribute.
   *
   * @generated from field: string FriendlyName = 1;
   */
  FriendlyName: string;

  /**
   * Name is a full name for the attribute, typically an OID value.
   *
   * @generated from field: string Name = 2;
   */
  Name: string;

  /**
   * NameFormat is the format of the name.
   *
   * @generated from field: string NameFormat = 3;
   */
  NameFormat: string;

  /**
   * Values is a list of attribute values.
   *
   * @generated from field: repeated types.SAMLAttributeValue Values = 4;
   */
  Values: SAMLAttributeValue[];
};

/**
 * Describes the message types.SAMLAttribute.
 * Use `create(SAMLAttributeSchema)` to create a new message.
 */
export const SAMLAttributeSchema: GenMessage<SAMLAttribute> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 164);

/**
 * SAMLAttributeValues contains a type, value, and an associated name ID block.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from message types.SAMLAttributeValue
 */
export type SAMLAttributeValue = Message<"types.SAMLAttributeValue"> & {
  /**
   * Type is the type of value this attribute represents.
   *
   * @generated from field: string Type = 1;
   */
  Type: string;

  /**
   * Value is the value of the attribute.
   *
   * @generated from field: string Value = 2;
   */
  Value: string;

  /**
   * NameID is a more restrictive identifier for the attribute value.
   *
   * @generated from field: types.SAMLNameID NameID = 3;
   */
  NameID?: SAMLNameID;
};

/**
 * Describes the message types.SAMLAttributeValue.
 * Use `create(SAMLAttributeValueSchema)` to create a new message.
 */
export const SAMLAttributeValueSchema: GenMessage<SAMLAttributeValue> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 165);

/**
 * SAMLNameID is a more restrictive identifier for an object in SAML.
 * Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
 *
 * @generated from message types.SAMLNameID
 */
export type SAMLNameID = Message<"types.SAMLNameID"> & {
  /**
   * NameQualifier is the domain that qualifies the identifier.
   *
   * @generated from field: string NameQualifier = 1;
   */
  NameQualifier: string;

  /**
   * SPNameQualifier qualifies the identifier with the name of the service provider.
   *
   * @generated from field: string SPNameQualifier = 2;
   */
  SPNameQualifier: string;

  /**
   * Format is the format of the identifier.
   *
   * @generated from field: string Format = 3;
   */
  Format: string;

  /**
   * SPProvidedID is an identifier established by the service provider.
   *
   * @generated from field: string SPProvidedID = 4;
   */
  SPProvidedID: string;

  /**
   * Value is the value of the name ID.
   *
   * @generated from field: string Value = 5;
   */
  Value: string;
};

/**
 * Describes the message types.SAMLNameID.
 * Use `create(SAMLNameIDSchema)` to create a new message.
 */
export const SAMLNameIDSchema: GenMessage<SAMLNameID> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 166);

/**
 * RemoteClusterV3 represents remote cluster resource specification
 *
 * @generated from message types.RemoteClusterV3
 */
export type RemoteClusterV3 = Message<"types.RemoteClusterV3"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is resource API version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Status is a remote cluster status
   *
   * @generated from field: types.RemoteClusterStatusV3 Status = 5;
   */
  Status?: RemoteClusterStatusV3;
};

/**
 * Describes the message types.RemoteClusterV3.
 * Use `create(RemoteClusterV3Schema)` to create a new message.
 */
export const RemoteClusterV3Schema: GenMessage<RemoteClusterV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 167);

/**
 * RemoteClusterStatusV3 represents status of the remote cluster
 *
 * @generated from message types.RemoteClusterStatusV3
 */
export type RemoteClusterStatusV3 = Message<"types.RemoteClusterStatusV3"> & {
  /**
   * Connection represents connection status, online or offline
   *
   * @generated from field: string Connection = 1;
   */
  Connection: string;

  /**
   * LastHeartbeat records last heartbeat of the cluster
   *
   * @generated from field: google.protobuf.Timestamp LastHeartbeat = 2;
   */
  LastHeartbeat?: Timestamp;
};

/**
 * Describes the message types.RemoteClusterStatusV3.
 * Use `create(RemoteClusterStatusV3Schema)` to create a new message.
 */
export const RemoteClusterStatusV3Schema: GenMessage<RemoteClusterStatusV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 168);

/**
 * KubernetesCluster is a named kubernetes API endpoint handled by a Server.
 *
 * TODO: deprecate and convert all usage to KubernetesClusterV3
 *
 * @generated from message types.KubernetesCluster
 */
export type KubernetesCluster = Message<"types.KubernetesCluster"> & {
  /**
   * Name is the name of this kubernetes cluster.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * StaticLabels is map of static labels associated with this cluster.
   * Used for RBAC.
   *
   * @generated from field: map<string, string> StaticLabels = 2;
   */
  StaticLabels: { [key: string]: string };

  /**
   * DynamicLabels is map of dynamic labels associated with this cluster.
   * Used for RBAC.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 3;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 };
};

/**
 * Describes the message types.KubernetesCluster.
 * Use `create(KubernetesClusterSchema)` to create a new message.
 */
export const KubernetesClusterSchema: GenMessage<KubernetesCluster> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 169);

/**
 * KubernetesClusterV3 represents a named kubernetes API endpoint.
 *
 * @generated from message types.KubernetesClusterV3
 */
export type KubernetesClusterV3 = Message<"types.KubernetesClusterV3"> & {
  /**
   * Kind is the cluster resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.KubernetesClusterSpecV3 Spec = 5;
   */
  Spec?: KubernetesClusterSpecV3;
};

/**
 * Describes the message types.KubernetesClusterV3.
 * Use `create(KubernetesClusterV3Schema)` to create a new message.
 */
export const KubernetesClusterV3Schema: GenMessage<KubernetesClusterV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 170);

/**
 * KubernetesClusterSpecV3 is a specification for a Kubernetes cluster.
 *
 * @generated from message types.KubernetesClusterSpecV3
 */
export type KubernetesClusterSpecV3 = Message<"types.KubernetesClusterSpecV3"> & {
  /**
   * DynamicLabels are the cluster's dynamic labels.
   *
   * @generated from field: map<string, types.CommandLabelV2> DynamicLabels = 1;
   */
  DynamicLabels: { [key: string]: CommandLabelV2 };

  /**
   * Kubeconfig is the kubeconfig file payload that grants access to the cluster.
   * If multiple contexts are specified, the first will be selected.
   *
   * @generated from field: bytes Kubeconfig = 2;
   */
  Kubeconfig: Uint8Array;

  /**
   * Azure holds the required Azure information for Teleport to access the cluster.
   *
   * @generated from field: types.KubeAzure Azure = 3;
   */
  Azure?: KubeAzure;

  /**
   * AWS holds the required AWS information for Teleport to access the cluster.
   *
   * @generated from field: types.KubeAWS AWS = 4;
   */
  AWS?: KubeAWS;

  /**
   * GCP holds the required GCP information for Teleport to access the cluster.
   *
   * @generated from field: types.KubeGCP GCP = 5;
   */
  GCP?: KubeGCP;
};

/**
 * Describes the message types.KubernetesClusterSpecV3.
 * Use `create(KubernetesClusterSpecV3Schema)` to create a new message.
 */
export const KubernetesClusterSpecV3Schema: GenMessage<KubernetesClusterSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 171);

/**
 * KubeAzure contains the Azure information about the cluster.
 *
 * @generated from message types.KubeAzure
 */
export type KubeAzure = Message<"types.KubeAzure"> & {
  /**
   * ResourceName is the AKS cluster name.
   *
   * @generated from field: string ResourceName = 1;
   */
  ResourceName: string;

  /**
   * ResourceGroup is the Azure resource group name.
   *
   * @generated from field: string ResourceGroup = 2;
   */
  ResourceGroup: string;

  /**
   * TenantID is the AKS cluster Tenant ID.
   *
   * @generated from field: string TenantID = 3;
   */
  TenantID: string;

  /**
   * SubscriptionID is the AKS cluster SubscriptionID.
   *
   * @generated from field: string SubscriptionID = 4;
   */
  SubscriptionID: string;
};

/**
 * Describes the message types.KubeAzure.
 * Use `create(KubeAzureSchema)` to create a new message.
 */
export const KubeAzureSchema: GenMessage<KubeAzure> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 172);

/**
 * KubeAWS contains the AWS information about the cluster.
 *
 * @generated from message types.KubeAWS
 */
export type KubeAWS = Message<"types.KubeAWS"> & {
  /**
   * Region is a AWS cloud region.
   *
   * @generated from field: string Region = 1;
   */
  Region: string;

  /**
   * AccountID is a AWS Account ID.
   *
   * @generated from field: string AccountID = 2;
   */
  AccountID: string;

  /**
   * Name is a AWS EKS cluster name.
   *
   * @generated from field: string Name = 3;
   */
  Name: string;
};

/**
 * Describes the message types.KubeAWS.
 * Use `create(KubeAWSSchema)` to create a new message.
 */
export const KubeAWSSchema: GenMessage<KubeAWS> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 173);

/**
 * KubeGCP contains the GCP information about the cluster.
 *
 * @generated from message types.KubeGCP
 */
export type KubeGCP = Message<"types.KubeGCP"> & {
  /**
   * Location is a GKE cluster location.
   *
   * @generated from field: string Location = 1;
   */
  Location: string;

  /**
   * ProjectID is the GKE Project ID.
   *
   * @generated from field: string ProjectID = 2;
   */
  ProjectID: string;

  /**
   * Name is a GCP GKE cluster name.
   *
   * @generated from field: string Name = 3;
   */
  Name: string;
};

/**
 * Describes the message types.KubeGCP.
 * Use `create(KubeGCPSchema)` to create a new message.
 */
export const KubeGCPSchema: GenMessage<KubeGCP> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 174);

/**
 * KubernetesClusterV3List represents a list of kubernetes clusters.
 *
 * @generated from message types.KubernetesClusterV3List
 */
export type KubernetesClusterV3List = Message<"types.KubernetesClusterV3List"> & {
  /**
   * KubernetesClusters is a list of kubernetes clusters resources.
   *
   * @generated from field: repeated types.KubernetesClusterV3 KubernetesClusters = 1;
   */
  KubernetesClusters: KubernetesClusterV3[];
};

/**
 * Describes the message types.KubernetesClusterV3List.
 * Use `create(KubernetesClusterV3ListSchema)` to create a new message.
 */
export const KubernetesClusterV3ListSchema: GenMessage<KubernetesClusterV3List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 175);

/**
 * KubernetesServerV3 represents a Kubernetes server.
 *
 * @generated from message types.KubernetesServerV3
 */
export type KubernetesServerV3 = Message<"types.KubernetesServerV3"> & {
  /**
   * Kind is the Kubernetes server resource kind. Always "kube_server".
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the Kubernetes server metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the Kubernetes server spec.
   *
   * @generated from field: types.KubernetesServerSpecV3 Spec = 5;
   */
  Spec?: KubernetesServerSpecV3;
};

/**
 * Describes the message types.KubernetesServerV3.
 * Use `create(KubernetesServerV3Schema)` to create a new message.
 */
export const KubernetesServerV3Schema: GenMessage<KubernetesServerV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 176);

/**
 * KubernetesServerSpecV3 is the Kubernetes server spec.
 *
 * @generated from message types.KubernetesServerSpecV3
 */
export type KubernetesServerSpecV3 = Message<"types.KubernetesServerSpecV3"> & {
  /**
   * Version is the Teleport version that the server is running.
   *
   * @generated from field: string Version = 1;
   */
  Version: string;

  /**
   * Hostname is the Kubernetes server hostname.
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname: string;

  /**
   * HostID is the Kubernetes server host uuid.
   *
   * @generated from field: string HostID = 3;
   */
  HostID: string;

  /**
   * Rotation contains the Kubernetes server CA rotation information.
   *
   * @generated from field: types.Rotation Rotation = 4;
   */
  Rotation?: Rotation;

  /**
   * Cluster is a Kubernetes Cluster proxied by this Kubernetes server.
   *
   * @generated from field: types.KubernetesClusterV3 Cluster = 5;
   */
  Cluster?: KubernetesClusterV3;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 6;
   */
  ProxyIDs: string[];
};

/**
 * Describes the message types.KubernetesServerSpecV3.
 * Use `create(KubernetesServerSpecV3Schema)` to create a new message.
 */
export const KubernetesServerSpecV3Schema: GenMessage<KubernetesServerSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 177);

/**
 * WebTokenV3 describes a web token. Web tokens are used as a transport to relay bearer tokens
 * to the client.
 * Initially bound to a web session, these have been factored out into a separate resource to
 * enable separate lifecycle management.
 *
 * @generated from message types.WebTokenV3
 */
export type WebTokenV3 = Message<"types.WebTokenV3"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is resource metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec defines the web token
   *
   * @generated from field: types.WebTokenSpecV3 Spec = 5;
   */
  Spec?: WebTokenSpecV3;
};

/**
 * Describes the message types.WebTokenV3.
 * Use `create(WebTokenV3Schema)` to create a new message.
 */
export const WebTokenV3Schema: GenMessage<WebTokenV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 178);

/**
 * WebTokenSpecV3 is a unique time-limited token bound to a user's web session
 *
 * @generated from message types.WebTokenSpecV3
 */
export type WebTokenSpecV3 = Message<"types.WebTokenSpecV3"> & {
  /**
   * User specifies the user the token is bound to.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * Token specifies the token's value.
   *
   * @generated from field: string Token = 2;
   */
  Token: string;
};

/**
 * Describes the message types.WebTokenSpecV3.
 * Use `create(WebTokenSpecV3Schema)` to create a new message.
 */
export const WebTokenSpecV3Schema: GenMessage<WebTokenSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 179);

/**
 * GetWebSessionRequest describes a request to query a web session
 *
 * @generated from message types.GetWebSessionRequest
 */
export type GetWebSessionRequest = Message<"types.GetWebSessionRequest"> & {
  /**
   * User specifies the user the web session is for.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * SessionID specifies the web session ID.
   *
   * @generated from field: string SessionID = 2;
   */
  SessionID: string;
};

/**
 * Describes the message types.GetWebSessionRequest.
 * Use `create(GetWebSessionRequestSchema)` to create a new message.
 */
export const GetWebSessionRequestSchema: GenMessage<GetWebSessionRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 180);

/**
 * DeleteWebSessionRequest describes a request to delete a web session
 *
 * @generated from message types.DeleteWebSessionRequest
 */
export type DeleteWebSessionRequest = Message<"types.DeleteWebSessionRequest"> & {
  /**
   * User specifies the user the session is bound to
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * SessionID specifies the web session ID to delete.
   *
   * @generated from field: string SessionID = 2;
   */
  SessionID: string;
};

/**
 * Describes the message types.DeleteWebSessionRequest.
 * Use `create(DeleteWebSessionRequestSchema)` to create a new message.
 */
export const DeleteWebSessionRequestSchema: GenMessage<DeleteWebSessionRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 181);

/**
 * GetWebTokenRequest describes a request to query a web token
 *
 * @generated from message types.GetWebTokenRequest
 */
export type GetWebTokenRequest = Message<"types.GetWebTokenRequest"> & {
  /**
   * User specifies the user the token is for.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * Token specifies the token to get.
   *
   * @generated from field: string Token = 2;
   */
  Token: string;
};

/**
 * Describes the message types.GetWebTokenRequest.
 * Use `create(GetWebTokenRequestSchema)` to create a new message.
 */
export const GetWebTokenRequestSchema: GenMessage<GetWebTokenRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 182);

/**
 * DeleteWebTokenRequest describes a request to delete a web token
 *
 * @generated from message types.DeleteWebTokenRequest
 */
export type DeleteWebTokenRequest = Message<"types.DeleteWebTokenRequest"> & {
  /**
   * User specifies the user the token is for.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * Token specifies the token to delete.
   *
   * @generated from field: string Token = 2;
   */
  Token: string;
};

/**
 * Describes the message types.DeleteWebTokenRequest.
 * Use `create(DeleteWebTokenRequestSchema)` to create a new message.
 */
export const DeleteWebTokenRequestSchema: GenMessage<DeleteWebTokenRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 183);

/**
 * ResourceRequest is a request relating to a named resource.
 *
 * @generated from message types.ResourceRequest
 */
export type ResourceRequest = Message<"types.ResourceRequest"> & {
  /**
   * Name is the name of the resource.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;
};

/**
 * Describes the message types.ResourceRequest.
 * Use `create(ResourceRequestSchema)` to create a new message.
 */
export const ResourceRequestSchema: GenMessage<ResourceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 184);

/**
 * ResourceWithSecretsRequest is a request relating to a named resource with secrets.
 *
 * @generated from message types.ResourceWithSecretsRequest
 */
export type ResourceWithSecretsRequest = Message<"types.ResourceWithSecretsRequest"> & {
  /**
   * Name is the name of the resource.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * WithSecrets specifies whether to load associated secrets.
   *
   * @generated from field: bool WithSecrets = 2;
   */
  WithSecrets: boolean;
};

/**
 * Describes the message types.ResourceWithSecretsRequest.
 * Use `create(ResourceWithSecretsRequestSchema)` to create a new message.
 */
export const ResourceWithSecretsRequestSchema: GenMessage<ResourceWithSecretsRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 185);

/**
 * ResourcesWithSecretsRequest is a request relating to resources with secrets.
 *
 * @generated from message types.ResourcesWithSecretsRequest
 */
export type ResourcesWithSecretsRequest = Message<"types.ResourcesWithSecretsRequest"> & {
  /**
   * WithSecrets specifies whether to load associated secrets.
   *
   * @generated from field: bool WithSecrets = 1;
   */
  WithSecrets: boolean;
};

/**
 * Describes the message types.ResourcesWithSecretsRequest.
 * Use `create(ResourcesWithSecretsRequestSchema)` to create a new message.
 */
export const ResourcesWithSecretsRequestSchema: GenMessage<ResourcesWithSecretsRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 186);

/**
 * ResourcesInNamespaceRequest is a request relating to a named resource in the given namespace.
 *
 * @generated from message types.ResourceInNamespaceRequest
 */
export type ResourceInNamespaceRequest = Message<"types.ResourceInNamespaceRequest"> & {
  /**
   * Name is the name of the resource.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Namespace is the namespace of resources.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace: string;
};

/**
 * Describes the message types.ResourceInNamespaceRequest.
 * Use `create(ResourceInNamespaceRequestSchema)` to create a new message.
 */
export const ResourceInNamespaceRequestSchema: GenMessage<ResourceInNamespaceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 187);

/**
 * ResourcesInNamespaceRequest is a request relating to resources in the given namespace.
 *
 * @generated from message types.ResourcesInNamespaceRequest
 */
export type ResourcesInNamespaceRequest = Message<"types.ResourcesInNamespaceRequest"> & {
  /**
   * Namespace is the namespace of resources.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace: string;
};

/**
 * Describes the message types.ResourcesInNamespaceRequest.
 * Use `create(ResourcesInNamespaceRequestSchema)` to create a new message.
 */
export const ResourcesInNamespaceRequestSchema: GenMessage<ResourcesInNamespaceRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 188);

/**
 * OIDCConnectorV3 represents an OIDC connector.
 *
 * @generated from message types.OIDCConnectorV3
 */
export type OIDCConnectorV3 = Message<"types.OIDCConnectorV3"> & {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an OIDC connector specification.
   *
   * @generated from field: types.OIDCConnectorSpecV3 Spec = 5;
   */
  Spec?: OIDCConnectorSpecV3;
};

/**
 * Describes the message types.OIDCConnectorV3.
 * Use `create(OIDCConnectorV3Schema)` to create a new message.
 */
export const OIDCConnectorV3Schema: GenMessage<OIDCConnectorV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 189);

/**
 * OIDCConnectorV3List is a list of OIDC connectors.
 *
 * @generated from message types.OIDCConnectorV3List
 */
export type OIDCConnectorV3List = Message<"types.OIDCConnectorV3List"> & {
  /**
   * OIDCConnectors is a list of OIDC connectors.
   *
   * @generated from field: repeated types.OIDCConnectorV3 OIDCConnectors = 1;
   */
  OIDCConnectors: OIDCConnectorV3[];
};

/**
 * Describes the message types.OIDCConnectorV3List.
 * Use `create(OIDCConnectorV3ListSchema)` to create a new message.
 */
export const OIDCConnectorV3ListSchema: GenMessage<OIDCConnectorV3List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 190);

/**
 * OIDCConnectorSpecV3 is an OIDC connector specification.
 *
 * It specifies configuration for Open ID Connect compatible external
 * identity provider: https://openid.net/specs/openid-connect-core-1_0.html
 *
 * @generated from message types.OIDCConnectorSpecV3
 */
export type OIDCConnectorSpecV3 = Message<"types.OIDCConnectorSpecV3"> & {
  /**
   * IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
   *
   * @generated from field: string IssuerURL = 1;
   */
  IssuerURL: string;

  /**
   * ClientID is the id of the authentication client (Teleport Auth server).
   *
   * @generated from field: string ClientID = 2;
   */
  ClientID: string;

  /**
   * ClientSecret is used to authenticate the client.
   *
   * @generated from field: string ClientSecret = 3;
   */
  ClientSecret: string;

  /**
   * ACR is an Authentication Context Class Reference value. The meaning of the ACR
   * value is context-specific and varies for identity providers.
   *
   * @generated from field: string ACR = 5;
   */
  ACR: string;

  /**
   * Provider is the external identity provider.
   *
   * @generated from field: string Provider = 6;
   */
  Provider: string;

  /**
   * Display is the friendly name for this provider.
   *
   * @generated from field: string Display = 7;
   */
  Display: string;

  /**
   * Scope specifies additional scopes set by provider.
   *
   * @generated from field: repeated string Scope = 8;
   */
  Scope: string[];

  /**
   * Prompt is an optional OIDC prompt. An empty string omits prompt.
   * If not specified, it defaults to select_account for backwards compatibility.
   *
   * @generated from field: string Prompt = 9;
   */
  Prompt: string;

  /**
   * ClaimsToRoles specifies a dynamic mapping from claims to roles.
   *
   * @generated from field: repeated types.ClaimMapping ClaimsToRoles = 10;
   */
  ClaimsToRoles: ClaimMapping[];

  /**
   * GoogleServiceAccountURI is a path to a google service account uri.
   *
   * @generated from field: string GoogleServiceAccountURI = 11;
   */
  GoogleServiceAccountURI: string;

  /**
   * GoogleServiceAccount is a string containing google service account credentials.
   *
   * @generated from field: string GoogleServiceAccount = 12;
   */
  GoogleServiceAccount: string;

  /**
   * GoogleAdminEmail is the email of a google admin to impersonate.
   *
   * @generated from field: string GoogleAdminEmail = 13;
   */
  GoogleAdminEmail: string;

  /**
   * RedirectURLs is a list of callback URLs which the identity provider can use
   * to redirect the client back to the Teleport Proxy to complete authentication.
   * This list should match the URLs on the provider's side. The URL used for a
   * given auth request will be chosen to match the requesting Proxy's public
   * address. If there is no match, the first url in the list will be used.
   *
   * @generated from field: wrappers.StringValues RedirectURLs = 14;
   */
  RedirectURLs?: StringValues;

  /**
   * AllowUnverifiedEmail tells the connector to accept OIDC users with unverified emails.
   *
   * @generated from field: bool AllowUnverifiedEmail = 15;
   */
  AllowUnverifiedEmail: boolean;

  /**
   * UsernameClaim specifies the name of the claim from the OIDC connector to be used as the user's username.
   *
   * @generated from field: string UsernameClaim = 16;
   */
  UsernameClaim: string;

  /**
   * MaxAge is the amount of time that user logins are
   * valid for. If a user logs in, but then does not login again
   * within this time period, they will be forced to re-authenticate.
   *
   * @generated from field: types.MaxAge MaxAge = 17;
   */
  MaxAge?: MaxAge;

  /**
   * ClientRedirectSettings defines which client redirect URLs are allowed for
   * non-browser SSO logins other than the standard localhost ones.
   *
   * @generated from field: types.SSOClientRedirectSettings ClientRedirectSettings = 18;
   */
  ClientRedirectSettings?: SSOClientRedirectSettings;
};

/**
 * Describes the message types.OIDCConnectorSpecV3.
 * Use `create(OIDCConnectorSpecV3Schema)` to create a new message.
 */
export const OIDCConnectorSpecV3Schema: GenMessage<OIDCConnectorSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 191);

/**
 * MaxAge allows the max_age parameter to be nullable to preserve backwards
 * compatibility. The duration is stored as nanoseconds.
 *
 * @generated from message types.MaxAge
 */
export type MaxAge = Message<"types.MaxAge"> & {
  /**
   * @generated from field: int64 Value = 1;
   */
  Value: bigint;
};

/**
 * Describes the message types.MaxAge.
 * Use `create(MaxAgeSchema)` to create a new message.
 */
export const MaxAgeSchema: GenMessage<MaxAge> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 192);

/**
 * SSOClientRedirectSettings contains settings to define which additional client
 * redirect URLs should be allowed for non-browser SSO logins.
 *
 * @generated from message types.SSOClientRedirectSettings
 */
export type SSOClientRedirectSettings = Message<"types.SSOClientRedirectSettings"> & {
  /**
   * a list of hostnames allowed for https client redirect URLs
   *
   * @generated from field: repeated string allowed_https_hostnames = 1;
   */
  allowedHttpsHostnames: string[];

  /**
   * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
   *
   * @generated from field: repeated string insecure_allowed_cidr_ranges = 2;
   */
  insecureAllowedCidrRanges: string[];
};

/**
 * Describes the message types.SSOClientRedirectSettings.
 * Use `create(SSOClientRedirectSettingsSchema)` to create a new message.
 */
export const SSOClientRedirectSettingsSchema: GenMessage<SSOClientRedirectSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 193);

/**
 * OIDCAuthRequest is a request to authenticate with OIDC
 * provider, the state about request is managed by auth server
 *
 * @generated from message types.OIDCAuthRequest
 */
export type OIDCAuthRequest = Message<"types.OIDCAuthRequest"> & {
  /**
   * ConnectorID is ID of OIDC connector this request uses
   *
   * @generated from field: string ConnectorID = 1;
   */
  ConnectorID: string;

  /**
   * Type is opaque string that helps callbacks identify the request type
   *
   * @generated from field: string Type = 2;
   */
  Type: string;

  /**
   * CheckUser tells validator if it should expect and check user
   *
   * @generated from field: bool CheckUser = 3;
   */
  CheckUser: boolean;

  /**
   * StateToken is generated by service and is used to validate
   * request coming from
   *
   * @generated from field: string StateToken = 4;
   */
  StateToken: string;

  /**
   * CSRFToken is associated with user web session token
   *
   * @generated from field: string CSRFToken = 5;
   */
  CSRFToken: string;

  /**
   * RedirectURL will be used to route the user back to a
   * Teleport Proxy after the oidc login attempt in the browser.
   *
   * @generated from field: string RedirectURL = 6;
   */
  RedirectURL: string;

  /**
   * PublicKey is an optional public key, users want these keys to be signed by
   * auth servers user CA in case of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes PublicKey = 7 [deprecated = true];
   * @deprecated
   */
  PublicKey: Uint8Array;

  /**
   * CertTTL is the TTL of the certificate user wants to get
   *
   * @generated from field: int64 CertTTL = 8;
   */
  CertTTL: bigint;

  /**
   * CreateWebSession indicates if user wants to generate a web
   * session after successful authentication
   *
   * @generated from field: bool CreateWebSession = 9;
   */
  CreateWebSession: boolean;

  /**
   * ClientRedirectURL is a URL client wants to be redirected
   * after successful authentication
   *
   * @generated from field: string ClientRedirectURL = 10;
   */
  ClientRedirectURL: string;

  /**
   * Compatibility specifies OpenSSH compatibility flags.
   *
   * @generated from field: string Compatibility = 11;
   */
  Compatibility: string;

  /**
   * RouteToCluster is the name of Teleport cluster to issue credentials for.
   *
   * @generated from field: string RouteToCluster = 12;
   */
  RouteToCluster: string;

  /**
   * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
   *
   * @generated from field: string KubernetesCluster = 13;
   */
  KubernetesCluster: string;

  /**
   * SSOTestFlow indicates if the request is part of the test flow.
   *
   * @generated from field: bool SSOTestFlow = 14;
   */
  SSOTestFlow: boolean;

  /**
   * ConnectorSpec is embedded connector spec for use in test flow.
   *
   * @generated from field: types.OIDCConnectorSpecV3 ConnectorSpec = 15;
   */
  ConnectorSpec?: OIDCConnectorSpecV3;

  /**
   * ProxyAddress is an optional address which can be used to
   * find a redirect url from the OIDC connector which matches
   * the address. If there is no match, the default redirect
   * url will be used.
   *
   * @generated from field: string ProxyAddress = 16;
   */
  ProxyAddress: string;

  /**
   * attestation_statement is an attestation statement for the given public key.
   *
   * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement attestation_statement = 17 [deprecated = true];
   * @deprecated
   */
  attestationStatement?: AttestationStatement;

  /**
   * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
   *
   * @generated from field: string ClientLoginIP = 18;
   */
  ClientLoginIP: string;

  /**
   * ClientUserAgent is the user agent of the Web browser, used for issuing a
   * DeviceWebToken.
   *
   * @generated from field: string ClientUserAgent = 19;
   */
  ClientUserAgent: string;

  /**
   * SshPublicKey is an optional public key to use as the subject of an issued
   * SSH cert in case of successful auth.
   *
   * @generated from field: bytes ssh_public_key = 20;
   */
  sshPublicKey: Uint8Array;

  /**
   * TlsPublicKey is an optional public key to use as the subject of an issued
   * TLS cert in case of successful auth.
   *
   * @generated from field: bytes tls_public_key = 21;
   */
  tlsPublicKey: Uint8Array;

  /**
   * SshAttestationStatement is an attestation statement for the given SSH public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 22;
   */
  sshAttestationStatement?: AttestationStatement;

  /**
   * TlsAttestationStatement is an attestation statement for the given TLS public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 23;
   */
  tlsAttestationStatement?: AttestationStatement;
};

/**
 * Describes the message types.OIDCAuthRequest.
 * Use `create(OIDCAuthRequestSchema)` to create a new message.
 */
export const OIDCAuthRequestSchema: GenMessage<OIDCAuthRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 194);

/**
 * SAMLConnectorV2 represents a SAML connector.
 *
 * @generated from message types.SAMLConnectorV2
 */
export type SAMLConnectorV2 = Message<"types.SAMLConnectorV2"> & {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an SAML connector specification.
   *
   * @generated from field: types.SAMLConnectorSpecV2 Spec = 5;
   */
  Spec?: SAMLConnectorSpecV2;
};

/**
 * Describes the message types.SAMLConnectorV2.
 * Use `create(SAMLConnectorV2Schema)` to create a new message.
 */
export const SAMLConnectorV2Schema: GenMessage<SAMLConnectorV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 195);

/**
 * SAMLConnectorV2List is a list of SAML connectors.
 *
 * @generated from message types.SAMLConnectorV2List
 */
export type SAMLConnectorV2List = Message<"types.SAMLConnectorV2List"> & {
  /**
   * SAMLConnectors is a list of SAML connectors.
   *
   * @generated from field: repeated types.SAMLConnectorV2 SAMLConnectors = 1;
   */
  SAMLConnectors: SAMLConnectorV2[];
};

/**
 * Describes the message types.SAMLConnectorV2List.
 * Use `create(SAMLConnectorV2ListSchema)` to create a new message.
 */
export const SAMLConnectorV2ListSchema: GenMessage<SAMLConnectorV2List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 196);

/**
 * SAMLConnectorSpecV2 is a SAML connector specification.
 *
 * @generated from message types.SAMLConnectorSpecV2
 */
export type SAMLConnectorSpecV2 = Message<"types.SAMLConnectorSpecV2"> & {
  /**
   * Issuer is the identity provider issuer.
   *
   * @generated from field: string Issuer = 1;
   */
  Issuer: string;

  /**
   * SSO is the URL of the identity provider's SSO service.
   *
   * @generated from field: string SSO = 2;
   */
  SSO: string;

  /**
   * Cert is the identity provider certificate PEM.
   * IDP signs `<Response>` responses using this certificate.
   *
   * @generated from field: string Cert = 3;
   */
  Cert: string;

  /**
   * Display controls how this connector is displayed.
   *
   * @generated from field: string Display = 4;
   */
  Display: string;

  /**
   * AssertionConsumerService is a URL for assertion consumer service
   * on the service provider (Teleport's side).
   *
   * @generated from field: string AssertionConsumerService = 5;
   */
  AssertionConsumerService: string;

  /**
   * Audience uniquely identifies our service provider.
   *
   * @generated from field: string Audience = 6;
   */
  Audience: string;

  /**
   * ServiceProviderIssuer is the issuer of the service provider (Teleport).
   *
   * @generated from field: string ServiceProviderIssuer = 7;
   */
  ServiceProviderIssuer: string;

  /**
   * EntityDescriptor is XML with descriptor. It can be used to supply configuration
   * parameters in one XML file rather than supplying them in the individual elements.
   *
   * @generated from field: string EntityDescriptor = 8;
   */
  EntityDescriptor: string;

  /**
   * EntityDescriptorURL is a URL that supplies a configuration XML.
   *
   * @generated from field: string EntityDescriptorURL = 9;
   */
  EntityDescriptorURL: string;

  /**
   * AttributesToRoles is a list of mappings of attribute statements to roles.
   *
   * @generated from field: repeated types.AttributeMapping AttributesToRoles = 10;
   */
  AttributesToRoles: AttributeMapping[];

  /**
   * SigningKeyPair is an x509 key pair used to sign AuthnRequest.
   *
   * @generated from field: types.AsymmetricKeyPair SigningKeyPair = 11;
   */
  SigningKeyPair?: AsymmetricKeyPair;

  /**
   * Provider is the external identity provider.
   *
   * @generated from field: string Provider = 12;
   */
  Provider: string;

  /**
   * EncryptionKeyPair is a key pair used for decrypting SAML assertions.
   *
   * @generated from field: types.AsymmetricKeyPair EncryptionKeyPair = 13;
   */
  EncryptionKeyPair?: AsymmetricKeyPair;

  /**
   * AllowIDPInitiated is a flag that indicates if the connector can be used for IdP-initiated
   * logins.
   *
   * @generated from field: bool AllowIDPInitiated = 14;
   */
  AllowIDPInitiated: boolean;

  /**
   * ClientRedirectSettings defines which client redirect URLs are allowed for
   * non-browser SSO logins other than the standard localhost ones.
   *
   * @generated from field: types.SSOClientRedirectSettings ClientRedirectSettings = 15;
   */
  ClientRedirectSettings?: SSOClientRedirectSettings;

  /**
   * SingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out). If this is not provided, SLO is disabled.
   *
   * @generated from field: string SingleLogoutURL = 16;
   */
  SingleLogoutURL: string;
};

/**
 * Describes the message types.SAMLConnectorSpecV2.
 * Use `create(SAMLConnectorSpecV2Schema)` to create a new message.
 */
export const SAMLConnectorSpecV2Schema: GenMessage<SAMLConnectorSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 197);

/**
 * SAMLAuthRequest is a request to authenticate with SAML
 * provider, the state about request is managed by auth server.
 *
 * @generated from message types.SAMLAuthRequest
 */
export type SAMLAuthRequest = Message<"types.SAMLAuthRequest"> & {
  /**
   * ID is a unique request ID.
   *
   * @generated from field: string ID = 1;
   */
  ID: string;

  /**
   * ConnectorID is ID of OIDC connector this request uses.
   *
   * @generated from field: string ConnectorID = 2;
   */
  ConnectorID: string;

  /**
   * Type is opaque string that helps callbacks identify the request type.
   *
   * @generated from field: string Type = 3;
   */
  Type: string;

  /**
   * CheckUser tells validator if it should expect and check user.
   *
   * @generated from field: bool CheckUser = 4;
   */
  CheckUser: boolean;

  /**
   * RedirectURL will be used by browser.
   *
   * @generated from field: string RedirectURL = 5;
   */
  RedirectURL: string;

  /**
   * PublicKey is an optional public key, users want these
   * keys to be signed by auth servers user CA in case
   * of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes PublicKey = 6 [deprecated = true];
   * @deprecated
   */
  PublicKey: Uint8Array;

  /**
   * CertTTL is the TTL of the certificate user wants to get.
   *
   * @generated from field: int64 CertTTL = 7;
   */
  CertTTL: bigint;

  /**
   * CSRFToken is associated with user web session token.
   *
   * @generated from field: string CSRFToken = 8;
   */
  CSRFToken: string;

  /**
   * CreateWebSession indicates if user wants to generate a web
   * session after successful authentication.
   *
   * @generated from field: bool CreateWebSession = 9;
   */
  CreateWebSession: boolean;

  /**
   * ClientRedirectURL is a URL client wants to be redirected
   * after successful authentication.
   *
   * @generated from field: string ClientRedirectURL = 10;
   */
  ClientRedirectURL: string;

  /**
   * Compatibility specifies OpenSSH compatibility flags.
   *
   * @generated from field: string Compatibility = 11;
   */
  Compatibility: string;

  /**
   * RouteToCluster is the name of Teleport cluster to issue credentials for.
   *
   * @generated from field: string RouteToCluster = 12;
   */
  RouteToCluster: string;

  /**
   * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
   *
   * @generated from field: string KubernetesCluster = 13;
   */
  KubernetesCluster: string;

  /**
   * SSOTestFlow indicates if the request is part of the test flow.
   *
   * @generated from field: bool SSOTestFlow = 14;
   */
  SSOTestFlow: boolean;

  /**
   * ConnectorSpec is embedded connector spec for use in test flow.
   *
   * @generated from field: types.SAMLConnectorSpecV2 ConnectorSpec = 15;
   */
  ConnectorSpec?: SAMLConnectorSpecV2;

  /**
   * attestation_statement is an attestation statement for the given public key.
   *
   * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement attestation_statement = 16;
   */
  attestationStatement?: AttestationStatement;

  /**
   * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
   *
   * @generated from field: string ClientLoginIP = 17;
   */
  ClientLoginIP: string;

  /**
   * ClientUserAgent is the user agent of the Web browser, used for issuing a
   * DeviceWebToken.
   *
   * @generated from field: string ClientUserAgent = 18;
   */
  ClientUserAgent: string;

  /**
   * SshPublicKey is an optional public key to use as the subject of an issued
   * SSH cert in case of successful auth.
   *
   * @generated from field: bytes ssh_public_key = 19;
   */
  sshPublicKey: Uint8Array;

  /**
   * TlsPublicKey is an optional public key to use as the subject of an issued
   * TLS cert in case of successful auth.
   *
   * @generated from field: bytes tls_public_key = 20;
   */
  tlsPublicKey: Uint8Array;

  /**
   * SshAttestationStatement is an attestation statement for the given SSH public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21;
   */
  sshAttestationStatement?: AttestationStatement;

  /**
   * TlsAttestationStatement is an attestation statement for the given TLS public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22;
   */
  tlsAttestationStatement?: AttestationStatement;
};

/**
 * Describes the message types.SAMLAuthRequest.
 * Use `create(SAMLAuthRequestSchema)` to create a new message.
 */
export const SAMLAuthRequestSchema: GenMessage<SAMLAuthRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 198);

/**
 * AttributeMapping maps a SAML attribute statement to teleport roles.
 *
 * @generated from message types.AttributeMapping
 */
export type AttributeMapping = Message<"types.AttributeMapping"> & {
  /**
   * Name is an attribute statement name.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Value is an attribute statement value to match.
   *
   * @generated from field: string Value = 2;
   */
  Value: string;

  /**
   * Roles is a list of static teleport roles to map to.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[];
};

/**
 * Describes the message types.AttributeMapping.
 * Use `create(AttributeMappingSchema)` to create a new message.
 */
export const AttributeMappingSchema: GenMessage<AttributeMapping> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 199);

/**
 * AsymmetricKeyPair is a combination of a public certificate and
 * private key that can be used for encryption and signing.
 *
 * @generated from message types.AsymmetricKeyPair
 */
export type AsymmetricKeyPair = Message<"types.AsymmetricKeyPair"> & {
  /**
   * PrivateKey is a PEM encoded x509 private key.
   *
   * @generated from field: string PrivateKey = 1;
   */
  PrivateKey: string;

  /**
   * Cert is a PEM-encoded x509 certificate.
   *
   * @generated from field: string Cert = 2;
   */
  Cert: string;
};

/**
 * Describes the message types.AsymmetricKeyPair.
 * Use `create(AsymmetricKeyPairSchema)` to create a new message.
 */
export const AsymmetricKeyPairSchema: GenMessage<AsymmetricKeyPair> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 200);

/**
 * GithubConnectorV3 represents a Github connector.
 *
 * @generated from message types.GithubConnectorV3
 */
export type GithubConnectorV3 = Message<"types.GithubConnectorV3"> & {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v3`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is an Github connector specification.
   *
   * @generated from field: types.GithubConnectorSpecV3 Spec = 5;
   */
  Spec?: GithubConnectorSpecV3;
};

/**
 * Describes the message types.GithubConnectorV3.
 * Use `create(GithubConnectorV3Schema)` to create a new message.
 */
export const GithubConnectorV3Schema: GenMessage<GithubConnectorV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 201);

/**
 * GithubConnectorV3List is a list of Github connectors.
 *
 * @generated from message types.GithubConnectorV3List
 */
export type GithubConnectorV3List = Message<"types.GithubConnectorV3List"> & {
  /**
   * GithubConnectors is a list of Github connectors.
   *
   * @generated from field: repeated types.GithubConnectorV3 GithubConnectors = 1;
   */
  GithubConnectors: GithubConnectorV3[];
};

/**
 * Describes the message types.GithubConnectorV3List.
 * Use `create(GithubConnectorV3ListSchema)` to create a new message.
 */
export const GithubConnectorV3ListSchema: GenMessage<GithubConnectorV3List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 202);

/**
 * GithubConnectorSpecV3 is a Github connector specification.
 *
 * @generated from message types.GithubConnectorSpecV3
 */
export type GithubConnectorSpecV3 = Message<"types.GithubConnectorSpecV3"> & {
  /**
   * ClientID is the Github OAuth app client ID.
   *
   * @generated from field: string ClientID = 1;
   */
  ClientID: string;

  /**
   * ClientSecret is the Github OAuth app client secret.
   *
   * @generated from field: string ClientSecret = 2;
   */
  ClientSecret: string;

  /**
   * RedirectURL is the authorization callback URL.
   *
   * @generated from field: string RedirectURL = 3;
   */
  RedirectURL: string;

  /**
   * TeamsToLogins maps Github team memberships onto allowed logins/roles.
   *
   * DELETE IN 11.0.0
   * Deprecated: use GithubTeamsToRoles instead.
   *
   * @generated from field: repeated types.TeamMapping TeamsToLogins = 4;
   */
  TeamsToLogins: TeamMapping[];

  /**
   * Display is the connector display name.
   *
   * @generated from field: string Display = 5;
   */
  Display: string;

  /**
   * TeamsToRoles maps Github team memberships onto allowed roles.
   *
   * @generated from field: repeated types.TeamRolesMapping TeamsToRoles = 6;
   */
  TeamsToRoles: TeamRolesMapping[];

  /**
   * EndpointURL is the URL of the GitHub instance this connector is for.
   *
   * @generated from field: string EndpointURL = 7;
   */
  EndpointURL: string;

  /**
   * APIEndpointURL is the URL of the API endpoint of the Github instance
   * this connector is for.
   *
   * @generated from field: string APIEndpointURL = 8;
   */
  APIEndpointURL: string;

  /**
   * ClientRedirectSettings defines which client redirect URLs are allowed for
   * non-browser SSO logins other than the standard localhost ones.
   *
   * @generated from field: types.SSOClientRedirectSettings ClientRedirectSettings = 9;
   */
  ClientRedirectSettings?: SSOClientRedirectSettings;
};

/**
 * Describes the message types.GithubConnectorSpecV3.
 * Use `create(GithubConnectorSpecV3Schema)` to create a new message.
 */
export const GithubConnectorSpecV3Schema: GenMessage<GithubConnectorSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 203);

/**
 * GithubAuthRequest is the request to start Github OAuth2 flow.
 *
 * @generated from message types.GithubAuthRequest
 */
export type GithubAuthRequest = Message<"types.GithubAuthRequest"> & {
  /**
   * ConnectorID is the name of the connector to use.
   *
   * @generated from field: string ConnectorID = 1;
   */
  ConnectorID: string;

  /**
   * Type is opaque string that helps callbacks identify the request type.
   *
   * @generated from field: string Type = 2;
   */
  Type: string;

  /**
   * StateToken is used to validate the request.
   *
   * @generated from field: string StateToken = 3;
   */
  StateToken: string;

  /**
   * CSRFToken is used to protect against CSRF attacks.
   *
   * @generated from field: string CSRFToken = 4;
   */
  CSRFToken: string;

  /**
   * PublicKey is an optional public key to sign in case of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes PublicKey = 5 [deprecated = true];
   * @deprecated
   */
  PublicKey: Uint8Array;

  /**
   * CertTTL is TTL of the cert that's generated in case of successful auth.
   *
   * @generated from field: int64 CertTTL = 6;
   */
  CertTTL: bigint;

  /**
   * CreateWebSession indicates that a user wants to generate a web session
   * after successful authentication.
   *
   * @generated from field: bool CreateWebSession = 7;
   */
  CreateWebSession: boolean;

  /**
   * RedirectURL will be used by browser.
   *
   * @generated from field: string RedirectURL = 8;
   */
  RedirectURL: string;

  /**
   * ClientRedirectURL is the URL where client will be redirected after
   * successful auth.
   *
   * @generated from field: string ClientRedirectURL = 9;
   */
  ClientRedirectURL: string;

  /**
   * Compatibility specifies OpenSSH compatibility flags.
   *
   * @generated from field: string Compatibility = 10;
   */
  Compatibility: string;

  /**
   * Expires is a global expiry time header can be set on any resource in the system.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 11;
   */
  Expires?: Timestamp;

  /**
   * RouteToCluster is the name of Teleport cluster to issue credentials for.
   *
   * @generated from field: string RouteToCluster = 12;
   */
  RouteToCluster: string;

  /**
   * KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
   *
   * @generated from field: string KubernetesCluster = 13;
   */
  KubernetesCluster: string;

  /**
   * SSOTestFlow indicates if the request is part of the test flow.
   *
   * @generated from field: bool SSOTestFlow = 14;
   */
  SSOTestFlow: boolean;

  /**
   * ConnectorSpec is embedded connector spec for use in test flow.
   *
   * @generated from field: types.GithubConnectorSpecV3 ConnectorSpec = 15;
   */
  ConnectorSpec?: GithubConnectorSpecV3;

  /**
   * AttestationStatement is an attestation statement for the given public key.
   *
   * Deprecated: prefer SshAttestationStatement and/or TlsAttestationStatement.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement attestation_statement = 16 [deprecated = true];
   * @deprecated
   */
  attestationStatement?: AttestationStatement;

  /**
   * ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
   *
   * @generated from field: string ClientLoginIP = 17;
   */
  ClientLoginIP: string;

  /**
   * ClientUserAgent is the user agent of the Web browser, used for issuing
   * a DeviceWebToken.
   *
   * @generated from field: string ClientUserAgent = 18;
   */
  ClientUserAgent: string;

  /**
   * SshPublicKey is an optional public key to use as the subject of an issued
   * SSH cert in case of successful auth.
   *
   * @generated from field: bytes ssh_public_key = 19;
   */
  sshPublicKey: Uint8Array;

  /**
   * TlsPublicKey is an optional public key to use as the subject of an issued
   * TLS cert in case of successful auth.
   *
   * @generated from field: bytes tls_public_key = 20;
   */
  tlsPublicKey: Uint8Array;

  /**
   * SshAttestationStatement is an attestation statement for the given SSH public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement ssh_attestation_statement = 21;
   */
  sshAttestationStatement?: AttestationStatement;

  /**
   * TlsAttestationStatement is an attestation statement for the given TLS public key.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement tls_attestation_statement = 22;
   */
  tlsAttestationStatement?: AttestationStatement;
};

/**
 * Describes the message types.GithubAuthRequest.
 * Use `create(GithubAuthRequestSchema)` to create a new message.
 */
export const GithubAuthRequestSchema: GenMessage<GithubAuthRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 204);

/**
 * SSOWarnings conveys a user-facing main message along with auxiliary warnings.
 *
 * @generated from message types.SSOWarnings
 */
export type SSOWarnings = Message<"types.SSOWarnings"> & {
  /**
   * Message is main user-facing message to be shown.
   *
   * @generated from field: string Message = 1;
   */
  Message: string;

  /**
   * Warnings is a set of distinct warnings to be reported.
   *
   * @generated from field: repeated string Warnings = 2;
   */
  Warnings: string[];
};

/**
 * Describes the message types.SSOWarnings.
 * Use `create(SSOWarningsSchema)` to create a new message.
 */
export const SSOWarningsSchema: GenMessage<SSOWarnings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 205);

/**
 * CreateUserParams represents the user creation parameters as called during SSO login flow.
 *
 * @generated from message types.CreateUserParams
 */
export type CreateUserParams = Message<"types.CreateUserParams"> & {
  /**
   * ConnectorName is the name of the connector used for SSO login flow.
   *
   * @generated from field: string ConnectorName = 1;
   */
  ConnectorName: string;

  /**
   * Username is the name of the user to be created.
   *
   * @generated from field: string Username = 2;
   */
  Username: string;

  /**
   * Logins is a list of available unix logins.
   *
   * @generated from field: repeated string Logins = 3;
   */
  Logins: string[];

  /**
   * KubeGroups is a list of assigned kube groups.
   *
   * @generated from field: repeated string KubeGroups = 4;
   */
  KubeGroups: string[];

  /**
   * KubeUsers is a list of available kube users.
   *
   * @generated from field: repeated string KubeUsers = 5;
   */
  KubeUsers: string[];

  /**
   * Roles is a list of assigned roles.
   *
   * @generated from field: repeated string Roles = 6;
   */
  Roles: string[];

  /**
   * Traits is the set of traits the user is assigned.
   *
   * @generated from field: wrappers.LabelValues Traits = 7;
   */
  Traits?: LabelValues;

  /**
   * SessionTTL determines the TTL.
   *
   * @generated from field: int64 SessionTTL = 8;
   */
  SessionTTL: bigint;
};

/**
 * Describes the message types.CreateUserParams.
 * Use `create(CreateUserParamsSchema)` to create a new message.
 */
export const CreateUserParamsSchema: GenMessage<CreateUserParams> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 206);

/**
 * SSODiagnosticInfo is a single SSO diagnostic info entry.
 *
 * @generated from message types.SSODiagnosticInfo
 */
export type SSODiagnosticInfo = Message<"types.SSODiagnosticInfo"> & {
  /**
   * TestFlow indicates the SSO flow was a test one.
   *
   * @generated from field: bool TestFlow = 1;
   */
  TestFlow: boolean;

  /**
   * Error stores user-friendly error message.
   *
   * @generated from field: string Error = 2;
   */
  Error: string;

  /**
   * Success if present, marks the flow as finished with success.
   *
   * @generated from field: bool Success = 3;
   */
  Success: boolean;

  /**
   * CreateUserParams represents the user creation parameters as called during SSO login flow.
   *
   * @generated from field: types.CreateUserParams CreateUserParams = 4;
   */
  CreateUserParams?: CreateUserParams;

  /**
   * SAMLAttributesToRoles represents mapping from attributes to roles, as used during SAML SSO
   * login flow.
   *
   * @generated from field: repeated types.AttributeMapping SAMLAttributesToRoles = 10;
   */
  SAMLAttributesToRoles: AttributeMapping[];

  /**
   * SAMLAttributesToRolesWarnings contains warnings produced during the process of mapping the
   * SAML attributes to roles.
   *
   * @generated from field: types.SSOWarnings SAMLAttributesToRolesWarnings = 11;
   */
  SAMLAttributesToRolesWarnings?: SSOWarnings;

  /**
   * SAMLAttributeStatements represents SAML attribute statements.
   *
   * @generated from field: wrappers.LabelValues SAMLAttributeStatements = 12;
   */
  SAMLAttributeStatements?: LabelValues;

  /**
   * SAMLAssertionInfo represents raw SAML assertion info as returned by IdP during SAML flow.
   *
   * @generated from field: wrappers.CustomType SAMLAssertionInfo = 13;
   */
  SAMLAssertionInfo?: CustomType;

  /**
   * SAMLTraitsFromAssertions represents traits translated from SAML assertions.
   *
   * @generated from field: wrappers.LabelValues SAMLTraitsFromAssertions = 14;
   */
  SAMLTraitsFromAssertions?: LabelValues;

  /**
   * SAMLConnectorTraitMapping represents connector-specific trait mapping.
   *
   * @generated from field: repeated types.TraitMapping SAMLConnectorTraitMapping = 15;
   */
  SAMLConnectorTraitMapping: TraitMapping[];

  /**
   * OIDCClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
   *
   * @generated from field: repeated types.ClaimMapping OIDCClaimsToRoles = 20;
   */
  OIDCClaimsToRoles: ClaimMapping[];

  /**
   * OIDCClaimsToRolesWarnings contains warnings produced during the process of mapping the
   * OIDC claims to roles.
   *
   * @generated from field: types.SSOWarnings OIDCClaimsToRolesWarnings = 21;
   */
  OIDCClaimsToRolesWarnings?: SSOWarnings;

  /**
   * OIDCClaims represents OIDC claims.
   *
   * @generated from field: wrappers.CustomType OIDCClaims = 22;
   */
  OIDCClaims?: CustomType;

  /**
   * OIDCIdentity represents mapped OIDC Identity.
   *
   * @generated from field: wrappers.CustomType OIDCIdentity = 23;
   */
  OIDCIdentity?: CustomType;

  /**
   * OIDCTraitsFromClaims represents traits translated from OIDC claims.
   *
   * @generated from field: wrappers.LabelValues OIDCTraitsFromClaims = 24;
   */
  OIDCTraitsFromClaims?: LabelValues;

  /**
   * OIDCConnectorTraitMapping represents connector-specific trait mapping.
   *
   * @generated from field: repeated types.TraitMapping OIDCConnectorTraitMapping = 25;
   */
  OIDCConnectorTraitMapping: TraitMapping[];

  /**
   * GithubClaims represents Github user information obtained during OAuth2 flow.
   *
   * @generated from field: types.GithubClaims GithubClaims = 30;
   */
  GithubClaims?: GithubClaims;

  /**
   * GithubTeamsToLogins is TeamsToLogins mapping from Github connector used in the SSO flow.
   *
   * @generated from field: repeated types.TeamMapping GithubTeamsToLogins = 31;
   */
  GithubTeamsToLogins: TeamMapping[];

  /**
   * GithubTeamsToRoles is TeamRolesMapping mapping from Github connector used in the SSO flow.
   *
   * @generated from field: repeated types.TeamRolesMapping GithubTeamsToRoles = 32;
   */
  GithubTeamsToRoles: TeamRolesMapping[];

  /**
   * GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
   *
   * @generated from field: types.GithubTokenInfo GithubTokenInfo = 33;
   */
  GithubTokenInfo?: GithubTokenInfo;

  /**
   * AppliedLoginRules stores the name of each login rule that was applied.
   *
   * @generated from field: repeated string AppliedLoginRules = 34;
   */
  AppliedLoginRules: string[];
};

/**
 * Describes the message types.SSODiagnosticInfo.
 * Use `create(SSODiagnosticInfoSchema)` to create a new message.
 */
export const SSODiagnosticInfoSchema: GenMessage<SSODiagnosticInfo> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 207);

/**
 * GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
 * The token itself is secret and therefore not included.
 *
 * @generated from message types.GithubTokenInfo
 */
export type GithubTokenInfo = Message<"types.GithubTokenInfo"> & {
  /**
   * @generated from field: string TokenType = 1;
   */
  TokenType: string;

  /**
   * @generated from field: int64 Expires = 2;
   */
  Expires: bigint;

  /**
   * @generated from field: string Scope = 3;
   */
  Scope: string;
};

/**
 * Describes the message types.GithubTokenInfo.
 * Use `create(GithubTokenInfoSchema)` to create a new message.
 */
export const GithubTokenInfoSchema: GenMessage<GithubTokenInfo> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 208);

/**
 * GithubClaims represents Github user information obtained during OAuth2 flow
 *
 * @generated from message types.GithubClaims
 */
export type GithubClaims = Message<"types.GithubClaims"> & {
  /**
   * Username is the user's username
   *
   * @generated from field: string Username = 1;
   */
  Username: string;

  /**
   * OrganizationToTeams is the user's organization and team membership
   *
   * @generated from field: wrappers.LabelValues OrganizationToTeams = 2;
   */
  OrganizationToTeams?: LabelValues;

  /**
   * Teams is the users team membership
   *
   * @generated from field: repeated string Teams = 3;
   */
  Teams: string[];
};

/**
 * Describes the message types.GithubClaims.
 * Use `create(GithubClaimsSchema)` to create a new message.
 */
export const GithubClaimsSchema: GenMessage<GithubClaims> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 209);

/**
 * TeamMapping represents a single team membership mapping.
 *
 * DELETE IN 11.0.0
 *
 * @generated from message types.TeamMapping
 */
export type TeamMapping = Message<"types.TeamMapping"> & {
  /**
   * Organization is a Github organization a user belongs to.
   *
   * @generated from field: string Organization = 1;
   */
  Organization: string;

  /**
   * Team is a team within the organization a user belongs to.
   *
   * @generated from field: string Team = 2;
   */
  Team: string;

  /**
   * Logins is a list of allowed logins for this org/team.
   *
   * @generated from field: repeated string Logins = 3;
   */
  Logins: string[];

  /**
   * KubeGroups is a list of allowed kubernetes groups for this org/team.
   *
   * @generated from field: repeated string KubeGroups = 4;
   */
  KubeGroups: string[];

  /**
   * KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
   *
   * @generated from field: repeated string KubeUsers = 5;
   */
  KubeUsers: string[];
};

/**
 * Describes the message types.TeamMapping.
 * Use `create(TeamMappingSchema)` to create a new message.
 */
export const TeamMappingSchema: GenMessage<TeamMapping> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 210);

/**
 * TeamRolesMapping represents a single team membership mapping.
 *
 * @generated from message types.TeamRolesMapping
 */
export type TeamRolesMapping = Message<"types.TeamRolesMapping"> & {
  /**
   * Organization is a Github organization a user belongs to.
   *
   * @generated from field: string Organization = 1;
   */
  Organization: string;

  /**
   * Team is a team within the organization a user belongs to.
   *
   * @generated from field: string Team = 2;
   */
  Team: string;

  /**
   * Roles is a list of allowed logins for this org/team.
   *
   * @generated from field: repeated string Roles = 3;
   */
  Roles: string[];
};

/**
 * Describes the message types.TeamRolesMapping.
 * Use `create(TeamRolesMappingSchema)` to create a new message.
 */
export const TeamRolesMappingSchema: GenMessage<TeamRolesMapping> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 211);

/**
 * TrustedClusterV2 represents a Trusted Cluster.
 *
 * @generated from message types.TrustedClusterV2
 */
export type TrustedClusterV2 = Message<"types.TrustedClusterV2"> & {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a Trusted Cluster specification.
   *
   * @generated from field: types.TrustedClusterSpecV2 Spec = 5;
   */
  Spec?: TrustedClusterSpecV2;
};

/**
 * Describes the message types.TrustedClusterV2.
 * Use `create(TrustedClusterV2Schema)` to create a new message.
 */
export const TrustedClusterV2Schema: GenMessage<TrustedClusterV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 212);

/**
 * TrustedClusterV2List is a list of trusted cluster.
 *
 * @generated from message types.TrustedClusterV2List
 */
export type TrustedClusterV2List = Message<"types.TrustedClusterV2List"> & {
  /**
   * TrustedClusters is a list of trusted cluster.
   *
   * @generated from field: repeated types.TrustedClusterV2 TrustedClusters = 1;
   */
  TrustedClusters: TrustedClusterV2[];
};

/**
 * Describes the message types.TrustedClusterV2List.
 * Use `create(TrustedClusterV2ListSchema)` to create a new message.
 */
export const TrustedClusterV2ListSchema: GenMessage<TrustedClusterV2List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 213);

/**
 * TrustedClusterSpecV2 is a Trusted Cluster specification.
 *
 * @generated from message types.TrustedClusterSpecV2
 */
export type TrustedClusterSpecV2 = Message<"types.TrustedClusterSpecV2"> & {
  /**
   * Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
   * Setting Enabled to false has a side effect of deleting the user and host certificate
   * authority (CA).
   *
   * @generated from field: bool Enabled = 1;
   */
  Enabled: boolean;

  /**
   * Roles is a list of roles that users will be assuming when connecting to this cluster.
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[];

  /**
   * Token is the authorization token provided by another cluster needed by this cluster to join.
   *
   * @generated from field: string Token = 3;
   */
  Token: string;

  /**
   * ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
   * it is derived from `<metadata.name>:<default web proxy server port>`.
   *
   * @generated from field: string ProxyAddress = 4;
   */
  ProxyAddress: string;

  /**
   * ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
   * not set, it is derived from `<metadata.name>:<default reverse tunnel port>`.
   *
   * @generated from field: string ReverseTunnelAddress = 5;
   */
  ReverseTunnelAddress: string;

  /**
   * RoleMap specifies role mappings to remote roles.
   *
   * @generated from field: repeated types.RoleMapping RoleMap = 6;
   */
  RoleMap: RoleMapping[];
};

/**
 * Describes the message types.TrustedClusterSpecV2.
 * Use `create(TrustedClusterSpecV2Schema)` to create a new message.
 */
export const TrustedClusterSpecV2Schema: GenMessage<TrustedClusterSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 214);

/**
 * LockV2 represents a lock.
 * Locks are used to restrict access to a Teleport environment by disabling
 * interactions involving a user, an RBAC role, a node, etc.
 * See rfd/0009-locking.md for more details.
 *
 * @generated from message types.LockV2
 */
export type LockV2 = Message<"types.LockV2"> & {
  /**
   * Kind is a resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version. It must be specified.
   * Supported values are: `v2`.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata holds resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is a Lock specification.
   *
   * @generated from field: types.LockSpecV2 Spec = 5;
   */
  Spec?: LockSpecV2;
};

/**
 * Describes the message types.LockV2.
 * Use `create(LockV2Schema)` to create a new message.
 */
export const LockV2Schema: GenMessage<LockV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 215);

/**
 * LockSpecV2 is a Lock specification.
 *
 * @generated from message types.LockSpecV2
 */
export type LockSpecV2 = Message<"types.LockSpecV2"> & {
  /**
   * Target describes the set of interactions that the lock applies to.
   *
   * @generated from field: types.LockTarget Target = 1;
   */
  Target?: LockTarget;

  /**
   * Message is the message displayed to locked-out users.
   *
   * @generated from field: string Message = 2;
   */
  Message: string;

  /**
   * Expires if set specifies when the lock ceases to be in force.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 3;
   */
  Expires?: Timestamp;

  /**
   * CreatedAt is the date time that the lock was created.
   *
   * @generated from field: google.protobuf.Timestamp CreatedAt = 4;
   */
  CreatedAt?: Timestamp;

  /**
   * CreatedBy is the username of the author of the lock.
   *
   * @generated from field: string CreatedBy = 5;
   */
  CreatedBy: string;
};

/**
 * Describes the message types.LockSpecV2.
 * Use `create(LockSpecV2Schema)` to create a new message.
 */
export const LockSpecV2Schema: GenMessage<LockSpecV2> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 216);

/**
 * LockTarget lists the attributes of interactions to be disabled.
 *
 * @generated from message types.LockTarget
 */
export type LockTarget = Message<"types.LockTarget"> & {
  /**
   * User specifies the name of a Teleport user.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * Role specifies the name of an RBAC role known to the root cluster.
   * In remote clusters, this constraint is evaluated before translating to local roles.
   *
   * @generated from field: string Role = 2;
   */
  Role: string;

  /**
   * Login specifies the name of a local UNIX user.
   *
   * @generated from field: string Login = 3;
   */
  Login: string;

  /**
   * Node specifies the UUID of a Teleport node.
   * A matching node is also prevented from heartbeating to the auth server.
   * DEPRECATED: use ServerID instead.
   *
   * @generated from field: string Node = 4 [deprecated = true];
   * @deprecated
   */
  Node: string;

  /**
   * MFADevice specifies the UUID of a user MFA device.
   *
   * @generated from field: string MFADevice = 5;
   */
  MFADevice: string;

  /**
   * WindowsDesktop specifies the name of a Windows desktop.
   *
   * @generated from field: string WindowsDesktop = 6;
   */
  WindowsDesktop: string;

  /**
   * AccessRequest specifies the UUID of an access request.
   *
   * @generated from field: string AccessRequest = 7;
   */
  AccessRequest: string;

  /**
   * Device is the device ID of a trusted device.
   * Requires Teleport Enterprise.
   *
   * @generated from field: string Device = 8;
   */
  Device: string;

  /**
   * ServerID is the host id of the Teleport instance.
   *
   * @generated from field: string ServerID = 9;
   */
  ServerID: string;
};

/**
 * Describes the message types.LockTarget.
 * Use `create(LockTargetSchema)` to create a new message.
 */
export const LockTargetSchema: GenMessage<LockTarget> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 217);

/**
 * AddressCondition represents a set of addresses. Presently the addresses are specified
 * exclusively in terms of IPv4/IPv6 ranges.
 *
 * @generated from message types.AddressCondition
 */
export type AddressCondition = Message<"types.AddressCondition"> & {
  /**
   * CIDR is IPv4 or IPv6 address. Valid value are either CIDR ranges (e.g. "10.0.1.0/24",
   * "fe::/8") or a single IP address (e.g "10.1.2.3")
   *
   * @generated from field: string CIDR = 1;
   */
  CIDR: string;
};

/**
 * Describes the message types.AddressCondition.
 * Use `create(AddressConditionSchema)` to create a new message.
 */
export const AddressConditionSchema: GenMessage<AddressCondition> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 218);

/**
 * @generated from message types.NetworkRestrictionsSpecV4
 */
export type NetworkRestrictionsSpecV4 = Message<"types.NetworkRestrictionsSpecV4"> & {
  /**
   * Allow lists the addresses that should be allowed.
   *
   * @generated from field: repeated types.AddressCondition Allow = 1;
   */
  Allow: AddressCondition[];

  /**
   * Deny lists the addresses that should be denied even if they're allowed by Allow condition.
   *
   * @generated from field: repeated types.AddressCondition Deny = 2;
   */
  Deny: AddressCondition[];
};

/**
 * Describes the message types.NetworkRestrictionsSpecV4.
 * Use `create(NetworkRestrictionsSpecV4Schema)` to create a new message.
 */
export const NetworkRestrictionsSpecV4Schema: GenMessage<NetworkRestrictionsSpecV4> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 219);

/**
 * NetworkRestrictions specifies a list of addresses to restrict (block). The deny
 * list is checked first and the allow lists overrides it. Thus an empty allow
 * list does not mean that no addresses will be allowed, that will only be the
 * case if the deny list covers the whole address range.
 *
 * @generated from message types.NetworkRestrictionsV4
 */
export type NetworkRestrictionsV4 = Message<"types.NetworkRestrictionsV4"> & {
  /**
   * Kind is the network restrictions resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the network restrictions metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec contains the network restrictions data
   *
   * @generated from field: types.NetworkRestrictionsSpecV4 Spec = 5;
   */
  Spec?: NetworkRestrictionsSpecV4;
};

/**
 * Describes the message types.NetworkRestrictionsV4.
 * Use `create(NetworkRestrictionsV4Schema)` to create a new message.
 */
export const NetworkRestrictionsV4Schema: GenMessage<NetworkRestrictionsV4> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 220);

/**
 * WindowsDesktopServiceV3 represents a windows desktop access service.
 *
 * @generated from message types.WindowsDesktopServiceV3
 */
export type WindowsDesktopServiceV3 = Message<"types.WindowsDesktopServiceV3"> & {
  /**
   * Header is the common resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the windows desktop service spec.
   *
   * @generated from field: types.WindowsDesktopServiceSpecV3 Spec = 2;
   */
  Spec?: WindowsDesktopServiceSpecV3;
};

/**
 * Describes the message types.WindowsDesktopServiceV3.
 * Use `create(WindowsDesktopServiceV3Schema)` to create a new message.
 */
export const WindowsDesktopServiceV3Schema: GenMessage<WindowsDesktopServiceV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 221);

/**
 * WindowsDesktopServiceSpecV3 is the windows desktop service spec.
 *
 * @generated from message types.WindowsDesktopServiceSpecV3
 */
export type WindowsDesktopServiceSpecV3 = Message<"types.WindowsDesktopServiceSpecV3"> & {
  /**
   * Addr is the address that this service can be reached at.
   *
   * @generated from field: string Addr = 1;
   */
  Addr: string;

  /**
   * TeleportVersion is teleport binary version running this service.
   *
   * @generated from field: string TeleportVersion = 2;
   */
  TeleportVersion: string;

  /**
   * Hostname is the desktop service hostname.
   *
   * @generated from field: string Hostname = 3;
   */
  Hostname: string;

  /**
   * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
   *
   * @generated from field: repeated string ProxyIDs = 4;
   */
  ProxyIDs: string[];
};

/**
 * Describes the message types.WindowsDesktopServiceSpecV3.
 * Use `create(WindowsDesktopServiceSpecV3Schema)` to create a new message.
 */
export const WindowsDesktopServiceSpecV3Schema: GenMessage<WindowsDesktopServiceSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 222);

/**
 * WindowsDesktopFilter are filters to apply when searching for windows desktops.
 *
 * @generated from message types.WindowsDesktopFilter
 */
export type WindowsDesktopFilter = Message<"types.WindowsDesktopFilter"> & {
  /**
   * HostID is the ID of the host the Windows Desktop Service proxying the desktop.
   *
   * @generated from field: string HostID = 1;
   */
  HostID: string;

  /**
   * Name is the name of the desktop.
   *
   * @generated from field: string Name = 2;
   */
  Name: string;
};

/**
 * Describes the message types.WindowsDesktopFilter.
 * Use `create(WindowsDesktopFilterSchema)` to create a new message.
 */
export const WindowsDesktopFilterSchema: GenMessage<WindowsDesktopFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 223);

/**
 * WindowsDesktopV3 represents a Windows host for desktop access.
 *
 * @generated from message types.WindowsDesktopV3
 */
export type WindowsDesktopV3 = Message<"types.WindowsDesktopV3"> & {
  /**
   * Header is the common resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the Windows host spec.
   *
   * @generated from field: types.WindowsDesktopSpecV3 Spec = 2;
   */
  Spec?: WindowsDesktopSpecV3;
};

/**
 * Describes the message types.WindowsDesktopV3.
 * Use `create(WindowsDesktopV3Schema)` to create a new message.
 */
export const WindowsDesktopV3Schema: GenMessage<WindowsDesktopV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 224);

/**
 * WindowsDesktopSpecV3 is the Windows host spec.
 *
 * @generated from message types.WindowsDesktopSpecV3
 */
export type WindowsDesktopSpecV3 = Message<"types.WindowsDesktopSpecV3"> & {
  /**
   * Addr is the address that this host can be reached at.
   *
   * @generated from field: string Addr = 1;
   */
  Addr: string;

  /**
   * Domain is the ActiveDirectory domain that this host belongs to.
   *
   * @generated from field: string Domain = 2;
   */
  Domain: string;

  /**
   * HostID is the ID of the host the Windows Desktop Service proxying the desktop.
   *
   * @generated from field: string HostID = 3;
   */
  HostID: string;

  /**
   * NonAD marks this desktop as a standalone host that is
   * not joined to an Active Directory domain.
   *
   * @generated from field: bool NonAD = 4;
   */
  NonAD: boolean;

  /**
   * ScreenSize specifies the size of the screen to use for sessions
   * on this host. In most cases this should be unspecified, in which
   * case Teleport will fill the browser window.
   *
   * @generated from field: types.Resolution ScreenSize = 5;
   */
  ScreenSize?: Resolution;
};

/**
 * Describes the message types.WindowsDesktopSpecV3.
 * Use `create(WindowsDesktopSpecV3Schema)` to create a new message.
 */
export const WindowsDesktopSpecV3Schema: GenMessage<WindowsDesktopSpecV3> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 225);

/**
 * @generated from message types.Resolution
 */
export type Resolution = Message<"types.Resolution"> & {
  /**
   * @generated from field: uint32 Width = 1;
   */
  Width: number;

  /**
   * @generated from field: uint32 Height = 2;
   */
  Height: number;
};

/**
 * Describes the message types.Resolution.
 * Use `create(ResolutionSchema)` to create a new message.
 */
export const ResolutionSchema: GenMessage<Resolution> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 226);

/**
 * RegisterUsingTokenRequest is a request to register with the auth server using
 * an authentication token
 *
 * @generated from message types.RegisterUsingTokenRequest
 */
export type RegisterUsingTokenRequest = Message<"types.RegisterUsingTokenRequest"> & {
  /**
   * HostID is a unique host ID, usually a UUID
   *
   * @generated from field: string HostID = 1;
   */
  HostID: string;

  /**
   * NodeName is a node name
   *
   * @generated from field: string NodeName = 2;
   */
  NodeName: string;

  /**
   * Role is a system role, e.g. Proxy
   *
   * @generated from field: string Role = 3;
   */
  Role: string;

  /**
   * Token is the name of an authentication token
   *
   * @generated from field: string Token = 4;
   */
  Token: string;

  /**
   * AdditionalPrincipals is a list of additional principals
   *
   * @generated from field: repeated string AdditionalPrincipals = 5;
   */
  AdditionalPrincipals: string[];

  /**
   * DNSNames is a list of DNS names to include in the x509 client certificate
   *
   * @generated from field: repeated string DNSNames = 6;
   */
  DNSNames: string[];

  /**
   * PublicTLSKey is a PEM encoded public key
   * used for TLS setup
   *
   * @generated from field: bytes PublicTLSKey = 7;
   */
  PublicTLSKey: Uint8Array;

  /**
   * PublicSSHKey is a SSH encoded public key,
   * if present will be signed as a return value
   * otherwise, new public/private key pair will be generated
   *
   * @generated from field: bytes PublicSSHKey = 8;
   */
  PublicSSHKey: Uint8Array;

  /**
   * RemoteAddr is the remote address of the host requesting a host certificate.
   * It is used to replace 0.0.0.0 in the list of additional principals.
   *
   * @generated from field: string RemoteAddr = 9;
   */
  RemoteAddr: string;

  /**
   * EC2IdentityDocument is used for the EC2 join method to prove the identity
   * of a joining EC2 instance.
   *
   * @generated from field: bytes EC2IdentityDocument = 10;
   */
  EC2IdentityDocument: Uint8Array;

  /**
   * IDToken is a token provided by a workload identity provider as part of
   * OIDC join types such as GitHub.
   *
   * @generated from field: string IDToken = 11;
   */
  IDToken: string;

  /**
   * Expires is a desired time of the expiry of user certificates returned by
   * registration. This only applies to bot joining, and will be ignored by
   * node joining.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 12;
   */
  Expires?: Timestamp;

  /**
   * BotInstanceID is a trusted instance identifier for a Machine ID bot,
   * provided when rejoining. This parameters may only be provided by the join
   * service and is ignored otherwise; bots should otherwise rejoin with their
   * existing client certificate to prove their instance identity.
   *
   * @generated from field: string BotInstanceID = 13;
   */
  BotInstanceID: string;

  /**
   * BotGeneration is a trusted generation counter value for Machine ID bots,
   * provided to Auth by the Join Service when bots rejoin via a streamed/gRPC
   * join method. Rejoining bots supply this value via a client certificate
   * extension; it is ignored from other sources.
   *
   * @generated from field: int32 BotGeneration = 14;
   */
  BotGeneration: number;
};

/**
 * Describes the message types.RegisterUsingTokenRequest.
 * Use `create(RegisterUsingTokenRequestSchema)` to create a new message.
 */
export const RegisterUsingTokenRequestSchema: GenMessage<RegisterUsingTokenRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 227);

/**
 * RecoveryCodes holds a user's recovery code information. Recovery codes allows users to regain
 * access to their account by restoring their lost password or second factor. Once a recovery code
 * is successfully verified, the code is mark used (which invalidates it), and lets the user begin
 * the recovery flow. When a user successfully finishes the recovery flow, users will get a new set
 * of codes that will replace all the previous ones.
 *
 * @generated from message types.RecoveryCodesV1
 */
export type RecoveryCodesV1 = Message<"types.RecoveryCodesV1"> & {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind. Currently unused for this resource.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.RecoveryCodesSpecV1 Spec = 5;
   */
  Spec?: RecoveryCodesSpecV1;
};

/**
 * Describes the message types.RecoveryCodesV1.
 * Use `create(RecoveryCodesV1Schema)` to create a new message.
 */
export const RecoveryCodesV1Schema: GenMessage<RecoveryCodesV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 228);

/**
 * RecoveryCodesSpecV1 is the recovery codes spec.
 *
 * @generated from message types.RecoveryCodesSpecV1
 */
export type RecoveryCodesSpecV1 = Message<"types.RecoveryCodesSpecV1"> & {
  /**
   * Codes hold a list of numOfRecoveryCodes.
   *
   * @generated from field: repeated types.RecoveryCode Codes = 1;
   */
  Codes: RecoveryCode[];

  /**
   * Created is when the set of recovery codes were generated. Updated when a new set of recovery
   * codes are inserted.
   *
   * @generated from field: google.protobuf.Timestamp Created = 2;
   */
  Created?: Timestamp;
};

/**
 * Describes the message types.RecoveryCodesSpecV1.
 * Use `create(RecoveryCodesSpecV1Schema)` to create a new message.
 */
export const RecoveryCodesSpecV1Schema: GenMessage<RecoveryCodesSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 229);

/**
 * RecoveryCode describes a recovery code.
 *
 * @generated from message types.RecoveryCode
 */
export type RecoveryCode = Message<"types.RecoveryCode"> & {
  /**
   * HashedCode is a bcrypt hash of this recovery code.
   *
   * @generated from field: bytes HashedCode = 1;
   */
  HashedCode: Uint8Array;

  /**
   * IsUsed determines if this recovery code was used.
   *
   * @generated from field: bool IsUsed = 2;
   */
  IsUsed: boolean;
};

/**
 * Describes the message types.RecoveryCode.
 * Use `create(RecoveryCodeSchema)` to create a new message.
 */
export const RecoveryCodeSchema: GenMessage<RecoveryCode> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 230);

/**
 * @generated from message types.NullableSessionState
 */
export type NullableSessionState = Message<"types.NullableSessionState"> & {
  /**
   * @generated from field: types.SessionState State = 1;
   */
  State: SessionState;
};

/**
 * Describes the message types.NullableSessionState.
 * Use `create(NullableSessionStateSchema)` to create a new message.
 */
export const NullableSessionStateSchema: GenMessage<NullableSessionState> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 231);

/**
 * SessionTrackerFilter are filters to apply when searching for session trackers.
 *
 * @generated from message types.SessionTrackerFilter
 */
export type SessionTrackerFilter = Message<"types.SessionTrackerFilter"> & {
  /**
   * Kind describes what kind of session this is.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * State is the current state of this session.
   *
   * @generated from field: types.NullableSessionState State = 2;
   */
  State?: NullableSessionState;

  /**
   * DesktopName is the windows desktop server this session belongs to.
   *
   * @generated from field: string DesktopName = 3;
   */
  DesktopName: string;
};

/**
 * Describes the message types.SessionTrackerFilter.
 * Use `create(SessionTrackerFilterSchema)` to create a new message.
 */
export const SessionTrackerFilterSchema: GenMessage<SessionTrackerFilter> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 232);

/**
 * SessionTrackerV1 represents a live session resource.
 *
 * @generated from message types.SessionTrackerV1
 */
export type SessionTrackerV1 = Message<"types.SessionTrackerV1"> & {
  /**
   * Header is the common resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is a session specification.
   *
   * @generated from field: types.SessionTrackerSpecV1 Spec = 2;
   */
  Spec?: SessionTrackerSpecV1;
};

/**
 * Describes the message types.SessionTrackerV1.
 * Use `create(SessionTrackerV1Schema)` to create a new message.
 */
export const SessionTrackerV1Schema: GenMessage<SessionTrackerV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 233);

/**
 * SessionTrackerSpecV1 is the specification for a live session.
 *
 * @generated from message types.SessionTrackerSpecV1
 */
export type SessionTrackerSpecV1 = Message<"types.SessionTrackerSpecV1"> & {
  /**
   * SessionID is unique identifier of this session.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID: string;

  /**
   * Kind describes what kind of session this is.
   *
   * @generated from field: string Kind = 2;
   */
  Kind: string;

  /**
   * State is the current state of this session.
   *
   * @generated from field: types.SessionState State = 3;
   */
  State: SessionState;

  /**
   * Created encodes the time at which the session was registered with the auth
   * server.
   *
   * This should match the timestamp in the corresponding `session.create` event.
   * It's thus up to the tracker creator to set the correct timestamp.
   *
   * @generated from field: google.protobuf.Timestamp Created = 4;
   */
  Created?: Timestamp;

  /**
   * Expires encodes the time at which this session expires and becomes invalid.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 5;
   */
  Expires?: Timestamp;

  /**
   * AttachedData is arbitrary attached JSON serialized metadata.
   *
   * @generated from field: string AttachedData = 6;
   */
  AttachedData: string;

  /**
   * Reason is an arbitrary string that may be used to describe the session and/or it's
   * purpose.
   *
   * @generated from field: string Reason = 7;
   */
  Reason: string;

  /**
   * Invited is a list of invited users, this field can be used by
   * clients to deliver notifications to invited users.
   *
   * @generated from field: repeated string Invited = 8;
   */
  Invited: string[];

  /**
   * Hostname identifies the target this session is connected to.
   *
   * @generated from field: string Hostname = 9;
   */
  Hostname: string;

  /**
   * Address is the address of the target this session is connected to.
   *
   * @generated from field: string Address = 10;
   */
  Address: string;

  /**
   * ClusterName is the name of the Teleport cluster that this session belongs to.
   *
   * @generated from field: string ClusterName = 11;
   */
  ClusterName: string;

  /**
   * Login is the local login/user on the target used by the session.
   *
   * @generated from field: string Login = 12;
   */
  Login: string;

  /**
   * Participants is a list of session participants.
   *
   * @generated from field: repeated types.Participant Participants = 13;
   */
  Participants: Participant[];

  /**
   * The Kubernetes cluster this session belongs to.
   *
   * @generated from field: string KubernetesCluster = 14;
   */
  KubernetesCluster: string;

  /**
   * HostUser is the user regarded as the owner of this session, RBAC checks are performed
   * against the require policies of this user.
   *
   * This refers to the Teleport user but may not be the same as the sessions initiator.
   *
   * @generated from field: string HostUser = 15;
   */
  HostUser: string;

  /**
   * HostPolicies is a list of RBAC policy sets held by the host user at the time of session
   * creation.
   *
   * @generated from field: repeated types.SessionTrackerPolicySet HostPolicies = 16;
   */
  HostPolicies: SessionTrackerPolicySet[];

  /**
   * DatabaseName is the database server this session belongs to.
   *
   * @generated from field: string DatabaseName = 17;
   */
  DatabaseName: string;

  /**
   * AppName is the app server this session belongs to.
   *
   * @generated from field: string AppName = 18;
   */
  AppName: string;

  /**
   * AppSessionID is the unique ID of the app access certificate used to start this app session.
   *
   * @generated from field: string AppSessionID = 19;
   */
  AppSessionID: string;

  /**
   * DesktopName is the windows desktop server this session belongs to.
   *
   * @generated from field: string DesktopName = 20;
   */
  DesktopName: string;

  /**
   * HostID is the target host id that created the session tracker.
   * It's useful for Kubernetes moderated sessions when running in high availabilty
   * otherwise kube proxy is not able to know which agent runs the session.
   *
   * @generated from field: string HostID = 21;
   */
  HostID: string;

  /**
   * TargetSubKind is the sub kind of the target server.
   *
   * @generated from field: string TargetSubKind = 22;
   */
  TargetSubKind: string;

  /**
   * InitialCommand is the command that was executed to start this session.
   *
   * @generated from field: repeated string InitialCommand = 23;
   */
  InitialCommand: string[];
};

/**
 * Describes the message types.SessionTrackerSpecV1.
 * Use `create(SessionTrackerSpecV1Schema)` to create a new message.
 */
export const SessionTrackerSpecV1Schema: GenMessage<SessionTrackerSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 234);

/**
 * SessionTrackerPolicySet is a set of RBAC policies held by the session tracker
 * that contain additional metadata from the originating role.
 *
 * @generated from message types.SessionTrackerPolicySet
 */
export type SessionTrackerPolicySet = Message<"types.SessionTrackerPolicySet"> & {
  /**
   * Name is name of the role this policy set originates from.
   *
   * @generated from field: string Name = 1;
   */
  Name: string;

  /**
   * Version is version of the role this policy set originates from.
   *
   * @generated from field: string Version = 2;
   */
  Version: string;

  /**
   * RequireSessionJoin specifies policies for required users to start a session.
   *
   * @generated from field: repeated types.SessionRequirePolicy RequireSessionJoin = 3;
   */
  RequireSessionJoin: SessionRequirePolicy[];
};

/**
 * Describes the message types.SessionTrackerPolicySet.
 * Use `create(SessionTrackerPolicySetSchema)` to create a new message.
 */
export const SessionTrackerPolicySetSchema: GenMessage<SessionTrackerPolicySet> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 235);

/**
 * Participant stores information about a participant in the session.
 *
 * @generated from message types.Participant
 */
export type Participant = Message<"types.Participant"> & {
  /**
   * ID is a unique UUID of this participant for a given session.
   *
   * @generated from field: string ID = 1;
   */
  ID: string;

  /**
   * User is the canonical name of the Teleport user controlling this participant.
   *
   * @generated from field: string User = 2;
   */
  User: string;

  /**
   * Mode is the participant mode.
   *
   * @generated from field: string Mode = 3;
   */
  Mode: string;

  /**
   * LastActive is the last time this party was active in the session.
   *
   * @generated from field: google.protobuf.Timestamp LastActive = 4;
   */
  LastActive?: Timestamp;
};

/**
 * Describes the message types.Participant.
 * Use `create(ParticipantSchema)` to create a new message.
 */
export const ParticipantSchema: GenMessage<Participant> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 236);

/**
 * UIConfigV1 represents the configuration for the web UI served by the proxy service
 *
 * @generated from message types.UIConfigV1
 */
export type UIConfigV1 = Message<"types.UIConfigV1"> & {
  /**
   * Header is the resource header for the UI configuration.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.UIConfigSpecV1 Spec = 5;
   */
  Spec?: UIConfigSpecV1;
};

/**
 * Describes the message types.UIConfigV1.
 * Use `create(UIConfigV1Schema)` to create a new message.
 */
export const UIConfigV1Schema: GenMessage<UIConfigV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 237);

/**
 * UIConfigSpecV1 is the specification for a UIConfig
 *
 * @generated from message types.UIConfigSpecV1
 */
export type UIConfigSpecV1 = Message<"types.UIConfigSpecV1"> & {
  /**
   * ScrollbackLines is the max number of lines the UI terminal can display in its history.
   *
   * @generated from field: int32 ScrollbackLines = 1;
   */
  ScrollbackLines: number;

  /**
   * ShowResources determines which resources are shown in the web UI. Default if unset is "requestable"
   * which means resources the user has access to and resources they can request will be shown in the
   * resources UI. If set to `accessible_only`, only resources the user already has access to will be shown.
   *
   * @generated from field: string ShowResources = 2;
   */
  ShowResources: string;
};

/**
 * Describes the message types.UIConfigSpecV1.
 * Use `create(UIConfigSpecV1Schema)` to create a new message.
 */
export const UIConfigSpecV1Schema: GenMessage<UIConfigSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 238);

/**
 * InstallerV1 represents an installer script resource. Used to
 * provide a script to install teleport on discovered nodes.
 *
 * @generated from message types.InstallerV1
 */
export type InstallerV1 = Message<"types.InstallerV1"> & {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind. Currently unused for this resource.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.InstallerSpecV1 Spec = 5;
   */
  Spec?: InstallerSpecV1;
};

/**
 * Describes the message types.InstallerV1.
 * Use `create(InstallerV1Schema)` to create a new message.
 */
export const InstallerV1Schema: GenMessage<InstallerV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 239);

/**
 * InstallerSpecV1 is the specification for an Installer
 *
 * @generated from message types.InstallerSpecV1
 */
export type InstallerSpecV1 = Message<"types.InstallerSpecV1"> & {
  /**
   * Script represents the contents of a installer shell script
   *
   * @generated from field: string Script = 1;
   */
  Script: string;
};

/**
 * Describes the message types.InstallerSpecV1.
 * Use `create(InstallerSpecV1Schema)` to create a new message.
 */
export const InstallerSpecV1Schema: GenMessage<InstallerSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 240);

/**
 * InstallerV1List represents a list of installer resources.
 *
 * @generated from message types.InstallerV1List
 */
export type InstallerV1List = Message<"types.InstallerV1List"> & {
  /**
   * Installers is a list of installer resources.
   *
   * @generated from field: repeated types.InstallerV1 installers = 1;
   */
  installers: InstallerV1[];
};

/**
 * Describes the message types.InstallerV1List.
 * Use `create(InstallerV1ListSchema)` to create a new message.
 */
export const InstallerV1ListSchema: GenMessage<InstallerV1List> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 241);

/**
 * SortBy defines a sort criteria.
 *
 * @generated from message types.SortBy
 */
export type SortBy = Message<"types.SortBy"> & {
  /**
   * IsDesc is a sort direction flag where if true the direction is descending, else ascending.
   *
   * @generated from field: bool IsDesc = 1;
   */
  IsDesc: boolean;

  /**
   * Field is the name of an objects field to sort by.
   *
   * @generated from field: string Field = 2;
   */
  Field: string;
};

/**
 * Describes the message types.SortBy.
 * Use `create(SortBySchema)` to create a new message.
 */
export const SortBySchema: GenMessage<SortBy> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 242);

/**
 * ConnectionDiagnosticV1 is the result of testing a connection.
 * When setting up a new resource in Teleport, it's useful to know if we can connect to it.
 * This can be done using the test connection feature.
 * The user can then receive the result as feedback using the UI
 *
 * @generated from message types.ConnectionDiagnosticV1
 */
export type ConnectionDiagnosticV1 = Message<"types.ConnectionDiagnosticV1"> & {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.ConnectionDiagnosticSpecV1 Spec = 5;
   */
  Spec?: ConnectionDiagnosticSpecV1;
};

/**
 * Describes the message types.ConnectionDiagnosticV1.
 * Use `create(ConnectionDiagnosticV1Schema)` to create a new message.
 */
export const ConnectionDiagnosticV1Schema: GenMessage<ConnectionDiagnosticV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 243);

/**
 * ConnectionDiagnosticSpecV1 is the ConnectionDiagnostic Spec.
 * It contains the result of testing a connection.
 * It has the overall result of the connection and then a list of traces.
 * Each trace contains checkpoints of the connection attempt and its result.
 *
 * @generated from message types.ConnectionDiagnosticSpecV1
 */
export type ConnectionDiagnosticSpecV1 = Message<"types.ConnectionDiagnosticSpecV1"> & {
  /**
   * Success describes whether the connection was a success or a failure.
   *
   * @generated from field: bool Success = 1;
   */
  Success: boolean;

  /**
   * Message may contain some user friendly message to let the user know whether it was
   * successful or a failure.
   *
   * @generated from field: string Message = 2;
   */
  Message: string;

  /**
   * Traces contain a list of checkpoints defined by
   *
   * @generated from field: repeated types.ConnectionDiagnosticTrace Traces = 3;
   */
  Traces: ConnectionDiagnosticTrace[];
};

/**
 * Describes the message types.ConnectionDiagnosticSpecV1.
 * Use `create(ConnectionDiagnosticSpecV1Schema)` to create a new message.
 */
export const ConnectionDiagnosticSpecV1Schema: GenMessage<ConnectionDiagnosticSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 244);

/**
 * ConnectionDiagnosticTrace describes a trace of a connection diagnostic
 *
 * @generated from message types.ConnectionDiagnosticTrace
 */
export type ConnectionDiagnosticTrace = Message<"types.ConnectionDiagnosticTrace"> & {
  /**
   * @generated from field: types.ConnectionDiagnosticTrace.TraceType Type = 1;
   */
  Type: ConnectionDiagnosticTrace_TraceType;

  /**
   * @generated from field: types.ConnectionDiagnosticTrace.StatusType Status = 2;
   */
  Status: ConnectionDiagnosticTrace_StatusType;

  /**
   * Details contains a User friendly message of the check's result.
   *
   * @generated from field: string Details = 3;
   */
  Details: string;

  /**
   * Error contains the low level error message in case of a failure.
   *
   * @generated from field: string Error = 4;
   */
  Error: string;
};

/**
 * Describes the message types.ConnectionDiagnosticTrace.
 * Use `create(ConnectionDiagnosticTraceSchema)` to create a new message.
 */
export const ConnectionDiagnosticTraceSchema: GenMessage<ConnectionDiagnosticTrace> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 245);

/**
 * TraceType is an identification of the checkpoint.
 *
 * @generated from enum types.ConnectionDiagnosticTrace.TraceType
 */
export enum ConnectionDiagnosticTrace_TraceType {
  /**
   * @generated from enum value: TRACE_TYPE_UNSPECIFIED = 0;
   */
  TRACE_TYPE_UNSPECIFIED = 0,

  /**
   * UNKNOWN_ERROR is used when we don't know the error.
   * It's not always possible to offer guidance based on the received error.
   * This trace type should be used when the error is too generic given the context we
   * have.
   *
   * @generated from enum value: UNKNOWN_ERROR = 1;
   */
  UNKNOWN_ERROR = 1,

  /**
   * RBAC_NODE is for RBAC checks for the node.
   *
   * @generated from enum value: RBAC_NODE = 2;
   */
  RBAC_NODE = 2,

  /**
   * CONNECTIVITY is for network connectivity checks.
   *
   * @generated from enum value: CONNECTIVITY = 3;
   */
  CONNECTIVITY = 3,

  /**
   * RBAC_PRINCIPAL is used when checking if the principal is allowed per RBAC rules.
   *
   * @generated from enum value: RBAC_PRINCIPAL = 4;
   */
  RBAC_PRINCIPAL = 4,

  /**
   * NODE_PRINCIPAL is used when checking if the Node has the requested principal.
   *
   * @generated from enum value: NODE_PRINCIPAL = 5;
   */
  NODE_PRINCIPAL = 5,

  /**
   * RBAC_KUBE is for RBAC checks to kubernetes the cluster.
   *
   * @generated from enum value: RBAC_KUBE = 6;
   */
  RBAC_KUBE = 6,

  /**
   * KUBE_PRINCIPAL is used when checking if the Kube Cluster has at least one user principals.
   *
   * @generated from enum value: KUBE_PRINCIPAL = 7;
   */
  KUBE_PRINCIPAL = 7,

  /**
   * RBAC_DATABASE is for RBAC checks to database access (db_labels).
   *
   * @generated from enum value: RBAC_DATABASE = 8;
   */
  RBAC_DATABASE = 8,

  /**
   * RBAC_DATABASE_LOGIN is for RBAC checks to database login (db_name and db_user).
   *
   * @generated from enum value: RBAC_DATABASE_LOGIN = 9;
   */
  RBAC_DATABASE_LOGIN = 9,

  /**
   * DATABASE_DB_USER is used when checking whether the Database has the requested Database User.
   *
   * @generated from enum value: DATABASE_DB_USER = 10;
   */
  DATABASE_DB_USER = 10,

  /**
   * DATABASE_DB_NAME is used when checking whether the Database has the requested Database Name.
   *
   * @generated from enum value: DATABASE_DB_NAME = 11;
   */
  DATABASE_DB_NAME = 11,
}

/**
 * Describes the enum types.ConnectionDiagnosticTrace.TraceType.
 */
export const ConnectionDiagnosticTrace_TraceTypeSchema: GenEnum<ConnectionDiagnosticTrace_TraceType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 245, 0);

/**
 * StatusType describes whether this was a success or a failure.
 *
 * @generated from enum types.ConnectionDiagnosticTrace.StatusType
 */
export enum ConnectionDiagnosticTrace_StatusType {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: FAILED = 2;
   */
  FAILED = 2,
}

/**
 * Describes the enum types.ConnectionDiagnosticTrace.StatusType.
 */
export const ConnectionDiagnosticTrace_StatusTypeSchema: GenEnum<ConnectionDiagnosticTrace_StatusType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 245, 1);

/**
 * DatabaseServiceV1 is the representation of a DatabaseService (agent) process.
 *
 * @generated from message types.DatabaseServiceV1
 */
export type DatabaseServiceV1 = Message<"types.DatabaseServiceV1"> & {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.DatabaseServiceSpecV1 Spec = 2;
   */
  Spec?: DatabaseServiceSpecV1;
};

/**
 * Describes the message types.DatabaseServiceV1.
 * Use `create(DatabaseServiceV1Schema)` to create a new message.
 */
export const DatabaseServiceV1Schema: GenMessage<DatabaseServiceV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 246);

/**
 * DatabaseServiceSpecV1 is the DatabaseService Spec.
 *
 * @generated from message types.DatabaseServiceSpecV1
 */
export type DatabaseServiceSpecV1 = Message<"types.DatabaseServiceSpecV1"> & {
  /**
   * ResourceMatchers is the configured match for Database resources.
   *
   * @generated from field: repeated types.DatabaseResourceMatcher ResourceMatchers = 1;
   */
  ResourceMatchers: DatabaseResourceMatcher[];

  /**
   * Hostname is the hostname where this service is running.
   *
   * @generated from field: string Hostname = 2;
   */
  Hostname: string;
};

/**
 * Describes the message types.DatabaseServiceSpecV1.
 * Use `create(DatabaseServiceSpecV1Schema)` to create a new message.
 */
export const DatabaseServiceSpecV1Schema: GenMessage<DatabaseServiceSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 247);

/**
 * DatabaseResourceMatcher is a set of properties that is used to match on resources.
 *
 * @generated from message types.DatabaseResourceMatcher
 */
export type DatabaseResourceMatcher = Message<"types.DatabaseResourceMatcher"> & {
  /**
   * @generated from field: wrappers.LabelValues Labels = 1;
   */
  Labels?: LabelValues;

  /**
   * @generated from field: types.ResourceMatcherAWS AWS = 2;
   */
  AWS?: ResourceMatcherAWS;
};

/**
 * Describes the message types.DatabaseResourceMatcher.
 * Use `create(DatabaseResourceMatcherSchema)` to create a new message.
 */
export const DatabaseResourceMatcherSchema: GenMessage<DatabaseResourceMatcher> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 248);

/**
 * ResourceMatcherAWS contains AWS specific settings for resource matcher.
 *
 * @generated from message types.ResourceMatcherAWS
 */
export type ResourceMatcherAWS = Message<"types.ResourceMatcherAWS"> & {
  /**
   * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
   *
   * @generated from field: string AssumeRoleARN = 1;
   */
  AssumeRoleARN: string;

  /**
   * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
   *
   * @generated from field: string ExternalID = 2;
   */
  ExternalID: string;
};

/**
 * Describes the message types.ResourceMatcherAWS.
 * Use `create(ResourceMatcherAWSSchema)` to create a new message.
 */
export const ResourceMatcherAWSSchema: GenMessage<ResourceMatcherAWS> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 249);

/**
 * ClusterAlert is a cluster-level alert message.
 *
 * @generated from message types.ClusterAlert
 */
export type ClusterAlert = Message<"types.ClusterAlert"> & {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * @generated from field: types.ClusterAlertSpec Spec = 2;
   */
  Spec?: ClusterAlertSpec;
};

/**
 * Describes the message types.ClusterAlert.
 * Use `create(ClusterAlertSchema)` to create a new message.
 */
export const ClusterAlertSchema: GenMessage<ClusterAlert> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 250);

/**
 * ClusterAlertSpec is a cluster alert specification.
 *
 * @generated from message types.ClusterAlertSpec
 */
export type ClusterAlertSpec = Message<"types.ClusterAlertSpec"> & {
  /**
   * Severity represents how problematic/urgent the alert is.
   *
   * @generated from field: types.AlertSeverity Severity = 1;
   */
  Severity: AlertSeverity;

  /**
   * Message is the user-facing message associated with the alert.
   *
   * @generated from field: string Message = 2;
   */
  Message: string;

  /**
   * Created is the time at which the alert was generated.
   *
   * @generated from field: google.protobuf.Timestamp Created = 3;
   */
  Created?: Timestamp;
};

/**
 * Describes the message types.ClusterAlertSpec.
 * Use `create(ClusterAlertSpecSchema)` to create a new message.
 */
export const ClusterAlertSpecSchema: GenMessage<ClusterAlertSpec> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 251);

/**
 * GetClusterAlertsRequest matches cluster alerts.
 *
 * @generated from message types.GetClusterAlertsRequest
 */
export type GetClusterAlertsRequest = Message<"types.GetClusterAlertsRequest"> & {
  /**
   * Severity is an optional minimum severity.
   *
   * @generated from field: types.AlertSeverity Severity = 1;
   */
  Severity: AlertSeverity;

  /**
   * AlertID optionally specifies the ID of the alert being requested.
   *
   * @generated from field: string AlertID = 2;
   */
  AlertID: string;

  /**
   * Labels is an optional label selector.
   *
   * @generated from field: map<string, string> Labels = 3;
   */
  Labels: { [key: string]: string };

  /**
   * WithSuperseded includes superseded alerts in the output of the request.
   *
   * @generated from field: bool WithSuperseded = 4;
   */
  WithSuperseded: boolean;

  /**
   * WithAcknowledged includes acknowledged alerts in the output of the request.
   *
   * @generated from field: bool WithAcknowledged = 5;
   */
  WithAcknowledged: boolean;

  /**
   * WithUntargeted requests that alerts be included even if they are not specifically
   * targeted toward the caller. This has no effect unless the caller has `cluster_alert:list`.
   *
   * @generated from field: bool WithUntargeted = 6;
   */
  WithUntargeted: boolean;
};

/**
 * Describes the message types.GetClusterAlertsRequest.
 * Use `create(GetClusterAlertsRequestSchema)` to create a new message.
 */
export const GetClusterAlertsRequestSchema: GenMessage<GetClusterAlertsRequest> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 252);

/**
 * AlertAcknowledgement marks a cluster alert as having been "acknowledged".
 * This causes the alert to no longer be displayed in 'tsh login', UI banners,
 * etc. Acknowledgements must have an expiry and a message describing why the
 * alert can be considered acknowledged.
 *
 * @generated from message types.AlertAcknowledgement
 */
export type AlertAcknowledgement = Message<"types.AlertAcknowledgement"> & {
  /**
   * AlertID is the ID of the alert being acknowledged.
   *
   * @generated from field: string AlertID = 1;
   */
  AlertID: string;

  /**
   * Reason describes the reason why the alert can be considered
   * acknowledged (e.g. 'alice will fix next week').
   *
   * @generated from field: string Reason = 2;
   */
  Reason: string;

  /**
   * Expires is the time after which the acknowledgement expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 4;
   */
  Expires?: Timestamp;
};

/**
 * Describes the message types.AlertAcknowledgement.
 * Use `create(AlertAcknowledgementSchema)` to create a new message.
 */
export const AlertAcknowledgementSchema: GenMessage<AlertAcknowledgement> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 253);

/**
 * Release correspond to a Teleport Enterprise releases
 *
 * @generated from message types.Release
 */
export type Release = Message<"types.Release"> & {
  /**
   * NotesMD is the notes of the release in markdown
   *
   * @generated from field: string NotesMD = 1;
   */
  NotesMD: string;

  /**
   * Product is the release product, teleport or teleport-ent
   *
   * @generated from field: string Product = 2;
   */
  Product: string;

  /**
   * ReleaseID is the ID of the product
   *
   * @generated from field: string ReleaseID = 3;
   */
  ReleaseID: string;

  /**
   * Status is the status of the release
   *
   * @generated from field: string Status = 4;
   */
  Status: string;

  /**
   * Version is the version of the release
   *
   * @generated from field: string Version = 5;
   */
  Version: string;

  /**
   * Assets is a list of assets related to the release
   *
   * @generated from field: repeated types.Asset Assets = 6;
   */
  Assets: Asset[];
};

/**
 * Describes the message types.Release.
 * Use `create(ReleaseSchema)` to create a new message.
 */
export const ReleaseSchema: GenMessage<Release> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 254);

/**
 * Asset represents a release asset
 *
 * @generated from message types.Asset
 */
export type Asset = Message<"types.Asset"> & {
  /**
   * Arch is the architecture of the asset
   *
   * @generated from field: string Arch = 1;
   */
  Arch: string;

  /**
   * Description is the description of the asset
   *
   * @generated from field: string Description = 2;
   */
  Description: string;

  /**
   * Name is the name of the asset
   *
   * @generated from field: string Name = 3;
   */
  Name: string;

  /**
   * OS is which OS the asset is built for
   *
   * @generated from field: string OS = 4;
   */
  OS: string;

  /**
   * SHA256 is the sha256 of the asset
   *
   * @generated from field: string SHA256 = 5;
   */
  SHA256: string;

  /**
   * Size is the size of the release in bytes
   *
   * @generated from field: int64 AssetSize = 6;
   */
  AssetSize: bigint;

  /**
   * DisplaySize is the human-readable size of the asset
   *
   * @generated from field: string DisplaySize = 7;
   */
  DisplaySize: string;

  /**
   * ReleaseIDs is a list of releases that have the asset included
   *
   * @generated from field: repeated string ReleaseIDs = 8;
   */
  ReleaseIDs: string[];

  /**
   * PublicURL is the public URL used to download the asset
   *
   * @generated from field: string PublicURL = 9;
   */
  PublicURL: string;
};

/**
 * Describes the message types.Asset.
 * Use `create(AssetSchema)` to create a new message.
 */
export const AssetSchema: GenMessage<Asset> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 255);

/**
 * Plugin describes a single instance of a Teleport Plugin
 *
 * @generated from message types.PluginV1
 */
export type PluginV1 = Message<"types.PluginV1"> & {
  /**
   * kind is the plugin resource kind.
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * sub_kind is an optional resource subkind.
   *
   * @generated from field: string sub_kind = 2;
   */
  subKind: string;

  /**
   * version is the resource version.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * metadata is the resource metadata.
   *
   * @generated from field: types.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * @generated from field: types.PluginSpecV1 spec = 5;
   */
  spec?: PluginSpecV1;

  /**
   * @generated from field: types.PluginStatusV1 status = 6;
   */
  status?: PluginStatusV1;

  /**
   * credentials are "live" credentials to the 3rd party API.
   * These are considered secrets.
   *
   * @generated from field: types.PluginCredentialsV1 credentials = 7;
   */
  credentials?: PluginCredentialsV1;
};

/**
 * Describes the message types.PluginV1.
 * Use `create(PluginV1Schema)` to create a new message.
 */
export const PluginV1Schema: GenMessage<PluginV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 256);

/**
 * @generated from message types.PluginSpecV1
 */
export type PluginSpecV1 = Message<"types.PluginSpecV1"> & {
  /**
   * settings contain provider-specific plugin options.
   *
   * @generated from oneof types.PluginSpecV1.settings
   */
  settings: {
    /**
     * Settings for the Slack access plugin
     *
     * @generated from field: types.PluginSlackAccessSettings slack_access_plugin = 1;
     */
    value: PluginSlackAccessSettings;
    case: "slackAccessPlugin";
  } | {
    /**
     * Settings for the Opsgenie access plugin
     *
     * @generated from field: types.PluginOpsgenieAccessSettings opsgenie = 2;
     */
    value: PluginOpsgenieAccessSettings;
    case: "opsgenie";
  } | {
    /**
     * Settings for OpenAI plugin
     *
     * @generated from field: types.PluginOpenAISettings openai = 3;
     */
    value: PluginOpenAISettings;
    case: "openai";
  } | {
    /**
     * Settings for the Okta plugin
     *
     * @generated from field: types.PluginOktaSettings okta = 4;
     */
    value: PluginOktaSettings;
    case: "okta";
  } | {
    /**
     * Settings for device trust jamf plugin
     *
     * @generated from field: types.PluginJamfSettings jamf = 5;
     */
    value: PluginJamfSettings;
    case: "jamf";
  } | {
    /**
     * Settings for the PagerDuty plugin
     *
     * @generated from field: types.PluginPagerDutySettings pager_duty = 6;
     */
    value: PluginPagerDutySettings;
    case: "pagerDuty";
  } | {
    /**
     * Settings for the Mattermost plugin
     *
     * @generated from field: types.PluginMattermostSettings mattermost = 7;
     */
    value: PluginMattermostSettings;
    case: "mattermost";
  } | {
    /**
     * Settings for the JIRA plugin
     *
     * @generated from field: types.PluginJiraSettings jira = 8;
     */
    value: PluginJiraSettings;
    case: "jira";
  } | {
    /**
     * Settings for the Discord plugin
     *
     * @generated from field: types.PluginDiscordSettings discord = 9;
     */
    value: PluginDiscordSettings;
    case: "discord";
  } | {
    /**
     * Settings for the ServiceNow plugin
     *
     * @generated from field: types.PluginServiceNowSettings serviceNow = 10;
     */
    value: PluginServiceNowSettings;
    case: "serviceNow";
  } | {
    /**
     * Settings for the Gitlab plugin.
     *
     * @generated from field: types.PluginGitlabSettings gitlab = 12;
     */
    value: PluginGitlabSettings;
    case: "gitlab";
  } | {
    /**
     * Settings for the Entra ID plugin
     *
     * @generated from field: types.PluginEntraIDSettings entra_id = 13;
     */
    value: PluginEntraIDSettings;
    case: "entraId";
  } | {
    /**
     * Settings for the SCIM plugin
     *
     * @generated from field: types.PluginSCIMSettings scim = 14;
     */
    value: PluginSCIMSettings;
    case: "scim";
  } | {
    /**
     * Settings for the Datadog Incident Management plugin
     *
     * @generated from field: types.PluginDatadogAccessSettings datadog = 15;
     */
    value: PluginDatadogAccessSettings;
    case: "datadog";
  } | { case: undefined; value?: undefined };

  /**
   * generation contains a unique ID that should:
   * - Be created by the backend on plugin creation.
   * - Be updated by the backend if the plugin is updated in any way.
   *
   * For older plugins, it's possible for this to be empty.
   *
   * @generated from field: string generation = 11;
   */
  generation: string;
};

/**
 * Describes the message types.PluginSpecV1.
 * Use `create(PluginSpecV1Schema)` to create a new message.
 */
export const PluginSpecV1Schema: GenMessage<PluginSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 257);

/**
 * @generated from message types.PluginSlackAccessSettings
 */
export type PluginSlackAccessSettings = Message<"types.PluginSlackAccessSettings"> & {
  /**
   * @generated from field: string fallback_channel = 1;
   */
  fallbackChannel: string;
};

/**
 * Describes the message types.PluginSlackAccessSettings.
 * Use `create(PluginSlackAccessSettingsSchema)` to create a new message.
 */
export const PluginSlackAccessSettingsSchema: GenMessage<PluginSlackAccessSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 258);

/**
 * @generated from message types.PluginGitlabSettings
 */
export type PluginGitlabSettings = Message<"types.PluginGitlabSettings"> & {
  /**
   * APIEndpoint is the address of Gitlab API.
   *
   * @generated from field: string api_endpoint = 1;
   */
  apiEndpoint: string;
};

/**
 * Describes the message types.PluginGitlabSettings.
 * Use `create(PluginGitlabSettingsSchema)` to create a new message.
 */
export const PluginGitlabSettingsSchema: GenMessage<PluginGitlabSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 259);

/**
 * @generated from message types.PluginOpsgenieAccessSettings
 */
export type PluginOpsgenieAccessSettings = Message<"types.PluginOpsgenieAccessSettings"> & {
  /**
   * Priority to create Opsgenie alerts with
   *
   * @generated from field: string priority = 2;
   */
  priority: string;

  /**
   * List of tags to be added to alerts created in Opsgenie
   *
   * @generated from field: repeated string alert_tags = 3;
   */
  alertTags: string[];

  /**
   * Default on-call schedules to check if none are provided in the access request annotations
   *
   * @generated from field: repeated string default_schedules = 4;
   */
  defaultSchedules: string[];

  /**
   * APIEndpoint is the address of Opsgenie API.
   *
   * @generated from field: string api_endpoint = 5;
   */
  apiEndpoint: string;
};

/**
 * Describes the message types.PluginOpsgenieAccessSettings.
 * Use `create(PluginOpsgenieAccessSettingsSchema)` to create a new message.
 */
export const PluginOpsgenieAccessSettingsSchema: GenMessage<PluginOpsgenieAccessSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 260);

/**
 * PluginServiceNowSettings are the settings for the serviceNow plugin
 *
 * @generated from message types.PluginServiceNowSettings
 */
export type PluginServiceNowSettings = Message<"types.PluginServiceNowSettings"> & {
  /**
   * ApiEndpoint is the ServiceNow API endpoint.
   *
   * @generated from field: string api_endpoint = 1;
   */
  apiEndpoint: string;

  /**
   * Username is the ServiceNow API username.
   *
   * @generated from field: string username = 2;
   */
  username: string;

  /**
   * Password is the ServiceNow API password.
   *
   * @generated from field: string password = 3;
   */
  password: string;

  /**
   * CloseCode is the close code that ServiceNow incidents will use.
   *
   * @generated from field: string close_code = 4;
   */
  closeCode: string;
};

/**
 * Describes the message types.PluginServiceNowSettings.
 * Use `create(PluginServiceNowSettingsSchema)` to create a new message.
 */
export const PluginServiceNowSettingsSchema: GenMessage<PluginServiceNowSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 261);

/**
 * @generated from message types.PluginPagerDutySettings
 */
export type PluginPagerDutySettings = Message<"types.PluginPagerDutySettings"> & {
  /**
   * UserEmail is the email address of the PagerDuty user that will be
   * listed as the reporter source of incidents, comments, etc
   * within PagerDuty. Should usually be the same user the API key
   * represents.
   *
   * @generated from field: string user_email = 1;
   */
  userEmail: string;

  /**
   * APIEndpoint is the address of PagerDuty API.
   *
   * @generated from field: string api_endpoint = 2;
   */
  apiEndpoint: string;
};

/**
 * Describes the message types.PluginPagerDutySettings.
 * Use `create(PluginPagerDutySettingsSchema)` to create a new message.
 */
export const PluginPagerDutySettingsSchema: GenMessage<PluginPagerDutySettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 262);

/**
 * @generated from message types.PluginJiraSettings
 */
export type PluginJiraSettings = Message<"types.PluginJiraSettings"> & {
  /**
   * ServerURL is the address of the target JIRA Server instance.
   *
   * @generated from field: string server_url = 1;
   */
  serverUrl: string;

  /**
   * ProjectKey is the key of the Jira project that will receive
   * notifications and issues from the plugin.
   *
   * @generated from field: string project_key = 2;
   */
  projectKey: string;

  /**
   * IssueType is the type of Jira Issue that the plugin will create
   *
   * @generated from field: string issue_type = 3;
   */
  issueType: string;
};

/**
 * Describes the message types.PluginJiraSettings.
 * Use `create(PluginJiraSettingsSchema)` to create a new message.
 */
export const PluginJiraSettingsSchema: GenMessage<PluginJiraSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 263);

/**
 * Defines settings for the OpenAI plugin. Currently there are no settings.
 *
 * @generated from message types.PluginOpenAISettings
 */
export type PluginOpenAISettings = Message<"types.PluginOpenAISettings"> & {
};

/**
 * Describes the message types.PluginOpenAISettings.
 * Use `create(PluginOpenAISettingsSchema)` to create a new message.
 */
export const PluginOpenAISettingsSchema: GenMessage<PluginOpenAISettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 264);

/**
 * Defines settings for the Mattermost plugin.
 *
 * @generated from message types.PluginMattermostSettings
 */
export type PluginMattermostSettings = Message<"types.PluginMattermostSettings"> & {
  /**
   * serverURL is the URL to access Mattermost.
   *
   * @generated from field: string server_url = 1;
   */
  serverUrl: string;

  /**
   * team is the Mattermost workspace.
   *
   * @generated from field: string team = 2;
   */
  team: string;

  /**
   * channel is the Mattermost channel in the workspace
   * (team) to send notifications to.
   *
   * @generated from field: string channel = 3;
   */
  channel: string;

  /**
   * report_to_email is an optional email address of a Mattermost user
   * to notify via a direct message when the plugin receives an
   * Access Request event.
   *
   * @generated from field: string report_to_email = 4;
   */
  reportToEmail: string;
};

/**
 * Describes the message types.PluginMattermostSettings.
 * Use `create(PluginMattermostSettingsSchema)` to create a new message.
 */
export const PluginMattermostSettingsSchema: GenMessage<PluginMattermostSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 265);

/**
 * Defines settings for Jamf plugin.
 *
 * @generated from message types.PluginJamfSettings
 */
export type PluginJamfSettings = Message<"types.PluginJamfSettings"> & {
  /**
   * Jamf service spec
   *
   * @generated from field: types.JamfSpecV1 jamf_spec = 1;
   */
  jamfSpec?: JamfSpecV1;
};

/**
 * Describes the message types.PluginJamfSettings.
 * Use `create(PluginJamfSettingsSchema)` to create a new message.
 */
export const PluginJamfSettingsSchema: GenMessage<PluginJamfSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 266);

/**
 * Defines settings for the Okta plugin.
 *
 * @generated from message types.PluginOktaSettings
 */
export type PluginOktaSettings = Message<"types.PluginOktaSettings"> & {
  /**
   * OrgUrl is the Okta organization URL to use for API communication.
   *
   * @generated from field: string org_url = 1;
   */
  orgUrl: string;

  /**
   * EnableUserSync controls the user sync in the Okta integration service. Deprecated.
   * TODO(mdwn): Remove once e changes have been made.
   *
   * @generated from field: bool enable_user_sync = 2;
   */
  enableUserSync: boolean;

  /**
   * SSOConnectorID (deprecated)
   * TODO(mdwn): Remove once e changes have been made.
   *
   * @generated from field: string sso_connector_id = 3;
   */
  ssoConnectorId: string;

  /**
   * Sync settings controls the user and access list sync settings for Okta.
   *
   * @generated from field: types.PluginOktaSyncSettings sync_settings = 4;
   */
  syncSettings?: PluginOktaSyncSettings;
};

/**
 * Describes the message types.PluginOktaSettings.
 * Use `create(PluginOktaSettingsSchema)` to create a new message.
 */
export const PluginOktaSettingsSchema: GenMessage<PluginOktaSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 267);

/**
 * Defines settings for syncing users and access lists from Okta.
 *
 * @generated from message types.PluginOktaSyncSettings
 */
export type PluginOktaSyncSettings = Message<"types.PluginOktaSyncSettings"> & {
  /**
   * SyncUsers controls the user sync in the Okta integration service.
   *
   * @generated from field: bool sync_users = 1;
   */
  syncUsers: boolean;

  /**
   * SSOConnectorID is the name of the Teleport SSO connector created and used by the Okta plugin
   *
   * @generated from field: string sso_connector_id = 2;
   */
  ssoConnectorId: string;

  /**
   * SyncAccessLists controls the access list sync in the Okta integration service.
   *
   * @generated from field: bool sync_access_lists = 3;
   */
  syncAccessLists: boolean;

  /**
   * DefaultOwners are the default owners for all imported access lists.
   *
   * @generated from field: repeated string default_owners = 4;
   */
  defaultOwners: string[];

  /**
   * AppID is the Okta-assigned ID of the Okta App that Teleport uses as a
   * gateway to interact with Okta for SAML login, SCIM provisioning and user
   * sync. When set, user sync will pull users from the assignment list for this
   * app. When empty the plugin will fall back to the legacy behaviour of syncing
   * users from the entre organization.
   *
   * @generated from field: string app_id = 5;
   */
  appId: string;

  /**
   * GroupFilters are filters for which Okta groups to synchronize as access lists.
   * Filters can be globs, for example:
   *   group*
   *   *service*
   * Or regexes if they're prefixed and suffixed with ^ and $, for example:
   *   ^group.*$
   *   ^.*service.*$
   *
   * @generated from field: repeated string group_filters = 6;
   */
  groupFilters: string[];

  /**
   * AppFilters are filters for which Okta applications to synchronize as access lists.
   * Filters can be globs, for example:
   *   app*
   *   *service*
   * Or regexes if they're prefixed and suffixed with ^ and $, for example:
   *   ^app.*$
   *   ^.*service.*$
   *
   * @generated from field: repeated string app_filters = 7;
   */
  appFilters: string[];

  /**
   * AppName is the Okta-assigned unique name of the Okta App that Teleport uses
   * as a gateway to interact with Okta for SAML login, SCIM provisioning and user
   * sync. May be missing for old Okta integration installs.
   *
   * @generated from field: string app_name = 8;
   */
  appName: string;

  /**
   * DisableSyncAppGroups disables syncing of app groups from Okta.
   * This is useful when the app groups are not needed in Teleport.
   * and integration with Okta is only used for user sync.
   *
   * @generated from field: bool disable_sync_app_groups = 9;
   */
  disableSyncAppGroups: boolean;
};

/**
 * Describes the message types.PluginOktaSyncSettings.
 * Use `create(PluginOktaSyncSettingsSchema)` to create a new message.
 */
export const PluginOktaSyncSettingsSchema: GenMessage<PluginOktaSyncSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 268);

/**
 * Defines a set of discord channel IDs
 *
 * @generated from message types.DiscordChannels
 */
export type DiscordChannels = Message<"types.DiscordChannels"> & {
  /**
   * @generated from field: repeated string channel_ids = 1;
   */
  channelIds: string[];
};

/**
 * Describes the message types.DiscordChannels.
 * Use `create(DiscordChannelsSchema)` to create a new message.
 */
export const DiscordChannelsSchema: GenMessage<DiscordChannels> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 269);

/**
 * Defines settings for the discord plugin
 *
 * @generated from message types.PluginDiscordSettings
 */
export type PluginDiscordSettings = Message<"types.PluginDiscordSettings"> & {
  /**
   * RoleToRecipients maps Teleport roles (by name) to the set of Discord
   * channel IDs that will receive notifications and requests regarding that
   * that Role.
   *
   * @generated from field: map<string, types.DiscordChannels> role_to_recipients = 1;
   */
  roleToRecipients: { [key: string]: DiscordChannels };
};

/**
 * Describes the message types.PluginDiscordSettings.
 * Use `create(PluginDiscordSettingsSchema)` to create a new message.
 */
export const PluginDiscordSettingsSchema: GenMessage<PluginDiscordSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 270);

/**
 * PluginEntraIDSettings defines settings for the Entra ID sync plugin
 *
 * @generated from message types.PluginEntraIDSettings
 */
export type PluginEntraIDSettings = Message<"types.PluginEntraIDSettings"> & {
  /**
   * SyncSettings controls the user and access list sync settings for EntraID.
   *
   * @generated from field: types.PluginEntraIDSyncSettings sync_settings = 1;
   */
  syncSettings?: PluginEntraIDSyncSettings;

  /**
   * AccessGraphSettings controls settings for syncing access graph specific data.
   * When this is null, Entra ID integration with Access Graph is disabled.
   *
   * @generated from field: types.PluginEntraIDAccessGraphSettings access_graph_settings = 2;
   */
  accessGraphSettings?: PluginEntraIDAccessGraphSettings;
};

/**
 * Describes the message types.PluginEntraIDSettings.
 * Use `create(PluginEntraIDSettingsSchema)` to create a new message.
 */
export const PluginEntraIDSettingsSchema: GenMessage<PluginEntraIDSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 271);

/**
 * Defines settings for syncing users and access lists from Entra ID.
 *
 * @generated from message types.PluginEntraIDSyncSettings
 */
export type PluginEntraIDSyncSettings = Message<"types.PluginEntraIDSyncSettings"> & {
  /**
   * DefaultOwners are the default owners for all imported access lists.
   *
   * @generated from field: repeated string default_owners = 1;
   */
  defaultOwners: string[];

  /**
   * SSOConnectorID is the name of the Teleport SSO connector created and used by the Entra ID plugin
   *
   * @generated from field: string sso_connector_id = 2;
   */
  ssoConnectorId: string;
};

/**
 * Describes the message types.PluginEntraIDSyncSettings.
 * Use `create(PluginEntraIDSyncSettingsSchema)` to create a new message.
 */
export const PluginEntraIDSyncSettingsSchema: GenMessage<PluginEntraIDSyncSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 272);

/**
 * AccessGraphSettings controls settings for syncing access graph specific data.
 *
 * @generated from message types.PluginEntraIDAccessGraphSettings
 */
export type PluginEntraIDAccessGraphSettings = Message<"types.PluginEntraIDAccessGraphSettings"> & {
  /**
   * AppSsoSettingsCache is an array of single sign-on settings for Entra enterprise applications.
   *
   * This data is stored here because it is not available through traditional methods (MS Graph API).
   * Instead, it is fetched once during the plugin's set up using the user's credentials to connect to Azure's private API.
   *
   * @generated from field: repeated types.PluginEntraIDAppSSOSettings app_sso_settings_cache = 1;
   */
  appSsoSettingsCache: PluginEntraIDAppSSOSettings[];
};

/**
 * Describes the message types.PluginEntraIDAccessGraphSettings.
 * Use `create(PluginEntraIDAccessGraphSettingsSchema)` to create a new message.
 */
export const PluginEntraIDAccessGraphSettingsSchema: GenMessage<PluginEntraIDAccessGraphSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 273);

/**
 * PluginEntraIDAppSSOSettings is a container for a single Entra ID enterprise application's
 * cached SSO settings.
 * As this data is only parsed by TAG, each value is stored as an opaque JSON blob.
 *
 * @generated from message types.PluginEntraIDAppSSOSettings
 */
export type PluginEntraIDAppSSOSettings = Message<"types.PluginEntraIDAppSSOSettings"> & {
  /**
   * AppID is the `AppID` property of Entra application.
   *
   * @generated from field: string app_id = 1;
   */
  appId: string;

  /**
   * FederatedSSOV2 contains the cached, gzip-compressed payload from the /ApplicationSso/{servicePrincipalId}/FederatedSSOV2 endpoint.
   *
   * @generated from field: bytes federated_sso_v2 = 2;
   */
  federatedSsoV2: Uint8Array;
};

/**
 * Describes the message types.PluginEntraIDAppSSOSettings.
 * Use `create(PluginEntraIDAppSSOSettingsSchema)` to create a new message.
 */
export const PluginEntraIDAppSSOSettingsSchema: GenMessage<PluginEntraIDAppSSOSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 274);

/**
 * PluginSCIMSettings defines the settings for a SCIM integration plugin
 *
 * @generated from message types.PluginSCIMSettings
 */
export type PluginSCIMSettings = Message<"types.PluginSCIMSettings"> & {
  /**
   * SamlConnectorName is the name of the SAML Connector that users provisioned
   * by this SCIM plugin will use to log in to Teleport.
   *
   * @generated from field: string saml_connector_name = 1;
   */
  samlConnectorName: string;

  /**
   * DefaultRole is the default role assigned to users provisioned by this
   * plugin.
   *
   * @generated from field: string default_role = 2;
   */
  defaultRole: string;
};

/**
 * Describes the message types.PluginSCIMSettings.
 * Use `create(PluginSCIMSettingsSchema)` to create a new message.
 */
export const PluginSCIMSettingsSchema: GenMessage<PluginSCIMSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 275);

/**
 * PluginDatadogAccessSettings defines the settings for a Datadog Incident Management plugin
 *
 * @generated from message types.PluginDatadogAccessSettings
 */
export type PluginDatadogAccessSettings = Message<"types.PluginDatadogAccessSettings"> & {
  /**
   * ApiEndpoint is the Datadog API endpoint.
   *
   * @generated from field: string api_endpoint = 1;
   */
  apiEndpoint: string;

  /**
   * FallbackRecipient specifies the default recipient.
   *
   * @generated from field: string fallback_recipient = 2;
   */
  fallbackRecipient: string;
};

/**
 * Describes the message types.PluginDatadogAccessSettings.
 * Use `create(PluginDatadogAccessSettingsSchema)` to create a new message.
 */
export const PluginDatadogAccessSettingsSchema: GenMessage<PluginDatadogAccessSettings> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 276);

/**
 * @generated from message types.PluginBootstrapCredentialsV1
 */
export type PluginBootstrapCredentialsV1 = Message<"types.PluginBootstrapCredentialsV1"> & {
  /**
   * @generated from oneof types.PluginBootstrapCredentialsV1.credentials
   */
  credentials: {
    /**
     * @generated from field: types.PluginOAuth2AuthorizationCodeCredentials oauth2_authorization_code = 1;
     */
    value: PluginOAuth2AuthorizationCodeCredentials;
    case: "oauth2AuthorizationCode";
  } | {
    /**
     * @generated from field: types.PluginBearerTokenCredentials bearer_token = 2;
     */
    value: PluginBearerTokenCredentials;
    case: "bearerToken";
  } | {
    /**
     * @generated from field: types.PluginIdSecretCredential id_secret = 3;
     */
    value: PluginIdSecretCredential;
    case: "idSecret";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message types.PluginBootstrapCredentialsV1.
 * Use `create(PluginBootstrapCredentialsV1Schema)` to create a new message.
 */
export const PluginBootstrapCredentialsV1Schema: GenMessage<PluginBootstrapCredentialsV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 277);

/**
 * PluginIdSecretCredential can be OAuth2-like client_id and client_secret or username and password.
 *
 * @generated from message types.PluginIdSecretCredential
 */
export type PluginIdSecretCredential = Message<"types.PluginIdSecretCredential"> & {
  /**
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * @generated from field: string secret = 2;
   */
  secret: string;
};

/**
 * Describes the message types.PluginIdSecretCredential.
 * Use `create(PluginIdSecretCredentialSchema)` to create a new message.
 */
export const PluginIdSecretCredentialSchema: GenMessage<PluginIdSecretCredential> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 278);

/**
 * @generated from message types.PluginOAuth2AuthorizationCodeCredentials
 */
export type PluginOAuth2AuthorizationCodeCredentials = Message<"types.PluginOAuth2AuthorizationCodeCredentials"> & {
  /**
   * @generated from field: string authorization_code = 1;
   */
  authorizationCode: string;

  /**
   * @generated from field: string redirect_uri = 2;
   */
  redirectUri: string;
};

/**
 * Describes the message types.PluginOAuth2AuthorizationCodeCredentials.
 * Use `create(PluginOAuth2AuthorizationCodeCredentialsSchema)` to create a new message.
 */
export const PluginOAuth2AuthorizationCodeCredentialsSchema: GenMessage<PluginOAuth2AuthorizationCodeCredentials> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 279);

/**
 * PluginStatus is the user-facing status for the plugin instance.
 *
 * @generated from message types.PluginStatusV1
 */
export type PluginStatusV1 = Message<"types.PluginStatusV1"> & {
  /**
   * @generated from field: types.PluginStatusCode code = 1;
   */
  code: PluginStatusCode;

  /**
   * error_message is a human-readable error message that can be displayed to the user.
   *
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * last_sync_time is the last time the plugin was run.
   *
   * @generated from field: google.protobuf.Timestamp last_sync_time = 3;
   */
  lastSyncTime?: Timestamp;

  /**
   * details contains provider-specific plugin status details.
   *
   * @generated from oneof types.PluginStatusV1.details
   */
  details: {
    /**
     * gitlab is the status details for the Gitlab plugin.
     *
     * @generated from field: types.PluginGitlabStatusV1 gitlab = 4;
     */
    value: PluginGitlabStatusV1;
    case: "gitlab";
  } | {
    /**
     * @generated from field: types.PluginEntraIDStatusV1 entra_id = 5;
     */
    value: PluginEntraIDStatusV1;
    case: "entraId";
  } | {
    /**
     * Okta holds status details for the Okta plugin
     *
     * @generated from field: types.PluginOktaStatusV1 okta = 7;
     */
    value: PluginOktaStatusV1;
    case: "okta";
  } | { case: undefined; value?: undefined };

  /**
   * last_raw_error variable stores the most recent raw error message received from an API or service.
   * It is intended to capture the original error message without any modifications or formatting.
   * This can be useful for debugging purposes, providing detailed information about what went wrong
   * in the interaction with the external service.
   *
   * @generated from field: string last_raw_error = 6;
   */
  lastRawError: string;
};

/**
 * Describes the message types.PluginStatusV1.
 * Use `create(PluginStatusV1Schema)` to create a new message.
 */
export const PluginStatusV1Schema: GenMessage<PluginStatusV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 280);

/**
 * PluginGitlabStatusV1 is the status details for the Gitlab plugin.
 *
 * @generated from message types.PluginGitlabStatusV1
 */
export type PluginGitlabStatusV1 = Message<"types.PluginGitlabStatusV1"> & {
  /**
   * imported_users is the number of users imported from Gitlab.
   *
   * @generated from field: uint32 imported_users = 1;
   */
  importedUsers: number;

  /**
   * imported_groups is the number of groups imported from Gitlab.
   *
   * @generated from field: uint32 imported_groups = 2;
   */
  importedGroups: number;

  /**
   * imported_projects is the number of projects imported from Gitlab.
   *
   * @generated from field: uint32 imported_projects = 3;
   */
  importedProjects: number;
};

/**
 * Describes the message types.PluginGitlabStatusV1.
 * Use `create(PluginGitlabStatusV1Schema)` to create a new message.
 */
export const PluginGitlabStatusV1Schema: GenMessage<PluginGitlabStatusV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 281);

/**
 * PluginEntraIDStatusV1 is the status details for the Entra ID plugin.
 *
 * @generated from message types.PluginEntraIDStatusV1
 */
export type PluginEntraIDStatusV1 = Message<"types.PluginEntraIDStatusV1"> & {
  /**
   * imported_users is the number of users imported from Entra ID.
   *
   * @generated from field: uint32 imported_users = 1;
   */
  importedUsers: number;

  /**
   * imported_groups is the number of groups imported from Entra ID.
   *
   * @generated from field: uint32 imported_groups = 2;
   */
  importedGroups: number;
};

/**
 * Describes the message types.PluginEntraIDStatusV1.
 * Use `create(PluginEntraIDStatusV1Schema)` to create a new message.
 */
export const PluginEntraIDStatusV1Schema: GenMessage<PluginEntraIDStatusV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 282);

/**
 * PluginOktaStatusV1 contains the details for the running Okta plugin.
 *
 * @generated from message types.PluginOktaStatusV1
 */
export type PluginOktaStatusV1 = Message<"types.PluginOktaStatusV1"> & {
  /**
   * SSODetails are status details relating to SSO.
   *
   * @generated from field: types.PluginOktaStatusDetailsSSO sso_details = 1;
   */
  ssoDetails?: PluginOktaStatusDetailsSSO;

  /**
   * AppGroupSyncDetails are status details relating to synchronizing apps and
   * groups from Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsAppGroupSync app_group_sync_details = 2;
   */
  appGroupSyncDetails?: PluginOktaStatusDetailsAppGroupSync;

  /**
   * UsersSyncDetails are status details relating to synchronizing users from
   * Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsUsersSync users_sync_details = 3;
   */
  usersSyncDetails?: PluginOktaStatusDetailsUsersSync;

  /**
   * ScimDetails are status details relating to SCIM integration with
   * Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsSCIM scim_details = 4;
   */
  scimDetails?: PluginOktaStatusDetailsSCIM;

  /**
   * AccessListSyncDetails are status details relating to synchronizing access
   * lists from Okta.
   *
   * @generated from field: types.PluginOktaStatusDetailsAccessListsSync access_lists_sync_details = 5;
   */
  accessListsSyncDetails?: PluginOktaStatusDetailsAccessListsSync;
};

/**
 * Describes the message types.PluginOktaStatusV1.
 * Use `create(PluginOktaStatusV1Schema)` to create a new message.
 */
export const PluginOktaStatusV1Schema: GenMessage<PluginOktaStatusV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 283);

/**
 * PluginOktaStatusDetailsSSO are details related to the
 * current status of the Okta integration w/r/t SSO.
 *
 * @generated from message types.PluginOktaStatusDetailsSSO
 */
export type PluginOktaStatusDetailsSSO = Message<"types.PluginOktaStatusDetailsSSO"> & {
  /**
   * Enabled indicates whether SSO login is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * AppId is the unique Okta application ID of the Okta Applicaion used for
   * SSO login.
   *
   * @generated from field: string app_id = 2;
   */
  appId: string;

  /**
   * AppName is the human-readable name of the Okta Applicaion used for SSO.
   *
   * @generated from field: string app_name = 3;
   */
  appName: string;
};

/**
 * Describes the message types.PluginOktaStatusDetailsSSO.
 * Use `create(PluginOktaStatusDetailsSSOSchema)` to create a new message.
 */
export const PluginOktaStatusDetailsSSOSchema: GenMessage<PluginOktaStatusDetailsSSO> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 284);

/**
 * PluginOktaStatusDetailsAppGroupSync are details related to the
 * current status of the Okta integration w/r/t application and group
 * sync.
 *
 * @generated from message types.PluginOktaStatusDetailsAppGroupSync
 */
export type PluginOktaStatusDetailsAppGroupSync = Message<"types.PluginOktaStatusDetailsAppGroupSync"> & {
  /**
   * Enabled is whether the users sync is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * StatusCode indicates the current state of the App & Group sync service
   *
   * @generated from field: types.OktaPluginSyncStatusCode status_code = 2;
   */
  statusCode: OktaPluginSyncStatusCode;

  /**
   * LastSuccessful is the date of the last successful run.
   *
   * @generated from field: google.protobuf.Timestamp last_successful = 3;
   */
  lastSuccessful?: Timestamp;

  /**
   * LastFailed is the date of the last failed run.
   *
   * @generated from field: google.protobuf.Timestamp last_failed = 4;
   */
  lastFailed?: Timestamp;

  /**
   * NumAppsSynced is the total number of apps synchronized.
   *
   * @generated from field: int32 num_apps_synced = 5;
   */
  numAppsSynced: number;

  /**
   * NumAppsSynced is the total number of groups synchronized.
   *
   * @generated from field: int32 num_groups_synced = 6;
   */
  numGroupsSynced: number;

  /**
   * Error contains a textual description of the reason the last synchronization
   * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
   *
   * @generated from field: string error = 7;
   */
  error: string;
};

/**
 * Describes the message types.PluginOktaStatusDetailsAppGroupSync.
 * Use `create(PluginOktaStatusDetailsAppGroupSyncSchema)` to create a new message.
 */
export const PluginOktaStatusDetailsAppGroupSyncSchema: GenMessage<PluginOktaStatusDetailsAppGroupSync> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 285);

/**
 * PluginOktaStatusDetailsUsersSync are details related to the
 * current status of the Okta integration w/r/t users sync.
 *
 * @generated from message types.PluginOktaStatusDetailsUsersSync
 */
export type PluginOktaStatusDetailsUsersSync = Message<"types.PluginOktaStatusDetailsUsersSync"> & {
  /**
   * Enabled is whether the users sync is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * StatusCode indicates the current state of the User sync service
   *
   * @generated from field: types.OktaPluginSyncStatusCode status_code = 2;
   */
  statusCode: OktaPluginSyncStatusCode;

  /**
   * LastSuccessful is the date of the last successful run.
   *
   * @generated from field: google.protobuf.Timestamp last_successful = 3;
   */
  lastSuccessful?: Timestamp;

  /**
   * LastFailed is the date of the last failed run.
   *
   * @generated from field: google.protobuf.Timestamp last_failed = 4;
   */
  lastFailed?: Timestamp;

  /**
   * NumUsersSynced is the total number of users synchronized.
   *
   * @generated from field: int32 num_users_synced = 5;
   */
  numUsersSynced: number;

  /**
   * Error contains a textual description of the reason the last synchronization
   * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
   *
   * @generated from field: string error = 6;
   */
  error: string;
};

/**
 * Describes the message types.PluginOktaStatusDetailsUsersSync.
 * Use `create(PluginOktaStatusDetailsUsersSyncSchema)` to create a new message.
 */
export const PluginOktaStatusDetailsUsersSyncSchema: GenMessage<PluginOktaStatusDetailsUsersSync> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 286);

/**
 * PluginOktaStatusDetailsSCIM are details related to the
 * current status of the Okta integration w/r/t SCIM.
 *
 * @generated from message types.PluginOktaStatusDetailsSCIM
 */
export type PluginOktaStatusDetailsSCIM = Message<"types.PluginOktaStatusDetailsSCIM"> & {
  /**
   * Enabled is whether SCIM is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

/**
 * Describes the message types.PluginOktaStatusDetailsSCIM.
 * Use `create(PluginOktaStatusDetailsSCIMSchema)` to create a new message.
 */
export const PluginOktaStatusDetailsSCIMSchema: GenMessage<PluginOktaStatusDetailsSCIM> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 287);

/**
 * PluginOktaStatusDetailsAccessListsSync are details related to the
 * current status of the Okta integration w/r/t access list sync.
 *
 * @generated from message types.PluginOktaStatusDetailsAccessListsSync
 */
export type PluginOktaStatusDetailsAccessListsSync = Message<"types.PluginOktaStatusDetailsAccessListsSync"> & {
  /**
   * Enabled is whether access lists sync is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * StatusCode indicates the current state of the AccessList sync service
   *
   * @generated from field: types.OktaPluginSyncStatusCode status_code = 2;
   */
  statusCode: OktaPluginSyncStatusCode;

  /**
   * LastSuccessful is the date of the last successful run.
   *
   * @generated from field: google.protobuf.Timestamp last_successful = 3;
   */
  lastSuccessful?: Timestamp;

  /**
   * LastFailed is the date of the last failed run.
   *
   * @generated from field: google.protobuf.Timestamp last_failed = 4;
   */
  lastFailed?: Timestamp;

  /**
   * AppFilters are the app filters used for the access list sync.
   *
   * @generated from field: repeated string app_filters = 5;
   */
  appFilters: string[];

  /**
   * NumAppsSynced are the number of applications synchronized as access lists.
   *
   * @generated from field: int32 num_apps_synced = 6;
   */
  numAppsSynced: number;

  /**
   * GroupFilters are the group filters used for the access list sync.
   *
   * @generated from field: repeated string group_filters = 7;
   */
  groupFilters: string[];

  /**
   * NumGroupsSynced are the number of groups synchronized as access lists.
   *
   * @generated from field: int32 num_groups_synced = 8;
   */
  numGroupsSynced: number;

  /**
   * Error contains a textual description of the reason the last synchronization
   * failed. Only valid when StatusCode is OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR.
   *
   * @generated from field: string error = 9;
   */
  error: string;
};

/**
 * Describes the message types.PluginOktaStatusDetailsAccessListsSync.
 * Use `create(PluginOktaStatusDetailsAccessListsSyncSchema)` to create a new message.
 */
export const PluginOktaStatusDetailsAccessListsSyncSchema: GenMessage<PluginOktaStatusDetailsAccessListsSync> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 288);

/**
 * PluginCredentialsV1 represents "live" credentials
 * that are used by the plugin to authenticate to the 3rd party API.
 *
 * @generated from message types.PluginCredentialsV1
 */
export type PluginCredentialsV1 = Message<"types.PluginCredentialsV1"> & {
  /**
   * @generated from oneof types.PluginCredentialsV1.credentials
   */
  credentials: {
    /**
     * @generated from field: types.PluginOAuth2AccessTokenCredentials oauth2_access_token = 1;
     */
    value: PluginOAuth2AccessTokenCredentials;
    case: "oauth2AccessToken";
  } | {
    /**
     * @generated from field: types.PluginBearerTokenCredentials bearer_token = 2;
     */
    value: PluginBearerTokenCredentials;
    case: "bearerToken";
  } | {
    /**
     * @generated from field: types.PluginIdSecretCredential id_secret = 3;
     */
    value: PluginIdSecretCredential;
    case: "idSecret";
  } | {
    /**
     * @generated from field: types.PluginStaticCredentialsRef static_credentials_ref = 4;
     */
    value: PluginStaticCredentialsRef;
    case: "staticCredentialsRef";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message types.PluginCredentialsV1.
 * Use `create(PluginCredentialsV1Schema)` to create a new message.
 */
export const PluginCredentialsV1Schema: GenMessage<PluginCredentialsV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 289);

/**
 * @generated from message types.PluginOAuth2AccessTokenCredentials
 */
export type PluginOAuth2AccessTokenCredentials = Message<"types.PluginOAuth2AccessTokenCredentials"> & {
  /**
   * @generated from field: string access_token = 1;
   */
  accessToken: string;

  /**
   * @generated from field: string refresh_token = 2;
   */
  refreshToken: string;

  /**
   * @generated from field: google.protobuf.Timestamp expires = 3;
   */
  expires?: Timestamp;
};

/**
 * Describes the message types.PluginOAuth2AccessTokenCredentials.
 * Use `create(PluginOAuth2AccessTokenCredentialsSchema)` to create a new message.
 */
export const PluginOAuth2AccessTokenCredentialsSchema: GenMessage<PluginOAuth2AccessTokenCredentials> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 290);

/**
 * @generated from message types.PluginBearerTokenCredentials
 */
export type PluginBearerTokenCredentials = Message<"types.PluginBearerTokenCredentials"> & {
  /**
   * Token is the literal bearer token to be submitted to the 3rd-party API provider.
   *
   * @generated from field: string token = 1;
   */
  token: string;
};

/**
 * Describes the message types.PluginBearerTokenCredentials.
 * Use `create(PluginBearerTokenCredentialsSchema)` to create a new message.
 */
export const PluginBearerTokenCredentialsSchema: GenMessage<PluginBearerTokenCredentials> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 291);

/**
 * PluginStaticCredentialsRef is a reference to plugin static credentials by labels.
 *
 * @generated from message types.PluginStaticCredentialsRef
 */
export type PluginStaticCredentialsRef = Message<"types.PluginStaticCredentialsRef"> & {
  /**
   * Labels is the set of labels to use to match against a set of static credentials.
   *
   * @generated from field: map<string, string> Labels = 1;
   */
  Labels: { [key: string]: string };
};

/**
 * Describes the message types.PluginStaticCredentialsRef.
 * Use `create(PluginStaticCredentialsRefSchema)` to create a new message.
 */
export const PluginStaticCredentialsRefSchema: GenMessage<PluginStaticCredentialsRef> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 292);

/**
 * PluginList represents a list of plugin resources
 *
 * @generated from message types.PluginListV1
 */
export type PluginListV1 = Message<"types.PluginListV1"> & {
  /**
   * Plugins is a list of plugin resources.
   *
   * @generated from field: repeated types.PluginV1 plugins = 1;
   */
  plugins: PluginV1[];
};

/**
 * Describes the message types.PluginListV1.
 * Use `create(PluginListV1Schema)` to create a new message.
 */
export const PluginListV1Schema: GenMessage<PluginListV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 293);

/**
 * PluginStaticCredentialsV1 is a representation of static credentials for plugins.
 *
 * @generated from message types.PluginStaticCredentialsV1
 */
export type PluginStaticCredentialsV1 = Message<"types.PluginStaticCredentialsV1"> & {
  /**
   * Header is the resource header for the plugin static credentials object.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec contains the actual credentials for the object.
   *
   * @generated from field: types.PluginStaticCredentialsSpecV1 Spec = 2;
   */
  Spec?: PluginStaticCredentialsSpecV1;
};

/**
 * Describes the message types.PluginStaticCredentialsV1.
 * Use `create(PluginStaticCredentialsV1Schema)` to create a new message.
 */
export const PluginStaticCredentialsV1Schema: GenMessage<PluginStaticCredentialsV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 294);

/**
 * PluginStaticCredentialsSpecV1 is the specification for the static credentials object.
 *
 * @generated from message types.PluginStaticCredentialsSpecV1
 */
export type PluginStaticCredentialsSpecV1 = Message<"types.PluginStaticCredentialsSpecV1"> & {
  /**
   * @generated from oneof types.PluginStaticCredentialsSpecV1.credentials
   */
  credentials: {
    /**
     * @generated from field: string APIToken = 1;
     */
    value: string;
    case: "APIToken";
  } | {
    /**
     * @generated from field: types.PluginStaticCredentialsBasicAuth BasicAuth = 2;
     */
    value: PluginStaticCredentialsBasicAuth;
    case: "BasicAuth";
  } | {
    /**
     * @generated from field: types.PluginStaticCredentialsOAuthClientSecret OAuthClientSecret = 3;
     */
    value: PluginStaticCredentialsOAuthClientSecret;
    case: "OAuthClientSecret";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message types.PluginStaticCredentialsSpecV1.
 * Use `create(PluginStaticCredentialsSpecV1Schema)` to create a new message.
 */
export const PluginStaticCredentialsSpecV1Schema: GenMessage<PluginStaticCredentialsSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 295);

/**
 * PluginStaticCredentialsBasicAuth represents username and password credentials for a plugin.
 *
 * @generated from message types.PluginStaticCredentialsBasicAuth
 */
export type PluginStaticCredentialsBasicAuth = Message<"types.PluginStaticCredentialsBasicAuth"> & {
  /**
   * Username is the username to use for basic auth.
   *
   * @generated from field: string Username = 1;
   */
  Username: string;

  /**
   * Password is the password to use for basic auth.
   *
   * @generated from field: string Password = 2;
   */
  Password: string;
};

/**
 * Describes the message types.PluginStaticCredentialsBasicAuth.
 * Use `create(PluginStaticCredentialsBasicAuthSchema)` to create a new message.
 */
export const PluginStaticCredentialsBasicAuthSchema: GenMessage<PluginStaticCredentialsBasicAuth> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 296);

/**
 * PluginStaticCredentialsOAuthClientSecret represents an oauth client id and secret.
 *
 * @generated from message types.PluginStaticCredentialsOAuthClientSecret
 */
export type PluginStaticCredentialsOAuthClientSecret = Message<"types.PluginStaticCredentialsOAuthClientSecret"> & {
  /**
   * ClientId is the client ID to use for OAuth client secret.
   *
   * @generated from field: string ClientId = 1;
   */
  ClientId: string;

  /**
   * ClientSecret is the client secret to use.
   *
   * @generated from field: string ClientSecret = 2;
   */
  ClientSecret: string;
};

/**
 * Describes the message types.PluginStaticCredentialsOAuthClientSecret.
 * Use `create(PluginStaticCredentialsOAuthClientSecretSchema)` to create a new message.
 */
export const PluginStaticCredentialsOAuthClientSecretSchema: GenMessage<PluginStaticCredentialsOAuthClientSecret> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 297);

/**
 * SAMLIdPServiceProviderV1 is the representation of a SAML IdP service provider.
 *
 * @generated from message types.SAMLIdPServiceProviderV1
 */
export type SAMLIdPServiceProviderV1 = Message<"types.SAMLIdPServiceProviderV1"> & {
  /**
   * Header is the resource header for the SAML IdP service provider.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the SAML IdP service provider spec.
   *
   * @generated from field: types.SAMLIdPServiceProviderSpecV1 Spec = 2;
   */
  Spec?: SAMLIdPServiceProviderSpecV1;
};

/**
 * Describes the message types.SAMLIdPServiceProviderV1.
 * Use `create(SAMLIdPServiceProviderV1Schema)` to create a new message.
 */
export const SAMLIdPServiceProviderV1Schema: GenMessage<SAMLIdPServiceProviderV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 298);

/**
 * SAMLIdPServiceProviderSpecV1 is the SAMLIdPServiceProviderV1 resource spec.
 *
 * @generated from message types.SAMLIdPServiceProviderSpecV1
 */
export type SAMLIdPServiceProviderSpecV1 = Message<"types.SAMLIdPServiceProviderSpecV1"> & {
  /**
   * EntityDescriptor is the entity descriptor for the service provider
   *
   * @generated from field: string EntityDescriptor = 1;
   */
  EntityDescriptor: string;

  /**
   * EntityID is the entity ID for the entity descriptor. If entity descriptor is provided,
   * this value is checked that it matches the entity ID in the entity descriptor
   * at upsert time to avoid having to parse the XML blob in the entity descriptor
   * every time we need to use this resource.
   *
   * @generated from field: string EntityID = 2;
   */
  EntityID: string;

  /**
   * ACSURL is the endpoint where SAML authentication response will be redirected.
   *
   * @generated from field: string ACSURL = 3;
   */
  ACSURL: string;

  /**
   * AttributeMapping is used to map service provider requested attributes to
   * username, role and traits in Teleport.
   *
   * @generated from field: repeated types.SAMLAttributeMapping AttributeMapping = 4;
   */
  AttributeMapping: SAMLAttributeMapping[];

  /**
   * Preset is used to define service provider profile that will have a custom behavior
   * processed by Teleport.
   *
   * @generated from field: string Preset = 5;
   */
  Preset: string;

  /**
   * RelayState is used to add custom value in the SAML response as a relay_state HTTP parameter.
   * The value can contain service provider specific redirect URL, static state token etc.
   * The value is only applied in the IdP initiated SSO flow.
   *
   * @generated from field: string RelayState = 6;
   */
  RelayState: string;

  /**
   * LaunchURLs is used to configure custom landing URLs for service provider. It is useful in
   * the following scenarios:
   * 1. If a service provider does not support IdP initiated authentication, launch url can be
   *    configured to launch users directly into the service provider authentication endpoint.
   * 2. If a service provider does support IdP initiated authentication, it can be useful if
   *    that service provider acts as a master authentication service provider for internal services.
   *    In such case, Teleport administrator can configure launch URL, that lets user pick a specific
   *    internal service URL from the Log In tile in the UI, which would take them to that particular
   *    service for authentication instead of directly launching to the master service provider.
   * Each launch URL value must be an HTTPs endpoint.
   *
   * @generated from field: repeated string LaunchURLs = 7;
   */
  LaunchURLs: string[];
};

/**
 * Describes the message types.SAMLIdPServiceProviderSpecV1.
 * Use `create(SAMLIdPServiceProviderSpecV1Schema)` to create a new message.
 */
export const SAMLIdPServiceProviderSpecV1Schema: GenMessage<SAMLIdPServiceProviderSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 299);

/**
 * SAMLAttributeMapping represents SAML service provider requested attribute
 * name, format and its values.
 *
 * @generated from message types.SAMLAttributeMapping
 */
export type SAMLAttributeMapping = Message<"types.SAMLAttributeMapping"> & {
  /**
   *  name is an attribute name.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   *  name_format is an attribute name format.
   *
   * @generated from field: string name_format = 2;
   */
  nameFormat: string;

  /**
   *  value is an attribute value definable with predicate expression.
   *
   * @generated from field: string value = 3;
   */
  value: string;
};

/**
 * Describes the message types.SAMLAttributeMapping.
 * Use `create(SAMLAttributeMappingSchema)` to create a new message.
 */
export const SAMLAttributeMappingSchema: GenMessage<SAMLAttributeMapping> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 300);

/**
 * IdPOptions specify options related to access Teleport IdPs.
 *
 * @generated from message types.IdPOptions
 */
export type IdPOptions = Message<"types.IdPOptions"> & {
  /**
   * SAML are options related to the Teleport SAML IdP.
   *
   * @generated from field: types.IdPSAMLOptions SAML = 1;
   */
  SAML?: IdPSAMLOptions;
};

/**
 * Describes the message types.IdPOptions.
 * Use `create(IdPOptionsSchema)` to create a new message.
 */
export const IdPOptionsSchema: GenMessage<IdPOptions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 301);

/**
 * IdPSAMLOptions specifies options related to accessing the Teleport SAML IdP.
 *
 * @generated from message types.IdPSAMLOptions
 */
export type IdPSAMLOptions = Message<"types.IdPSAMLOptions"> & {
  /**
   * Enabled is set to true if this option allows access to the Teleport SAML IdP.
   *
   * @generated from field: types.BoolValue Enabled = 1;
   */
  Enabled?: BoolValue;
};

/**
 * Describes the message types.IdPSAMLOptions.
 * Use `create(IdPSAMLOptionsSchema)` to create a new message.
 */
export const IdPSAMLOptionsSchema: GenMessage<IdPSAMLOptions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 302);

/**
 * KubernetesResourceV1 represents a Kubernetes resource.
 *
 * @generated from message types.KubernetesResourceV1
 */
export type KubernetesResourceV1 = Message<"types.KubernetesResourceV1"> & {
  /**
   * Kind is a resource kind
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource sub kind, used in some resources
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is version
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is KubernetesResourceV1 metadata
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec contains the Kubernetes resource data.
   *
   * @generated from field: types.KubernetesResourceSpecV1 Spec = 5;
   */
  Spec?: KubernetesResourceSpecV1;
};

/**
 * Describes the message types.KubernetesResourceV1.
 * Use `create(KubernetesResourceV1Schema)` to create a new message.
 */
export const KubernetesResourceV1Schema: GenMessage<KubernetesResourceV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 303);

/**
 * KubernetesResourceSpecV1 is the Kubernetes resource spec.
 *
 * @generated from message types.KubernetesResourceSpecV1
 */
export type KubernetesResourceSpecV1 = Message<"types.KubernetesResourceSpecV1"> & {
  /**
   * Namespace is the resource namespace.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace: string;
};

/**
 * Describes the message types.KubernetesResourceSpecV1.
 * Use `create(KubernetesResourceSpecV1Schema)` to create a new message.
 */
export const KubernetesResourceSpecV1Schema: GenMessage<KubernetesResourceSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 304);

/**
 * ClusterMaintenanceConfigV1 is a config singleton used to configure infrequent
 * cluster maintenance operations.
 *
 * @generated from message types.ClusterMaintenanceConfigV1
 */
export type ClusterMaintenanceConfigV1 = Message<"types.ClusterMaintenanceConfigV1"> & {
  /**
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * @generated from field: types.ClusterMaintenanceConfigSpecV1 Spec = 2;
   */
  Spec?: ClusterMaintenanceConfigSpecV1;

  /**
   * Nonce is used to protect against concurrent modification of the maintenance
   * window. Clients should treat nonces as opaque.
   *
   * @generated from field: uint64 Nonce = 3;
   */
  Nonce: bigint;
};

/**
 * Describes the message types.ClusterMaintenanceConfigV1.
 * Use `create(ClusterMaintenanceConfigV1Schema)` to create a new message.
 */
export const ClusterMaintenanceConfigV1Schema: GenMessage<ClusterMaintenanceConfigV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 305);

/**
 * ClusterMaintenanceConfigSpecV1 encodes the parameters of the upgrade window config object.
 *
 * @generated from message types.ClusterMaintenanceConfigSpecV1
 */
export type ClusterMaintenanceConfigSpecV1 = Message<"types.ClusterMaintenanceConfigSpecV1"> & {
  /**
   * AgentUpgrades encodes the agent upgrade window.
   *
   * @generated from field: types.AgentUpgradeWindow AgentUpgrades = 1;
   */
  AgentUpgrades?: AgentUpgradeWindow;
};

/**
 * Describes the message types.ClusterMaintenanceConfigSpecV1.
 * Use `create(ClusterMaintenanceConfigSpecV1Schema)` to create a new message.
 */
export const ClusterMaintenanceConfigSpecV1Schema: GenMessage<ClusterMaintenanceConfigSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 306);

/**
 * AgentUpgradeWindow is the config object used to determine upcoming agent
 * upgrade windows.
 *
 * @generated from message types.AgentUpgradeWindow
 */
export type AgentUpgradeWindow = Message<"types.AgentUpgradeWindow"> & {
  /**
   * UTCStartHour is the start hour of the maintenance window in UTC.
   *
   * @generated from field: uint32 UTCStartHour = 1;
   */
  UTCStartHour: number;

  /**
   * Weekdays is an optional list of weekdays. If not specified, an agent upgrade window
   * occurs every day.
   *
   * @generated from field: repeated string Weekdays = 2;
   */
  Weekdays: string[];
};

/**
 * Describes the message types.AgentUpgradeWindow.
 * Use `create(AgentUpgradeWindowSchema)` to create a new message.
 */
export const AgentUpgradeWindowSchema: GenMessage<AgentUpgradeWindow> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 307);

/**
 * ScheduledAgentUpgradeWindow is a derived value representing a single
 * upgrade window. Upgraders deal with discrete start/end times, so we use the
 * agent upgrade window configuration object to generate a sequence of specific
 * scheduled windows.
 *
 * @generated from message types.ScheduledAgentUpgradeWindow
 */
export type ScheduledAgentUpgradeWindow = Message<"types.ScheduledAgentUpgradeWindow"> & {
  /**
   * Start is the start time of the upgrade window.
   *
   * @generated from field: google.protobuf.Timestamp Start = 1;
   */
  Start?: Timestamp;

  /**
   * Stop is the stop time of the upgrade window.
   *
   * @generated from field: google.protobuf.Timestamp Stop = 2;
   */
  Stop?: Timestamp;
};

/**
 * Describes the message types.ScheduledAgentUpgradeWindow.
 * Use `create(ScheduledAgentUpgradeWindowSchema)` to create a new message.
 */
export const ScheduledAgentUpgradeWindowSchema: GenMessage<ScheduledAgentUpgradeWindow> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 308);

/**
 * AgentUpgradeSchedule is the canonical representation of upcoming
 * agent upgrade windows as generated by the AgentUpgradeWindow config object.
 *
 * @generated from message types.AgentUpgradeSchedule
 */
export type AgentUpgradeSchedule = Message<"types.AgentUpgradeSchedule"> & {
  /**
   * Windows is the list of upcoming windows.
   *
   * @generated from field: repeated types.ScheduledAgentUpgradeWindow Windows = 1;
   */
  Windows: ScheduledAgentUpgradeWindow[];
};

/**
 * Describes the message types.AgentUpgradeSchedule.
 * Use `create(AgentUpgradeScheduleSchema)` to create a new message.
 */
export const AgentUpgradeScheduleSchema: GenMessage<AgentUpgradeSchedule> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 309);

/**
 * UserGroupV1 is a representation of an externally sourced user group.
 *
 * @generated from message types.UserGroupV1
 */
export type UserGroupV1 = Message<"types.UserGroupV1"> & {
  /**
   * Header is the resource header for the user group.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the user group resource spec.
   *
   * @generated from field: types.UserGroupSpecV1 Spec = 2;
   */
  Spec?: UserGroupSpecV1;
};

/**
 * Describes the message types.UserGroupV1.
 * Use `create(UserGroupV1Schema)` to create a new message.
 */
export const UserGroupV1Schema: GenMessage<UserGroupV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 310);

/**
 * UserGroupSpecV1 is the specification of a user group.
 *
 * @generated from message types.UserGroupSpecV1
 */
export type UserGroupSpecV1 = Message<"types.UserGroupSpecV1"> & {
  /**
   * Applications are a list of application IDs belonging to this user group.
   *
   * @generated from field: repeated string Applications = 1;
   */
  Applications: string[];
};

/**
 * Describes the message types.UserGroupSpecV1.
 * Use `create(UserGroupSpecV1Schema)` to create a new message.
 */
export const UserGroupSpecV1Schema: GenMessage<UserGroupSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 311);

/**
 * OktaImportRuleSpecV1 is a Okta import rule specification.
 *
 * @generated from message types.OktaImportRuleSpecV1
 */
export type OktaImportRuleSpecV1 = Message<"types.OktaImportRuleSpecV1"> & {
  /**
   * Priority represents the priority of the rule application. Lower numbered rules will be applied first.
   *
   * @generated from field: int32 Priority = 1;
   */
  Priority: number;

  /**
   * Mappings is a list of matches that will map match conditions to labels.
   *
   * @generated from field: repeated types.OktaImportRuleMappingV1 Mappings = 2;
   */
  Mappings: OktaImportRuleMappingV1[];
};

/**
 * Describes the message types.OktaImportRuleSpecV1.
 * Use `create(OktaImportRuleSpecV1Schema)` to create a new message.
 */
export const OktaImportRuleSpecV1Schema: GenMessage<OktaImportRuleSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 312);

/**
 * OktaImportRuleMappingV1 is a list of matches that map match rules to labels.
 *
 * @generated from message types.OktaImportRuleMappingV1
 */
export type OktaImportRuleMappingV1 = Message<"types.OktaImportRuleMappingV1"> & {
  /**
   * Match is a set of matching rules for this mapping. If any of these match, then the mapping will be applied.
   *
   * @generated from field: repeated types.OktaImportRuleMatchV1 Match = 1;
   */
  Match: OktaImportRuleMatchV1[];

  /**
   * AddLabels specifies which labels to add if any of the previous matches match.
   *
   * @generated from field: map<string, string> AddLabels = 2;
   */
  AddLabels: { [key: string]: string };
};

/**
 * Describes the message types.OktaImportRuleMappingV1.
 * Use `create(OktaImportRuleMappingV1Schema)` to create a new message.
 */
export const OktaImportRuleMappingV1Schema: GenMessage<OktaImportRuleMappingV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 313);

/**
 * OktaImportRuleV1 is a representation of labeling rules for importing of Okta objects.
 *
 * @generated from message types.OktaImportRuleV1
 */
export type OktaImportRuleV1 = Message<"types.OktaImportRuleV1"> & {
  /**
   * Header is the resource header for the SAML IdP service provider.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the specification for the Okta import rule.
   *
   * @generated from field: types.OktaImportRuleSpecV1 Spec = 2;
   */
  Spec?: OktaImportRuleSpecV1;
};

/**
 * Describes the message types.OktaImportRuleV1.
 * Use `create(OktaImportRuleV1Schema)` to create a new message.
 */
export const OktaImportRuleV1Schema: GenMessage<OktaImportRuleV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 314);

/**
 * OktaImportRuleMatchV1 is a match rule for a mapping.
 *
 * @generated from message types.OktaImportRuleMatchV1
 */
export type OktaImportRuleMatchV1 = Message<"types.OktaImportRuleMatchV1"> & {
  /**
   * AppIDs is a list of app IDs to match against.
   *
   * @generated from field: repeated string AppIDs = 1;
   */
  AppIDs: string[];

  /**
   * GroupIDs is a list of group IDs to match against.
   *
   * @generated from field: repeated string GroupIDs = 2;
   */
  GroupIDs: string[];

  /**
   * AppNameRegexes is a list of regexes to match against app names.
   *
   * @generated from field: repeated string AppNameRegexes = 3;
   */
  AppNameRegexes: string[];

  /**
   * GroupNameRegexes is a list of regexes to match against group names.
   *
   * @generated from field: repeated string GroupNameRegexes = 4;
   */
  GroupNameRegexes: string[];
};

/**
 * Describes the message types.OktaImportRuleMatchV1.
 * Use `create(OktaImportRuleMatchV1Schema)` to create a new message.
 */
export const OktaImportRuleMatchV1Schema: GenMessage<OktaImportRuleMatchV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 315);

/**
 * OktaAssignmentV1 is a representation of an action or set of actions taken by Teleport to assign Okta users to applications or groups.
 *
 * @generated from message types.OktaAssignmentV1
 */
export type OktaAssignmentV1 = Message<"types.OktaAssignmentV1"> & {
  /**
   * Header is the resource header for the Okta assignment.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is the specification for the Okta assignment.
   *
   * @generated from field: types.OktaAssignmentSpecV1 Spec = 2;
   */
  Spec?: OktaAssignmentSpecV1;
};

/**
 * Describes the message types.OktaAssignmentV1.
 * Use `create(OktaAssignmentV1Schema)` to create a new message.
 */
export const OktaAssignmentV1Schema: GenMessage<OktaAssignmentV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 316);

/**
 * OktaAssignmentSpecV1 is a Okta assignment specification.
 *
 * @generated from message types.OktaAssignmentSpecV1
 */
export type OktaAssignmentSpecV1 = Message<"types.OktaAssignmentSpecV1"> & {
  /**
   * User is the user that these actions will be applied to.
   *
   * @generated from field: string User = 1;
   */
  User: string;

  /**
   * Targets is a list of Okta targets to take on a user.
   *
   * @generated from field: repeated types.OktaAssignmentTargetV1 Targets = 2;
   */
  Targets: OktaAssignmentTargetV1[];

  /**
   * CleanupTime is an optional field that notes when the assignment should be cleaned up.
   * If absent, the assignment will never be cleaned up.
   *
   * @generated from field: google.protobuf.Timestamp CleanupTime = 3;
   */
  CleanupTime?: Timestamp;

  /**
   * Status is the status of the assignment.
   *
   * @generated from field: types.OktaAssignmentSpecV1.OktaAssignmentStatus status = 4;
   */
  status: OktaAssignmentSpecV1_OktaAssignmentStatus;

  /**
   * LastTransition is an optional field that notes when the last state transition
   * occurred for this action. If absent, this object has never transitioned.
   *
   * @generated from field: google.protobuf.Timestamp LastTransition = 5;
   */
  LastTransition?: Timestamp;

  /**
   * Finalized is set when the assignment has been properly cleaned up.
   *
   * @generated from field: bool Finalized = 6;
   */
  Finalized: boolean;
};

/**
 * Describes the message types.OktaAssignmentSpecV1.
 * Use `create(OktaAssignmentSpecV1Schema)` to create a new message.
 */
export const OktaAssignmentSpecV1Schema: GenMessage<OktaAssignmentSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 317);

/**
 * OktaAssignmentStatus represents the status of an Okta assignment.
 *
 * @generated from enum types.OktaAssignmentSpecV1.OktaAssignmentStatus
 */
export enum OktaAssignmentSpecV1_OktaAssignmentStatus {
  /**
   * UNKNOWN indicates the status is not set.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * PENDING indicates the action has not yet been applied.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * PROCESSSING indicates that the assignment is being applied.
   *
   * @generated from enum value: PROCESSING = 2;
   */
  PROCESSING = 2,

  /**
   * SUCCESSFUL indicates the action was applied successfully.
   *
   * @generated from enum value: SUCCESSFUL = 3;
   */
  SUCCESSFUL = 3,

  /**
   * FAILED indicates the action was not applied successfully. It will be retried.
   *
   * @generated from enum value: FAILED = 4;
   */
  FAILED = 4,
}

/**
 * Describes the enum types.OktaAssignmentSpecV1.OktaAssignmentStatus.
 */
export const OktaAssignmentSpecV1_OktaAssignmentStatusSchema: GenEnum<OktaAssignmentSpecV1_OktaAssignmentStatus> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 317, 0);

/**
 * OktaAssignmentTargetV1 is a target of an Okta assignment.
 *
 * @generated from message types.OktaAssignmentTargetV1
 */
export type OktaAssignmentTargetV1 = Message<"types.OktaAssignmentTargetV1"> & {
  /**
   * Type is the type of Okta resource this assignment is targeting.
   *
   * @generated from field: types.OktaAssignmentTargetV1.OktaAssignmentTargetType type = 1;
   */
  type: OktaAssignmentTargetV1_OktaAssignmentTargetType;

  /**
   * ID is the ID of the Okta resource that's being targeted.
   *
   * @generated from field: string id = 2;
   */
  id: string;
};

/**
 * Describes the message types.OktaAssignmentTargetV1.
 * Use `create(OktaAssignmentTargetV1Schema)` to create a new message.
 */
export const OktaAssignmentTargetV1Schema: GenMessage<OktaAssignmentTargetV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 318);

/**
 * OktaAssignmentTargetType is the type of Okta object that an assignment is targeting.
 *
 * @generated from enum types.OktaAssignmentTargetV1.OktaAssignmentTargetType
 */
export enum OktaAssignmentTargetV1_OktaAssignmentTargetType {
  /**
   * UNKNOWN indicates the target is unknown.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * APPLICATION indicates the target is an application.
   *
   * @generated from enum value: APPLICATION = 1;
   */
  APPLICATION = 1,

  /**
   * GROUP indicates the target is a group.
   *
   * @generated from enum value: GROUP = 2;
   */
  GROUP = 2,
}

/**
 * Describes the enum types.OktaAssignmentTargetV1.OktaAssignmentTargetType.
 */
export const OktaAssignmentTargetV1_OktaAssignmentTargetTypeSchema: GenEnum<OktaAssignmentTargetV1_OktaAssignmentTargetType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 318, 0);

/**
 * IntegrationV1 represents a connection between Teleport and some other 3rd party system.
 * This connection allows API access to that service from Teleport.
 * Each Integration instance must have a SubKind defined which identifies the external system.
 *
 * @generated from message types.IntegrationV1
 */
export type IntegrationV1 = Message<"types.IntegrationV1"> & {
  /**
   * Header is the resource header.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;

  /**
   * Spec is an Integration specification.
   *
   * @generated from field: types.IntegrationSpecV1 Spec = 2;
   */
  Spec?: IntegrationSpecV1;
};

/**
 * Describes the message types.IntegrationV1.
 * Use `create(IntegrationV1Schema)` to create a new message.
 */
export const IntegrationV1Schema: GenMessage<IntegrationV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 319);

/**
 * IntegrationSpecV1 contains properties of all the supported integrations.
 *
 * @generated from message types.IntegrationSpecV1
 */
export type IntegrationSpecV1 = Message<"types.IntegrationSpecV1"> & {
  /**
   * @generated from oneof types.IntegrationSpecV1.SubKindSpec
   */
  SubKindSpec: {
    /**
     * AWSOIDC contains the specific fields to handle the AWS OIDC Integration subkind
     *
     * @generated from field: types.AWSOIDCIntegrationSpecV1 AWSOIDC = 1;
     */
    value: AWSOIDCIntegrationSpecV1;
    case: "AWSOIDC";
  } | {
    /**
     * AzureOIDC contains the specific fields to handle the Azure OIDC Integration subkind
     *
     * @generated from field: types.AzureOIDCIntegrationSpecV1 AzureOIDC = 2;
     */
    value: AzureOIDCIntegrationSpecV1;
    case: "AzureOIDC";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message types.IntegrationSpecV1.
 * Use `create(IntegrationSpecV1Schema)` to create a new message.
 */
export const IntegrationSpecV1Schema: GenMessage<IntegrationSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 320);

/**
 * AWSOIDCIntegrationSpecV1 contains the spec properties for the AWS OIDC SubKind Integration.
 *
 * @generated from message types.AWSOIDCIntegrationSpecV1
 */
export type AWSOIDCIntegrationSpecV1 = Message<"types.AWSOIDCIntegrationSpecV1"> & {
  /**
   * RoleARN contains the Role ARN used to set up the Integration.
   * This is the AWS Role that Teleport will use to issue tokens for API Calls.
   *
   * @generated from field: string RoleARN = 1;
   */
  RoleARN: string;

  /**
   * IssuerS3URI is the Identity Provider that was configured in AWS.
   * This bucket/prefix/* files must be publicly accessible and contain the following:
   * > .well-known/openid-configuration
   * > .well-known/jwks
   * Format: s3://<bucket>/<prefix>
   * Optional. The proxy's endpoint is used if it is not specified.
   *
   * DEPRECATED: Thumbprint validation requires the issuer to update the IdP in AWS everytime the issuer changes the certificate.
   * Amazon had some whitelisted providers where the thumbprint was ignored. S3 hosted providers was in that list.
   * Amazon is now trusting all the root certificate authorities, and this workaround is no longer needed.
   * DELETE IN 18.0.
   *
   * @generated from field: string IssuerS3URI = 2 [deprecated = true];
   * @deprecated
   */
  IssuerS3URI: string;
};

/**
 * Describes the message types.AWSOIDCIntegrationSpecV1.
 * Use `create(AWSOIDCIntegrationSpecV1Schema)` to create a new message.
 */
export const AWSOIDCIntegrationSpecV1Schema: GenMessage<AWSOIDCIntegrationSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 321);

/**
 * AzureOIDCIntegrationSpecV1 contains the spec properties for the Azure OIDC SubKind Integration.
 *
 * @generated from message types.AzureOIDCIntegrationSpecV1
 */
export type AzureOIDCIntegrationSpecV1 = Message<"types.AzureOIDCIntegrationSpecV1"> & {
  /**
   * TenantID specifies the ID of Entra Tenant (Directory)
   * that this plugin integrates with.
   *
   * @generated from field: string TenantID = 1;
   */
  TenantID: string;

  /**
   * ClientID specifies the ID of Azure enterprise application (client)
   * that corresponds to this plugin.
   *
   * @generated from field: string ClientID = 2;
   */
  ClientID: string;
};

/**
 * Describes the message types.AzureOIDCIntegrationSpecV1.
 * Use `create(AzureOIDCIntegrationSpecV1Schema)` to create a new message.
 */
export const AzureOIDCIntegrationSpecV1Schema: GenMessage<AzureOIDCIntegrationSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 322);

/**
 * HeadlessAuthentication holds data for an ongoing headless authentication attempt.
 *
 * @generated from message types.HeadlessAuthentication
 */
export type HeadlessAuthentication = Message<"types.HeadlessAuthentication"> & {
  /**
   * Header is the resource header.
   *
   * @generated from field: types.ResourceHeader header = 1;
   */
  header?: ResourceHeader;

  /**
   * User is a teleport user name.
   *
   * @generated from field: string user = 2;
   */
  user: string;

  /**
   * PublicKey is an ssh public key to sign in case of successful auth.
   *
   * Deprecated: prefer SshPublicKey and/or TlsPublicKey.
   *
   * @generated from field: bytes public_key = 3 [deprecated = true];
   * @deprecated
   */
  publicKey: Uint8Array;

  /**
   * State is the headless authentication request state.
   *
   * @generated from field: types.HeadlessAuthenticationState state = 4;
   */
  state: HeadlessAuthenticationState;

  /**
   * MFADevice is the mfa device used to approve the request in case of successful auth.
   *
   * @generated from field: types.MFADevice mfa_device = 5;
   */
  mfaDevice?: MFADevice;

  /**
   * ClientIPAddress is the IP address of the client being authenticated.
   *
   * @generated from field: string client_ip_address = 6;
   */
  clientIpAddress: string;

  /**
   * SshPublicKey is a public key that will be used as the subject of the issued
   * SSH certificate in case of successful auth. It must be in SSH authorized_keys format.
   *
   * @generated from field: bytes ssh_public_key = 7;
   */
  sshPublicKey: Uint8Array;

  /**
   * TlsPublicKey is a public key that will be used as the subject of the issued
   * TLS certificate in case of successful auth. It must be in PEM-encoded
   * PKCS#1 or PKIX format.
   *
   * @generated from field: bytes tls_public_key = 8;
   */
  tlsPublicKey: Uint8Array;
};

/**
 * Describes the message types.HeadlessAuthentication.
 * Use `create(HeadlessAuthenticationSchema)` to create a new message.
 */
export const HeadlessAuthenticationSchema: GenMessage<HeadlessAuthentication> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 323);

/**
 * WatchKind specifies resource kind to watch
 * When adding fields to this struct, make sure to review/update WatchKind.Contains method.
 *
 * @generated from message types.WatchKind
 */
export type WatchKind = Message<"types.WatchKind"> & {
  /**
   * Kind is a resource kind to watch
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * LoadSecrets specifies whether to load secrets
   *
   * @generated from field: bool LoadSecrets = 2;
   */
  LoadSecrets: boolean;

  /**
   * Name is an optional specific resource type to watch,
   * if specified only the events with a specific resource
   * name will be sent
   *
   * @generated from field: string Name = 3;
   */
  Name: string;

  /**
   * Filter is an optional mapping of custom filter parameters.
   * Valid values vary by resource kind.
   *
   * @generated from field: map<string, string> Filter = 4;
   */
  Filter: { [key: string]: string };

  /**
   * SubKind is a resource subkind to watch
   *
   * @generated from field: string SubKind = 5;
   */
  SubKind: string;

  /**
   * Version optionally specifies the resource version to watch.
   * Currently this field is ignored.
   *
   * @generated from field: string Version = 6;
   */
  Version: string;
};

/**
 * Describes the message types.WatchKind.
 * Use `create(WatchKindSchema)` to create a new message.
 */
export const WatchKindSchema: GenMessage<WatchKind> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 324);

/**
 * WatchStatusV1 is intended to be attached to OpInit events and contain information about a successful WatchEvents call.
 *
 * @generated from message types.WatchStatusV1
 */
export type WatchStatusV1 = Message<"types.WatchStatusV1"> & {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind. Currently unused for this resource.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.WatchStatusSpecV1 Spec = 5;
   */
  Spec?: WatchStatusSpecV1;
};

/**
 * Describes the message types.WatchStatusV1.
 * Use `create(WatchStatusV1Schema)` to create a new message.
 */
export const WatchStatusV1Schema: GenMessage<WatchStatusV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 325);

/**
 * WatchStatusSpecV1 contains resource kinds confirmed by WatchEvents to be included in the event stream.
 *
 * @generated from message types.WatchStatusSpecV1
 */
export type WatchStatusSpecV1 = Message<"types.WatchStatusSpecV1"> & {
  /**
   * @generated from field: repeated types.WatchKind Kinds = 1;
   */
  Kinds: WatchKind[];
};

/**
 * Describes the message types.WatchStatusSpecV1.
 * Use `create(WatchStatusSpecV1Schema)` to create a new message.
 */
export const WatchStatusSpecV1Schema: GenMessage<WatchStatusSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 326);

/**
 * ServerInfoV1 contains info that should be applied to joining Nodes.
 *
 * @generated from message types.ServerInfoV1
 */
export type ServerInfoV1 = Message<"types.ServerInfoV1"> & {
  /**
   * Kind is the resource kind.
   *
   * @generated from field: string Kind = 1;
   */
  Kind: string;

  /**
   * SubKind is an optional resource subkind.
   *
   * @generated from field: string SubKind = 2;
   */
  SubKind: string;

  /**
   * Version is the resource version.
   *
   * @generated from field: string Version = 3;
   */
  Version: string;

  /**
   * Metadata is the resource metadata.
   *
   * @generated from field: types.Metadata Metadata = 4;
   */
  Metadata?: Metadata;

  /**
   * Spec is the resource spec.
   *
   * @generated from field: types.ServerInfoSpecV1 Spec = 5;
   */
  Spec?: ServerInfoSpecV1;
};

/**
 * Describes the message types.ServerInfoV1.
 * Use `create(ServerInfoV1Schema)` to create a new message.
 */
export const ServerInfoV1Schema: GenMessage<ServerInfoV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 327);

/**
 * ServerInfoSpecV1 contains fields used to match Nodes to this ServerInfo.
 *
 * @generated from message types.ServerInfoSpecV1
 */
export type ServerInfoSpecV1 = Message<"types.ServerInfoSpecV1"> & {
  /**
   * NewLabels is the set of labels to add to nodes matching this ServerInfo.
   *
   * @generated from field: map<string, string> NewLabels = 2;
   */
  NewLabels: { [key: string]: string };
};

/**
 * Describes the message types.ServerInfoSpecV1.
 * Use `create(ServerInfoSpecV1Schema)` to create a new message.
 */
export const ServerInfoSpecV1Schema: GenMessage<ServerInfoSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 328);

/**
 * JamfSpecV1 is the base configuration for the Jamf MDM service.
 *
 * @generated from message types.JamfSpecV1
 */
export type JamfSpecV1 = Message<"types.JamfSpecV1"> & {
  /**
   * Enabled toggles the service on or off.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * Name of the service device source.
   * See the teleport.devicetrust.v1.DeviceSource proto.
   * Defaults to "jamf".
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Initial sync delay for the service.
   * Set to negative to perform syncs immediately on startup.
   * Defaults to a random delay (a few minutes max).
   *
   * @generated from field: int64 sync_delay = 3;
   */
  syncDelay: bigint;

  /**
   * Jamf Pro API endpoint.
   * Example: "https://yourtenant.jamfcloud.com/api".
   * Required.
   *
   * @generated from field: string api_endpoint = 4;
   */
  apiEndpoint: string;

  /**
   * Inventory sync entries.
   * If empty a default sync configuration is used.
   *
   * @generated from field: repeated types.JamfInventoryEntry inventory = 7;
   */
  inventory: JamfInventoryEntry[];
};

/**
 * Describes the message types.JamfSpecV1.
 * Use `create(JamfSpecV1Schema)` to create a new message.
 */
export const JamfSpecV1Schema: GenMessage<JamfSpecV1> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 329);

/**
 * JamfInventoryEntry is an inventory sync entry for [JamfSpecV1].
 *
 * @generated from message types.JamfInventoryEntry
 */
export type JamfInventoryEntry = Message<"types.JamfInventoryEntry"> & {
  /**
   * Jamf Pro API RSQL filter, used when querying endpoints like
   * "/api/v1/computers-inventory".
   * See https://developer.jamf.com/jamf-pro/reference/get_v1-computers-inventory.
   *
   * @generated from field: string filter_rsql = 1;
   */
  filterRsql: string;

  /**
   * Sync period for PARTIAL syncs.
   * PARTIAL syncs are scheduled in the time window between FULL syncs, so
   * sync_period_partial must always be smaller than sync_period_full, otherwise
   * it would never trigger.
   * Set to zero or negative to disable PARTIAL syncs.
   *
   * @generated from field: int64 sync_period_partial = 2;
   */
  syncPeriodPartial: bigint;

  /**
   * Sync period for FULL syncs.
   * Ideally sync_period_full is a multiple of sync_period_partial, so schedules
   * line up perfectly.
   * Set to zero or negative to disable FULL syncs.
   *
   * @generated from field: int64 sync_period_full = 3;
   */
  syncPeriodFull: bigint;

  /**
   * on_missing is the trigger used on devices missing from the MDM view in a
   * FULL sync.
   * Only runs on successful FULL syncs.
   * Corresponds to [teleport.devicetrust.v1.SyncInventoryDeviceAction].
   * Must be either "NOOP" or "DELETE".
   * Defaults to "NOOP".
   *
   * @generated from field: string on_missing = 4;
   */
  onMissing: string;

  /**
   * Custom page size for inventory queries.
   * A server default is used if zeroed or negative.
   *
   * @generated from field: int32 page_size = 5;
   */
  pageSize: number;
};

/**
 * Describes the message types.JamfInventoryEntry.
 * Use `create(JamfInventoryEntrySchema)` to create a new message.
 */
export const JamfInventoryEntrySchema: GenMessage<JamfInventoryEntry> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 330);

/**
 * MessageWithHeader is a message with a resource header. This is used primarily
 * for parsing of resource headers and isn't expected to be used directly by any
 * resources.
 *
 * When using a oneof in a protobuf messages, the existing utils.FastMarshal
 * utility does not work, so using something like protojson or jsonpb is required.
 * However, these do not respect gogoproto's extensions. When using a ResourceHeader,
 * protojson will not recognize that the ResourceHeader is intended to be embedded and
 * the resulting JSON will have the header as a separate field. This means that using
 * utils.FastUnmarshal will not work for extracting a ResourceHeader from the
 * JSON, and we explicitly extract this header to do things like version checking in
 * lib/services.
 *
 * This can be avoided by explicitly embedding the members of the ResourceHeader in
 * a message. However, if we would like to avoid this, we can use this MessageWitHheader
 * to extract the resource header and its elements, which can later be used for the
 * aforementioned processing in lib/services.
 *
 * @generated from message types.MessageWithHeader
 */
export type MessageWithHeader = Message<"types.MessageWithHeader"> & {
  /**
   * Header is the resource header for a resource.
   *
   * @generated from field: types.ResourceHeader Header = 1;
   */
  Header?: ResourceHeader;
};

/**
 * Describes the message types.MessageWithHeader.
 * Use `create(MessageWithHeaderSchema)` to create a new message.
 */
export const MessageWithHeaderSchema: GenMessage<MessageWithHeader> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 331);

/**
 * AWSMatcher matches AWS EC2 instances and AWS Databases
 *
 * @generated from message types.AWSMatcher
 */
export type AWSMatcher = Message<"types.AWSMatcher"> & {
  /**
   * Types are AWS database types to match, "ec2", "rds", "redshift", "elasticache",
   * or "memorydb".
   *
   * @generated from field: repeated string Types = 1;
   */
  Types: string[];

  /**
   * Regions are AWS regions to query for databases.
   *
   * @generated from field: repeated string Regions = 2;
   */
  Regions: string[];

  /**
   * AssumeRoleARN is the AWS role to assume for database discovery.
   *
   * @generated from field: types.AssumeRole AssumeRole = 3;
   */
  AssumeRole?: AssumeRole;

  /**
   * Tags are AWS resource Tags to match.
   *
   * @generated from field: wrappers.LabelValues Tags = 4;
   */
  Tags?: LabelValues;

  /**
   * Params sets the join method when installing on discovered EC2 nodes
   *
   * @generated from field: types.InstallerParams Params = 5;
   */
  Params?: InstallerParams;

  /**
   * SSM provides options to use when sending a document command to
   * an EC2 node
   *
   * @generated from field: types.AWSSSM SSM = 6;
   */
  SSM?: AWSSSM;

  /**
   * Integration is the integration name used to generate credentials to interact with AWS APIs.
   * Environment credentials will not be used when this value is set.
   *
   * @generated from field: string Integration = 7;
   */
  Integration: string;

  /**
   * KubeAppDiscovery controls whether Kubernetes App Discovery will be enabled for agents running on
   * discovered clusters, currently only affects AWS EKS discovery in integration mode.
   *
   * @generated from field: bool KubeAppDiscovery = 8;
   */
  KubeAppDiscovery: boolean;

  /**
   * SetupAccessForARN is the role that the discovery service should create EKS Access Entries for.
   * This value should match the IAM identity that Teleport Kubernetes Service uses.
   * If this value is empty, the discovery service will attempt to set up access for its own identity (self).
   *
   * @generated from field: string SetupAccessForARN = 9;
   */
  SetupAccessForARN: string;
};

/**
 * Describes the message types.AWSMatcher.
 * Use `create(AWSMatcherSchema)` to create a new message.
 */
export const AWSMatcherSchema: GenMessage<AWSMatcher> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 332);

/**
 * AssumeRole provides a role ARN and ExternalID to assume an AWS role
 * when interacting with AWS resources.
 *
 * @generated from message types.AssumeRole
 */
export type AssumeRole = Message<"types.AssumeRole"> & {
  /**
   * RoleARN is the fully specified AWS IAM role ARN.
   *
   * @generated from field: string RoleARN = 1;
   */
  RoleARN: string;

  /**
   * ExternalID is the external ID used to assume a role in another account.
   *
   * @generated from field: string ExternalID = 2;
   */
  ExternalID: string;
};

/**
 * Describes the message types.AssumeRole.
 * Use `create(AssumeRoleSchema)` to create a new message.
 */
export const AssumeRoleSchema: GenMessage<AssumeRole> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 333);

/**
 * InstallParams sets join method to use on discovered nodes
 *
 * @generated from message types.InstallerParams
 */
export type InstallerParams = Message<"types.InstallerParams"> & {
  /**
   * JoinMethod is the method to use when joining the cluster
   *
   * @generated from field: string JoinMethod = 1;
   */
  JoinMethod: string;

  /**
   * JoinToken is the token to use when joining the cluster
   *
   * @generated from field: string JoinToken = 2;
   */
  JoinToken: string;

  /**
   * ScriptName is the name of the teleport installer script
   * resource for the cloud instance to execute
   *
   * @generated from field: string ScriptName = 3;
   */
  ScriptName: string;

  /**
   * InstallTeleport disables agentless discovery
   *
   * @generated from field: bool InstallTeleport = 4;
   */
  InstallTeleport: boolean;

  /**
   * SSHDConfig provides the path to write sshd configuration changes
   *
   * @generated from field: string SSHDConfig = 5;
   */
  SSHDConfig: string;

  /**
   * PublicProxyAddr is the address of the proxy the discovered node should use
   * to connect to the cluster.
   *
   * @generated from field: string PublicProxyAddr = 6;
   */
  PublicProxyAddr: string;

  /**
   * Azure is the set of Azure-specific installation parameters.
   *
   * @generated from field: types.AzureInstallerParams Azure = 7;
   */
  Azure?: AzureInstallerParams;

  /**
   * EnrollMode indicates the enrollment mode to be used when adding a node.
   * Valid values:
   * 0: uses eice for EC2 matchers which use an integration and script for all the other methods
   * 1: uses script mode
   * 2: uses eice mode
   *
   * @generated from field: types.InstallParamEnrollMode EnrollMode = 8;
   */
  EnrollMode: InstallParamEnrollMode;
};

/**
 * Describes the message types.InstallerParams.
 * Use `create(InstallerParamsSchema)` to create a new message.
 */
export const InstallerParamsSchema: GenMessage<InstallerParams> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 334);

/**
 * AWSSSM provides options to use when executing SSM documents
 *
 * @generated from message types.AWSSSM
 */
export type AWSSSM = Message<"types.AWSSSM"> & {
  /**
   * DocumentName is the name of the document to use when executing an
   * SSM command
   *
   * @generated from field: string DocumentName = 1;
   */
  DocumentName: string;
};

/**
 * Describes the message types.AWSSSM.
 * Use `create(AWSSSMSchema)` to create a new message.
 */
export const AWSSSMSchema: GenMessage<AWSSSM> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 335);

/**
 * AzureInstallerParams is the set of Azure-specific installation parameters.
 *
 * @generated from message types.AzureInstallerParams
 */
export type AzureInstallerParams = Message<"types.AzureInstallerParams"> & {
  /**
   * ClientID is the client ID of the managed identity discovered nodes
   * should use to join the cluster.
   *
   * @generated from field: string ClientID = 1;
   */
  ClientID: string;
};

/**
 * Describes the message types.AzureInstallerParams.
 * Use `create(AzureInstallerParamsSchema)` to create a new message.
 */
export const AzureInstallerParamsSchema: GenMessage<AzureInstallerParams> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 336);

/**
 * AzureMatcher matches Azure resources.
 * It defines which resource types, filters and some configuration params.
 *
 * @generated from message types.AzureMatcher
 */
export type AzureMatcher = Message<"types.AzureMatcher"> & {
  /**
   * Subscriptions are Azure subscriptions to query for resources.
   *
   * @generated from field: repeated string Subscriptions = 1;
   */
  Subscriptions: string[];

  /**
   * ResourceGroups are Azure resource groups to query for resources.
   *
   * @generated from field: repeated string ResourceGroups = 2;
   */
  ResourceGroups: string[];

  /**
   * Types are Azure types to match: "mysql", "postgres", "aks", "vm"
   *
   * @generated from field: repeated string Types = 3;
   */
  Types: string[];

  /**
   * Regions are Azure locations to match for databases.
   *
   * @generated from field: repeated string Regions = 4;
   */
  Regions: string[];

  /**
   * ResourceTags are Azure tags on resources to match.
   *
   * @generated from field: wrappers.LabelValues ResourceTags = 5;
   */
  ResourceTags?: LabelValues;

  /**
   * Params sets the join method when installing on
   * discovered Azure nodes.
   *
   * @generated from field: types.InstallerParams Params = 6;
   */
  Params?: InstallerParams;
};

/**
 * Describes the message types.AzureMatcher.
 * Use `create(AzureMatcherSchema)` to create a new message.
 */
export const AzureMatcherSchema: GenMessage<AzureMatcher> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 337);

/**
 * GCPMatcher matches GCP resources.
 *
 * @generated from message types.GCPMatcher
 */
export type GCPMatcher = Message<"types.GCPMatcher"> & {
  /**
   * Types are GKE resource types to match: "gke", "vm".
   *
   * @generated from field: repeated string Types = 1;
   */
  Types: string[];

  /**
   * Locations are GKE locations to search resources for.
   *
   * @generated from field: repeated string Locations = 2;
   */
  Locations: string[];

  /**
   * Tags is obsolete and only exists for backwards compatibility. Use Labels instead.
   *
   * @generated from field: wrappers.LabelValues Tags = 3;
   */
  Tags?: LabelValues;

  /**
   * ProjectIDs are the GCP project ID where the resources are deployed.
   *
   * @generated from field: repeated string ProjectIDs = 4;
   */
  ProjectIDs: string[];

  /**
   * ServiceAccounts are the emails of service accounts attached to VMs.
   *
   * @generated from field: repeated string ServiceAccounts = 5;
   */
  ServiceAccounts: string[];

  /**
   * Params sets the join method when installing on
   * discovered GCP nodes.
   *
   * @generated from field: types.InstallerParams Params = 6;
   */
  Params?: InstallerParams;

  /**
   * Labels are GCP labels to match.
   *
   * @generated from field: wrappers.LabelValues Labels = 7;
   */
  Labels?: LabelValues;
};

/**
 * Describes the message types.GCPMatcher.
 * Use `create(GCPMatcherSchema)` to create a new message.
 */
export const GCPMatcherSchema: GenMessage<GCPMatcher> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 338);

/**
 * KubernetesMatcher matches Kubernetes services.
 *
 * @generated from message types.KubernetesMatcher
 */
export type KubernetesMatcher = Message<"types.KubernetesMatcher"> & {
  /**
   * Types are Kubernetes services types to match. Currently only 'app' is supported.
   *
   * @generated from field: repeated string Types = 1;
   */
  Types: string[];

  /**
   * Namespaces are Kubernetes namespaces in which to discover services
   *
   * @generated from field: repeated string Namespaces = 2;
   */
  Namespaces: string[];

  /**
   * Labels are Kubernetes services labels to match.
   *
   * @generated from field: wrappers.LabelValues Labels = 3;
   */
  Labels?: LabelValues;
};

/**
 * Describes the message types.KubernetesMatcher.
 * Use `create(KubernetesMatcherSchema)` to create a new message.
 */
export const KubernetesMatcherSchema: GenMessage<KubernetesMatcher> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 339);

/**
 * OktaOptions specify options related to the Okta service.
 *
 * @generated from message types.OktaOptions
 */
export type OktaOptions = Message<"types.OktaOptions"> & {
  /**
   * SyncPeriod is the duration between synchronization calls in nanoseconds.
   *
   * @generated from field: int64 SyncPeriod = 1;
   */
  SyncPeriod: bigint;
};

/**
 * Describes the message types.OktaOptions.
 * Use `create(OktaOptionsSchema)` to create a new message.
 */
export const OktaOptionsSchema: GenMessage<OktaOptions> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 340);

/**
 * AccessGraphSync is a configuration for Access Graph service.
 *
 * @generated from message types.AccessGraphSync
 */
export type AccessGraphSync = Message<"types.AccessGraphSync"> & {
  /**
   * AWS is a configuration for AWS Access Graph service poll service.
   *
   * @generated from field: repeated types.AccessGraphAWSSync AWS = 1;
   */
  AWS: AccessGraphAWSSync[];
};

/**
 * Describes the message types.AccessGraphSync.
 * Use `create(AccessGraphSyncSchema)` to create a new message.
 */
export const AccessGraphSyncSchema: GenMessage<AccessGraphSync> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 341);

/**
 * AccessGraphAWSSync is a configuration for AWS Access Graph service poll service.
 *
 * @generated from message types.AccessGraphAWSSync
 */
export type AccessGraphAWSSync = Message<"types.AccessGraphAWSSync"> & {
  /**
   * Regions are AWS regions to import resources from.
   *
   * @generated from field: repeated string Regions = 1;
   */
  Regions: string[];

  /**
   * AssumeRoleARN is the AWS role to assume for database discovery.
   *
   * @generated from field: types.AssumeRole AssumeRole = 3;
   */
  AssumeRole?: AssumeRole;

  /**
   * Integration is the integration name used to generate credentials to interact with AWS APIs.
   *
   * @generated from field: string Integration = 4;
   */
  Integration: string;
};

/**
 * Describes the message types.AccessGraphAWSSync.
 * Use `create(AccessGraphAWSSyncSchema)` to create a new message.
 */
export const AccessGraphAWSSyncSchema: GenMessage<AccessGraphAWSSync> = /*@__PURE__*/
  messageDesc(file_teleport_legacy_types_types, 342);

/**
 * IAMPolicyStatus represents states that describe if an AWS database
 * has its IAM policy properly configured or not.
 * This enum is set in a Sync.Map during an IAM task that checks for the
 * validity of IAM policy, and the database gets updated with the value
 * from this map during a heartbeat.
 *
 * @generated from enum types.IAMPolicyStatus
 */
export enum IAMPolicyStatus {
  /**
   * IAM_POLICY_STATUS_UNSPECIFIED represents a zero value where
   * nothing has been attempted yet.
   *
   * @generated from enum value: IAM_POLICY_STATUS_UNSPECIFIED = 0;
   */
  IAM_POLICY_STATUS_UNSPECIFIED = 0,

  /**
   * IAM_POLICY_STATUS_PENDING represents a state where iam policy status
   * is pending to be checked. This enum value is set at the start of
   * registering a database -> IAM setup (before the db heartbeat starts).
   *
   * This state was required for two reasons:
   *   1) To be able to tell apart from an older service that do not update
   *      the IAMPolicyStatus (in which case the enum value will remain the
   *      zero value).
   *   2) When starting a database, the heartbeat and its IAM task starts,
   *      and the heartbeat may run first before the IAM task finishes.
   *
   * @generated from enum value: IAM_POLICY_STATUS_PENDING = 1;
   */
  IAM_POLICY_STATUS_PENDING = 1,

  /**
   * IAM_POLICY_STATUS_FAILED represents a state where an error occured
   * while checking for IAM policy status eg: no AWS credentials provider found
   * or the policy was misconfigured.
   *
   * @generated from enum value: IAM_POLICY_STATUS_FAILED = 2;
   */
  IAM_POLICY_STATUS_FAILED = 2,

  /**
   * IAM_POLICY_STATUS_SUCCESS represents a state where IAM policy was configured
   * correctly.
   *
   * @generated from enum value: IAM_POLICY_STATUS_SUCCESS = 3;
   */
  IAM_POLICY_STATUS_SUCCESS = 3,
}

/**
 * Describes the enum types.IAMPolicyStatus.
 */
export const IAMPolicyStatusSchema: GenEnum<IAMPolicyStatus> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 0);

/**
 * DatabaseTLSMode represents the level of TLS verification performed by
 * DB agent when connecting to a database.
 *
 * @generated from enum types.DatabaseTLSMode
 */
export enum DatabaseTLSMode {
  /**
   * VERIFY_FULL performs full certificate validation.
   *
   * @generated from enum value: VERIFY_FULL = 0;
   */
  VERIFY_FULL = 0,

  /**
   * VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.
   *
   * @generated from enum value: VERIFY_CA = 1;
   */
  VERIFY_CA = 1,

  /**
   * INSECURE accepts any certificate provided by server. This is the least secure option.
   *
   * @generated from enum value: INSECURE = 2;
   */
  INSECURE = 2,
}

/**
 * Describes the enum types.DatabaseTLSMode.
 */
export const DatabaseTLSModeSchema: GenEnum<DatabaseTLSMode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 1);

/**
 * PrivateKeyType is the storage type of a private key.
 *
 * @generated from enum types.PrivateKeyType
 */
export enum PrivateKeyType {
  /**
   * RAW is a plaintext private key.
   *
   * @generated from enum value: RAW = 0;
   */
  RAW = 0,

  /**
   * PKCS11 is a private key backed by a PKCS11 device such as HSM.
   *
   * @generated from enum value: PKCS11 = 1;
   */
  PKCS11 = 1,

  /**
   * GCP_KMS is a private key backed by GCP KMS.
   *
   * @generated from enum value: GCP_KMS = 2;
   */
  GCP_KMS = 2,

  /**
   * AWS_KMS is a private key backed by AWS KMS.
   *
   * @generated from enum value: AWS_KMS = 3;
   */
  AWS_KMS = 3,
}

/**
 * Describes the enum types.PrivateKeyType.
 */
export const PrivateKeyTypeSchema: GenEnum<PrivateKeyType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 2);

/**
 * ProxyListenerMode represents the cluster proxy listener mode.
 *
 * @generated from enum types.ProxyListenerMode
 */
export enum ProxyListenerMode {
  /**
   * Separate is the proxy listener mode indicating that proxies are running
   * in separate listener mode where Teleport Proxy services use different listeners.
   *
   * @generated from enum value: Separate = 0;
   */
  Separate = 0,

  /**
   * Multiplex is the proxy listener mode indicating the proxy should use multiplex mode
   * where all proxy services are multiplexed on a single proxy port.
   *
   * @generated from enum value: Multiplex = 1;
   */
  Multiplex = 1,
}

/**
 * Describes the enum types.ProxyListenerMode.
 */
export const ProxyListenerModeSchema: GenEnum<ProxyListenerMode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 3);

/**
 * RoutingStrategy determines the strategy used to route to nodes.
 *
 * @generated from enum types.RoutingStrategy
 */
export enum RoutingStrategy {
  /**
   * UnambiguousMatch only routes to distinct nodes.
   *
   * @generated from enum value: UNAMBIGUOUS_MATCH = 0;
   */
  UNAMBIGUOUS_MATCH = 0,

  /**
   * MostRecent routes to the most recently heartbeated node if duplicates are present.
   *
   * @generated from enum value: MOST_RECENT = 1;
   */
  MOST_RECENT = 1,
}

/**
 * Describes the enum types.RoutingStrategy.
 */
export const RoutingStrategySchema: GenEnum<RoutingStrategy> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 4);

/**
 * UserTokenUsage contains additional information about the intended usage of a user token.
 *
 * @generated from enum types.UserTokenUsage
 */
export enum UserTokenUsage {
  /**
   * Default value that implies token usage was not set.
   *
   * @generated from enum value: USER_TOKEN_USAGE_UNSPECIFIED = 0;
   */
  USER_TOKEN_USAGE_UNSPECIFIED = 0,

  /**
   * USER_TOKEN_RECOVER_PASSWORD is a request to recover password.
   *
   * @generated from enum value: USER_TOKEN_RECOVER_PASSWORD = 1;
   */
  USER_TOKEN_RECOVER_PASSWORD = 1,

  /**
   * USER_TOKEN_RECOVER_MFA is a request to recover a MFA.
   *
   * @generated from enum value: USER_TOKEN_RECOVER_MFA = 2;
   */
  USER_TOKEN_RECOVER_MFA = 2,

  /**
   * USER_TOKEN_RENEWAL_BOT is a request to generate certificates
   * for a bot user.
   *
   * @generated from enum value: USER_TOKEN_RENEWAL_BOT = 3;
   */
  USER_TOKEN_RENEWAL_BOT = 3,
}

/**
 * Describes the enum types.UserTokenUsage.
 */
export const UserTokenUsageSchema: GenEnum<UserTokenUsage> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 5);

/**
 * RequestState represents the state of a request for escalated privilege.
 *
 * @generated from enum types.RequestState
 */
export enum RequestState {
  /**
   * NONE variant exists to allow RequestState to be explicitly omitted
   * in certain circumstances (e.g. in an AccessRequestFilter).
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * PENDING variant is the default for newly created requests.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * APPROVED variant indicates that a request has been accepted by
   * an administrating party.
   *
   * @generated from enum value: APPROVED = 2;
   */
  APPROVED = 2,

  /**
   * DENIED variant indicates that a request has been rejected by
   * an administrating party.
   *
   * @generated from enum value: DENIED = 3;
   */
  DENIED = 3,

  /**
   * PROMOTED variant indicates that a request has been promoted to
   * an access list.
   *
   * @generated from enum value: PROMOTED = 4;
   */
  PROMOTED = 4,
}

/**
 * Describes the enum types.RequestState.
 */
export const RequestStateSchema: GenEnum<RequestState> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 6);

/**
 * @generated from enum types.AccessRequestScope
 */
export enum AccessRequestScope {
  /**
   * DEFAULT allows all requests to be viewed
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * MY_REQUESTS will return only requests created by the requester
   *
   * @generated from enum value: MY_REQUESTS = 1;
   */
  MY_REQUESTS = 1,

  /**
   * NEEDS_REVIEW will return only requests that were not created by
   * the requester and do not include a review made by the requester
   *
   * @generated from enum value: NEEDS_REVIEW = 2;
   */
  NEEDS_REVIEW = 2,

  /**
   * REVIEWED will return only requests that were not created by
   * the requester and have a review submitted by the requester. This
   * can include requests that have no yet been completely approved/denied.
   *
   * @generated from enum value: REVIEWED = 3;
   */
  REVIEWED = 3,
}

/**
 * Describes the enum types.AccessRequestScope.
 */
export const AccessRequestScopeSchema: GenEnum<AccessRequestScope> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 7);

/**
 * CreateHostUserMode determines whether host user creation should be
 * disabled or if host users should be cleaned up or kept after
 * sessions end.
 *
 * @generated from enum types.CreateHostUserMode
 */
export enum CreateHostUserMode {
  /**
   * @generated from enum value: HOST_USER_MODE_UNSPECIFIED = 0;
   */
  HOST_USER_MODE_UNSPECIFIED = 0,

  /**
   * HOST_USER_MODE_OFF disables host user creation.
   *
   * @generated from enum value: HOST_USER_MODE_OFF = 1;
   */
  HOST_USER_MODE_OFF = 1,

  /**
   * HOST_USER_MODE_DROP enables host user creation and deletes users at session end.
   * Deprecated: replaced by HOST_USER_MODE_INSECURE_DROP.
   *
   * @generated from enum value: HOST_USER_MODE_DROP = 2 [deprecated = true];
   * @deprecated
   */
  HOST_USER_MODE_DROP = 2,

  /**
   * HOST_USER_MODE_KEEP enables host user creation and leaves users behind at session end.
   *
   * @generated from enum value: HOST_USER_MODE_KEEP = 3;
   */
  HOST_USER_MODE_KEEP = 3,

  /**
   * HOST_USER_MODE_INSECURE_DROP enables host user creation without a home directory and deletes
   * users at session end.
   *
   * @generated from enum value: HOST_USER_MODE_INSECURE_DROP = 4;
   */
  HOST_USER_MODE_INSECURE_DROP = 4,
}

/**
 * Describes the enum types.CreateHostUserMode.
 */
export const CreateHostUserModeSchema: GenEnum<CreateHostUserMode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 8);

/**
 * CreateDatabaseUserMode determines whether database user creation should be
 * disabled or if users should be cleaned up or kept after sessions end.
 *
 * @generated from enum types.CreateDatabaseUserMode
 */
export enum CreateDatabaseUserMode {
  /**
   * @generated from enum value: DB_USER_MODE_UNSPECIFIED = 0;
   */
  DB_USER_MODE_UNSPECIFIED = 0,

  /**
   * DB_USER_MODE_OFF disables user creation.
   *
   * @generated from enum value: DB_USER_MODE_OFF = 1;
   */
  DB_USER_MODE_OFF = 1,

  /**
   * DB_USER_MODE_KEEP allows user creation and disable users at session end.
   *
   * @generated from enum value: DB_USER_MODE_KEEP = 2;
   */
  DB_USER_MODE_KEEP = 2,

  /**
   * DB_USER_MODE_BEST_EFFORT_DROP allows user creation and tries to drop user
   * at session end. If the drop fails, fallback to disabling them.
   *
   * @generated from enum value: DB_USER_MODE_BEST_EFFORT_DROP = 3;
   */
  DB_USER_MODE_BEST_EFFORT_DROP = 3,
}

/**
 * Describes the enum types.CreateDatabaseUserMode.
 */
export const CreateDatabaseUserModeSchema: GenEnum<CreateDatabaseUserMode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 9);

/**
 * CertExtensionMode specifies the type of extension to use in the cert.
 *
 * @generated from enum types.CertExtensionMode
 */
export enum CertExtensionMode {
  /**
   * EXTENSION represents a cert extension that may or may not be
   * honored by the server.
   *
   * @generated from enum value: EXTENSION = 0;
   */
  EXTENSION = 0,
}

/**
 * Describes the enum types.CertExtensionMode.
 */
export const CertExtensionModeSchema: GenEnum<CertExtensionMode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 10);

/**
 * CertExtensionType represents the certificate type the extension is for.
 * Currently only ssh is supported.
 *
 * @generated from enum types.CertExtensionType
 */
export enum CertExtensionType {
  /**
   * SSH is used when extending an ssh certificate
   *
   * @generated from enum value: SSH = 0;
   */
  SSH = 0,
}

/**
 * Describes the enum types.CertExtensionType.
 */
export const CertExtensionTypeSchema: GenEnum<CertExtensionType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 11);

/**
 * PasswordState indicates what is known about existence of user's password.
 *
 * @generated from enum types.PasswordState
 */
export enum PasswordState {
  /**
   * Unable to tell whether the password has been configured.
   *
   * @generated from enum value: PASSWORD_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Password is known to be not configured.
   *
   * @generated from enum value: PASSWORD_STATE_UNSET = 1;
   */
  UNSET = 1,

  /**
   * Password is known to be configured.
   *
   * @generated from enum value: PASSWORD_STATE_SET = 2;
   */
  SET = 2,
}

/**
 * Describes the enum types.PasswordState.
 */
export const PasswordStateSchema: GenEnum<PasswordState> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 12);

/**
 * TrustedDeviceRequirement indicates whether access may be hindered by the lack
 * of a trusted device.
 *
 * @generated from enum types.TrustedDeviceRequirement
 */
export enum TrustedDeviceRequirement {
  /**
   * Device requirement not determined.
   * Does not mean that a device is not required, only that the necessary data
   * was not considered.
   *
   * @generated from enum value: TRUSTED_DEVICE_REQUIREMENT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Trusted device not required.
   *
   * @generated from enum value: TRUSTED_DEVICE_REQUIREMENT_NOT_REQUIRED = 1;
   */
  NOT_REQUIRED = 1,

  /**
   * Trusted device required by either cluster mode or user roles.
   *
   * @generated from enum value: TRUSTED_DEVICE_REQUIREMENT_REQUIRED = 2;
   */
  REQUIRED = 2,
}

/**
 * Describes the enum types.TrustedDeviceRequirement.
 */
export const TrustedDeviceRequirementSchema: GenEnum<TrustedDeviceRequirement> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 13);

/**
 * SessionState represents the state of a session.
 *
 * @generated from enum types.SessionState
 */
export enum SessionState {
  /**
   * Pending variant represents a session that is waiting on participants to fulfill the criteria
   * to start the session.
   *
   * @generated from enum value: SessionStatePending = 0;
   */
  SessionStatePending = 0,

  /**
   * Running variant represents a session that has had it's criteria for starting
   * fulfilled at least once and has transitioned to a RUNNING state.
   *
   * @generated from enum value: SessionStateRunning = 1;
   */
  SessionStateRunning = 1,

  /**
   * Terminated variant represents a session that is no longer running and due for removal.
   *
   * @generated from enum value: SessionStateTerminated = 2;
   */
  SessionStateTerminated = 2,
}

/**
 * Describes the enum types.SessionState.
 */
export const SessionStateSchema: GenEnum<SessionState> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 14);

/**
 * AlertSeverity represents how problematic/urgent an alert is, and is used to assist
 * in sorting alerts for display.
 *
 * @generated from enum types.AlertSeverity
 */
export enum AlertSeverity {
  /**
   * @generated from enum value: LOW = 0;
   */
  LOW = 0,

  /**
   * @generated from enum value: MEDIUM = 5;
   */
  MEDIUM = 5,

  /**
   * @generated from enum value: HIGH = 10;
   */
  HIGH = 10,
}

/**
 * Describes the enum types.AlertSeverity.
 */
export const AlertSeveritySchema: GenEnum<AlertSeverity> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 15);

/**
 * RequireMFAType is a type of MFA requirement enforced outside of login,
 * such as per-session MFA or per-request PIV touch.
 *
 * @generated from enum types.RequireMFAType
 */
export enum RequireMFAType {
  /**
   * OFF means additional MFA enforcement is not enabled.
   *
   * @generated from enum value: OFF = 0;
   */
  OFF = 0,

  /**
   * SESSION means MFA is required to begin server sessions.
   *
   * @generated from enum value: SESSION = 1;
   */
  SESSION = 1,

  /**
   * SESSION_AND_HARDWARE_KEY means MFA is required to begin server sessions,
   * and login sessions must use a private key backed by a hardware key.
   *
   * @generated from enum value: SESSION_AND_HARDWARE_KEY = 2;
   */
  SESSION_AND_HARDWARE_KEY = 2,

  /**
   * HARDWARE_KEY_TOUCH means login sessions must use a hardware private key that
   * requires touch to be used.
   *
   * @generated from enum value: HARDWARE_KEY_TOUCH = 3;
   */
  HARDWARE_KEY_TOUCH = 3,

  /**
   * HARDWARE_KEY_PIN means login sessions must use a hardware private key that
   * requires pin to be used.
   *
   * @generated from enum value: HARDWARE_KEY_PIN = 4;
   */
  HARDWARE_KEY_PIN = 4,

  /**
   * HARDWARE_KEY_TOUCH_AND_PIN means login sessions must use a hardware private key that
   * requires touch and pin to be used.
   *
   * @generated from enum value: HARDWARE_KEY_TOUCH_AND_PIN = 5;
   */
  HARDWARE_KEY_TOUCH_AND_PIN = 5,
}

/**
 * Describes the enum types.RequireMFAType.
 */
export const RequireMFATypeSchema: GenEnum<RequireMFAType> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 16);

/**
 * SignatureAlgorithmSuite represents the suite of cryptographic signature algorithms used in the cluster.
 *
 * @generated from enum types.SignatureAlgorithmSuite
 */
export enum SignatureAlgorithmSuite {
  /**
   * SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED represents an unspecified signature algorithm suite.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * SIGNATURE_ALGORITHM_SUITE_LEGACY is the original algorithm suite used in
   * Teleport, it almost exclusively uses 2048-bit RSA.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_LEGACY = 1;
   */
  LEGACY = 1,

  /**
   * SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 aims to strikes a balance between
   * security, compatibility, and performance. It uses Ed25519 for most SSH
   * keys, ECDSA on the NIST P256 curve for most TLS keys, and 2048-bit RSA
   * where necessary for compatibility with third-party software.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_BALANCED_V1 = 2;
   */
  BALANCED_V1 = 2,

  /**
   * SIGNATURE_ALGORITHM_SUITE_FIPS_V1 is tailored for FIPS compliance. It is
   * based on the BALANCED_V1 suite but replaces all instances of Ed25519 with
   * ECDSA on the NIST P256 curve.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_FIPS_V1 = 3;
   */
  FIPS_V1 = 3,

  /**
   * SIGNATURE_ALGORITHM_SUITE_HSM_V1 is tailored for clusters using an HSM or
   * KMS service to back CA private material. It is based on the BALANCED suite
   * but replaces Ed25519 with ECDSA on the NIST P256 curve for CA keys only,
   * not for server or client keys. It is also valid to use the LEGACY for FIPS
   * suites if your cluster uses an HSM or KMS.
   *
   * @generated from enum value: SIGNATURE_ALGORITHM_SUITE_HSM_V1 = 4;
   */
  HSM_V1 = 4,
}

/**
 * Describes the enum types.SignatureAlgorithmSuite.
 */
export const SignatureAlgorithmSuiteSchema: GenEnum<SignatureAlgorithmSuite> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 17);

/**
 * @generated from enum types.PluginStatusCode
 */
export enum PluginStatusCode {
  /**
   * UNKNOWN is the default value when the plugin has not reported its status yet.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * RUNNING means the plugin reports running successfully.
   *
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * OTHER_ERROR indicates that an otherwise-unspecified error has been encountered.
   *
   * @generated from enum value: OTHER_ERROR = 2;
   */
  OTHER_ERROR = 2,

  /**
   * UNAUTHORIZED indicates that plugin is not able to authenticate to the 3rd party API.
   * This could be a result of e.g. the user revoking the authorization on the API provider's side.
   *
   * @generated from enum value: UNAUTHORIZED = 3;
   */
  UNAUTHORIZED = 3,

  /**
   * SLACK_NOT_IN_CHANNEL is a Slack-specific status code that indicates
   * that the bot has not been invited to a channel that it is configured to post in.
   *
   * @generated from enum value: SLACK_NOT_IN_CHANNEL = 10;
   */
  SLACK_NOT_IN_CHANNEL = 10,
}

/**
 * Describes the enum types.PluginStatusCode.
 */
export const PluginStatusCodeSchema: GenEnum<PluginStatusCode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 18);

/**
 * OktaPluginSyncStatusCode indicates the possible states of an Okta
 * synchronization service.
 *
 * @generated from enum types.OktaPluginSyncStatusCode
 */
export enum OktaPluginSyncStatusCode {
  /**
   * OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED is the status code zero value,
   * indicating that the service has not yet reported a status code.
   *
   * @generated from enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS indicates that the service is running
   * without error
   *
   * @generated from enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR indicates that the service is currently
   * in an error state.
   *
   * @generated from enum value: OKTA_PLUGIN_SYNC_STATUS_CODE_ERROR = 2;
   */
  ERROR = 2,
}

/**
 * Describes the enum types.OktaPluginSyncStatusCode.
 */
export const OktaPluginSyncStatusCodeSchema: GenEnum<OktaPluginSyncStatusCode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 19);

/**
 * HeadlessAuthenticationState is a headless authentication state.
 *
 * @generated from enum types.HeadlessAuthenticationState
 */
export enum HeadlessAuthenticationState {
  /**
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * authentication pending.
   *
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_PENDING = 1;
   */
  PENDING = 1,

  /**
   * authentication denied.
   *
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_DENIED = 2;
   */
  DENIED = 2,

  /**
   * authentication approved.
   *
   * @generated from enum value: HEADLESS_AUTHENTICATION_STATE_APPROVED = 3;
   */
  APPROVED = 3,
}

/**
 * Describes the enum types.HeadlessAuthenticationState.
 */
export const HeadlessAuthenticationStateSchema: GenEnum<HeadlessAuthenticationState> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 20);

/**
 * InstallParamEnrollMode is the mode used to enroll the node into the cluster.
 *
 * @generated from enum types.InstallParamEnrollMode
 */
export enum InstallParamEnrollMode {
  /**
   * INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED uses the EICE mode for EC2 Matchers with an Integration and SCRIPT mode otherwise.
   *
   * @generated from enum value: INSTALL_PARAM_ENROLL_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * INSTALL_PARAM_ENROLL_MODE_SCRIPT runs a script on the target host.
   *
   * @generated from enum value: INSTALL_PARAM_ENROLL_MODE_SCRIPT = 1;
   */
  SCRIPT = 1,

  /**
   * INSTALL_PARAM_ENROLL_MODE_EICE uses EC2 Instance Connect Endpoint to access the node and DiscoveryService handles the heartbeat.
   * Only available for AWS EC2 instances.
   *
   * @generated from enum value: INSTALL_PARAM_ENROLL_MODE_EICE = 2;
   */
  EICE = 2,
}

/**
 * Describes the enum types.InstallParamEnrollMode.
 */
export const InstallParamEnrollModeSchema: GenEnum<InstallParamEnrollMode> = /*@__PURE__*/
  enumDesc(file_teleport_legacy_types_types, 21);

