// Copyright 2021-2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file teleport/legacy/client/proto/authservice.proto (package proto, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { AccessRequestAllowedPromotions, AccessRequestFilter, AccessRequestV3, AgentUpgradeSchedule, AlertAcknowledgement, AppServerOrSAMLIdPServiceProviderV1, AppServerV3, ClusterAlert, ConnectionDiagnosticTrace, DatabaseServerV3, DatabaseServiceV1, GithubConnectorV3, HeadlessAuthenticationState, KubernetesClusterV3, KubernetesServerV3, LockTarget, LockV2, MFADevice, OIDCConnectorV3, Participant, PluginDataV3, ProvisionTokenV2, Release, RequestState, RoleFilter, RoleV6, Rotation, SAMLConnectorV2, SAMLIdPServiceProviderV1, SAMLSessionData, SemaphoreV3, ServerV2, SessionState, SessionTrackerV1, SignatureAlgorithmSuite, SortBy, UserGroupV1, UserTokenUsage, UserV2, WatchKind, WebSessionV2, WebTokenV3, WindowsDesktopFilter, WindowsDesktopServiceV3, WindowsDesktopV3 } from "../../types/types_pb.js";
import { AttestationStatement } from "../../../attestation/v1/attestation_pb.js";
import { CredentialAssertion, CredentialAssertionResponse, CredentialCreation, CredentialCreationResponse } from "../../types/webauthn/webauthn_pb.js";
import { LabelValues, StringValues } from "../../types/wrappers/wrappers_pb.js";
import { OneOf } from "../../types/events/events_pb.js";
import { ChallengeExtensions } from "../../../mfa/v1/mfa_pb.js";
import { UsageEventOneOf } from "../../../usageevents/v1/usageevents_pb.js";

/**
 * ProductType is the type of product.
 *
 * @generated from enum proto.ProductType
 */
export enum ProductType {
  /**
   * @generated from enum value: PRODUCT_TYPE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * PRODUCT_TYPE_TEAM is Teleport Team product.
   *
   * @generated from enum value: PRODUCT_TYPE_TEAM = 1;
   */
  TEAM = 1,

  /**
   * PRODUCT_TYPE_EUB is Teleport Enterprise Usage Based product.
   *
   * @generated from enum value: PRODUCT_TYPE_EUB = 2;
   */
  EUB = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ProductType)
proto3.util.setEnumType(ProductType, "proto.ProductType", [
  { no: 0, name: "PRODUCT_TYPE_UNKNOWN" },
  { no: 1, name: "PRODUCT_TYPE_TEAM" },
  { no: 2, name: "PRODUCT_TYPE_EUB" },
]);

/**
 * SupportType if the type of support offered.
 *
 * @generated from enum proto.SupportType
 */
export enum SupportType {
  /**
   * @generated from enum value: SUPPORT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * SUPPORT_TYPE_FREE is the free tier support
   *
   * @generated from enum value: SUPPORT_TYPE_FREE = 1;
   */
  FREE = 1,

  /**
   * SUPPORT_TYPE_PREMIUM is the premium tier support
   *
   * @generated from enum value: SUPPORT_TYPE_PREMIUM = 2;
   */
  PREMIUM = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SupportType)
proto3.util.setEnumType(SupportType, "proto.SupportType", [
  { no: 0, name: "SUPPORT_TYPE_UNSPECIFIED" },
  { no: 1, name: "SUPPORT_TYPE_FREE" },
  { no: 2, name: "SUPPORT_TYPE_PREMIUM" },
]);

/**
 * DeviceType describes supported MFA device types.
 *
 * @generated from enum proto.DeviceType
 */
export enum DeviceType {
  /**
   * @generated from enum value: DEVICE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * TOTP is a Time-based One-Time Password device.
   *
   * @generated from enum value: DEVICE_TYPE_TOTP = 1;
   */
  TOTP = 1,

  /**
   * Webauthn is a device compatible with the Web Authentication
   * specification, registered via Webauthn APIs.
   * Supports various kinds of devices: U2F/CTAP1, CTAP2, platform
   * authenticators (Touch ID), etc.
   *
   * @generated from enum value: DEVICE_TYPE_WEBAUTHN = 3;
   */
  WEBAUTHN = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(DeviceType)
proto3.util.setEnumType(DeviceType, "proto.DeviceType", [
  { no: 0, name: "DEVICE_TYPE_UNSPECIFIED" },
  { no: 1, name: "DEVICE_TYPE_TOTP" },
  { no: 3, name: "DEVICE_TYPE_WEBAUTHN" },
]);

/**
 * @generated from enum proto.DeviceUsage
 */
export enum DeviceUsage {
  /**
   * @generated from enum value: DEVICE_USAGE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Device intended for MFA use, but not for passwordless.
   * Allows both FIDO and FIDO2 devices.
   * Resident keys not required.
   *
   * @generated from enum value: DEVICE_USAGE_MFA = 1;
   */
  MFA = 1,

  /**
   * Device intended for both MFA and passwordless.
   * Requires a FIDO2 device and takes a resident key slot.
   *
   * @generated from enum value: DEVICE_USAGE_PASSWORDLESS = 2;
   */
  PASSWORDLESS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DeviceUsage)
proto3.util.setEnumType(DeviceUsage, "proto.DeviceUsage", [
  { no: 0, name: "DEVICE_USAGE_UNSPECIFIED" },
  { no: 1, name: "DEVICE_USAGE_MFA" },
  { no: 2, name: "DEVICE_USAGE_PASSWORDLESS" },
]);

/**
 * MFARequired indicates if MFA is required to access a
 * resource.
 *
 * @generated from enum proto.MFARequired
 */
export enum MFARequired {
  /**
   * Indicates the client/server are either old and don't support
   * checking if MFA is required during the ceremony or that there
   * was a catastrophic error checking RBAC to determine if completing
   * an MFA ceremony will grant access to a resource.
   *
   * @generated from enum value: MFA_REQUIRED_UNSPECIFIED = 0;
   */
  MFA_REQUIRED_UNSPECIFIED = 0,

  /**
   * Completing an MFA ceremony will grant access to a resource.
   *
   * @generated from enum value: MFA_REQUIRED_YES = 1;
   */
  MFA_REQUIRED_YES = 1,

  /**
   * Completing an MFA ceremony will not grant access to a resource.
   *
   * @generated from enum value: MFA_REQUIRED_NO = 2;
   */
  MFA_REQUIRED_NO = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(MFARequired)
proto3.util.setEnumType(MFARequired, "proto.MFARequired", [
  { no: 0, name: "MFA_REQUIRED_UNSPECIFIED" },
  { no: 1, name: "MFA_REQUIRED_YES" },
  { no: 2, name: "MFA_REQUIRED_NO" },
]);

/**
 * Order specifies any ordering of some objects as returned in regards to some aspect
 * of said objects which may be trivially ordered such as a timestamp.
 *
 * @generated from enum proto.Order
 */
export enum Order {
  /**
   * @generated from enum value: DESCENDING = 0;
   */
  DESCENDING = 0,

  /**
   * @generated from enum value: ASCENDING = 1;
   */
  ASCENDING = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Order)
proto3.util.setEnumType(Order, "proto.Order", [
  { no: 0, name: "DESCENDING" },
  { no: 1, name: "ASCENDING" },
]);

/**
 * LabelUpdateKind is the type of service to update labels for.
 *
 * @generated from enum proto.LabelUpdateKind
 */
export enum LabelUpdateKind {
  /**
   * SSHServer is a label update for an SSH server.
   *
   * @generated from enum value: SSHServer = 0;
   */
  SSHServer = 0,

  /**
   * SSHServerCloudLabels is a label update for an SSH server coming from a
   * cloud provider.
   *
   * @generated from enum value: SSHServerCloudLabels = 1;
   */
  SSHServerCloudLabels = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(LabelUpdateKind)
proto3.util.setEnumType(LabelUpdateKind, "proto.LabelUpdateKind", [
  { no: 0, name: "SSHServer" },
  { no: 1, name: "SSHServerCloudLabels" },
]);

/**
 * AccessRequestSort determines access request sort index.
 *
 * @generated from enum proto.AccessRequestSort
 */
export enum AccessRequestSort {
  /**
   * DEFAULT sorts access requests by their native backend index. this is currently equivalent
   * to sorting by request ID, but that is subject to change.
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * CREATED sorts access requests by creation time (this is the sort index typically used in
   * user interfaces since most users are looking for recently-created requests).
   *
   * @generated from enum value: CREATED = 1;
   */
  CREATED = 1,

  /**
   * STATE sorts access requests by their state (PENDING, APPROVED, etc).
   *
   * @generated from enum value: STATE = 2;
   */
  STATE = 2,

  /**
   * USER sorts access requests by their creator's teleport username
   *
   * @generated from enum value: USER = 3;
   */
  USER = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AccessRequestSort)
proto3.util.setEnumType(AccessRequestSort, "proto.AccessRequestSort", [
  { no: 0, name: "DEFAULT" },
  { no: 1, name: "CREATED" },
  { no: 2, name: "STATE" },
  { no: 3, name: "USER" },
]);

/**
 * Watch specifies watch parameters
 *
 * @generated from message proto.Watch
 */
export class Watch extends Message<Watch> {
  /**
   * Kinds specifies object kinds to watch
   *
   * @generated from field: repeated types.WatchKind Kinds = 1;
   */
  Kinds: WatchKind[] = [];

  /**
   * @generated from field: bool AllowPartialSuccess = 2;
   */
  AllowPartialSuccess = false;

  constructor(data?: PartialMessage<Watch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.Watch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kinds", kind: "message", T: WatchKind, repeated: true },
    { no: 2, name: "AllowPartialSuccess", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Watch {
    return new Watch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Watch {
    return new Watch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Watch {
    return new Watch().fromJsonString(jsonString, options);
  }

  static equals(a: Watch | PlainMessage<Watch> | undefined, b: Watch | PlainMessage<Watch> | undefined): boolean {
    return proto3.util.equals(Watch, a, b);
  }
}

/**
 * HostCertsRequest specifies certificate-generation parameters
 * for a server.
 *
 * @generated from message proto.HostCertsRequest
 */
export class HostCertsRequest extends Message<HostCertsRequest> {
  /**
   * HostID is a unique ID of the host.
   *
   * @generated from field: string HostID = 1;
   */
  HostID = "";

  /**
   * NodeName is a user-friendly host name.
   *
   * @generated from field: string NodeName = 2;
   */
  NodeName = "";

  /**
   * Role is a system role assigned to the host.
   *
   * @generated from field: string Role = 3;
   */
  Role = "";

  /**
   * AdditionalPrincipals is a list of additional principals
   * to include in OpenSSH and X509 certificates
   *
   * @generated from field: repeated string AdditionalPrincipals = 4;
   */
  AdditionalPrincipals: string[] = [];

  /**
   * DNSNames is a list of DNS names to include in x509 certificates.
   *
   * @generated from field: repeated string DNSNames = 5;
   */
  DNSNames: string[] = [];

  /**
   * PublicTLSKey is a PEM encoded public key, which the auth server will use
   * to create a signed TLS certificate. This field is required.
   *
   * @generated from field: bytes PublicTLSKey = 6;
   */
  PublicTLSKey = new Uint8Array(0);

  /**
   * PublicSSHKey is a SSH encoded public key, which the auth server will use
   * to create a signed SSH certificate. This field is required.
   *
   * @generated from field: bytes PublicSSHKey = 7;
   */
  PublicSSHKey = new Uint8Array(0);

  /**
   * RemoteAddr is the IP address of the remote host requesting a certificate.
   * RemoteAddr is used to replace 0.0.0.0 in the list of additional principals.
   *
   * @generated from field: string RemoteAddr = 8;
   */
  RemoteAddr = "";

  /**
   * Rotation allows clients to send the certificate authority rotation state
   * expected by the client so that auth servers can avoid the situation when
   * clients request certs assuming one state and auth servers issue another.
   *
   * @generated from field: types.Rotation Rotation = 9;
   */
  Rotation?: Rotation;

  /**
   * NoCache is argument that only local callers can supply to bypass cache
   *
   * @generated from field: bool NoCache = 10;
   */
  NoCache = false;

  /**
   * SystemRoles is a list of system roles held by the host. Most host certs are
   * single-role and only specify the Role field. The SystemRoles field is only
   * currently used on Instance certs, which need to express all roles held by
   * the instance.
   *
   * @generated from field: repeated string SystemRoles = 11;
   */
  SystemRoles: string[] = [];

  /**
   * SystemRoleAssertionID is used by agents to prove that they have a given system role when
   * their credentials originate from multiple separate join tokens so that they can be issued
   * an instance certificate that encompasses all of their capabilities. This field will be
   * deprecated once we have a more comprehensive model for join token joining/replacement.
   *
   * @generated from field: string SystemRoleAssertionID = 13;
   */
  SystemRoleAssertionID = "";

  constructor(data?: PartialMessage<HostCertsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.HostCertsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "NodeName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "AdditionalPrincipals", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "DNSNames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "PublicTLSKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "PublicSSHKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "RemoteAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "Rotation", kind: "message", T: Rotation },
    { no: 10, name: "NoCache", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "SystemRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "SystemRoleAssertionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostCertsRequest {
    return new HostCertsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostCertsRequest {
    return new HostCertsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostCertsRequest {
    return new HostCertsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: HostCertsRequest | PlainMessage<HostCertsRequest> | undefined, b: HostCertsRequest | PlainMessage<HostCertsRequest> | undefined): boolean {
    return proto3.util.equals(HostCertsRequest, a, b);
  }
}

/**
 * OpenSSHCertRequest specifies certificate-generation parameters
 * for a certificates used to connect to Agentless nodes.
 *
 * @generated from message proto.OpenSSHCertRequest
 */
export class OpenSSHCertRequest extends Message<OpenSSHCertRequest> {
  /**
   * PublicKey is the public key to sign.
   *
   * @generated from field: bytes PublicKey = 2;
   */
  PublicKey = new Uint8Array(0);

  /**
   * TTL is the duration the certificate will be valid for.
   *
   * @generated from field: int64 TTL = 3;
   */
  TTL = protoInt64.zero;

  /**
   * Cluster is the Teleport cluster name the target node is connected to.
   *
   * @generated from field: string Cluster = 4;
   */
  Cluster = "";

  /**
   * User is the Teleport user the certificate will be generated for.
   *
   * @generated from field: types.UserV2 User = 5;
   */
  User?: UserV2;

  /**
   * Roles are the roles of the Teleport user the certificate will be
   * generated for.
   *
   * @generated from field: repeated types.RoleV6 Roles = 6;
   */
  Roles: RoleV6[] = [];

  constructor(data?: PartialMessage<OpenSSHCertRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.OpenSSHCertRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "TTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "Cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "User", kind: "message", T: UserV2 },
    { no: 6, name: "Roles", kind: "message", T: RoleV6, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenSSHCertRequest {
    return new OpenSSHCertRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenSSHCertRequest {
    return new OpenSSHCertRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenSSHCertRequest {
    return new OpenSSHCertRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OpenSSHCertRequest | PlainMessage<OpenSSHCertRequest> | undefined, b: OpenSSHCertRequest | PlainMessage<OpenSSHCertRequest> | undefined): boolean {
    return proto3.util.equals(OpenSSHCertRequest, a, b);
  }
}

/**
 * OpenSSHCert is a SSH certificate signed by OpenSSH CA.
 *
 * @generated from message proto.OpenSSHCert
 */
export class OpenSSHCert extends Message<OpenSSHCert> {
  /**
   * @generated from field: bytes Cert = 1;
   */
  Cert = new Uint8Array(0);

  constructor(data?: PartialMessage<OpenSSHCert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.OpenSSHCert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenSSHCert {
    return new OpenSSHCert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenSSHCert {
    return new OpenSSHCert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenSSHCert {
    return new OpenSSHCert().fromJsonString(jsonString, options);
  }

  static equals(a: OpenSSHCert | PlainMessage<OpenSSHCert> | undefined, b: OpenSSHCert | PlainMessage<OpenSSHCert> | undefined): boolean {
    return proto3.util.equals(OpenSSHCert, a, b);
  }
}

/**
 * UserCertRequest specifies certificate-generation parameters
 * for a user.
 *
 * @generated from message proto.UserCertsRequest
 */
export class UserCertsRequest extends Message<UserCertsRequest> {
  /**
   * PublicKey is a public key to be signed.
   *
   * Deprecated: Prefer SSHPublicKey and/or TLSPublicKey.
   *
   * @generated from field: bytes PublicKey = 1 [deprecated = true];
   * @deprecated
   */
  PublicKey = new Uint8Array(0);

  /**
   * Username of key owner.
   *
   * @generated from field: string Username = 2;
   */
  Username = "";

  /**
   * Expires is a desired time of the expiry of the certificate, could
   * be adjusted based on the permissions
   *
   * @generated from field: google.protobuf.Timestamp Expires = 3;
   */
  Expires?: Timestamp;

  /**
   * Format encodes the desired SSH Certificate format (either old ssh
   * compatibility
   * format to remove some metadata causing trouble with old SSH servers)
   * or standard SSH cert format with custom extensions
   *
   * @generated from field: string Format = 4;
   */
  Format = "";

  /**
   * RouteToCluster is an optional cluster name to add to the certificate,
   * so that requests originating with this certificate will be redirected
   * to this cluster
   *
   * @generated from field: string RouteToCluster = 5;
   */
  RouteToCluster = "";

  /**
   * AccessRequests is an optional list of request IDs indicating requests whose
   * escalated privileges should be added to the certificate.
   *
   * @generated from field: repeated string AccessRequests = 6;
   */
  AccessRequests: string[] = [];

  /**
   * KubernetesCluster specifies the target kubernetes cluster for TLS
   * identities. This can be empty on older Teleport clients.
   *
   * @generated from field: string KubernetesCluster = 7;
   */
  KubernetesCluster = "";

  /**
   * RouteToDatabase specifies the target database proxy name to encode into
   * certificate so database client requests are routed appropriately.
   *
   * @generated from field: proto.RouteToDatabase RouteToDatabase = 8;
   */
  RouteToDatabase?: RouteToDatabase;

  /**
   * NodeName is the name of the SSH node that this user certificate will be
   * scoped to.
   *
   * @generated from field: string NodeName = 9;
   */
  NodeName = "";

  /**
   * CertUsage limits the resulting user certificate to a single protocol.
   *
   * @generated from field: proto.UserCertsRequest.CertUsage Usage = 10;
   */
  Usage = UserCertsRequest_CertUsage.All;

  /**
   * RouteToApp specifies application to issue certificate for.
   *
   * @generated from field: proto.RouteToApp RouteToApp = 11;
   */
  RouteToApp?: RouteToApp;

  /**
   * RoleRequests specify an alternative set of named roles to apply to the
   * certificate, assuming the requestor is allowed to impersonate said roles
   * directly. An empty set of requests returns the user's normal set of
   * roles.
   *
   * @generated from field: repeated string RoleRequests = 12;
   */
  RoleRequests: string[] = [];

  /**
   * RouteToWindowsDesktop specifies the target windows desktop name to encode into
   * certificate so windows desktop client requests are routed appropriately.
   *
   * @generated from field: proto.RouteToWindowsDesktop RouteToWindowsDesktop = 13;
   */
  RouteToWindowsDesktop?: RouteToWindowsDesktop;

  /**
   * UseRoleRequests is used to ensure a certificate request is intended to
   * use role impersonation, even if the list of role requests is empty.
   *
   * @generated from field: bool UseRoleRequests = 14;
   */
  UseRoleRequests = false;

  /**
   * DropAccessRequests is an optional list of request IDs indicating requests
   * whose escalated privileges should be removed from the certificate.
   * IDs pointing at non-existent requests are ignored.
   *
   * If present, the roles and traits in the generated cert will be based on
   * the state of the user resource on the backend, active requests (not being
   * dropped) and new access requests specified through AccessRequests (if any).
   *
   * This means that technically sending UserCertsRequest with bogus IDs in
   * DropAccessRequests can be used to refresh the role list based on backend
   * state. A better long-term solution would be to add a dedicated field for
   * this to avoid sending bogus IDs.
   *
   * @generated from field: repeated string DropAccessRequests = 15;
   */
  DropAccessRequests: string[] = [];

  /**
   * ConnectionDiagnosticID is the ID of the ConnectionDiagnostic resource we should use to add
   * traces as we pass certain checkpoints.
   *
   * @generated from field: string ConnectionDiagnosticID = 16;
   */
  ConnectionDiagnosticID = "";

  /**
   * RequesterName identifies who sent the request.
   *
   * @generated from field: proto.UserCertsRequest.Requester RequesterName = 17;
   */
  RequesterName = UserCertsRequest_Requester.UNSPECIFIED;

  /**
   * MFAResponse is a response to a challenge from a user's MFA device.
   * An optional field, that when provided, the response will be validated
   * and the ID of the validated MFA device will be stored in the certificate.
   *
   * @generated from field: proto.MFAAuthenticateResponse MFAResponse = 18;
   */
  MFAResponse?: MFAAuthenticateResponse;

  /**
   * SSHLogin is the OS Login for the SSH session that the certificate will be used for.
   * This login is used when performing RBAC checks to determine if MFA is required
   * to access the resource.
   *
   * @generated from field: string SSHLogin = 19;
   */
  SSHLogin = "";

  /**
   * AttestationStatement is an attestation statement for the given public key.
   *
   * Deprecated: prefer SSHPublicKeyAttestationStatement and/or
   * TLSPublicKeyAttestationStatement.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement attestation_statement = 20 [deprecated = true];
   * @deprecated
   */
  attestationStatement?: AttestationStatement;

  /**
   * Purpose is the intended purpose of the certificates.
   *
   * @generated from field: proto.UserCertsRequest.CertPurpose Purpose = 21;
   */
  Purpose = UserCertsRequest_CertPurpose.UNSPECIFIED;

  /**
   * SSHPublicKey is a public key in SSH authorized_keys format, to be used as
   * the subject for the issued SSH certificate. If omitted, only a TLS cert
   * will be returned.
   *
   * @generated from field: bytes SSHPublicKey = 22;
   */
  SSHPublicKey = new Uint8Array(0);

  /**
   * TLSPublicKey is a public key in PEM-encoded PKCS#1 or PKIX format, to be used as
   * the subject for the issued TLS certificate. If omitted, only an SSH cert
   * will be returned.
   *
   * @generated from field: bytes TLSPublicKey = 23;
   */
  TLSPublicKey = new Uint8Array(0);

  /**
   * SSHPublicKeyAttestationStatement is an attestation statement for SSHPublicKey.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement SSHPublicKeyAttestationStatement = 25;
   */
  SSHPublicKeyAttestationStatement?: AttestationStatement;

  /**
   * TLSPublicKeyAttestationStatement is an attestation statement for TLSPublicKey.
   *
   * @generated from field: teleport.attestation.v1.AttestationStatement TLSPublicKeyAttestationStatement = 26;
   */
  TLSPublicKeyAttestationStatement?: AttestationStatement;

  constructor(data?: PartialMessage<UserCertsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UserCertsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Expires", kind: "message", T: Timestamp },
    { no: 4, name: "Format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "RouteToCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "AccessRequests", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "RouteToDatabase", kind: "message", T: RouteToDatabase },
    { no: 9, name: "NodeName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "Usage", kind: "enum", T: proto3.getEnumType(UserCertsRequest_CertUsage) },
    { no: 11, name: "RouteToApp", kind: "message", T: RouteToApp },
    { no: 12, name: "RoleRequests", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "RouteToWindowsDesktop", kind: "message", T: RouteToWindowsDesktop },
    { no: 14, name: "UseRoleRequests", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "DropAccessRequests", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 16, name: "ConnectionDiagnosticID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "RequesterName", kind: "enum", T: proto3.getEnumType(UserCertsRequest_Requester) },
    { no: 18, name: "MFAResponse", kind: "message", T: MFAAuthenticateResponse },
    { no: 19, name: "SSHLogin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "attestation_statement", kind: "message", T: AttestationStatement },
    { no: 21, name: "Purpose", kind: "enum", T: proto3.getEnumType(UserCertsRequest_CertPurpose) },
    { no: 22, name: "SSHPublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 23, name: "TLSPublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 25, name: "SSHPublicKeyAttestationStatement", kind: "message", T: AttestationStatement },
    { no: 26, name: "TLSPublicKeyAttestationStatement", kind: "message", T: AttestationStatement },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserCertsRequest {
    return new UserCertsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserCertsRequest {
    return new UserCertsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserCertsRequest {
    return new UserCertsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UserCertsRequest | PlainMessage<UserCertsRequest> | undefined, b: UserCertsRequest | PlainMessage<UserCertsRequest> | undefined): boolean {
    return proto3.util.equals(UserCertsRequest, a, b);
  }
}

/**
 * @generated from enum proto.UserCertsRequest.CertUsage
 */
export enum UserCertsRequest_CertUsage {
  /**
   * All means a request for both SSH and TLS certificates for the
   * overall user session. These certificates are not specific to any SSH
   * node, Kubernetes cluster, database or web app.
   *
   * @generated from enum value: All = 0;
   */
  All = 0,

  /**
   * SSH means a request for an SSH certificate for access to a specific
   * SSH node, as specified by NodeName.
   *
   * @generated from enum value: SSH = 1;
   */
  SSH = 1,

  /**
   * Kubernetes means a request for a TLS certificate for access to a
   * specific Kubernetes cluster, as specified by KubernetesCluster.
   *
   * @generated from enum value: Kubernetes = 2;
   */
  Kubernetes = 2,

  /**
   * Database means a request for a TLS certificate for access to a
   * specific database, as specified by RouteToDatabase.
   *
   * @generated from enum value: Database = 3;
   */
  Database = 3,

  /**
   * App means a request for a TLS certificate for access to a specific
   * web app, as specified by RouteToApp.
   *
   * @generated from enum value: App = 4;
   */
  App = 4,

  /**
   * WindowsDesktop means a request for a TLS certificate for access to a specific
   * windows desktop.
   *
   * @generated from enum value: WindowsDesktop = 5;
   */
  WindowsDesktop = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(UserCertsRequest_CertUsage)
proto3.util.setEnumType(UserCertsRequest_CertUsage, "proto.UserCertsRequest.CertUsage", [
  { no: 0, name: "All" },
  { no: 1, name: "SSH" },
  { no: 2, name: "Kubernetes" },
  { no: 3, name: "Database" },
  { no: 4, name: "App" },
  { no: 5, name: "WindowsDesktop" },
]);

/**
 * Requester is the name of the service that sent the request.
 *
 * @generated from enum proto.UserCertsRequest.Requester
 */
export enum UserCertsRequest_Requester {
  /**
   * UNSPECIFIED is set when the requester in unknown.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * TSH_DB_LOCAL_PROXY_TUNNEL is set when the request was sent by a tsh db local proxy tunnel.
   *
   * @generated from enum value: TSH_DB_LOCAL_PROXY_TUNNEL = 1;
   */
  TSH_DB_LOCAL_PROXY_TUNNEL = 1,

  /**
   * TSH_KUBE_LOCAL_PROXY is set when the request was sent by a tsh kube local proxy.
   *
   * @generated from enum value: TSH_KUBE_LOCAL_PROXY = 2;
   */
  TSH_KUBE_LOCAL_PROXY = 2,

  /**
   * TSH_KUBE_LOCAL_PROXY_HEADLESS is set when the request was sent by a tsh kube local proxy in headless mode.
   *
   * @generated from enum value: TSH_KUBE_LOCAL_PROXY_HEADLESS = 3;
   */
  TSH_KUBE_LOCAL_PROXY_HEADLESS = 3,

  /**
   * TSH_APP_LOCAL_PROXY is set when the request was sent by a tsh app local proxy.
   *
   * @generated from enum value: TSH_APP_LOCAL_PROXY = 4;
   */
  TSH_APP_LOCAL_PROXY = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(UserCertsRequest_Requester)
proto3.util.setEnumType(UserCertsRequest_Requester, "proto.UserCertsRequest.Requester", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "TSH_DB_LOCAL_PROXY_TUNNEL" },
  { no: 2, name: "TSH_KUBE_LOCAL_PROXY" },
  { no: 3, name: "TSH_KUBE_LOCAL_PROXY_HEADLESS" },
  { no: 4, name: "TSH_APP_LOCAL_PROXY" },
]);

/**
 * CertPurpose complements CertUsage by informing Teleport of the intended use
 * for the certificates.
 *
 * @generated from enum proto.UserCertsRequest.CertPurpose
 */
export enum UserCertsRequest_CertPurpose {
  /**
   * Purpose not specified.
   * Interpreted as CERT_PURPOSE_LOGIN_CERTS.
   *
   * @generated from enum value: CERT_PURPOSE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Generate login certificates, both SSH and TLS, as well as CA certs.
   *
   * @generated from enum value: CERT_PURPOSE_LOGIN_CERTS = 1;
   */
  LOGIN_CERTS = 1,

  /**
   * Generate single-user certificates, either SSH or TLS, depending on the
   * specified Usage.
   *
   * @generated from enum value: CERT_PURPOSE_SINGLE_USE_CERTS = 2;
   */
  SINGLE_USE_CERTS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UserCertsRequest_CertPurpose)
proto3.util.setEnumType(UserCertsRequest_CertPurpose, "proto.UserCertsRequest.CertPurpose", [
  { no: 0, name: "CERT_PURPOSE_UNSPECIFIED" },
  { no: 1, name: "CERT_PURPOSE_LOGIN_CERTS" },
  { no: 2, name: "CERT_PURPOSE_SINGLE_USE_CERTS" },
]);

/**
 * RouteToDatabase combines parameters for database service routing information.
 *
 * @generated from message proto.RouteToDatabase
 */
export class RouteToDatabase extends Message<RouteToDatabase> {
  /**
   * ServiceName is the Teleport database proxy service name the cert is for.
   *
   * @generated from field: string ServiceName = 1;
   */
  ServiceName = "";

  /**
   * Protocol is the type of the database the cert is for.
   *
   * @generated from field: string Protocol = 2;
   */
  Protocol = "";

  /**
   * Username is an optional database username to embed.
   *
   * @generated from field: string Username = 3;
   */
  Username = "";

  /**
   * Database is an optional database name to embed.
   *
   * @generated from field: string Database = 4;
   */
  Database = "";

  /**
   * Roles is an optional list of database roles to embed.
   *
   * @generated from field: repeated string Roles = 5;
   */
  Roles: string[] = [];

  constructor(data?: PartialMessage<RouteToDatabase>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RouteToDatabase";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServiceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteToDatabase {
    return new RouteToDatabase().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteToDatabase {
    return new RouteToDatabase().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteToDatabase {
    return new RouteToDatabase().fromJsonString(jsonString, options);
  }

  static equals(a: RouteToDatabase | PlainMessage<RouteToDatabase> | undefined, b: RouteToDatabase | PlainMessage<RouteToDatabase> | undefined): boolean {
    return proto3.util.equals(RouteToDatabase, a, b);
  }
}

/**
 * RouteToWindowsDesktop combines parameters for windows desktop routing information.
 *
 * @generated from message proto.RouteToWindowsDesktop
 */
export class RouteToWindowsDesktop extends Message<RouteToWindowsDesktop> {
  /**
   * WindowsDesktop is the Windows Desktop server name to embed.
   *
   * @generated from field: string WindowsDesktop = 1;
   */
  WindowsDesktop = "";

  /**
   * Login is the Windows desktop user login to embed.
   *
   * @generated from field: string Login = 2;
   */
  Login = "";

  constructor(data?: PartialMessage<RouteToWindowsDesktop>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RouteToWindowsDesktop";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "WindowsDesktop", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Login", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteToWindowsDesktop {
    return new RouteToWindowsDesktop().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteToWindowsDesktop {
    return new RouteToWindowsDesktop().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteToWindowsDesktop {
    return new RouteToWindowsDesktop().fromJsonString(jsonString, options);
  }

  static equals(a: RouteToWindowsDesktop | PlainMessage<RouteToWindowsDesktop> | undefined, b: RouteToWindowsDesktop | PlainMessage<RouteToWindowsDesktop> | undefined): boolean {
    return proto3.util.equals(RouteToWindowsDesktop, a, b);
  }
}

/**
 * RouteToApp contains parameters for application access certificate requests.
 *
 * @generated from message proto.RouteToApp
 */
export class RouteToApp extends Message<RouteToApp> {
  /**
   * Name is the application name certificate is being requested for.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * SessionID is the ID of the application session.
   * DEPRECATED: Automatically generated by server.
   * TODO (Joerger): DELETE IN v17.0.0
   *
   * @generated from field: string SessionID = 2 [deprecated = true];
   * @deprecated
   */
  SessionID = "";

  /**
   * PublicAddr is the application public address.
   *
   * @generated from field: string PublicAddr = 3;
   */
  PublicAddr = "";

  /**
   * ClusterName is the cluster where the application resides.
   *
   * @generated from field: string ClusterName = 4;
   */
  ClusterName = "";

  /**
   * AWSRoleARN is the AWS role to assume when accessing AWS API.
   *
   * @generated from field: string AWSRoleARN = 5;
   */
  AWSRoleARN = "";

  /**
   * AzureIdentity is the Azure identity to assume when accessing Azure API.
   *
   * @generated from field: string AzureIdentity = 6;
   */
  AzureIdentity = "";

  /**
   * GCPServiceAccount is the GCP service account to assume when accessing GCP API.
   *
   * @generated from field: string GCPServiceAccount = 7;
   */
  GCPServiceAccount = "";

  /**
   * URI is the URI of the app. This is the internal endpoint where the application is running and isn't user-facing.
   *
   * @generated from field: string URI = 8;
   */
  URI = "";

  constructor(data?: PartialMessage<RouteToApp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RouteToApp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "PublicAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "AWSRoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "AzureIdentity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "GCPServiceAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteToApp {
    return new RouteToApp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteToApp {
    return new RouteToApp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteToApp {
    return new RouteToApp().fromJsonString(jsonString, options);
  }

  static equals(a: RouteToApp | PlainMessage<RouteToApp> | undefined, b: RouteToApp | PlainMessage<RouteToApp> | undefined): boolean {
    return proto3.util.equals(RouteToApp, a, b);
  }
}

/**
 * GetUserRequest specifies parameters for the GetUser method.
 *
 * @generated from message proto.GetUserRequest
 */
export class GetUserRequest extends Message<GetUserRequest> {
  /**
   * Name is the name of the desired user.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * WithSecrets specifies whether to load associated secrets.
   *
   * @generated from field: bool WithSecrets = 2;
   */
  WithSecrets = false;

  constructor(data?: PartialMessage<GetUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "WithSecrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserRequest {
    return new GetUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserRequest {
    return new GetUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserRequest {
    return new GetUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserRequest | PlainMessage<GetUserRequest> | undefined, b: GetUserRequest | PlainMessage<GetUserRequest> | undefined): boolean {
    return proto3.util.equals(GetUserRequest, a, b);
  }
}

/**
 * GetUsersRequest specifies parameters for the GetUsers method.
 *
 * @generated from message proto.GetUsersRequest
 */
export class GetUsersRequest extends Message<GetUsersRequest> {
  /**
   * WithSecrets specifies whether to load associated secrets.
   *
   * @generated from field: bool WithSecrets = 1;
   */
  WithSecrets = false;

  constructor(data?: PartialMessage<GetUsersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetUsersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "WithSecrets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUsersRequest {
    return new GetUsersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUsersRequest {
    return new GetUsersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUsersRequest {
    return new GetUsersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUsersRequest | PlainMessage<GetUsersRequest> | undefined, b: GetUsersRequest | PlainMessage<GetUsersRequest> | undefined): boolean {
    return proto3.util.equals(GetUsersRequest, a, b);
  }
}

/**
 * ChangePasswordRequest specifies the parameters for the ChangePassword method.
 *
 * @generated from message proto.ChangePasswordRequest
 */
export class ChangePasswordRequest extends Message<ChangePasswordRequest> {
  /**
   * @generated from field: string User = 1;
   */
  User = "";

  /**
   * @generated from field: bytes OldPassword = 2;
   */
  OldPassword = new Uint8Array(0);

  /**
   * @generated from field: bytes NewPassword = 3;
   */
  NewPassword = new Uint8Array(0);

  /**
   * @generated from field: string SecondFactorToken = 4;
   */
  SecondFactorToken = "";

  /**
   * @generated from field: webauthn.CredentialAssertionResponse Webauthn = 5;
   */
  Webauthn?: CredentialAssertionResponse;

  constructor(data?: PartialMessage<ChangePasswordRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ChangePasswordRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "User", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "OldPassword", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "NewPassword", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "SecondFactorToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Webauthn", kind: "message", T: CredentialAssertionResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangePasswordRequest {
    return new ChangePasswordRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangePasswordRequest {
    return new ChangePasswordRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangePasswordRequest {
    return new ChangePasswordRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ChangePasswordRequest | PlainMessage<ChangePasswordRequest> | undefined, b: ChangePasswordRequest | PlainMessage<ChangePasswordRequest> | undefined): boolean {
    return proto3.util.equals(ChangePasswordRequest, a, b);
  }
}

/**
 * PluginDataSeq is a sequence of plugin data.
 *
 * @generated from message proto.PluginDataSeq
 */
export class PluginDataSeq extends Message<PluginDataSeq> {
  /**
   * @generated from field: repeated types.PluginDataV3 PluginData = 1;
   */
  PluginData: PluginDataV3[] = [];

  constructor(data?: PartialMessage<PluginDataSeq>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.PluginDataSeq";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "PluginData", kind: "message", T: PluginDataV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginDataSeq {
    return new PluginDataSeq().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginDataSeq {
    return new PluginDataSeq().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginDataSeq {
    return new PluginDataSeq().fromJsonString(jsonString, options);
  }

  static equals(a: PluginDataSeq | PlainMessage<PluginDataSeq> | undefined, b: PluginDataSeq | PlainMessage<PluginDataSeq> | undefined): boolean {
    return proto3.util.equals(PluginDataSeq, a, b);
  }
}

/**
 * RequestStateSetter encodes the parameters necessary to update the
 * state of a privilege escalation request.
 *
 * @generated from message proto.RequestStateSetter
 */
export class RequestStateSetter extends Message<RequestStateSetter> {
  /**
   * ID is the request ID being targeted
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  /**
   * State is the desired state to be set
   *
   * @generated from field: types.RequestState State = 2;
   */
  State = RequestState.NONE;

  /**
   * Delegator is an optional indicator of who delegated this
   * state update (used by plugins to indicate which user approved
   * or denied the request).
   *
   * @generated from field: string Delegator = 3;
   */
  Delegator = "";

  /**
   * Reason is an optional message indicating the reason for the
   * resolution (approval, denail , etc...).
   *
   * @generated from field: string Reason = 4;
   */
  Reason = "";

  /**
   * Annotations are key/value pairs received from plugins during request
   * resolution.  They are currently only used to provide additional logging
   * information.
   *
   * @generated from field: wrappers.LabelValues Annotations = 5;
   */
  Annotations?: LabelValues;

  /**
   * Roles, if present, overrides the existing set of roles associated
   * with the access request.
   *
   * @generated from field: repeated string Roles = 6;
   */
  Roles: string[] = [];

  /**
   * AssumeStartTime is the time the requested roles can be assumed.
   *
   * @generated from field: google.protobuf.Timestamp AssumeStartTime = 7;
   */
  AssumeStartTime?: Timestamp;

  constructor(data?: PartialMessage<RequestStateSetter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RequestStateSetter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "State", kind: "enum", T: proto3.getEnumType(RequestState) },
    { no: 3, name: "Delegator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Annotations", kind: "message", T: LabelValues },
    { no: 6, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "AssumeStartTime", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestStateSetter {
    return new RequestStateSetter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestStateSetter {
    return new RequestStateSetter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestStateSetter {
    return new RequestStateSetter().fromJsonString(jsonString, options);
  }

  static equals(a: RequestStateSetter | PlainMessage<RequestStateSetter> | undefined, b: RequestStateSetter | PlainMessage<RequestStateSetter> | undefined): boolean {
    return proto3.util.equals(RequestStateSetter, a, b);
  }
}

/**
 * RequestID is the unique identifier of an access request.
 *
 * @generated from message proto.RequestID
 */
export class RequestID extends Message<RequestID> {
  /**
   * @generated from field: string ID = 1;
   */
  ID = "";

  constructor(data?: PartialMessage<RequestID>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RequestID";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestID {
    return new RequestID().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestID {
    return new RequestID().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestID {
    return new RequestID().fromJsonString(jsonString, options);
  }

  static equals(a: RequestID | PlainMessage<RequestID> | undefined, b: RequestID | PlainMessage<RequestID> | undefined): boolean {
    return proto3.util.equals(RequestID, a, b);
  }
}

/**
 * GetResetPasswordTokenRequest is a request to get a reset password token.
 *
 * @generated from message proto.GetResetPasswordTokenRequest
 */
export class GetResetPasswordTokenRequest extends Message<GetResetPasswordTokenRequest> {
  /**
   * @generated from field: string TokenID = 1;
   */
  TokenID = "";

  constructor(data?: PartialMessage<GetResetPasswordTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetResetPasswordTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetResetPasswordTokenRequest {
    return new GetResetPasswordTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetResetPasswordTokenRequest {
    return new GetResetPasswordTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetResetPasswordTokenRequest {
    return new GetResetPasswordTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetResetPasswordTokenRequest | PlainMessage<GetResetPasswordTokenRequest> | undefined, b: GetResetPasswordTokenRequest | PlainMessage<GetResetPasswordTokenRequest> | undefined): boolean {
    return proto3.util.equals(GetResetPasswordTokenRequest, a, b);
  }
}

/**
 * CreateResetPasswordTokenRequest is a request to create a reset password token.
 *
 * @generated from message proto.CreateResetPasswordTokenRequest
 */
export class CreateResetPasswordTokenRequest extends Message<CreateResetPasswordTokenRequest> {
  /**
   * Name is the user name.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Type is a token type.
   *
   * @generated from field: string Type = 2;
   */
  Type = "";

  /**
   * TTL specifies how long the generated token is valid for.
   *
   * @generated from field: int64 TTL = 3;
   */
  TTL = protoInt64.zero;

  constructor(data?: PartialMessage<CreateResetPasswordTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateResetPasswordTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateResetPasswordTokenRequest {
    return new CreateResetPasswordTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateResetPasswordTokenRequest {
    return new CreateResetPasswordTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateResetPasswordTokenRequest {
    return new CreateResetPasswordTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateResetPasswordTokenRequest | PlainMessage<CreateResetPasswordTokenRequest> | undefined, b: CreateResetPasswordTokenRequest | PlainMessage<CreateResetPasswordTokenRequest> | undefined): boolean {
    return proto3.util.equals(CreateResetPasswordTokenRequest, a, b);
  }
}

/**
 * RenewableCertsRequest is a request to generate a first set of renewable
 * certificates from a bot join token.
 *
 * @generated from message proto.RenewableCertsRequest
 */
export class RenewableCertsRequest extends Message<RenewableCertsRequest> {
  /**
   * Token is a bot join token.
   *
   * @generated from field: string Token = 1;
   */
  Token = "";

  /**
   * PublicKey is a public key to be signed.
   *
   * @generated from field: bytes PublicKey = 2;
   */
  PublicKey = new Uint8Array(0);

  constructor(data?: PartialMessage<RenewableCertsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RenewableCertsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "PublicKey", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RenewableCertsRequest {
    return new RenewableCertsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RenewableCertsRequest {
    return new RenewableCertsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RenewableCertsRequest {
    return new RenewableCertsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RenewableCertsRequest | PlainMessage<RenewableCertsRequest> | undefined, b: RenewableCertsRequest | PlainMessage<RenewableCertsRequest> | undefined): boolean {
    return proto3.util.equals(RenewableCertsRequest, a, b);
  }
}

/**
 * PingRequest is the input value for the Ping method.
 *
 * Ping method currently takes no parameters
 *
 * @generated from message proto.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PingRequest | PlainMessage<PingRequest> | undefined, b: PingRequest | PlainMessage<PingRequest> | undefined): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * PingResponse contains data about the teleport auth server.
 *
 * @generated from message proto.PingResponse
 */
export class PingResponse extends Message<PingResponse> {
  /**
   * ClusterName is the name of the teleport cluster.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * ServerVersion is the version of the auth server.
   *
   * @generated from field: string ServerVersion = 2;
   */
  ServerVersion = "";

  /**
   * ServerFeatures are the features supported by the auth server.
   *
   * @generated from field: proto.Features ServerFeatures = 3;
   */
  ServerFeatures?: Features;

  /**
   * ProxyPublicAddr is the server's public proxy address.
   *
   * @generated from field: string ProxyPublicAddr = 4;
   */
  ProxyPublicAddr = "";

  /**
   * IsBoring signals whether or not the server was compiled with BoringCrypto.
   *
   * @generated from field: bool IsBoring = 5;
   */
  IsBoring = false;

  /**
   * RemoteAddr is the client peer addr as seen from the auth server (used to assist
   * instances in guessing their external IP when none is configured).
   *
   * @generated from field: string RemoteAddr = 7;
   */
  RemoteAddr = "";

  /**
   * LoadAllCAs signals whether or not tsh should load all CAs when trying
   * to ssh into a node.
   *
   * @generated from field: bool LoadAllCAs = 8;
   */
  LoadAllCAs = false;

  /**
   * SignatureAlgorithmSuite is the configured signature algorithm suite for the cluster.
   *
   * @generated from field: types.SignatureAlgorithmSuite signature_algorithm_suite = 9;
   */
  signatureAlgorithmSuite = SignatureAlgorithmSuite.UNSPECIFIED;

  constructor(data?: PartialMessage<PingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.PingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ServerVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ServerFeatures", kind: "message", T: Features },
    { no: 4, name: "ProxyPublicAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "IsBoring", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "RemoteAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "LoadAllCAs", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "signature_algorithm_suite", kind: "enum", T: proto3.getEnumType(SignatureAlgorithmSuite) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingResponse {
    return new PingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingResponse {
    return new PingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PingResponse | PlainMessage<PingResponse> | undefined, b: PingResponse | PlainMessage<PingResponse> | undefined): boolean {
    return proto3.util.equals(PingResponse, a, b);
  }
}

/**
 * Features are auth server features.
 *
 * @generated from message proto.Features
 */
export class Features extends Message<Features> {
  /**
   * Kubernetes enables Kubernetes Access product
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool Kubernetes = 1;
   */
  Kubernetes = false;

  /**
   * App enables Application Access product
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool App = 2;
   */
  App = false;

  /**
   * DB enables database access product
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool DB = 3;
   */
  DB = false;

  /**
   * OIDC enables OIDC connectors
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool OIDC = 4;
   */
  OIDC = false;

  /**
   * SAML enables SAML connectors
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool SAML = 5;
   */
  SAML = false;

  /**
   * AccessControls enables FIPS access controls
   *
   * @generated from field: bool AccessControls = 6;
   */
  AccessControls = false;

  /**
   * AdvancedAccessWorkflows is currently set to the value of the Cloud AccessRequests entitlement
   *
   * @generated from field: bool AdvancedAccessWorkflows = 7;
   */
  AdvancedAccessWorkflows = false;

  /**
   * Cloud enables some cloud-related features
   *
   * @generated from field: bool Cloud = 8;
   */
  Cloud = false;

  /**
   * HSM enables PKCS#11 HSM support
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool HSM = 9;
   */
  HSM = false;

  /**
   * Desktop enables desktop access product
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool Desktop = 10;
   */
  Desktop = false;

  /**
   * RecoveryCodes enables recovery codes
   *
   * @generated from field: bool RecoveryCodes = 14;
   */
  RecoveryCodes = false;

  /**
   * Plugins enables hosted plugins
   *
   * @generated from field: bool Plugins = 15;
   */
  Plugins = false;

  /**
   * AutomaticUpgrades enables Automatic Upgrades for the agents/services.
   *
   * @generated from field: bool AutomaticUpgrades = 16;
   */
  AutomaticUpgrades = false;

  /**
   * IsUsageBased enables some usage-based billing features
   *
   * @generated from field: bool IsUsageBased = 17;
   */
  IsUsageBased = false;

  /**
   * Assist enables the Assistant feature
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool Assist = 18;
   */
  Assist = false;

  /**
   * DeviceTrust holds its namesake feature settings.
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: proto.DeviceTrustFeature DeviceTrust = 19;
   */
  DeviceTrust?: DeviceTrustFeature;

  /**
   * FeatureHiding enables hiding features from being discoverable for users who don't have the necessary permissions.
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool FeatureHiding = 20;
   */
  FeatureHiding = false;

  /**
   * AccessRequests holds its namesake feature settings.
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: proto.AccessRequestsFeature AccessRequests = 21;
   */
  AccessRequests?: AccessRequestsFeature;

  /**
   * CustomTheme holds the name of WebUI custom theme.
   *
   * @generated from field: string CustomTheme = 22;
   */
  CustomTheme = "";

  /**
   * IdentityGovernance indicates whether IGS related features are enabled:
   * access list, access request, access monitoring, device trust.
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool IdentityGovernance = 23;
   */
  IdentityGovernance = false;

  /**
   * AccessGraph enables the usage of access graph.
   * NOTE: this is a legacy flag that is currently used to signal
   * that Access Graph integration is *enabled* on a cluster.
   * *Access* to the feature is gated on the `Policy` flag.
   * TODO(justinas): remove this field once "TAG enabled" status is moved to a resource in the backend.
   *
   * @generated from field: bool AccessGraph = 24;
   */
  AccessGraph = false;

  /**
   * AccessListFeature holds its namesake feature settings.
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: proto.AccessListFeature AccessList = 25;
   */
  AccessList?: AccessListFeature;

  /**
   * AccessMonitoringFeature holds its namesake feature settings.
   * Deprecated remove in v18; leverage entitlements for access and AccessMonitoringConfigured for enabled
   *
   * @generated from field: proto.AccessMonitoringFeature AccessMonitoring = 26;
   */
  AccessMonitoring?: AccessMonitoringFeature;

  /**
   * ProductType describes the product being used.
   *
   * @generated from field: proto.ProductType ProductType = 27;
   */
  ProductType = ProductType.UNKNOWN;

  /**
   * Policy enables the Teleport Policy feature set.
   * At the time of writing, this includes Teleport Access Graph (TAG).
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: proto.PolicyFeature Policy = 28;
   */
  Policy?: PolicyFeature;

  /**
   * Questionnaire indicates whether cluster users should get an onboarding questionnaire
   *
   * @generated from field: bool Questionnaire = 29;
   */
  Questionnaire = false;

  /**
   * IsStripeManaged indicates if the cluster billing is managed via Stripe
   *
   * @generated from field: bool IsStripeManaged = 30;
   */
  IsStripeManaged = false;

  /**
   * ExternalAuditStorage indicates whether the EAS feature is enabled in the cluster.
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool ExternalAuditStorage = 31;
   */
  ExternalAuditStorage = false;

  /**
   * SupportType indicates the type of the customer's support
   *
   * @generated from field: proto.SupportType SupportType = 32;
   */
  SupportType = SupportType.UNSPECIFIED;

  /**
   * JoinActiveSessions indicates whether joining active sessions via web UI is enabled
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool JoinActiveSessions = 33;
   */
  JoinActiveSessions = false;

  /**
   * MobileDeviceManagement indicates whether endpoint management (like Jamf Plugin) can be used in the cluster
   * Deprecated remove in v18; leverage entitlements
   *
   * @generated from field: bool MobileDeviceManagement = 34;
   */
  MobileDeviceManagement = false;

  /**
   * entitlements define a customers access to a specific features
   *
   * @generated from field: map<string, proto.EntitlementInfo> entitlements = 35;
   */
  entitlements: { [key: string]: EntitlementInfo } = {};

  /**
   * AccessMonitoringConfigured contributes to the enablement of access monitoring.
   * NOTE: this flag is used to signal that Access Monitoring is *enabled* on a cluster.
   * *Access* to the feature is gated on the `AccessMonitoring` entitlement.
   *
   * @generated from field: bool AccessMonitoringConfigured = 36;
   */
  AccessMonitoringConfigured = false;

  constructor(data?: PartialMessage<Features>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.Features";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kubernetes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "App", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "DB", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "OIDC", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "SAML", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "AccessControls", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "AdvancedAccessWorkflows", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "Cloud", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "HSM", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "Desktop", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "RecoveryCodes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "Plugins", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "AutomaticUpgrades", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "IsUsageBased", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "Assist", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "DeviceTrust", kind: "message", T: DeviceTrustFeature },
    { no: 20, name: "FeatureHiding", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 21, name: "AccessRequests", kind: "message", T: AccessRequestsFeature },
    { no: 22, name: "CustomTheme", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "IdentityGovernance", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 24, name: "AccessGraph", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 25, name: "AccessList", kind: "message", T: AccessListFeature },
    { no: 26, name: "AccessMonitoring", kind: "message", T: AccessMonitoringFeature },
    { no: 27, name: "ProductType", kind: "enum", T: proto3.getEnumType(ProductType) },
    { no: 28, name: "Policy", kind: "message", T: PolicyFeature },
    { no: 29, name: "Questionnaire", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 30, name: "IsStripeManaged", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 31, name: "ExternalAuditStorage", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 32, name: "SupportType", kind: "enum", T: proto3.getEnumType(SupportType) },
    { no: 33, name: "JoinActiveSessions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 34, name: "MobileDeviceManagement", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 35, name: "entitlements", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: EntitlementInfo} },
    { no: 36, name: "AccessMonitoringConfigured", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Features {
    return new Features().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Features {
    return new Features().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Features {
    return new Features().fromJsonString(jsonString, options);
  }

  static equals(a: Features | PlainMessage<Features> | undefined, b: Features | PlainMessage<Features> | undefined): boolean {
    return proto3.util.equals(Features, a, b);
  }
}

/**
 * EntitlementInfo is the state and limits of a particular entitlement
 *
 * @generated from message proto.EntitlementInfo
 */
export class EntitlementInfo extends Message<EntitlementInfo> {
  /**
   * enabled indicates the feature is 'on' if true
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * limit indicates the allotted amount of use when limited
   *
   * @generated from field: int32 limit = 2;
   */
  limit = 0;

  constructor(data?: PartialMessage<EntitlementInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.EntitlementInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntitlementInfo {
    return new EntitlementInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntitlementInfo {
    return new EntitlementInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntitlementInfo {
    return new EntitlementInfo().fromJsonString(jsonString, options);
  }

  static equals(a: EntitlementInfo | PlainMessage<EntitlementInfo> | undefined, b: EntitlementInfo | PlainMessage<EntitlementInfo> | undefined): boolean {
    return proto3.util.equals(EntitlementInfo, a, b);
  }
}

/**
 * DeviceTrustFeature holds the Device Trust feature general and usage-based
 * settings.
 * Limits have no affect if [Features.IdentityGovernance] is enabled.
 *
 * @generated from message proto.DeviceTrustFeature
 */
export class DeviceTrustFeature extends Message<DeviceTrustFeature> {
  /**
   * Currently this flag is to gate actions from OSS clusters.
   *
   * Determining support for device trust is currently determined by:
   *   1) Enterprise + [Features.IdentityGovernanceSecurity] == true, new flag
   *   introduced with Enterprise Usage Based (EUB) product.
   *   2) Enterprise + [Features.IsUsageBasedBilling] == false, legacy support
   *   where before EUB, it was unlimited.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Usage-based limit for the number of registered/enrolled devices, at the
   * implementation's discretion.
   *
   * @generated from field: int32 devices_usage_limit = 2;
   */
  devicesUsageLimit = 0;

  constructor(data?: PartialMessage<DeviceTrustFeature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeviceTrustFeature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "devices_usage_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceTrustFeature {
    return new DeviceTrustFeature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceTrustFeature {
    return new DeviceTrustFeature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceTrustFeature {
    return new DeviceTrustFeature().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceTrustFeature | PlainMessage<DeviceTrustFeature> | undefined, b: DeviceTrustFeature | PlainMessage<DeviceTrustFeature> | undefined): boolean {
    return proto3.util.equals(DeviceTrustFeature, a, b);
  }
}

/**
 * AccessRequestsFeature holds the AccessRequest feature general and usage-based
 * settings.
 * Limits have no affect if [Features.IdentityGovernance] is enabled.
 *
 * @generated from message proto.AccessRequestsFeature
 */
export class AccessRequestsFeature extends Message<AccessRequestsFeature> {
  /**
   * Usage-based limit for the number of limit for the number of
   * access requests created in a calendar month.
   *
   * @generated from field: int32 monthly_request_limit = 1;
   */
  monthlyRequestLimit = 0;

  constructor(data?: PartialMessage<AccessRequestsFeature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AccessRequestsFeature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "monthly_request_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestsFeature {
    return new AccessRequestsFeature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestsFeature {
    return new AccessRequestsFeature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestsFeature {
    return new AccessRequestsFeature().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestsFeature | PlainMessage<AccessRequestsFeature> | undefined, b: AccessRequestsFeature | PlainMessage<AccessRequestsFeature> | undefined): boolean {
    return proto3.util.equals(AccessRequestsFeature, a, b);
  }
}

/**
 * AccessListFeature holds the Access List feature settings.
 * Limits have no affect if [Features.IdentityGovernance] is enabled.
 *
 * @generated from message proto.AccessListFeature
 */
export class AccessListFeature extends Message<AccessListFeature> {
  /**
   * Limit for the number of access list creatable when feature is
   * not enabled.
   *
   * @generated from field: int32 create_limit = 1;
   */
  createLimit = 0;

  constructor(data?: PartialMessage<AccessListFeature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AccessListFeature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "create_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListFeature {
    return new AccessListFeature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListFeature {
    return new AccessListFeature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListFeature {
    return new AccessListFeature().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListFeature | PlainMessage<AccessListFeature> | undefined, b: AccessListFeature | PlainMessage<AccessListFeature> | undefined): boolean {
    return proto3.util.equals(AccessListFeature, a, b);
  }
}

/**
 * AccessMonitoringFeature holds the Access Monitoring feature settings.
 * Limits have no affect if [Features.IdentityGovernance] is enabled.
 *
 * @generated from message proto.AccessMonitoringFeature
 */
export class AccessMonitoringFeature extends Message<AccessMonitoringFeature> {
  /**
   * True if enabled in the auth service config: [auth_service.access_monitoring.enabled].
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Defines the max number of days to include in an access report.
   *
   * @generated from field: int32 max_report_range_limit = 2;
   */
  maxReportRangeLimit = 0;

  constructor(data?: PartialMessage<AccessMonitoringFeature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AccessMonitoringFeature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "max_report_range_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessMonitoringFeature {
    return new AccessMonitoringFeature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessMonitoringFeature {
    return new AccessMonitoringFeature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessMonitoringFeature {
    return new AccessMonitoringFeature().fromJsonString(jsonString, options);
  }

  static equals(a: AccessMonitoringFeature | PlainMessage<AccessMonitoringFeature> | undefined, b: AccessMonitoringFeature | PlainMessage<AccessMonitoringFeature> | undefined): boolean {
    return proto3.util.equals(AccessMonitoringFeature, a, b);
  }
}

/**
 * PolicyFeature holds the Teleport Policy feature set settings.
 *
 * @generated from message proto.PolicyFeature
 */
export class PolicyFeature extends Message<PolicyFeature> {
  /**
   * True if Teleport Policy is enabled in the license.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  constructor(data?: PartialMessage<PolicyFeature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.PolicyFeature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PolicyFeature {
    return new PolicyFeature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PolicyFeature {
    return new PolicyFeature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PolicyFeature {
    return new PolicyFeature().fromJsonString(jsonString, options);
  }

  static equals(a: PolicyFeature | PlainMessage<PolicyFeature> | undefined, b: PolicyFeature | PlainMessage<PolicyFeature> | undefined): boolean {
    return proto3.util.equals(PolicyFeature, a, b);
  }
}

/**
 * DeleteUserRequest is the input value for the DeleteUser method.
 *
 * @generated from message proto.DeleteUserRequest
 */
export class DeleteUserRequest extends Message<DeleteUserRequest> {
  /**
   * Name is the user name to delete.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteUserRequest {
    return new DeleteUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteUserRequest {
    return new DeleteUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteUserRequest {
    return new DeleteUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteUserRequest | PlainMessage<DeleteUserRequest> | undefined, b: DeleteUserRequest | PlainMessage<DeleteUserRequest> | undefined): boolean {
    return proto3.util.equals(DeleteUserRequest, a, b);
  }
}

/**
 * Semaphores is a sequence of Semaphore resources.
 *
 * @generated from message proto.Semaphores
 */
export class Semaphores extends Message<Semaphores> {
  /**
   * @generated from field: repeated types.SemaphoreV3 Semaphores = 1;
   */
  Semaphores: SemaphoreV3[] = [];

  constructor(data?: PartialMessage<Semaphores>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.Semaphores";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Semaphores", kind: "message", T: SemaphoreV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Semaphores {
    return new Semaphores().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Semaphores {
    return new Semaphores().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Semaphores {
    return new Semaphores().fromJsonString(jsonString, options);
  }

  static equals(a: Semaphores | PlainMessage<Semaphores> | undefined, b: Semaphores | PlainMessage<Semaphores> | undefined): boolean {
    return proto3.util.equals(Semaphores, a, b);
  }
}

/**
 * AuditStreamRequest contains stream request - event or stream control request
 *
 * @generated from message proto.AuditStreamRequest
 */
export class AuditStreamRequest extends Message<AuditStreamRequest> {
  /**
   * Request is either stream request - create, resume or complete stream
   * or event submitted as a part of the stream
   *
   * @generated from oneof proto.AuditStreamRequest.Request
   */
  Request: {
    /**
     * CreateStream creates the stream for session ID
     * should be the first message sent to the stream
     *
     * @generated from field: proto.CreateStream CreateStream = 1;
     */
    value: CreateStream;
    case: "CreateStream";
  } | {
    /**
     * ResumeStream resumes existing stream, should be the
     * first message sent to the stream
     *
     * @generated from field: proto.ResumeStream ResumeStream = 2;
     */
    value: ResumeStream;
    case: "ResumeStream";
  } | {
    /**
     * CompleteStream completes the stream
     *
     * @generated from field: proto.CompleteStream CompleteStream = 3;
     */
    value: CompleteStream;
    case: "CompleteStream";
  } | {
    /**
     * FlushAndClose flushes and closes the stream
     *
     * @generated from field: proto.FlushAndCloseStream FlushAndCloseStream = 4;
     */
    value: FlushAndCloseStream;
    case: "FlushAndCloseStream";
  } | {
    /**
     * Event contains the stream event
     *
     * @generated from field: events.OneOf Event = 5;
     */
    value: OneOf;
    case: "Event";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AuditStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AuditStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CreateStream", kind: "message", T: CreateStream, oneof: "Request" },
    { no: 2, name: "ResumeStream", kind: "message", T: ResumeStream, oneof: "Request" },
    { no: 3, name: "CompleteStream", kind: "message", T: CompleteStream, oneof: "Request" },
    { no: 4, name: "FlushAndCloseStream", kind: "message", T: FlushAndCloseStream, oneof: "Request" },
    { no: 5, name: "Event", kind: "message", T: OneOf, oneof: "Request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuditStreamRequest {
    return new AuditStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuditStreamRequest {
    return new AuditStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuditStreamRequest {
    return new AuditStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AuditStreamRequest | PlainMessage<AuditStreamRequest> | undefined, b: AuditStreamRequest | PlainMessage<AuditStreamRequest> | undefined): boolean {
    return proto3.util.equals(AuditStreamRequest, a, b);
  }
}

/**
 * AuditStreamStatus returns audit stream status
 * with corresponding upload ID
 *
 * @generated from message proto.AuditStreamStatus
 */
export class AuditStreamStatus extends Message<AuditStreamStatus> {
  /**
   * UploadID is upload ID associated with the stream,
   * can be used to resume the stream
   *
   * @generated from field: string UploadID = 1;
   */
  UploadID = "";

  constructor(data?: PartialMessage<AuditStreamStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AuditStreamStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UploadID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuditStreamStatus {
    return new AuditStreamStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuditStreamStatus {
    return new AuditStreamStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuditStreamStatus {
    return new AuditStreamStatus().fromJsonString(jsonString, options);
  }

  static equals(a: AuditStreamStatus | PlainMessage<AuditStreamStatus> | undefined, b: AuditStreamStatus | PlainMessage<AuditStreamStatus> | undefined): boolean {
    return proto3.util.equals(AuditStreamStatus, a, b);
  }
}

/**
 * CreateStream creates stream for a new session ID
 *
 * @generated from message proto.CreateStream
 */
export class CreateStream extends Message<CreateStream> {
  /**
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<CreateStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateStream {
    return new CreateStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateStream {
    return new CreateStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateStream {
    return new CreateStream().fromJsonString(jsonString, options);
  }

  static equals(a: CreateStream | PlainMessage<CreateStream> | undefined, b: CreateStream | PlainMessage<CreateStream> | undefined): boolean {
    return proto3.util.equals(CreateStream, a, b);
  }
}

/**
 * ResumeStream resumes stream that was previously created
 *
 * @generated from message proto.ResumeStream
 */
export class ResumeStream extends Message<ResumeStream> {
  /**
   * SessionID is a session ID of the stream
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  /**
   * UploadID is upload ID to resume
   *
   * @generated from field: string UploadID = 2;
   */
  UploadID = "";

  constructor(data?: PartialMessage<ResumeStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ResumeStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "UploadID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResumeStream {
    return new ResumeStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResumeStream {
    return new ResumeStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResumeStream {
    return new ResumeStream().fromJsonString(jsonString, options);
  }

  static equals(a: ResumeStream | PlainMessage<ResumeStream> | undefined, b: ResumeStream | PlainMessage<ResumeStream> | undefined): boolean {
    return proto3.util.equals(ResumeStream, a, b);
  }
}

/**
 * CompleteStream completes the stream
 * and uploads it to the session server
 *
 * @generated from message proto.CompleteStream
 */
export class CompleteStream extends Message<CompleteStream> {
  constructor(data?: PartialMessage<CompleteStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CompleteStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompleteStream {
    return new CompleteStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompleteStream {
    return new CompleteStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompleteStream {
    return new CompleteStream().fromJsonString(jsonString, options);
  }

  static equals(a: CompleteStream | PlainMessage<CompleteStream> | undefined, b: CompleteStream | PlainMessage<CompleteStream> | undefined): boolean {
    return proto3.util.equals(CompleteStream, a, b);
  }
}

/**
 * FlushAndCloseStream flushes the stream data and closes the stream
 *
 * @generated from message proto.FlushAndCloseStream
 */
export class FlushAndCloseStream extends Message<FlushAndCloseStream> {
  constructor(data?: PartialMessage<FlushAndCloseStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.FlushAndCloseStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlushAndCloseStream {
    return new FlushAndCloseStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlushAndCloseStream {
    return new FlushAndCloseStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlushAndCloseStream {
    return new FlushAndCloseStream().fromJsonString(jsonString, options);
  }

  static equals(a: FlushAndCloseStream | PlainMessage<FlushAndCloseStream> | undefined, b: FlushAndCloseStream | PlainMessage<FlushAndCloseStream> | undefined): boolean {
    return proto3.util.equals(FlushAndCloseStream, a, b);
  }
}

/**
 * UpsertApplicationServerRequest upserts an app server.
 *
 * @generated from message proto.UpsertApplicationServerRequest
 */
export class UpsertApplicationServerRequest extends Message<UpsertApplicationServerRequest> {
  /**
   * Server is an app server resource to register.
   *
   * @generated from field: types.AppServerV3 Server = 1;
   */
  Server?: AppServerV3;

  constructor(data?: PartialMessage<UpsertApplicationServerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertApplicationServerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Server", kind: "message", T: AppServerV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertApplicationServerRequest {
    return new UpsertApplicationServerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertApplicationServerRequest {
    return new UpsertApplicationServerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertApplicationServerRequest {
    return new UpsertApplicationServerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertApplicationServerRequest | PlainMessage<UpsertApplicationServerRequest> | undefined, b: UpsertApplicationServerRequest | PlainMessage<UpsertApplicationServerRequest> | undefined): boolean {
    return proto3.util.equals(UpsertApplicationServerRequest, a, b);
  }
}

/**
 * DeleteApplicationServerRequest is a request to delete an app server.
 *
 * @generated from message proto.DeleteApplicationServerRequest
 */
export class DeleteApplicationServerRequest extends Message<DeleteApplicationServerRequest> {
  /**
   * Namespace is the app server namespace.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace = "";

  /**
   * HostID is the app server host uuid.
   *
   * @generated from field: string HostID = 2;
   */
  HostID = "";

  /**
   * Name is the name of the application to delete.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteApplicationServerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteApplicationServerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteApplicationServerRequest {
    return new DeleteApplicationServerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteApplicationServerRequest {
    return new DeleteApplicationServerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteApplicationServerRequest {
    return new DeleteApplicationServerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteApplicationServerRequest | PlainMessage<DeleteApplicationServerRequest> | undefined, b: DeleteApplicationServerRequest | PlainMessage<DeleteApplicationServerRequest> | undefined): boolean {
    return proto3.util.equals(DeleteApplicationServerRequest, a, b);
  }
}

/**
 * DeleteAllApplicationServersRequest are the parameters used to remove all applications.
 *
 * @generated from message proto.DeleteAllApplicationServersRequest
 */
export class DeleteAllApplicationServersRequest extends Message<DeleteAllApplicationServersRequest> {
  /**
   * Namespace is the app servers namespace.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace = "";

  constructor(data?: PartialMessage<DeleteAllApplicationServersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteAllApplicationServersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAllApplicationServersRequest {
    return new DeleteAllApplicationServersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAllApplicationServersRequest {
    return new DeleteAllApplicationServersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAllApplicationServersRequest {
    return new DeleteAllApplicationServersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAllApplicationServersRequest | PlainMessage<DeleteAllApplicationServersRequest> | undefined, b: DeleteAllApplicationServersRequest | PlainMessage<DeleteAllApplicationServersRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAllApplicationServersRequest, a, b);
  }
}

/**
 * GenerateAppTokenRequest are the parameters used to request an application
 * token.
 *
 * @generated from message proto.GenerateAppTokenRequest
 */
export class GenerateAppTokenRequest extends Message<GenerateAppTokenRequest> {
  /**
   * Username is the Teleport username.
   *
   * @generated from field: string Username = 1;
   */
  Username = "";

  /**
   * Roles is a list of Teleport roles assigned to the user.
   *
   * @generated from field: repeated string Roles = 2;
   */
  Roles: string[] = [];

  /**
   * URI is the URI of the application this token is targeting.
   *
   * @generated from field: string URI = 3;
   */
  URI = "";

  /**
   * Expires is the time this token expires.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 4;
   */
  Expires?: Timestamp;

  /**
   * Traits are the traits assigned to the user within Teleport.
   *
   * @generated from field: map<string, wrappers.StringValues> Traits = 5;
   */
  Traits: { [key: string]: StringValues } = {};

  constructor(data?: PartialMessage<GenerateAppTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GenerateAppTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Expires", kind: "message", T: Timestamp },
    { no: 5, name: "Traits", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: StringValues} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateAppTokenRequest {
    return new GenerateAppTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateAppTokenRequest {
    return new GenerateAppTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateAppTokenRequest {
    return new GenerateAppTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateAppTokenRequest | PlainMessage<GenerateAppTokenRequest> | undefined, b: GenerateAppTokenRequest | PlainMessage<GenerateAppTokenRequest> | undefined): boolean {
    return proto3.util.equals(GenerateAppTokenRequest, a, b);
  }
}

/**
 * GenerateAppTokenResponse contains a signed application token.
 *
 * @generated from message proto.GenerateAppTokenResponse
 */
export class GenerateAppTokenResponse extends Message<GenerateAppTokenResponse> {
  /**
   * @generated from field: string Token = 1;
   */
  Token = "";

  constructor(data?: PartialMessage<GenerateAppTokenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GenerateAppTokenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateAppTokenResponse {
    return new GenerateAppTokenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateAppTokenResponse {
    return new GenerateAppTokenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateAppTokenResponse {
    return new GenerateAppTokenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateAppTokenResponse | PlainMessage<GenerateAppTokenResponse> | undefined, b: GenerateAppTokenResponse | PlainMessage<GenerateAppTokenResponse> | undefined): boolean {
    return proto3.util.equals(GenerateAppTokenResponse, a, b);
  }
}

/**
 * GetAppSessionRequest are the parameters used to request an application web session.
 *
 * @generated from message proto.GetAppSessionRequest
 */
export class GetAppSessionRequest extends Message<GetAppSessionRequest> {
  /**
   * SessionID is the ID of the session being requested.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<GetAppSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetAppSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppSessionRequest {
    return new GetAppSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppSessionRequest {
    return new GetAppSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppSessionRequest {
    return new GetAppSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppSessionRequest | PlainMessage<GetAppSessionRequest> | undefined, b: GetAppSessionRequest | PlainMessage<GetAppSessionRequest> | undefined): boolean {
    return proto3.util.equals(GetAppSessionRequest, a, b);
  }
}

/**
 * GetAppSessionResponse contains the requested application web session.
 *
 * @generated from message proto.GetAppSessionResponse
 */
export class GetAppSessionResponse extends Message<GetAppSessionResponse> {
  /**
   * Session is the application web session.
   *
   * @generated from field: types.WebSessionV2 Session = 1;
   */
  Session?: WebSessionV2;

  constructor(data?: PartialMessage<GetAppSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetAppSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Session", kind: "message", T: WebSessionV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAppSessionResponse {
    return new GetAppSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAppSessionResponse {
    return new GetAppSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAppSessionResponse {
    return new GetAppSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAppSessionResponse | PlainMessage<GetAppSessionResponse> | undefined, b: GetAppSessionResponse | PlainMessage<GetAppSessionResponse> | undefined): boolean {
    return proto3.util.equals(GetAppSessionResponse, a, b);
  }
}

/**
 * ListAppSessionRequest are the parameters used to request an application web session.
 *
 * Follows the pagination semantics of
 * https://cloud.google.com/apis/design/standard_methods#list.
 *
 * @generated from message proto.ListAppSessionsRequest
 */
export class ListAppSessionsRequest extends Message<ListAppSessionsRequest> {
  /**
   * The maximum number of items to return.
   * The server may impose a different page size at its discretion.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * The next_page_token value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * Optional username which will filter the returned web sessions
   * to include only those for the given user.
   *
   * @generated from field: string user = 3;
   */
  user = "";

  constructor(data?: PartialMessage<ListAppSessionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListAppSessionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAppSessionsRequest {
    return new ListAppSessionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAppSessionsRequest {
    return new ListAppSessionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAppSessionsRequest {
    return new ListAppSessionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAppSessionsRequest | PlainMessage<ListAppSessionsRequest> | undefined, b: ListAppSessionsRequest | PlainMessage<ListAppSessionsRequest> | undefined): boolean {
    return proto3.util.equals(ListAppSessionsRequest, a, b);
  }
}

/**
 * ListAppSessionResponse contains the requested application web session.
 *
 * @generated from message proto.ListAppSessionsResponse
 */
export class ListAppSessionsResponse extends Message<ListAppSessionsResponse> {
  /**
   * Sessions for the retrieved page.
   *
   * @generated from field: repeated types.WebSessionV2 sessions = 1;
   */
  sessions: WebSessionV2[] = [];

  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListAppSessionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListAppSessionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sessions", kind: "message", T: WebSessionV2, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAppSessionsResponse {
    return new ListAppSessionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAppSessionsResponse {
    return new ListAppSessionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAppSessionsResponse {
    return new ListAppSessionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAppSessionsResponse | PlainMessage<ListAppSessionsResponse> | undefined, b: ListAppSessionsResponse | PlainMessage<ListAppSessionsResponse> | undefined): boolean {
    return proto3.util.equals(ListAppSessionsResponse, a, b);
  }
}

/**
 * GetSnowflakeSessionsResponse contains all the requested Snowflake web sessions.
 *
 * @generated from message proto.GetSnowflakeSessionsResponse
 */
export class GetSnowflakeSessionsResponse extends Message<GetSnowflakeSessionsResponse> {
  /**
   * Sessions is a list of Snowflake web sessions.
   *
   * @generated from field: repeated types.WebSessionV2 Sessions = 1;
   */
  Sessions: WebSessionV2[] = [];

  constructor(data?: PartialMessage<GetSnowflakeSessionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSnowflakeSessionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Sessions", kind: "message", T: WebSessionV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSnowflakeSessionsResponse {
    return new GetSnowflakeSessionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSnowflakeSessionsResponse {
    return new GetSnowflakeSessionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSnowflakeSessionsResponse {
    return new GetSnowflakeSessionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSnowflakeSessionsResponse | PlainMessage<GetSnowflakeSessionsResponse> | undefined, b: GetSnowflakeSessionsResponse | PlainMessage<GetSnowflakeSessionsResponse> | undefined): boolean {
    return proto3.util.equals(GetSnowflakeSessionsResponse, a, b);
  }
}

/**
 * ListSAMLIdPSessionRequest are the parameters used to request a SAML IdP sessions.
 *
 * Follows the pagination semantics of
 * https://cloud.google.com/apis/design/standard_methods#list.
 *
 * @generated from message proto.ListSAMLIdPSessionsRequest
 */
export class ListSAMLIdPSessionsRequest extends Message<ListSAMLIdPSessionsRequest> {
  /**
   * The maximum number of items to return.
   * The server may impose a different page size at its discretion.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * The next_page_token value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * Optional username which will filter the returned SAML IdP sessions
   * to include only those for the given user.
   *
   * @generated from field: string user = 3;
   */
  user = "";

  constructor(data?: PartialMessage<ListSAMLIdPSessionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListSAMLIdPSessionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSAMLIdPSessionsRequest {
    return new ListSAMLIdPSessionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSAMLIdPSessionsRequest {
    return new ListSAMLIdPSessionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSAMLIdPSessionsRequest {
    return new ListSAMLIdPSessionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSAMLIdPSessionsRequest | PlainMessage<ListSAMLIdPSessionsRequest> | undefined, b: ListSAMLIdPSessionsRequest | PlainMessage<ListSAMLIdPSessionsRequest> | undefined): boolean {
    return proto3.util.equals(ListSAMLIdPSessionsRequest, a, b);
  }
}

/**
 * ListSAMLIdPSessionsResponse contains all the requested SAML IdP sessions.
 *
 * @generated from message proto.ListSAMLIdPSessionsResponse
 */
export class ListSAMLIdPSessionsResponse extends Message<ListSAMLIdPSessionsResponse> {
  /**
   * Sessions for the retrieved page.
   *
   * @generated from field: repeated types.WebSessionV2 sessions = 1;
   */
  sessions: WebSessionV2[] = [];

  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListSAMLIdPSessionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListSAMLIdPSessionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sessions", kind: "message", T: WebSessionV2, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSAMLIdPSessionsResponse {
    return new ListSAMLIdPSessionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSAMLIdPSessionsResponse {
    return new ListSAMLIdPSessionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSAMLIdPSessionsResponse {
    return new ListSAMLIdPSessionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSAMLIdPSessionsResponse | PlainMessage<ListSAMLIdPSessionsResponse> | undefined, b: ListSAMLIdPSessionsResponse | PlainMessage<ListSAMLIdPSessionsResponse> | undefined): boolean {
    return proto3.util.equals(ListSAMLIdPSessionsResponse, a, b);
  }
}

/**
 * CreateAppSessionRequest contains the parameters to request a application web session.
 *
 * @generated from message proto.CreateAppSessionRequest
 */
export class CreateAppSessionRequest extends Message<CreateAppSessionRequest> {
  /**
   * Username is the name of the user requesting the session.
   *
   * @generated from field: string Username = 1;
   */
  Username = "";

  /**
   * PublicAddr is the public address the application.
   *
   * @generated from field: string PublicAddr = 3;
   */
  PublicAddr = "";

  /**
   * ClusterName is cluster within which the application is running.
   *
   * @generated from field: string ClusterName = 4;
   */
  ClusterName = "";

  /**
   * AWSRoleARN is AWS role the user wants to assume.
   *
   * @generated from field: string AWSRoleARN = 5;
   */
  AWSRoleARN = "";

  /**
   * AzureIdentity is Azure identity the user wants to assume.
   *
   * @generated from field: string AzureIdentity = 6;
   */
  AzureIdentity = "";

  /**
   * GCPServiceAccount is the GCP service account the user wants to assume.
   *
   * @generated from field: string GCPServiceAccount = 7;
   */
  GCPServiceAccount = "";

  /**
   * MFAResponse is a response to a challenge from a user's MFA device.
   * An optional field, that when provided, the response will be validated and
   * the ID of the validated MFA device will be stored in session's certificate.
   *
   * @generated from field: proto.MFAAuthenticateResponse MFAResponse = 8;
   */
  MFAResponse?: MFAAuthenticateResponse;

  /**
   * AppName is the name of the application.
   *
   * @generated from field: string AppName = 9;
   */
  AppName = "";

  /**
   * URI is the URI of the app. This is the internal endpoint where the application is running and isn't user-facing.
   *
   * @generated from field: string URI = 10;
   */
  URI = "";

  /**
   * ClientAddr is a client (user's) address.
   *
   * @generated from field: string ClientAddr = 11;
   */
  ClientAddr = "";

  constructor(data?: PartialMessage<CreateAppSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateAppSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "PublicAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "AWSRoleARN", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "AzureIdentity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "GCPServiceAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "MFAResponse", kind: "message", T: MFAAuthenticateResponse },
    { no: 9, name: "AppName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "URI", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "ClientAddr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAppSessionRequest {
    return new CreateAppSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAppSessionRequest {
    return new CreateAppSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAppSessionRequest {
    return new CreateAppSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAppSessionRequest | PlainMessage<CreateAppSessionRequest> | undefined, b: CreateAppSessionRequest | PlainMessage<CreateAppSessionRequest> | undefined): boolean {
    return proto3.util.equals(CreateAppSessionRequest, a, b);
  }
}

/**
 * CreateAppSessionResponse contains the requested application web session.
 *
 * @generated from message proto.CreateAppSessionResponse
 */
export class CreateAppSessionResponse extends Message<CreateAppSessionResponse> {
  /**
   * Session is the application web session.
   *
   * @generated from field: types.WebSessionV2 Session = 1;
   */
  Session?: WebSessionV2;

  constructor(data?: PartialMessage<CreateAppSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateAppSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Session", kind: "message", T: WebSessionV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAppSessionResponse {
    return new CreateAppSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAppSessionResponse {
    return new CreateAppSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAppSessionResponse {
    return new CreateAppSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAppSessionResponse | PlainMessage<CreateAppSessionResponse> | undefined, b: CreateAppSessionResponse | PlainMessage<CreateAppSessionResponse> | undefined): boolean {
    return proto3.util.equals(CreateAppSessionResponse, a, b);
  }
}

/**
 * CreateSnowflakeSessionRequest contains data required to create Snowflake web session.
 *
 * @generated from message proto.CreateSnowflakeSessionRequest
 */
export class CreateSnowflakeSessionRequest extends Message<CreateSnowflakeSessionRequest> {
  /**
   * Username is the name of the user requesting the session.
   *
   * @generated from field: string Username = 1;
   */
  Username = "";

  /**
   * SessionToken is the Snowflake server session token.
   *
   * @generated from field: string SessionToken = 2;
   */
  SessionToken = "";

  /**
   * TokenTTL is the token validity period.
   *
   * @generated from field: int64 TokenTTL = 3;
   */
  TokenTTL = protoInt64.zero;

  constructor(data?: PartialMessage<CreateSnowflakeSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateSnowflakeSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "SessionToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TokenTTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSnowflakeSessionRequest {
    return new CreateSnowflakeSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSnowflakeSessionRequest {
    return new CreateSnowflakeSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSnowflakeSessionRequest {
    return new CreateSnowflakeSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSnowflakeSessionRequest | PlainMessage<CreateSnowflakeSessionRequest> | undefined, b: CreateSnowflakeSessionRequest | PlainMessage<CreateSnowflakeSessionRequest> | undefined): boolean {
    return proto3.util.equals(CreateSnowflakeSessionRequest, a, b);
  }
}

/**
 * CreateSnowflakeSessionResponse contains Snowflake WebSession.
 *
 * @generated from message proto.CreateSnowflakeSessionResponse
 */
export class CreateSnowflakeSessionResponse extends Message<CreateSnowflakeSessionResponse> {
  /**
   * @generated from field: types.WebSessionV2 Session = 1;
   */
  Session?: WebSessionV2;

  constructor(data?: PartialMessage<CreateSnowflakeSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateSnowflakeSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Session", kind: "message", T: WebSessionV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSnowflakeSessionResponse {
    return new CreateSnowflakeSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSnowflakeSessionResponse {
    return new CreateSnowflakeSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSnowflakeSessionResponse {
    return new CreateSnowflakeSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSnowflakeSessionResponse | PlainMessage<CreateSnowflakeSessionResponse> | undefined, b: CreateSnowflakeSessionResponse | PlainMessage<CreateSnowflakeSessionResponse> | undefined): boolean {
    return proto3.util.equals(CreateSnowflakeSessionResponse, a, b);
  }
}

/**
 * CreateSAMLIdPSessionRequest contains data required to create a SAML IdP session.
 *
 * @generated from message proto.CreateSAMLIdPSessionRequest
 */
export class CreateSAMLIdPSessionRequest extends Message<CreateSAMLIdPSessionRequest> {
  /**
   * SessionID is the identifier for the session.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  /**
   * Username is the name of the user requesting the session.
   *
   * @generated from field: string Username = 2;
   */
  Username = "";

  /**
   * SAMLSession is the session data associated with the SAML IdP session.
   *
   * @generated from field: types.SAMLSessionData SAMLSession = 3;
   */
  SAMLSession?: SAMLSessionData;

  constructor(data?: PartialMessage<CreateSAMLIdPSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateSAMLIdPSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "SAMLSession", kind: "message", T: SAMLSessionData },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSAMLIdPSessionRequest {
    return new CreateSAMLIdPSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSAMLIdPSessionRequest {
    return new CreateSAMLIdPSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSAMLIdPSessionRequest {
    return new CreateSAMLIdPSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSAMLIdPSessionRequest | PlainMessage<CreateSAMLIdPSessionRequest> | undefined, b: CreateSAMLIdPSessionRequest | PlainMessage<CreateSAMLIdPSessionRequest> | undefined): boolean {
    return proto3.util.equals(CreateSAMLIdPSessionRequest, a, b);
  }
}

/**
 * CreateSAMLIdPSessionResponse contains a SAML IdP session.
 *
 * @generated from message proto.CreateSAMLIdPSessionResponse
 */
export class CreateSAMLIdPSessionResponse extends Message<CreateSAMLIdPSessionResponse> {
  /**
   * @generated from field: types.WebSessionV2 Session = 1;
   */
  Session?: WebSessionV2;

  constructor(data?: PartialMessage<CreateSAMLIdPSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateSAMLIdPSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Session", kind: "message", T: WebSessionV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSAMLIdPSessionResponse {
    return new CreateSAMLIdPSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSAMLIdPSessionResponse {
    return new CreateSAMLIdPSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSAMLIdPSessionResponse {
    return new CreateSAMLIdPSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSAMLIdPSessionResponse | PlainMessage<CreateSAMLIdPSessionResponse> | undefined, b: CreateSAMLIdPSessionResponse | PlainMessage<CreateSAMLIdPSessionResponse> | undefined): boolean {
    return proto3.util.equals(CreateSAMLIdPSessionResponse, a, b);
  }
}

/**
 * GetSnowflakeSessionRequest are the parameters used to request an Snowflake web session.
 *
 * @generated from message proto.GetSnowflakeSessionRequest
 */
export class GetSnowflakeSessionRequest extends Message<GetSnowflakeSessionRequest> {
  /**
   * SessionID is the ID of the session being requested.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<GetSnowflakeSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSnowflakeSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSnowflakeSessionRequest {
    return new GetSnowflakeSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSnowflakeSessionRequest {
    return new GetSnowflakeSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSnowflakeSessionRequest {
    return new GetSnowflakeSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSnowflakeSessionRequest | PlainMessage<GetSnowflakeSessionRequest> | undefined, b: GetSnowflakeSessionRequest | PlainMessage<GetSnowflakeSessionRequest> | undefined): boolean {
    return proto3.util.equals(GetSnowflakeSessionRequest, a, b);
  }
}

/**
 * GetSnowflakeSessionResponse contains the requested Snowflake web session.
 *
 * @generated from message proto.GetSnowflakeSessionResponse
 */
export class GetSnowflakeSessionResponse extends Message<GetSnowflakeSessionResponse> {
  /**
   * Session is the Snowflake web session.
   *
   * @generated from field: types.WebSessionV2 Session = 1;
   */
  Session?: WebSessionV2;

  constructor(data?: PartialMessage<GetSnowflakeSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSnowflakeSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Session", kind: "message", T: WebSessionV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSnowflakeSessionResponse {
    return new GetSnowflakeSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSnowflakeSessionResponse {
    return new GetSnowflakeSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSnowflakeSessionResponse {
    return new GetSnowflakeSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSnowflakeSessionResponse | PlainMessage<GetSnowflakeSessionResponse> | undefined, b: GetSnowflakeSessionResponse | PlainMessage<GetSnowflakeSessionResponse> | undefined): boolean {
    return proto3.util.equals(GetSnowflakeSessionResponse, a, b);
  }
}

/**
 * GetSAMLIdPSessionRequest are the parameters used to request a SAML IdP session.
 *
 * @generated from message proto.GetSAMLIdPSessionRequest
 */
export class GetSAMLIdPSessionRequest extends Message<GetSAMLIdPSessionRequest> {
  /**
   * SessionID is the ID of the session being requested.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<GetSAMLIdPSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSAMLIdPSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSAMLIdPSessionRequest {
    return new GetSAMLIdPSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSAMLIdPSessionRequest {
    return new GetSAMLIdPSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSAMLIdPSessionRequest {
    return new GetSAMLIdPSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSAMLIdPSessionRequest | PlainMessage<GetSAMLIdPSessionRequest> | undefined, b: GetSAMLIdPSessionRequest | PlainMessage<GetSAMLIdPSessionRequest> | undefined): boolean {
    return proto3.util.equals(GetSAMLIdPSessionRequest, a, b);
  }
}

/**
 * GetSAMLIdPSessionResponse contains the requested SAML IdP session.
 *
 * @generated from message proto.GetSAMLIdPSessionResponse
 */
export class GetSAMLIdPSessionResponse extends Message<GetSAMLIdPSessionResponse> {
  /**
   * Session is the SAML IdP web session.
   *
   * @generated from field: types.WebSessionV2 Session = 1;
   */
  Session?: WebSessionV2;

  constructor(data?: PartialMessage<GetSAMLIdPSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSAMLIdPSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Session", kind: "message", T: WebSessionV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSAMLIdPSessionResponse {
    return new GetSAMLIdPSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSAMLIdPSessionResponse {
    return new GetSAMLIdPSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSAMLIdPSessionResponse {
    return new GetSAMLIdPSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSAMLIdPSessionResponse | PlainMessage<GetSAMLIdPSessionResponse> | undefined, b: GetSAMLIdPSessionResponse | PlainMessage<GetSAMLIdPSessionResponse> | undefined): boolean {
    return proto3.util.equals(GetSAMLIdPSessionResponse, a, b);
  }
}

/**
 * DeleteAppSessionRequest contains the parameters used to remove an application web session.
 *
 * @generated from message proto.DeleteAppSessionRequest
 */
export class DeleteAppSessionRequest extends Message<DeleteAppSessionRequest> {
  /**
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<DeleteAppSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteAppSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAppSessionRequest {
    return new DeleteAppSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAppSessionRequest {
    return new DeleteAppSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAppSessionRequest {
    return new DeleteAppSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAppSessionRequest | PlainMessage<DeleteAppSessionRequest> | undefined, b: DeleteAppSessionRequest | PlainMessage<DeleteAppSessionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAppSessionRequest, a, b);
  }
}

/**
 * DeleteSnowflakeSessionRequest contains the parameters used to remove a Snowflake web session.
 *
 * @generated from message proto.DeleteSnowflakeSessionRequest
 */
export class DeleteSnowflakeSessionRequest extends Message<DeleteSnowflakeSessionRequest> {
  /**
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<DeleteSnowflakeSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteSnowflakeSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSnowflakeSessionRequest {
    return new DeleteSnowflakeSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSnowflakeSessionRequest {
    return new DeleteSnowflakeSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSnowflakeSessionRequest {
    return new DeleteSnowflakeSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSnowflakeSessionRequest | PlainMessage<DeleteSnowflakeSessionRequest> | undefined, b: DeleteSnowflakeSessionRequest | PlainMessage<DeleteSnowflakeSessionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSnowflakeSessionRequest, a, b);
  }
}

/**
 * DeleteSAMLIdPSessionRequest contains the parameters used to remove a SAML IdP session.
 *
 * @generated from message proto.DeleteSAMLIdPSessionRequest
 */
export class DeleteSAMLIdPSessionRequest extends Message<DeleteSAMLIdPSessionRequest> {
  /**
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<DeleteSAMLIdPSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteSAMLIdPSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSAMLIdPSessionRequest {
    return new DeleteSAMLIdPSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSAMLIdPSessionRequest {
    return new DeleteSAMLIdPSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSAMLIdPSessionRequest {
    return new DeleteSAMLIdPSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSAMLIdPSessionRequest | PlainMessage<DeleteSAMLIdPSessionRequest> | undefined, b: DeleteSAMLIdPSessionRequest | PlainMessage<DeleteSAMLIdPSessionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSAMLIdPSessionRequest, a, b);
  }
}

/**
 * DeleteUserAppSessionsRequest contains the parameters used to remove the
 * user's application web sessions.
 *
 * @generated from message proto.DeleteUserAppSessionsRequest
 */
export class DeleteUserAppSessionsRequest extends Message<DeleteUserAppSessionsRequest> {
  /**
   * @generated from field: string Username = 1;
   */
  Username = "";

  constructor(data?: PartialMessage<DeleteUserAppSessionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteUserAppSessionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteUserAppSessionsRequest {
    return new DeleteUserAppSessionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteUserAppSessionsRequest {
    return new DeleteUserAppSessionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteUserAppSessionsRequest {
    return new DeleteUserAppSessionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteUserAppSessionsRequest | PlainMessage<DeleteUserAppSessionsRequest> | undefined, b: DeleteUserAppSessionsRequest | PlainMessage<DeleteUserAppSessionsRequest> | undefined): boolean {
    return proto3.util.equals(DeleteUserAppSessionsRequest, a, b);
  }
}

/**
 * DeleteUserAppSessionsRequest contains the parameters used to remove the
 * user's SAML IdP sessions.
 *
 * @generated from message proto.DeleteUserSAMLIdPSessionsRequest
 */
export class DeleteUserSAMLIdPSessionsRequest extends Message<DeleteUserSAMLIdPSessionsRequest> {
  /**
   * @generated from field: string Username = 1;
   */
  Username = "";

  constructor(data?: PartialMessage<DeleteUserSAMLIdPSessionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteUserSAMLIdPSessionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteUserSAMLIdPSessionsRequest {
    return new DeleteUserSAMLIdPSessionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteUserSAMLIdPSessionsRequest {
    return new DeleteUserSAMLIdPSessionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteUserSAMLIdPSessionsRequest {
    return new DeleteUserSAMLIdPSessionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteUserSAMLIdPSessionsRequest | PlainMessage<DeleteUserSAMLIdPSessionsRequest> | undefined, b: DeleteUserSAMLIdPSessionsRequest | PlainMessage<DeleteUserSAMLIdPSessionsRequest> | undefined): boolean {
    return proto3.util.equals(DeleteUserSAMLIdPSessionsRequest, a, b);
  }
}

/**
 * GetWebSessionResponse contains the requested web session.
 *
 * @generated from message proto.GetWebSessionResponse
 */
export class GetWebSessionResponse extends Message<GetWebSessionResponse> {
  /**
   * Session is the web session.
   *
   * @generated from field: types.WebSessionV2 Session = 1;
   */
  Session?: WebSessionV2;

  constructor(data?: PartialMessage<GetWebSessionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWebSessionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Session", kind: "message", T: WebSessionV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWebSessionResponse {
    return new GetWebSessionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWebSessionResponse {
    return new GetWebSessionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWebSessionResponse {
    return new GetWebSessionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWebSessionResponse | PlainMessage<GetWebSessionResponse> | undefined, b: GetWebSessionResponse | PlainMessage<GetWebSessionResponse> | undefined): boolean {
    return proto3.util.equals(GetWebSessionResponse, a, b);
  }
}

/**
 * GetWebSessionsResponse contains all the requested web sessions.
 *
 * @generated from message proto.GetWebSessionsResponse
 */
export class GetWebSessionsResponse extends Message<GetWebSessionsResponse> {
  /**
   * Sessions is a list of web sessions.
   *
   * @generated from field: repeated types.WebSessionV2 Sessions = 1;
   */
  Sessions: WebSessionV2[] = [];

  constructor(data?: PartialMessage<GetWebSessionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWebSessionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Sessions", kind: "message", T: WebSessionV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWebSessionsResponse {
    return new GetWebSessionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWebSessionsResponse {
    return new GetWebSessionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWebSessionsResponse {
    return new GetWebSessionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWebSessionsResponse | PlainMessage<GetWebSessionsResponse> | undefined, b: GetWebSessionsResponse | PlainMessage<GetWebSessionsResponse> | undefined): boolean {
    return proto3.util.equals(GetWebSessionsResponse, a, b);
  }
}

/**
 * GetWebTokenResponse contains the requested web token.
 *
 * @generated from message proto.GetWebTokenResponse
 */
export class GetWebTokenResponse extends Message<GetWebTokenResponse> {
  /**
   * Token is the web token being requested.
   *
   * @generated from field: types.WebTokenV3 Token = 1;
   */
  Token?: WebTokenV3;

  constructor(data?: PartialMessage<GetWebTokenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWebTokenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Token", kind: "message", T: WebTokenV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWebTokenResponse {
    return new GetWebTokenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWebTokenResponse {
    return new GetWebTokenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWebTokenResponse {
    return new GetWebTokenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWebTokenResponse | PlainMessage<GetWebTokenResponse> | undefined, b: GetWebTokenResponse | PlainMessage<GetWebTokenResponse> | undefined): boolean {
    return proto3.util.equals(GetWebTokenResponse, a, b);
  }
}

/**
 * GetWebTokensResponse contains all the requested web tokens.
 *
 * @generated from message proto.GetWebTokensResponse
 */
export class GetWebTokensResponse extends Message<GetWebTokensResponse> {
  /**
   * Tokens is a list of web tokens.
   *
   * @generated from field: repeated types.WebTokenV3 Tokens = 1;
   */
  Tokens: WebTokenV3[] = [];

  constructor(data?: PartialMessage<GetWebTokensResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWebTokensResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Tokens", kind: "message", T: WebTokenV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWebTokensResponse {
    return new GetWebTokensResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWebTokensResponse {
    return new GetWebTokensResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWebTokensResponse {
    return new GetWebTokensResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWebTokensResponse | PlainMessage<GetWebTokensResponse> | undefined, b: GetWebTokensResponse | PlainMessage<GetWebTokensResponse> | undefined): boolean {
    return proto3.util.equals(GetWebTokensResponse, a, b);
  }
}

/**
 * UpsertKubernetesServerRequest are the parameters used to add or update a
 * kubernetes server.
 *
 * @generated from message proto.UpsertKubernetesServerRequest
 */
export class UpsertKubernetesServerRequest extends Message<UpsertKubernetesServerRequest> {
  /**
   * @generated from field: types.KubernetesServerV3 Server = 1;
   */
  Server?: KubernetesServerV3;

  constructor(data?: PartialMessage<UpsertKubernetesServerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertKubernetesServerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Server", kind: "message", T: KubernetesServerV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertKubernetesServerRequest {
    return new UpsertKubernetesServerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertKubernetesServerRequest {
    return new UpsertKubernetesServerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertKubernetesServerRequest {
    return new UpsertKubernetesServerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertKubernetesServerRequest | PlainMessage<UpsertKubernetesServerRequest> | undefined, b: UpsertKubernetesServerRequest | PlainMessage<UpsertKubernetesServerRequest> | undefined): boolean {
    return proto3.util.equals(UpsertKubernetesServerRequest, a, b);
  }
}

/**
 * DeleteKubernetesServerRequest are the parameters used to remove a kubernetes server.
 *
 * @generated from message proto.DeleteKubernetesServerRequest
 */
export class DeleteKubernetesServerRequest extends Message<DeleteKubernetesServerRequest> {
  /**
   * HostID is the kube server host uuid.
   *
   * @generated from field: string HostID = 1;
   */
  HostID = "";

  /**
   * Name is the name of the kubernetes service to delete.
   *
   * @generated from field: string Name = 2;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteKubernetesServerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteKubernetesServerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteKubernetesServerRequest {
    return new DeleteKubernetesServerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteKubernetesServerRequest {
    return new DeleteKubernetesServerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteKubernetesServerRequest {
    return new DeleteKubernetesServerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteKubernetesServerRequest | PlainMessage<DeleteKubernetesServerRequest> | undefined, b: DeleteKubernetesServerRequest | PlainMessage<DeleteKubernetesServerRequest> | undefined): boolean {
    return proto3.util.equals(DeleteKubernetesServerRequest, a, b);
  }
}

/**
 * DeleteAllKubernetesServersRequest are the parameters used to remove all kubernetes servers.
 *
 * @generated from message proto.DeleteAllKubernetesServersRequest
 */
export class DeleteAllKubernetesServersRequest extends Message<DeleteAllKubernetesServersRequest> {
  constructor(data?: PartialMessage<DeleteAllKubernetesServersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteAllKubernetesServersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAllKubernetesServersRequest {
    return new DeleteAllKubernetesServersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAllKubernetesServersRequest {
    return new DeleteAllKubernetesServersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAllKubernetesServersRequest {
    return new DeleteAllKubernetesServersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAllKubernetesServersRequest | PlainMessage<DeleteAllKubernetesServersRequest> | undefined, b: DeleteAllKubernetesServersRequest | PlainMessage<DeleteAllKubernetesServersRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAllKubernetesServersRequest, a, b);
  }
}

/**
 * UpsertDatabaseServerRequest is a request to register database server.
 *
 * @generated from message proto.UpsertDatabaseServerRequest
 */
export class UpsertDatabaseServerRequest extends Message<UpsertDatabaseServerRequest> {
  /**
   * Server is the database proxy server to register.
   *
   * @generated from field: types.DatabaseServerV3 Server = 1;
   */
  Server?: DatabaseServerV3;

  constructor(data?: PartialMessage<UpsertDatabaseServerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertDatabaseServerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Server", kind: "message", T: DatabaseServerV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertDatabaseServerRequest {
    return new UpsertDatabaseServerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertDatabaseServerRequest {
    return new UpsertDatabaseServerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertDatabaseServerRequest {
    return new UpsertDatabaseServerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertDatabaseServerRequest | PlainMessage<UpsertDatabaseServerRequest> | undefined, b: UpsertDatabaseServerRequest | PlainMessage<UpsertDatabaseServerRequest> | undefined): boolean {
    return proto3.util.equals(UpsertDatabaseServerRequest, a, b);
  }
}

/**
 * DeleteDatabaseServerRequest is a request to delete a database server.
 *
 * @generated from message proto.DeleteDatabaseServerRequest
 */
export class DeleteDatabaseServerRequest extends Message<DeleteDatabaseServerRequest> {
  /**
   * Namespace is the database server namespace.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace = "";

  /**
   * HostID is the ID of the host database server is running on.
   *
   * @generated from field: string HostID = 2;
   */
  HostID = "";

  /**
   * Name is the database server name.
   *
   * @generated from field: string Name = 3;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteDatabaseServerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteDatabaseServerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDatabaseServerRequest {
    return new DeleteDatabaseServerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDatabaseServerRequest {
    return new DeleteDatabaseServerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDatabaseServerRequest {
    return new DeleteDatabaseServerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDatabaseServerRequest | PlainMessage<DeleteDatabaseServerRequest> | undefined, b: DeleteDatabaseServerRequest | PlainMessage<DeleteDatabaseServerRequest> | undefined): boolean {
    return proto3.util.equals(DeleteDatabaseServerRequest, a, b);
  }
}

/**
 * DeleteAllDatabaseServersRequest is a request to delete all database servers.
 *
 * @generated from message proto.DeleteAllDatabaseServersRequest
 */
export class DeleteAllDatabaseServersRequest extends Message<DeleteAllDatabaseServersRequest> {
  /**
   * Namespace is the database servers namespace.
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace = "";

  constructor(data?: PartialMessage<DeleteAllDatabaseServersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteAllDatabaseServersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAllDatabaseServersRequest {
    return new DeleteAllDatabaseServersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAllDatabaseServersRequest {
    return new DeleteAllDatabaseServersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAllDatabaseServersRequest {
    return new DeleteAllDatabaseServersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAllDatabaseServersRequest | PlainMessage<DeleteAllDatabaseServersRequest> | undefined, b: DeleteAllDatabaseServersRequest | PlainMessage<DeleteAllDatabaseServersRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAllDatabaseServersRequest, a, b);
  }
}

/**
 * DatabaseServiceV1List represents a list of DatabaseService resources.
 *
 * @generated from message proto.DatabaseServiceV1List
 */
export class DatabaseServiceV1List extends Message<DatabaseServiceV1List> {
  /**
   * Services is a list of DatabaseService resources.
   *
   * @generated from field: repeated types.DatabaseServiceV1 Services = 1;
   */
  Services: DatabaseServiceV1[] = [];

  constructor(data?: PartialMessage<DatabaseServiceV1List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DatabaseServiceV1List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Services", kind: "message", T: DatabaseServiceV1, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseServiceV1List {
    return new DatabaseServiceV1List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseServiceV1List {
    return new DatabaseServiceV1List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseServiceV1List {
    return new DatabaseServiceV1List().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseServiceV1List | PlainMessage<DatabaseServiceV1List> | undefined, b: DatabaseServiceV1List | PlainMessage<DatabaseServiceV1List> | undefined): boolean {
    return proto3.util.equals(DatabaseServiceV1List, a, b);
  }
}

/**
 * UpsertDatabaseServiceRequest is a request to register DatabaseService.
 *
 * @generated from message proto.UpsertDatabaseServiceRequest
 */
export class UpsertDatabaseServiceRequest extends Message<UpsertDatabaseServiceRequest> {
  /**
   * Service is the database service to register.
   *
   * @generated from field: types.DatabaseServiceV1 Service = 1;
   */
  Service?: DatabaseServiceV1;

  constructor(data?: PartialMessage<UpsertDatabaseServiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertDatabaseServiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Service", kind: "message", T: DatabaseServiceV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertDatabaseServiceRequest {
    return new UpsertDatabaseServiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertDatabaseServiceRequest {
    return new UpsertDatabaseServiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertDatabaseServiceRequest {
    return new UpsertDatabaseServiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertDatabaseServiceRequest | PlainMessage<UpsertDatabaseServiceRequest> | undefined, b: UpsertDatabaseServiceRequest | PlainMessage<UpsertDatabaseServiceRequest> | undefined): boolean {
    return proto3.util.equals(UpsertDatabaseServiceRequest, a, b);
  }
}

/**
 * DeleteAllDatabaseServicesRequest is a request to delete all DatabaseServices.
 *
 * @generated from message proto.DeleteAllDatabaseServicesRequest
 */
export class DeleteAllDatabaseServicesRequest extends Message<DeleteAllDatabaseServicesRequest> {
  constructor(data?: PartialMessage<DeleteAllDatabaseServicesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteAllDatabaseServicesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAllDatabaseServicesRequest {
    return new DeleteAllDatabaseServicesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAllDatabaseServicesRequest {
    return new DeleteAllDatabaseServicesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAllDatabaseServicesRequest {
    return new DeleteAllDatabaseServicesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAllDatabaseServicesRequest | PlainMessage<DeleteAllDatabaseServicesRequest> | undefined, b: DeleteAllDatabaseServicesRequest | PlainMessage<DeleteAllDatabaseServicesRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAllDatabaseServicesRequest, a, b);
  }
}

/**
 * DatabaseCSRRequest is a request to generate a client certificate used
 * by the proxy to authenticate with a remote database service.
 *
 * @generated from message proto.DatabaseCSRRequest
 */
export class DatabaseCSRRequest extends Message<DatabaseCSRRequest> {
  /**
   * CSR is the request to sign.
   *
   * @generated from field: bytes CSR = 1;
   */
  CSR = new Uint8Array(0);

  /**
   * ClusterName is the name of the cluster the request is for.
   *
   * @generated from field: string ClusterName = 2;
   */
  ClusterName = "";

  constructor(data?: PartialMessage<DatabaseCSRRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DatabaseCSRRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CSR", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseCSRRequest {
    return new DatabaseCSRRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseCSRRequest {
    return new DatabaseCSRRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseCSRRequest {
    return new DatabaseCSRRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseCSRRequest | PlainMessage<DatabaseCSRRequest> | undefined, b: DatabaseCSRRequest | PlainMessage<DatabaseCSRRequest> | undefined): boolean {
    return proto3.util.equals(DatabaseCSRRequest, a, b);
  }
}

/**
 * DatabaseCSRResponse contains the signed database certificate.
 *
 * @generated from message proto.DatabaseCSRResponse
 */
export class DatabaseCSRResponse extends Message<DatabaseCSRResponse> {
  /**
   * Cert is the signed certificate.
   *
   * @generated from field: bytes Cert = 1;
   */
  Cert = new Uint8Array(0);

  /**
   * CACerts is a list of certificate authorities.
   *
   * @generated from field: repeated bytes CACerts = 2;
   */
  CACerts: Uint8Array[] = [];

  constructor(data?: PartialMessage<DatabaseCSRResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DatabaseCSRResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "CACerts", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseCSRResponse {
    return new DatabaseCSRResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseCSRResponse {
    return new DatabaseCSRResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseCSRResponse {
    return new DatabaseCSRResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseCSRResponse | PlainMessage<DatabaseCSRResponse> | undefined, b: DatabaseCSRResponse | PlainMessage<DatabaseCSRResponse> | undefined): boolean {
    return proto3.util.equals(DatabaseCSRResponse, a, b);
  }
}

/**
 * DatabaseCertRequest is a request to generate a client certificate used
 * by a database service to authenticate with a database instance.
 *
 * @generated from message proto.DatabaseCertRequest
 */
export class DatabaseCertRequest extends Message<DatabaseCertRequest> {
  /**
   * CSR is the request to sign.
   *
   * @generated from field: bytes CSR = 1;
   */
  CSR = new Uint8Array(0);

  /**
   * ServerName is the SAN to include in the certificate.
   * DEPRECATED: Replaced by ServerNames.
   *
   * @generated from field: string ServerName = 2 [deprecated = true];
   * @deprecated
   */
  ServerName = "";

  /**
   * TTL is the certificate validity period.
   *
   * @generated from field: int64 TTL = 3;
   */
  TTL = protoInt64.zero;

  /**
   * ServerNames are SANs to include in the certificate.
   *
   * @generated from field: repeated string ServerNames = 4;
   */
  ServerNames: string[] = [];

  /**
   * RequesterName identifies who sent the request.
   *
   * @generated from field: proto.DatabaseCertRequest.Requester RequesterName = 5;
   */
  RequesterName = DatabaseCertRequest_Requester.UNSPECIFIED;

  /**
   * CertificateExtensions identifies which extensions, if any, should be added to the certificate.
   *
   * @generated from field: proto.DatabaseCertRequest.Extensions CertificateExtensions = 6;
   */
  CertificateExtensions = DatabaseCertRequest_Extensions.NORMAL;

  /**
   * CRLEndpoint is a certificate revocation list distribution point. Required for Windows smartcard certs.
   *
   * @generated from field: string CRLEndpoint = 7;
   */
  CRLEndpoint = "";

  constructor(data?: PartialMessage<DatabaseCertRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DatabaseCertRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CSR", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "ServerName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "ServerNames", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "RequesterName", kind: "enum", T: proto3.getEnumType(DatabaseCertRequest_Requester) },
    { no: 6, name: "CertificateExtensions", kind: "enum", T: proto3.getEnumType(DatabaseCertRequest_Extensions) },
    { no: 7, name: "CRLEndpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseCertRequest {
    return new DatabaseCertRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseCertRequest {
    return new DatabaseCertRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseCertRequest {
    return new DatabaseCertRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseCertRequest | PlainMessage<DatabaseCertRequest> | undefined, b: DatabaseCertRequest | PlainMessage<DatabaseCertRequest> | undefined): boolean {
    return proto3.util.equals(DatabaseCertRequest, a, b);
  }
}

/**
 * Requester is a name of service that sent the request.
 *
 * @generated from enum proto.DatabaseCertRequest.Requester
 */
export enum DatabaseCertRequest_Requester {
  /**
   * UNSPECIFIED is set when the requester in unknown.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * TCTL is set when request was sent by tctl tool.
   *
   * @generated from enum value: TCTL = 1;
   */
  TCTL = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DatabaseCertRequest_Requester)
proto3.util.setEnumType(DatabaseCertRequest_Requester, "proto.DatabaseCertRequest.Requester", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "TCTL" },
]);

/**
 * Extensions are the extensions to add to the certificate.
 *
 * @generated from enum proto.DatabaseCertRequest.Extensions
 */
export enum DatabaseCertRequest_Extensions {
  /**
   * NORMAL is used in all cases except Windows.
   *
   * @generated from enum value: NORMAL = 0;
   */
  NORMAL = 0,

  /**
   * WINDOWS adds specific required extensions for SQL Server, similar to Desktop Access.
   *
   * @generated from enum value: WINDOWS_SMARTCARD = 1;
   */
  WINDOWS_SMARTCARD = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DatabaseCertRequest_Extensions)
proto3.util.setEnumType(DatabaseCertRequest_Extensions, "proto.DatabaseCertRequest.Extensions", [
  { no: 0, name: "NORMAL" },
  { no: 1, name: "WINDOWS_SMARTCARD" },
]);

/**
 * DatabaseCertResponse contains the signed certificate.
 *
 * @generated from message proto.DatabaseCertResponse
 */
export class DatabaseCertResponse extends Message<DatabaseCertResponse> {
  /**
   * Cert is the signed certificate.
   *
   * @generated from field: bytes Cert = 1;
   */
  Cert = new Uint8Array(0);

  /**
   * CACerts is a list of certificate authorities.
   *
   * @generated from field: repeated bytes CACerts = 2;
   */
  CACerts: Uint8Array[] = [];

  constructor(data?: PartialMessage<DatabaseCertResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DatabaseCertResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "CACerts", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseCertResponse {
    return new DatabaseCertResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseCertResponse {
    return new DatabaseCertResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseCertResponse {
    return new DatabaseCertResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseCertResponse | PlainMessage<DatabaseCertResponse> | undefined, b: DatabaseCertResponse | PlainMessage<DatabaseCertResponse> | undefined): boolean {
    return proto3.util.equals(DatabaseCertResponse, a, b);
  }
}

/**
 * SnowflakeJWTRequest contains data required to generate Snowflake JWT used for authorization.
 *
 * @generated from message proto.SnowflakeJWTRequest
 */
export class SnowflakeJWTRequest extends Message<SnowflakeJWTRequest> {
  /**
   * @generated from field: string AccountName = 1;
   */
  AccountName = "";

  /**
   * @generated from field: string UserName = 2;
   */
  UserName = "";

  constructor(data?: PartialMessage<SnowflakeJWTRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SnowflakeJWTRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AccountName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "UserName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SnowflakeJWTRequest {
    return new SnowflakeJWTRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SnowflakeJWTRequest {
    return new SnowflakeJWTRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SnowflakeJWTRequest {
    return new SnowflakeJWTRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SnowflakeJWTRequest | PlainMessage<SnowflakeJWTRequest> | undefined, b: SnowflakeJWTRequest | PlainMessage<SnowflakeJWTRequest> | undefined): boolean {
    return proto3.util.equals(SnowflakeJWTRequest, a, b);
  }
}

/**
 * SnowflakeJWTResponse contains signed JWT that can be used for Snowflake authentication.
 *
 * @generated from message proto.SnowflakeJWTResponse
 */
export class SnowflakeJWTResponse extends Message<SnowflakeJWTResponse> {
  /**
   * @generated from field: string Token = 1;
   */
  Token = "";

  constructor(data?: PartialMessage<SnowflakeJWTResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SnowflakeJWTResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SnowflakeJWTResponse {
    return new SnowflakeJWTResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SnowflakeJWTResponse {
    return new SnowflakeJWTResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SnowflakeJWTResponse {
    return new SnowflakeJWTResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SnowflakeJWTResponse | PlainMessage<SnowflakeJWTResponse> | undefined, b: SnowflakeJWTResponse | PlainMessage<SnowflakeJWTResponse> | undefined): boolean {
    return proto3.util.equals(SnowflakeJWTResponse, a, b);
  }
}

/**
 * GetRoleRequest is a request to query a role.
 *
 * @generated from message proto.GetRoleRequest
 */
export class GetRoleRequest extends Message<GetRoleRequest> {
  /**
   * Name is the name of the role to get.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<GetRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRoleRequest {
    return new GetRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRoleRequest {
    return new GetRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRoleRequest {
    return new GetRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRoleRequest | PlainMessage<GetRoleRequest> | undefined, b: GetRoleRequest | PlainMessage<GetRoleRequest> | undefined): boolean {
    return proto3.util.equals(GetRoleRequest, a, b);
  }
}

/**
 * GetRolesResponse is a response to querying for all roles.
 *
 * @generated from message proto.GetRolesResponse
 */
export class GetRolesResponse extends Message<GetRolesResponse> {
  /**
   * Roles is a list of roles.
   *
   * @generated from field: repeated types.RoleV6 Roles = 1;
   */
  Roles: RoleV6[] = [];

  constructor(data?: PartialMessage<GetRolesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetRolesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Roles", kind: "message", T: RoleV6, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRolesResponse {
    return new GetRolesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRolesResponse {
    return new GetRolesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRolesResponse {
    return new GetRolesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRolesResponse | PlainMessage<GetRolesResponse> | undefined, b: GetRolesResponse | PlainMessage<GetRolesResponse> | undefined): boolean {
    return proto3.util.equals(GetRolesResponse, a, b);
  }
}

/**
 * ListRolesRequest encodes parameters for paginated role lookup.
 *
 * @generated from message proto.ListRolesRequest
 */
export class ListRolesRequest extends Message<ListRolesRequest> {
  /**
   * Limit is the maximum amount of roles per page.
   *
   * @generated from field: int32 Limit = 1;
   */
  Limit = 0;

  /**
   * StartKey is used to resume a query in order to enable pagination.
   * If the previous response had LastKey set then this should be
   * set to its value. Otherwise leave empty.
   *
   * @generated from field: string StartKey = 2;
   */
  StartKey = "";

  /**
   * Filter matches roles.
   *
   * @generated from field: types.RoleFilter Filter = 3;
   */
  Filter?: RoleFilter;

  constructor(data?: PartialMessage<ListRolesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListRolesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "StartKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Filter", kind: "message", T: RoleFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRolesRequest {
    return new ListRolesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRolesRequest {
    return new ListRolesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRolesRequest {
    return new ListRolesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListRolesRequest | PlainMessage<ListRolesRequest> | undefined, b: ListRolesRequest | PlainMessage<ListRolesRequest> | undefined): boolean {
    return proto3.util.equals(ListRolesRequest, a, b);
  }
}

/**
 * ListRolesResponse is a page of roles.
 *
 * @generated from message proto.ListRolesResponse
 */
export class ListRolesResponse extends Message<ListRolesResponse> {
  /**
   * Roles is a page of roles.
   *
   * @generated from field: repeated types.RoleV6 Roles = 1;
   */
  Roles: RoleV6[] = [];

  /**
   * NextKey will serve as the StartKey for the next page of roles.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  constructor(data?: PartialMessage<ListRolesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListRolesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Roles", kind: "message", T: RoleV6, repeated: true },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRolesResponse {
    return new ListRolesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRolesResponse {
    return new ListRolesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRolesResponse {
    return new ListRolesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListRolesResponse | PlainMessage<ListRolesResponse> | undefined, b: ListRolesResponse | PlainMessage<ListRolesResponse> | undefined): boolean {
    return proto3.util.equals(ListRolesResponse, a, b);
  }
}

/**
 * Request for CreateRole.
 *
 * @generated from message proto.CreateRoleRequest
 */
export class CreateRoleRequest extends Message<CreateRoleRequest> {
  /**
   * Role to be created.
   *
   * @generated from field: types.RoleV6 Role = 1;
   */
  Role?: RoleV6;

  constructor(data?: PartialMessage<CreateRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Role", kind: "message", T: RoleV6 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateRoleRequest {
    return new CreateRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateRoleRequest {
    return new CreateRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateRoleRequest {
    return new CreateRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateRoleRequest | PlainMessage<CreateRoleRequest> | undefined, b: CreateRoleRequest | PlainMessage<CreateRoleRequest> | undefined): boolean {
    return proto3.util.equals(CreateRoleRequest, a, b);
  }
}

/**
 * Request for UpdateRole.
 *
 * @generated from message proto.UpdateRoleRequest
 */
export class UpdateRoleRequest extends Message<UpdateRoleRequest> {
  /**
   * Role to be updated.
   *
   * @generated from field: types.RoleV6 Role = 1;
   */
  Role?: RoleV6;

  constructor(data?: PartialMessage<UpdateRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpdateRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Role", kind: "message", T: RoleV6 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateRoleRequest {
    return new UpdateRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateRoleRequest {
    return new UpdateRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateRoleRequest {
    return new UpdateRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateRoleRequest | PlainMessage<UpdateRoleRequest> | undefined, b: UpdateRoleRequest | PlainMessage<UpdateRoleRequest> | undefined): boolean {
    return proto3.util.equals(UpdateRoleRequest, a, b);
  }
}

/**
 * Request for UpsertRole.
 *
 * @generated from message proto.UpsertRoleRequest
 */
export class UpsertRoleRequest extends Message<UpsertRoleRequest> {
  /**
   * Role to be upserted.
   *
   * @generated from field: types.RoleV6 Role = 1;
   */
  Role?: RoleV6;

  constructor(data?: PartialMessage<UpsertRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Role", kind: "message", T: RoleV6 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertRoleRequest {
    return new UpsertRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertRoleRequest {
    return new UpsertRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertRoleRequest {
    return new UpsertRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertRoleRequest | PlainMessage<UpsertRoleRequest> | undefined, b: UpsertRoleRequest | PlainMessage<UpsertRoleRequest> | undefined): boolean {
    return proto3.util.equals(UpsertRoleRequest, a, b);
  }
}

/**
 * DeleteRoleRequest is a request to delete a role.
 *
 * @generated from message proto.DeleteRoleRequest
 */
export class DeleteRoleRequest extends Message<DeleteRoleRequest> {
  /**
   * Name is the role name to delete.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteRoleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteRoleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteRoleRequest {
    return new DeleteRoleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteRoleRequest {
    return new DeleteRoleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteRoleRequest {
    return new DeleteRoleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteRoleRequest | PlainMessage<DeleteRoleRequest> | undefined, b: DeleteRoleRequest | PlainMessage<DeleteRoleRequest> | undefined): boolean {
    return proto3.util.equals(DeleteRoleRequest, a, b);
  }
}

/**
 * MFAAuthenticateChallenge is a challenge for all MFA devices registered for a
 * user.
 *
 * @generated from message proto.MFAAuthenticateChallenge
 */
export class MFAAuthenticateChallenge extends Message<MFAAuthenticateChallenge> {
  /**
   * TOTP is a challenge for all TOTP devices registered for a user. When
   * this field is set, any TOTP device a user has registered can be used to
   * respond.
   *
   * @generated from field: proto.TOTPChallenge TOTP = 2;
   */
  TOTP?: TOTPChallenge;

  /**
   * WebauthnChallenge contains a Webauthn credential assertion used for
   * login/authentication ceremonies.
   * Credential assertions hold, among other information, a list of allowed
   * credentials for the ceremony (one for each U2F or Webauthn device
   * registered by the user).
   *
   * @generated from field: webauthn.CredentialAssertion WebauthnChallenge = 3;
   */
  WebauthnChallenge?: CredentialAssertion;

  /**
   * MFRequired indicates whether proceeding with the MFA ceremony will
   * grant access to the resource.
   *
   * If `MFA_REQUIRED_NO` is returned then the server may opt to end ongoing
   * communications, in case of streaming RPCs. It may also return empty
   * challenges for all other fields.
   *
   * @generated from field: proto.MFARequired MFARequired = 4;
   */
  MFARequired = MFARequired.MFA_REQUIRED_UNSPECIFIED;

  constructor(data?: PartialMessage<MFAAuthenticateChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.MFAAuthenticateChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "TOTP", kind: "message", T: TOTPChallenge },
    { no: 3, name: "WebauthnChallenge", kind: "message", T: CredentialAssertion },
    { no: 4, name: "MFARequired", kind: "enum", T: proto3.getEnumType(MFARequired) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFAAuthenticateChallenge {
    return new MFAAuthenticateChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFAAuthenticateChallenge {
    return new MFAAuthenticateChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFAAuthenticateChallenge {
    return new MFAAuthenticateChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MFAAuthenticateChallenge | PlainMessage<MFAAuthenticateChallenge> | undefined, b: MFAAuthenticateChallenge | PlainMessage<MFAAuthenticateChallenge> | undefined): boolean {
    return proto3.util.equals(MFAAuthenticateChallenge, a, b);
  }
}

/**
 * MFAAuthenticateResponse is a response to MFAAuthenticateChallenge using one
 * of the MFA devices registered for a user.
 *
 * @generated from message proto.MFAAuthenticateResponse
 */
export class MFAAuthenticateResponse extends Message<MFAAuthenticateResponse> {
  /**
   * @generated from oneof proto.MFAAuthenticateResponse.Response
   */
  Response: {
    /**
     * Removed: U2FResponse U2F = 1;
     *
     * @generated from field: proto.TOTPResponse TOTP = 2;
     */
    value: TOTPResponse;
    case: "TOTP";
  } | {
    /**
     * @generated from field: webauthn.CredentialAssertionResponse Webauthn = 3;
     */
    value: CredentialAssertionResponse;
    case: "Webauthn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MFAAuthenticateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.MFAAuthenticateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "TOTP", kind: "message", T: TOTPResponse, oneof: "Response" },
    { no: 3, name: "Webauthn", kind: "message", T: CredentialAssertionResponse, oneof: "Response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFAAuthenticateResponse {
    return new MFAAuthenticateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFAAuthenticateResponse {
    return new MFAAuthenticateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFAAuthenticateResponse {
    return new MFAAuthenticateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MFAAuthenticateResponse | PlainMessage<MFAAuthenticateResponse> | undefined, b: MFAAuthenticateResponse | PlainMessage<MFAAuthenticateResponse> | undefined): boolean {
    return proto3.util.equals(MFAAuthenticateResponse, a, b);
  }
}

/**
 * TOTPChallenge is a challenge for all TOTP devices registered for a user.
 *
 * TOTP protocol has no challenge per se, but the user has to provide a
 * valid token in response. TOTPChallenge exists only to signal to the user
 * that TOTP MFA is supported, which means that the user has a TOTP device
 * registered.
 *
 * @generated from message proto.TOTPChallenge
 */
export class TOTPChallenge extends Message<TOTPChallenge> {
  constructor(data?: PartialMessage<TOTPChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.TOTPChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TOTPChallenge {
    return new TOTPChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TOTPChallenge {
    return new TOTPChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TOTPChallenge {
    return new TOTPChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: TOTPChallenge | PlainMessage<TOTPChallenge> | undefined, b: TOTPChallenge | PlainMessage<TOTPChallenge> | undefined): boolean {
    return proto3.util.equals(TOTPChallenge, a, b);
  }
}

/**
 * TOTPResponse is a response to TOTPChallenge.
 *
 * @generated from message proto.TOTPResponse
 */
export class TOTPResponse extends Message<TOTPResponse> {
  /**
   * @generated from field: string Code = 1;
   */
  Code = "";

  constructor(data?: PartialMessage<TOTPResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.TOTPResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TOTPResponse {
    return new TOTPResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TOTPResponse {
    return new TOTPResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TOTPResponse {
    return new TOTPResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TOTPResponse | PlainMessage<TOTPResponse> | undefined, b: TOTPResponse | PlainMessage<TOTPResponse> | undefined): boolean {
    return proto3.util.equals(TOTPResponse, a, b);
  }
}

/**
 * MFARegisterChallenge is a challenge for registering a new MFA device.
 *
 * @generated from message proto.MFARegisterChallenge
 */
export class MFARegisterChallenge extends Message<MFARegisterChallenge> {
  /**
   * Request depends on the type of the MFA device being registered.
   *
   * @generated from oneof proto.MFARegisterChallenge.Request
   */
  Request: {
    /**
     * Removed: U2FRegisterChallenge U2F = 1;
     *
     * @generated from field: proto.TOTPRegisterChallenge TOTP = 2;
     */
    value: TOTPRegisterChallenge;
    case: "TOTP";
  } | {
    /**
     * @generated from field: webauthn.CredentialCreation Webauthn = 3;
     */
    value: CredentialCreation;
    case: "Webauthn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MFARegisterChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.MFARegisterChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "TOTP", kind: "message", T: TOTPRegisterChallenge, oneof: "Request" },
    { no: 3, name: "Webauthn", kind: "message", T: CredentialCreation, oneof: "Request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFARegisterChallenge {
    return new MFARegisterChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFARegisterChallenge {
    return new MFARegisterChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFARegisterChallenge {
    return new MFARegisterChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: MFARegisterChallenge | PlainMessage<MFARegisterChallenge> | undefined, b: MFARegisterChallenge | PlainMessage<MFARegisterChallenge> | undefined): boolean {
    return proto3.util.equals(MFARegisterChallenge, a, b);
  }
}

/**
 * MFARegisterResponse is a response to MFARegisterChallenge.
 *
 * @generated from message proto.MFARegisterResponse
 */
export class MFARegisterResponse extends Message<MFARegisterResponse> {
  /**
   * @generated from oneof proto.MFARegisterResponse.Response
   */
  Response: {
    /**
     * Removed: U2FRegisterResponse U2F = 1;
     *
     * @generated from field: proto.TOTPRegisterResponse TOTP = 2;
     */
    value: TOTPRegisterResponse;
    case: "TOTP";
  } | {
    /**
     * @generated from field: webauthn.CredentialCreationResponse Webauthn = 3;
     */
    value: CredentialCreationResponse;
    case: "Webauthn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MFARegisterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.MFARegisterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "TOTP", kind: "message", T: TOTPRegisterResponse, oneof: "Response" },
    { no: 3, name: "Webauthn", kind: "message", T: CredentialCreationResponse, oneof: "Response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MFARegisterResponse {
    return new MFARegisterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MFARegisterResponse {
    return new MFARegisterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MFARegisterResponse {
    return new MFARegisterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MFARegisterResponse | PlainMessage<MFARegisterResponse> | undefined, b: MFARegisterResponse | PlainMessage<MFARegisterResponse> | undefined): boolean {
    return proto3.util.equals(MFARegisterResponse, a, b);
  }
}

/**
 * TOTPRegisterChallenge is a challenge for registering a new TOTP device.
 *
 * @generated from message proto.TOTPRegisterChallenge
 */
export class TOTPRegisterChallenge extends Message<TOTPRegisterChallenge> {
  /**
   * Secret is a secret shared by client and server to generate codes.
   *
   * @generated from field: string Secret = 1;
   */
  Secret = "";

  /**
   * Issuer is the name of the Teleport cluster.
   *
   * @generated from field: string Issuer = 2;
   */
  Issuer = "";

  /**
   * PeriodSeconds is a period for TOTP code rotation, in seconds.
   *
   * @generated from field: uint32 PeriodSeconds = 3;
   */
  PeriodSeconds = 0;

  /**
   * Algorithm is the TOTP hashing algorithm.
   *
   * @generated from field: string Algorithm = 4;
   */
  Algorithm = "";

  /**
   * Digits is the number of digits in the TOTP code.
   *
   * @generated from field: uint32 Digits = 5;
   */
  Digits = 0;

  /**
   * Account is the account name for this user.
   *
   * @generated from field: string Account = 6;
   */
  Account = "";

  /**
   * QRCode is an optional field for the QR code in PNG format. Used to display a QR code
   * image in the UI.
   *
   * @generated from field: bytes QRCode = 7;
   */
  QRCode = new Uint8Array(0);

  /**
   * ID of the TOTP challenge.
   * Send this back in the TOTPRegisterResponse.
   *
   * @generated from field: string ID = 8;
   */
  ID = "";

  constructor(data?: PartialMessage<TOTPRegisterChallenge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.TOTPRegisterChallenge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Secret", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Issuer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "PeriodSeconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "Algorithm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Digits", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "Account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "QRCode", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TOTPRegisterChallenge {
    return new TOTPRegisterChallenge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TOTPRegisterChallenge {
    return new TOTPRegisterChallenge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TOTPRegisterChallenge {
    return new TOTPRegisterChallenge().fromJsonString(jsonString, options);
  }

  static equals(a: TOTPRegisterChallenge | PlainMessage<TOTPRegisterChallenge> | undefined, b: TOTPRegisterChallenge | PlainMessage<TOTPRegisterChallenge> | undefined): boolean {
    return proto3.util.equals(TOTPRegisterChallenge, a, b);
  }
}

/**
 * TOTPRegisterResponse is a response to TOTPRegisterChallenge.
 *
 * @generated from message proto.TOTPRegisterResponse
 */
export class TOTPRegisterResponse extends Message<TOTPRegisterResponse> {
  /**
   * @generated from field: string Code = 1;
   */
  Code = "";

  /**
   * ID of the TOTP challenge, as informed by the TOTPRegisterChallenge.
   *
   * @generated from field: string ID = 2;
   */
  ID = "";

  constructor(data?: PartialMessage<TOTPRegisterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.TOTPRegisterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TOTPRegisterResponse {
    return new TOTPRegisterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TOTPRegisterResponse {
    return new TOTPRegisterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TOTPRegisterResponse {
    return new TOTPRegisterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TOTPRegisterResponse | PlainMessage<TOTPRegisterResponse> | undefined, b: TOTPRegisterResponse | PlainMessage<TOTPRegisterResponse> | undefined): boolean {
    return proto3.util.equals(TOTPRegisterResponse, a, b);
  }
}

/**
 * Deprecated: Use [AuthService.AddMFADeviceSync] instead.
 *
 * @generated from message proto.AddMFADeviceRequest
 */
export class AddMFADeviceRequest extends Message<AddMFADeviceRequest> {
  constructor(data?: PartialMessage<AddMFADeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AddMFADeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddMFADeviceRequest {
    return new AddMFADeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddMFADeviceRequest {
    return new AddMFADeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddMFADeviceRequest {
    return new AddMFADeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddMFADeviceRequest | PlainMessage<AddMFADeviceRequest> | undefined, b: AddMFADeviceRequest | PlainMessage<AddMFADeviceRequest> | undefined): boolean {
    return proto3.util.equals(AddMFADeviceRequest, a, b);
  }
}

/**
 * Deprecated: Use [AuthService.AddMFADeviceSync] instead.
 *
 * @generated from message proto.AddMFADeviceResponse
 */
export class AddMFADeviceResponse extends Message<AddMFADeviceResponse> {
  constructor(data?: PartialMessage<AddMFADeviceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AddMFADeviceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddMFADeviceResponse {
    return new AddMFADeviceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddMFADeviceResponse {
    return new AddMFADeviceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddMFADeviceResponse {
    return new AddMFADeviceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AddMFADeviceResponse | PlainMessage<AddMFADeviceResponse> | undefined, b: AddMFADeviceResponse | PlainMessage<AddMFADeviceResponse> | undefined): boolean {
    return proto3.util.equals(AddMFADeviceResponse, a, b);
  }
}

/**
 * Deprecated: Use [AuthService.DeleteMFADeviceSync] instead.
 *
 * @generated from message proto.DeleteMFADeviceRequest
 */
export class DeleteMFADeviceRequest extends Message<DeleteMFADeviceRequest> {
  constructor(data?: PartialMessage<DeleteMFADeviceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteMFADeviceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteMFADeviceRequest {
    return new DeleteMFADeviceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteMFADeviceRequest {
    return new DeleteMFADeviceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteMFADeviceRequest {
    return new DeleteMFADeviceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteMFADeviceRequest | PlainMessage<DeleteMFADeviceRequest> | undefined, b: DeleteMFADeviceRequest | PlainMessage<DeleteMFADeviceRequest> | undefined): boolean {
    return proto3.util.equals(DeleteMFADeviceRequest, a, b);
  }
}

/**
 * Deprecated: Use [AuthService.DeleteMFADeviceSync] instead.
 *
 * @generated from message proto.DeleteMFADeviceResponse
 */
export class DeleteMFADeviceResponse extends Message<DeleteMFADeviceResponse> {
  constructor(data?: PartialMessage<DeleteMFADeviceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteMFADeviceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteMFADeviceResponse {
    return new DeleteMFADeviceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteMFADeviceResponse {
    return new DeleteMFADeviceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteMFADeviceResponse {
    return new DeleteMFADeviceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteMFADeviceResponse | PlainMessage<DeleteMFADeviceResponse> | undefined, b: DeleteMFADeviceResponse | PlainMessage<DeleteMFADeviceResponse> | undefined): boolean {
    return proto3.util.equals(DeleteMFADeviceResponse, a, b);
  }
}

/**
 * DeleteMFADeviceSyncRequest is a request to delete a MFA device (nonstream).
 *
 * @generated from message proto.DeleteMFADeviceSyncRequest
 */
export class DeleteMFADeviceSyncRequest extends Message<DeleteMFADeviceSyncRequest> {
  /**
   * TokenID is the ID of a user token that will be used to verify this request.
   *
   * Token types accepted are:
   *   - Recovery approved token that is obtained with RPC VerifyAccountRecovery
   *   - Privilege token that is obtained with RPC CreatePrivilegeToken
   *
   * Authenticated users can delete a device by providing an ExistingMFAResponse
   * instead.
   *
   * @generated from field: string TokenID = 1;
   */
  TokenID = "";

  /**
   * DeviceName is the name of the device to delete.
   *
   * @generated from field: string DeviceName = 2;
   */
  DeviceName = "";

  /**
   * ExistingMFAResponse is an MFA response from an existing device.
   *
   * May be provided as an alternative to TokenID.
   *
   * @generated from field: proto.MFAAuthenticateResponse ExistingMFAResponse = 3;
   */
  ExistingMFAResponse?: MFAAuthenticateResponse;

  constructor(data?: PartialMessage<DeleteMFADeviceSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteMFADeviceSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "DeviceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ExistingMFAResponse", kind: "message", T: MFAAuthenticateResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteMFADeviceSyncRequest {
    return new DeleteMFADeviceSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteMFADeviceSyncRequest {
    return new DeleteMFADeviceSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteMFADeviceSyncRequest {
    return new DeleteMFADeviceSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteMFADeviceSyncRequest | PlainMessage<DeleteMFADeviceSyncRequest> | undefined, b: DeleteMFADeviceSyncRequest | PlainMessage<DeleteMFADeviceSyncRequest> | undefined): boolean {
    return proto3.util.equals(DeleteMFADeviceSyncRequest, a, b);
  }
}

/**
 * AddMFADeviceSyncRequest is a request to add a MFA device (nonstream).
 *
 * @generated from message proto.AddMFADeviceSyncRequest
 */
export class AddMFADeviceSyncRequest extends Message<AddMFADeviceSyncRequest> {
  /**
   * TokenID is the ID of a user token that will be used to verify this request.
   *
   * Token types accepted are:
   *  - Privilege token that is obtained with RPC CreatePrivilegeToken
   *
   * An authenticated user can register a new device using only a
   * NewMFAResponse. See [ContextUser].
   *
   * @generated from field: string TokenID = 1;
   */
  TokenID = "";

  /**
   * ContextUser allows registering a device for the authenticated user.
   *
   * Default option if no other is provided.
   *
   * @generated from field: proto.ContextUser ContextUser = 5;
   */
  ContextUser?: ContextUser;

  /**
   * NewDeviceName is the name of a new mfa device.
   *
   * @generated from field: string NewDeviceName = 2;
   */
  NewDeviceName = "";

  /**
   * NewMFAResponse is a user's new mfa response to a mfa register challenge.
   *
   * @generated from field: proto.MFARegisterResponse NewMFAResponse = 3;
   */
  NewMFAResponse?: MFARegisterResponse;

  /**
   * DeviceUsage is the requested usage for the device.
   * Defaults to DEVICE_USAGE_MFA.
   *
   * @generated from field: proto.DeviceUsage DeviceUsage = 4;
   */
  DeviceUsage = DeviceUsage.UNSPECIFIED;

  constructor(data?: PartialMessage<AddMFADeviceSyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AddMFADeviceSyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ContextUser", kind: "message", T: ContextUser },
    { no: 2, name: "NewDeviceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "NewMFAResponse", kind: "message", T: MFARegisterResponse },
    { no: 4, name: "DeviceUsage", kind: "enum", T: proto3.getEnumType(DeviceUsage) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddMFADeviceSyncRequest {
    return new AddMFADeviceSyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddMFADeviceSyncRequest {
    return new AddMFADeviceSyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddMFADeviceSyncRequest {
    return new AddMFADeviceSyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AddMFADeviceSyncRequest | PlainMessage<AddMFADeviceSyncRequest> | undefined, b: AddMFADeviceSyncRequest | PlainMessage<AddMFADeviceSyncRequest> | undefined): boolean {
    return proto3.util.equals(AddMFADeviceSyncRequest, a, b);
  }
}

/**
 * AddMFADeviceSyncResponse is a response to AddMFADeviceSyncRequest.
 *
 * @generated from message proto.AddMFADeviceSyncResponse
 */
export class AddMFADeviceSyncResponse extends Message<AddMFADeviceSyncResponse> {
  /**
   * @generated from field: types.MFADevice Device = 1;
   */
  Device?: MFADevice;

  constructor(data?: PartialMessage<AddMFADeviceSyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AddMFADeviceSyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Device", kind: "message", T: MFADevice },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddMFADeviceSyncResponse {
    return new AddMFADeviceSyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddMFADeviceSyncResponse {
    return new AddMFADeviceSyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddMFADeviceSyncResponse {
    return new AddMFADeviceSyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AddMFADeviceSyncResponse | PlainMessage<AddMFADeviceSyncResponse> | undefined, b: AddMFADeviceSyncResponse | PlainMessage<AddMFADeviceSyncResponse> | undefined): boolean {
    return proto3.util.equals(AddMFADeviceSyncResponse, a, b);
  }
}

/**
 * GetMFADeviceRequest is a request for MFA devices for the calling user.
 *
 * @generated from message proto.GetMFADevicesRequest
 */
export class GetMFADevicesRequest extends Message<GetMFADevicesRequest> {
  /**
   * TokenID is an optional field for the ID of a user token that will be used to
   * verify this request. Token is only required if an unauthenticated user wants to view their
   * list of devices eg: during account recovery process. An empty field implies the logged in
   * user wants to view their devices.
   * Token types accepted are:
   *  - Recovery approved token that is obtained after successful invocation of RPC
   *  VerifyAccountRecovery
   *
   * @generated from field: string TokenID = 1;
   */
  TokenID = "";

  constructor(data?: PartialMessage<GetMFADevicesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetMFADevicesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMFADevicesRequest {
    return new GetMFADevicesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMFADevicesRequest {
    return new GetMFADevicesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMFADevicesRequest {
    return new GetMFADevicesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetMFADevicesRequest | PlainMessage<GetMFADevicesRequest> | undefined, b: GetMFADevicesRequest | PlainMessage<GetMFADevicesRequest> | undefined): boolean {
    return proto3.util.equals(GetMFADevicesRequest, a, b);
  }
}

/**
 * GetMFADeviceResponse is a response for GetMFADevices RPC.
 *
 * @generated from message proto.GetMFADevicesResponse
 */
export class GetMFADevicesResponse extends Message<GetMFADevicesResponse> {
  /**
   * @generated from field: repeated types.MFADevice Devices = 1;
   */
  Devices: MFADevice[] = [];

  constructor(data?: PartialMessage<GetMFADevicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetMFADevicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Devices", kind: "message", T: MFADevice, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetMFADevicesResponse {
    return new GetMFADevicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetMFADevicesResponse {
    return new GetMFADevicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetMFADevicesResponse {
    return new GetMFADevicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetMFADevicesResponse | PlainMessage<GetMFADevicesResponse> | undefined, b: GetMFADevicesResponse | PlainMessage<GetMFADevicesResponse> | undefined): boolean {
    return proto3.util.equals(GetMFADevicesResponse, a, b);
  }
}

/**
 * Deprecated: Use [AuthService.GenerateUserCerts] instead.
 *
 * @generated from message proto.UserSingleUseCertsRequest
 */
export class UserSingleUseCertsRequest extends Message<UserSingleUseCertsRequest> {
  constructor(data?: PartialMessage<UserSingleUseCertsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UserSingleUseCertsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSingleUseCertsRequest {
    return new UserSingleUseCertsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSingleUseCertsRequest {
    return new UserSingleUseCertsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSingleUseCertsRequest {
    return new UserSingleUseCertsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UserSingleUseCertsRequest | PlainMessage<UserSingleUseCertsRequest> | undefined, b: UserSingleUseCertsRequest | PlainMessage<UserSingleUseCertsRequest> | undefined): boolean {
    return proto3.util.equals(UserSingleUseCertsRequest, a, b);
  }
}

/**
 * Deprecated: Use [AuthService.GenerateUserCerts] instead.
 *
 * @generated from message proto.UserSingleUseCertsResponse
 */
export class UserSingleUseCertsResponse extends Message<UserSingleUseCertsResponse> {
  constructor(data?: PartialMessage<UserSingleUseCertsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UserSingleUseCertsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserSingleUseCertsResponse {
    return new UserSingleUseCertsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserSingleUseCertsResponse {
    return new UserSingleUseCertsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserSingleUseCertsResponse {
    return new UserSingleUseCertsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UserSingleUseCertsResponse | PlainMessage<UserSingleUseCertsResponse> | undefined, b: UserSingleUseCertsResponse | PlainMessage<UserSingleUseCertsResponse> | undefined): boolean {
    return proto3.util.equals(UserSingleUseCertsResponse, a, b);
  }
}

/**
 * IsMFARequiredRequest is a request to check whether MFA is required to access
 * the Target.
 *
 * @generated from message proto.IsMFARequiredRequest
 */
export class IsMFARequiredRequest extends Message<IsMFARequiredRequest> {
  /**
   * @generated from oneof proto.IsMFARequiredRequest.Target
   */
  Target: {
    /**
     * KubernetesCluster specifies the target kubernetes cluster.
     *
     * @generated from field: string KubernetesCluster = 1;
     */
    value: string;
    case: "KubernetesCluster";
  } | {
    /**
     * RouteToDatabase specifies the target database proxy name.
     *
     * @generated from field: proto.RouteToDatabase Database = 2;
     */
    value: RouteToDatabase;
    case: "Database";
  } | {
    /**
     * Node specifies the target SSH node.
     *
     * @generated from field: proto.NodeLogin Node = 3;
     */
    value: NodeLogin;
    case: "Node";
  } | {
    /**
     * WindowsDesktop specifies the target Windows Desktop.
     *
     * @generated from field: proto.RouteToWindowsDesktop WindowsDesktop = 4;
     */
    value: RouteToWindowsDesktop;
    case: "WindowsDesktop";
  } | {
    /**
     * AdminAction specifies an admin action.
     *
     * @generated from field: proto.AdminAction AdminAction = 5;
     */
    value: AdminAction;
    case: "AdminAction";
  } | {
    /**
     * App specifies the target App.
     *
     * @generated from field: proto.RouteToApp App = 6;
     */
    value: RouteToApp;
    case: "App";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<IsMFARequiredRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.IsMFARequiredRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "KubernetesCluster", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "Target" },
    { no: 2, name: "Database", kind: "message", T: RouteToDatabase, oneof: "Target" },
    { no: 3, name: "Node", kind: "message", T: NodeLogin, oneof: "Target" },
    { no: 4, name: "WindowsDesktop", kind: "message", T: RouteToWindowsDesktop, oneof: "Target" },
    { no: 5, name: "AdminAction", kind: "message", T: AdminAction, oneof: "Target" },
    { no: 6, name: "App", kind: "message", T: RouteToApp, oneof: "Target" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsMFARequiredRequest {
    return new IsMFARequiredRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsMFARequiredRequest {
    return new IsMFARequiredRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsMFARequiredRequest {
    return new IsMFARequiredRequest().fromJsonString(jsonString, options);
  }

  static equals(a: IsMFARequiredRequest | PlainMessage<IsMFARequiredRequest> | undefined, b: IsMFARequiredRequest | PlainMessage<IsMFARequiredRequest> | undefined): boolean {
    return proto3.util.equals(IsMFARequiredRequest, a, b);
  }
}

/**
 * StreamSessionEventsRequest is a request containing needed data to fetch a session recording.
 *
 * @generated from message proto.StreamSessionEventsRequest
 */
export class StreamSessionEventsRequest extends Message<StreamSessionEventsRequest> {
  /**
   * SessionID is the ID for a given session in an UUIDv4 format.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  /**
   * StartIndex is the index of the event to resume the stream after.
   * A StartIndex of 0 creates a new stream.
   *
   * @generated from field: int32 StartIndex = 2;
   */
  StartIndex = 0;

  constructor(data?: PartialMessage<StreamSessionEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.StreamSessionEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "StartIndex", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamSessionEventsRequest {
    return new StreamSessionEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamSessionEventsRequest {
    return new StreamSessionEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamSessionEventsRequest {
    return new StreamSessionEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamSessionEventsRequest | PlainMessage<StreamSessionEventsRequest> | undefined, b: StreamSessionEventsRequest | PlainMessage<StreamSessionEventsRequest> | undefined): boolean {
    return proto3.util.equals(StreamSessionEventsRequest, a, b);
  }
}

/**
 * NodeLogin specifies an SSH node and OS login.
 *
 * @generated from message proto.NodeLogin
 */
export class NodeLogin extends Message<NodeLogin> {
  /**
   * Node can be node's hostname or UUID.
   *
   * @generated from field: string Node = 1;
   */
  Node = "";

  /**
   * Login is the OS login name.
   *
   * @generated from field: string Login = 2;
   */
  Login = "";

  constructor(data?: PartialMessage<NodeLogin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.NodeLogin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Node", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Login", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeLogin {
    return new NodeLogin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeLogin {
    return new NodeLogin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeLogin {
    return new NodeLogin().fromJsonString(jsonString, options);
  }

  static equals(a: NodeLogin | PlainMessage<NodeLogin> | undefined, b: NodeLogin | PlainMessage<NodeLogin> | undefined): boolean {
    return proto3.util.equals(NodeLogin, a, b);
  }
}

/**
 * AdminAction specifies an admin action.
 *
 * @generated from message proto.AdminAction
 */
export class AdminAction extends Message<AdminAction> {
  constructor(data?: PartialMessage<AdminAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AdminAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminAction {
    return new AdminAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminAction {
    return new AdminAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminAction {
    return new AdminAction().fromJsonString(jsonString, options);
  }

  static equals(a: AdminAction | PlainMessage<AdminAction> | undefined, b: AdminAction | PlainMessage<AdminAction> | undefined): boolean {
    return proto3.util.equals(AdminAction, a, b);
  }
}

/**
 * IsMFARequiredResponse is a response for MFA requirement check.
 *
 * @generated from message proto.IsMFARequiredResponse
 */
export class IsMFARequiredResponse extends Message<IsMFARequiredResponse> {
  /**
   * Required is a simplified view over [MFARequired].
   *
   * @generated from field: bool Required = 1;
   */
  Required = false;

  /**
   * MFARequired informs whether MFA is required to access the corresponding
   * resource.
   *
   * @generated from field: proto.MFARequired MFARequired = 2;
   */
  MFARequired = MFARequired.MFA_REQUIRED_UNSPECIFIED;

  constructor(data?: PartialMessage<IsMFARequiredResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.IsMFARequiredResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "MFARequired", kind: "enum", T: proto3.getEnumType(MFARequired) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsMFARequiredResponse {
    return new IsMFARequiredResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsMFARequiredResponse {
    return new IsMFARequiredResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsMFARequiredResponse {
    return new IsMFARequiredResponse().fromJsonString(jsonString, options);
  }

  static equals(a: IsMFARequiredResponse | PlainMessage<IsMFARequiredResponse> | undefined, b: IsMFARequiredResponse | PlainMessage<IsMFARequiredResponse> | undefined): boolean {
    return proto3.util.equals(IsMFARequiredResponse, a, b);
  }
}

/**
 * @generated from message proto.GetEventsRequest
 */
export class GetEventsRequest extends Message<GetEventsRequest> {
  /**
   * Namespace, if not set, defaults to 'default'
   *
   * @generated from field: string Namespace = 1;
   */
  Namespace = "";

  /**
   * StartDate is the oldest date of returned events
   *
   * @generated from field: google.protobuf.Timestamp StartDate = 2;
   */
  StartDate?: Timestamp;

  /**
   * EndDate is the newest date of returned events
   *
   * @generated from field: google.protobuf.Timestamp EndDate = 3;
   */
  EndDate?: Timestamp;

  /**
   * EventTypes is optional, if not set, returns all events
   *
   * @generated from field: repeated string EventTypes = 4;
   */
  EventTypes: string[] = [];

  /**
   * Limit is the maximum amount of events returned
   *
   * @generated from field: int32 Limit = 5;
   */
  Limit = 0;

  /**
   * StartKey is used to resume a query in order to enable pagination.
   * If the previous response had LastKey set then this should be
   * set to its value. Otherwise leave empty.
   *
   * @generated from field: string StartKey = 6;
   */
  StartKey = "";

  /**
   * Order specifies an ascending or descending order of events.
   * A value of 0 means a descending order and a value of 1 means an ascending order.
   *
   * @generated from field: proto.Order Order = 7;
   */
  Order = Order.DESCENDING;

  constructor(data?: PartialMessage<GetEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "StartDate", kind: "message", T: Timestamp },
    { no: 3, name: "EndDate", kind: "message", T: Timestamp },
    { no: 4, name: "EventTypes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "StartKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "Order", kind: "enum", T: proto3.getEnumType(Order) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEventsRequest {
    return new GetEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEventsRequest {
    return new GetEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEventsRequest {
    return new GetEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetEventsRequest | PlainMessage<GetEventsRequest> | undefined, b: GetEventsRequest | PlainMessage<GetEventsRequest> | undefined): boolean {
    return proto3.util.equals(GetEventsRequest, a, b);
  }
}

/**
 * @generated from message proto.GetSessionEventsRequest
 */
export class GetSessionEventsRequest extends Message<GetSessionEventsRequest> {
  /**
   * StartDate is the oldest date of returned events
   *
   * @generated from field: google.protobuf.Timestamp StartDate = 1;
   */
  StartDate?: Timestamp;

  /**
   * EndDate is the newest date of returned events
   *
   * @generated from field: google.protobuf.Timestamp EndDate = 2;
   */
  EndDate?: Timestamp;

  /**
   * Limit is the maximum amount of events to retrieve.
   *
   * @generated from field: int32 Limit = 3;
   */
  Limit = 0;

  /**
   * StartKey is used to resume a query in order to enable pagination.
   * If the previous response had LastKey set then this should be
   * set to its value. Otherwise leave empty.
   *
   * @generated from field: string StartKey = 4;
   */
  StartKey = "";

  /**
   * Order specifies an ascending or descending order of events.
   * A value of 0 means a descending order and a value of 1 means an ascending order.
   *
   * @generated from field: proto.Order Order = 5;
   */
  Order = Order.DESCENDING;

  constructor(data?: PartialMessage<GetSessionEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSessionEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "StartDate", kind: "message", T: Timestamp },
    { no: 2, name: "EndDate", kind: "message", T: Timestamp },
    { no: 3, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "StartKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Order", kind: "enum", T: proto3.getEnumType(Order) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSessionEventsRequest {
    return new GetSessionEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSessionEventsRequest {
    return new GetSessionEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSessionEventsRequest {
    return new GetSessionEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSessionEventsRequest | PlainMessage<GetSessionEventsRequest> | undefined, b: GetSessionEventsRequest | PlainMessage<GetSessionEventsRequest> | undefined): boolean {
    return proto3.util.equals(GetSessionEventsRequest, a, b);
  }
}

/**
 * @generated from message proto.Events
 */
export class Events extends Message<Events> {
  /**
   * Items is a list of typed gRPC formatted audit events.
   *
   * @generated from field: repeated events.OneOf Items = 1;
   */
  Items: OneOf[] = [];

  /**
   * the key of the last event if the returned set did not contain all events found i.e limit <
   * actual amount. this is the key clients can supply in another API request to continue fetching
   * events from the previous last position
   *
   * @generated from field: string LastKey = 2;
   */
  LastKey = "";

  constructor(data?: PartialMessage<Events>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.Events";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Items", kind: "message", T: OneOf, repeated: true },
    { no: 2, name: "LastKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Events {
    return new Events().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Events {
    return new Events().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Events {
    return new Events().fromJsonString(jsonString, options);
  }

  static equals(a: Events | PlainMessage<Events> | undefined, b: Events | PlainMessage<Events> | undefined): boolean {
    return proto3.util.equals(Events, a, b);
  }
}

/**
 * @generated from message proto.GetLocksRequest
 */
export class GetLocksRequest extends Message<GetLocksRequest> {
  /**
   * Targets is a list of targets. Every returned lock must match at least
   * one of the targets.
   *
   * @generated from field: repeated types.LockTarget Targets = 1;
   */
  Targets: LockTarget[] = [];

  /**
   * InForceOnly specifies whether to return only those locks that are in force.
   *
   * @generated from field: bool InForceOnly = 2;
   */
  InForceOnly = false;

  constructor(data?: PartialMessage<GetLocksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetLocksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Targets", kind: "message", T: LockTarget, repeated: true },
    { no: 2, name: "InForceOnly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLocksRequest {
    return new GetLocksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLocksRequest {
    return new GetLocksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLocksRequest {
    return new GetLocksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLocksRequest | PlainMessage<GetLocksRequest> | undefined, b: GetLocksRequest | PlainMessage<GetLocksRequest> | undefined): boolean {
    return proto3.util.equals(GetLocksRequest, a, b);
  }
}

/**
 * @generated from message proto.GetLocksResponse
 */
export class GetLocksResponse extends Message<GetLocksResponse> {
  /**
   * Locks is a list of locks.
   *
   * @generated from field: repeated types.LockV2 Locks = 1;
   */
  Locks: LockV2[] = [];

  constructor(data?: PartialMessage<GetLocksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetLocksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Locks", kind: "message", T: LockV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLocksResponse {
    return new GetLocksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLocksResponse {
    return new GetLocksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLocksResponse {
    return new GetLocksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLocksResponse | PlainMessage<GetLocksResponse> | undefined, b: GetLocksResponse | PlainMessage<GetLocksResponse> | undefined): boolean {
    return proto3.util.equals(GetLocksResponse, a, b);
  }
}

/**
 * @generated from message proto.GetLockRequest
 */
export class GetLockRequest extends Message<GetLockRequest> {
  /**
   * Name is the name of the lock to get.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<GetLockRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetLockRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLockRequest {
    return new GetLockRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLockRequest {
    return new GetLockRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLockRequest {
    return new GetLockRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLockRequest | PlainMessage<GetLockRequest> | undefined, b: GetLockRequest | PlainMessage<GetLockRequest> | undefined): boolean {
    return proto3.util.equals(GetLockRequest, a, b);
  }
}

/**
 * @generated from message proto.DeleteLockRequest
 */
export class DeleteLockRequest extends Message<DeleteLockRequest> {
  /**
   * Name is the name of the lock to delete.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteLockRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteLockRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteLockRequest {
    return new DeleteLockRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteLockRequest {
    return new DeleteLockRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteLockRequest {
    return new DeleteLockRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteLockRequest | PlainMessage<DeleteLockRequest> | undefined, b: DeleteLockRequest | PlainMessage<DeleteLockRequest> | undefined): boolean {
    return proto3.util.equals(DeleteLockRequest, a, b);
  }
}

/**
 * @generated from message proto.ReplaceRemoteLocksRequest
 */
export class ReplaceRemoteLocksRequest extends Message<ReplaceRemoteLocksRequest> {
  /**
   * ClusterName identifies the cluster from which the locks originate.
   *
   * @generated from field: string ClusterName = 1;
   */
  ClusterName = "";

  /**
   * Locks is a list of new remote locks to store.
   *
   * @generated from field: repeated types.LockV2 Locks = 2;
   */
  Locks: LockV2[] = [];

  constructor(data?: PartialMessage<ReplaceRemoteLocksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ReplaceRemoteLocksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ClusterName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Locks", kind: "message", T: LockV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReplaceRemoteLocksRequest {
    return new ReplaceRemoteLocksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReplaceRemoteLocksRequest {
    return new ReplaceRemoteLocksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReplaceRemoteLocksRequest {
    return new ReplaceRemoteLocksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReplaceRemoteLocksRequest | PlainMessage<ReplaceRemoteLocksRequest> | undefined, b: ReplaceRemoteLocksRequest | PlainMessage<ReplaceRemoteLocksRequest> | undefined): boolean {
    return proto3.util.equals(ReplaceRemoteLocksRequest, a, b);
  }
}

/**
 * GetWindowsDesktopServicesResponse contains all registered Windows desktop services.
 *
 * @generated from message proto.GetWindowsDesktopServicesResponse
 */
export class GetWindowsDesktopServicesResponse extends Message<GetWindowsDesktopServicesResponse> {
  /**
   * Services is a list of Windows desktop services.
   *
   * @generated from field: repeated types.WindowsDesktopServiceV3 services = 1;
   */
  services: WindowsDesktopServiceV3[] = [];

  constructor(data?: PartialMessage<GetWindowsDesktopServicesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWindowsDesktopServicesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "services", kind: "message", T: WindowsDesktopServiceV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWindowsDesktopServicesResponse {
    return new GetWindowsDesktopServicesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWindowsDesktopServicesResponse {
    return new GetWindowsDesktopServicesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWindowsDesktopServicesResponse {
    return new GetWindowsDesktopServicesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWindowsDesktopServicesResponse | PlainMessage<GetWindowsDesktopServicesResponse> | undefined, b: GetWindowsDesktopServicesResponse | PlainMessage<GetWindowsDesktopServicesResponse> | undefined): boolean {
    return proto3.util.equals(GetWindowsDesktopServicesResponse, a, b);
  }
}

/**
 * GetWindowsDesktopServiceRequest is a request for a specific Windows Desktop Service.
 *
 * @generated from message proto.GetWindowsDesktopServiceRequest
 */
export class GetWindowsDesktopServiceRequest extends Message<GetWindowsDesktopServiceRequest> {
  /**
   * Name is the name of the Windows Desktop Service to be requested.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<GetWindowsDesktopServiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWindowsDesktopServiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWindowsDesktopServiceRequest {
    return new GetWindowsDesktopServiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWindowsDesktopServiceRequest {
    return new GetWindowsDesktopServiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWindowsDesktopServiceRequest {
    return new GetWindowsDesktopServiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetWindowsDesktopServiceRequest | PlainMessage<GetWindowsDesktopServiceRequest> | undefined, b: GetWindowsDesktopServiceRequest | PlainMessage<GetWindowsDesktopServiceRequest> | undefined): boolean {
    return proto3.util.equals(GetWindowsDesktopServiceRequest, a, b);
  }
}

/**
 * GetWindowsDesktopServiceResponse contains the requested WindowsDesktopService
 *
 * @generated from message proto.GetWindowsDesktopServiceResponse
 */
export class GetWindowsDesktopServiceResponse extends Message<GetWindowsDesktopServiceResponse> {
  /**
   * Service is the requested Windows Desktop Service.
   *
   * @generated from field: types.WindowsDesktopServiceV3 service = 1;
   */
  service?: WindowsDesktopServiceV3;

  constructor(data?: PartialMessage<GetWindowsDesktopServiceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWindowsDesktopServiceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "service", kind: "message", T: WindowsDesktopServiceV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWindowsDesktopServiceResponse {
    return new GetWindowsDesktopServiceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWindowsDesktopServiceResponse {
    return new GetWindowsDesktopServiceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWindowsDesktopServiceResponse {
    return new GetWindowsDesktopServiceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWindowsDesktopServiceResponse | PlainMessage<GetWindowsDesktopServiceResponse> | undefined, b: GetWindowsDesktopServiceResponse | PlainMessage<GetWindowsDesktopServiceResponse> | undefined): boolean {
    return proto3.util.equals(GetWindowsDesktopServiceResponse, a, b);
  }
}

/**
 * DeleteWindowsDesktopServiceRequest is a request to delete a Windows desktop service.
 *
 * @generated from message proto.DeleteWindowsDesktopServiceRequest
 */
export class DeleteWindowsDesktopServiceRequest extends Message<DeleteWindowsDesktopServiceRequest> {
  /**
   * Name is the Windows desktop service name.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteWindowsDesktopServiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteWindowsDesktopServiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWindowsDesktopServiceRequest {
    return new DeleteWindowsDesktopServiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWindowsDesktopServiceRequest {
    return new DeleteWindowsDesktopServiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWindowsDesktopServiceRequest {
    return new DeleteWindowsDesktopServiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWindowsDesktopServiceRequest | PlainMessage<DeleteWindowsDesktopServiceRequest> | undefined, b: DeleteWindowsDesktopServiceRequest | PlainMessage<DeleteWindowsDesktopServiceRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWindowsDesktopServiceRequest, a, b);
  }
}

/**
 * GetWindowsDesktopsResponse contains all registered Windows desktop hosts.
 *
 * @generated from message proto.GetWindowsDesktopsResponse
 */
export class GetWindowsDesktopsResponse extends Message<GetWindowsDesktopsResponse> {
  /**
   * Servers is a list of Windows desktop hosts.
   *
   * @generated from field: repeated types.WindowsDesktopV3 Desktops = 1;
   */
  Desktops: WindowsDesktopV3[] = [];

  constructor(data?: PartialMessage<GetWindowsDesktopsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetWindowsDesktopsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Desktops", kind: "message", T: WindowsDesktopV3, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetWindowsDesktopsResponse {
    return new GetWindowsDesktopsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetWindowsDesktopsResponse {
    return new GetWindowsDesktopsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetWindowsDesktopsResponse {
    return new GetWindowsDesktopsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetWindowsDesktopsResponse | PlainMessage<GetWindowsDesktopsResponse> | undefined, b: GetWindowsDesktopsResponse | PlainMessage<GetWindowsDesktopsResponse> | undefined): boolean {
    return proto3.util.equals(GetWindowsDesktopsResponse, a, b);
  }
}

/**
 * DeleteWindowsDesktopRequest is a request to delete a Windows
 * desktop host. If HostID is not specified, all Windows desktops with
 * specified Name will be deleted
 *
 * @generated from message proto.DeleteWindowsDesktopRequest
 */
export class DeleteWindowsDesktopRequest extends Message<DeleteWindowsDesktopRequest> {
  /**
   * Name is the name of the Windows desktop host.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * HostID is the ID of the Windows Desktop Service reporting the desktop.
   *
   * @generated from field: string HostID = 2;
   */
  HostID = "";

  constructor(data?: PartialMessage<DeleteWindowsDesktopRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteWindowsDesktopRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "HostID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteWindowsDesktopRequest {
    return new DeleteWindowsDesktopRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteWindowsDesktopRequest {
    return new DeleteWindowsDesktopRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteWindowsDesktopRequest {
    return new DeleteWindowsDesktopRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteWindowsDesktopRequest | PlainMessage<DeleteWindowsDesktopRequest> | undefined, b: DeleteWindowsDesktopRequest | PlainMessage<DeleteWindowsDesktopRequest> | undefined): boolean {
    return proto3.util.equals(DeleteWindowsDesktopRequest, a, b);
  }
}

/**
 * WindowsDesktopCertRequest is a request to generate a client certificate used
 * for Windows RDP authentication.
 *
 * @generated from message proto.WindowsDesktopCertRequest
 */
export class WindowsDesktopCertRequest extends Message<WindowsDesktopCertRequest> {
  /**
   * CSR is the request to sign in PEM format.
   *
   * @generated from field: bytes CSR = 1;
   */
  CSR = new Uint8Array(0);

  /**
   * CRLEndpoint is the address of the CRL for this certificate.
   *
   * @generated from field: string CRLEndpoint = 2;
   */
  CRLEndpoint = "";

  /**
   * TTL is the certificate validity period.
   *
   * @generated from field: int64 TTL = 3;
   */
  TTL = protoInt64.zero;

  constructor(data?: PartialMessage<WindowsDesktopCertRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.WindowsDesktopCertRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CSR", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "CRLEndpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TTL", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopCertRequest {
    return new WindowsDesktopCertRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopCertRequest {
    return new WindowsDesktopCertRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopCertRequest {
    return new WindowsDesktopCertRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopCertRequest | PlainMessage<WindowsDesktopCertRequest> | undefined, b: WindowsDesktopCertRequest | PlainMessage<WindowsDesktopCertRequest> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopCertRequest, a, b);
  }
}

/**
 * WindowsDesktopCertResponse contains the signed Windows RDP certificate.
 *
 * @generated from message proto.WindowsDesktopCertResponse
 */
export class WindowsDesktopCertResponse extends Message<WindowsDesktopCertResponse> {
  /**
   * Cert is the signed certificate in PEM format.
   *
   * @generated from field: bytes Cert = 1;
   */
  Cert = new Uint8Array(0);

  constructor(data?: PartialMessage<WindowsDesktopCertResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.WindowsDesktopCertResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Cert", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WindowsDesktopCertResponse {
    return new WindowsDesktopCertResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WindowsDesktopCertResponse {
    return new WindowsDesktopCertResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WindowsDesktopCertResponse {
    return new WindowsDesktopCertResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WindowsDesktopCertResponse | PlainMessage<WindowsDesktopCertResponse> | undefined, b: WindowsDesktopCertResponse | PlainMessage<WindowsDesktopCertResponse> | undefined): boolean {
    return proto3.util.equals(WindowsDesktopCertResponse, a, b);
  }
}

/**
 * Response message for GetDesktopBootstrapScript.
 *
 * @generated from message proto.DesktopBootstrapScriptResponse
 */
export class DesktopBootstrapScriptResponse extends Message<DesktopBootstrapScriptResponse> {
  /**
   * The PowerShell script content.
   *
   * @generated from field: string Script = 1;
   */
  Script = "";

  constructor(data?: PartialMessage<DesktopBootstrapScriptResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DesktopBootstrapScriptResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DesktopBootstrapScriptResponse {
    return new DesktopBootstrapScriptResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DesktopBootstrapScriptResponse {
    return new DesktopBootstrapScriptResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DesktopBootstrapScriptResponse {
    return new DesktopBootstrapScriptResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DesktopBootstrapScriptResponse | PlainMessage<DesktopBootstrapScriptResponse> | undefined, b: DesktopBootstrapScriptResponse | PlainMessage<DesktopBootstrapScriptResponse> | undefined): boolean {
    return proto3.util.equals(DesktopBootstrapScriptResponse, a, b);
  }
}

/**
 * ListSAMLIdPServiceProvidersRequest is a request for a paginated list of SAML IdP service providers.
 *
 * @generated from message proto.ListSAMLIdPServiceProvidersRequest
 */
export class ListSAMLIdPServiceProvidersRequest extends Message<ListSAMLIdPServiceProvidersRequest> {
  /**
   * Limit is the maximum amount of resources to retrieve.
   *
   * @generated from field: int32 Limit = 1;
   */
  Limit = 0;

  /**
   * NextKey is the key for the next page of SAML IdP service providers.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  constructor(data?: PartialMessage<ListSAMLIdPServiceProvidersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListSAMLIdPServiceProvidersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSAMLIdPServiceProvidersRequest {
    return new ListSAMLIdPServiceProvidersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSAMLIdPServiceProvidersRequest {
    return new ListSAMLIdPServiceProvidersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSAMLIdPServiceProvidersRequest {
    return new ListSAMLIdPServiceProvidersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSAMLIdPServiceProvidersRequest | PlainMessage<ListSAMLIdPServiceProvidersRequest> | undefined, b: ListSAMLIdPServiceProvidersRequest | PlainMessage<ListSAMLIdPServiceProvidersRequest> | undefined): boolean {
    return proto3.util.equals(ListSAMLIdPServiceProvidersRequest, a, b);
  }
}

/**
 * ListSAMLIdPServiceProvidersResponse a paginated list of SAML IdP service providers.
 *
 * @generated from message proto.ListSAMLIdPServiceProvidersResponse
 */
export class ListSAMLIdPServiceProvidersResponse extends Message<ListSAMLIdPServiceProvidersResponse> {
  /**
   * Servers is a list of SAML IdP service providers.
   *
   * @generated from field: repeated types.SAMLIdPServiceProviderV1 ServiceProviders = 1;
   */
  ServiceProviders: SAMLIdPServiceProviderV1[] = [];

  /**
   * NextKey is the key for the next page of SAML IdP service providers.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  /**
   * TotalCount is the total number of resources available after filter, if any.
   *
   * @generated from field: int32 TotalCount = 3;
   */
  TotalCount = 0;

  constructor(data?: PartialMessage<ListSAMLIdPServiceProvidersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListSAMLIdPServiceProvidersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServiceProviders", kind: "message", T: SAMLIdPServiceProviderV1, repeated: true },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TotalCount", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSAMLIdPServiceProvidersResponse {
    return new ListSAMLIdPServiceProvidersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSAMLIdPServiceProvidersResponse {
    return new ListSAMLIdPServiceProvidersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSAMLIdPServiceProvidersResponse {
    return new ListSAMLIdPServiceProvidersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSAMLIdPServiceProvidersResponse | PlainMessage<ListSAMLIdPServiceProvidersResponse> | undefined, b: ListSAMLIdPServiceProvidersResponse | PlainMessage<ListSAMLIdPServiceProvidersResponse> | undefined): boolean {
    return proto3.util.equals(ListSAMLIdPServiceProvidersResponse, a, b);
  }
}

/**
 * GetSAMLIdPServiceProviderRequest is a request for a specific SAML IdP service provider resource.
 *
 * @generated from message proto.GetSAMLIdPServiceProviderRequest
 */
export class GetSAMLIdPServiceProviderRequest extends Message<GetSAMLIdPServiceProviderRequest> {
  /**
   * Name is the name of the SAML IdP sercice provider to be requested.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<GetSAMLIdPServiceProviderRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSAMLIdPServiceProviderRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSAMLIdPServiceProviderRequest {
    return new GetSAMLIdPServiceProviderRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSAMLIdPServiceProviderRequest {
    return new GetSAMLIdPServiceProviderRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSAMLIdPServiceProviderRequest {
    return new GetSAMLIdPServiceProviderRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSAMLIdPServiceProviderRequest | PlainMessage<GetSAMLIdPServiceProviderRequest> | undefined, b: GetSAMLIdPServiceProviderRequest | PlainMessage<GetSAMLIdPServiceProviderRequest> | undefined): boolean {
    return proto3.util.equals(GetSAMLIdPServiceProviderRequest, a, b);
  }
}

/**
 * DeleteSAMLIdPServiceProviderRequest is a request for deleting a specific SAML IdP service provider resource.
 *
 * @generated from message proto.DeleteSAMLIdPServiceProviderRequest
 */
export class DeleteSAMLIdPServiceProviderRequest extends Message<DeleteSAMLIdPServiceProviderRequest> {
  /**
   * Name is the name of the SAML IdP sercice provider to be deleted.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteSAMLIdPServiceProviderRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteSAMLIdPServiceProviderRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSAMLIdPServiceProviderRequest {
    return new DeleteSAMLIdPServiceProviderRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSAMLIdPServiceProviderRequest {
    return new DeleteSAMLIdPServiceProviderRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSAMLIdPServiceProviderRequest {
    return new DeleteSAMLIdPServiceProviderRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSAMLIdPServiceProviderRequest | PlainMessage<DeleteSAMLIdPServiceProviderRequest> | undefined, b: DeleteSAMLIdPServiceProviderRequest | PlainMessage<DeleteSAMLIdPServiceProviderRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSAMLIdPServiceProviderRequest, a, b);
  }
}

/**
 * ListUserGroupsRequest is a request for a paginated list of user groups.
 *
 * @generated from message proto.ListUserGroupsRequest
 */
export class ListUserGroupsRequest extends Message<ListUserGroupsRequest> {
  /**
   * Limit is the maximum amount of resources to retrieve.
   *
   * @generated from field: int32 Limit = 1;
   */
  Limit = 0;

  /**
   * NextKey is the key for the next page of user groups.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  constructor(data?: PartialMessage<ListUserGroupsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListUserGroupsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUserGroupsRequest {
    return new ListUserGroupsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUserGroupsRequest {
    return new ListUserGroupsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUserGroupsRequest {
    return new ListUserGroupsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListUserGroupsRequest | PlainMessage<ListUserGroupsRequest> | undefined, b: ListUserGroupsRequest | PlainMessage<ListUserGroupsRequest> | undefined): boolean {
    return proto3.util.equals(ListUserGroupsRequest, a, b);
  }
}

/**
 * ListUserGroupsResponse a paginated list of user groups.
 *
 * @generated from message proto.ListUserGroupsResponse
 */
export class ListUserGroupsResponse extends Message<ListUserGroupsResponse> {
  /**
   * UserGroups is a list of user groups.
   *
   * @generated from field: repeated types.UserGroupV1 UserGroups = 1;
   */
  UserGroups: UserGroupV1[] = [];

  /**
   * NextKey is the key for the next page of user groups.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  /**
   * TotalCount is the total number of resources available after filter, if any.
   *
   * @generated from field: int32 TotalCount = 3;
   */
  TotalCount = 0;

  constructor(data?: PartialMessage<ListUserGroupsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListUserGroupsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UserGroups", kind: "message", T: UserGroupV1, repeated: true },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TotalCount", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUserGroupsResponse {
    return new ListUserGroupsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUserGroupsResponse {
    return new ListUserGroupsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUserGroupsResponse {
    return new ListUserGroupsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListUserGroupsResponse | PlainMessage<ListUserGroupsResponse> | undefined, b: ListUserGroupsResponse | PlainMessage<ListUserGroupsResponse> | undefined): boolean {
    return proto3.util.equals(ListUserGroupsResponse, a, b);
  }
}

/**
 * GetUserGroupRequest is a request for a specific user group resource.
 *
 * @generated from message proto.GetUserGroupRequest
 */
export class GetUserGroupRequest extends Message<GetUserGroupRequest> {
  /**
   * Name is the name of the user group to be requested.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<GetUserGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetUserGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUserGroupRequest {
    return new GetUserGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUserGroupRequest {
    return new GetUserGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUserGroupRequest {
    return new GetUserGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUserGroupRequest | PlainMessage<GetUserGroupRequest> | undefined, b: GetUserGroupRequest | PlainMessage<GetUserGroupRequest> | undefined): boolean {
    return proto3.util.equals(GetUserGroupRequest, a, b);
  }
}

/**
 * DeleteUserGroupRequest is a request for deleting a specific user group resource.
 *
 * @generated from message proto.DeleteUserGroupRequest
 */
export class DeleteUserGroupRequest extends Message<DeleteUserGroupRequest> {
  /**
   * Name is the name of the user group to be deleted.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<DeleteUserGroupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DeleteUserGroupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteUserGroupRequest {
    return new DeleteUserGroupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteUserGroupRequest {
    return new DeleteUserGroupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteUserGroupRequest {
    return new DeleteUserGroupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteUserGroupRequest | PlainMessage<DeleteUserGroupRequest> | undefined, b: DeleteUserGroupRequest | PlainMessage<DeleteUserGroupRequest> | undefined): boolean {
    return proto3.util.equals(DeleteUserGroupRequest, a, b);
  }
}

/**
 * CertAuthorityRequest is a request that identifies a Teleport CA.
 *
 * @generated from message proto.CertAuthorityRequest
 */
export class CertAuthorityRequest extends Message<CertAuthorityRequest> {
  /**
   * Type is either user or host certificate authority.
   *
   * @generated from field: string Type = 1;
   */
  Type = "";

  constructor(data?: PartialMessage<CertAuthorityRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CertAuthorityRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertAuthorityRequest {
    return new CertAuthorityRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertAuthorityRequest {
    return new CertAuthorityRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertAuthorityRequest {
    return new CertAuthorityRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CertAuthorityRequest | PlainMessage<CertAuthorityRequest> | undefined, b: CertAuthorityRequest | PlainMessage<CertAuthorityRequest> | undefined): boolean {
    return proto3.util.equals(CertAuthorityRequest, a, b);
  }
}

/**
 * CRL is the X.509 Certificate Revocation List.
 *
 * @generated from message proto.CRL
 */
export class CRL extends Message<CRL> {
  /**
   * CRL is the Certificate Revocation List in DER format.
   *
   * @generated from field: bytes CRL = 1;
   */
  CRL = new Uint8Array(0);

  constructor(data?: PartialMessage<CRL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CRL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CRL", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CRL {
    return new CRL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CRL {
    return new CRL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CRL {
    return new CRL().fromJsonString(jsonString, options);
  }

  static equals(a: CRL | PlainMessage<CRL> | undefined, b: CRL | PlainMessage<CRL> | undefined): boolean {
    return proto3.util.equals(CRL, a, b);
  }
}

/**
 * ChangeUserAuthenticationRequest defines a request to change a password and if enabled
 * also adds a new MFA device from a user reset or from a new user invite. User can also skip
 * setting a new password if passwordless is enabled and just provide a new webauthn register
 * response.
 *
 * After a successful request a new web session is created.
 *
 * Users may also receive new recovery codes if they meet the necessary requirements. If a user
 * previously had recovery codes, the previous codes become invalid as it is replaced with newly
 * generated ones.
 *
 * @generated from message proto.ChangeUserAuthenticationRequest
 */
export class ChangeUserAuthenticationRequest extends Message<ChangeUserAuthenticationRequest> {
  /**
   * TokenID is the ID of a reset or invite token.
   * The token allows the user to change their credentials without being logged
   * in.
   *
   * @generated from field: string TokenID = 1;
   */
  TokenID = "";

  /**
   * NewPassword is the new password in plain text.
   *
   * @generated from field: bytes NewPassword = 2;
   */
  NewPassword = new Uint8Array(0);

  /**
   * NewMFARegisterResponse is a MFA response to a MFA authentication challenge.
   * This field can be empty which implies that user chose not to add a new device (allowable when
   * cluster settings enable optional second factor), or cluster settings disabled second factor.
   *
   * @generated from field: proto.MFARegisterResponse NewMFARegisterResponse = 3;
   */
  NewMFARegisterResponse?: MFARegisterResponse;

  /**
   * NewDeviceName is the name of a new mfa or passwordless device.
   *
   * @generated from field: string NewDeviceName = 4;
   */
  NewDeviceName = "";

  /**
   * LoginIP is an IP that will be embedded in the new client's certificate for web session if successful.
   *
   * @generated from field: string LoginIP = 5;
   */
  LoginIP = "";

  constructor(data?: PartialMessage<ChangeUserAuthenticationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ChangeUserAuthenticationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "NewPassword", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "NewMFARegisterResponse", kind: "message", T: MFARegisterResponse },
    { no: 4, name: "NewDeviceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "LoginIP", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeUserAuthenticationRequest {
    return new ChangeUserAuthenticationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeUserAuthenticationRequest {
    return new ChangeUserAuthenticationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeUserAuthenticationRequest {
    return new ChangeUserAuthenticationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ChangeUserAuthenticationRequest | PlainMessage<ChangeUserAuthenticationRequest> | undefined, b: ChangeUserAuthenticationRequest | PlainMessage<ChangeUserAuthenticationRequest> | undefined): boolean {
    return proto3.util.equals(ChangeUserAuthenticationRequest, a, b);
  }
}

/**
 * ChangeUserAuthenticationResponse is a response for ChangeUserAuthentication.
 *
 * @generated from message proto.ChangeUserAuthenticationResponse
 */
export class ChangeUserAuthenticationResponse extends Message<ChangeUserAuthenticationResponse> {
  /**
   * WebSession is a user's web sesssion created from successful changing of password.
   *
   * @generated from field: types.WebSessionV2 WebSession = 1;
   */
  WebSession?: WebSessionV2;

  /**
   * Recovery holds user's new recovery related fields. Previous recovery codes become invalid.
   * This field can be empty if a user does not meet the following
   * requirements to receive recovery codes:
   *  - cloud feature is enabled
   *  - username is in valid email format
   *
   * @generated from field: proto.RecoveryCodes Recovery = 2;
   */
  Recovery?: RecoveryCodes;

  /**
   * PrivateKeyPolicyEnabled is a flag that when true means one of the private key policy was
   * set in either through cluster config or through a user's assigned role.
   *
   * @generated from field: bool PrivateKeyPolicyEnabled = 3;
   */
  PrivateKeyPolicyEnabled = false;

  constructor(data?: PartialMessage<ChangeUserAuthenticationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ChangeUserAuthenticationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "WebSession", kind: "message", T: WebSessionV2 },
    { no: 2, name: "Recovery", kind: "message", T: RecoveryCodes },
    { no: 3, name: "PrivateKeyPolicyEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeUserAuthenticationResponse {
    return new ChangeUserAuthenticationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeUserAuthenticationResponse {
    return new ChangeUserAuthenticationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeUserAuthenticationResponse {
    return new ChangeUserAuthenticationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ChangeUserAuthenticationResponse | PlainMessage<ChangeUserAuthenticationResponse> | undefined, b: ChangeUserAuthenticationResponse | PlainMessage<ChangeUserAuthenticationResponse> | undefined): boolean {
    return proto3.util.equals(ChangeUserAuthenticationResponse, a, b);
  }
}

/**
 * StartAccountRecoveryRequest defines a request to create a recovery start token for a user who is
 * allowed to recover their account. The tokens ID is used as part of a URL that will be emailed to
 * the user (not done in this request). Represents step 1 of the account recovery process, next step
 * is RPC VerifyAccountRecovery.
 *
 * @generated from message proto.StartAccountRecoveryRequest
 */
export class StartAccountRecoveryRequest extends Message<StartAccountRecoveryRequest> {
  /**
   * Username is the requesting user. The username must meet the following requirements to be
   * allowed to recover their account:
   *  - cloud feature is enabled
   *  - username is in valid email format
   *
   * @generated from field: string Username = 1;
   */
  Username = "";

  /**
   * RecoveryCode is one of the user's recovery code in plain text.
   *
   * @generated from field: bytes RecoveryCode = 2;
   */
  RecoveryCode = new Uint8Array(0);

  /**
   * RecoverType defines what type of authentication user needs to recover.
   *
   * @generated from field: types.UserTokenUsage RecoverType = 3;
   */
  RecoverType = UserTokenUsage.USER_TOKEN_USAGE_UNSPECIFIED;

  constructor(data?: PartialMessage<StartAccountRecoveryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.StartAccountRecoveryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "RecoveryCode", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "RecoverType", kind: "enum", T: proto3.getEnumType(UserTokenUsage) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartAccountRecoveryRequest {
    return new StartAccountRecoveryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartAccountRecoveryRequest {
    return new StartAccountRecoveryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartAccountRecoveryRequest {
    return new StartAccountRecoveryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartAccountRecoveryRequest | PlainMessage<StartAccountRecoveryRequest> | undefined, b: StartAccountRecoveryRequest | PlainMessage<StartAccountRecoveryRequest> | undefined): boolean {
    return proto3.util.equals(StartAccountRecoveryRequest, a, b);
  }
}

/**
 * VerifyAccountRecoveryRequest is a request to create a recovery approved token that allows users
 * to perform protected actions while not logged in. Represents step 2 of the account recovery
 * process after RPC StartAccountRecovery, next step is RPC CompleteAccountRecovery.
 *
 * @generated from message proto.VerifyAccountRecoveryRequest
 */
export class VerifyAccountRecoveryRequest extends Message<VerifyAccountRecoveryRequest> {
  /**
   * RecoveryStartTokenID is the ID of a recovery start token that's required to verify this
   * request.
   *
   * @generated from field: string RecoveryStartTokenID = 1;
   */
  RecoveryStartTokenID = "";

  /**
   * Username is the name of the user that the token belongs to, used to verify that this name
   * is the same as defined in token for use with emails.
   *
   * @generated from field: string Username = 2;
   */
  Username = "";

  /**
   * AuthnCred is the authentication cred that needs to be verified.
   *
   * @generated from oneof proto.VerifyAccountRecoveryRequest.AuthnCred
   */
  AuthnCred: {
    /**
     * Password is users password in plain text.
     *
     * @generated from field: bytes Password = 3;
     */
    value: Uint8Array;
    case: "Password";
  } | {
    /**
     * MFAAuthenticateResponse is a response to a MFA challenge.
     *
     * @generated from field: proto.MFAAuthenticateResponse MFAAuthenticateResponse = 4;
     */
    value: MFAAuthenticateResponse;
    case: "MFAAuthenticateResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<VerifyAccountRecoveryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.VerifyAccountRecoveryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RecoveryStartTokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Password", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "AuthnCred" },
    { no: 4, name: "MFAAuthenticateResponse", kind: "message", T: MFAAuthenticateResponse, oneof: "AuthnCred" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerifyAccountRecoveryRequest {
    return new VerifyAccountRecoveryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerifyAccountRecoveryRequest {
    return new VerifyAccountRecoveryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerifyAccountRecoveryRequest {
    return new VerifyAccountRecoveryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: VerifyAccountRecoveryRequest | PlainMessage<VerifyAccountRecoveryRequest> | undefined, b: VerifyAccountRecoveryRequest | PlainMessage<VerifyAccountRecoveryRequest> | undefined): boolean {
    return proto3.util.equals(VerifyAccountRecoveryRequest, a, b);
  }
}

/**
 * CompleteAccountRecoveryRequest is a request to set either a new password or
 * add a new mfa device, allowing the user to regain access to their account with the new
 * credentials. Represents the last step in the account recovery process after RPC's
 * StartAccountRecovery and VerifyAccountRecovery.
 *
 * @generated from message proto.CompleteAccountRecoveryRequest
 */
export class CompleteAccountRecoveryRequest extends Message<CompleteAccountRecoveryRequest> {
  /**
   * RecoveryApprovedTokenID is the ID of a recovery approved token that's required to verify this
   * request.
   *
   * @generated from field: string RecoveryApprovedTokenID = 1;
   */
  RecoveryApprovedTokenID = "";

  /**
   * NewDeviceName is the name of a new mfa device.
   * Optional if NewPassword is used.
   *
   * @generated from field: string NewDeviceName = 2;
   */
  NewDeviceName = "";

  /**
   * NewAuthnCred contains the new authentication credential.
   *
   * @generated from oneof proto.CompleteAccountRecoveryRequest.NewAuthnCred
   */
  NewAuthnCred: {
    /**
     * NewPassword is user's new password in plain text.
     *
     * @generated from field: bytes NewPassword = 3;
     */
    value: Uint8Array;
    case: "NewPassword";
  } | {
    /**
     * NewMFAResponse is a user's new mfa response to a mfa register challenge.
     *
     * @generated from field: proto.MFARegisterResponse NewMFAResponse = 4;
     */
    value: MFARegisterResponse;
    case: "NewMFAResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CompleteAccountRecoveryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CompleteAccountRecoveryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RecoveryApprovedTokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "NewDeviceName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "NewPassword", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "NewAuthnCred" },
    { no: 4, name: "NewMFAResponse", kind: "message", T: MFARegisterResponse, oneof: "NewAuthnCred" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompleteAccountRecoveryRequest {
    return new CompleteAccountRecoveryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompleteAccountRecoveryRequest {
    return new CompleteAccountRecoveryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompleteAccountRecoveryRequest {
    return new CompleteAccountRecoveryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CompleteAccountRecoveryRequest | PlainMessage<CompleteAccountRecoveryRequest> | undefined, b: CompleteAccountRecoveryRequest | PlainMessage<CompleteAccountRecoveryRequest> | undefined): boolean {
    return proto3.util.equals(CompleteAccountRecoveryRequest, a, b);
  }
}

/**
 * RecoveryCodes describes account recovery fields. Used as a RPC
 * response or as part of a RPC response that requires any of these fields.
 *
 * @generated from message proto.RecoveryCodes
 */
export class RecoveryCodes extends Message<RecoveryCodes> {
  /**
   * Codes holds the list of recovery phrase words.
   * Field is only used when new recovery codes are generated and returned to user.
   *
   * @generated from field: repeated string Codes = 1;
   */
  Codes: string[] = [];

  /**
   * Created is the date the recovery codes were created.
   *
   * @generated from field: google.protobuf.Timestamp Created = 2;
   */
  Created?: Timestamp;

  constructor(data?: PartialMessage<RecoveryCodes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RecoveryCodes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Codes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Created", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecoveryCodes {
    return new RecoveryCodes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecoveryCodes {
    return new RecoveryCodes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecoveryCodes {
    return new RecoveryCodes().fromJsonString(jsonString, options);
  }

  static equals(a: RecoveryCodes | PlainMessage<RecoveryCodes> | undefined, b: RecoveryCodes | PlainMessage<RecoveryCodes> | undefined): boolean {
    return proto3.util.equals(RecoveryCodes, a, b);
  }
}

/**
 * CreateAccountRecoveryCodesRequest is a request to create new set of recovery codes for a user,
 * replacing and invalidating any previously existing codes. Recovery codes can only be given to
 * users who meet the following requirements:
 *  - cloud feature is enabled
 *  - username is in valid email format
 *
 * @generated from message proto.CreateAccountRecoveryCodesRequest
 */
export class CreateAccountRecoveryCodesRequest extends Message<CreateAccountRecoveryCodesRequest> {
  /**
   * TokenID is the ID of a user token that will be used to verify this request.
   * Token types accepted are:
   *   - Recovery approved token that is obtained with RPC VerifyAccountRecovery
   *   - Privilege token that is obtained with RPC CreatePrivilegeToken
   *
   * @generated from field: string TokenID = 1;
   */
  TokenID = "";

  constructor(data?: PartialMessage<CreateAccountRecoveryCodesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateAccountRecoveryCodesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAccountRecoveryCodesRequest {
    return new CreateAccountRecoveryCodesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAccountRecoveryCodesRequest {
    return new CreateAccountRecoveryCodesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAccountRecoveryCodesRequest {
    return new CreateAccountRecoveryCodesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAccountRecoveryCodesRequest | PlainMessage<CreateAccountRecoveryCodesRequest> | undefined, b: CreateAccountRecoveryCodesRequest | PlainMessage<CreateAccountRecoveryCodesRequest> | undefined): boolean {
    return proto3.util.equals(CreateAccountRecoveryCodesRequest, a, b);
  }
}

/**
 * GetAccountRecoveryTokenRequest is a request to return a user token resource after verifying that
 * the token in the request is not expired and is of the recovery kind.
 *
 * @generated from message proto.GetAccountRecoveryTokenRequest
 */
export class GetAccountRecoveryTokenRequest extends Message<GetAccountRecoveryTokenRequest> {
  /**
   * RecoveryTokenID is the ID of a recovery token to verify.
   * Recovery tokens are obtained with RPC StartAccountRecovery or VerifyAccountRecovery.
   *
   * @generated from field: string RecoveryTokenID = 1;
   */
  RecoveryTokenID = "";

  constructor(data?: PartialMessage<GetAccountRecoveryTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetAccountRecoveryTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "RecoveryTokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountRecoveryTokenRequest {
    return new GetAccountRecoveryTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountRecoveryTokenRequest {
    return new GetAccountRecoveryTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountRecoveryTokenRequest {
    return new GetAccountRecoveryTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountRecoveryTokenRequest | PlainMessage<GetAccountRecoveryTokenRequest> | undefined, b: GetAccountRecoveryTokenRequest | PlainMessage<GetAccountRecoveryTokenRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountRecoveryTokenRequest, a, b);
  }
}

/**
 * GetAccountRecoveryCodesRequest is a request to return the user in context their
 * recovery codes. This request will not return any secrets (the values of recovery codes).
 *
 * @generated from message proto.GetAccountRecoveryCodesRequest
 */
export class GetAccountRecoveryCodesRequest extends Message<GetAccountRecoveryCodesRequest> {
  constructor(data?: PartialMessage<GetAccountRecoveryCodesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetAccountRecoveryCodesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAccountRecoveryCodesRequest {
    return new GetAccountRecoveryCodesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAccountRecoveryCodesRequest {
    return new GetAccountRecoveryCodesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAccountRecoveryCodesRequest {
    return new GetAccountRecoveryCodesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAccountRecoveryCodesRequest | PlainMessage<GetAccountRecoveryCodesRequest> | undefined, b: GetAccountRecoveryCodesRequest | PlainMessage<GetAccountRecoveryCodesRequest> | undefined): boolean {
    return proto3.util.equals(GetAccountRecoveryCodesRequest, a, b);
  }
}

/**
 * UserCredentials describes fields for a user's username and password.
 *
 * @generated from message proto.UserCredentials
 */
export class UserCredentials extends Message<UserCredentials> {
  /**
   * @generated from field: string Username = 1;
   */
  Username = "";

  /**
   * @generated from field: bytes Password = 2;
   */
  Password = new Uint8Array(0);

  constructor(data?: PartialMessage<UserCredentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UserCredentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Password", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserCredentials {
    return new UserCredentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserCredentials {
    return new UserCredentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserCredentials {
    return new UserCredentials().fromJsonString(jsonString, options);
  }

  static equals(a: UserCredentials | PlainMessage<UserCredentials> | undefined, b: UserCredentials | PlainMessage<UserCredentials> | undefined): boolean {
    return proto3.util.equals(UserCredentials, a, b);
  }
}

/**
 * ContextUser marks requests that rely in the currently authenticated user.
 *
 * @generated from message proto.ContextUser
 */
export class ContextUser extends Message<ContextUser> {
  constructor(data?: PartialMessage<ContextUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ContextUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContextUser {
    return new ContextUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContextUser {
    return new ContextUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContextUser {
    return new ContextUser().fromJsonString(jsonString, options);
  }

  static equals(a: ContextUser | PlainMessage<ContextUser> | undefined, b: ContextUser | PlainMessage<ContextUser> | undefined): boolean {
    return proto3.util.equals(ContextUser, a, b);
  }
}

/**
 * Passwordless marks requests for passwordless challenges.
 *
 * @generated from message proto.Passwordless
 */
export class Passwordless extends Message<Passwordless> {
  constructor(data?: PartialMessage<Passwordless>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.Passwordless";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Passwordless {
    return new Passwordless().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Passwordless {
    return new Passwordless().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Passwordless {
    return new Passwordless().fromJsonString(jsonString, options);
  }

  static equals(a: Passwordless | PlainMessage<Passwordless> | undefined, b: Passwordless | PlainMessage<Passwordless> | undefined): boolean {
    return proto3.util.equals(Passwordless, a, b);
  }
}

/**
 * CreateAuthenticateChallengeRequest is a request for creating MFA authentication challenges for a
 * users mfa devices.
 *
 * @generated from message proto.CreateAuthenticateChallengeRequest
 */
export class CreateAuthenticateChallengeRequest extends Message<CreateAuthenticateChallengeRequest> {
  /**
   * Request defines how the request will be verified before creating challenges.
   * An empty Request is equivalent to context_user being set.
   *
   * @generated from oneof proto.CreateAuthenticateChallengeRequest.Request
   */
  Request: {
    /**
     * UserCredentials verifies request with username and password. Used with logins or
     * when the logged in user wants to change their password.
     *
     * @generated from field: proto.UserCredentials UserCredentials = 1;
     */
    value: UserCredentials;
    case: "UserCredentials";
  } | {
    /**
     * RecoveryStartTokenID is the ID of a recovery start token obtained with RPC
     * StartAccountRecovery. This token allows a user to retrieve their MFA challenges for RPC
     * VerifyAccountRecovery (step 2 of the recovery process after RPC StartAccountRecovery).
     *
     * @generated from field: string RecoveryStartTokenID = 2;
     */
    value: string;
    case: "RecoveryStartTokenID";
  } | {
    /**
     * ContextUser issues a challenge for the currently-authenticated user.
     * Default option if no other is provided.
     *
     * @generated from field: proto.ContextUser ContextUser = 3;
     */
    value: ContextUser;
    case: "ContextUser";
  } | {
    /**
     * Passwordless issues a passwordless challenge (authenticated user not
     * required).
     *
     * @generated from field: proto.Passwordless Passwordless = 4;
     */
    value: Passwordless;
    case: "Passwordless";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * MFARequiredCheck, if set, is used to verify if MFA is necessary for the
   * request. It's akin to a call to [AuthService.IsMFARequired].
   *
   * If MFA is not required, then no challenges are issued in the
   * [MFAAuthenticateResponse].
   *
   * MFA verification should run in the cluster that holds the target resource.
   * If you are issuing challenges from the root cluster, but accessing a leaf,
   * call [AuthService.IsMFARequired] in the leaf instead of setting this field.
   *
   * @generated from field: proto.IsMFARequiredRequest MFARequiredCheck = 5;
   */
  MFARequiredCheck?: IsMFARequiredRequest;

  /**
   * ChallengeExtensions are extensions that will be apply to the issued MFA challenge.
   * ChallengeExtensions only apply to webauthn challenges currently. Required, except
   * for v15 clients and older.
   *
   * @generated from field: teleport.mfa.v1.ChallengeExtensions ChallengeExtensions = 6;
   */
  ChallengeExtensions?: ChallengeExtensions;

  constructor(data?: PartialMessage<CreateAuthenticateChallengeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateAuthenticateChallengeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "UserCredentials", kind: "message", T: UserCredentials, oneof: "Request" },
    { no: 2, name: "RecoveryStartTokenID", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "Request" },
    { no: 3, name: "ContextUser", kind: "message", T: ContextUser, oneof: "Request" },
    { no: 4, name: "Passwordless", kind: "message", T: Passwordless, oneof: "Request" },
    { no: 5, name: "MFARequiredCheck", kind: "message", T: IsMFARequiredRequest },
    { no: 6, name: "ChallengeExtensions", kind: "message", T: ChallengeExtensions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAuthenticateChallengeRequest {
    return new CreateAuthenticateChallengeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAuthenticateChallengeRequest {
    return new CreateAuthenticateChallengeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAuthenticateChallengeRequest {
    return new CreateAuthenticateChallengeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAuthenticateChallengeRequest | PlainMessage<CreateAuthenticateChallengeRequest> | undefined, b: CreateAuthenticateChallengeRequest | PlainMessage<CreateAuthenticateChallengeRequest> | undefined): boolean {
    return proto3.util.equals(CreateAuthenticateChallengeRequest, a, b);
  }
}

/**
 * CreatePrivilegeTokenRequest defines a request to obtain a privilege token.
 * Only logged in users are allowed to obtain privilege tokens after they have successfully
 * re-authenticated with their second factor.
 *
 * @generated from message proto.CreatePrivilegeTokenRequest
 */
export class CreatePrivilegeTokenRequest extends Message<CreatePrivilegeTokenRequest> {
  /**
   * ExistingMFAResponse is a response to a challenge from the user's existing MFA devices.
   * This field can be empty to create a UserTokenTypePrivilegeException token that
   * allows a user to bypass second factor re-authentication eg: allowing a user
   * with no mfa devices to add a device without re-authenticating.
   *
   * @generated from field: proto.MFAAuthenticateResponse ExistingMFAResponse = 1;
   */
  ExistingMFAResponse?: MFAAuthenticateResponse;

  constructor(data?: PartialMessage<CreatePrivilegeTokenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreatePrivilegeTokenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ExistingMFAResponse", kind: "message", T: MFAAuthenticateResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreatePrivilegeTokenRequest {
    return new CreatePrivilegeTokenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreatePrivilegeTokenRequest {
    return new CreatePrivilegeTokenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreatePrivilegeTokenRequest {
    return new CreatePrivilegeTokenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreatePrivilegeTokenRequest | PlainMessage<CreatePrivilegeTokenRequest> | undefined, b: CreatePrivilegeTokenRequest | PlainMessage<CreatePrivilegeTokenRequest> | undefined): boolean {
    return proto3.util.equals(CreatePrivilegeTokenRequest, a, b);
  }
}

/**
 * CreateRegisterChallengeRequest is a request for creating MFA register challenge for a
 * new MFA device.
 *
 * @generated from message proto.CreateRegisterChallengeRequest
 */
export class CreateRegisterChallengeRequest extends Message<CreateRegisterChallengeRequest> {
  /**
   * TokenID is the ID of a user token that will be used to verify this request.
   * Either TokenID or ExistingMFAResponse are required.
   *
   * All user token types are accepted except UserTokenTypeRecoveryStart.
   *
   * An authenticated user can create challenges without a token by supplying an
   * ExistingMFAResponse.
   *
   * @generated from field: string TokenID = 1;
   */
  TokenID = "";

  /**
   * ExistingMFAResponse is a response to ExistingMFAChallenge auth challenge.
   * Either ExistingMFAResponse or TokenID are required.
   *
   * Note that a user with no devices can create the initial register challenge,
   * in the same manner that they could create a privilege token.
   *
   * See the [AuthService.CreateAuthenticateChallenge] RPC.
   *
   * @generated from field: proto.MFAAuthenticateResponse ExistingMFAResponse = 4;
   */
  ExistingMFAResponse?: MFAAuthenticateResponse;

  /**
   * DeviceType is the type of MFA device to make a register challenge for.
   *
   * @generated from field: proto.DeviceType DeviceType = 2;
   */
  DeviceType = DeviceType.UNSPECIFIED;

  /**
   * DeviceUsage is the requested usage for the device.
   * Defaults to DEVICE_USAGE_MFA.
   *
   * @generated from field: proto.DeviceUsage DeviceUsage = 3;
   */
  DeviceUsage = DeviceUsage.UNSPECIFIED;

  constructor(data?: PartialMessage<CreateRegisterChallengeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateRegisterChallengeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TokenID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ExistingMFAResponse", kind: "message", T: MFAAuthenticateResponse },
    { no: 2, name: "DeviceType", kind: "enum", T: proto3.getEnumType(DeviceType) },
    { no: 3, name: "DeviceUsage", kind: "enum", T: proto3.getEnumType(DeviceUsage) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateRegisterChallengeRequest {
    return new CreateRegisterChallengeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateRegisterChallengeRequest {
    return new CreateRegisterChallengeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateRegisterChallengeRequest {
    return new CreateRegisterChallengeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateRegisterChallengeRequest | PlainMessage<CreateRegisterChallengeRequest> | undefined, b: CreateRegisterChallengeRequest | PlainMessage<CreateRegisterChallengeRequest> | undefined): boolean {
    return proto3.util.equals(CreateRegisterChallengeRequest, a, b);
  }
}

/**
 * PaginatedResource represents one of the supported resources.
 *
 * @generated from message proto.PaginatedResource
 */
export class PaginatedResource extends Message<PaginatedResource> {
  /**
   * Resource is the resource itself.
   *
   * @generated from oneof proto.PaginatedResource.resource
   */
  resource: {
    /**
     * DatabaseServer represents a DatabaseServer resource.
     *
     * @generated from field: types.DatabaseServerV3 DatabaseServer = 1;
     */
    value: DatabaseServerV3;
    case: "DatabaseServer";
  } | {
    /**
     * AppServer represents a AppServer resource.
     *
     * @generated from field: types.AppServerV3 AppServer = 2;
     */
    value: AppServerV3;
    case: "AppServer";
  } | {
    /**
     * Nodes represents a Server resource.
     *
     * @generated from field: types.ServerV2 Node = 3;
     */
    value: ServerV2;
    case: "Node";
  } | {
    /**
     * WindowsDesktop represents a WindowsDesktop resource.
     *
     * @generated from field: types.WindowsDesktopV3 WindowsDesktop = 5;
     */
    value: WindowsDesktopV3;
    case: "WindowsDesktop";
  } | {
    /**
     * KubeCluster represents a KubeCluster resource.
     *
     * @generated from field: types.KubernetesClusterV3 KubeCluster = 6;
     */
    value: KubernetesClusterV3;
    case: "KubeCluster";
  } | {
    /**
     * KubernetesServer represents a Kubernetes Server resource.
     *
     * @generated from field: types.KubernetesServerV3 KubernetesServer = 7;
     */
    value: KubernetesServerV3;
    case: "KubernetesServer";
  } | {
    /**
     * WindowsDesktopService represents a WindowsDesktopServiceV3 resource.
     *
     * @generated from field: types.WindowsDesktopServiceV3 WindowsDesktopService = 8;
     */
    value: WindowsDesktopServiceV3;
    case: "WindowsDesktopService";
  } | {
    /**
     * DatabaseService represents a DatabaseService resource.
     *
     * @generated from field: types.DatabaseServiceV1 DatabaseService = 9;
     */
    value: DatabaseServiceV1;
    case: "DatabaseService";
  } | {
    /**
     * UserGroup represents a UserGroup resource.
     *
     * @generated from field: types.UserGroupV1 UserGroup = 10;
     */
    value: UserGroupV1;
    case: "UserGroup";
  } | {
    /**
     * AppServerOrSAMLIdPServiceProvider represents either an AppServer or a SAML IdP Service Provider resource.
     *
     * DEPRECATED: Use AppServer and SAMLIdPServiceProvider type individually.
     *
     * @generated from field: types.AppServerOrSAMLIdPServiceProviderV1 AppServerOrSAMLIdPServiceProvider = 11 [deprecated = true];
     * @deprecated
     */
    value: AppServerOrSAMLIdPServiceProviderV1;
    case: "AppServerOrSAMLIdPServiceProvider";
  } | {
    /**
     * SAMLIdPServiceProvider represents a SAML IdP service provider resource.
     *
     * @generated from field: types.SAMLIdPServiceProviderV1 SAMLIdPServiceProvider = 12;
     */
    value: SAMLIdPServiceProviderV1;
    case: "SAMLIdPServiceProvider";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Logins allowed for the included resource. Only to be populated for SSH and Desktops.
   *
   * @generated from field: repeated string Logins = 13;
   */
  Logins: string[] = [];

  /**
   * RequiresRequest indicates if a resource requires an access request to access. Only populated with requests
   * that IncludeRequestable.
   *
   * @generated from field: bool RequiresRequest = 14;
   */
  RequiresRequest = false;

  constructor(data?: PartialMessage<PaginatedResource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.PaginatedResource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DatabaseServer", kind: "message", T: DatabaseServerV3, oneof: "resource" },
    { no: 2, name: "AppServer", kind: "message", T: AppServerV3, oneof: "resource" },
    { no: 3, name: "Node", kind: "message", T: ServerV2, oneof: "resource" },
    { no: 5, name: "WindowsDesktop", kind: "message", T: WindowsDesktopV3, oneof: "resource" },
    { no: 6, name: "KubeCluster", kind: "message", T: KubernetesClusterV3, oneof: "resource" },
    { no: 7, name: "KubernetesServer", kind: "message", T: KubernetesServerV3, oneof: "resource" },
    { no: 8, name: "WindowsDesktopService", kind: "message", T: WindowsDesktopServiceV3, oneof: "resource" },
    { no: 9, name: "DatabaseService", kind: "message", T: DatabaseServiceV1, oneof: "resource" },
    { no: 10, name: "UserGroup", kind: "message", T: UserGroupV1, oneof: "resource" },
    { no: 11, name: "AppServerOrSAMLIdPServiceProvider", kind: "message", T: AppServerOrSAMLIdPServiceProviderV1, oneof: "resource" },
    { no: 12, name: "SAMLIdPServiceProvider", kind: "message", T: SAMLIdPServiceProviderV1, oneof: "resource" },
    { no: 13, name: "Logins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "RequiresRequest", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginatedResource {
    return new PaginatedResource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginatedResource {
    return new PaginatedResource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginatedResource {
    return new PaginatedResource().fromJsonString(jsonString, options);
  }

  static equals(a: PaginatedResource | PlainMessage<PaginatedResource> | undefined, b: PaginatedResource | PlainMessage<PaginatedResource> | undefined): boolean {
    return proto3.util.equals(PaginatedResource, a, b);
  }
}

/**
 * ListUnifiedResourcesRequest is a request to receive a paginated list of unified resources
 *
 * @generated from message proto.ListUnifiedResourcesRequest
 */
export class ListUnifiedResourcesRequest extends Message<ListUnifiedResourcesRequest> {
  /**
   * Kinds is a list of kinds to match against a resource's kind. This can be used in a
   * unified resource request that can include multiple types.
   *
   * @generated from field: repeated string Kinds = 1;
   */
  Kinds: string[] = [];

  /**
   * Limit is the maximum amount of resources to retrieve.
   *
   * @generated from field: int32 Limit = 2;
   */
  Limit = 0;

  /**
   * StartKey is used to start listing resources from a specific spot. It
   * should be set to the previous NextKey value if using pagination, or
   * left empty.
   *
   * @generated from field: string StartKey = 3;
   */
  StartKey = "";

  /**
   * Labels is a label-based matcher if non-empty.
   *
   * @generated from field: map<string, string> Labels = 4;
   */
  Labels: { [key: string]: string } = {};

  /**
   * PredicateExpression defines boolean conditions that will be matched against the resource.
   *
   * @generated from field: string PredicateExpression = 5;
   */
  PredicateExpression = "";

  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   *
   * @generated from field: repeated string SearchKeywords = 6;
   */
  SearchKeywords: string[] = [];

  /**
   * SortBy describes which resource field and which direction to sort by.
   *
   * @generated from field: types.SortBy SortBy = 7;
   */
  SortBy?: SortBy;

  /**
   * WindowsDesktopFilter specifies windows desktop specific filters.
   *
   * @generated from field: types.WindowsDesktopFilter WindowsDesktopFilter = 8;
   */
  WindowsDesktopFilter?: WindowsDesktopFilter;

  /**
   * UseSearchAsRoles indicates that the response should include all resources
   * the caller is able to request access to using search_as_roles
   *
   * @generated from field: bool UseSearchAsRoles = 9;
   */
  UseSearchAsRoles = false;

  /**
   * UsePreviewAsRoles indicates that the response should include all resources
   * the caller would be able to access with their preview_as_roles
   *
   * @generated from field: bool UsePreviewAsRoles = 10;
   */
  UsePreviewAsRoles = false;

  /**
   * PinnedOnly indicates that the request will pull only the pinned resources
   * of the requesting user
   *
   * @generated from field: bool PinnedOnly = 11;
   */
  PinnedOnly = false;

  /**
   * IncludeLogins indicates that the response should include a users allowed logins
   * for all returned resources.
   *
   * @generated from field: bool IncludeLogins = 12;
   */
  IncludeLogins = false;

  /**
   * IncludeRequestable indicates that the response should include resources that the user must request access to.
   *
   * @generated from field: bool IncludeRequestable = 14;
   */
  IncludeRequestable = false;

  constructor(data?: PartialMessage<ListUnifiedResourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListUnifiedResourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "StartKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "PredicateExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "SearchKeywords", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "SortBy", kind: "message", T: SortBy },
    { no: 8, name: "WindowsDesktopFilter", kind: "message", T: WindowsDesktopFilter },
    { no: 9, name: "UseSearchAsRoles", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "UsePreviewAsRoles", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "PinnedOnly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "IncludeLogins", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "IncludeRequestable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUnifiedResourcesRequest {
    return new ListUnifiedResourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUnifiedResourcesRequest {
    return new ListUnifiedResourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUnifiedResourcesRequest {
    return new ListUnifiedResourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListUnifiedResourcesRequest | PlainMessage<ListUnifiedResourcesRequest> | undefined, b: ListUnifiedResourcesRequest | PlainMessage<ListUnifiedResourcesRequest> | undefined): boolean {
    return proto3.util.equals(ListUnifiedResourcesRequest, a, b);
  }
}

/**
 * ListUnifiedResourceResponse response of ListUnifiedResources.
 *
 * @generated from message proto.ListUnifiedResourcesResponse
 */
export class ListUnifiedResourcesResponse extends Message<ListUnifiedResourcesResponse> {
  /**
   * Resources is a list of resource.
   *
   * @generated from field: repeated proto.PaginatedResource Resources = 1;
   */
  Resources: PaginatedResource[] = [];

  /**
   * NextKey is the next Key to use as StartKey in a ListResourcesRequest to
   * continue retrieving pages of resource. If NextKey is empty, there are no
   * more pages.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  constructor(data?: PartialMessage<ListUnifiedResourcesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListUnifiedResourcesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Resources", kind: "message", T: PaginatedResource, repeated: true },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListUnifiedResourcesResponse {
    return new ListUnifiedResourcesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListUnifiedResourcesResponse {
    return new ListUnifiedResourcesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListUnifiedResourcesResponse {
    return new ListUnifiedResourcesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListUnifiedResourcesResponse | PlainMessage<ListUnifiedResourcesResponse> | undefined, b: ListUnifiedResourcesResponse | PlainMessage<ListUnifiedResourcesResponse> | undefined): boolean {
    return proto3.util.equals(ListUnifiedResourcesResponse, a, b);
  }
}

/**
 * ListResourcesRequest defines a request to retrieve resources paginated. Only
 * one type of resource can be retrieved per request.
 *
 * NOTE: There are two paths this request can take:
 *  1. ListResources: the more efficient path that retrieves resources by subset
 *  at a time defined by field 'Limit'. Does NOT de-duplicate matches.
 *  2. listResourcesWithSort: the less efficient path that retrieves all resources
 *  upfront by falling back to the traditional GetXXX calls. Used when sorting (SortBy),
 *  total count of resources (NeedTotalCount), or ResourceType `KindKubernetesCluster`
 *  is requested. Matches are de-duplicated.
 *
 * @generated from message proto.ListResourcesRequest
 */
export class ListResourcesRequest extends Message<ListResourcesRequest> {
  /**
   * ResourceType is the resource that is going to be retrieved.
   * This only needs to be set explicitly for the `ListResources` rpc.
   *
   * @generated from field: string ResourceType = 1;
   */
  ResourceType = "";

  /**
   * Namespace is the namespace of resources.
   *
   * @generated from field: string Namespace = 2;
   */
  Namespace = "";

  /**
   * Limit is the maximum amount of resources to retrieve.
   *
   * @generated from field: int32 Limit = 3;
   */
  Limit = 0;

  /**
   * StartKey is used to start listing resources from a specific spot. It
   * should be set to the previous NextKey value if using pagination, or
   * left empty.
   *
   * @generated from field: string StartKey = 4;
   */
  StartKey = "";

  /**
   * Labels is a label-based matcher if non-empty.
   *
   * @generated from field: map<string, string> Labels = 5;
   */
  Labels: { [key: string]: string } = {};

  /**
   * PredicateExpression defines boolean conditions that will be matched against the resource.
   *
   * @generated from field: string PredicateExpression = 6;
   */
  PredicateExpression = "";

  /**
   * SearchKeywords is a list of search keywords to match against resource field values.
   *
   * @generated from field: repeated string SearchKeywords = 7;
   */
  SearchKeywords: string[] = [];

  /**
   * SortBy describes which resource field and which direction to sort by.
   *
   * @generated from field: types.SortBy SortBy = 8;
   */
  SortBy?: SortBy;

  /**
   * NeedTotalCount indicates whether or not the caller also wants the total number of resources
   * after filtering.
   *
   * @generated from field: bool NeedTotalCount = 9;
   */
  NeedTotalCount = false;

  /**
   * WindowsDesktopFilter specifies windows desktop specific filters.
   *
   * @generated from field: types.WindowsDesktopFilter WindowsDesktopFilter = 10;
   */
  WindowsDesktopFilter?: WindowsDesktopFilter;

  /**
   * UseSearchAsRoles indicates that the response should include all resources
   * the caller is able to request access to using search_as_roles
   *
   * @generated from field: bool UseSearchAsRoles = 11;
   */
  UseSearchAsRoles = false;

  /**
   * UsePreviewAsRoles indicates that the response should include all resources
   * the caller would be able to access with their preview_as_roles
   *
   * @generated from field: bool UsePreviewAsRoles = 12;
   */
  UsePreviewAsRoles = false;

  /**
   * IncludeLogins indicates that the response should include a users allowed logins
   * for all returned resources.
   *
   * @generated from field: bool IncludeLogins = 13;
   */
  IncludeLogins = false;

  constructor(data?: PartialMessage<ListResourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListResourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ResourceType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "StartKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "PredicateExpression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "SearchKeywords", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "SortBy", kind: "message", T: SortBy },
    { no: 9, name: "NeedTotalCount", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "WindowsDesktopFilter", kind: "message", T: WindowsDesktopFilter },
    { no: 11, name: "UseSearchAsRoles", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "UsePreviewAsRoles", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "IncludeLogins", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListResourcesRequest {
    return new ListResourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListResourcesRequest {
    return new ListResourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListResourcesRequest {
    return new ListResourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListResourcesRequest | PlainMessage<ListResourcesRequest> | undefined, b: ListResourcesRequest | PlainMessage<ListResourcesRequest> | undefined): boolean {
    return proto3.util.equals(ListResourcesRequest, a, b);
  }
}

/**
 * GetSSHTargetsRequest gets all servers that might match an equivalent ssh dial request.
 *
 * @generated from message proto.GetSSHTargetsRequest
 */
export class GetSSHTargetsRequest extends Message<GetSSHTargetsRequest> {
  /**
   * Host is the target host as would be sent to the proxy during a dial request.
   *
   * @generated from field: string Host = 1;
   */
  Host = "";

  /**
   * Port is the ssh port. This value is optional, and both empty string and "0" are typically
   * treated as meaning that any port should match.
   *
   * @generated from field: string Port = 2;
   */
  Port = "";

  constructor(data?: PartialMessage<GetSSHTargetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSSHTargetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSSHTargetsRequest {
    return new GetSSHTargetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSSHTargetsRequest {
    return new GetSSHTargetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSSHTargetsRequest {
    return new GetSSHTargetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSSHTargetsRequest | PlainMessage<GetSSHTargetsRequest> | undefined, b: GetSSHTargetsRequest | PlainMessage<GetSSHTargetsRequest> | undefined): boolean {
    return proto3.util.equals(GetSSHTargetsRequest, a, b);
  }
}

/**
 * GetSSHTargetsResponse holds ssh servers that match an ssh targets request.
 *
 * @generated from message proto.GetSSHTargetsResponse
 */
export class GetSSHTargetsResponse extends Message<GetSSHTargetsResponse> {
  /**
   * Servers is a list of servers matching the supplied request.
   *
   * @generated from field: repeated types.ServerV2 Servers = 1;
   */
  Servers: ServerV2[] = [];

  constructor(data?: PartialMessage<GetSSHTargetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSSHTargetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Servers", kind: "message", T: ServerV2, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSSHTargetsResponse {
    return new GetSSHTargetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSSHTargetsResponse {
    return new GetSSHTargetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSSHTargetsResponse {
    return new GetSSHTargetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetSSHTargetsResponse | PlainMessage<GetSSHTargetsResponse> | undefined, b: GetSSHTargetsResponse | PlainMessage<GetSSHTargetsResponse> | undefined): boolean {
    return proto3.util.equals(GetSSHTargetsResponse, a, b);
  }
}

/**
 * ListResourceResponse response of ListResources.
 *
 * @generated from message proto.ListResourcesResponse
 */
export class ListResourcesResponse extends Message<ListResourcesResponse> {
  /**
   * Resources is a list of resource.
   *
   * @generated from field: repeated proto.PaginatedResource Resources = 1;
   */
  Resources: PaginatedResource[] = [];

  /**
   * NextKey is the next Key to use as StartKey in a ListResourcesRequest to
   * continue retrieving pages of resource. If NextKey is empty, there are no
   * more pages.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  /**
   * TotalCount is the total number of resources available after filter, if any.
   *
   * @generated from field: int32 TotalCount = 3;
   */
  TotalCount = 0;

  constructor(data?: PartialMessage<ListResourcesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListResourcesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Resources", kind: "message", T: PaginatedResource, repeated: true },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "TotalCount", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListResourcesResponse {
    return new ListResourcesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListResourcesResponse {
    return new ListResourcesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListResourcesResponse {
    return new ListResourcesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListResourcesResponse | PlainMessage<ListResourcesResponse> | undefined, b: ListResourcesResponse | PlainMessage<ListResourcesResponse> | undefined): boolean {
    return proto3.util.equals(ListResourcesResponse, a, b);
  }
}

/**
 * CreateSessionTrackerRequest is a request to create a new session.
 *
 * This is not specific to any session type. Relevant fields should be set for a given session type.
 *
 * @generated from message proto.CreateSessionTrackerRequest
 */
export class CreateSessionTrackerRequest extends Message<CreateSessionTrackerRequest> {
  /**
   * SessionTracker is the session tracker to be created.
   *
   * @generated from field: types.SessionTrackerV1 SessionTracker = 15;
   */
  SessionTracker?: SessionTrackerV1;

  constructor(data?: PartialMessage<CreateSessionTrackerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateSessionTrackerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 15, name: "SessionTracker", kind: "message", T: SessionTrackerV1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSessionTrackerRequest {
    return new CreateSessionTrackerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSessionTrackerRequest {
    return new CreateSessionTrackerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSessionTrackerRequest {
    return new CreateSessionTrackerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSessionTrackerRequest | PlainMessage<CreateSessionTrackerRequest> | undefined, b: CreateSessionTrackerRequest | PlainMessage<CreateSessionTrackerRequest> | undefined): boolean {
    return proto3.util.equals(CreateSessionTrackerRequest, a, b);
  }
}

/**
 * GetSessionTrackerRequest is a request to fetch a session resource.
 *
 * @generated from message proto.GetSessionTrackerRequest
 */
export class GetSessionTrackerRequest extends Message<GetSessionTrackerRequest> {
  /**
   * SessionID is unique identifier of this session.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<GetSessionTrackerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSessionTrackerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSessionTrackerRequest {
    return new GetSessionTrackerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSessionTrackerRequest {
    return new GetSessionTrackerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSessionTrackerRequest {
    return new GetSessionTrackerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSessionTrackerRequest | PlainMessage<GetSessionTrackerRequest> | undefined, b: GetSessionTrackerRequest | PlainMessage<GetSessionTrackerRequest> | undefined): boolean {
    return proto3.util.equals(GetSessionTrackerRequest, a, b);
  }
}

/**
 * RemoveSessionTrackerRequest is a request to remove a session.
 *
 * @generated from message proto.RemoveSessionTrackerRequest
 */
export class RemoveSessionTrackerRequest extends Message<RemoveSessionTrackerRequest> {
  /**
   * SessionID is unique identifier of this session.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<RemoveSessionTrackerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.RemoveSessionTrackerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveSessionTrackerRequest {
    return new RemoveSessionTrackerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveSessionTrackerRequest {
    return new RemoveSessionTrackerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveSessionTrackerRequest {
    return new RemoveSessionTrackerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveSessionTrackerRequest | PlainMessage<RemoveSessionTrackerRequest> | undefined, b: RemoveSessionTrackerRequest | PlainMessage<RemoveSessionTrackerRequest> | undefined): boolean {
    return proto3.util.equals(RemoveSessionTrackerRequest, a, b);
  }
}

/**
 * @generated from message proto.SessionTrackerUpdateState
 */
export class SessionTrackerUpdateState extends Message<SessionTrackerUpdateState> {
  /**
   * State is the new state of the session tracker.
   *
   * @generated from field: types.SessionState State = 2;
   */
  State = SessionState.SessionStatePending;

  constructor(data?: PartialMessage<SessionTrackerUpdateState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SessionTrackerUpdateState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "State", kind: "enum", T: proto3.getEnumType(SessionState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerUpdateState {
    return new SessionTrackerUpdateState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerUpdateState {
    return new SessionTrackerUpdateState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerUpdateState {
    return new SessionTrackerUpdateState().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerUpdateState | PlainMessage<SessionTrackerUpdateState> | undefined, b: SessionTrackerUpdateState | PlainMessage<SessionTrackerUpdateState> | undefined): boolean {
    return proto3.util.equals(SessionTrackerUpdateState, a, b);
  }
}

/**
 * @generated from message proto.SessionTrackerAddParticipant
 */
export class SessionTrackerAddParticipant extends Message<SessionTrackerAddParticipant> {
  /**
   * Participant is the participant to be added to the session.
   *
   * @generated from field: types.Participant Participant = 2;
   */
  Participant?: Participant;

  constructor(data?: PartialMessage<SessionTrackerAddParticipant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SessionTrackerAddParticipant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "Participant", kind: "message", T: Participant },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerAddParticipant {
    return new SessionTrackerAddParticipant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerAddParticipant {
    return new SessionTrackerAddParticipant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerAddParticipant {
    return new SessionTrackerAddParticipant().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerAddParticipant | PlainMessage<SessionTrackerAddParticipant> | undefined, b: SessionTrackerAddParticipant | PlainMessage<SessionTrackerAddParticipant> | undefined): boolean {
    return proto3.util.equals(SessionTrackerAddParticipant, a, b);
  }
}

/**
 * @generated from message proto.SessionTrackerRemoveParticipant
 */
export class SessionTrackerRemoveParticipant extends Message<SessionTrackerRemoveParticipant> {
  /**
   * ParticipantID is unique identifier of the participant.
   *
   * @generated from field: string ParticipantID = 2;
   */
  ParticipantID = "";

  constructor(data?: PartialMessage<SessionTrackerRemoveParticipant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SessionTrackerRemoveParticipant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "ParticipantID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerRemoveParticipant {
    return new SessionTrackerRemoveParticipant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerRemoveParticipant {
    return new SessionTrackerRemoveParticipant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerRemoveParticipant {
    return new SessionTrackerRemoveParticipant().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerRemoveParticipant | PlainMessage<SessionTrackerRemoveParticipant> | undefined, b: SessionTrackerRemoveParticipant | PlainMessage<SessionTrackerRemoveParticipant> | undefined): boolean {
    return proto3.util.equals(SessionTrackerRemoveParticipant, a, b);
  }
}

/**
 * SessionTrackerUpdateExpiry is used to update the session tracker expiration time.
 *
 * @generated from message proto.SessionTrackerUpdateExpiry
 */
export class SessionTrackerUpdateExpiry extends Message<SessionTrackerUpdateExpiry> {
  /**
   * Expires is when the session tracker will expire.
   *
   * @generated from field: google.protobuf.Timestamp Expires = 1;
   */
  Expires?: Timestamp;

  constructor(data?: PartialMessage<SessionTrackerUpdateExpiry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SessionTrackerUpdateExpiry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Expires", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionTrackerUpdateExpiry {
    return new SessionTrackerUpdateExpiry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionTrackerUpdateExpiry {
    return new SessionTrackerUpdateExpiry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionTrackerUpdateExpiry {
    return new SessionTrackerUpdateExpiry().fromJsonString(jsonString, options);
  }

  static equals(a: SessionTrackerUpdateExpiry | PlainMessage<SessionTrackerUpdateExpiry> | undefined, b: SessionTrackerUpdateExpiry | PlainMessage<SessionTrackerUpdateExpiry> | undefined): boolean {
    return proto3.util.equals(SessionTrackerUpdateExpiry, a, b);
  }
}

/**
 * UpdateSessionTrackerRequest is a request to update some state of a session.
 *
 * @generated from message proto.UpdateSessionTrackerRequest
 */
export class UpdateSessionTrackerRequest extends Message<UpdateSessionTrackerRequest> {
  /**
   * SessionID is unique identifier of this session.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  /**
   * @generated from oneof proto.UpdateSessionTrackerRequest.Update
   */
  Update: {
    /**
     * @generated from field: proto.SessionTrackerUpdateState UpdateState = 2;
     */
    value: SessionTrackerUpdateState;
    case: "UpdateState";
  } | {
    /**
     * @generated from field: proto.SessionTrackerAddParticipant AddParticipant = 3;
     */
    value: SessionTrackerAddParticipant;
    case: "AddParticipant";
  } | {
    /**
     * @generated from field: proto.SessionTrackerRemoveParticipant RemoveParticipant = 4;
     */
    value: SessionTrackerRemoveParticipant;
    case: "RemoveParticipant";
  } | {
    /**
     * @generated from field: proto.SessionTrackerUpdateExpiry UpdateExpiry = 5;
     */
    value: SessionTrackerUpdateExpiry;
    case: "UpdateExpiry";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UpdateSessionTrackerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpdateSessionTrackerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "UpdateState", kind: "message", T: SessionTrackerUpdateState, oneof: "Update" },
    { no: 3, name: "AddParticipant", kind: "message", T: SessionTrackerAddParticipant, oneof: "Update" },
    { no: 4, name: "RemoveParticipant", kind: "message", T: SessionTrackerRemoveParticipant, oneof: "Update" },
    { no: 5, name: "UpdateExpiry", kind: "message", T: SessionTrackerUpdateExpiry, oneof: "Update" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSessionTrackerRequest {
    return new UpdateSessionTrackerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSessionTrackerRequest {
    return new UpdateSessionTrackerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSessionTrackerRequest {
    return new UpdateSessionTrackerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSessionTrackerRequest | PlainMessage<UpdateSessionTrackerRequest> | undefined, b: UpdateSessionTrackerRequest | PlainMessage<UpdateSessionTrackerRequest> | undefined): boolean {
    return proto3.util.equals(UpdateSessionTrackerRequest, a, b);
  }
}

/**
 * PresenceMFAChallengeRequest is a request for a presence MFA challenge.
 *
 * @generated from message proto.PresenceMFAChallengeRequest
 */
export class PresenceMFAChallengeRequest extends Message<PresenceMFAChallengeRequest> {
  /**
   * SessionID is unique identifier of the session you want to request presence for.
   *
   * @generated from field: string SessionID = 1;
   */
  SessionID = "";

  constructor(data?: PartialMessage<PresenceMFAChallengeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.PresenceMFAChallengeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SessionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PresenceMFAChallengeRequest {
    return new PresenceMFAChallengeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PresenceMFAChallengeRequest {
    return new PresenceMFAChallengeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PresenceMFAChallengeRequest {
    return new PresenceMFAChallengeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PresenceMFAChallengeRequest | PlainMessage<PresenceMFAChallengeRequest> | undefined, b: PresenceMFAChallengeRequest | PlainMessage<PresenceMFAChallengeRequest> | undefined): boolean {
    return proto3.util.equals(PresenceMFAChallengeRequest, a, b);
  }
}

/**
 * PresenceMFAChallengeSend is a presence challenge request or response.
 *
 * @generated from message proto.PresenceMFAChallengeSend
 */
export class PresenceMFAChallengeSend extends Message<PresenceMFAChallengeSend> {
  /**
   * @generated from oneof proto.PresenceMFAChallengeSend.Request
   */
  Request: {
    /**
     * @generated from field: proto.PresenceMFAChallengeRequest ChallengeRequest = 1;
     */
    value: PresenceMFAChallengeRequest;
    case: "ChallengeRequest";
  } | {
    /**
     * @generated from field: proto.MFAAuthenticateResponse ChallengeResponse = 2;
     */
    value: MFAAuthenticateResponse;
    case: "ChallengeResponse";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PresenceMFAChallengeSend>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.PresenceMFAChallengeSend";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ChallengeRequest", kind: "message", T: PresenceMFAChallengeRequest, oneof: "Request" },
    { no: 2, name: "ChallengeResponse", kind: "message", T: MFAAuthenticateResponse, oneof: "Request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PresenceMFAChallengeSend {
    return new PresenceMFAChallengeSend().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PresenceMFAChallengeSend {
    return new PresenceMFAChallengeSend().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PresenceMFAChallengeSend {
    return new PresenceMFAChallengeSend().fromJsonString(jsonString, options);
  }

  static equals(a: PresenceMFAChallengeSend | PlainMessage<PresenceMFAChallengeSend> | undefined, b: PresenceMFAChallengeSend | PlainMessage<PresenceMFAChallengeSend> | undefined): boolean {
    return proto3.util.equals(PresenceMFAChallengeSend, a, b);
  }
}

/**
 * GetDomainNameResponse is a response from GetDomainName.
 *
 * @generated from message proto.GetDomainNameResponse
 */
export class GetDomainNameResponse extends Message<GetDomainNameResponse> {
  /**
   * DomainName is the local auth domain of the current auth server.
   *
   * @generated from field: string DomainName = 1;
   */
  DomainName = "";

  constructor(data?: PartialMessage<GetDomainNameResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetDomainNameResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DomainName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDomainNameResponse {
    return new GetDomainNameResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDomainNameResponse {
    return new GetDomainNameResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDomainNameResponse {
    return new GetDomainNameResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetDomainNameResponse | PlainMessage<GetDomainNameResponse> | undefined, b: GetDomainNameResponse | PlainMessage<GetDomainNameResponse> | undefined): boolean {
    return proto3.util.equals(GetDomainNameResponse, a, b);
  }
}

/**
 * GetClusterCACertResponse is a response from GetClusterCACert.
 *
 * @generated from message proto.GetClusterCACertResponse
 */
export class GetClusterCACertResponse extends Message<GetClusterCACertResponse> {
  /**
   * TLSCA is a PEM-encoded TLS certificate authority.
   *
   * @generated from field: bytes TLSCA = 1;
   */
  TLSCA = new Uint8Array(0);

  constructor(data?: PartialMessage<GetClusterCACertResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetClusterCACertResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TLSCA", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterCACertResponse {
    return new GetClusterCACertResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterCACertResponse {
    return new GetClusterCACertResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterCACertResponse {
    return new GetClusterCACertResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterCACertResponse | PlainMessage<GetClusterCACertResponse> | undefined, b: GetClusterCACertResponse | PlainMessage<GetClusterCACertResponse> | undefined): boolean {
    return proto3.util.equals(GetClusterCACertResponse, a, b);
  }
}

/**
 * GetLicenseResponse is a response from GetLicense
 *
 * @generated from message proto.GetLicenseResponse
 */
export class GetLicenseResponse extends Message<GetLicenseResponse> {
  /**
   * @generated from field: bytes License = 1;
   */
  License = new Uint8Array(0);

  constructor(data?: PartialMessage<GetLicenseResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetLicenseResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "License", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLicenseResponse {
    return new GetLicenseResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLicenseResponse {
    return new GetLicenseResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLicenseResponse {
    return new GetLicenseResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetLicenseResponse | PlainMessage<GetLicenseResponse> | undefined, b: GetLicenseResponse | PlainMessage<GetLicenseResponse> | undefined): boolean {
    return proto3.util.equals(GetLicenseResponse, a, b);
  }
}

/**
 * ListReleasesResponse is a response from ListReleases
 *
 * @generated from message proto.ListReleasesResponse
 */
export class ListReleasesResponse extends Message<ListReleasesResponse> {
  /**
   * @generated from field: repeated types.Release releases = 1;
   */
  releases: Release[] = [];

  constructor(data?: PartialMessage<ListReleasesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListReleasesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "releases", kind: "message", T: Release, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListReleasesResponse {
    return new ListReleasesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListReleasesResponse {
    return new ListReleasesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListReleasesResponse {
    return new ListReleasesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListReleasesResponse | PlainMessage<ListReleasesResponse> | undefined, b: ListReleasesResponse | PlainMessage<ListReleasesResponse> | undefined): boolean {
    return proto3.util.equals(ListReleasesResponse, a, b);
  }
}

/**
 * GetOIDCAuthRequestRequest is a request for GetOIDCAuthRequest.
 *
 * @generated from message proto.GetOIDCAuthRequestRequest
 */
export class GetOIDCAuthRequestRequest extends Message<GetOIDCAuthRequestRequest> {
  /**
   * StateToken is an oidc auth request state token.
   *
   * @generated from field: string StateToken = 1;
   */
  StateToken = "";

  constructor(data?: PartialMessage<GetOIDCAuthRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetOIDCAuthRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "StateToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOIDCAuthRequestRequest {
    return new GetOIDCAuthRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOIDCAuthRequestRequest {
    return new GetOIDCAuthRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOIDCAuthRequestRequest {
    return new GetOIDCAuthRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetOIDCAuthRequestRequest | PlainMessage<GetOIDCAuthRequestRequest> | undefined, b: GetOIDCAuthRequestRequest | PlainMessage<GetOIDCAuthRequestRequest> | undefined): boolean {
    return proto3.util.equals(GetOIDCAuthRequestRequest, a, b);
  }
}

/**
 * GetSAMLAuthRequestRequest is a request for GetSAMLAuthRequest.
 *
 * @generated from message proto.GetSAMLAuthRequestRequest
 */
export class GetSAMLAuthRequestRequest extends Message<GetSAMLAuthRequestRequest> {
  /**
   * ID is a saml auth request unique id.
   *
   * @generated from field: string ID = 1;
   */
  ID = "";

  constructor(data?: PartialMessage<GetSAMLAuthRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSAMLAuthRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSAMLAuthRequestRequest {
    return new GetSAMLAuthRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSAMLAuthRequestRequest {
    return new GetSAMLAuthRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSAMLAuthRequestRequest {
    return new GetSAMLAuthRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSAMLAuthRequestRequest | PlainMessage<GetSAMLAuthRequestRequest> | undefined, b: GetSAMLAuthRequestRequest | PlainMessage<GetSAMLAuthRequestRequest> | undefined): boolean {
    return proto3.util.equals(GetSAMLAuthRequestRequest, a, b);
  }
}

/**
 * GetGithubAuthRequestRequest is a request for GetGithubAuthRequest.
 *
 * @generated from message proto.GetGithubAuthRequestRequest
 */
export class GetGithubAuthRequestRequest extends Message<GetGithubAuthRequestRequest> {
  /**
   * StateToken is a github auth request state token.
   *
   * @generated from field: string StateToken = 1;
   */
  StateToken = "";

  constructor(data?: PartialMessage<GetGithubAuthRequestRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetGithubAuthRequestRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "StateToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetGithubAuthRequestRequest {
    return new GetGithubAuthRequestRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetGithubAuthRequestRequest {
    return new GetGithubAuthRequestRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetGithubAuthRequestRequest {
    return new GetGithubAuthRequestRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetGithubAuthRequestRequest | PlainMessage<GetGithubAuthRequestRequest> | undefined, b: GetGithubAuthRequestRequest | PlainMessage<GetGithubAuthRequestRequest> | undefined): boolean {
    return proto3.util.equals(GetGithubAuthRequestRequest, a, b);
  }
}

/**
 * CreateOIDCConnectorRequest is a request for CreateOIDCConnector.
 *
 * @generated from message proto.CreateOIDCConnectorRequest
 */
export class CreateOIDCConnectorRequest extends Message<CreateOIDCConnectorRequest> {
  /**
   * Connector to be created.
   *
   * @generated from field: types.OIDCConnectorV3 Connector = 1;
   */
  Connector?: OIDCConnectorV3;

  constructor(data?: PartialMessage<CreateOIDCConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateOIDCConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: OIDCConnectorV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateOIDCConnectorRequest {
    return new CreateOIDCConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateOIDCConnectorRequest {
    return new CreateOIDCConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateOIDCConnectorRequest {
    return new CreateOIDCConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateOIDCConnectorRequest | PlainMessage<CreateOIDCConnectorRequest> | undefined, b: CreateOIDCConnectorRequest | PlainMessage<CreateOIDCConnectorRequest> | undefined): boolean {
    return proto3.util.equals(CreateOIDCConnectorRequest, a, b);
  }
}

/**
 * UpdateOIDCConnectorRequest is a request for UpdateOIDCConnector.
 *
 * @generated from message proto.UpdateOIDCConnectorRequest
 */
export class UpdateOIDCConnectorRequest extends Message<UpdateOIDCConnectorRequest> {
  /**
   * Connector to be updated.
   *
   * @generated from field: types.OIDCConnectorV3 Connector = 1;
   */
  Connector?: OIDCConnectorV3;

  constructor(data?: PartialMessage<UpdateOIDCConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpdateOIDCConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: OIDCConnectorV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateOIDCConnectorRequest {
    return new UpdateOIDCConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateOIDCConnectorRequest {
    return new UpdateOIDCConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateOIDCConnectorRequest {
    return new UpdateOIDCConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateOIDCConnectorRequest | PlainMessage<UpdateOIDCConnectorRequest> | undefined, b: UpdateOIDCConnectorRequest | PlainMessage<UpdateOIDCConnectorRequest> | undefined): boolean {
    return proto3.util.equals(UpdateOIDCConnectorRequest, a, b);
  }
}

/**
 * UpsertOIDCConnectorRequest is a request for UpsertOIDCConnector.
 *
 * @generated from message proto.UpsertOIDCConnectorRequest
 */
export class UpsertOIDCConnectorRequest extends Message<UpsertOIDCConnectorRequest> {
  /**
   * Connector to be created or updated.
   *
   * @generated from field: types.OIDCConnectorV3 Connector = 1;
   */
  Connector?: OIDCConnectorV3;

  constructor(data?: PartialMessage<UpsertOIDCConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertOIDCConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: OIDCConnectorV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertOIDCConnectorRequest {
    return new UpsertOIDCConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertOIDCConnectorRequest {
    return new UpsertOIDCConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertOIDCConnectorRequest {
    return new UpsertOIDCConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertOIDCConnectorRequest | PlainMessage<UpsertOIDCConnectorRequest> | undefined, b: UpsertOIDCConnectorRequest | PlainMessage<UpsertOIDCConnectorRequest> | undefined): boolean {
    return proto3.util.equals(UpsertOIDCConnectorRequest, a, b);
  }
}

/**
 * CreateSAMLConnectorRequest is a request for CreateSAMLConnector.
 *
 * @generated from message proto.CreateSAMLConnectorRequest
 */
export class CreateSAMLConnectorRequest extends Message<CreateSAMLConnectorRequest> {
  /**
   * Connector to be created.
   *
   * @generated from field: types.SAMLConnectorV2 Connector = 1;
   */
  Connector?: SAMLConnectorV2;

  constructor(data?: PartialMessage<CreateSAMLConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateSAMLConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: SAMLConnectorV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSAMLConnectorRequest {
    return new CreateSAMLConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSAMLConnectorRequest {
    return new CreateSAMLConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSAMLConnectorRequest {
    return new CreateSAMLConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSAMLConnectorRequest | PlainMessage<CreateSAMLConnectorRequest> | undefined, b: CreateSAMLConnectorRequest | PlainMessage<CreateSAMLConnectorRequest> | undefined): boolean {
    return proto3.util.equals(CreateSAMLConnectorRequest, a, b);
  }
}

/**
 * UpdateSAMLConnectorRequest is a request for UpdateSAMLConnector.
 *
 * @generated from message proto.UpdateSAMLConnectorRequest
 */
export class UpdateSAMLConnectorRequest extends Message<UpdateSAMLConnectorRequest> {
  /**
   * Connector to be updated.
   *
   * @generated from field: types.SAMLConnectorV2 Connector = 1;
   */
  Connector?: SAMLConnectorV2;

  constructor(data?: PartialMessage<UpdateSAMLConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpdateSAMLConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: SAMLConnectorV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSAMLConnectorRequest {
    return new UpdateSAMLConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSAMLConnectorRequest {
    return new UpdateSAMLConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSAMLConnectorRequest {
    return new UpdateSAMLConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSAMLConnectorRequest | PlainMessage<UpdateSAMLConnectorRequest> | undefined, b: UpdateSAMLConnectorRequest | PlainMessage<UpdateSAMLConnectorRequest> | undefined): boolean {
    return proto3.util.equals(UpdateSAMLConnectorRequest, a, b);
  }
}

/**
 * UpsertSAMLConnectorRequest is a request for UpsertSAMLConnector.
 *
 * @generated from message proto.UpsertSAMLConnectorRequest
 */
export class UpsertSAMLConnectorRequest extends Message<UpsertSAMLConnectorRequest> {
  /**
   * Connector to be created or updated.
   *
   * @generated from field: types.SAMLConnectorV2 Connector = 1;
   */
  Connector?: SAMLConnectorV2;

  constructor(data?: PartialMessage<UpsertSAMLConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertSAMLConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: SAMLConnectorV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertSAMLConnectorRequest {
    return new UpsertSAMLConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertSAMLConnectorRequest {
    return new UpsertSAMLConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertSAMLConnectorRequest {
    return new UpsertSAMLConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertSAMLConnectorRequest | PlainMessage<UpsertSAMLConnectorRequest> | undefined, b: UpsertSAMLConnectorRequest | PlainMessage<UpsertSAMLConnectorRequest> | undefined): boolean {
    return proto3.util.equals(UpsertSAMLConnectorRequest, a, b);
  }
}

/**
 * CreateGithubConnectorRequest is a request for CreateGithubConnector.
 *
 * @generated from message proto.CreateGithubConnectorRequest
 */
export class CreateGithubConnectorRequest extends Message<CreateGithubConnectorRequest> {
  /**
   * Connector to be created.
   *
   * @generated from field: types.GithubConnectorV3 Connector = 1;
   */
  Connector?: GithubConnectorV3;

  constructor(data?: PartialMessage<CreateGithubConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateGithubConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: GithubConnectorV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateGithubConnectorRequest {
    return new CreateGithubConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateGithubConnectorRequest {
    return new CreateGithubConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateGithubConnectorRequest {
    return new CreateGithubConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateGithubConnectorRequest | PlainMessage<CreateGithubConnectorRequest> | undefined, b: CreateGithubConnectorRequest | PlainMessage<CreateGithubConnectorRequest> | undefined): boolean {
    return proto3.util.equals(CreateGithubConnectorRequest, a, b);
  }
}

/**
 * UpdateGithubConnectorRequest is a request for UpdateGithubConnector.
 *
 * @generated from message proto.UpdateGithubConnectorRequest
 */
export class UpdateGithubConnectorRequest extends Message<UpdateGithubConnectorRequest> {
  /**
   * Connector to be updated.
   *
   * @generated from field: types.GithubConnectorV3 Connector = 1;
   */
  Connector?: GithubConnectorV3;

  constructor(data?: PartialMessage<UpdateGithubConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpdateGithubConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: GithubConnectorV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateGithubConnectorRequest {
    return new UpdateGithubConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateGithubConnectorRequest {
    return new UpdateGithubConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateGithubConnectorRequest {
    return new UpdateGithubConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateGithubConnectorRequest | PlainMessage<UpdateGithubConnectorRequest> | undefined, b: UpdateGithubConnectorRequest | PlainMessage<UpdateGithubConnectorRequest> | undefined): boolean {
    return proto3.util.equals(UpdateGithubConnectorRequest, a, b);
  }
}

/**
 * UpsertGithubConnectorRequest is a request for UpsertGithubConnector.
 *
 * @generated from message proto.UpsertGithubConnectorRequest
 */
export class UpsertGithubConnectorRequest extends Message<UpsertGithubConnectorRequest> {
  /**
   * Connector to be created or updated.
   *
   * @generated from field: types.GithubConnectorV3 Connector = 1;
   */
  Connector?: GithubConnectorV3;

  constructor(data?: PartialMessage<UpsertGithubConnectorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertGithubConnectorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connector", kind: "message", T: GithubConnectorV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertGithubConnectorRequest {
    return new UpsertGithubConnectorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertGithubConnectorRequest {
    return new UpsertGithubConnectorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertGithubConnectorRequest {
    return new UpsertGithubConnectorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertGithubConnectorRequest | PlainMessage<UpsertGithubConnectorRequest> | undefined, b: UpsertGithubConnectorRequest | PlainMessage<UpsertGithubConnectorRequest> | undefined): boolean {
    return proto3.util.equals(UpsertGithubConnectorRequest, a, b);
  }
}

/**
 * GetSSODiagnosticInfoRequest is a request for GetSSODiagnosticInfo.
 *
 * @generated from message proto.GetSSODiagnosticInfoRequest
 */
export class GetSSODiagnosticInfoRequest extends Message<GetSSODiagnosticInfoRequest> {
  /**
   * AuthRequestKind is the SSO Auth Request kind (oidc, saml, or github).
   *
   * @generated from field: string AuthRequestKind = 1;
   */
  AuthRequestKind = "";

  /**
   * AuthRequestID is the SSO Auth Request id or state token.
   *
   * @generated from field: string AuthRequestID = 2;
   */
  AuthRequestID = "";

  constructor(data?: PartialMessage<GetSSODiagnosticInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetSSODiagnosticInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AuthRequestKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AuthRequestID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSSODiagnosticInfoRequest {
    return new GetSSODiagnosticInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSSODiagnosticInfoRequest {
    return new GetSSODiagnosticInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSSODiagnosticInfoRequest {
    return new GetSSODiagnosticInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSSODiagnosticInfoRequest | PlainMessage<GetSSODiagnosticInfoRequest> | undefined, b: GetSSODiagnosticInfoRequest | PlainMessage<GetSSODiagnosticInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetSSODiagnosticInfoRequest, a, b);
  }
}

/**
 * SystemRoleAssertion is used by agents to prove that they have a given system role when their
 * credentials originate from multiple separate join tokens so that they can be issued an
 * instance certificate that encompasses all of their capabilities. This type will be
 * deprecated once we have a more comprehensive model for join token joining/replacement.
 *
 * @generated from message proto.SystemRoleAssertion
 */
export class SystemRoleAssertion extends Message<SystemRoleAssertion> {
  /**
   * ServerID is the server ID of the instance that the assertion is for. Assertions are
   * only accepted if the calling agent's certificate matches this server id.
   *
   * @generated from field: string ServerID = 1;
   */
  ServerID = "";

  /**
   * AssertionID is a random UUID that uniquely identifies a set of assertions
   * as originating from the same teleport process.
   *
   * @generated from field: string AssertionID = 2;
   */
  AssertionID = "";

  /**
   * SystemRole is the system role being asserted. Assertions are only accepted if
   * the calling agent's certificate authorizes it for this system role.
   *
   * @generated from field: string SystemRole = 3;
   */
  SystemRole = "";

  constructor(data?: PartialMessage<SystemRoleAssertion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SystemRoleAssertion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AssertionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "SystemRole", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SystemRoleAssertion {
    return new SystemRoleAssertion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SystemRoleAssertion {
    return new SystemRoleAssertion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SystemRoleAssertion {
    return new SystemRoleAssertion().fromJsonString(jsonString, options);
  }

  static equals(a: SystemRoleAssertion | PlainMessage<SystemRoleAssertion> | undefined, b: SystemRoleAssertion | PlainMessage<SystemRoleAssertion> | undefined): boolean {
    return proto3.util.equals(SystemRoleAssertion, a, b);
  }
}

/**
 * SystemRoleAssertionSet is an aggregate generated as a result of one or more successful
 * assertions. This type will be deprecated once we have a more comprehensive model for
 * join token joining/replacement.
 *
 * @generated from message proto.SystemRoleAssertionSet
 */
export class SystemRoleAssertionSet extends Message<SystemRoleAssertionSet> {
  /**
   * ServerID is the server ID of the agent that generated the assertions.
   *
   * @generated from field: string ServerID = 1;
   */
  ServerID = "";

  /**
   * AssertionID is a random UUID that identified all constituent assertions as originating
   * from the same teleport process.
   *
   * @generated from field: string AssertionID = 2;
   */
  AssertionID = "";

  /**
   * SystemRoles is the set of system roles that the agent has successfully asserted.
   *
   * @generated from field: repeated string SystemRoles = 3;
   */
  SystemRoles: string[] = [];

  constructor(data?: PartialMessage<SystemRoleAssertionSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SystemRoleAssertionSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "AssertionID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "SystemRoles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SystemRoleAssertionSet {
    return new SystemRoleAssertionSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SystemRoleAssertionSet {
    return new SystemRoleAssertionSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SystemRoleAssertionSet {
    return new SystemRoleAssertionSet().fromJsonString(jsonString, options);
  }

  static equals(a: SystemRoleAssertionSet | PlainMessage<SystemRoleAssertionSet> | undefined, b: SystemRoleAssertionSet | PlainMessage<SystemRoleAssertionSet> | undefined): boolean {
    return proto3.util.equals(SystemRoleAssertionSet, a, b);
  }
}

/**
 * UpstreamInventoryOneOf is the upstream message for the inventory control stream,
 * sent from teleport instances to the auth server.
 *
 * @generated from message proto.UpstreamInventoryOneOf
 */
export class UpstreamInventoryOneOf extends Message<UpstreamInventoryOneOf> {
  /**
   * @generated from oneof proto.UpstreamInventoryOneOf.Msg
   */
  Msg: {
    /**
     * Hello is the first message sent up the control stream.
     *
     * @generated from field: proto.UpstreamInventoryHello Hello = 1;
     */
    value: UpstreamInventoryHello;
    case: "Hello";
  } | {
    /**
     * Heartbeat advertises instance status/liveness.
     *
     * @generated from field: proto.InventoryHeartbeat Heartbeat = 2;
     */
    value: InventoryHeartbeat;
    case: "Heartbeat";
  } | {
    /**
     * UpstreamInventoryPong is a response to a ping (used for testing/debug).
     *
     * @generated from field: proto.UpstreamInventoryPong Pong = 3;
     */
    value: UpstreamInventoryPong;
    case: "Pong";
  } | {
    /**
     * UpstreamInventoryAgentMetadata advertises instance metadata.
     *
     * @generated from field: proto.UpstreamInventoryAgentMetadata AgentMetadata = 4;
     */
    value: UpstreamInventoryAgentMetadata;
    case: "AgentMetadata";
  } | {
    /**
     * UpstreamInventoryGoodbye advertises that the instance is terminating.
     *
     * @generated from field: proto.UpstreamInventoryGoodbye Goodbye = 5;
     */
    value: UpstreamInventoryGoodbye;
    case: "Goodbye";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UpstreamInventoryOneOf>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpstreamInventoryOneOf";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Hello", kind: "message", T: UpstreamInventoryHello, oneof: "Msg" },
    { no: 2, name: "Heartbeat", kind: "message", T: InventoryHeartbeat, oneof: "Msg" },
    { no: 3, name: "Pong", kind: "message", T: UpstreamInventoryPong, oneof: "Msg" },
    { no: 4, name: "AgentMetadata", kind: "message", T: UpstreamInventoryAgentMetadata, oneof: "Msg" },
    { no: 5, name: "Goodbye", kind: "message", T: UpstreamInventoryGoodbye, oneof: "Msg" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpstreamInventoryOneOf {
    return new UpstreamInventoryOneOf().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpstreamInventoryOneOf {
    return new UpstreamInventoryOneOf().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpstreamInventoryOneOf {
    return new UpstreamInventoryOneOf().fromJsonString(jsonString, options);
  }

  static equals(a: UpstreamInventoryOneOf | PlainMessage<UpstreamInventoryOneOf> | undefined, b: UpstreamInventoryOneOf | PlainMessage<UpstreamInventoryOneOf> | undefined): boolean {
    return proto3.util.equals(UpstreamInventoryOneOf, a, b);
  }
}

/**
 * DownstreamInventoryOneOf is the downstream message for the inventory control stream,
 * sent from auth servers to teleport instances.
 *
 * @generated from message proto.DownstreamInventoryOneOf
 */
export class DownstreamInventoryOneOf extends Message<DownstreamInventoryOneOf> {
  /**
   * @generated from oneof proto.DownstreamInventoryOneOf.Msg
   */
  Msg: {
    /**
     * Hello is the first message sent down the control stream.
     *
     * @generated from field: proto.DownstreamInventoryHello Hello = 1;
     */
    value: DownstreamInventoryHello;
    case: "Hello";
  } | {
    /**
     * Ping triggers an upstream pong (used for testing/debug).
     *
     * @generated from field: proto.DownstreamInventoryPing Ping = 2;
     */
    value: DownstreamInventoryPing;
    case: "Ping";
  } | {
    /**
     * UpdateLabels updates the instance's labels.
     *
     * @generated from field: proto.DownstreamInventoryUpdateLabels UpdateLabels = 3;
     */
    value: DownstreamInventoryUpdateLabels;
    case: "UpdateLabels";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DownstreamInventoryOneOf>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DownstreamInventoryOneOf";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Hello", kind: "message", T: DownstreamInventoryHello, oneof: "Msg" },
    { no: 2, name: "Ping", kind: "message", T: DownstreamInventoryPing, oneof: "Msg" },
    { no: 3, name: "UpdateLabels", kind: "message", T: DownstreamInventoryUpdateLabels, oneof: "Msg" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownstreamInventoryOneOf {
    return new DownstreamInventoryOneOf().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownstreamInventoryOneOf {
    return new DownstreamInventoryOneOf().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownstreamInventoryOneOf {
    return new DownstreamInventoryOneOf().fromJsonString(jsonString, options);
  }

  static equals(a: DownstreamInventoryOneOf | PlainMessage<DownstreamInventoryOneOf> | undefined, b: DownstreamInventoryOneOf | PlainMessage<DownstreamInventoryOneOf> | undefined): boolean {
    return proto3.util.equals(DownstreamInventoryOneOf, a, b);
  }
}

/**
 * DownstreamInventoryPing is sent down the inventory control stream for testing/debug
 * purposes.
 *
 * @generated from message proto.DownstreamInventoryPing
 */
export class DownstreamInventoryPing extends Message<DownstreamInventoryPing> {
  /**
   * @generated from field: uint64 ID = 1;
   */
  ID = protoInt64.zero;

  constructor(data?: PartialMessage<DownstreamInventoryPing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DownstreamInventoryPing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownstreamInventoryPing {
    return new DownstreamInventoryPing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownstreamInventoryPing {
    return new DownstreamInventoryPing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownstreamInventoryPing {
    return new DownstreamInventoryPing().fromJsonString(jsonString, options);
  }

  static equals(a: DownstreamInventoryPing | PlainMessage<DownstreamInventoryPing> | undefined, b: DownstreamInventoryPing | PlainMessage<DownstreamInventoryPing> | undefined): boolean {
    return proto3.util.equals(DownstreamInventoryPing, a, b);
  }
}

/**
 * UpstreamInventoryPong is sent up the inventory control stream in response to a downstream
 * ping (used for testing/debug purposes).
 *
 * @generated from message proto.UpstreamInventoryPong
 */
export class UpstreamInventoryPong extends Message<UpstreamInventoryPong> {
  /**
   * @generated from field: uint64 ID = 1;
   */
  ID = protoInt64.zero;

  constructor(data?: PartialMessage<UpstreamInventoryPong>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpstreamInventoryPong";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ID", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpstreamInventoryPong {
    return new UpstreamInventoryPong().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpstreamInventoryPong {
    return new UpstreamInventoryPong().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpstreamInventoryPong {
    return new UpstreamInventoryPong().fromJsonString(jsonString, options);
  }

  static equals(a: UpstreamInventoryPong | PlainMessage<UpstreamInventoryPong> | undefined, b: UpstreamInventoryPong | PlainMessage<UpstreamInventoryPong> | undefined): boolean {
    return proto3.util.equals(UpstreamInventoryPong, a, b);
  }
}

/**
 * UpstreamInventoryHello is the hello message sent up the inventory control stream.
 *
 * @generated from message proto.UpstreamInventoryHello
 */
export class UpstreamInventoryHello extends Message<UpstreamInventoryHello> {
  /**
   * Version advertises the teleport version of the instance.
   *
   * @generated from field: string Version = 1;
   */
  Version = "";

  /**
   * ServerID advertises the server ID of the instance.
   *
   * @generated from field: string ServerID = 2;
   */
  ServerID = "";

  /**
   * Services advertises the currently live services of the instance. note: this is
   * distinct from the SystemRoles associated with a certificate in that a service may
   * hold a system role that is not currently in use if it was granted that role by
   * its auth token. i.e. Services is the subset of SystemRoles that are currently
   * active.
   *
   * @generated from field: repeated string Services = 3;
   */
  Services: string[] = [];

  /**
   * Hostname is the hostname associated with the instance. This value is not required or guaranteed
   * to be unique and its validity is not enforceable (i.e. join tokens do not constrain what an
   * instance can claim its hostname to be). This value exists only to assist users in correlating
   * instance resources with hosts.
   *
   * @generated from field: string Hostname = 4;
   */
  Hostname = "";

  /**
   * ExternalUpgrader identifies the external upgrader that the instance is configured to
   * export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
   *
   * @generated from field: string ExternalUpgrader = 5;
   */
  ExternalUpgrader = "";

  /**
   * ExternalUpgraderVersion identifies the external upgrader version. Empty if no upgrader is defined.
   *
   * @generated from field: string ExternalUpgraderVersion = 6;
   */
  ExternalUpgraderVersion = "";

  constructor(data?: PartialMessage<UpstreamInventoryHello>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpstreamInventoryHello";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Services", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "Hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ExternalUpgrader", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ExternalUpgraderVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpstreamInventoryHello {
    return new UpstreamInventoryHello().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpstreamInventoryHello {
    return new UpstreamInventoryHello().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpstreamInventoryHello {
    return new UpstreamInventoryHello().fromJsonString(jsonString, options);
  }

  static equals(a: UpstreamInventoryHello | PlainMessage<UpstreamInventoryHello> | undefined, b: UpstreamInventoryHello | PlainMessage<UpstreamInventoryHello> | undefined): boolean {
    return proto3.util.equals(UpstreamInventoryHello, a, b);
  }
}

/**
 * UpstreamInventoryAgentMetadata is the message sent up the inventory control stream containing
 * metadata about the instance.
 *
 * @generated from message proto.UpstreamInventoryAgentMetadata
 */
export class UpstreamInventoryAgentMetadata extends Message<UpstreamInventoryAgentMetadata> {
  /**
   * OS advertises the instance OS ("darwin" or "linux").
   *
   * @generated from field: string OS = 1;
   */
  OS = "";

  /**
   * OSVersion advertises the instance OS version (e.g. "ubuntu 22.04").
   *
   * @generated from field: string OSVersion = 2;
   */
  OSVersion = "";

  /**
   * HostArchitecture advertises the instance host architecture (e.g. "x86_64" or "arm64").
   *
   * @generated from field: string HostArchitecture = 3;
   */
  HostArchitecture = "";

  /**
   * GlibcVersion advertises the instance glibc version of linux instances (e.g. "2.35").
   *
   * @generated from field: string GlibcVersion = 4;
   */
  GlibcVersion = "";

  /**
   * InstallMethods advertises the install methods used for the instance (e.g. "dockerfile").
   *
   * @generated from field: repeated string InstallMethods = 5;
   */
  InstallMethods: string[] = [];

  /**
   * ContainerRuntime advertises the container runtime for the instance, if any (e.g. "docker").
   *
   * @generated from field: string ContainerRuntime = 6;
   */
  ContainerRuntime = "";

  /**
   * ContainerOrchestrator advertises the container orchestrator for the instance, if any
   * (e.g. "kubernetes-v1.24.8-eks-ffeb93d").
   *
   * @generated from field: string ContainerOrchestrator = 7;
   */
  ContainerOrchestrator = "";

  /**
   * CloudEnvironment advertises the cloud environment for the instance, if any (e.g. "aws").
   *
   * @generated from field: string CloudEnvironment = 8;
   */
  CloudEnvironment = "";

  constructor(data?: PartialMessage<UpstreamInventoryAgentMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpstreamInventoryAgentMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "OS", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "OSVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "HostArchitecture", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "GlibcVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "InstallMethods", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "ContainerRuntime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "ContainerOrchestrator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "CloudEnvironment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpstreamInventoryAgentMetadata {
    return new UpstreamInventoryAgentMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpstreamInventoryAgentMetadata {
    return new UpstreamInventoryAgentMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpstreamInventoryAgentMetadata {
    return new UpstreamInventoryAgentMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: UpstreamInventoryAgentMetadata | PlainMessage<UpstreamInventoryAgentMetadata> | undefined, b: UpstreamInventoryAgentMetadata | PlainMessage<UpstreamInventoryAgentMetadata> | undefined): boolean {
    return proto3.util.equals(UpstreamInventoryAgentMetadata, a, b);
  }
}

/**
 * DownstreamInventoryHello is the hello message sent down the inventory control stream.
 *
 * @generated from message proto.DownstreamInventoryHello
 */
export class DownstreamInventoryHello extends Message<DownstreamInventoryHello> {
  /**
   * Version advertises the version of the auth server.
   *
   * @generated from field: string Version = 1;
   */
  Version = "";

  /**
   * ServerID advertises the server ID of the auth server.
   *
   * @generated from field: string ServerID = 2;
   */
  ServerID = "";

  /**
   * SupportedCapabilities advertises the supported features of the auth server.
   *
   * @generated from field: proto.DownstreamInventoryHello.SupportedCapabilities Capabilities = 3;
   */
  Capabilities?: DownstreamInventoryHello_SupportedCapabilities;

  constructor(data?: PartialMessage<DownstreamInventoryHello>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DownstreamInventoryHello";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "Capabilities", kind: "message", T: DownstreamInventoryHello_SupportedCapabilities },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownstreamInventoryHello {
    return new DownstreamInventoryHello().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownstreamInventoryHello {
    return new DownstreamInventoryHello().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownstreamInventoryHello {
    return new DownstreamInventoryHello().fromJsonString(jsonString, options);
  }

  static equals(a: DownstreamInventoryHello | PlainMessage<DownstreamInventoryHello> | undefined, b: DownstreamInventoryHello | PlainMessage<DownstreamInventoryHello> | undefined): boolean {
    return proto3.util.equals(DownstreamInventoryHello, a, b);
  }
}

/**
 * SupportedCapabilities indicate which features of the ICS that
 * the connect auth server supports. This allows agents to determine
 * how they should interact with the auth server to maintain compatibility.
 *
 * @generated from message proto.DownstreamInventoryHello.SupportedCapabilities
 */
export class DownstreamInventoryHello_SupportedCapabilities extends Message<DownstreamInventoryHello_SupportedCapabilities> {
  /**
   * ProxyHeartbeats indicates the ICS supports heartbeating proxy servers.
   *
   * @generated from field: bool ProxyHeartbeats = 1;
   */
  ProxyHeartbeats = false;

  /**
   * ProxyCleanup indicates the ICS supports deleting proxies when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool ProxyCleanup = 2;
   */
  ProxyCleanup = false;

  /**
   * ProxyHeartbeats indicates the ICS supports heartbeating proxy servers.
   *
   * @generated from field: bool AuthHeartbeats = 3;
   */
  AuthHeartbeats = false;

  /**
   * ProxyCleanup indicates the ICS supports deleting proxies when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool AuthCleanup = 4;
   */
  AuthCleanup = false;

  /**
   * NodeHeartbeats indicates the ICS supports heartbeating ssh servers.
   *
   * @generated from field: bool NodeHeartbeats = 5;
   */
  NodeHeartbeats = false;

  /**
   * NodeCleanup indicates the ICS supports deleting nodes when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool NodeCleanup = 6;
   */
  NodeCleanup = false;

  /**
   * AppHeartbeats indicates the ICS supports heartbeating app servers.
   *
   * @generated from field: bool AppHeartbeats = 7;
   */
  AppHeartbeats = false;

  /**
   * AppCleanup indicates the ICS supports deleting apps when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool AppCleanup = 8;
   */
  AppCleanup = false;

  /**
   * DatabaseHeartbeats indicates the ICS supports heartbeating databases.
   *
   * @generated from field: bool DatabaseHeartbeats = 9;
   */
  DatabaseHeartbeats = false;

  /**
   * DatabaseCleanup indicates the ICS supports deleting databases when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool DatabaseCleanup = 10;
   */
  DatabaseCleanup = false;

  /**
   * DatabaseServiceHeartbeats indicates the ICS supports heartbeating databse services.
   *
   * @generated from field: bool DatabaseServiceHeartbeats = 11;
   */
  DatabaseServiceHeartbeats = false;

  /**
   * DatabaseServiceCleanup indicates the ICS supports deleting database services when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool DatabaseServiceCleanup = 12;
   */
  DatabaseServiceCleanup = false;

  /**
   * WindowsDesktopHeartbeats indicates the ICS supports heartbeating windows desktop servers.
   *
   * @generated from field: bool WindowsDesktopHeartbeats = 13;
   */
  WindowsDesktopHeartbeats = false;

  /**
   * WindowsDesktopCleanup indicates the ICS supports deleting windows desktops when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool WindowsDesktopCleanup = 14;
   */
  WindowsDesktopCleanup = false;

  /**
   * WindowsDesktopHeartbeats indicates the ICS supports heartbeating windows desktop services.
   *
   * @generated from field: bool WindowsDesktopServiceHeartbeats = 15;
   */
  WindowsDesktopServiceHeartbeats = false;

  /**
   * WindowsDesktopCleanup indicates the ICS supports deleting windows desktop services when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool WindowsDesktopServiceCleanup = 16;
   */
  WindowsDesktopServiceCleanup = false;

  /**
   * KubernetesHeartbeats indicates the ICS supports heartbeating kubernetes clusters.
   *
   * @generated from field: bool KubernetesHeartbeats = 17;
   */
  KubernetesHeartbeats = false;

  /**
   * KubernetesCleanup indicates the ICS supports deleting kubernetes clusters when UpstreamInventoryGoodbye.DeleteResources is set.
   *
   * @generated from field: bool KubernetesCleanup = 18;
   */
  KubernetesCleanup = false;

  constructor(data?: PartialMessage<DownstreamInventoryHello_SupportedCapabilities>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DownstreamInventoryHello.SupportedCapabilities";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ProxyHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "ProxyCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "AuthHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "AuthCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "NodeHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "NodeCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "AppHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "AppCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "DatabaseHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "DatabaseCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "DatabaseServiceHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "DatabaseServiceCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "WindowsDesktopHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "WindowsDesktopCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "WindowsDesktopServiceHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "WindowsDesktopServiceCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "KubernetesHeartbeats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "KubernetesCleanup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownstreamInventoryHello_SupportedCapabilities {
    return new DownstreamInventoryHello_SupportedCapabilities().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownstreamInventoryHello_SupportedCapabilities {
    return new DownstreamInventoryHello_SupportedCapabilities().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownstreamInventoryHello_SupportedCapabilities {
    return new DownstreamInventoryHello_SupportedCapabilities().fromJsonString(jsonString, options);
  }

  static equals(a: DownstreamInventoryHello_SupportedCapabilities | PlainMessage<DownstreamInventoryHello_SupportedCapabilities> | undefined, b: DownstreamInventoryHello_SupportedCapabilities | PlainMessage<DownstreamInventoryHello_SupportedCapabilities> | undefined): boolean {
    return proto3.util.equals(DownstreamInventoryHello_SupportedCapabilities, a, b);
  }
}

/**
 * InventoryUpdateLabelsRequest is used to request that a specified instance
 * update its labels.
 *
 * @generated from message proto.InventoryUpdateLabelsRequest
 */
export class InventoryUpdateLabelsRequest extends Message<InventoryUpdateLabelsRequest> {
  /**
   * ServerID advertises the server ID of the instance.
   *
   * @generated from field: string ServerID = 1;
   */
  ServerID = "";

  /**
   * Kind is the type of service to update labels for.
   *
   * @generated from field: proto.LabelUpdateKind Kind = 2;
   */
  Kind = LabelUpdateKind.SSHServer;

  /**
   * Labels is the new set of labels for the instance.
   *
   * @generated from field: map<string, string> Labels = 3;
   */
  Labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<InventoryUpdateLabelsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryUpdateLabelsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Kind", kind: "enum", T: proto3.getEnumType(LabelUpdateKind) },
    { no: 3, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryUpdateLabelsRequest {
    return new InventoryUpdateLabelsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryUpdateLabelsRequest {
    return new InventoryUpdateLabelsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryUpdateLabelsRequest {
    return new InventoryUpdateLabelsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryUpdateLabelsRequest | PlainMessage<InventoryUpdateLabelsRequest> | undefined, b: InventoryUpdateLabelsRequest | PlainMessage<InventoryUpdateLabelsRequest> | undefined): boolean {
    return proto3.util.equals(InventoryUpdateLabelsRequest, a, b);
  }
}

/**
 * DownstreamInventoryUpdateLabels is the message sent down the inventory
 * control stream to update the instance's labels.
 *
 * @generated from message proto.DownstreamInventoryUpdateLabels
 */
export class DownstreamInventoryUpdateLabels extends Message<DownstreamInventoryUpdateLabels> {
  /**
   * Kind is the type of service to update labels for.
   *
   * @generated from field: proto.LabelUpdateKind Kind = 1;
   */
  Kind = LabelUpdateKind.SSHServer;

  /**
   * Labels is the new set of labels for the instance.
   *
   * @generated from field: map<string, string> Labels = 2;
   */
  Labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<DownstreamInventoryUpdateLabels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.DownstreamInventoryUpdateLabels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Kind", kind: "enum", T: proto3.getEnumType(LabelUpdateKind) },
    { no: 2, name: "Labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownstreamInventoryUpdateLabels {
    return new DownstreamInventoryUpdateLabels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownstreamInventoryUpdateLabels {
    return new DownstreamInventoryUpdateLabels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownstreamInventoryUpdateLabels {
    return new DownstreamInventoryUpdateLabels().fromJsonString(jsonString, options);
  }

  static equals(a: DownstreamInventoryUpdateLabels | PlainMessage<DownstreamInventoryUpdateLabels> | undefined, b: DownstreamInventoryUpdateLabels | PlainMessage<DownstreamInventoryUpdateLabels> | undefined): boolean {
    return proto3.util.equals(DownstreamInventoryUpdateLabels, a, b);
  }
}

/**
 * InventoryHeartbeat announces information about instance state.
 *
 * @generated from message proto.InventoryHeartbeat
 */
export class InventoryHeartbeat extends Message<InventoryHeartbeat> {
  /**
   * SSHServer is a complete ssh server spec to be heartbeated (note: the full spec is heartbeated
   * in the interest of simple conversion from the old logic of heartbeating via UpsertNode, but
   * we should be able to cut down on network usage fairly significantly by moving static values
   * to the hello message and only heartbeating dynamic values here).
   *
   * @generated from field: types.ServerV2 SSHServer = 1;
   */
  SSHServer?: ServerV2;

  /**
   * AppServer is a complete app server spec to be heartbeated.
   *
   * @generated from field: types.AppServerV3 AppServer = 2;
   */
  AppServer?: AppServerV3;

  /**
   * DatabaseServer is a complete db server spec to be heartbeated.
   *
   * @generated from field: types.DatabaseServerV3 DatabaseServer = 3;
   */
  DatabaseServer?: DatabaseServerV3;

  /**
   * KubeServer is a complete kube server spec to be heartbeated.
   *
   * @generated from field: types.KubernetesServerV3 KubernetesServer = 4;
   */
  KubernetesServer?: KubernetesServerV3;

  constructor(data?: PartialMessage<InventoryHeartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryHeartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "SSHServer", kind: "message", T: ServerV2 },
    { no: 2, name: "AppServer", kind: "message", T: AppServerV3 },
    { no: 3, name: "DatabaseServer", kind: "message", T: DatabaseServerV3 },
    { no: 4, name: "KubernetesServer", kind: "message", T: KubernetesServerV3 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryHeartbeat {
    return new InventoryHeartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryHeartbeat {
    return new InventoryHeartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryHeartbeat {
    return new InventoryHeartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryHeartbeat | PlainMessage<InventoryHeartbeat> | undefined, b: InventoryHeartbeat | PlainMessage<InventoryHeartbeat> | undefined): boolean {
    return proto3.util.equals(InventoryHeartbeat, a, b);
  }
}

/**
 * UpstreamInventoryGoodbye informs the upstream service that instance
 * is terminating
 *
 * @generated from message proto.UpstreamInventoryGoodbye
 */
export class UpstreamInventoryGoodbye extends Message<UpstreamInventoryGoodbye> {
  /**
   * DeleteResources indicates that any heartbeats received from
   * the instance should be terminated when the stream is closed.
   *
   * @generated from field: bool DeleteResources = 1;
   */
  DeleteResources = false;

  constructor(data?: PartialMessage<UpstreamInventoryGoodbye>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpstreamInventoryGoodbye";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "DeleteResources", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpstreamInventoryGoodbye {
    return new UpstreamInventoryGoodbye().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpstreamInventoryGoodbye {
    return new UpstreamInventoryGoodbye().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpstreamInventoryGoodbye {
    return new UpstreamInventoryGoodbye().fromJsonString(jsonString, options);
  }

  static equals(a: UpstreamInventoryGoodbye | PlainMessage<UpstreamInventoryGoodbye> | undefined, b: UpstreamInventoryGoodbye | PlainMessage<UpstreamInventoryGoodbye> | undefined): boolean {
    return proto3.util.equals(UpstreamInventoryGoodbye, a, b);
  }
}

/**
 * InventoryStatusRequest requests inventory status info.
 *
 * @generated from message proto.InventoryStatusRequest
 */
export class InventoryStatusRequest extends Message<InventoryStatusRequest> {
  /**
   * Connected requests summary of the inventory control streams registered with
   * the auth server that handles the request.
   *
   * @generated from field: bool Connected = 1;
   */
  Connected = false;

  constructor(data?: PartialMessage<InventoryStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connected", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryStatusRequest {
    return new InventoryStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryStatusRequest {
    return new InventoryStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryStatusRequest {
    return new InventoryStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryStatusRequest | PlainMessage<InventoryStatusRequest> | undefined, b: InventoryStatusRequest | PlainMessage<InventoryStatusRequest> | undefined): boolean {
    return proto3.util.equals(InventoryStatusRequest, a, b);
  }
}

/**
 * InventoryStatusSummary is the status summary returned by the GetInventoryStatus rpc.
 *
 * @generated from message proto.InventoryStatusSummary
 */
export class InventoryStatusSummary extends Message<InventoryStatusSummary> {
  /**
   * Connected is a summary of the instances connected to the current auth server.  Only set if
   * the Connected flag in the status request is true.
   *
   * @generated from field: repeated proto.UpstreamInventoryHello Connected = 1;
   */
  Connected: UpstreamInventoryHello[] = [];

  /**
   * InstanceCount is the total number of instance resources aggregated.
   *
   * @generated from field: uint32 InstanceCount = 2;
   */
  InstanceCount = 0;

  /**
   * VersionCounts aggregates unique version counts.
   *
   * @generated from field: map<string, uint32> VersionCounts = 3;
   */
  VersionCounts: { [key: string]: number } = {};

  /**
   * UpgraderCounts aggregates the unique upgrader counts.
   *
   * @generated from field: map<string, uint32> UpgraderCounts = 4;
   */
  UpgraderCounts: { [key: string]: number } = {};

  /**
   * ServiceCounts aggregates the number of services.
   *
   * @generated from field: map<string, uint32> ServiceCounts = 5;
   */
  ServiceCounts: { [key: string]: number } = {};

  constructor(data?: PartialMessage<InventoryStatusSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryStatusSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Connected", kind: "message", T: UpstreamInventoryHello, repeated: true },
    { no: 2, name: "InstanceCount", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "VersionCounts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 13 /* ScalarType.UINT32 */} },
    { no: 4, name: "UpgraderCounts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 13 /* ScalarType.UINT32 */} },
    { no: 5, name: "ServiceCounts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 13 /* ScalarType.UINT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryStatusSummary {
    return new InventoryStatusSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryStatusSummary {
    return new InventoryStatusSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryStatusSummary {
    return new InventoryStatusSummary().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryStatusSummary | PlainMessage<InventoryStatusSummary> | undefined, b: InventoryStatusSummary | PlainMessage<InventoryStatusSummary> | undefined): boolean {
    return proto3.util.equals(InventoryStatusSummary, a, b);
  }
}

/**
 * InventoryConnectedServiceCountsRequest requests inventory connected service counts.
 *
 * @generated from message proto.InventoryConnectedServiceCountsRequest
 */
export class InventoryConnectedServiceCountsRequest extends Message<InventoryConnectedServiceCountsRequest> {
  constructor(data?: PartialMessage<InventoryConnectedServiceCountsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryConnectedServiceCountsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryConnectedServiceCountsRequest {
    return new InventoryConnectedServiceCountsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryConnectedServiceCountsRequest {
    return new InventoryConnectedServiceCountsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryConnectedServiceCountsRequest {
    return new InventoryConnectedServiceCountsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryConnectedServiceCountsRequest | PlainMessage<InventoryConnectedServiceCountsRequest> | undefined, b: InventoryConnectedServiceCountsRequest | PlainMessage<InventoryConnectedServiceCountsRequest> | undefined): boolean {
    return proto3.util.equals(InventoryConnectedServiceCountsRequest, a, b);
  }
}

/**
 * InventoryConnectedServiceCounts is the connected service counts seen in the inventory.
 *
 * @generated from message proto.InventoryConnectedServiceCounts
 */
export class InventoryConnectedServiceCounts extends Message<InventoryConnectedServiceCounts> {
  /**
   * ServiceCounts is the count of each connected service seen in the inventory.
   *
   * @generated from field: map<string, uint64> ServiceCounts = 1;
   */
  ServiceCounts: { [key: string]: bigint } = {};

  constructor(data?: PartialMessage<InventoryConnectedServiceCounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryConnectedServiceCounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServiceCounts", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 4 /* ScalarType.UINT64 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryConnectedServiceCounts {
    return new InventoryConnectedServiceCounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryConnectedServiceCounts {
    return new InventoryConnectedServiceCounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryConnectedServiceCounts {
    return new InventoryConnectedServiceCounts().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryConnectedServiceCounts | PlainMessage<InventoryConnectedServiceCounts> | undefined, b: InventoryConnectedServiceCounts | PlainMessage<InventoryConnectedServiceCounts> | undefined): boolean {
    return proto3.util.equals(InventoryConnectedServiceCounts, a, b);
  }
}

/**
 * InventoryPingRequest is used to request that the specified server be sent an inventory ping
 * if it has a control stream registered.
 *
 * @generated from message proto.InventoryPingRequest
 */
export class InventoryPingRequest extends Message<InventoryPingRequest> {
  /**
   * ServerID is the ID of the instance to ping.
   *
   * @generated from field: string ServerID = 1;
   */
  ServerID = "";

  /**
   * ControlLog forces the ping to use the standard "commit then act" model of control log synchronization
   * for the ping. This significantly increases the amount of time it takes for the ping request to
   * complete, but is useful for testing/debugging control log issues.
   *
   * @generated from field: bool ControlLog = 2;
   */
  ControlLog = false;

  constructor(data?: PartialMessage<InventoryPingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryPingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ServerID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ControlLog", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryPingRequest {
    return new InventoryPingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryPingRequest {
    return new InventoryPingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryPingRequest {
    return new InventoryPingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryPingRequest | PlainMessage<InventoryPingRequest> | undefined, b: InventoryPingRequest | PlainMessage<InventoryPingRequest> | undefined): boolean {
    return proto3.util.equals(InventoryPingRequest, a, b);
  }
}

/**
 * InventoryPingResponse returns the result of an inventory ping initiated via an
 * inventory ping request.
 *
 * @generated from message proto.InventoryPingResponse
 */
export class InventoryPingResponse extends Message<InventoryPingResponse> {
  /**
   * @generated from field: int64 Duration = 1;
   */
  Duration = protoInt64.zero;

  constructor(data?: PartialMessage<InventoryPingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.InventoryPingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryPingResponse {
    return new InventoryPingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryPingResponse {
    return new InventoryPingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryPingResponse {
    return new InventoryPingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryPingResponse | PlainMessage<InventoryPingResponse> | undefined, b: InventoryPingResponse | PlainMessage<InventoryPingResponse> | undefined): boolean {
    return proto3.util.equals(InventoryPingResponse, a, b);
  }
}

/**
 * GetClusterAlertsResponse contains the result of a cluster alerts query.
 *
 * @generated from message proto.GetClusterAlertsResponse
 */
export class GetClusterAlertsResponse extends Message<GetClusterAlertsResponse> {
  /**
   * Alerts is the list of matching alerts.
   *
   * @generated from field: repeated types.ClusterAlert Alerts = 1;
   */
  Alerts: ClusterAlert[] = [];

  constructor(data?: PartialMessage<GetClusterAlertsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetClusterAlertsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Alerts", kind: "message", T: ClusterAlert, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterAlertsResponse {
    return new GetClusterAlertsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterAlertsResponse {
    return new GetClusterAlertsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterAlertsResponse {
    return new GetClusterAlertsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterAlertsResponse | PlainMessage<GetClusterAlertsResponse> | undefined, b: GetClusterAlertsResponse | PlainMessage<GetClusterAlertsResponse> | undefined): boolean {
    return proto3.util.equals(GetClusterAlertsResponse, a, b);
  }
}

/**
 * GetAlertAcksRequest returns the currently acknowledged alerts
 *
 * GetAlertAcksRequest currently takes no params
 *
 * @generated from message proto.GetAlertAcksRequest
 */
export class GetAlertAcksRequest extends Message<GetAlertAcksRequest> {
  constructor(data?: PartialMessage<GetAlertAcksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetAlertAcksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAlertAcksRequest {
    return new GetAlertAcksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAlertAcksRequest {
    return new GetAlertAcksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAlertAcksRequest {
    return new GetAlertAcksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAlertAcksRequest | PlainMessage<GetAlertAcksRequest> | undefined, b: GetAlertAcksRequest | PlainMessage<GetAlertAcksRequest> | undefined): boolean {
    return proto3.util.equals(GetAlertAcksRequest, a, b);
  }
}

/**
 * GetAlertAcksResponse contains the set of active cluster alert
 * acknowledgements for this cluster.
 *
 * @generated from message proto.GetAlertAcksResponse
 */
export class GetAlertAcksResponse extends Message<GetAlertAcksResponse> {
  /**
   * @generated from field: repeated types.AlertAcknowledgement Acks = 1;
   */
  Acks: AlertAcknowledgement[] = [];

  constructor(data?: PartialMessage<GetAlertAcksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetAlertAcksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Acks", kind: "message", T: AlertAcknowledgement, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAlertAcksResponse {
    return new GetAlertAcksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAlertAcksResponse {
    return new GetAlertAcksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAlertAcksResponse {
    return new GetAlertAcksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAlertAcksResponse | PlainMessage<GetAlertAcksResponse> | undefined, b: GetAlertAcksResponse | PlainMessage<GetAlertAcksResponse> | undefined): boolean {
    return proto3.util.equals(GetAlertAcksResponse, a, b);
  }
}

/**
 * ClearAlertAcksRequest specifies alerts acknowledgements to clear.
 *
 * @generated from message proto.ClearAlertAcksRequest
 */
export class ClearAlertAcksRequest extends Message<ClearAlertAcksRequest> {
  /**
   * AlertID deletes an acknowledgement by ID. Deletes all acknowledgements if
   * the id is '*'.
   *
   * @generated from field: string AlertID = 1;
   */
  AlertID = "";

  constructor(data?: PartialMessage<ClearAlertAcksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ClearAlertAcksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AlertID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClearAlertAcksRequest {
    return new ClearAlertAcksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClearAlertAcksRequest {
    return new ClearAlertAcksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClearAlertAcksRequest {
    return new ClearAlertAcksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ClearAlertAcksRequest | PlainMessage<ClearAlertAcksRequest> | undefined, b: ClearAlertAcksRequest | PlainMessage<ClearAlertAcksRequest> | undefined): boolean {
    return proto3.util.equals(ClearAlertAcksRequest, a, b);
  }
}

/**
 * UpsertClusterAlertRequest is used to create a cluster alert.
 *
 * @generated from message proto.UpsertClusterAlertRequest
 */
export class UpsertClusterAlertRequest extends Message<UpsertClusterAlertRequest> {
  /**
   * Alert is the alert being created.
   *
   * @generated from field: types.ClusterAlert Alert = 1;
   */
  Alert?: ClusterAlert;

  constructor(data?: PartialMessage<UpsertClusterAlertRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertClusterAlertRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Alert", kind: "message", T: ClusterAlert },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertClusterAlertRequest {
    return new UpsertClusterAlertRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertClusterAlertRequest {
    return new UpsertClusterAlertRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertClusterAlertRequest {
    return new UpsertClusterAlertRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertClusterAlertRequest | PlainMessage<UpsertClusterAlertRequest> | undefined, b: UpsertClusterAlertRequest | PlainMessage<UpsertClusterAlertRequest> | undefined): boolean {
    return proto3.util.equals(UpsertClusterAlertRequest, a, b);
  }
}

/**
 * GetConnectionDiagnosticRequest is a request to return a connection diagnostic.
 *
 * @generated from message proto.GetConnectionDiagnosticRequest
 */
export class GetConnectionDiagnosticRequest extends Message<GetConnectionDiagnosticRequest> {
  /**
   * Name is the name of the connection diagnostic.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  constructor(data?: PartialMessage<GetConnectionDiagnosticRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetConnectionDiagnosticRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionDiagnosticRequest {
    return new GetConnectionDiagnosticRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionDiagnosticRequest {
    return new GetConnectionDiagnosticRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionDiagnosticRequest {
    return new GetConnectionDiagnosticRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionDiagnosticRequest | PlainMessage<GetConnectionDiagnosticRequest> | undefined, b: GetConnectionDiagnosticRequest | PlainMessage<GetConnectionDiagnosticRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionDiagnosticRequest, a, b);
  }
}

/**
 * AppendDiagnosticTraceRequest is a request to append a trace into a DiagnosticConnection.
 *
 * @generated from message proto.AppendDiagnosticTraceRequest
 */
export class AppendDiagnosticTraceRequest extends Message<AppendDiagnosticTraceRequest> {
  /**
   * Name is the name of the connection diagnostic.
   *
   * @generated from field: string Name = 1;
   */
  Name = "";

  /**
   * Trace is the ConnectionDiagnosticTrace to append into the DiagnosticConnection.
   *
   * @generated from field: types.ConnectionDiagnosticTrace Trace = 2;
   */
  Trace?: ConnectionDiagnosticTrace;

  constructor(data?: PartialMessage<AppendDiagnosticTraceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AppendDiagnosticTraceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "Trace", kind: "message", T: ConnectionDiagnosticTrace },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppendDiagnosticTraceRequest {
    return new AppendDiagnosticTraceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppendDiagnosticTraceRequest {
    return new AppendDiagnosticTraceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppendDiagnosticTraceRequest {
    return new AppendDiagnosticTraceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AppendDiagnosticTraceRequest | PlainMessage<AppendDiagnosticTraceRequest> | undefined, b: AppendDiagnosticTraceRequest | PlainMessage<AppendDiagnosticTraceRequest> | undefined): boolean {
    return proto3.util.equals(AppendDiagnosticTraceRequest, a, b);
  }
}

/**
 * SubmitUsageEventRequest is used to submit an external usage event.
 *
 * @generated from message proto.SubmitUsageEventRequest
 */
export class SubmitUsageEventRequest extends Message<SubmitUsageEventRequest> {
  /**
   * @generated from field: teleport.usageevents.v1.UsageEventOneOf Event = 1;
   */
  Event?: UsageEventOneOf;

  constructor(data?: PartialMessage<SubmitUsageEventRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.SubmitUsageEventRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Event", kind: "message", T: UsageEventOneOf },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitUsageEventRequest {
    return new SubmitUsageEventRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitUsageEventRequest {
    return new SubmitUsageEventRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubmitUsageEventRequest {
    return new SubmitUsageEventRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubmitUsageEventRequest | PlainMessage<SubmitUsageEventRequest> | undefined, b: SubmitUsageEventRequest | PlainMessage<SubmitUsageEventRequest> | undefined): boolean {
    return proto3.util.equals(SubmitUsageEventRequest, a, b);
  }
}

/**
 * GetLicenseEvent is used to submit an external usage event.
 *
 * GetLicense currently takes no params
 *
 * @generated from message proto.GetLicenseRequest
 */
export class GetLicenseRequest extends Message<GetLicenseRequest> {
  constructor(data?: PartialMessage<GetLicenseRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetLicenseRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLicenseRequest {
    return new GetLicenseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLicenseRequest {
    return new GetLicenseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLicenseRequest {
    return new GetLicenseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLicenseRequest | PlainMessage<GetLicenseRequest> | undefined, b: GetLicenseRequest | PlainMessage<GetLicenseRequest> | undefined): boolean {
    return proto3.util.equals(GetLicenseRequest, a, b);
  }
}

/**
 * GetLicenseEvent is used to submit an external usage event.
 *
 * ListReleases currently takes no params
 *
 * @generated from message proto.ListReleasesRequest
 */
export class ListReleasesRequest extends Message<ListReleasesRequest> {
  constructor(data?: PartialMessage<ListReleasesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListReleasesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListReleasesRequest {
    return new ListReleasesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListReleasesRequest {
    return new ListReleasesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListReleasesRequest {
    return new ListReleasesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListReleasesRequest | PlainMessage<ListReleasesRequest> | undefined, b: ListReleasesRequest | PlainMessage<ListReleasesRequest> | undefined): boolean {
    return proto3.util.equals(ListReleasesRequest, a, b);
  }
}

/**
 * CreateTokenV2Request is used with CreateTokenV2 to create tokens in the
 * backend.
 *
 * @generated from message proto.CreateTokenV2Request
 */
export class CreateTokenV2Request extends Message<CreateTokenV2Request> {
  /**
   * @generated from oneof proto.CreateTokenV2Request.Token
   */
  Token: {
    /**
     * @generated from field: types.ProvisionTokenV2 V2 = 1;
     */
    value: ProvisionTokenV2;
    case: "V2";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CreateTokenV2Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.CreateTokenV2Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "V2", kind: "message", T: ProvisionTokenV2, oneof: "Token" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateTokenV2Request {
    return new CreateTokenV2Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateTokenV2Request {
    return new CreateTokenV2Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateTokenV2Request {
    return new CreateTokenV2Request().fromJsonString(jsonString, options);
  }

  static equals(a: CreateTokenV2Request | PlainMessage<CreateTokenV2Request> | undefined, b: CreateTokenV2Request | PlainMessage<CreateTokenV2Request> | undefined): boolean {
    return proto3.util.equals(CreateTokenV2Request, a, b);
  }
}

/**
 * UpsertTokenV2Request is used with UpsertTokenV2 to upsert tokens in the
 * backend.
 *
 * @generated from message proto.UpsertTokenV2Request
 */
export class UpsertTokenV2Request extends Message<UpsertTokenV2Request> {
  /**
   * @generated from oneof proto.UpsertTokenV2Request.Token
   */
  Token: {
    /**
     * @generated from field: types.ProvisionTokenV2 V2 = 1;
     */
    value: ProvisionTokenV2;
    case: "V2";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UpsertTokenV2Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpsertTokenV2Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "V2", kind: "message", T: ProvisionTokenV2, oneof: "Token" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertTokenV2Request {
    return new UpsertTokenV2Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertTokenV2Request {
    return new UpsertTokenV2Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertTokenV2Request {
    return new UpsertTokenV2Request().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertTokenV2Request | PlainMessage<UpsertTokenV2Request> | undefined, b: UpsertTokenV2Request | PlainMessage<UpsertTokenV2Request> | undefined): boolean {
    return proto3.util.equals(UpsertTokenV2Request, a, b);
  }
}

/**
 * Request for GetHeadlessAuthentication.
 *
 * @generated from message proto.GetHeadlessAuthenticationRequest
 */
export class GetHeadlessAuthenticationRequest extends Message<GetHeadlessAuthenticationRequest> {
  /**
   * ID is the headless authentication id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetHeadlessAuthenticationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.GetHeadlessAuthenticationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetHeadlessAuthenticationRequest {
    return new GetHeadlessAuthenticationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetHeadlessAuthenticationRequest {
    return new GetHeadlessAuthenticationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetHeadlessAuthenticationRequest {
    return new GetHeadlessAuthenticationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetHeadlessAuthenticationRequest | PlainMessage<GetHeadlessAuthenticationRequest> | undefined, b: GetHeadlessAuthenticationRequest | PlainMessage<GetHeadlessAuthenticationRequest> | undefined): boolean {
    return proto3.util.equals(GetHeadlessAuthenticationRequest, a, b);
  }
}

/**
 * Request for UpdateHeadlessAuthenticationState.
 *
 * @generated from message proto.UpdateHeadlessAuthenticationStateRequest
 */
export class UpdateHeadlessAuthenticationStateRequest extends Message<UpdateHeadlessAuthenticationStateRequest> {
  /**
   * ID is the headless authentication id.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * State is the state that the request will be updated to.
   * MFA verification is required if State=APPROVED.
   *
   * @generated from field: types.HeadlessAuthenticationState state = 2;
   */
  state = HeadlessAuthenticationState.UNSPECIFIED;

  /**
   * MFAResponse is an mfa challenge response used to verify the user.
   * MFA Auth Challenges can be created for a user with the
   * authservice.GenerateAuthenticateChallenge rpc.
   *
   * @generated from field: proto.MFAAuthenticateResponse mfa_response = 3;
   */
  mfaResponse?: MFAAuthenticateResponse;

  constructor(data?: PartialMessage<UpdateHeadlessAuthenticationStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.UpdateHeadlessAuthenticationStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(HeadlessAuthenticationState) },
    { no: 3, name: "mfa_response", kind: "message", T: MFAAuthenticateResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateHeadlessAuthenticationStateRequest {
    return new UpdateHeadlessAuthenticationStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateHeadlessAuthenticationStateRequest {
    return new UpdateHeadlessAuthenticationStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateHeadlessAuthenticationStateRequest {
    return new UpdateHeadlessAuthenticationStateRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateHeadlessAuthenticationStateRequest | PlainMessage<UpdateHeadlessAuthenticationStateRequest> | undefined, b: UpdateHeadlessAuthenticationStateRequest | PlainMessage<UpdateHeadlessAuthenticationStateRequest> | undefined): boolean {
    return proto3.util.equals(UpdateHeadlessAuthenticationStateRequest, a, b);
  }
}

/**
 * ExportUpgradeWindowsRequest encodes parameters for loading the
 * upgrader-facing representations of upcoming agent maintenance windows.
 *
 * @generated from message proto.ExportUpgradeWindowsRequest
 */
export class ExportUpgradeWindowsRequest extends Message<ExportUpgradeWindowsRequest> {
  /**
   * TeleportVersion is the version of the teleport client making the request.
   *
   * @generated from field: string TeleportVersion = 1;
   */
  TeleportVersion = "";

  /**
   * UpgraderKind represents the kind of upgrader the schedule is intended for.
   *
   * @generated from field: string UpgraderKind = 2;
   */
  UpgraderKind = "";

  constructor(data?: PartialMessage<ExportUpgradeWindowsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ExportUpgradeWindowsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "TeleportVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "UpgraderKind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportUpgradeWindowsRequest {
    return new ExportUpgradeWindowsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportUpgradeWindowsRequest {
    return new ExportUpgradeWindowsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportUpgradeWindowsRequest {
    return new ExportUpgradeWindowsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExportUpgradeWindowsRequest | PlainMessage<ExportUpgradeWindowsRequest> | undefined, b: ExportUpgradeWindowsRequest | PlainMessage<ExportUpgradeWindowsRequest> | undefined): boolean {
    return proto3.util.equals(ExportUpgradeWindowsRequest, a, b);
  }
}

/**
 * ExportUpgradeWindowsResponse encodes an upgrader-facing representation
 * of upcoming agent maintenance windows. Teleport agents periodically export these
 * schedules to external upgraders as part of the externally-managed upgrade system.
 *
 * @generated from message proto.ExportUpgradeWindowsResponse
 */
export class ExportUpgradeWindowsResponse extends Message<ExportUpgradeWindowsResponse> {
  /**
   * CanonicalSchedule is the teleport-facing schedule repr.
   *
   * @generated from field: types.AgentUpgradeSchedule CanonicalSchedule = 1;
   */
  CanonicalSchedule?: AgentUpgradeSchedule;

  /**
   * KubeControllerSchedule encodes upcoming upgrade upgrade windows in a format known
   * to the kube upgrade controller. Teleport agents should treat this value as an
   * opaque blob.
   *
   * @generated from field: string KubeControllerSchedule = 2;
   */
  KubeControllerSchedule = "";

  /**
   * SystemdUnitSchedule encodes the upcoming upgrade windows in a format known to
   * the teleport-upgrade systemd unit. Teleport agents should treat this value as an
   * opaque blob.
   *
   * @generated from field: string SystemdUnitSchedule = 3;
   */
  SystemdUnitSchedule = "";

  constructor(data?: PartialMessage<ExportUpgradeWindowsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ExportUpgradeWindowsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "CanonicalSchedule", kind: "message", T: AgentUpgradeSchedule },
    { no: 2, name: "KubeControllerSchedule", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "SystemdUnitSchedule", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportUpgradeWindowsResponse {
    return new ExportUpgradeWindowsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportUpgradeWindowsResponse {
    return new ExportUpgradeWindowsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportUpgradeWindowsResponse {
    return new ExportUpgradeWindowsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExportUpgradeWindowsResponse | PlainMessage<ExportUpgradeWindowsResponse> | undefined, b: ExportUpgradeWindowsResponse | PlainMessage<ExportUpgradeWindowsResponse> | undefined): boolean {
    return proto3.util.equals(ExportUpgradeWindowsResponse, a, b);
  }
}

/**
 * ListAccessRequestsRequest encodes the parameters for a paginated access request lookup.
 *
 * @generated from message proto.ListAccessRequestsRequest
 */
export class ListAccessRequestsRequest extends Message<ListAccessRequestsRequest> {
  /**
   * Filter matches access requests.
   *
   * @generated from field: types.AccessRequestFilter Filter = 1;
   */
  Filter?: AccessRequestFilter;

  /**
   * Sort determines the sort order of returned access requests.
   *
   * @generated from field: proto.AccessRequestSort Sort = 2;
   */
  Sort = AccessRequestSort.DEFAULT;

  /**
   * Descending requests descending sort order if true (teleport APIs generally always
   * defaults to ascending sort order since that is the native sort order used in the
   * teleport backend).
   *
   * @generated from field: bool Descending = 3;
   */
  Descending = false;

  /**
   * Limit is the maximum amount of requests per page.
   *
   * @generated from field: int32 Limit = 4;
   */
  Limit = 0;

  /**
   * StartKey is used to resume a query in order to enable pagination.
   * If the previous response had NextKey set then this should be
   * set to its value. Otherwise leave empty.
   *
   * @generated from field: string StartKey = 5;
   */
  StartKey = "";

  constructor(data?: PartialMessage<ListAccessRequestsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListAccessRequestsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Filter", kind: "message", T: AccessRequestFilter },
    { no: 2, name: "Sort", kind: "enum", T: proto3.getEnumType(AccessRequestSort) },
    { no: 3, name: "Descending", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "Limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "StartKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccessRequestsRequest {
    return new ListAccessRequestsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccessRequestsRequest {
    return new ListAccessRequestsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccessRequestsRequest {
    return new ListAccessRequestsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccessRequestsRequest | PlainMessage<ListAccessRequestsRequest> | undefined, b: ListAccessRequestsRequest | PlainMessage<ListAccessRequestsRequest> | undefined): boolean {
    return proto3.util.equals(ListAccessRequestsRequest, a, b);
  }
}

/**
 * ListAccessRequestsResponse is a page of access requests.
 *
 * @generated from message proto.ListAccessRequestsResponse
 */
export class ListAccessRequestsResponse extends Message<ListAccessRequestsResponse> {
  /**
   * AccessRequests is a page of access requests.
   *
   * @generated from field: repeated types.AccessRequestV3 AccessRequests = 1;
   */
  AccessRequests: AccessRequestV3[] = [];

  /**
   * NextKey will serve as the StartKey for the next page of requests.
   *
   * @generated from field: string NextKey = 2;
   */
  NextKey = "";

  constructor(data?: PartialMessage<ListAccessRequestsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.ListAccessRequestsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "AccessRequests", kind: "message", T: AccessRequestV3, repeated: true },
    { no: 2, name: "NextKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAccessRequestsResponse {
    return new ListAccessRequestsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAccessRequestsResponse {
    return new ListAccessRequestsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAccessRequestsResponse {
    return new ListAccessRequestsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAccessRequestsResponse | PlainMessage<ListAccessRequestsResponse> | undefined, b: ListAccessRequestsResponse | PlainMessage<ListAccessRequestsResponse> | undefined): boolean {
    return proto3.util.equals(ListAccessRequestsResponse, a, b);
  }
}

/**
 * AccessRequestAllowedPromotionRequest is the request to AccessRequestAllowedPromotion RPC call.
 *
 * @generated from message proto.AccessRequestAllowedPromotionRequest
 */
export class AccessRequestAllowedPromotionRequest extends Message<AccessRequestAllowedPromotionRequest> {
  /**
   * AccessRequest is the access request to get promotions for.
   *
   * @generated from field: string accessRequestID = 1;
   */
  accessRequestID = "";

  constructor(data?: PartialMessage<AccessRequestAllowedPromotionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AccessRequestAllowedPromotionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accessRequestID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestAllowedPromotionRequest {
    return new AccessRequestAllowedPromotionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotionRequest {
    return new AccessRequestAllowedPromotionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotionRequest {
    return new AccessRequestAllowedPromotionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestAllowedPromotionRequest | PlainMessage<AccessRequestAllowedPromotionRequest> | undefined, b: AccessRequestAllowedPromotionRequest | PlainMessage<AccessRequestAllowedPromotionRequest> | undefined): boolean {
    return proto3.util.equals(AccessRequestAllowedPromotionRequest, a, b);
  }
}

/**
 * AccessRequestAllowedPromotionResponse is the response to AccessRequestAllowedPromotion RPC call.
 *
 * @generated from message proto.AccessRequestAllowedPromotionResponse
 */
export class AccessRequestAllowedPromotionResponse extends Message<AccessRequestAllowedPromotionResponse> {
  /**
   * allowedPromotions is the list of allowed promotions for the access request.
   *
   * @generated from field: types.AccessRequestAllowedPromotions allowedPromotions = 1;
   */
  allowedPromotions?: AccessRequestAllowedPromotions;

  constructor(data?: PartialMessage<AccessRequestAllowedPromotionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "proto.AccessRequestAllowedPromotionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowedPromotions", kind: "message", T: AccessRequestAllowedPromotions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestAllowedPromotionResponse {
    return new AccessRequestAllowedPromotionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotionResponse {
    return new AccessRequestAllowedPromotionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestAllowedPromotionResponse {
    return new AccessRequestAllowedPromotionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestAllowedPromotionResponse | PlainMessage<AccessRequestAllowedPromotionResponse> | undefined, b: AccessRequestAllowedPromotionResponse | PlainMessage<AccessRequestAllowedPromotionResponse> | undefined): boolean {
    return proto3.util.equals(AccessRequestAllowedPromotionResponse, a, b);
  }
}

