// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: prehog/v1alpha/tbot.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// TbotStartEvent is triggered whenever tbot starts, regardless of whether tbot
/// was able to successfully connect to or authenticate with a Teleport cluster.
struct Prehog_V1alpha_TbotStartEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var runMode: Prehog_V1alpha_TbotStartEvent.RunMode = .unspecified

  var version: String = String()

  var joinType: String = String()

  var helper: String = String()

  var helperVersion: String = String()

  var destinationsOther: Int32 = 0

  var destinationsDatabase: Int32 = 0

  var destinationsKubernetes: Int32 = 0

  var destinationsApplication: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// RunMode specifies whether or not tbot has been configured to run once
  /// and output certificates, or continually renew certificates in the
  /// background.
  enum RunMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0
    case oneShot // = 1
    case daemon // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .oneShot
      case 2: self = .daemon
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .oneShot: return 1
      case .daemon: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Prehog_V1alpha_TbotStartEvent.RunMode] = [
      .unspecified,
      .oneShot,
      .daemon,
    ]

  }

  init() {}
}

struct Prehog_V1alpha_SubmitTbotEventRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uuid identifying that tbot session. This is future-proofing for if we
  /// decide to add multiple events in future, and need to tie them together.
  var distinctID: String = String()

  /// optional, will default to the ingest time if unset
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var event: Prehog_V1alpha_SubmitTbotEventRequest.OneOf_Event? = nil

  var start: Prehog_V1alpha_TbotStartEvent {
    get {
      if case .start(let v)? = event {return v}
      return Prehog_V1alpha_TbotStartEvent()
    }
    set {event = .start(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case start(Prehog_V1alpha_TbotStartEvent)

  }

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Prehog_V1alpha_SubmitTbotEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "prehog.v1alpha"

extension Prehog_V1alpha_TbotStartEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TbotStartEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "run_mode"),
    2: .same(proto: "version"),
    3: .standard(proto: "join_type"),
    4: .same(proto: "helper"),
    5: .standard(proto: "helper_version"),
    6: .standard(proto: "destinations_other"),
    7: .standard(proto: "destinations_database"),
    8: .standard(proto: "destinations_kubernetes"),
    9: .standard(proto: "destinations_application"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.runMode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.joinType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.helper) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.helperVersion) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.destinationsOther) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.destinationsDatabase) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.destinationsKubernetes) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.destinationsApplication) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.runMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.runMode, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.joinType.isEmpty {
      try visitor.visitSingularStringField(value: self.joinType, fieldNumber: 3)
    }
    if !self.helper.isEmpty {
      try visitor.visitSingularStringField(value: self.helper, fieldNumber: 4)
    }
    if !self.helperVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.helperVersion, fieldNumber: 5)
    }
    if self.destinationsOther != 0 {
      try visitor.visitSingularInt32Field(value: self.destinationsOther, fieldNumber: 6)
    }
    if self.destinationsDatabase != 0 {
      try visitor.visitSingularInt32Field(value: self.destinationsDatabase, fieldNumber: 7)
    }
    if self.destinationsKubernetes != 0 {
      try visitor.visitSingularInt32Field(value: self.destinationsKubernetes, fieldNumber: 8)
    }
    if self.destinationsApplication != 0 {
      try visitor.visitSingularInt32Field(value: self.destinationsApplication, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Prehog_V1alpha_TbotStartEvent, rhs: Prehog_V1alpha_TbotStartEvent) -> Bool {
    if lhs.runMode != rhs.runMode {return false}
    if lhs.version != rhs.version {return false}
    if lhs.joinType != rhs.joinType {return false}
    if lhs.helper != rhs.helper {return false}
    if lhs.helperVersion != rhs.helperVersion {return false}
    if lhs.destinationsOther != rhs.destinationsOther {return false}
    if lhs.destinationsDatabase != rhs.destinationsDatabase {return false}
    if lhs.destinationsKubernetes != rhs.destinationsKubernetes {return false}
    if lhs.destinationsApplication != rhs.destinationsApplication {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_TbotStartEvent.RunMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUN_MODE_UNSPECIFIED"),
    1: .same(proto: "RUN_MODE_ONE_SHOT"),
    2: .same(proto: "RUN_MODE_DAEMON"),
  ]
}

extension Prehog_V1alpha_SubmitTbotEventRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitTbotEventRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distinct_id"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "start"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.distinctID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try {
        var v: Prehog_V1alpha_TbotStartEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .start(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.distinctID.isEmpty {
      try visitor.visitSingularStringField(value: self.distinctID, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if case .start(let v)? = self.event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Prehog_V1alpha_SubmitTbotEventRequest, rhs: Prehog_V1alpha_SubmitTbotEventRequest) -> Bool {
    if lhs.distinctID != rhs.distinctID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Prehog_V1alpha_SubmitTbotEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubmitTbotEventResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Prehog_V1alpha_SubmitTbotEventResponse, rhs: Prehog_V1alpha_SubmitTbotEventResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
