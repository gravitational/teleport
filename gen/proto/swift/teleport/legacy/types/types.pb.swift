// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/legacy/types/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2021 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// IAMPolicyStatus represents states that describe if an AWS database
/// has its IAM policy properly configured or not.
/// This enum is set in a Sync.Map during an IAM task that checks for the
/// validity of IAM policy, and the database gets updated with the value
/// from this map during a heartbeat.
enum Types_IAMPolicyStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// IAM_POLICY_STATUS_UNSPECIFIED represents a zero value where
  /// nothing has been attempted yet.
  case unspecified // = 0

  /// IAM_POLICY_STATUS_PENDING represents a state where iam policy status
  /// is pending to be checked. This enum value is set at the start of
  /// registering a database -> IAM setup (before the db heartbeat starts).
  ///
  /// This state was required for two reasons:
  ///   1) To be able to tell apart from an older service that do not update
  ///      the IAMPolicyStatus (in which case the enum value will remain the
  ///      zero value).
  ///   2) When starting a database, the heartbeat and its IAM task starts,
  ///      and the heartbeat may run first before the IAM task finishes.
  case pending // = 1

  /// IAM_POLICY_STATUS_FAILED represents a state where an error occured
  /// while checking for IAM policy status eg: no AWS credentials provider found
  /// or the policy was misconfigured.
  case failed // = 2

  /// IAM_POLICY_STATUS_SUCCESS represents a state where IAM policy was configured
  /// correctly.
  case success // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .failed
    case 3: self = .success
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .failed: return 2
    case .success: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_IAMPolicyStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_IAMPolicyStatus] = [
    .unspecified,
    .pending,
    .failed,
    .success,
  ]
}

#endif  // swift(>=4.2)

/// DatabaseTLSMode represents the level of TLS verification performed by
/// DB agent when connecting to a database.
enum Types_DatabaseTLSMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// VERIFY_FULL performs full certificate validation.
  case verifyFull // = 0

  /// VERIFY_CA works the same as VERIFY_FULL, but it skips the hostname check.
  case verifyCa // = 1

  /// INSECURE accepts any certificate provided by server. This is the least secure option.
  case insecure // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .verifyFull
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .verifyFull
    case 1: self = .verifyCa
    case 2: self = .insecure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .verifyFull: return 0
    case .verifyCa: return 1
    case .insecure: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_DatabaseTLSMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_DatabaseTLSMode] = [
    .verifyFull,
    .verifyCa,
    .insecure,
  ]
}

#endif  // swift(>=4.2)

/// PrivateKeyType is the storage type of a private key.
enum Types_PrivateKeyType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// RAW is a plaintext private key.
  case raw // = 0

  /// PKCS11 is a private key backed by a PKCS11 device such as HSM.
  case pkcs11 // = 1

  /// GCP_KMS is a private key backed by GCP KMS.
  case gcpKms // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .raw
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .raw
    case 1: self = .pkcs11
    case 2: self = .gcpKms
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .raw: return 0
    case .pkcs11: return 1
    case .gcpKms: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_PrivateKeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_PrivateKeyType] = [
    .raw,
    .pkcs11,
    .gcpKms,
  ]
}

#endif  // swift(>=4.2)

/// ProxyListenerMode represents the cluster proxy listener mode.
enum Types_ProxyListenerMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Separate is the proxy listener mode indicating that proxies are running
  /// in separate listener mode where Teleport Proxy services use different listeners.
  case separate // = 0

  /// Multiplex is the proxy listener mode indicating the proxy should use multiplex mode
  /// where all proxy services are multiplexed on a single proxy port.
  case multiplex // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .separate
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .separate
    case 1: self = .multiplex
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .separate: return 0
    case .multiplex: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_ProxyListenerMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_ProxyListenerMode] = [
    .separate,
    .multiplex,
  ]
}

#endif  // swift(>=4.2)

/// RoutingStrategy determines the strategy used to route to nodes.
enum Types_RoutingStrategy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// UnambiguousMatch only routes to distinct nodes.
  case unambiguousMatch // = 0

  /// MostRecent routes to the most recently heartbeated node if duplicates are present.
  case mostRecent // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unambiguousMatch
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unambiguousMatch
    case 1: self = .mostRecent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unambiguousMatch: return 0
    case .mostRecent: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_RoutingStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_RoutingStrategy] = [
    .unambiguousMatch,
    .mostRecent,
  ]
}

#endif  // swift(>=4.2)

/// UserTokenUsage contains additional information about the intended usage of a user token.
enum Types_UserTokenUsage: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Default value that implies token usage was not set.
  case unspecified // = 0

  /// USER_TOKEN_RECOVER_PASSWORD is a request to recover password.
  case userTokenRecoverPassword // = 1

  /// USER_TOKEN_RECOVER_MFA is a request to recover a MFA.
  case userTokenRecoverMfa // = 2

  /// USER_TOKEN_RENEWAL_BOT is a request to generate certificates
  /// for a bot user.
  case userTokenRenewalBot // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .userTokenRecoverPassword
    case 2: self = .userTokenRecoverMfa
    case 3: self = .userTokenRenewalBot
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .userTokenRecoverPassword: return 1
    case .userTokenRecoverMfa: return 2
    case .userTokenRenewalBot: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_UserTokenUsage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_UserTokenUsage] = [
    .unspecified,
    .userTokenRecoverPassword,
    .userTokenRecoverMfa,
    .userTokenRenewalBot,
  ]
}

#endif  // swift(>=4.2)

/// RequestState represents the state of a request for escalated privilege.
enum Types_RequestState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// NONE variant exists to allow RequestState to be explicitly omitted
  /// in certain circumstances (e.g. in an AccessRequestFilter).
  case none // = 0

  /// PENDING variant is the default for newly created requests.
  case pending // = 1

  /// APPROVED variant indicates that a request has been accepted by
  /// an administrating party.
  case approved // = 2

  /// DENIED variant indicates that a request has been rejected by
  /// an administrating party.
  case denied // = 3

  /// PROMOTED variant indicates that a request has been promoted to
  /// an access list.
  case promoted // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .pending
    case 2: self = .approved
    case 3: self = .denied
    case 4: self = .promoted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .pending: return 1
    case .approved: return 2
    case .denied: return 3
    case .promoted: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_RequestState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_RequestState] = [
    .none,
    .pending,
    .approved,
    .denied,
    .promoted,
  ]
}

#endif  // swift(>=4.2)

/// CreateHostUserMode determines whether host user creation should be
/// disabled or if host users should be cleaned up or kept after
/// sessions end.
enum Types_CreateHostUserMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case hostUserModeUnspecified // = 0

  /// HOST_USER_MODE_OFF disables host user creation.
  case hostUserModeOff // = 1

  /// HOST_USER_MODE_DROP enables host user creation and deletes users at session end.
  case hostUserModeDrop // = 2

  /// HOST_USER_MODE_KEEP enables host user creation and leaves users behind at session end.
  case hostUserModeKeep // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .hostUserModeUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hostUserModeUnspecified
    case 1: self = .hostUserModeOff
    case 2: self = .hostUserModeDrop
    case 3: self = .hostUserModeKeep
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .hostUserModeUnspecified: return 0
    case .hostUserModeOff: return 1
    case .hostUserModeDrop: return 2
    case .hostUserModeKeep: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_CreateHostUserMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_CreateHostUserMode] = [
    .hostUserModeUnspecified,
    .hostUserModeOff,
    .hostUserModeDrop,
    .hostUserModeKeep,
  ]
}

#endif  // swift(>=4.2)

/// CreateDatabaseUserMode determines whether database user creation should be
/// disabled or if users should be cleaned up or kept after sessions end.
enum Types_CreateDatabaseUserMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case dbUserModeUnspecified // = 0

  /// DB_USER_MODE_OFF disables user creation.
  case dbUserModeOff // = 1

  /// DB_USER_MODE_KEEP allows user creation and disable users at session end.
  case dbUserModeKeep // = 2

  /// DB_USER_MODE_BEST_EFFORT_DROP allows user creation and tries to drop user
  /// at session end. If the drop fails, fallback to disabling them.
  case dbUserModeBestEffortDrop // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .dbUserModeUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dbUserModeUnspecified
    case 1: self = .dbUserModeOff
    case 2: self = .dbUserModeKeep
    case 3: self = .dbUserModeBestEffortDrop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .dbUserModeUnspecified: return 0
    case .dbUserModeOff: return 1
    case .dbUserModeKeep: return 2
    case .dbUserModeBestEffortDrop: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_CreateDatabaseUserMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_CreateDatabaseUserMode] = [
    .dbUserModeUnspecified,
    .dbUserModeOff,
    .dbUserModeKeep,
    .dbUserModeBestEffortDrop,
  ]
}

#endif  // swift(>=4.2)

/// CertExtensionMode specifies the type of extension to use in the cert.
enum Types_CertExtensionMode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// EXTENSION represents a cert extension that may or may not be
  /// honored by the server.
  case `extension` // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .extension
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .extension
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .extension: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_CertExtensionMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_CertExtensionMode] = [
    .extension,
  ]
}

#endif  // swift(>=4.2)

/// CertExtensionType represents the certificate type the extension is for.
/// Currently only ssh is supported.
enum Types_CertExtensionType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// SSH is used when extending an ssh certificate
  case ssh // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .ssh
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ssh
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ssh: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_CertExtensionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_CertExtensionType] = [
    .ssh,
  ]
}

#endif  // swift(>=4.2)

/// SessionState represents the state of a session.
enum Types_SessionState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Pending variant represents a session that is waiting on participants to fulfill the criteria
  /// to start the session.
  case pending // = 0

  /// Running variant represents a session that has had it's criteria for starting
  /// fulfilled at least once and has transitioned to a RUNNING state.
  case running // = 1

  /// Terminated variant represents a session that is no longer running and due for removal.
  case terminated // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .running
    case 2: self = .terminated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .running: return 1
    case .terminated: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_SessionState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_SessionState] = [
    .pending,
    .running,
    .terminated,
  ]
}

#endif  // swift(>=4.2)

/// AlertSeverity represents how problematic/urgent an alert is, and is used to assist
/// in sorting alerts for display.
enum Types_AlertSeverity: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case low // = 0
  case medium // = 5
  case high // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .low
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .low
    case 5: self = .medium
    case 10: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .low: return 0
    case .medium: return 5
    case .high: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_AlertSeverity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_AlertSeverity] = [
    .low,
    .medium,
    .high,
  ]
}

#endif  // swift(>=4.2)

/// RequireMFAType is a type of MFA requirement enforced outside of login,
/// such as per-session MFA or per-request PIV touch.
enum Types_RequireMFAType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// OFF means additional MFA enforcement is not enabled.
  case off // = 0

  /// SESSION means MFA is required to begin server sessions.
  case session // = 1

  /// SESSION_AND_HARDWARE_KEY means MFA is required to begin server sessions,
  /// and login sessions must use a private key backed by a hardware key.
  case sessionAndHardwareKey // = 2

  /// HARDWARE_KEY_TOUCH means login sessions must use a hardware private key that
  /// requires touch to be used.
  case hardwareKeyTouch // = 3

  /// HARDWARE_KEY_PIN means login sessions must use a hardware private key that
  /// requires pin to be used.
  case hardwareKeyPin // = 4

  /// HARDWARE_KEY_TOUCH_AND_PIN means login sessions must use a hardware private key that
  /// requires touch and pin to be used.
  case hardwareKeyTouchAndPin // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .off
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .off
    case 1: self = .session
    case 2: self = .sessionAndHardwareKey
    case 3: self = .hardwareKeyTouch
    case 4: self = .hardwareKeyPin
    case 5: self = .hardwareKeyTouchAndPin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .off: return 0
    case .session: return 1
    case .sessionAndHardwareKey: return 2
    case .hardwareKeyTouch: return 3
    case .hardwareKeyPin: return 4
    case .hardwareKeyTouchAndPin: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_RequireMFAType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_RequireMFAType] = [
    .off,
    .session,
    .sessionAndHardwareKey,
    .hardwareKeyTouch,
    .hardwareKeyPin,
    .hardwareKeyTouchAndPin,
  ]
}

#endif  // swift(>=4.2)

enum Types_PluginStatusCode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// UNKNOWN is the default value when the plugin has not reported its status yet.
  case unknown // = 0

  /// RUNNING means the plugin reports running successfully.
  case running // = 1

  /// OTHER_ERROR indicates that an otherwise-unspecified error has been encountered.
  case otherError // = 2

  /// UNAUTHORIZED indicates that plugin is not able to authenticate to the 3rd party API.
  /// This could be a result of e.g. the user revoking the authorization on the API provider's side.
  case unauthorized // = 3

  /// SLACK_NOT_IN_CHANNEL is a Slack-specific status code that indicates
  /// that the bot has not been invited to a channel that it is configured to post in.
  case slackNotInChannel // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .running
    case 2: self = .otherError
    case 3: self = .unauthorized
    case 10: self = .slackNotInChannel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .running: return 1
    case .otherError: return 2
    case .unauthorized: return 3
    case .slackNotInChannel: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_PluginStatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_PluginStatusCode] = [
    .unknown,
    .running,
    .otherError,
    .unauthorized,
    .slackNotInChannel,
  ]
}

#endif  // swift(>=4.2)

/// HeadlessAuthenticationState is a headless authentication state.
enum Types_HeadlessAuthenticationState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// authentication pending.
  case pending // = 1

  /// authentication denied.
  case denied // = 2

  /// authentication approved.
  case approved // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pending
    case 2: self = .denied
    case 3: self = .approved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pending: return 1
    case .denied: return 2
    case .approved: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Types_HeadlessAuthenticationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_HeadlessAuthenticationState] = [
    .unspecified,
    .pending,
    .denied,
    .approved,
  ]
}

#endif  // swift(>=4.2)

struct Types_KeepAlive {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the resource to keep alive.
  var name: String = String()

  /// Namespace is the namespace of the resource.
  var namespace: String = String()

  /// LeaseID is ID of the lease.
  var leaseID: Int64 = 0

  /// Expires is set to update expiry time of the resource.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// Type is the type (or kind) of the resource that's being kept alive.
  var type: Types_KeepAlive.KeepAliveType = .unknown

  /// HostID is an optional UUID of the host the resource belongs to.
  var hostID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of a KeepAlive. When adding a new type, please double-check
  /// lib/usagereporter/teleport to see if we need any change in the resource
  /// heartbeat event.
  enum KeepAliveType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0

    /// "node", KindNode. For the sake of correct usage reporting, it shouldn't
    /// be used for OpenSSH nodes.
    case node // = 1

    /// "app_server", KindAppServer
    case app // = 2

    /// "db_server", KindDatabaseServer
    case database // = 3

    /// "windows_desktop_service", KindWindowsDesktopService
    case windowsDesktop // = 4

    /// "kube_server", KindKubeServer
    case kubernetes // = 5

    /// "db_service", KindDatabaseService
    case databaseService // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .node
      case 2: self = .app
      case 3: self = .database
      case 4: self = .windowsDesktop
      case 5: self = .kubernetes
      case 6: self = .databaseService
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .node: return 1
      case .app: return 2
      case .database: return 3
      case .windowsDesktop: return 4
      case .kubernetes: return 5
      case .databaseService: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Types_KeepAlive.KeepAliveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_KeepAlive.KeepAliveType] = [
    .unknown,
    .node,
    .app,
    .database,
    .windowsDesktop,
    .kubernetes,
    .databaseService,
  ]
}

#endif  // swift(>=4.2)

/// Metadata is resource metadata
struct Types_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is an object name
  var name: String = String()

  /// Namespace is object namespace. The field should be called "namespace"
  /// when it returns in Teleport 2.4.
  var namespace: String = String()

  /// Description is object description
  var description_p: String = String()

  /// Labels is a set of labels
  var labels: Dictionary<String,String> = [:]

  /// Expires is a global expiry time header can be set on any resource in the
  /// system.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// ID is a record ID.
  /// Deprecated: Use revision instead.
  var id: Int64 = 0

  /// Revision is an opaque identifier which tracks the versions of a resource
  /// over time. Clients should ignore and not alter its value but must return
  /// the revision in any updates of a resource.
  var revision: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Rotation is a status of the rotation of the certificate authority
struct Types_Rotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// State could be one of "init" or "in_progress".
  var state: String = String()

  /// Phase is the current rotation phase.
  var phase: String = String()

  /// Mode sets manual or automatic rotation mode.
  var mode: String = String()

  /// CurrentID is the ID of the rotation operation
  /// to differentiate between rotation attempts.
  var currentID: String = String()

  /// Started is set to the time when rotation has been started
  /// in case if the state of the rotation is "in_progress".
  var started: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _started ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_started = newValue}
  }
  /// Returns true if `started` has been explicitly set.
  var hasStarted: Bool {return self._started != nil}
  /// Clears the value of `started`. Subsequent reads from it will return its default value.
  mutating func clearStarted() {self._started = nil}

  /// GracePeriod is a period during which old and new CA
  /// are valid for checking purposes, but only new CA is issuing certificates.
  var gracePeriod: Int64 = 0

  /// LastRotated specifies the last time of the completed rotation.
  var lastRotated: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastRotated ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastRotated = newValue}
  }
  /// Returns true if `lastRotated` has been explicitly set.
  var hasLastRotated: Bool {return self._lastRotated != nil}
  /// Clears the value of `lastRotated`. Subsequent reads from it will return its default value.
  mutating func clearLastRotated() {self._lastRotated = nil}

  /// Schedule is a rotation schedule - used in
  /// automatic mode to switch between phases.
  var schedule: Types_RotationSchedule {
    get {return _schedule ?? Types_RotationSchedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {self._schedule = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _started: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastRotated: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _schedule: Types_RotationSchedule? = nil
}

/// RotationSchedule is a rotation schedule setting time switches
/// for different phases.
struct Types_RotationSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UpdateClients specifies time to switch to the "Update clients" phase
  var updateClients: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateClients ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateClients = newValue}
  }
  /// Returns true if `updateClients` has been explicitly set.
  var hasUpdateClients: Bool {return self._updateClients != nil}
  /// Clears the value of `updateClients`. Subsequent reads from it will return its default value.
  mutating func clearUpdateClients() {self._updateClients = nil}

  /// UpdateServers specifies time to switch to the "Update servers" phase.
  var updateServers: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateServers ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateServers = newValue}
  }
  /// Returns true if `updateServers` has been explicitly set.
  var hasUpdateServers: Bool {return self._updateServers != nil}
  /// Clears the value of `updateServers`. Subsequent reads from it will return its default value.
  mutating func clearUpdateServers() {self._updateServers = nil}

  /// Standby specifies time to switch to the "Standby" phase.
  var standby: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _standby ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_standby = newValue}
  }
  /// Returns true if `standby` has been explicitly set.
  var hasStandby: Bool {return self._standby != nil}
  /// Clears the value of `standby`. Subsequent reads from it will return its default value.
  mutating func clearStandby() {self._standby = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updateClients: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateServers: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _standby: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// ResourceHeader is a shared resource header
/// used in cases when only type and name is known
struct Types_ResourceHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
}

/// DatabaseServerV3 represents a database access server.
struct Types_DatabaseServerV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the database server resource kind.
  var kind: String = String()

  /// SubKind is an optional resource subkind.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the database server metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is the database server spec.
  var spec: Types_DatabaseServerSpecV3 {
    get {return _spec ?? Types_DatabaseServerSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_DatabaseServerSpecV3? = nil
}

/// DatabaseServerSpecV3 is the database server spec.
struct Types_DatabaseServerSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version is the Teleport version that the server is running.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Hostname is the database server hostname.
  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  /// HostID is the ID of the host the database server is running on.
  var hostID: String {
    get {return _storage._hostID}
    set {_uniqueStorage()._hostID = newValue}
  }

  /// Rotation contains the server CA rotation information.
  var rotation: Types_Rotation {
    get {return _storage._rotation ?? Types_Rotation()}
    set {_uniqueStorage()._rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  var hasRotation: Bool {return _storage._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  mutating func clearRotation() {_uniqueStorage()._rotation = nil}

  /// Database is the database proxied by this database server.
  var database: Types_DatabaseV3 {
    get {return _storage._database ?? Types_DatabaseV3()}
    set {_uniqueStorage()._database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return _storage._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {_uniqueStorage()._database = nil}

  /// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
  var proxyIds: [String] {
    get {return _storage._proxyIds}
    set {_uniqueStorage()._proxyIds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseV3List represents a list of databases.
struct Types_DatabaseV3List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Databases is a list of database resources.
  var databases: [Types_DatabaseV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseV3 represents a single proxied database.
struct Types_DatabaseV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the database resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource subkind.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is the resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata is the database metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is the database spec.
  var spec: Types_DatabaseSpecV3 {
    get {return _storage._spec ?? Types_DatabaseSpecV3()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// Status is the database runtime information.
  var status: Types_DatabaseStatusV3 {
    get {return _storage._status ?? Types_DatabaseStatusV3()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseSpecV3 is the database spec.
struct Types_DatabaseSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol is the database protocol: postgres, mysql, mongodb, etc.
  var `protocol`: String {
    get {return _storage._protocol}
    set {_uniqueStorage()._protocol = newValue}
  }

  /// URI is the database connection endpoint.
  var uri: String {
    get {return _storage._uri}
    set {_uniqueStorage()._uri = newValue}
  }

  /// CACert is the PEM-encoded database CA certificate.
  ///
  /// DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
  var cacert: String {
    get {return _storage._cacert}
    set {_uniqueStorage()._cacert = newValue}
  }

  /// DynamicLabels is the database dynamic labels.
  var dynamicLabels: Dictionary<String,Types_CommandLabelV2> {
    get {return _storage._dynamicLabels}
    set {_uniqueStorage()._dynamicLabels = newValue}
  }

  /// AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
  var aws: Types_AWS {
    get {return _storage._aws ?? Types_AWS()}
    set {_uniqueStorage()._aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return _storage._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {_uniqueStorage()._aws = nil}

  /// GCP contains parameters specific to GCP Cloud SQL databases.
  var gcp: Types_GCPCloudSQL {
    get {return _storage._gcp ?? Types_GCPCloudSQL()}
    set {_uniqueStorage()._gcp = newValue}
  }
  /// Returns true if `gcp` has been explicitly set.
  var hasGcp: Bool {return _storage._gcp != nil}
  /// Clears the value of `gcp`. Subsequent reads from it will return its default value.
  mutating func clearGcp() {_uniqueStorage()._gcp = nil}

  /// Azure contains Azure specific database metadata.
  var azure: Types_Azure {
    get {return _storage._azure ?? Types_Azure()}
    set {_uniqueStorage()._azure = newValue}
  }
  /// Returns true if `azure` has been explicitly set.
  var hasAzure: Bool {return _storage._azure != nil}
  /// Clears the value of `azure`. Subsequent reads from it will return its default value.
  mutating func clearAzure() {_uniqueStorage()._azure = nil}

  /// TLS is the TLS configuration used when establishing connection to target database.
  /// Allows to provide custom CA cert or override server name.
  var tls: Types_DatabaseTLS {
    get {return _storage._tls ?? Types_DatabaseTLS()}
    set {_uniqueStorage()._tls = newValue}
  }
  /// Returns true if `tls` has been explicitly set.
  var hasTls: Bool {return _storage._tls != nil}
  /// Clears the value of `tls`. Subsequent reads from it will return its default value.
  mutating func clearTls() {_uniqueStorage()._tls = nil}

  /// AD is the Active Directory configuration for the database.
  var ad: Types_AD {
    get {return _storage._ad ?? Types_AD()}
    set {_uniqueStorage()._ad = newValue}
  }
  /// Returns true if `ad` has been explicitly set.
  var hasAd: Bool {return _storage._ad != nil}
  /// Clears the value of `ad`. Subsequent reads from it will return its default value.
  mutating func clearAd() {_uniqueStorage()._ad = nil}

  /// MySQL is an additional section with MySQL database options.
  var mySql: Types_MySQLOptions {
    get {return _storage._mySql ?? Types_MySQLOptions()}
    set {_uniqueStorage()._mySql = newValue}
  }
  /// Returns true if `mySql` has been explicitly set.
  var hasMySql: Bool {return _storage._mySql != nil}
  /// Clears the value of `mySql`. Subsequent reads from it will return its default value.
  mutating func clearMySql() {_uniqueStorage()._mySql = nil}

  /// AdminUser is the database admin user for automatic user provisioning.
  var adminUser: Types_DatabaseAdminUser {
    get {return _storage._adminUser ?? Types_DatabaseAdminUser()}
    set {_uniqueStorage()._adminUser = newValue}
  }
  /// Returns true if `adminUser` has been explicitly set.
  var hasAdminUser: Bool {return _storage._adminUser != nil}
  /// Clears the value of `adminUser`. Subsequent reads from it will return its default value.
  mutating func clearAdminUser() {_uniqueStorage()._adminUser = nil}

  /// MongoAtlas contains Atlas metadata about the database.
  var mongoAtlas: Types_MongoAtlas {
    get {return _storage._mongoAtlas ?? Types_MongoAtlas()}
    set {_uniqueStorage()._mongoAtlas = newValue}
  }
  /// Returns true if `mongoAtlas` has been explicitly set.
  var hasMongoAtlas: Bool {return _storage._mongoAtlas != nil}
  /// Clears the value of `mongoAtlas`. Subsequent reads from it will return its default value.
  mutating func clearMongoAtlas() {_uniqueStorage()._mongoAtlas = nil}

  /// Oracle is an additional Oracle configuration options.
  var oracle: Types_OracleOptions {
    get {return _storage._oracle ?? Types_OracleOptions()}
    set {_uniqueStorage()._oracle = newValue}
  }
  /// Returns true if `oracle` has been explicitly set.
  var hasOracle: Bool {return _storage._oracle != nil}
  /// Clears the value of `oracle`. Subsequent reads from it will return its default value.
  mutating func clearOracle() {_uniqueStorage()._oracle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DatabaseAdminUser contains information about privileged database user used
/// for automatic user provisioning.
struct Types_DatabaseAdminUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the username of the privileged database user.
  var name: String = String()

  /// DefaultDatabase is the database that the privileged database user logs
  /// into by default.
  ///
  /// Depending on the database type, this database may be used to store
  /// procedures or data for managing database users.
  var defaultDatabase: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OracleOptions contains information about privileged database user used
/// for database audit.
struct Types_OracleOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
  var auditUser: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseStatusV3 contains runtime information about the database.
struct Types_DatabaseStatusV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CACert is the auto-downloaded cloud database CA certificate.
  var cacert: String = String()

  /// AWS is the auto-discovered AWS cloud database metadata.
  var aws: Types_AWS {
    get {return _aws ?? Types_AWS()}
    set {_aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return self._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {self._aws = nil}

  /// MySQL is an additional section with MySQL runtime database information.
  var mySql: Types_MySQLOptions {
    get {return _mySql ?? Types_MySQLOptions()}
    set {_mySql = newValue}
  }
  /// Returns true if `mySql` has been explicitly set.
  var hasMySql: Bool {return self._mySql != nil}
  /// Clears the value of `mySql`. Subsequent reads from it will return its default value.
  mutating func clearMySql() {self._mySql = nil}

  /// ManagedUsers is a list of database users that are managed by Teleport.
  var managedUsers: [String] = []

  /// Azure is the auto-discovered Azure cloud database metadata.
  var azure: Types_Azure {
    get {return _azure ?? Types_Azure()}
    set {_azure = newValue}
  }
  /// Returns true if `azure` has been explicitly set.
  var hasAzure: Bool {return self._azure != nil}
  /// Clears the value of `azure`. Subsequent reads from it will return its default value.
  mutating func clearAzure() {self._azure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _aws: Types_AWS? = nil
  fileprivate var _mySql: Types_MySQLOptions? = nil
  fileprivate var _azure: Types_Azure? = nil
}

/// AWS contains AWS metadata about the database.
struct Types_AWS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Region is a AWS cloud region.
  var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  /// Redshift contains Redshift specific metadata.
  var redshift: Types_Redshift {
    get {return _storage._redshift ?? Types_Redshift()}
    set {_uniqueStorage()._redshift = newValue}
  }
  /// Returns true if `redshift` has been explicitly set.
  var hasRedshift: Bool {return _storage._redshift != nil}
  /// Clears the value of `redshift`. Subsequent reads from it will return its default value.
  mutating func clearRedshift() {_uniqueStorage()._redshift = nil}

  /// RDS contains RDS specific metadata.
  var rds: Types_RDS {
    get {return _storage._rds ?? Types_RDS()}
    set {_uniqueStorage()._rds = newValue}
  }
  /// Returns true if `rds` has been explicitly set.
  var hasRds: Bool {return _storage._rds != nil}
  /// Clears the value of `rds`. Subsequent reads from it will return its default value.
  mutating func clearRds() {_uniqueStorage()._rds = nil}

  /// AccountID is the AWS account ID this database belongs to.
  var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  /// ElastiCache contains AWS ElastiCache Redis specific metadata.
  var elastiCache: Types_ElastiCache {
    get {return _storage._elastiCache ?? Types_ElastiCache()}
    set {_uniqueStorage()._elastiCache = newValue}
  }
  /// Returns true if `elastiCache` has been explicitly set.
  var hasElastiCache: Bool {return _storage._elastiCache != nil}
  /// Clears the value of `elastiCache`. Subsequent reads from it will return its default value.
  mutating func clearElastiCache() {_uniqueStorage()._elastiCache = nil}

  /// SecretStore contains secret store configurations.
  var secretStore: Types_SecretStore {
    get {return _storage._secretStore ?? Types_SecretStore()}
    set {_uniqueStorage()._secretStore = newValue}
  }
  /// Returns true if `secretStore` has been explicitly set.
  var hasSecretStore: Bool {return _storage._secretStore != nil}
  /// Clears the value of `secretStore`. Subsequent reads from it will return its default value.
  mutating func clearSecretStore() {_uniqueStorage()._secretStore = nil}

  /// MemoryDB contains AWS MemoryDB specific metadata.
  var memoryDb: Types_MemoryDB {
    get {return _storage._memoryDb ?? Types_MemoryDB()}
    set {_uniqueStorage()._memoryDb = newValue}
  }
  /// Returns true if `memoryDb` has been explicitly set.
  var hasMemoryDb: Bool {return _storage._memoryDb != nil}
  /// Clears the value of `memoryDb`. Subsequent reads from it will return its default value.
  mutating func clearMemoryDb() {_uniqueStorage()._memoryDb = nil}

  /// RDSProxy contains AWS Proxy specific metadata.
  var rdsproxy: Types_RDSProxy {
    get {return _storage._rdsproxy ?? Types_RDSProxy()}
    set {_uniqueStorage()._rdsproxy = newValue}
  }
  /// Returns true if `rdsproxy` has been explicitly set.
  var hasRdsproxy: Bool {return _storage._rdsproxy != nil}
  /// Clears the value of `rdsproxy`. Subsequent reads from it will return its default value.
  mutating func clearRdsproxy() {_uniqueStorage()._rdsproxy = nil}

  /// RedshiftServerless contains AWS Redshift Serverless specific metadata.
  var redshiftServerless: Types_RedshiftServerless {
    get {return _storage._redshiftServerless ?? Types_RedshiftServerless()}
    set {_uniqueStorage()._redshiftServerless = newValue}
  }
  /// Returns true if `redshiftServerless` has been explicitly set.
  var hasRedshiftServerless: Bool {return _storage._redshiftServerless != nil}
  /// Clears the value of `redshiftServerless`. Subsequent reads from it will return its default value.
  mutating func clearRedshiftServerless() {_uniqueStorage()._redshiftServerless = nil}

  /// ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
  var externalID: String {
    get {return _storage._externalID}
    set {_uniqueStorage()._externalID = newValue}
  }

  /// AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
  /// Set this field and ExternalID to enable access across AWS accounts.
  var assumeRoleArn: String {
    get {return _storage._assumeRoleArn}
    set {_uniqueStorage()._assumeRoleArn = newValue}
  }

  /// OpenSearch contains AWS OpenSearch specific metadata.
  var openSearch: Types_OpenSearch {
    get {return _storage._openSearch ?? Types_OpenSearch()}
    set {_uniqueStorage()._openSearch = newValue}
  }
  /// Returns true if `openSearch` has been explicitly set.
  var hasOpenSearch: Bool {return _storage._openSearch != nil}
  /// Clears the value of `openSearch`. Subsequent reads from it will return its default value.
  mutating func clearOpenSearch() {_uniqueStorage()._openSearch = nil}

  /// IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access.
  /// If not, the user must update the AWS profile identity to allow access to the Database.
  /// Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
  var iampolicyStatus: Types_IAMPolicyStatus {
    get {return _storage._iampolicyStatus}
    set {_uniqueStorage()._iampolicyStatus = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SecretStore contains secret store configurations.
struct Types_SecretStore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KeyPrefix specifies the secret key prefix.
  var keyPrefix: String = String()

  /// KMSKeyID specifies the AWS KMS key for encryption.
  var kmskeyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Redshift contains AWS Redshift specific database metadata.
struct Types_Redshift {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterID is the Redshift cluster identifier.
  var clusterID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RDS contains AWS RDS specific database metadata.
struct Types_RDS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// InstanceID is the RDS instance identifier.
  var instanceID: String = String()

  /// ClusterID is the RDS cluster (Aurora) identifier.
  var clusterID: String = String()

  /// ResourceID is the RDS instance resource identifier (db-xxx).
  var resourceID: String = String()

  /// IAMAuth indicates whether database IAM authentication is enabled.
  var iamauth: Bool = false

  /// Subnets is a list of subnets for the RDS instance.
  var subnets: [String] = []

  /// VPCID is the VPC where the RDS is running.
  var vpcid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RDSProxy contains AWS RDS Proxy specific database metadata.
struct Types_RDSProxy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the identifier of an RDS Proxy.
  var name: String = String()

  /// CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
  var customEndpointName: String = String()

  /// ResourceID is the RDS instance resource identifier (prx-xxx).
  var resourceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ElastiCache contains AWS ElastiCache Redis specific metadata.
struct Types_ElastiCache {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ReplicationGroupID is the Redis replication group ID.
  var replicationGroupID: String = String()

  /// UserGroupIDs is a list of user group IDs.
  var userGroupIds: [String] = []

  /// TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
  var transitEncryptionEnabled: Bool = false

  /// EndpointType is the type of the endpoint.
  var endpointType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MemoryDB contains AWS MemoryDB specific metadata.
struct Types_MemoryDB {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName is the name of the MemoryDB cluster.
  var clusterName: String = String()

  /// ACLName is the name of the ACL associated with the cluster.
  var aclname: String = String()

  /// TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
  var tlsenabled: Bool = false

  /// EndpointType is the type of the endpoint.
  var endpointType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RedshiftServerless contains AWS Redshift Serverless specific metadata.
struct Types_RedshiftServerless {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// WorkgroupName is the workgroup name.
  var workgroupName: String = String()

  /// EndpointName is the VPC endpoint name.
  var endpointName: String = String()

  /// WorkgroupID is the workgroup ID.
  var workgroupID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OpenSearch contains AWS OpenSearch specific metadata.
struct Types_OpenSearch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DomainName is the name of the domain.
  var domainName: String = String()

  /// DomainID is the ID of the domain.
  var domainID: String = String()

  /// EndpointType is the type of the endpoint.
  var endpointType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GCPCloudSQL contains parameters specific to GCP Cloud SQL databases.
struct Types_GCPCloudSQL {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ProjectID is the GCP project ID the Cloud SQL instance resides in.
  var projectID: String = String()

  /// InstanceID is the Cloud SQL instance ID.
  var instanceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Azure contains Azure specific database metadata.
struct Types_Azure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the Azure database server name.
  var name: String = String()

  /// ResourceID is the Azure fully qualified ID for the resource.
  var resourceID: String = String()

  /// Redis contains Azure Cache for Redis specific database metadata.
  var redis: Types_AzureRedis {
    get {return _redis ?? Types_AzureRedis()}
    set {_redis = newValue}
  }
  /// Returns true if `redis` has been explicitly set.
  var hasRedis: Bool {return self._redis != nil}
  /// Clears the value of `redis`. Subsequent reads from it will return its default value.
  mutating func clearRedis() {self._redis = nil}

  /// IsFlexiServer is true if the database is an Azure Flexible server.
  var isFlexiServer: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _redis: Types_AzureRedis? = nil
}

/// AzureRedis contains Azure Cache for Redis specific database metadata.
struct Types_AzureRedis {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusteringPolicy is the clustering policy for Redis Enterprise.
  var clusteringPolicy: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AD contains Active Directory specific database configuration.
struct Types_AD {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KeytabFile is the path to the Kerberos keytab file.
  var keytabFile: String = String()

  /// Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
  var krb5File: String = String()

  /// Domain is the Active Directory domain the database resides in.
  var domain: String = String()

  /// SPN is the service principal name for the database.
  var spn: String = String()

  /// LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
  var ldapcert: String = String()

  /// KDCHostName is the host name for a KDC for x509 Authentication.
  var kdchostName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseTLS contains TLS configuration options.
struct Types_DatabaseTLS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mode is a TLS connection mode. See DatabaseTLSMode for details.
  var mode: Types_DatabaseTLSMode = .verifyFull

  /// CACert is an optional user provided CA certificate used for verifying
  /// database TLS connection.
  var cacert: String = String()

  /// ServerName allows to provide custom hostname. This value will override the
  /// servername/hostname on a certificate during validation.
  var serverName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MySQLOptions are additional MySQL database options.
struct Types_MySQLOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServerVersion is the server version reported by DB proxy if the runtime information is
  /// not available.
  var serverVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MongoAtlas contains Atlas metadata about the database.
struct Types_MongoAtlas {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the Atlas database instance name.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InstanceV1 represents the state of a running teleport instance independent
/// of the specific services that instance exposes.
struct Types_InstanceV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Types_ResourceHeader {
    get {return _storage._header ?? Types_ResourceHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  var spec: Types_InstanceSpecV1 {
    get {return _storage._spec ?? Types_InstanceSpecV1()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_InstanceSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version is the version of teleport this instance most recently advertised.
  var version: String = String()

  /// Services is the list of active services this instance most recently advertised.
  var services: [String] = []

  /// Hostname is the hostname this instance most recently advertised.
  var hostname: String = String()

  /// AuthID is the ID of the auth server that most recently observed this instance.
  var authID: String = String()

  /// LastSeen is the last time an auth server reported observing this instance.
  var lastSeen: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastSeen ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastSeen = newValue}
  }
  /// Returns true if `lastSeen` has been explicitly set.
  var hasLastSeen: Bool {return self._lastSeen != nil}
  /// Clears the value of `lastSeen`. Subsequent reads from it will return its default value.
  mutating func clearLastSeen() {self._lastSeen = nil}

  /// ControlLog is the log of recent important instance control events related to this instance. See comments
  /// on the InstanceControlLogEntry type for details.
  var controlLog: [Types_InstanceControlLogEntry] = []

  /// ExternalUpgrader identifies the external upgrader that the instance is configured to
  /// export schedules to (e.g. 'kube'). Empty if no upgrader is defined.
  var externalUpgrader: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastSeen: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// InstanceControlLogEntry represents an entry in a given instance's control log. The control log of
/// an instance is protected by CompareAndSwap semantics, allowing entries to function as a means of
/// synchronization as well as recordkeeping. For example, an auth server intending to trigger an upgrade
/// for a given instance can check its control log for 'upgrade-attempt' entries. If no such entry exists,
/// it can attempt to write an 'upgrade-attempt' entry of its own. If that entry successfully writes without
/// hitting a CompareFailed, the auth server knows that no other auth servers will make concurrent upgrade
/// attempts while that entry persists.
///
/// NOTE: Due to resource size and backend throughput limitations, care should be taken to minimize the
/// use and size of instance control log entries.
struct Types_InstanceControlLogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type represents the type of control log entry this is (e.g. 'upgrade-attempt').
  var type: String = String()

  /// ID is a random identifier used to assist in uniquely identifying entries. This value may
  /// be unique, or it may be used to associate a collection of related entries (e.g. an upgrade
  /// attempt entry may use the same ID as an associated upgrade failure entry if appropriate).
  var id: UInt64 = 0

  /// Time is the time at which the event represented by this entry occurred (used in determining
  /// ordering and expiry).
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// TTL is an optional custom time to live for this control log entry. Some control log entries
  /// (e.g. an upgrade failure) may require longer than normal TTLs in order to ensure visibility.
  /// If a log entry's TTL results in it having an intended expiry further in the future than the
  /// expiry of the enclosing Instance resource, the instance resource's expiry will be bumped
  /// to accommodate preservation of the log. Because of this fact, custom entry TTLs should be
  /// used sparingly, as excess usage could result in unexpected backend growth for high churn
  /// clusters.
  var ttl: Int64 = 0

  /// Labels is an arbitrary collection of key-value pairs. The expected labels are determined by the
  /// type of the entry. Use of labels is preferable to adding new fields in some cases in order to
  /// preserve fields across auth downgrades (this is mostly relevant for the version-control system).
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// InstanceFilter matches instance resources.
struct Types_InstanceFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServerID matches exactly one instance by server ID if specified.
  var serverID: String = String()

  /// Version matches instance version if specified.
  var version: String = String()

  /// Services matches the instance services if specified. Note that this field matches all instances which
  /// expose *at least* one of the listed services. This is in contrast to service matching in version
  /// directives which match instances that expose a *at most* the listed services.
  var services: [String] = []

  /// ExternalUpgrader matches instance upgrader if specified.
  var externalUpgrader: String = String()

  /// NoExtUpgrader explicitly matches instances for which no upgrader is defined.
  var noExtUpgrader: Bool = false

  /// OlderThanVersion is an optional exclusive upper version bound.
  var olderThanVersion: String = String()

  /// NewerThanVersion is an optional exclusive lower version bound.
  var newerThanVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ServerV2 represents a Node, App, Database, Proxy or Auth server in a Teleport cluster.
struct Types_ServerV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a server spec
  var spec: Types_ServerSpecV2 {
    get {return _spec ?? Types_ServerSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_ServerSpecV2? = nil
}

/// ServerSpecV2 is a specification for V2 Server
struct Types_ServerSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Addr is a host:port address where this server can be reached.
  var addr: String {
    get {return _storage._addr}
    set {_uniqueStorage()._addr = newValue}
  }

  /// PublicAddr is the public address where this server can be reached.
  /// DELETE IN 15.0. (joerger) Deprecated in favor of public_addrs.
  var publicAddr: String {
    get {return _storage._publicAddr}
    set {_uniqueStorage()._publicAddr = newValue}
  }

  /// Hostname is server hostname
  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  /// CmdLabels is server dynamic labels
  var cmdLabels: Dictionary<String,Types_CommandLabelV2> {
    get {return _storage._cmdLabels}
    set {_uniqueStorage()._cmdLabels = newValue}
  }

  /// Rotation specifies server rotation
  var rotation: Types_Rotation {
    get {return _storage._rotation ?? Types_Rotation()}
    set {_uniqueStorage()._rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  var hasRotation: Bool {return _storage._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  mutating func clearRotation() {_uniqueStorage()._rotation = nil}

  /// UseTunnel indicates that connections to this server should occur over a
  /// reverse tunnel.
  var useTunnel: Bool {
    get {return _storage._useTunnel}
    set {_uniqueStorage()._useTunnel = newValue}
  }

  /// TeleportVersion is the teleport version that the server is running on
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// PeerAddr is the address a proxy server is reachable at by its peer proxies.
  var peerAddr: String {
    get {return _storage._peerAddr}
    set {_uniqueStorage()._peerAddr = newValue}
  }

  /// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
  var proxyIds: [String] {
    get {return _storage._proxyIds}
    set {_uniqueStorage()._proxyIds = newValue}
  }

  /// PublicAddrs is a list of public addresses where this server can be reached.
  var publicAddrs: [String] {
    get {return _storage._publicAddrs}
    set {_uniqueStorage()._publicAddrs = newValue}
  }

  /// CloudMetadata contains info about the cloud instance the server is running
  /// on, if any.
  var cloudMetadata: Types_CloudMetadata {
    get {return _storage._cloudMetadata ?? Types_CloudMetadata()}
    set {_uniqueStorage()._cloudMetadata = newValue}
  }
  /// Returns true if `cloudMetadata` has been explicitly set.
  var hasCloudMetadata: Bool {return _storage._cloudMetadata != nil}
  /// Clears the value of `cloudMetadata`. Subsequent reads from it will return its default value.
  mutating func clearCloudMetadata() {_uniqueStorage()._cloudMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AWSInfo contains attributes to match to an EC2 instance.
struct Types_AWSInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AccountID is an AWS account ID.
  var accountID: String = String()

  /// InstanceID is an EC2 instance ID.
  var instanceID: String = String()

  /// Region is the AWS EC2 Instance Region.
  var region: String = String()

  /// VPCID is the AWS VPC ID where the Instance is running.
  var vpcid: String = String()

  /// Integration is the integration name that added this Node.
  /// When connecting to it, it will use this integration to issue AWS API calls in order to set up the connection.
  /// This includes sending an SSH Key and then opening a tunnel (EC2 Instance Connect Endpoint) so Teleport can connect to it.
  var integration: String = String()

  /// SubnetID is the Subnet ID in use by the instance.
  var subnetID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CloudMetadata contains info about the cloud instance a server is running
/// on, if any.
struct Types_CloudMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AWSInfo contains attributes to match to an EC2 instance.
  var aws: Types_AWSInfo {
    get {return _aws ?? Types_AWSInfo()}
    set {_aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return self._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {self._aws = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _aws: Types_AWSInfo? = nil
}

/// AppServerV3 represents a single proxied web app.
struct Types_AppServerV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the app server resource kind. Always "app_server".
  var kind: String = String()

  /// SubKind is an optional resource subkind.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the app server metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is the app server spec.
  var spec: Types_AppServerSpecV3 {
    get {return _spec ?? Types_AppServerSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_AppServerSpecV3? = nil
}

/// AppServerSpecV3 is the app access server spec.
struct Types_AppServerSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version is the Teleport version that the server is running.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Hostname is the app server hostname.
  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  /// HostID is the app server host uuid.
  var hostID: String {
    get {return _storage._hostID}
    set {_uniqueStorage()._hostID = newValue}
  }

  /// Rotation contains the app server CA rotation information.
  var rotation: Types_Rotation {
    get {return _storage._rotation ?? Types_Rotation()}
    set {_uniqueStorage()._rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  var hasRotation: Bool {return _storage._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  mutating func clearRotation() {_uniqueStorage()._rotation = nil}

  /// App is the app proxied by this app server.
  var app: Types_AppV3 {
    get {return _storage._app ?? Types_AppV3()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  mutating func clearApp() {_uniqueStorage()._app = nil}

  /// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
  var proxyIds: [String] {
    get {return _storage._proxyIds}
    set {_uniqueStorage()._proxyIds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppV3List represents a list of app resources.
struct Types_AppV3List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Apps is a list of app resources.
  var apps: [Types_AppV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AppV3 represents an app resource.
struct Types_AppV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the app resource kind. Always "app".
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource subkind.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is the resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata is the app resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is the app resource spec.
  var spec: Types_AppSpecV3 {
    get {return _storage._spec ?? Types_AppSpecV3()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AppSpecV3 is the AppV3 resource spec.
struct Types_AppSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URI is the web app endpoint.
  var uri: String = String()

  /// PublicAddr is the public address the application is accessible at.
  var publicAddr: String = String()

  /// DynamicLabels are the app's command labels.
  var dynamicLabels: Dictionary<String,Types_CommandLabelV2> = [:]

  /// InsecureSkipVerify disables app's TLS certificate verification.
  var insecureSkipVerify: Bool = false

  /// Rewrite is a list of rewriting rules to apply to requests and responses.
  var rewrite: Types_Rewrite {
    get {return _rewrite ?? Types_Rewrite()}
    set {_rewrite = newValue}
  }
  /// Returns true if `rewrite` has been explicitly set.
  var hasRewrite: Bool {return self._rewrite != nil}
  /// Clears the value of `rewrite`. Subsequent reads from it will return its default value.
  mutating func clearRewrite() {self._rewrite = nil}

  /// AWS contains additional options for AWS applications.
  var aws: Types_AppAWS {
    get {return _aws ?? Types_AppAWS()}
    set {_aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return self._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {self._aws = nil}

  /// Cloud identifies the cloud instance the app represents.
  var cloud: String = String()

  /// UserGroups are a list of user group IDs that this app is associated with.
  var userGroups: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rewrite: Types_Rewrite? = nil
  fileprivate var _aws: Types_AppAWS? = nil
}

/// AppServerOrSAMLIdPServiceProviderV1 holds either an AppServerV3 or a SAMLIdPServiceProviderV1 resource (never both).
/// Used in application listings that request both app servers and saml apps.
struct Types_AppServerOrSAMLIdPServiceProviderV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the resource kind. Always "app_server_saml_idp_sp".
  var kind: String = String()

  /// The AppServer or SAMLIdPServiceProvider resource.
  var resource: Types_AppServerOrSAMLIdPServiceProviderV1.OneOf_Resource? = nil

  /// AppServer is the AppServer resource.
  var appServer: Types_AppServerV3 {
    get {
      if case .appServer(let v)? = resource {return v}
      return Types_AppServerV3()
    }
    set {resource = .appServer(newValue)}
  }

  /// SAMLIdPServiceProvider is the SAMLIdPServiceProvider resource.
  var samlidPserviceProvider: Types_SAMLIdPServiceProviderV1 {
    get {
      if case .samlidPserviceProvider(let v)? = resource {return v}
      return Types_SAMLIdPServiceProviderV1()
    }
    set {resource = .samlidPserviceProvider(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The AppServer or SAMLIdPServiceProvider resource.
  enum OneOf_Resource: Equatable {
    /// AppServer is the AppServer resource.
    case appServer(Types_AppServerV3)
    /// SAMLIdPServiceProvider is the SAMLIdPServiceProvider resource.
    case samlidPserviceProvider(Types_SAMLIdPServiceProviderV1)

  #if !swift(>=4.1)
    static func ==(lhs: Types_AppServerOrSAMLIdPServiceProviderV1.OneOf_Resource, rhs: Types_AppServerOrSAMLIdPServiceProviderV1.OneOf_Resource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.appServer, .appServer): return {
        guard case .appServer(let l) = lhs, case .appServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.samlidPserviceProvider, .samlidPserviceProvider): return {
        guard case .samlidPserviceProvider(let l) = lhs, case .samlidPserviceProvider(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Rewrite is a list of rewriting rules to apply to requests and responses.
struct Types_Rewrite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Redirect defines a list of hosts which will be rewritten to the public
  /// address of the application if they occur in the "Location" header.
  var redirect: [String] = []

  /// Headers is a list of headers to inject when passing the request over
  /// to the application.
  var headers: [Types_Header] = []

  /// JWTClaims configures whether roles/traits are included in the JWT token.
  var jwtclaims: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Header represents a single http header passed over to the proxied application.
struct Types_Header {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the http header name.
  var name: String = String()

  /// Value is the http header value.
  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CommandLabelV2 is a label that has a value as a result of the
/// output generated by running command, e.g. hostname
struct Types_CommandLabelV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Period is a time between command runs
  var period: Int64 = 0

  /// Command is a command to run
  var command: [String] = []

  /// Result captures standard output
  var result: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AppAWS contains additional options for AWS applications.
struct Types_AppAWS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ExternalID is the AWS External ID used when assuming roles in this app.
  var externalID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SSHKeyPair is an SSH CA key pair.
struct Types_SSHKeyPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PublicKey is the SSH public key.
  var publicKey: Data = Data()

  /// PrivateKey is the SSH private key.
  var privateKey: Data = Data()

  /// PrivateKeyType is the type of the PrivateKey.
  var privateKeyType: Types_PrivateKeyType = .raw

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TLSKeyPair is a TLS key pair
struct Types_TLSKeyPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cert is a PEM encoded TLS cert
  var cert: Data = Data()

  /// Key is a PEM encoded TLS key
  var key: Data = Data()

  /// KeyType is the type of the Key.
  var keyType: Types_PrivateKeyType = .raw

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// JWTKeyPair is a PEM encoded keypair used for signing JWT tokens.
struct Types_JWTKeyPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PublicKey is a PEM encoded public key.
  var publicKey: Data = Data()

  /// PrivateKey is a PEM encoded private key.
  var privateKey: Data = Data()

  /// PrivateKeyType is the type of the PrivateKey.
  var privateKeyType: Types_PrivateKeyType = .raw

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CertAuthorityV2 is version 2 resource spec for Cert Authority
struct Types_CertAuthorityV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is connector metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec contains cert authority specification
  var spec: Types_CertAuthoritySpecV2 {
    get {return _spec ?? Types_CertAuthoritySpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_CertAuthoritySpecV2? = nil
}

/// CertAuthoritySpecV2 is a host or user certificate authority that
/// can check and if it has private key stored as well, sign it too
struct Types_CertAuthoritySpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is either user or host certificate authority
  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// DELETE IN(2.7.0) this field is deprecated,
  /// as resource name matches cluster name after migrations.
  /// and this property is enforced by the auth server code.
  /// ClusterName identifies cluster name this authority serves,
  /// for host authorities that means base hostname of all servers,
  /// for user authorities that means organization name
  var clusterName: String {
    get {return _storage._clusterName}
    set {_uniqueStorage()._clusterName = newValue}
  }

  /// Roles is a list of roles assumed by users signed by this CA
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// RoleMap specifies role mappings to remote roles
  var roleMap: [Types_RoleMapping] {
    get {return _storage._roleMap}
    set {_uniqueStorage()._roleMap = newValue}
  }

  /// Rotation is a status of the certificate authority rotation
  var rotation: Types_Rotation {
    get {return _storage._rotation ?? Types_Rotation()}
    set {_uniqueStorage()._rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  var hasRotation: Bool {return _storage._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  mutating func clearRotation() {_uniqueStorage()._rotation = nil}

  var signingAlg: Types_CertAuthoritySpecV2.SigningAlgType {
    get {return _storage._signingAlg}
    set {_uniqueStorage()._signingAlg = newValue}
  }

  /// ActiveKeys are the CA key sets used to sign any new certificates.
  var activeKeys: Types_CAKeySet {
    get {return _storage._activeKeys ?? Types_CAKeySet()}
    set {_uniqueStorage()._activeKeys = newValue}
  }
  /// Returns true if `activeKeys` has been explicitly set.
  var hasActiveKeys: Bool {return _storage._activeKeys != nil}
  /// Clears the value of `activeKeys`. Subsequent reads from it will return its default value.
  mutating func clearActiveKeys() {_uniqueStorage()._activeKeys = nil}

  /// AdditionalTrustedKeys are additional CA key sets that can be used to
  /// verify certificates. Certificates should be verified with
  /// AdditionalTrustedKeys and ActiveKeys combined.
  var additionalTrustedKeys: Types_CAKeySet {
    get {return _storage._additionalTrustedKeys ?? Types_CAKeySet()}
    set {_uniqueStorage()._additionalTrustedKeys = newValue}
  }
  /// Returns true if `additionalTrustedKeys` has been explicitly set.
  var hasAdditionalTrustedKeys: Bool {return _storage._additionalTrustedKeys != nil}
  /// Clears the value of `additionalTrustedKeys`. Subsequent reads from it will return its default value.
  mutating func clearAdditionalTrustedKeys() {_uniqueStorage()._additionalTrustedKeys = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SigningAlg is the algorithm used for signing new SSH certificates using
  /// SigningKeys.
  enum SigningAlgType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case rsaSha1 // = 1
    case rsaSha2256 // = 2
    case rsaSha2512 // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .rsaSha1
      case 2: self = .rsaSha2256
      case 3: self = .rsaSha2512
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .rsaSha1: return 1
      case .rsaSha2256: return 2
      case .rsaSha2512: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Types_CertAuthoritySpecV2.SigningAlgType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_CertAuthoritySpecV2.SigningAlgType] = [
    .unknown,
    .rsaSha1,
    .rsaSha2256,
    .rsaSha2512,
  ]
}

#endif  // swift(>=4.2)

/// CAKeySet is the set of CA keys.
struct Types_CAKeySet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SSH contains SSH CA key pairs.
  var ssh: [Types_SSHKeyPair] = []

  /// TLS contains TLS CA key/cert pairs.
  var tls: [Types_TLSKeyPair] = []

  /// JWT contains JWT signing key pairs.
  var jwt: [Types_JWTKeyPair] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RoleMapping provides mapping of remote roles to local roles
/// for trusted clusters
struct Types_RoleMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Remote specifies remote role name to map from
  var remote: String = String()

  /// Local specifies local roles to map to
  var local: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ProvisionTokenV1 is a provisioning token V1
struct Types_ProvisionTokenV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roles is a list of roles associated with the token,
  /// that will be converted to metadata in the SSH and X509
  /// certificates issued to the user of the token
  var roles: [String] = []

  /// Expires is a global expiry time header can be set on any resource in the
  /// system.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// Token is a token name
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// ProvisionTokenV2 specifies provisioning token
struct Types_ProvisionTokenV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a provisioning token V2 spec
  var spec: Types_ProvisionTokenSpecV2 {
    get {return _spec ?? Types_ProvisionTokenSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_ProvisionTokenSpecV2? = nil
}

/// ProvisionTokenV2List is a list of provisioning tokens.
struct Types_ProvisionTokenV2List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ProvisionTokens is a list of provisioning tokens.
  var provisionTokens: [Types_ProvisionTokenV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TokenRule is a rule that a joining node must match in order to use the
/// associated token.
struct Types_TokenRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AWSAccount is the AWS account ID.
  var awsaccount: String = String()

  /// AWSRegions is used for the EC2 join method and is a list of AWS regions a
  /// node is allowed to join from.
  var awsregions: [String] = []

  /// AWSRole is used for the EC2 join method and is the the ARN of the AWS
  /// role that the auth server will assume in order to call the ec2 API.
  var awsrole: String = String()

  /// AWSARN is used for the IAM join method, the AWS identity of joining nodes
  /// must match this ARN. Supports wildcards "*" and "?".
  var awsarn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ProvisionTokenSpecV2 is a specification for V2 token
struct Types_ProvisionTokenSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roles is a list of roles associated with the token,
  /// that will be converted to metadata in the SSH and X509
  /// certificates issued to the user of the token
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// Allow is a list of TokenRules, nodes using this token must match one
  /// allow rule to use this token.
  var allow: [Types_TokenRule] {
    get {return _storage._allow}
    set {_uniqueStorage()._allow = newValue}
  }

  /// AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used
  /// to join the cluster with this token.
  var awsiidttl: Int64 {
    get {return _storage._awsiidttl}
    set {_uniqueStorage()._awsiidttl = newValue}
  }

  /// JoinMethod is the joining method required in order to use this token.
  /// Supported joining methods include "token", "ec2", and "iam".
  var joinMethod: String {
    get {return _storage._joinMethod}
    set {_uniqueStorage()._joinMethod = newValue}
  }

  /// BotName is the name of the bot this token grants access to, if any
  var botName: String {
    get {return _storage._botName}
    set {_uniqueStorage()._botName = newValue}
  }

  /// SuggestedLabels is a set of labels that resources should set when using this token to enroll
  /// themselves in the cluster.
  /// Currently, only node-join scripts create a configuration according to the suggestion.
  var suggestedLabels: Wrappers_LabelValues {
    get {return _storage._suggestedLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._suggestedLabels = newValue}
  }
  /// Returns true if `suggestedLabels` has been explicitly set.
  var hasSuggestedLabels: Bool {return _storage._suggestedLabels != nil}
  /// Clears the value of `suggestedLabels`. Subsequent reads from it will return its default value.
  mutating func clearSuggestedLabels() {_uniqueStorage()._suggestedLabels = nil}

  /// GitHub allows the configuration of options specific to the "github" join method.
  var gitHub: Types_ProvisionTokenSpecV2GitHub {
    get {return _storage._gitHub ?? Types_ProvisionTokenSpecV2GitHub()}
    set {_uniqueStorage()._gitHub = newValue}
  }
  /// Returns true if `gitHub` has been explicitly set.
  var hasGitHub: Bool {return _storage._gitHub != nil}
  /// Clears the value of `gitHub`. Subsequent reads from it will return its default value.
  mutating func clearGitHub() {_uniqueStorage()._gitHub = nil}

  /// CircleCI allows the configuration of options specific to the "circleci" join method.
  var circleCi: Types_ProvisionTokenSpecV2CircleCI {
    get {return _storage._circleCi ?? Types_ProvisionTokenSpecV2CircleCI()}
    set {_uniqueStorage()._circleCi = newValue}
  }
  /// Returns true if `circleCi` has been explicitly set.
  var hasCircleCi: Bool {return _storage._circleCi != nil}
  /// Clears the value of `circleCi`. Subsequent reads from it will return its default value.
  mutating func clearCircleCi() {_uniqueStorage()._circleCi = nil}

  /// SuggestedAgentMatcherLabels is a set of labels to be used by agents to match on resources.
  /// When an agent uses this token, the agent should monitor resources that match those labels.
  /// For databases, this means adding the labels to `db_service.resources.labels`.
  /// Currently, only node-join scripts create a configuration according to the suggestion.
  var suggestedAgentMatcherLabels: Wrappers_LabelValues {
    get {return _storage._suggestedAgentMatcherLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._suggestedAgentMatcherLabels = newValue}
  }
  /// Returns true if `suggestedAgentMatcherLabels` has been explicitly set.
  var hasSuggestedAgentMatcherLabels: Bool {return _storage._suggestedAgentMatcherLabels != nil}
  /// Clears the value of `suggestedAgentMatcherLabels`. Subsequent reads from it will return its default value.
  mutating func clearSuggestedAgentMatcherLabels() {_uniqueStorage()._suggestedAgentMatcherLabels = nil}

  /// Kubernetes allows the configuration of options specific to the "kubernetes" join method.
  var kubernetes: Types_ProvisionTokenSpecV2Kubernetes {
    get {return _storage._kubernetes ?? Types_ProvisionTokenSpecV2Kubernetes()}
    set {_uniqueStorage()._kubernetes = newValue}
  }
  /// Returns true if `kubernetes` has been explicitly set.
  var hasKubernetes: Bool {return _storage._kubernetes != nil}
  /// Clears the value of `kubernetes`. Subsequent reads from it will return its default value.
  mutating func clearKubernetes() {_uniqueStorage()._kubernetes = nil}

  /// Azure allows the configuration of options specific to the "azure" join method.
  var azure: Types_ProvisionTokenSpecV2Azure {
    get {return _storage._azure ?? Types_ProvisionTokenSpecV2Azure()}
    set {_uniqueStorage()._azure = newValue}
  }
  /// Returns true if `azure` has been explicitly set.
  var hasAzure: Bool {return _storage._azure != nil}
  /// Clears the value of `azure`. Subsequent reads from it will return its default value.
  mutating func clearAzure() {_uniqueStorage()._azure = nil}

  /// GitLab allows the configuration of options specific to the "gitlab" join method.
  var gitLab: Types_ProvisionTokenSpecV2GitLab {
    get {return _storage._gitLab ?? Types_ProvisionTokenSpecV2GitLab()}
    set {_uniqueStorage()._gitLab = newValue}
  }
  /// Returns true if `gitLab` has been explicitly set.
  var hasGitLab: Bool {return _storage._gitLab != nil}
  /// Clears the value of `gitLab`. Subsequent reads from it will return its default value.
  mutating func clearGitLab() {_uniqueStorage()._gitLab = nil}

  /// GCP allows the configuration of options specific to the "gcp" join method.
  var gcp: Types_ProvisionTokenSpecV2GCP {
    get {return _storage._gcp ?? Types_ProvisionTokenSpecV2GCP()}
    set {_uniqueStorage()._gcp = newValue}
  }
  /// Returns true if `gcp` has been explicitly set.
  var hasGcp: Bool {return _storage._gcp != nil}
  /// Clears the value of `gcp`. Subsequent reads from it will return its default value.
  mutating func clearGcp() {_uniqueStorage()._gcp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ProvisionTokenSpecV2Github contains the GitHub-specific part of the
/// ProvisionTokenSpecV2
struct Types_ProvisionTokenSpecV2GitHub {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allow is a list of TokenRules, nodes using this token must match one
  /// allow rule to use this token.
  var allow: [Types_ProvisionTokenSpecV2GitHub.Rule] = []

  /// EnterpriseServerHost allows joining from runners associated with a
  /// GitHub Enterprise Server instance. When unconfigured, tokens will be
  /// validated against github.com, but when configured to the host of a GHES
  /// instance, then the tokens will be validated against host.
  ///
  /// This value should be the hostname of the GHES instance, and should not
  /// include the scheme or a path. The instance must be accessible over HTTPS
  /// at this hostname and the certificate must be trusted by the Auth Server.
  var enterpriseServerHost: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Rule includes fields mapped from `lib/githubactions.IDToken`
  /// Not all fields should be included, only ones that we expect to be useful
  /// when trying to create rules around which workflows should be allowed to
  /// authenticate against a cluster.
  struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Sub also known as Subject is a string that roughly uniquely identifies
    /// the workload. The format of this varies depending on the type of
    /// github action run.
    var sub: String = String()

    /// The repository from where the workflow is running.
    /// This includes the name of the owner e.g `gravitational/teleport`
    var repository: String = String()

    /// The name of the organization in which the repository is stored.
    var repositoryOwner: String = String()

    /// The name of the workflow.
    var workflow: String = String()

    /// The name of the environment used by the job.
    var environment: String = String()

    /// The personal account that initiated the workflow run.
    var actor: String = String()

    /// The git ref that triggered the workflow run.
    var ref: String = String()

    /// The type of ref, for example: "branch".
    var refType: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// ProvisionTokenSpecV2GitLab contains the GitLab-specific part of the
/// ProvisionTokenSpecV2
struct Types_ProvisionTokenSpecV2GitLab {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allow is a list of TokenRules, nodes using this token must match one
  /// allow rule to use this token.
  var allow: [Types_ProvisionTokenSpecV2GitLab.Rule] = []

  /// Domain is the domain of your GitLab instance. This will default to
  /// `gitlab.com` - but can be set to the domain of your self-hosted GitLab
  /// e.g `gitlab.example.com`.
  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Sub roughly uniquely identifies the workload. Example:
    /// `project_path:mygroup/my-project:ref_type:branch:ref:main`
    /// project_path:{group}/{project}:ref_type:{type}:ref:{branch_name}
    var sub: String = String()

    /// Ref allows access to be limited to jobs triggered by a specific git ref.
    /// Ensure this is used in combination with ref_type.
    var ref: String = String()

    /// RefType allows access to be limited to jobs triggered by a specific git
    /// ref type. Example:
    /// `branch` or `tag`
    var refType: String = String()

    /// NamespacePath is used to limit access to jobs in a group or user's
    /// projects.
    /// Example:
    /// `mygroup`
    var namespacePath: String = String()

    /// ProjectPath is used to limit access to jobs belonging to an individual
    /// project. Example:
    /// `mygroup/myproject`
    var projectPath: String = String()

    /// PipelineSource limits access by the job pipeline source type.
    /// https://docs.gitlab.com/ee/ci/jobs/job_control.html#common-if-clauses-for-rules
    /// Example: `web`
    var pipelineSource: String = String()

    /// Environment limits access by the environment the job deploys to
    /// (if one is associated)
    var environment: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// ProvisionTokenSpecV2CircleCI contains the CircleCI-specific part of the
/// ProvisionTokenSpecV2
struct Types_ProvisionTokenSpecV2CircleCI {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allow is a list of TokenRules, nodes using this token must match one
  /// allow rule to use this token.
  var allow: [Types_ProvisionTokenSpecV2CircleCI.Rule] = []

  var organizationID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var projectID: String = String()

    var contextID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// ProvisionTokenSpecV2Kubernetes contains the Kubernetes-specific part of the
/// ProvisionTokenSpecV2
struct Types_ProvisionTokenSpecV2Kubernetes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allow is a list of Rules, nodes using this token must match one
  /// allow rule to use this token.
  var allow: [Types_ProvisionTokenSpecV2Kubernetes.Rule] = []

  /// Type controls which behavior should be used for validating the Kubernetes
  /// Service Account token. Support values:
  /// - `in_cluster`
  /// - `static_jwks`
  /// If unset, this defaults to `in_cluster`.
  var type: String = String()

  /// StaticJWKS is the configuration specific to the `static_jwks` type.
  var staticJwks: Types_ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig {
    get {return _staticJwks ?? Types_ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig()}
    set {_staticJwks = newValue}
  }
  /// Returns true if `staticJwks` has been explicitly set.
  var hasStaticJwks: Bool {return self._staticJwks != nil}
  /// Clears the value of `staticJwks`. Subsequent reads from it will return its default value.
  mutating func clearStaticJwks() {self._staticJwks = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StaticJWKSConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// JWKS should be the JSON Web Key Set formatted public keys of that the
    /// Kubernetes Cluster uses to sign service account tokens.
    /// This can be fetched from /openid/v1/jwks on the Kubernetes API Server.
    var jwks: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Rule is a set of properties the Kubernetes-issued token might have to be
  /// allowed to use this ProvisionToken
  struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ServiceAccount is the namespaced name of the Kubernetes service account.
    /// Its format is "namespace:service-account".
    var serviceAccount: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _staticJwks: Types_ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig? = nil
}

/// ProvisionTokenSpecV2Azure contains the Azure-specific part of the
/// ProvisionTokenSpecV2.
struct Types_ProvisionTokenSpecV2Azure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allow is a list of Rules, nodes using this token must match one
  /// allow rule to use this token.
  var allow: [Types_ProvisionTokenSpecV2Azure.Rule] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Rule is a set of properties the Azure-issued token might have to be
  /// allowed to use this ProvisionToken.
  struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Subscription is the Azure subscription.
    var subscription: String = String()

    /// ResourceGroups is a list of Azure resource groups the node is allowed
    /// to join from.
    var resourceGroups: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// ProvisionTokenSpecV2GCP contains the GCP-specific part of the
/// ProvisionTokenSpecV2.
struct Types_ProvisionTokenSpecV2GCP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allow is a list of Rules, nodes using this token must match one
  /// allow rule to use this token.
  var allow: [Types_ProvisionTokenSpecV2GCP.Rule] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Rule is a set of properties the GCP-ussued token might have to be allowed
  /// to use this ProvisionToken.
  struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ProjectIDs is a list of project IDs (e.g. "<example-id-123456>").
    var projectIds: [String] = []

    /// Locations is a list of regions (e.g. "us-west1") and/or zones (e.g.
    /// "us-west1-b").
    var locations: [String] = []

    /// ServiceAccounts is a list of service account emails (e.g.
    /// "<project-number>-compute@developer.gserviceaccount.com").
    var serviceAccounts: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// StaticTokensV2 implements the StaticTokens interface.
struct Types_StaticTokensV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a provisioning token V2 spec
  var spec: Types_StaticTokensSpecV2 {
    get {return _spec ?? Types_StaticTokensSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_StaticTokensSpecV2? = nil
}

/// StaticTokensSpecV2 is the actual data we care about for StaticTokensSpecV2.
struct Types_StaticTokensSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// StaticTokens is a list of tokens that can be used to add nodes to the
  /// cluster.
  var staticTokens: [Types_ProvisionTokenV1] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClusterNameV2 implements the ClusterName interface.
struct Types_ClusterNameV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a cluster name V2 spec
  var spec: Types_ClusterNameSpecV2 {
    get {return _spec ?? Types_ClusterNameSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_ClusterNameSpecV2? = nil
}

/// ClusterNameSpecV2 is the actual data we care about for ClusterName.
struct Types_ClusterNameSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName is the name of the cluster. Changing this value once the
  /// cluster is setup can and will cause catastrophic problems.
  var clusterName: String = String()

  /// ClusterID is the unique cluster ID that is set once during the first
  /// auth server startup.
  var clusterID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClusterAuditConfigV2 represents audit log settings in the cluster.
struct Types_ClusterAuditConfigV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is a resource version
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is a ClusterAuditConfig specification
  var spec: Types_ClusterAuditConfigSpecV2 {
    get {return _storage._spec ?? Types_ClusterAuditConfigSpecV2()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ClusterAuditConfigSpecV2 is the actual data we care about
/// for ClusterAuditConfig.
struct Types_ClusterAuditConfigSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is audit backend type
  var type: String = String()

  /// Region is a region setting for audit sessions used by cloud providers
  var region: String = String()

  /// AuditSessionsURI is a parameter where to upload sessions
  var auditSessionsUri: String = String()

  /// AuditEventsURI is a parameter with all supported outputs
  /// for audit events
  var auditEventsUri: Wrappers_StringValues {
    get {return _auditEventsUri ?? Wrappers_StringValues()}
    set {_auditEventsUri = newValue}
  }
  /// Returns true if `auditEventsUri` has been explicitly set.
  var hasAuditEventsUri: Bool {return self._auditEventsUri != nil}
  /// Clears the value of `auditEventsUri`. Subsequent reads from it will return its default value.
  mutating func clearAuditEventsUri() {self._auditEventsUri = nil}

  /// EnableContinuousBackups is used to enable (or disable) PITR (Point-In-Time Recovery).
  var enableContinuousBackups: Bool = false

  /// EnableAutoScaling is used to enable (or disable) auto scaling policy.
  var enableAutoScaling: Bool = false

  /// ReadMaxCapacity is the maximum provisioned read capacity.
  var readMaxCapacity: Int64 = 0

  /// ReadMinCapacity is the minimum provisioned read capacity.
  var readMinCapacity: Int64 = 0

  /// ReadTargetValue is the ratio of consumed read to provisioned capacity.
  var readTargetValue: Double = 0

  /// WriteMaxCapacity is the maximum provisioned write capacity.
  var writeMaxCapacity: Int64 = 0

  /// WriteMinCapacity is the minimum provisioned write capacity.
  var writeMinCapacity: Int64 = 0

  /// WriteTargetValue is the ratio of consumed write to provisioned capacity.
  var writeTargetValue: Double = 0

  /// RetentionPeriod is the retention period for audit events.
  var retentionPeriod: Int64 = 0

  /// UseFIPSEndpoint configures AWS endpoints to use FIPS.
  var useFipsendpoint: Types_ClusterAuditConfigSpecV2.FIPSEndpointState = .fipsUnset

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// FIPSEndpointState represents an AWS FIPS endpoint state.
  enum FIPSEndpointState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// FIPS_UNSET allows setting FIPS state for AWS S3/Dynamo using configuration files or
    /// environment variables
    case fipsUnset // = 0

    /// FIPS_ENABLED explicitly enables FIPS support for AWS S3/Dynamo
    case fipsEnabled // = 1

    /// FIPS_DISABLED explicitly disables FIPS support for AWS S3/Dynamo
    case fipsDisabled // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .fipsUnset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .fipsUnset
      case 1: self = .fipsEnabled
      case 2: self = .fipsDisabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .fipsUnset: return 0
      case .fipsEnabled: return 1
      case .fipsDisabled: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _auditEventsUri: Wrappers_StringValues? = nil
}

#if swift(>=4.2)

extension Types_ClusterAuditConfigSpecV2.FIPSEndpointState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_ClusterAuditConfigSpecV2.FIPSEndpointState] = [
    .fipsUnset,
    .fipsEnabled,
    .fipsDisabled,
  ]
}

#endif  // swift(>=4.2)

/// ClusterNetworkingConfigV2 contains cluster-wide networking configuration.
struct Types_ClusterNetworkingConfigV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is a resource version
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is a ClusterNetworkingConfig specification
  var spec: Types_ClusterNetworkingConfigSpecV2 {
    get {return _storage._spec ?? Types_ClusterNetworkingConfigSpecV2()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ClusterNetworkingConfigSpecV2 is the actual data we care about
/// for ClusterNetworkingConfig.
struct Types_ClusterNetworkingConfigSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientIdleTimeout sets global cluster default setting for client idle
  /// timeouts.
  var clientIdleTimeout: Int64 = 0

  /// KeepAliveInterval is the interval at which the server sends keep-alive messages
  /// to the client.
  var keepAliveInterval: Int64 = 0

  /// KeepAliveCountMax is the number of keep-alive messages that can be
  /// missed before the server disconnects the connection to the client.
  var keepAliveCountMax: Int64 = 0

  /// SessionControlTimeout is the session control lease expiry and defines
  /// the upper limit of how long a node may be out of contact with the auth
  /// server before it begins terminating controlled sessions.
  var sessionControlTimeout: Int64 = 0

  /// ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
  var clientIdleTimeoutMessage: String = String()

  /// WebIdleTimeout sets global cluster default setting for the web UI idle
  /// timeouts.
  var webIdleTimeout: Int64 = 0

  /// ProxyListenerMode is proxy listener mode used by Teleport Proxies.
  var proxyListenerMode: Types_ProxyListenerMode = .separate

  /// RoutingStrategy determines the strategy used to route to nodes.
  var routingStrategy: Types_RoutingStrategy = .unambiguousMatch

  /// TunnelStrategyV1 determines the tunnel strategy used in the cluster.
  var tunnelStrategy: Types_TunnelStrategyV1 {
    get {return _tunnelStrategy ?? Types_TunnelStrategyV1()}
    set {_tunnelStrategy = newValue}
  }
  /// Returns true if `tunnelStrategy` has been explicitly set.
  var hasTunnelStrategy: Bool {return self._tunnelStrategy != nil}
  /// Clears the value of `tunnelStrategy`. Subsequent reads from it will return its default value.
  mutating func clearTunnelStrategy() {self._tunnelStrategy = nil}

  /// ProxyPingInterval defines in which interval the TLS routing ping message
  /// should be sent. This is applicable only when using ping-wrapped
  /// connections, regular TLS routing connections are not affected.
  var proxyPingInterval: Int64 = 0

  /// AssistCommandExecutionWorkers determines the number of workers that will
  /// execute arbitrary Assist commands on servers in parallel
  var assistCommandExecutionWorkers: Int32 = 0

  /// CaseInsensitiveRouting causes proxies to use case-insensitive hostname matching.
  var caseInsensitiveRouting: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tunnelStrategy: Types_TunnelStrategyV1? = nil
}

/// TunnelStrategyV1 defines possible tunnel strategy types.
struct Types_TunnelStrategyV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var strategy: Types_TunnelStrategyV1.OneOf_Strategy? = nil

  var agentMesh: Types_AgentMeshTunnelStrategy {
    get {
      if case .agentMesh(let v)? = strategy {return v}
      return Types_AgentMeshTunnelStrategy()
    }
    set {strategy = .agentMesh(newValue)}
  }

  var proxyPeering: Types_ProxyPeeringTunnelStrategy {
    get {
      if case .proxyPeering(let v)? = strategy {return v}
      return Types_ProxyPeeringTunnelStrategy()
    }
    set {strategy = .proxyPeering(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Strategy: Equatable {
    case agentMesh(Types_AgentMeshTunnelStrategy)
    case proxyPeering(Types_ProxyPeeringTunnelStrategy)

  #if !swift(>=4.1)
    static func ==(lhs: Types_TunnelStrategyV1.OneOf_Strategy, rhs: Types_TunnelStrategyV1.OneOf_Strategy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.agentMesh, .agentMesh): return {
        guard case .agentMesh(let l) = lhs, case .agentMesh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proxyPeering, .proxyPeering): return {
        guard case .proxyPeering(let l) = lhs, case .proxyPeering(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// AgentMeshTunnelStrategy requires reverse tunnels to dial every proxy.
struct Types_AgentMeshTunnelStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ProxyPeeringTunnelStrategy requires reverse tunnels to dial a fixed number of proxies.
struct Types_ProxyPeeringTunnelStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var agentConnectionCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionRecordingConfigV2 contains session recording configuration.
struct Types_SessionRecordingConfigV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is a resource version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a SessionRecordingConfig specification
  var spec: Types_SessionRecordingConfigSpecV2 {
    get {return _spec ?? Types_SessionRecordingConfigSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_SessionRecordingConfigSpecV2? = nil
}

/// SessionRecordingConfigSpecV2 is the actual data we care about
/// for SessionRecordingConfig.
struct Types_SessionRecordingConfigSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mode controls where (or if) the session is recorded.
  var mode: String = String()

  /// ProxyChecksHostKeys is used to control if the proxy will check host keys
  /// when in recording mode.
  var proxyChecksHostKeys: Types_BoolValue {
    get {return _proxyChecksHostKeys ?? Types_BoolValue()}
    set {_proxyChecksHostKeys = newValue}
  }
  /// Returns true if `proxyChecksHostKeys` has been explicitly set.
  var hasProxyChecksHostKeys: Bool {return self._proxyChecksHostKeys != nil}
  /// Clears the value of `proxyChecksHostKeys`. Subsequent reads from it will return its default value.
  mutating func clearProxyChecksHostKeys() {self._proxyChecksHostKeys = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proxyChecksHostKeys: Types_BoolValue? = nil
}

/// AuthPreferenceV2 implements the AuthPreference interface.
struct Types_AuthPreferenceV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is a resource version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is an AuthPreference specification
  var spec: Types_AuthPreferenceSpecV2 {
    get {return _spec ?? Types_AuthPreferenceSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_AuthPreferenceSpecV2? = nil
}

/// AuthPreferenceSpecV2 is the actual data we care about for AuthPreference.
struct Types_AuthPreferenceSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is the type of authentication.
  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// SecondFactor is the type of second factor.
  var secondFactor: String {
    get {return _storage._secondFactor}
    set {_uniqueStorage()._secondFactor = newValue}
  }

  /// ConnectorName is the name of the OIDC or SAML connector. If this value is
  /// not set the first connector in the backend will be used.
  var connectorName: String {
    get {return _storage._connectorName}
    set {_uniqueStorage()._connectorName = newValue}
  }

  /// U2F are the settings for the U2F device.
  var u2F: Types_U2F {
    get {return _storage._u2F ?? Types_U2F()}
    set {_uniqueStorage()._u2F = newValue}
  }
  /// Returns true if `u2F` has been explicitly set.
  var hasU2F: Bool {return _storage._u2F != nil}
  /// Clears the value of `u2F`. Subsequent reads from it will return its default value.
  mutating func clearU2F() {_uniqueStorage()._u2F = nil}

  /// DisconnectExpiredCert provides disconnect expired certificate setting -
  /// if true, connections with expired client certificates will get disconnected
  var disconnectExpiredCert: Types_BoolValue {
    get {return _storage._disconnectExpiredCert ?? Types_BoolValue()}
    set {_uniqueStorage()._disconnectExpiredCert = newValue}
  }
  /// Returns true if `disconnectExpiredCert` has been explicitly set.
  var hasDisconnectExpiredCert: Bool {return _storage._disconnectExpiredCert != nil}
  /// Clears the value of `disconnectExpiredCert`. Subsequent reads from it will return its default value.
  mutating func clearDisconnectExpiredCert() {_uniqueStorage()._disconnectExpiredCert = nil}

  /// AllowLocalAuth is true if local authentication is enabled.
  var allowLocalAuth: Types_BoolValue {
    get {return _storage._allowLocalAuth ?? Types_BoolValue()}
    set {_uniqueStorage()._allowLocalAuth = newValue}
  }
  /// Returns true if `allowLocalAuth` has been explicitly set.
  var hasAllowLocalAuth: Bool {return _storage._allowLocalAuth != nil}
  /// Clears the value of `allowLocalAuth`. Subsequent reads from it will return its default value.
  mutating func clearAllowLocalAuth() {_uniqueStorage()._allowLocalAuth = nil}

  var messageOfTheDay: String {
    get {return _storage._messageOfTheDay}
    set {_uniqueStorage()._messageOfTheDay = newValue}
  }

  /// LockingMode is the cluster-wide locking mode default.
  var lockingMode: String {
    get {return _storage._lockingMode}
    set {_uniqueStorage()._lockingMode = newValue}
  }

  /// Webauthn are the settings for server-side Web Authentication support.
  var webauthn: Types_Webauthn {
    get {return _storage._webauthn ?? Types_Webauthn()}
    set {_uniqueStorage()._webauthn = newValue}
  }
  /// Returns true if `webauthn` has been explicitly set.
  var hasWebauthn: Bool {return _storage._webauthn != nil}
  /// Clears the value of `webauthn`. Subsequent reads from it will return its default value.
  mutating func clearWebauthn() {_uniqueStorage()._webauthn = nil}

  /// AllowPasswordless enables/disables passwordless support.
  /// Passwordless requires Webauthn to work.
  /// Defaults to true if the Webauthn is configured, defaults to false
  /// otherwise.
  var allowPasswordless: Types_BoolValue {
    get {return _storage._allowPasswordless ?? Types_BoolValue()}
    set {_uniqueStorage()._allowPasswordless = newValue}
  }
  /// Returns true if `allowPasswordless` has been explicitly set.
  var hasAllowPasswordless: Bool {return _storage._allowPasswordless != nil}
  /// Clears the value of `allowPasswordless`. Subsequent reads from it will return its default value.
  mutating func clearAllowPasswordless() {_uniqueStorage()._allowPasswordless = nil}

  /// RequireMFAType is the type of MFA requirement enforced for this cluster.
  var requireMfatype: Types_RequireMFAType {
    get {return _storage._requireMfatype}
    set {_uniqueStorage()._requireMfatype = newValue}
  }

  /// DeviceTrust holds settings related to trusted device verification.
  /// Requires Teleport Enterprise.
  var deviceTrust: Types_DeviceTrust {
    get {return _storage._deviceTrust ?? Types_DeviceTrust()}
    set {_uniqueStorage()._deviceTrust = newValue}
  }
  /// Returns true if `deviceTrust` has been explicitly set.
  var hasDeviceTrust: Bool {return _storage._deviceTrust != nil}
  /// Clears the value of `deviceTrust`. Subsequent reads from it will return its default value.
  mutating func clearDeviceTrust() {_uniqueStorage()._deviceTrust = nil}

  /// IDP is a set of options related to accessing IdPs within Teleport.
  /// Requires Teleport Enterprise.
  var idp: Types_IdPOptions {
    get {return _storage._idp ?? Types_IdPOptions()}
    set {_uniqueStorage()._idp = newValue}
  }
  /// Returns true if `idp` has been explicitly set.
  var hasIdp: Bool {return _storage._idp != nil}
  /// Clears the value of `idp`. Subsequent reads from it will return its default value.
  mutating func clearIdp() {_uniqueStorage()._idp = nil}

  /// AllowHeadless enables/disables headless support.
  /// Headless authentication requires Webauthn to work.
  /// Defaults to true if the Webauthn is configured, defaults to false
  /// otherwise.
  var allowHeadless: Types_BoolValue {
    get {return _storage._allowHeadless ?? Types_BoolValue()}
    set {_uniqueStorage()._allowHeadless = newValue}
  }
  /// Returns true if `allowHeadless` has been explicitly set.
  var hasAllowHeadless: Bool {return _storage._allowHeadless != nil}
  /// Clears the value of `allowHeadless`. Subsequent reads from it will return its default value.
  mutating func clearAllowHeadless() {_uniqueStorage()._allowHeadless = nil}

  /// DefaultSessionTTL is the TTL to use for user certs when
  /// an explicit TTL is not requested.
  var defaultSessionTtl: Int64 {
    get {return _storage._defaultSessionTtl}
    set {_uniqueStorage()._defaultSessionTtl = newValue}
  }

  /// Okta is a set of options related to the Okta service in Teleport.
  /// Requires Teleport Enterprise.
  var okta: Types_OktaOptions {
    get {return _storage._okta ?? Types_OktaOptions()}
    set {_uniqueStorage()._okta = newValue}
  }
  /// Returns true if `okta` has been explicitly set.
  var hasOkta: Bool {return _storage._okta != nil}
  /// Clears the value of `okta`. Subsequent reads from it will return its default value.
  mutating func clearOkta() {_uniqueStorage()._okta = nil}

  /// PIVSlot is a PIV slot that Teleport clients should use instead of the
  /// default based on private key policy. For example, "9a" or "9e".
  var pivslot: String {
    get {return _storage._pivslot}
    set {_uniqueStorage()._pivslot = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// U2F defines settings for U2F device.
/// Deprecated: U2F is transparently converted to WebAuthn by Teleport. Prefer
/// using WebAuthn instead.
struct Types_U2F {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AppID returns the application ID for universal second factor.
  var appID: String = String()

  /// Facets returns the facets for universal second factor.
  /// Deprecated: Kept for backwards compatibility reasons, but Facets have no
  /// effect since Teleport v10, when Webauthn replaced the U2F implementation.
  var facets: [String] = []

  /// DeviceAttestationCAs contains the trusted attestation CAs for U2F
  /// devices.
  var deviceAttestationCas: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Webauthn defines user-visible settings for server-side Web Authentication
/// support.
struct Types_Webauthn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RPID is the ID of the Relying Party.
  /// It should be set to the domain name of the Teleport installation.
  ///
  /// IMPORTANT: RPID must never change in the lifetime of the cluster, because
  /// it's recorded in the registration data on the WebAuthn device. If the
  /// RPID changes, all existing WebAuthn key registrations will become invalid
  /// and all users who use WebAuthn as the second factor will need to
  /// re-register.
  var rpid: String = String()

  /// Allow list of device attestation CAs in PEM format.
  /// If present, only devices whose attestation certificates match the
  /// certificates specified here may be registered (existing registrations are
  /// unchanged).
  /// If supplied in conjunction with AttestationDeniedCAs, then both
  /// conditions need to be true for registration to be allowed (the device
  /// MUST match an allowed CA and MUST NOT match a denied CA).
  /// By default all devices are allowed.
  var attestationAllowedCas: [String] = []

  /// Deny list of device attestation CAs in PEM format.
  /// If present, only devices whose attestation certificates don't match the
  /// certificates specified here may be registered (existing registrations are
  /// unchanged).
  /// If supplied in conjunction with AttestationAllowedCAs, then both
  /// conditions need to be true for registration to be allowed (the device
  /// MUST match an allowed CA and MUST NOT match a denied CA).
  /// By default no devices are denied.
  var attestationDeniedCas: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeviceTrust holds settings related to trusted device verification.
/// Requires Teleport Enterprise.
struct Types_DeviceTrust {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mode of verification for trusted devices.
  ///
  /// The following modes are supported:
  ///
  /// - "off": disables both device authentication and authorization.
  /// - "optional": allows both device authentication and authorization, but
  ///   doesn't enforce the presence of device extensions for sensitive
  ///   endpoints.
  /// - "required": enforces the presence of device extensions for sensitive
  ///   endpoints.
  ///
  /// Mode is always "off" for OSS.
  /// Defaults to "optional" for Enterprise.
  var mode: String = String()

  /// Enable device auto-enroll.
  /// Auto-enroll lets any user issue a device enrollment token for a known
  /// device that is not already enrolled.
  /// `tsh` takes advantage of auto-enroll to automatically enroll devices on
  /// user login, when appropriate.
  /// The effective cluster Mode still applies: AutoEnroll=true is meaningless if
  /// Mode="off".
  var autoEnroll: Bool = false

  /// Allow list of EKCert CAs in PEM format.
  /// If present, only TPM devices that present an EKCert that is signed by a
  /// CA specified here may be enrolled (existing enrollments are
  /// unchanged).
  ///
  /// If not present, then the CA of TPM EKCerts will not be checked during
  /// enrollment, this allows any device to enroll.
  var ekcertAllowedCas: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Namespace represents namespace resource specification
struct Types_Namespace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a namespace spec
  var spec: Types_NamespaceSpec {
    get {return _spec ?? Types_NamespaceSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_NamespaceSpec? = nil
}

/// NamespaceSpec is a namespace specification
struct Types_NamespaceSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_UserTokenV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is a resource sub kind, used to define the type of user token.
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is an resource specification
  var spec: Types_UserTokenSpecV3 {
    get {return _spec ?? Types_UserTokenSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_UserTokenSpecV3? = nil
}

struct Types_UserTokenSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is user name associated with this token
  var user: String = String()

  /// URL is this token URL
  var url: String = String()

  /// Usage is an optional field that provides more information about how this token will be used.
  var usage: Types_UserTokenUsage = .unspecified

  /// Created holds information about when the token was created
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Types_UserTokenSecretsV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is an resource specification
  var spec: Types_UserTokenSecretsSpecV3 {
    get {return _spec ?? Types_UserTokenSecretsSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_UserTokenSecretsSpecV3? = nil
}

struct Types_UserTokenSecretsSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OTPKey is is a secret value of one time password secret generator
  var otpkey: String = String()

  /// OTPKey is is a secret value of one time password secret generator
  var qrcode: String = String()

  /// Created holds information about when the token was created
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// AccessRequest represents an access request resource specification
struct Types_AccessRequestV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is AccessRequest metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is an AccessRequest specification
  var spec: Types_AccessRequestSpecV3 {
    get {return _spec ?? Types_AccessRequestSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_AccessRequestSpecV3? = nil
}

/// AccessReviewThreshold describes a filter used to match access reviews,
/// as well as approval/denial counts which trigger state-transitions.  This type
/// can be used to describe policies such as "can be approved by 2 admins"
/// or "can be denied by any non-contractor".
struct Types_AccessReviewThreshold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the optional human-readable name of the threshold.
  var name: String = String()

  /// Filter is an optional predicate used to determine which reviews
  /// count toward this threshold.
  var filter: String = String()

  /// Approve is the number of matching approvals needed for state-transition.
  var approve: UInt32 = 0

  /// Deny is the number of denials needed for state-transition.
  var deny: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PromotedAccessList is a minimal access list representation used for
/// promoting access requests to access lists.
struct Types_PromotedAccessList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the access list.
  var name: String = String()

  /// Title is the title of the access list.
  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessReview is a review to be applied to an access request.
struct Types_AccessReview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Author is the teleport username of the review author.
  var author: String = String()

  /// Roles is a list used for role-subselection (not yet fully supported).
  var roles: [String] = []

  /// ProposedState is the proposed state (must be APPROVED or DENIED).
  var proposedState: Types_RequestState = .none

  /// Reason is an optional human-readable reason for why the above state
  /// is being proposed.
  var reason: String = String()

  /// Created is the time at which the review was created.
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  /// Annotations is the proposed value of the request's resolve_annotations field.
  var annotations: Wrappers_LabelValues {
    get {return _annotations ?? Wrappers_LabelValues()}
    set {_annotations = newValue}
  }
  /// Returns true if `annotations` has been explicitly set.
  var hasAnnotations: Bool {return self._annotations != nil}
  /// Clears the value of `annotations`. Subsequent reads from it will return its default value.
  mutating func clearAnnotations() {self._annotations = nil}

  /// ThresholdIndexes stores the indexes of thresholds which this review matches
  /// (internal use only).
  var thresholdIndexes: [UInt32] = []

  /// AccessList is the access list that this request was promoted to.
  /// This field is only populated when the request is in the PROMOTED state.
  var accessList: Types_PromotedAccessList {
    get {return _accessList ?? Types_PromotedAccessList()}
    set {_accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return self._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {self._accessList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _annotations: Wrappers_LabelValues? = nil
  fileprivate var _accessList: Types_PromotedAccessList? = nil
}

/// AccessReviewSubmission encodes the necessary parameters for submitting
/// a new access review.
struct Types_AccessReviewSubmission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestID is the unique ID of the request to be reviewed.
  var requestID: String = String()

  /// Review is the review to be applied.
  var review: Types_AccessReview {
    get {return _review ?? Types_AccessReview()}
    set {_review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  var hasReview: Bool {return self._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  mutating func clearReview() {self._review = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _review: Types_AccessReview? = nil
}

/// ThresholdIndexSet encodes a list of threshold indexes. One of the listed thresholds
/// must pass for the set to be considered to have passed (i.e. this is an `or` operator).
struct Types_ThresholdIndexSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indexes are the indexes of thresholds which relate to the role.
  var indexes: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ThresholdIndexSets is a list of threshold index sets.  Each of the individual
/// sets must pass (i.e. this is an `and` operator).
struct Types_ThresholdIndexSets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sets are the sets that make up this group.
  var sets: [Types_ThresholdIndexSet] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestSpec is the specification for AccessRequest
struct Types_AccessRequestSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is the name of the user to whom the roles will be applied.
  var user: String {
    get {return _storage._user}
    set {_uniqueStorage()._user = newValue}
  }

  /// Roles is the name of the roles being requested.
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// State is the current state of this access request.
  var state: Types_RequestState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Created encodes the time at which the request was registered with the auth
  /// server.
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// Expires constrains the maximum lifetime of any login session for which this
  /// request is active.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  /// RequestReason is an optional message explaining the reason for the request.
  var requestReason: String {
    get {return _storage._requestReason}
    set {_uniqueStorage()._requestReason = newValue}
  }

  /// ResolveReason is an optional message explaining the reason for the resolution
  /// of the request (approval, denial, etc...).
  var resolveReason: String {
    get {return _storage._resolveReason}
    set {_uniqueStorage()._resolveReason = newValue}
  }

  /// ResolveAnnotations is a set of arbitrary values received from plugins or other
  /// resolving parties during approval/denial.  Importantly, these annotations are
  /// included in the access_request.update event, allowing plugins to propagate
  /// arbitrary structured data to the audit log.
  var resolveAnnotations: Wrappers_LabelValues {
    get {return _storage._resolveAnnotations ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._resolveAnnotations = newValue}
  }
  /// Returns true if `resolveAnnotations` has been explicitly set.
  var hasResolveAnnotations: Bool {return _storage._resolveAnnotations != nil}
  /// Clears the value of `resolveAnnotations`. Subsequent reads from it will return its default value.
  mutating func clearResolveAnnotations() {_uniqueStorage()._resolveAnnotations = nil}

  /// SystemAnnotations is a set of programmatically generated annotations attached
  /// to pending access requests by teleport.  These annotations are generated by
  /// applying variable interpolation to the RoleConditions.Request.Annotations block
  /// of a user's role(s).  These annotations serve as a mechanism for administrators
  /// to pass extra information to plugins when they process pending access requests.
  var systemAnnotations: Wrappers_LabelValues {
    get {return _storage._systemAnnotations ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._systemAnnotations = newValue}
  }
  /// Returns true if `systemAnnotations` has been explicitly set.
  var hasSystemAnnotations: Bool {return _storage._systemAnnotations != nil}
  /// Clears the value of `systemAnnotations`. Subsequent reads from it will return its default value.
  mutating func clearSystemAnnotations() {_uniqueStorage()._systemAnnotations = nil}

  /// Thresholds is a list of review thresholds relevant to this request.  Order must be
  /// preserved, as thresholds are referenced by index (internal use only).
  var thresholds: [Types_AccessReviewThreshold] {
    get {return _storage._thresholds}
    set {_uniqueStorage()._thresholds = newValue}
  }

  /// RoleThresholdMapping encodes the relationship between the requested roles and
  /// the review threshold requirements for the given role (internal use only).
  /// By storing a representation of which thresholds must pass for each requested role, we
  /// both eliminate the need to cache the requestor's roles directly, and allow future
  /// versions of teleport to become smarter about calculating more granular requirements
  /// in a backwards-compatible manner (i.e. calculation can become smarter in minor releases).
  /// Storing this relationship on the request is necessary in order to avoid unexpected or
  /// inconsistent behavior due to review submission timing.
  var roleThresholdMapping: Dictionary<String,Types_ThresholdIndexSets> {
    get {return _storage._roleThresholdMapping}
    set {_uniqueStorage()._roleThresholdMapping = newValue}
  }

  /// Reviews is a list of reviews applied to this request (internal use only).
  var reviews: [Types_AccessReview] {
    get {return _storage._reviews}
    set {_uniqueStorage()._reviews = newValue}
  }

  /// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
  /// that is not a requirement.
  var suggestedReviewers: [String] {
    get {return _storage._suggestedReviewers}
    set {_uniqueStorage()._suggestedReviewers = newValue}
  }

  /// RequestedResourceIDs is a set of resources to which access is being requested.
  var requestedResourceIds: [Types_ResourceID] {
    get {return _storage._requestedResourceIds}
    set {_uniqueStorage()._requestedResourceIds = newValue}
  }

  /// LoginHint is used as a hint for search-based access requests to select
  /// roles based on the login the user is attempting.
  var loginHint: String {
    get {return _storage._loginHint}
    set {_uniqueStorage()._loginHint = newValue}
  }

  /// DryRun indicates that the request should not actually be created, the
  /// auth server should only validate the access request.
  var dryRun: Bool {
    get {return _storage._dryRun}
    set {_uniqueStorage()._dryRun = newValue}
  }

  /// MaxDuration indicates how long the access should be granted for.
  var maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._maxDuration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._maxDuration = newValue}
  }
  /// Returns true if `maxDuration` has been explicitly set.
  var hasMaxDuration: Bool {return _storage._maxDuration != nil}
  /// Clears the value of `maxDuration`. Subsequent reads from it will return its default value.
  mutating func clearMaxDuration() {_uniqueStorage()._maxDuration = nil}

  /// SessionTLL indicated how long a certificate for a session should be valid for.
  var sessionTtl: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._sessionTtl ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._sessionTtl = newValue}
  }
  /// Returns true if `sessionTtl` has been explicitly set.
  var hasSessionTtl: Bool {return _storage._sessionTtl != nil}
  /// Clears the value of `sessionTtl`. Subsequent reads from it will return its default value.
  mutating func clearSessionTtl() {_uniqueStorage()._sessionTtl = nil}

  /// PromotedAccessListTitle is the title of the access list that this request
  /// was promoted to. Used by WebUI to display the title of the access list.
  /// This field is only populated when the request is in the PROMOTED state.
  var accessList: Types_PromotedAccessList {
    get {return _storage._accessList ?? Types_PromotedAccessList()}
    set {_uniqueStorage()._accessList = newValue}
  }
  /// Returns true if `accessList` has been explicitly set.
  var hasAccessList: Bool {return _storage._accessList != nil}
  /// Clears the value of `accessList`. Subsequent reads from it will return its default value.
  mutating func clearAccessList() {_uniqueStorage()._accessList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccessRequestFilter encodes filter params for access requests.
struct Types_AccessRequestFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID specifies a request ID if set.
  var id: String = String()

  /// User specifies a username if set.
  var user: String = String()

  /// RequestState filters for requests in a specific state.
  var state: Types_RequestState = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessCapabilities is a summary of capabilities that a user
/// is granted via their dynamic access privileges which may not be
/// calculable by directly examining the user's own static roles.
struct Types_AccessCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestableRoles is a list of existent roles which the user is allowed to request.
  var requestableRoles: [String] = []

  /// SuggestedReviewers is a list of all reviewers which are suggested by the user's roles.
  var suggestedReviewers: [String] = []

  /// ApplicableRolesForResources is a list of the roles applicable for access to a given set of resources.
  var applicableRolesForResources: [String] = []

  /// RequestPrompt is an optional message which tells users what they aught to request.
  var requestPrompt: String = String()

  /// RequireReason indicates whether the request strategy is one that requires
  /// users to always supply reasons with their requests.
  var requireReason: Bool = false

  /// AutoRequest indicates whether the request strategy indicates that a
  /// request should be automatically generated on login.
  var autoRequest: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessCapabilitiesRequest encodes parameters for the GetAccessCapabilities method.
struct Types_AccessCapabilitiesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is the name of the user whose capabilities we are interested in (defaults to
  /// the caller's own username).
  var user: String = String()

  /// RequestableRoles is a flag indicating that we would like to view the list of roles
  /// that the user is able to request.
  var requestableRoles: Bool = false

  /// SuggestedReviewers is a flag indicating that we would like to view the list of all
  /// reviewers which are suggested by the user's roles.
  var suggestedReviewers: Bool = false

  /// ResourceIDs is the list of the ResourceIDs of the resources we would like to view
  /// the necessary roles for.
  var resourceIds: [Types_ResourceID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResourceID is a unique identifier for a teleport resource.
struct Types_ResourceID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName is the name of the cluster the resource is in.
  var clusterName: String = String()

  /// Kind is the resource kind.
  var kind: String = String()

  /// Name is the name of the specific resource.
  var name: String = String()

  /// SubResourceName is the resource belonging to resource identified by "Name"
  /// that the user is allowed to access to.
  /// When granting access to a subresource, access to other resources is limited.
  /// Currently it just supports resources of Kind=pod and the format is the following
  /// "<kube_namespace>/<kube_pod>".
  var subResourceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginData stores a collection of values associated with a specific resource.
struct Types_PluginDataV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is PluginData metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a PluginData specification
  var spec: Types_PluginDataSpecV3 {
    get {return _spec ?? Types_PluginDataSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_PluginDataSpecV3? = nil
}

/// PluginDataEntry wraps a mapping of arbitrary string values used by
/// plugins to store per-resource information.
struct Types_PluginDataEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data is a mapping of arbitrary string values.
  var data: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginData stores a collection of values associated with a specific resource.
struct Types_PluginDataSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entries is a collection of PluginData values organized by plugin name.
  var entries: Dictionary<String,Types_PluginDataEntry> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginDataFilter encodes filter params for plugin data.
struct Types_PluginDataFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the kind of resource that the target plugin data
  /// is associated with.
  var kind: String = String()

  /// Resource matches a specific resource name if set.
  var resource: String = String()

  /// Plugin matches a specific plugin name if set.
  var plugin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginDataUpdateParams encodes parameters for updating a PluginData field.
struct Types_PluginDataUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the kind of resource that the target plugin data
  /// is associated with.
  var kind: String = String()

  /// Resource indicates the name of the target resource.
  var resource: String = String()

  /// Plugin is the name of the plugin that owns the data.
  var plugin: String = String()

  /// Set indicates the fields which should be set by this operation.
  var set: Dictionary<String,String> = [:]

  /// Expect optionally indicates the expected state of fields prior to this update.
  var expect: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RoleV6 represents role resource specification
struct Types_RoleV6 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a role specification
  var spec: Types_RoleSpecV6 {
    get {return _spec ?? Types_RoleSpecV6()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_RoleSpecV6? = nil
}

/// RoleSpecV6 is role specification for RoleV6.
struct Types_RoleSpecV6 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Options is for OpenSSH options like agent forwarding.
  var options: Types_RoleOptions {
    get {return _options ?? Types_RoleOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  /// Allow is the set of conditions evaluated to grant access.
  var allow: Types_RoleConditions {
    get {return _allow ?? Types_RoleConditions()}
    set {_allow = newValue}
  }
  /// Returns true if `allow` has been explicitly set.
  var hasAllow: Bool {return self._allow != nil}
  /// Clears the value of `allow`. Subsequent reads from it will return its default value.
  mutating func clearAllow() {self._allow = nil}

  /// Deny is the set of conditions evaluated to deny access. Deny takes priority
  /// over allow.
  var deny: Types_RoleConditions {
    get {return _deny ?? Types_RoleConditions()}
    set {_deny = newValue}
  }
  /// Returns true if `deny` has been explicitly set.
  var hasDeny: Bool {return self._deny != nil}
  /// Clears the value of `deny`. Subsequent reads from it will return its default value.
  mutating func clearDeny() {self._deny = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _options: Types_RoleOptions? = nil
  fileprivate var _allow: Types_RoleConditions? = nil
  fileprivate var _deny: Types_RoleConditions? = nil
}

/// RoleOptions is a set of role options
struct Types_RoleOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ForwardAgent is SSH agent forwarding.
  var forwardAgent: Bool {
    get {return _storage._forwardAgent}
    set {_uniqueStorage()._forwardAgent = newValue}
  }

  /// MaxSessionTTL defines how long a SSH session can last for.
  var maxSessionTtl: Int64 {
    get {return _storage._maxSessionTtl}
    set {_uniqueStorage()._maxSessionTtl = newValue}
  }

  /// PortForwarding defines if the certificate will have
  /// "permit-port-forwarding"
  /// in the certificate. PortForwarding is "yes" if not set,
  /// that's why this is a pointer
  var portForwarding: Types_BoolValue {
    get {return _storage._portForwarding ?? Types_BoolValue()}
    set {_uniqueStorage()._portForwarding = newValue}
  }
  /// Returns true if `portForwarding` has been explicitly set.
  var hasPortForwarding: Bool {return _storage._portForwarding != nil}
  /// Clears the value of `portForwarding`. Subsequent reads from it will return its default value.
  mutating func clearPortForwarding() {_uniqueStorage()._portForwarding = nil}

  /// CertificateFormat defines the format of the user certificate to allow
  /// compatibility with older versions of OpenSSH.
  var certificateFormat: String {
    get {return _storage._certificateFormat}
    set {_uniqueStorage()._certificateFormat = newValue}
  }

  /// ClientIdleTimeout sets disconnect clients on idle timeout behavior,
  /// if set to 0 means do not disconnect, otherwise is set to the idle
  /// duration.
  var clientIdleTimeout: Int64 {
    get {return _storage._clientIdleTimeout}
    set {_uniqueStorage()._clientIdleTimeout = newValue}
  }

  /// DisconnectExpiredCert sets disconnect clients on expired certificates.
  var disconnectExpiredCert: Bool {
    get {return _storage._disconnectExpiredCert}
    set {_uniqueStorage()._disconnectExpiredCert = newValue}
  }

  /// BPF defines what events to record for the BPF-based session recorder.
  var bpf: [String] {
    get {return _storage._bpf}
    set {_uniqueStorage()._bpf = newValue}
  }

  /// PermitX11Forwarding authorizes use of X11 forwarding.
  var permitX11Forwarding: Bool {
    get {return _storage._permitX11Forwarding}
    set {_uniqueStorage()._permitX11Forwarding = newValue}
  }

  /// MaxConnections defines the maximum number of
  /// concurrent connections a user may hold.
  var maxConnections: Int64 {
    get {return _storage._maxConnections}
    set {_uniqueStorage()._maxConnections = newValue}
  }

  /// MaxSessions defines the maximum number of
  /// concurrent sessions per connection.
  var maxSessions: Int64 {
    get {return _storage._maxSessions}
    set {_uniqueStorage()._maxSessions = newValue}
  }

  /// RequestAccess defines the access request strategy (optional|note|always)
  /// where optional is the default.
  var requestAccess: String {
    get {return _storage._requestAccess}
    set {_uniqueStorage()._requestAccess = newValue}
  }

  /// RequestPrompt is an optional message which tells users what they aught to request.
  var requestPrompt: String {
    get {return _storage._requestPrompt}
    set {_uniqueStorage()._requestPrompt = newValue}
  }

  /// Lock specifies the locking mode (strict|best_effort) to be applied with
  /// the role.
  var lock: String {
    get {return _storage._lock}
    set {_uniqueStorage()._lock = newValue}
  }

  /// RecordDesktopSession indicates whether desktop access sessions should be recorded.
  /// It defaults to true unless explicitly set to false.
  var recordSession: Types_RecordSession {
    get {return _storage._recordSession ?? Types_RecordSession()}
    set {_uniqueStorage()._recordSession = newValue}
  }
  /// Returns true if `recordSession` has been explicitly set.
  var hasRecordSession: Bool {return _storage._recordSession != nil}
  /// Clears the value of `recordSession`. Subsequent reads from it will return its default value.
  mutating func clearRecordSession() {_uniqueStorage()._recordSession = nil}

  /// DesktopClipboard indicates whether clipboard sharing is allowed between the user's
  /// workstation and the remote desktop. It defaults to true unless explicitly set to
  /// false.
  var desktopClipboard: Types_BoolValue {
    get {return _storage._desktopClipboard ?? Types_BoolValue()}
    set {_uniqueStorage()._desktopClipboard = newValue}
  }
  /// Returns true if `desktopClipboard` has been explicitly set.
  var hasDesktopClipboard: Bool {return _storage._desktopClipboard != nil}
  /// Clears the value of `desktopClipboard`. Subsequent reads from it will return its default value.
  mutating func clearDesktopClipboard() {_uniqueStorage()._desktopClipboard = nil}

  /// CertExtensions specifies the key/values
  var certExtensions: [Types_CertExtension] {
    get {return _storage._certExtensions}
    set {_uniqueStorage()._certExtensions = newValue}
  }

  /// MaxKubernetesConnections defines the maximum number of concurrent
  /// Kubernetes sessions a user may hold.
  var maxKubernetesConnections: Int64 {
    get {return _storage._maxKubernetesConnections}
    set {_uniqueStorage()._maxKubernetesConnections = newValue}
  }

  /// DesktopDirectorySharing indicates whether directory sharing is allowed between the user's
  /// workstation and the remote desktop. It defaults to false unless explicitly set to
  /// true.
  var desktopDirectorySharing: Types_BoolValue {
    get {return _storage._desktopDirectorySharing ?? Types_BoolValue()}
    set {_uniqueStorage()._desktopDirectorySharing = newValue}
  }
  /// Returns true if `desktopDirectorySharing` has been explicitly set.
  var hasDesktopDirectorySharing: Bool {return _storage._desktopDirectorySharing != nil}
  /// Clears the value of `desktopDirectorySharing`. Subsequent reads from it will return its default value.
  mutating func clearDesktopDirectorySharing() {_uniqueStorage()._desktopDirectorySharing = nil}

  /// CreateHostUser allows users to be automatically created on a host
  var createHostUser: Types_BoolValue {
    get {return _storage._createHostUser ?? Types_BoolValue()}
    set {_uniqueStorage()._createHostUser = newValue}
  }
  /// Returns true if `createHostUser` has been explicitly set.
  var hasCreateHostUser: Bool {return _storage._createHostUser != nil}
  /// Clears the value of `createHostUser`. Subsequent reads from it will return its default value.
  mutating func clearCreateHostUser() {_uniqueStorage()._createHostUser = nil}

  /// PinSourceIP forces the same client IP for certificate generation and usage
  var pinSourceIp: Bool {
    get {return _storage._pinSourceIp}
    set {_uniqueStorage()._pinSourceIp = newValue}
  }

  /// SSHFileCopy indicates whether remote file operations via SCP or SFTP are allowed
  /// over an SSH session. It defaults to true unless explicitly set to false.
  var sshfileCopy: Types_BoolValue {
    get {return _storage._sshfileCopy ?? Types_BoolValue()}
    set {_uniqueStorage()._sshfileCopy = newValue}
  }
  /// Returns true if `sshfileCopy` has been explicitly set.
  var hasSshfileCopy: Bool {return _storage._sshfileCopy != nil}
  /// Clears the value of `sshfileCopy`. Subsequent reads from it will return its default value.
  mutating func clearSshfileCopy() {_uniqueStorage()._sshfileCopy = nil}

  /// RequireMFAType is the type of MFA requirement enforced for this user.
  var requireMfatype: Types_RequireMFAType {
    get {return _storage._requireMfatype}
    set {_uniqueStorage()._requireMfatype = newValue}
  }

  /// DeviceTrustMode is the device authorization mode used for the resources
  /// associated with the role.
  /// See DeviceTrust.Mode.
  /// Reserved for future use, not yet used by Teleport.
  var deviceTrustMode: String {
    get {return _storage._deviceTrustMode}
    set {_uniqueStorage()._deviceTrustMode = newValue}
  }

  /// IDP is a set of options related to accessing IdPs within Teleport.
  /// Requires Teleport Enterprise.
  var idp: Types_IdPOptions {
    get {return _storage._idp ?? Types_IdPOptions()}
    set {_uniqueStorage()._idp = newValue}
  }
  /// Returns true if `idp` has been explicitly set.
  var hasIdp: Bool {return _storage._idp != nil}
  /// Clears the value of `idp`. Subsequent reads from it will return its default value.
  mutating func clearIdp() {_uniqueStorage()._idp = nil}

  /// CreateDesktopUser allows users to be automatically created on a Windows desktop
  var createDesktopUser: Types_BoolValue {
    get {return _storage._createDesktopUser ?? Types_BoolValue()}
    set {_uniqueStorage()._createDesktopUser = newValue}
  }
  /// Returns true if `createDesktopUser` has been explicitly set.
  var hasCreateDesktopUser: Bool {return _storage._createDesktopUser != nil}
  /// Clears the value of `createDesktopUser`. Subsequent reads from it will return its default value.
  mutating func clearCreateDesktopUser() {_uniqueStorage()._createDesktopUser = nil}

  /// CreateDatabaseUser enabled automatic database user creation.
  var createDatabaseUser: Types_BoolValue {
    get {return _storage._createDatabaseUser ?? Types_BoolValue()}
    set {_uniqueStorage()._createDatabaseUser = newValue}
  }
  /// Returns true if `createDatabaseUser` has been explicitly set.
  var hasCreateDatabaseUser: Bool {return _storage._createDatabaseUser != nil}
  /// Clears the value of `createDatabaseUser`. Subsequent reads from it will return its default value.
  mutating func clearCreateDatabaseUser() {_uniqueStorage()._createDatabaseUser = nil}

  /// CreateHostUserMode allows users to be automatically created on a
  /// host when not set to off
  var createHostUserMode: Types_CreateHostUserMode {
    get {return _storage._createHostUserMode}
    set {_uniqueStorage()._createHostUserMode = newValue}
  }

  /// CreateDatabaseUserMode allows users to be automatically created on a
  /// database when not set to off.
  var createDatabaseUserMode: Types_CreateDatabaseUserMode {
    get {return _storage._createDatabaseUserMode}
    set {_uniqueStorage()._createDatabaseUserMode = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_RecordSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desktop indicates whether desktop sessions should be recorded.
  /// It defaults to true unless explicitly set to false.
  var desktop: Types_BoolValue {
    get {return _desktop ?? Types_BoolValue()}
    set {_desktop = newValue}
  }
  /// Returns true if `desktop` has been explicitly set.
  var hasDesktop: Bool {return self._desktop != nil}
  /// Clears the value of `desktop`. Subsequent reads from it will return its default value.
  mutating func clearDesktop() {self._desktop = nil}

  /// Default indicates the default value for the services.
  var `default`: String = String()

  /// SSH indicates the session mode used on SSH sessions.
  var ssh: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _desktop: Types_BoolValue? = nil
}

/// CertExtension represents a key/value for a certificate extension
struct Types_CertExtension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type represents the certificate type being extended, only ssh
  /// is supported at this time.
  var type: Types_CertExtensionType = .ssh

  /// Mode is the type of extension to be used -- currently
  /// critical-option is not supported
  var mode: Types_CertExtensionMode = .extension

  /// Name specifies the key to be used in the cert extension.
  var name: String = String()

  /// Value specifies the value to be used in the cert extension.
  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RoleConditions is a set of conditions that must all match to be allowed or
/// denied access.
struct Types_RoleConditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Logins is a list of *nix system logins.
  var logins: [String] {
    get {return _storage._logins}
    set {_uniqueStorage()._logins = newValue}
  }

  /// Namespaces is a list of namespaces (used to partition a cluster). The
  /// field should be called "namespaces" when it returns in Teleport 2.4.
  var namespaces: [String] {
    get {return _storage._namespaces}
    set {_uniqueStorage()._namespaces = newValue}
  }

  /// NodeLabels is a map of node labels (used to dynamically grant access to
  /// nodes).
  var nodeLabels: Wrappers_LabelValues {
    get {return _storage._nodeLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._nodeLabels = newValue}
  }
  /// Returns true if `nodeLabels` has been explicitly set.
  var hasNodeLabels: Bool {return _storage._nodeLabels != nil}
  /// Clears the value of `nodeLabels`. Subsequent reads from it will return its default value.
  mutating func clearNodeLabels() {_uniqueStorage()._nodeLabels = nil}

  /// Rules is a list of rules and their access levels. Rules are a high level
  /// construct used for access control.
  var rules: [Types_Rule] {
    get {return _storage._rules}
    set {_uniqueStorage()._rules = newValue}
  }

  /// KubeGroups is a list of kubernetes groups
  var kubeGroups: [String] {
    get {return _storage._kubeGroups}
    set {_uniqueStorage()._kubeGroups = newValue}
  }

  var request: Types_AccessRequestConditions {
    get {return _storage._request ?? Types_AccessRequestConditions()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  /// KubeUsers is an optional kubernetes users to impersonate
  var kubeUsers: [String] {
    get {return _storage._kubeUsers}
    set {_uniqueStorage()._kubeUsers = newValue}
  }

  /// AppLabels is a map of labels used as part of the RBAC system.
  var appLabels: Wrappers_LabelValues {
    get {return _storage._appLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._appLabels = newValue}
  }
  /// Returns true if `appLabels` has been explicitly set.
  var hasAppLabels: Bool {return _storage._appLabels != nil}
  /// Clears the value of `appLabels`. Subsequent reads from it will return its default value.
  mutating func clearAppLabels() {_uniqueStorage()._appLabels = nil}

  /// ClusterLabels is a map of node labels (used to dynamically grant access to
  /// clusters).
  var clusterLabels: Wrappers_LabelValues {
    get {return _storage._clusterLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._clusterLabels = newValue}
  }
  /// Returns true if `clusterLabels` has been explicitly set.
  var hasClusterLabels: Bool {return _storage._clusterLabels != nil}
  /// Clears the value of `clusterLabels`. Subsequent reads from it will return its default value.
  mutating func clearClusterLabels() {_uniqueStorage()._clusterLabels = nil}

  /// KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
  var kubernetesLabels: Wrappers_LabelValues {
    get {return _storage._kubernetesLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._kubernetesLabels = newValue}
  }
  /// Returns true if `kubernetesLabels` has been explicitly set.
  var hasKubernetesLabels: Bool {return _storage._kubernetesLabels != nil}
  /// Clears the value of `kubernetesLabels`. Subsequent reads from it will return its default value.
  mutating func clearKubernetesLabels() {_uniqueStorage()._kubernetesLabels = nil}

  /// DatabaseLabels are used in RBAC system to allow/deny access to databases.
  var databaseLabels: Wrappers_LabelValues {
    get {return _storage._databaseLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._databaseLabels = newValue}
  }
  /// Returns true if `databaseLabels` has been explicitly set.
  var hasDatabaseLabels: Bool {return _storage._databaseLabels != nil}
  /// Clears the value of `databaseLabels`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseLabels() {_uniqueStorage()._databaseLabels = nil}

  /// DatabaseNames is a list of database names this role is allowed to connect to.
  var databaseNames: [String] {
    get {return _storage._databaseNames}
    set {_uniqueStorage()._databaseNames = newValue}
  }

  /// DatabaseUsers is a list of databases users this role is allowed to connect as.
  var databaseUsers: [String] {
    get {return _storage._databaseUsers}
    set {_uniqueStorage()._databaseUsers = newValue}
  }

  /// Impersonate specifies what users and roles this role is allowed to impersonate
  /// by issuing certificates or other possible means.
  var impersonate: Types_ImpersonateConditions {
    get {return _storage._impersonate ?? Types_ImpersonateConditions()}
    set {_uniqueStorage()._impersonate = newValue}
  }
  /// Returns true if `impersonate` has been explicitly set.
  var hasImpersonate: Bool {return _storage._impersonate != nil}
  /// Clears the value of `impersonate`. Subsequent reads from it will return its default value.
  mutating func clearImpersonate() {_uniqueStorage()._impersonate = nil}

  /// ReviewRequests defines conditions for submitting access reviews.
  var reviewRequests: Types_AccessReviewConditions {
    get {return _storage._reviewRequests ?? Types_AccessReviewConditions()}
    set {_uniqueStorage()._reviewRequests = newValue}
  }
  /// Returns true if `reviewRequests` has been explicitly set.
  var hasReviewRequests: Bool {return _storage._reviewRequests != nil}
  /// Clears the value of `reviewRequests`. Subsequent reads from it will return its default value.
  mutating func clearReviewRequests() {_uniqueStorage()._reviewRequests = nil}

  /// AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
  var awsroleArns: [String] {
    get {return _storage._awsroleArns}
    set {_uniqueStorage()._awsroleArns = newValue}
  }

  /// WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
  var windowsDesktopLogins: [String] {
    get {return _storage._windowsDesktopLogins}
    set {_uniqueStorage()._windowsDesktopLogins = newValue}
  }

  /// WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
  var windowsDesktopLabels: Wrappers_LabelValues {
    get {return _storage._windowsDesktopLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._windowsDesktopLabels = newValue}
  }
  /// Returns true if `windowsDesktopLabels` has been explicitly set.
  var hasWindowsDesktopLabels: Bool {return _storage._windowsDesktopLabels != nil}
  /// Clears the value of `windowsDesktopLabels`. Subsequent reads from it will return its default value.
  mutating func clearWindowsDesktopLabels() {_uniqueStorage()._windowsDesktopLabels = nil}

  /// RequireSessionJoin specifies policies for required users to start a session.
  var requireSessionJoin: [Types_SessionRequirePolicy] {
    get {return _storage._requireSessionJoin}
    set {_uniqueStorage()._requireSessionJoin = newValue}
  }

  /// JoinSessions specifies policies to allow users to join other sessions.
  var joinSessions: [Types_SessionJoinPolicy] {
    get {return _storage._joinSessions}
    set {_uniqueStorage()._joinSessions = newValue}
  }

  /// HostGroups is a list of groups for created users to be added to
  var hostGroups: [String] {
    get {return _storage._hostGroups}
    set {_uniqueStorage()._hostGroups = newValue}
  }

  /// HostSudoers is a list of entries to include in a users sudoer file
  var hostSudoers: [String] {
    get {return _storage._hostSudoers}
    set {_uniqueStorage()._hostSudoers = newValue}
  }

  /// AzureIdentities is a list of Azure identities this role is allowed to assume.
  var azureIdentities: [String] {
    get {return _storage._azureIdentities}
    set {_uniqueStorage()._azureIdentities = newValue}
  }

  /// KubernetesResources is the Kubernetes Resources this Role grants access to.
  var kubernetesResources: [Types_KubernetesResource] {
    get {return _storage._kubernetesResources}
    set {_uniqueStorage()._kubernetesResources = newValue}
  }

  /// GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
  var gcpserviceAccounts: [String] {
    get {return _storage._gcpserviceAccounts}
    set {_uniqueStorage()._gcpserviceAccounts = newValue}
  }

  /// DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
  var databaseServiceLabels: Wrappers_LabelValues {
    get {return _storage._databaseServiceLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._databaseServiceLabels = newValue}
  }
  /// Returns true if `databaseServiceLabels` has been explicitly set.
  var hasDatabaseServiceLabels: Bool {return _storage._databaseServiceLabels != nil}
  /// Clears the value of `databaseServiceLabels`. Subsequent reads from it will return its default value.
  mutating func clearDatabaseServiceLabels() {_uniqueStorage()._databaseServiceLabels = nil}

  /// GroupLabels is a map of labels used as part of the RBAC system.
  var groupLabels: Wrappers_LabelValues {
    get {return _storage._groupLabels ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._groupLabels = newValue}
  }
  /// Returns true if `groupLabels` has been explicitly set.
  var hasGroupLabels: Bool {return _storage._groupLabels != nil}
  /// Clears the value of `groupLabels`. Subsequent reads from it will return its default value.
  mutating func clearGroupLabels() {_uniqueStorage()._groupLabels = nil}

  /// DesktopGroups is a list of groups for created desktop users to be added to
  var desktopGroups: [String] {
    get {return _storage._desktopGroups}
    set {_uniqueStorage()._desktopGroups = newValue}
  }

  /// DatabaseRoles is a list of databases roles for automatic user creation.
  var databaseRoles: [String] {
    get {return _storage._databaseRoles}
    set {_uniqueStorage()._databaseRoles = newValue}
  }

  /// NodeLabelsExpression is a predicate expression used to allow/deny access to
  /// SSH nodes.
  var nodeLabelsExpression: String {
    get {return _storage._nodeLabelsExpression}
    set {_uniqueStorage()._nodeLabelsExpression = newValue}
  }

  /// AppLabelsExpression is a predicate expression used to allow/deny access to
  /// Apps.
  var appLabelsExpression: String {
    get {return _storage._appLabelsExpression}
    set {_uniqueStorage()._appLabelsExpression = newValue}
  }

  /// ClusterLabelsExpression is a predicate expression used to allow/deny access
  /// to remote Teleport clusters.
  var clusterLabelsExpression: String {
    get {return _storage._clusterLabelsExpression}
    set {_uniqueStorage()._clusterLabelsExpression = newValue}
  }

  /// KubernetesLabelsExpression is a predicate expression used to allow/deny
  /// access to kubernetes clusters.
  var kubernetesLabelsExpression: String {
    get {return _storage._kubernetesLabelsExpression}
    set {_uniqueStorage()._kubernetesLabelsExpression = newValue}
  }

  /// DatabaseLabelsExpression is a predicate expression used to allow/deny
  /// access to Databases.
  var databaseLabelsExpression: String {
    get {return _storage._databaseLabelsExpression}
    set {_uniqueStorage()._databaseLabelsExpression = newValue}
  }

  /// DatabaseServiceLabelsExpression is a predicate expression used to
  /// allow/deny access to Database Services.
  var databaseServiceLabelsExpression: String {
    get {return _storage._databaseServiceLabelsExpression}
    set {_uniqueStorage()._databaseServiceLabelsExpression = newValue}
  }

  /// WindowsDesktopLabelsExpression is a predicate expression used to allow/deny
  /// access to Windows desktops.
  var windowsDesktopLabelsExpression: String {
    get {return _storage._windowsDesktopLabelsExpression}
    set {_uniqueStorage()._windowsDesktopLabelsExpression = newValue}
  }

  /// GroupLabelsExpression is a predicate expression used to allow/deny
  /// access to user groups.
  var groupLabelsExpression: String {
    get {return _storage._groupLabelsExpression}
    set {_uniqueStorage()._groupLabelsExpression = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// KubernetesResource is the Kubernetes resource identifier.
struct Types_KubernetesResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind specifies the Kubernetes Resource type.
  /// At the moment only "pod" is supported.
  var kind: String = String()

  /// Namespace is the resource namespace.
  /// It supports wildcards.
  var namespace: String = String()

  /// Name is the resource name.
  /// It supports wildcards.
  var name: String = String()

  /// Verbs are the allowed Kubernetes verbs for the following resource.
  var verbs: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionRequirePolicy a requirement policy that needs to be fulfilled to grant access.
struct Types_SessionRequirePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the policy.
  var name: String = String()

  /// Filter is a predicate that determines what users count towards this policy.
  var filter: String = String()

  /// Kinds are the session kinds this policy applies to.
  var kinds: [String] = []

  /// Count is the amount of people that need to be matched for this policy to be fulfilled.
  var count: Int32 = 0

  /// Modes is the list of modes that may be used to fulfill this policy.
  var modes: [String] = []

  /// OnLeave is the behaviour that's used when the policy is no longer fulfilled
  /// for a live session.
  var onLeave: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionJoinPolicy defines a policy that allows a user to join sessions.
struct Types_SessionJoinPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the policy.
  var name: String = String()

  /// Roles is a list of roles that you can join the session of.
  var roles: [String] = []

  /// Kinds are the session kinds this policy applies to.
  var kinds: [String] = []

  /// Modes is a list of permitted participant modes for this policy.
  var modes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestConditions is a matcher for allow/deny restrictions on
/// access-requests.
/// Please remember to update IsEmpty when updating this message.
struct Types_AccessRequestConditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roles is the name of roles which will match the request rule.
  var roles: [String] = []

  /// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
  var claimsToRoles: [Types_ClaimMapping] = []

  /// Annotations is a collection of annotations to be programmatically
  /// appended to pending access requests at the time of their creation.
  /// These annotations serve as a mechanism to propagate extra information
  /// to plugins.  Since these annotations support variable interpolation
  /// syntax, they also offer a mechanism for forwarding claims from an
  /// external identity provider, to a plugin via `{{external.trait_name}}`
  /// style substitutions.
  var annotations: Wrappers_LabelValues {
    get {return _annotations ?? Wrappers_LabelValues()}
    set {_annotations = newValue}
  }
  /// Returns true if `annotations` has been explicitly set.
  var hasAnnotations: Bool {return self._annotations != nil}
  /// Clears the value of `annotations`. Subsequent reads from it will return its default value.
  mutating func clearAnnotations() {self._annotations = nil}

  /// Thresholds is a list of thresholds, one of which must be met in order for reviews
  /// to trigger a state-transition.  If no thresholds are provided, a default threshold
  /// of 1 for approval and denial is used.
  var thresholds: [Types_AccessReviewThreshold] = []

  /// SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but
  /// that is not a requirement.
  var suggestedReviewers: [String] = []

  /// SearchAsRoles is a list of extra roles which should apply to a user while
  /// they are searching for resources as part of a Resource Access Request, and
  /// defines the underlying roles which will be requested as part of any
  /// Resource Access Request.
  var searchAsRoles: [String] = []

  /// MaxDuration is the amount of time the access will be granted for.
  /// If this is zero, the default duration is used.
  var maxDuration: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _annotations: Wrappers_LabelValues? = nil
}

/// AccessReviewConditions is a matcher for allow/deny restrictions on
/// access reviews.
/// Please remember to update IsEmpty when updating this message.
struct Types_AccessReviewConditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Roles is the name of roles which may be reviewed.
  var roles: [String] = []

  /// ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
  var claimsToRoles: [Types_ClaimMapping] = []

  /// Where is an optional predicate which further limits which requests are
  /// reviewable.
  var `where`: String = String()

  /// PreviewAsRoles is a list of extra roles which should apply to a reviewer
  /// while they are viewing a Resource Access Request for the purposes of
  /// viewing details such as the hostname and labels of requested resources.
  var previewAsRoles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestAllowedPromotion describes an allowed promotion to an access list.
struct Types_AccessRequestAllowedPromotion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// associated access list
  var accessListName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessRequestAllowedPromotions describes an valid promotion from an access request
/// to an access list.
struct Types_AccessRequestAllowedPromotions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// suggestions is a list of allowed access lists promotions.
  var promotions: [Types_AccessRequestAllowedPromotion] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClaimMapping maps a claim to teleport roles.
struct Types_ClaimMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Claim is a claim name.
  var claim: String = String()

  /// Value is a claim value to match.
  var value: String = String()

  /// Roles is a list of static teleport roles to match.
  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TraitMapping maps a trait to teleport roles.
struct Types_TraitMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trait is a trait name.
  var trait: String = String()

  /// Value is a trait value to match.
  var value: String = String()

  /// Roles is a list of static teleport roles to match.
  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Rule represents allow or deny rule that is executed to check
/// if user or service have access to resource
struct Types_Rule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resources is a list of resources
  var resources: [String] = []

  /// Verbs is a list of verbs
  var verbs: [String] = []

  /// Where specifies optional advanced matcher
  var `where`: String = String()

  /// Actions specifies optional actions taken when this rule matches
  var actions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ImpersonateConditions specifies whether users are allowed
/// to issue certificates for other users or groups.
struct Types_ImpersonateConditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Users is a list of resources this role is allowed to impersonate,
  /// could be an empty list or a Wildcard pattern
  var users: [String] = []

  /// Roles is a list of resources this role is allowed to impersonate
  var roles: [String] = []

  /// Where specifies optional advanced matcher
  var `where`: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BoolValue is a wrapper around bool, used in cases
/// whenever bool value can have different default value when missing
struct Types_BoolValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserV2 is version 2 resource spec of the user
struct Types_UserV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a user specification
  var spec: Types_UserSpecV2 {
    get {return _spec ?? Types_UserSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_UserSpecV2? = nil
}

/// UserSpecV2 is a specification for V2 user
struct Types_UserSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OIDCIdentities lists associated OpenID Connect identities
  /// that let user log in using externally verified identity
  var oidcidentities: [Types_ExternalIdentity] {
    get {return _storage._oidcidentities}
    set {_uniqueStorage()._oidcidentities = newValue}
  }

  /// SAMLIdentities lists associated SAML identities
  /// that let user log in using externally verified identity
  var samlidentities: [Types_ExternalIdentity] {
    get {return _storage._samlidentities}
    set {_uniqueStorage()._samlidentities = newValue}
  }

  /// GithubIdentities list associated Github OAuth2 identities
  /// that let user log in using externally verified identity
  var githubIdentities: [Types_ExternalIdentity] {
    get {return _storage._githubIdentities}
    set {_uniqueStorage()._githubIdentities = newValue}
  }

  /// Roles is a list of roles assigned to user
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  /// Traits are key/value pairs received from an identity provider (through
  /// OIDC claims or SAML assertions) or from a system administrator for local
  /// accounts. Traits are used to populate role variables.
  var traits: Wrappers_LabelValues {
    get {return _storage._traits ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._traits = newValue}
  }
  /// Returns true if `traits` has been explicitly set.
  var hasTraits: Bool {return _storage._traits != nil}
  /// Clears the value of `traits`. Subsequent reads from it will return its default value.
  mutating func clearTraits() {_uniqueStorage()._traits = nil}

  /// Status is a login status of the user
  var status: Types_LoginStatus {
    get {return _storage._status ?? Types_LoginStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Expires if set sets TTL on the user
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  /// CreatedBy holds information about agent or person created this user
  var createdBy: Types_CreatedBy {
    get {return _storage._createdBy ?? Types_CreatedBy()}
    set {_uniqueStorage()._createdBy = newValue}
  }
  /// Returns true if `createdBy` has been explicitly set.
  var hasCreatedBy: Bool {return _storage._createdBy != nil}
  /// Clears the value of `createdBy`. Subsequent reads from it will return its default value.
  mutating func clearCreatedBy() {_uniqueStorage()._createdBy = nil}

  /// LocalAuth holds sensitive data necessary for performing local
  /// authentication
  var localAuth: Types_LocalAuthSecrets {
    get {return _storage._localAuth ?? Types_LocalAuthSecrets()}
    set {_uniqueStorage()._localAuth = newValue}
  }
  /// Returns true if `localAuth` has been explicitly set.
  var hasLocalAuth: Bool {return _storage._localAuth != nil}
  /// Clears the value of `localAuth`. Subsequent reads from it will return its default value.
  mutating func clearLocalAuth() {_uniqueStorage()._localAuth = nil}

  /// TrustedDeviceIDs contains the IDs of trusted devices enrolled by the user.
  /// Managed by the Device Trust subsystem, avoid manual edits.
  var trustedDeviceIds: [String] {
    get {return _storage._trustedDeviceIds}
    set {_uniqueStorage()._trustedDeviceIds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ExternalIdentity is OpenID Connect/SAML or Github identity that is linked
/// to particular user and connector and lets user to log in using external
/// credentials, e.g. google
struct Types_ExternalIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
  var connectorID: String = String()

  /// Username is username supplied by external identity provider
  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LoginStatus is a login status of the user
struct Types_LoginStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IsLocked tells us if user is locked
  var isLocked: Bool = false

  /// LockedMessage contains the message in case if user is locked
  var lockedMessage: String = String()

  /// LockedTime contains time when user was locked
  var lockedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lockedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lockedTime = newValue}
  }
  /// Returns true if `lockedTime` has been explicitly set.
  var hasLockedTime: Bool {return self._lockedTime != nil}
  /// Clears the value of `lockedTime`. Subsequent reads from it will return its default value.
  mutating func clearLockedTime() {self._lockedTime = nil}

  /// LockExpires contains time when this lock will expire
  var lockExpires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lockExpires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lockExpires = newValue}
  }
  /// Returns true if `lockExpires` has been explicitly set.
  var hasLockExpires: Bool {return self._lockExpires != nil}
  /// Clears the value of `lockExpires`. Subsequent reads from it will return its default value.
  mutating func clearLockExpires() {self._lockExpires = nil}

  /// RecoveryAttemptLockExpires contains the time when this lock will expire
  /// from reaching MaxAccountRecoveryAttempts. This field is used to determine
  /// if a user got locked from recovery attempts.
  var recoveryAttemptLockExpires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _recoveryAttemptLockExpires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_recoveryAttemptLockExpires = newValue}
  }
  /// Returns true if `recoveryAttemptLockExpires` has been explicitly set.
  var hasRecoveryAttemptLockExpires: Bool {return self._recoveryAttemptLockExpires != nil}
  /// Clears the value of `recoveryAttemptLockExpires`. Subsequent reads from it will return its default value.
  mutating func clearRecoveryAttemptLockExpires() {self._recoveryAttemptLockExpires = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lockedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lockExpires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _recoveryAttemptLockExpires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// CreatedBy holds information about the person or agent who created the user
struct Types_CreatedBy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identity if present means that user was automatically created by identity
  var connector: Types_ConnectorRef {
    get {return _connector ?? Types_ConnectorRef()}
    set {_connector = newValue}
  }
  /// Returns true if `connector` has been explicitly set.
  var hasConnector: Bool {return self._connector != nil}
  /// Clears the value of `connector`. Subsequent reads from it will return its default value.
  mutating func clearConnector() {self._connector = nil}

  /// Time specifies when user was created
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// User holds information about user
  var user: Types_UserRef {
    get {return _user ?? Types_UserRef()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connector: Types_ConnectorRef? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _user: Types_UserRef? = nil
}

/// LocalAuthSecrets holds sensitive data used to authenticate a local user.
struct Types_LocalAuthSecrets {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PasswordHash encodes a combined salt & hash for password verification.
  var passwordHash: Data = Data()

  /// Deprecated 2nd factor fields, use MFA below instead.
  var totpkey: String = String()

  var mfa: [Types_MFADevice] = []

  /// Webauthn holds settings necessary for webauthn local auth.
  /// May be null for legacy users or users that haven't yet used webauthn as
  /// their second factor.
  var webauthn: Types_WebauthnLocalAuth {
    get {return _webauthn ?? Types_WebauthnLocalAuth()}
    set {_webauthn = newValue}
  }
  /// Returns true if `webauthn` has been explicitly set.
  var hasWebauthn: Bool {return self._webauthn != nil}
  /// Clears the value of `webauthn`. Subsequent reads from it will return its default value.
  mutating func clearWebauthn() {self._webauthn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _webauthn: Types_WebauthnLocalAuth? = nil
}

/// MFADevice is a multi-factor authentication device, such as a security key or
/// an OTP app.
struct Types_MFADevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Boilerplate for implementing the Resource interface.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ID is a UUID of this device.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var addedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._addedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._addedAt = newValue}
  }
  /// Returns true if `addedAt` has been explicitly set.
  var hasAddedAt: Bool {return _storage._addedAt != nil}
  /// Clears the value of `addedAt`. Subsequent reads from it will return its default value.
  mutating func clearAddedAt() {_uniqueStorage()._addedAt = nil}

  var lastUsed: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastUsed ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastUsed = newValue}
  }
  /// Returns true if `lastUsed` has been explicitly set.
  var hasLastUsed: Bool {return _storage._lastUsed != nil}
  /// Clears the value of `lastUsed`. Subsequent reads from it will return its default value.
  mutating func clearLastUsed() {_uniqueStorage()._lastUsed = nil}

  var device: OneOf_Device? {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  var totp: Types_TOTPDevice {
    get {
      if case .totp(let v)? = _storage._device {return v}
      return Types_TOTPDevice()
    }
    set {_uniqueStorage()._device = .totp(newValue)}
  }

  var u2F: Types_U2FDevice {
    get {
      if case .u2F(let v)? = _storage._device {return v}
      return Types_U2FDevice()
    }
    set {_uniqueStorage()._device = .u2F(newValue)}
  }

  var webauthn: Types_WebauthnDevice {
    get {
      if case .webauthn(let v)? = _storage._device {return v}
      return Types_WebauthnDevice()
    }
    set {_uniqueStorage()._device = .webauthn(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Device: Equatable {
    case totp(Types_TOTPDevice)
    case u2F(Types_U2FDevice)
    case webauthn(Types_WebauthnDevice)

  #if !swift(>=4.1)
    static func ==(lhs: Types_MFADevice.OneOf_Device, rhs: Types_MFADevice.OneOf_Device) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.totp, .totp): return {
        guard case .totp(let l) = lhs, case .totp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.u2F, .u2F): return {
        guard case .u2F(let l) = lhs, case .u2F(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webauthn, .webauthn): return {
        guard case .webauthn(let l) = lhs, case .webauthn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TOTPDevice holds the TOTP-specific fields of MFADevice.
struct Types_TOTPDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// U2FDevice holds the U2F-specific fields of MFADevice.
struct Types_U2FDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KeyHandle uniquely identifies a key on a device
  var keyHandle: Data = Data()

  /// PubKey is an DER encoded ecdsa public key
  var pubKey: Data = Data()

  /// Counter is the latest seen value of the U2F usage counter.
  var counter: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WebauthnDevice holds Webauthn-specific fields of MFADevice.
struct Types_WebauthnDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Credential ID for the authenticator.
  var credentialID: Data = Data()

  /// Public key encoded in CBOR format.
  /// Webauthn support various key algorithms; CBOR encoding is used to reflect
  /// those choices.
  /// See https://w3c.github.io/webauthn/#sctn-alg-identifier for a starter
  /// reference.
  var publicKeyCbor: Data = Data()

  /// Attestation format used by the authenticator, if any.
  var attestationType: String = String()

  /// AAGUID is the globally unique identifier of the authenticator model.
  /// Zeroed for U2F devices.
  var aaguid: Data = Data()

  /// Signature counter for login operations.
  /// Actual counter values received from the authenticator are expected to be
  /// higher than the previously-stored value.
  var signatureCounter: UInt32 = 0

  /// Raw attestation object, as returned by the authentication during
  /// registration.
  /// Absent for legacy entries (Teleport 8.x).
  var attestationObject: Data = Data()

  /// True if a resident key was requested during registration.
  /// Marks passwordless-capable devices.
  /// (Note that resident_key=true represents the server-side / Relying Party
  /// view of the registration process; the authenticator alone can determine
  /// if a key is truly resident.)
  var residentKey: Bool = false

  /// Relying Party ID used by the credential.
  /// Recorded on registration for new credentials, or on first successful
  /// authentication for "old" credentials (created before the field existed).
  /// Ideally, this is always the same as the configured RPID.
  /// If an RPID change does happen, this helps Teleport detect it and react
  /// accordingly.
  var credentialRpID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WebauthnLocalAuth holds settings necessary for local webauthn use.
struct Types_WebauthnLocalAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserID is the random user handle generated for the user.
  /// See https://www.w3.org/TR/webauthn-2/#sctn-user-handle-privacy.
  var userID: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ConnectorRef holds information about OIDC connector
struct Types_ConnectorRef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is connector type
  var type: String = String()

  /// ID is connector ID
  var id: String = String()

  /// Identity is external identity of the user
  var identity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserRef holds references to user
struct Types_UserRef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is name of the user
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ReverseTunnelV2 is version 2 of the resource spec of the reverse tunnel
struct Types_ReverseTunnelV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is a resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a reverse tunnel specification
  var spec: Types_ReverseTunnelSpecV2 {
    get {return _spec ?? Types_ReverseTunnelSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_ReverseTunnelSpecV2? = nil
}

/// ReverseTunnelSpecV2 is a specification for V2 reverse tunnel
struct Types_ReverseTunnelSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName is a domain name of remote cluster we are connecting to
  var clusterName: String = String()

  /// DialAddrs is a list of remote address to establish a connection to
  /// it's always SSH over TCP
  var dialAddrs: [String] = []

  /// Type is the type of reverse tunnel, either proxy or node.
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TunnelConnectionV2 is version 2 of the resource spec of the tunnel connection
struct Types_TunnelConnectionV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is a resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a tunnel specification
  var spec: Types_TunnelConnectionSpecV2 {
    get {return _spec ?? Types_TunnelConnectionSpecV2()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_TunnelConnectionSpecV2? = nil
}

/// TunnelConnectionSpecV2 is a specification for V2 tunnel connection
struct Types_TunnelConnectionSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClusterName is a name of the cluster
  var clusterName: String = String()

  /// ProxyName is the name of the proxy server
  var proxyName: String = String()

  /// LastHeartbeat is a time of the last heartbeat
  var lastHeartbeat: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastHeartbeat ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastHeartbeat = newValue}
  }
  /// Returns true if `lastHeartbeat` has been explicitly set.
  var hasLastHeartbeat: Bool {return self._lastHeartbeat != nil}
  /// Clears the value of `lastHeartbeat`. Subsequent reads from it will return its default value.
  mutating func clearLastHeartbeat() {self._lastHeartbeat = nil}

  /// Type is the type of reverse tunnel, either proxy or node.
  var type: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastHeartbeat: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// SemaphoreFilter encodes semaphore filtering params.
/// A semaphore filter matches a semaphore if all nonzero fields
/// match the corresponding semaphore fields (e.g. a filter which
/// specifies only `kind=foo` would match all semaphores of
/// kind `foo`).
struct Types_SemaphoreFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SemaphoreKind is the kind of the semaphore.
  var semaphoreKind: String = String()

  /// SemaphoreName is the name of the semaphore.
  var semaphoreName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AcquireSemaphoreRequest holds semaphore lease acquisition parameters.
struct Types_AcquireSemaphoreRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SemaphoreKind is the kind of the semaphore.
  var semaphoreKind: String = String()

  /// SemaphoreName is the name of the semaphore.
  var semaphoreName: String = String()

  /// MaxLeases is the maximum number of concurrent leases.  If acquisition
  /// would cause more than MaxLeases to exist, acquisition must fail.
  var maxLeases: Int64 = 0

  /// Expires is the time at which this lease expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// Holder identifies the entity holding the lease.
  var holder: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// SemaphoreLease represents lease acquired for semaphore
struct Types_SemaphoreLease {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SemaphoreKind is the kind of the semaphore.
  var semaphoreKind: String = String()

  /// SemaphoreName is the name of the semaphore.
  var semaphoreName: String = String()

  /// LeaseID uniquely identifies this lease.
  var leaseID: String = String()

  /// Expires is the time at which this lease expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// SemaphoreLeaseRef identifies an existent lease.
struct Types_SemaphoreLeaseRef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// LeaseID is the unique ID of the lease.
  var leaseID: String = String()

  /// Expires is the time at which the lease expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// Holder identifies the lease holder.
  var holder: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// SemaphoreV3 implements Semaphore interface
struct Types_SemaphoreV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is Semaphore metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is a lease V3 spec
  var spec: Types_SemaphoreSpecV3 {
    get {return _spec ?? Types_SemaphoreSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_SemaphoreSpecV3? = nil
}

/// SemaphoreSpecV3 contains the data about lease
struct Types_SemaphoreSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Leases is a list of all currently acquired leases.
  var leases: [Types_SemaphoreLeaseRef] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WebSessionV2 represents an application or UI web session.
struct Types_WebSessionV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata is a resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is a tunnel specification.
  var spec: Types_WebSessionSpecV2 {
    get {return _storage._spec ?? Types_WebSessionSpecV2()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WebSessionSpecV2 is a specification for web session.
struct Types_WebSessionSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is the identity of the user to which the web session belongs.
  var user: String = String()

  /// Pub is the SSH certificate for the user.
  var pub: Data = Data()

  /// Priv is the SSH private key for the user.
  var priv: Data = Data()

  /// TLSCert is the TLS certificate for the user.
  var tlscert: Data = Data()

  /// BearerToken is a token that is paired with the session cookie for
  /// authentication. It is periodically rotated so a stolen cookie itself
  /// is not enough to steal a session. In addition it is used for CSRF
  /// mitigation.
  var bearerToken: String = String()

  /// BearerTokenExpires is the absolute time when the token expires.
  var bearerTokenExpires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _bearerTokenExpires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_bearerTokenExpires = newValue}
  }
  /// Returns true if `bearerTokenExpires` has been explicitly set.
  var hasBearerTokenExpires: Bool {return self._bearerTokenExpires != nil}
  /// Clears the value of `bearerTokenExpires`. Subsequent reads from it will return its default value.
  mutating func clearBearerTokenExpires() {self._bearerTokenExpires = nil}

  /// Expires is the absolute time when the session expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// LoginTime is the time this user recently logged in.
  var loginTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _loginTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_loginTime = newValue}
  }
  /// Returns true if `loginTime` has been explicitly set.
  var hasLoginTime: Bool {return self._loginTime != nil}
  /// Clears the value of `loginTime`. Subsequent reads from it will return its default value.
  mutating func clearLoginTime() {self._loginTime = nil}

  /// IdleTimeout is the max time a user can be inactive in a session.
  var idleTimeout: Int64 = 0

  /// ConsumedAccessRequestID is the ID of the access request from which additional roles to assume
  /// were obtained.
  var consumedAccessRequestID: String = String()

  /// SAMLSession is data associated with a SAML IdP session.
  var samlsession: Types_SAMLSessionData {
    get {return _samlsession ?? Types_SAMLSessionData()}
    set {_samlsession = newValue}
  }
  /// Returns true if `samlsession` has been explicitly set.
  var hasSamlsession: Bool {return self._samlsession != nil}
  /// Clears the value of `samlsession`. Subsequent reads from it will return its default value.
  mutating func clearSamlsession() {self._samlsession = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bearerTokenExpires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _loginTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _samlsession: Types_SAMLSessionData? = nil
}

/// WebSessionFilter encodes cache watch parameters for filtering web sessions.
struct Types_WebSessionFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is the username to filter web sessions for.
  var user: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SAMLSessionData contains data for a SAML session.
/// Based on crewjam/saml's session object: https://github.com/crewjam/saml/blob/main/identity_provider.go
struct Types_SAMLSessionData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is the identifier for the SAML session.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// CreateTime is the time that the session was created.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// ExpireTime is the time that the session will expire.
  var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  var hasExpireTime: Bool {return _storage._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  mutating func clearExpireTime() {_uniqueStorage()._expireTime = nil}

  /// Index is the session index that allows the IdP to uniquely identify a session.
  var index: String {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  /// NameID an identifier for the session.
  var nameID: String {
    get {return _storage._nameID}
    set {_uniqueStorage()._nameID = newValue}
  }

  /// NameIDFormat is the format of the Name ID.
  var nameIdformat: String {
    get {return _storage._nameIdformat}
    set {_uniqueStorage()._nameIdformat = newValue}
  }

  /// SubjectID is the identifier for the subject of the session.
  var subjectID: String {
    get {return _storage._subjectID}
    set {_uniqueStorage()._subjectID = newValue}
  }

  /// Groups is a list of groups that the user has access to.
  var groups: [String] {
    get {return _storage._groups}
    set {_uniqueStorage()._groups = newValue}
  }

  /// UserName is the user's name.
  var userName: String {
    get {return _storage._userName}
    set {_uniqueStorage()._userName = newValue}
  }

  /// UserEmail is the user's e-mail.
  var userEmail: String {
    get {return _storage._userEmail}
    set {_uniqueStorage()._userEmail = newValue}
  }

  /// UserCommonName is the user's common name.
  var userCommonName: String {
    get {return _storage._userCommonName}
    set {_uniqueStorage()._userCommonName = newValue}
  }

  /// UserSurname is the user's surname.
  var userSurname: String {
    get {return _storage._userSurname}
    set {_uniqueStorage()._userSurname = newValue}
  }

  /// UserGivenName is the user's given name.
  var userGivenName: String {
    get {return _storage._userGivenName}
    set {_uniqueStorage()._userGivenName = newValue}
  }

  /// UserScopedAffiliation is the user's scoped affiliation.
  var userScopedAffiliation: String {
    get {return _storage._userScopedAffiliation}
    set {_uniqueStorage()._userScopedAffiliation = newValue}
  }

  /// CustomAttributes are any custom attributes associated with the request.
  var customAttributes: [Types_SAMLAttribute] {
    get {return _storage._customAttributes}
    set {_uniqueStorage()._customAttributes = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLAttribute contains an attribute name and associated values.
/// Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
struct Types_SAMLAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// FriendlyName is a user readable name for the attribute.
  var friendlyName: String = String()

  /// Name is a full name for the attribute, typically an OID value.
  var name: String = String()

  /// NameFormat is the format of the name.
  var nameFormat: String = String()

  /// Values is a list of attribute values.
  var values: [Types_SAMLAttributeValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SAMLAttributeValues contains a type, value, and an associated name ID block.
/// Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
struct Types_SAMLAttributeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is the type of value this attribute represents.
  var type: String = String()

  /// Value is the value of the attribute.
  var value: String = String()

  /// NameID is a more restrictive identifier for the attribute value.
  var nameID: Types_SAMLNameID {
    get {return _nameID ?? Types_SAMLNameID()}
    set {_nameID = newValue}
  }
  /// Returns true if `nameID` has been explicitly set.
  var hasNameID: Bool {return self._nameID != nil}
  /// Clears the value of `nameID`. Subsequent reads from it will return its default value.
  mutating func clearNameID() {self._nameID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nameID: Types_SAMLNameID? = nil
}

/// SAMLNameID is a more restrictive identifier for an object in SAML.
/// Defined in http://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf.
struct Types_SAMLNameID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NameQualifier is the domain that qualifies the identifier.
  var nameQualifier: String = String()

  /// SPNameQualifier qualifies the identifier with the name of the service provider.
  var spnameQualifier: String = String()

  /// Format is the format of the identifier.
  var format: String = String()

  /// SPProvidedID is an identifier established by the service provider.
  var spprovidedID: String = String()

  /// Value is the value of the name ID.
  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RemoteClusterV3 represents remote cluster resource specification
struct Types_RemoteClusterV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is resource API version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Status is a remote cluster status
  var status: Types_RemoteClusterStatusV3 {
    get {return _status ?? Types_RemoteClusterStatusV3()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _status: Types_RemoteClusterStatusV3? = nil
}

/// RemoteClusterStatusV3 represents status of the remote cluster
struct Types_RemoteClusterStatusV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Connection represents connection status, online or offline
  var connection: String = String()

  /// LastHeartbeat records last heartbeat of the cluster
  var lastHeartbeat: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastHeartbeat ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastHeartbeat = newValue}
  }
  /// Returns true if `lastHeartbeat` has been explicitly set.
  var hasLastHeartbeat: Bool {return self._lastHeartbeat != nil}
  /// Clears the value of `lastHeartbeat`. Subsequent reads from it will return its default value.
  mutating func clearLastHeartbeat() {self._lastHeartbeat = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastHeartbeat: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// KubernetesCluster is a named kubernetes API endpoint handled by a Server.
///
/// TODO: deprecate and convert all usage to KubernetesClusterV3
struct Types_KubernetesCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of this kubernetes cluster.
  var name: String = String()

  /// StaticLabels is map of static labels associated with this cluster.
  /// Used for RBAC.
  var staticLabels: Dictionary<String,String> = [:]

  /// DynamicLabels is map of dynamic labels associated with this cluster.
  /// Used for RBAC.
  var dynamicLabels: Dictionary<String,Types_CommandLabelV2> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubernetesClusterV3 represents a named kubernetes API endpoint.
struct Types_KubernetesClusterV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the cluster resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource subkind.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is the resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata is the resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is the resource spec.
  var spec: Types_KubernetesClusterSpecV3 {
    get {return _storage._spec ?? Types_KubernetesClusterSpecV3()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// KubernetesClusterSpecV3 is a specification for a Kubernetes cluster.
struct Types_KubernetesClusterSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DynamicLabels are the cluster's dynamic labels.
  var dynamicLabels: Dictionary<String,Types_CommandLabelV2> = [:]

  /// Kubeconfig is the kubeconfig file payload that grants access to the cluster.
  /// If multiple contexts are specified, the first will be selected.
  var kubeconfig: Data = Data()

  /// Azure holds the required Azure information for Teleport to access the cluster.
  var azure: Types_KubeAzure {
    get {return _azure ?? Types_KubeAzure()}
    set {_azure = newValue}
  }
  /// Returns true if `azure` has been explicitly set.
  var hasAzure: Bool {return self._azure != nil}
  /// Clears the value of `azure`. Subsequent reads from it will return its default value.
  mutating func clearAzure() {self._azure = nil}

  /// AWS holds the required AWS information for Teleport to access the cluster.
  var aws: Types_KubeAWS {
    get {return _aws ?? Types_KubeAWS()}
    set {_aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return self._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {self._aws = nil}

  /// GCP holds the required GCP information for Teleport to access the cluster.
  var gcp: Types_KubeGCP {
    get {return _gcp ?? Types_KubeGCP()}
    set {_gcp = newValue}
  }
  /// Returns true if `gcp` has been explicitly set.
  var hasGcp: Bool {return self._gcp != nil}
  /// Clears the value of `gcp`. Subsequent reads from it will return its default value.
  mutating func clearGcp() {self._gcp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _azure: Types_KubeAzure? = nil
  fileprivate var _aws: Types_KubeAWS? = nil
  fileprivate var _gcp: Types_KubeGCP? = nil
}

/// KubeAzure contains the Azure information about the cluster.
struct Types_KubeAzure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ResourceName is the AKS cluster name.
  var resourceName: String = String()

  /// ResourceGroup is the Azure resource group name.
  var resourceGroup: String = String()

  /// TenantID is the AKS cluster Tenant ID.
  var tenantID: String = String()

  /// SubscriptionID is the AKS cluster SubscriptionID.
  var subscriptionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubeAWS contains the AWS information about the cluster.
struct Types_KubeAWS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Region is a AWS cloud region.
  var region: String = String()

  /// AccountID is a AWS Account ID.
  var accountID: String = String()

  /// Name is a AWS EKS cluster name.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubeGCP contains the GCP information about the cluster.
struct Types_KubeGCP {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location is a GKE cluster location.
  var location: String = String()

  /// ProjectID is the GKE Project ID.
  var projectID: String = String()

  /// Name is a GCP GKE cluster name.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubernetesClusterV3List represents a list of kubernetes clusters.
struct Types_KubernetesClusterV3List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KubernetesClusters is a list of kubernetes clusters resources.
  var kubernetesClusters: [Types_KubernetesClusterV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// KubernetesServerV3 represents a Kubernetes server.
struct Types_KubernetesServerV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the Kubernetes server resource kind. Always "kube_server".
  var kind: String = String()

  /// SubKind is an optional resource subkind.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the Kubernetes server metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is the Kubernetes server spec.
  var spec: Types_KubernetesServerSpecV3 {
    get {return _spec ?? Types_KubernetesServerSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_KubernetesServerSpecV3? = nil
}

/// KubernetesServerSpecV3 is the Kubernetes server spec.
struct Types_KubernetesServerSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version is the Teleport version that the server is running.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Hostname is the Kubernetes server hostname.
  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  /// HostID is the Kubernetes server host uuid.
  var hostID: String {
    get {return _storage._hostID}
    set {_uniqueStorage()._hostID = newValue}
  }

  /// Rotation contains the Kubernetes server CA rotation information.
  var rotation: Types_Rotation {
    get {return _storage._rotation ?? Types_Rotation()}
    set {_uniqueStorage()._rotation = newValue}
  }
  /// Returns true if `rotation` has been explicitly set.
  var hasRotation: Bool {return _storage._rotation != nil}
  /// Clears the value of `rotation`. Subsequent reads from it will return its default value.
  mutating func clearRotation() {_uniqueStorage()._rotation = nil}

  /// Cluster is a Kubernetes Cluster proxied by this Kubernetes server.
  var cluster: Types_KubernetesClusterV3 {
    get {return _storage._cluster ?? Types_KubernetesClusterV3()}
    set {_uniqueStorage()._cluster = newValue}
  }
  /// Returns true if `cluster` has been explicitly set.
  var hasCluster: Bool {return _storage._cluster != nil}
  /// Clears the value of `cluster`. Subsequent reads from it will return its default value.
  mutating func clearCluster() {_uniqueStorage()._cluster = nil}

  /// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
  var proxyIds: [String] {
    get {return _storage._proxyIds}
    set {_uniqueStorage()._proxyIds = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WebTokenV3 describes a web token. Web tokens are used as a transport to relay bearer tokens
/// to the client.
/// Initially bound to a web session, these have been factored out into a separate resource to
/// enable separate lifecycle management.
struct Types_WebTokenV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind
  var subKind: String = String()

  /// Version is the resource version
  var version: String = String()

  /// Metadata is resource metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec defines the web token
  var spec: Types_WebTokenSpecV3 {
    get {return _spec ?? Types_WebTokenSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_WebTokenSpecV3? = nil
}

/// WebTokenSpecV3 is a unique time-limited token bound to a user's web session
struct Types_WebTokenSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User specifies the user the token is bound to.
  var user: String = String()

  /// Token specifies the token's value.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWebSessionRequest describes a request to query a web session
struct Types_GetWebSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User specifies the user the web session is for.
  var user: String = String()

  /// SessionID specifies the web session ID.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteWebSessionRequest describes a request to delete a web session
struct Types_DeleteWebSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User specifies the user the session is bound to
  var user: String = String()

  /// SessionID specifies the web session ID to delete.
  var sessionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetWebTokenRequest describes a request to query a web token
struct Types_GetWebTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User specifies the user the token is for.
  var user: String = String()

  /// Token specifies the token to get.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DeleteWebTokenRequest describes a request to delete a web token
struct Types_DeleteWebTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User specifies the user the token is for.
  var user: String = String()

  /// Token specifies the token to delete.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResourceRequest is a request relating to a named resource.
struct Types_ResourceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the resource.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResourceWithSecretsRequest is a request relating to a named resource with secrets.
struct Types_ResourceWithSecretsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the resource.
  var name: String = String()

  /// WithSecrets specifies whether to load associated secrets.
  var withSecrets: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResourcesWithSecretsRequest is a request relating to resources with secrets.
struct Types_ResourcesWithSecretsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// WithSecrets specifies whether to load associated secrets.
  var withSecrets: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResourcesInNamespaceRequest is a request relating to a named resource in the given namespace.
struct Types_ResourceInNamespaceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of the resource.
  var name: String = String()

  /// Namespace is the namespace of resources.
  var namespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ResourcesInNamespaceRequest is a request relating to resources in the given namespace.
struct Types_ResourcesInNamespaceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace is the namespace of resources.
  var namespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OIDCConnectorV3 represents an OIDC connector.
struct Types_OIDCConnectorV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is a resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata holds resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is an OIDC connector specification.
  var spec: Types_OIDCConnectorSpecV3 {
    get {return _storage._spec ?? Types_OIDCConnectorSpecV3()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OIDCConnectorV3List is a list of OIDC connectors.
struct Types_OIDCConnectorV3List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OIDCConnectors is a list of OIDC connectors.
  var oidcconnectors: [Types_OIDCConnectorV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OIDCConnectorSpecV3 is an OIDC connector specification.
///
/// It specifies configuration for Open ID Connect compatible external
/// identity provider: https://openid.net/specs/openid-connect-core-1_0.html
struct Types_OIDCConnectorSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
  var issuerURL: String = String()

  /// ClientID is the id of the authentication client (Teleport Auth server).
  var clientID: String = String()

  /// ClientSecret is used to authenticate the client.
  var clientSecret: String = String()

  /// ACR is an Authentication Context Class Reference value. The meaning of the ACR
  /// value is context-specific and varies for identity providers.
  var acr: String = String()

  /// Provider is the external identity provider.
  var provider: String = String()

  /// Display is the friendly name for this provider.
  var display: String = String()

  /// Scope specifies additional scopes set by provider.
  var scope: [String] = []

  /// Prompt is an optional OIDC prompt. An empty string omits prompt.
  /// If not specified, it defaults to select_account for backwards compatibility.
  var prompt: String = String()

  /// ClaimsToRoles specifies a dynamic mapping from claims to roles.
  var claimsToRoles: [Types_ClaimMapping] = []

  /// GoogleServiceAccountURI is a path to a google service account uri.
  var googleServiceAccountUri: String = String()

  /// GoogleServiceAccount is a string containing google service account credentials.
  var googleServiceAccount: String = String()

  /// GoogleAdminEmail is the email of a google admin to impersonate.
  var googleAdminEmail: String = String()

  /// RedirectURLs is a list of callback URLs which the identity provider can use
  /// to redirect the client back to the Teleport Proxy to complete authentication.
  /// This list should match the URLs on the provider's side. The URL used for a
  /// given auth request will be chosen to match the requesting Proxy's public
  /// address. If there is no match, the first url in the list will be used.
  var redirectUrls: Wrappers_StringValues {
    get {return _redirectUrls ?? Wrappers_StringValues()}
    set {_redirectUrls = newValue}
  }
  /// Returns true if `redirectUrls` has been explicitly set.
  var hasRedirectUrls: Bool {return self._redirectUrls != nil}
  /// Clears the value of `redirectUrls`. Subsequent reads from it will return its default value.
  mutating func clearRedirectUrls() {self._redirectUrls = nil}

  /// AllowUnverifiedEmail tells the connector to accept OIDC users with unverified emails.
  var allowUnverifiedEmail: Bool = false

  /// UsernameClaim specifies the name of the claim from the OIDC connector to be used as the user's username.
  var usernameClaim: String = String()

  /// MaxAge is the amount of time that user logins are
  /// valid for. If a user logs in, but then does not login again
  /// within this time period, they will be forced to re-authenticate.
  var maxAge: Types_MaxAge {
    get {return _maxAge ?? Types_MaxAge()}
    set {_maxAge = newValue}
  }
  /// Returns true if `maxAge` has been explicitly set.
  var hasMaxAge: Bool {return self._maxAge != nil}
  /// Clears the value of `maxAge`. Subsequent reads from it will return its default value.
  mutating func clearMaxAge() {self._maxAge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _redirectUrls: Wrappers_StringValues? = nil
  fileprivate var _maxAge: Types_MaxAge? = nil
}

/// MaxAge allows the max_age parameter to be nullable to preserve backwards
/// compatibility. The duration is stored as nanoseconds.
struct Types_MaxAge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OIDCAuthRequest is a request to authenticate with OIDC
/// provider, the state about request is managed by auth server
struct Types_OIDCAuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConnectorID is ID of OIDC connector this request uses
  var connectorID: String {
    get {return _storage._connectorID}
    set {_uniqueStorage()._connectorID = newValue}
  }

  /// Type is opaque string that helps callbacks identify the request type
  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// CheckUser tells validator if it should expect and check user
  var checkUser: Bool {
    get {return _storage._checkUser}
    set {_uniqueStorage()._checkUser = newValue}
  }

  /// StateToken is generated by service and is used to validate
  /// request coming from
  var stateToken: String {
    get {return _storage._stateToken}
    set {_uniqueStorage()._stateToken = newValue}
  }

  /// CSRFToken is associated with user web session token
  var csrftoken: String {
    get {return _storage._csrftoken}
    set {_uniqueStorage()._csrftoken = newValue}
  }

  /// RedirectURL will be used to route the user back to a
  /// Teleport Proxy after the oidc login attempt in the browser.
  var redirectURL: String {
    get {return _storage._redirectURL}
    set {_uniqueStorage()._redirectURL = newValue}
  }

  /// PublicKey is an optional public key, users want these
  /// keys to be signed by auth servers user CA in case
  /// of successful auth
  var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  /// CertTTL is the TTL of the certificate user wants to get
  var certTtl: Int64 {
    get {return _storage._certTtl}
    set {_uniqueStorage()._certTtl = newValue}
  }

  /// CreateWebSession indicates if user wants to generate a web
  /// session after successful authentication
  var createWebSession: Bool {
    get {return _storage._createWebSession}
    set {_uniqueStorage()._createWebSession = newValue}
  }

  /// ClientRedirectURL is a URL client wants to be redirected
  /// after successful authentication
  var clientRedirectURL: String {
    get {return _storage._clientRedirectURL}
    set {_uniqueStorage()._clientRedirectURL = newValue}
  }

  /// Compatibility specifies OpenSSH compatibility flags.
  var compatibility: String {
    get {return _storage._compatibility}
    set {_uniqueStorage()._compatibility = newValue}
  }

  /// RouteToCluster is the name of Teleport cluster to issue credentials for.
  var routeToCluster: String {
    get {return _storage._routeToCluster}
    set {_uniqueStorage()._routeToCluster = newValue}
  }

  /// KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
  var kubernetesCluster: String {
    get {return _storage._kubernetesCluster}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }

  /// SSOTestFlow indicates if the request is part of the test flow.
  var ssotestFlow: Bool {
    get {return _storage._ssotestFlow}
    set {_uniqueStorage()._ssotestFlow = newValue}
  }

  /// ConnectorSpec is embedded connector spec for use in test flow.
  var connectorSpec: Types_OIDCConnectorSpecV3 {
    get {return _storage._connectorSpec ?? Types_OIDCConnectorSpecV3()}
    set {_uniqueStorage()._connectorSpec = newValue}
  }
  /// Returns true if `connectorSpec` has been explicitly set.
  var hasConnectorSpec: Bool {return _storage._connectorSpec != nil}
  /// Clears the value of `connectorSpec`. Subsequent reads from it will return its default value.
  mutating func clearConnectorSpec() {_uniqueStorage()._connectorSpec = nil}

  /// ProxyAddress is an optional address which can be used to
  /// find a redirect url from the OIDC connector which matches
  /// the address. If there is no match, the default redirect
  /// url will be used.
  var proxyAddress: String {
    get {return _storage._proxyAddress}
    set {_uniqueStorage()._proxyAddress = newValue}
  }

  /// attestation_statement is an attestation statement for the given public key.
  var attestationStatement: Teleport_Attestation_V1_AttestationStatement {
    get {return _storage._attestationStatement ?? Teleport_Attestation_V1_AttestationStatement()}
    set {_uniqueStorage()._attestationStatement = newValue}
  }
  /// Returns true if `attestationStatement` has been explicitly set.
  var hasAttestationStatement: Bool {return _storage._attestationStatement != nil}
  /// Clears the value of `attestationStatement`. Subsequent reads from it will return its default value.
  mutating func clearAttestationStatement() {_uniqueStorage()._attestationStatement = nil}

  /// ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
  var clientLoginIp: String {
    get {return _storage._clientLoginIp}
    set {_uniqueStorage()._clientLoginIp = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLConnectorV2 represents a SAML connector.
struct Types_SAMLConnectorV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is a resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata holds resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is an SAML connector specification.
  var spec: Types_SAMLConnectorSpecV2 {
    get {return _storage._spec ?? Types_SAMLConnectorSpecV2()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SAMLConnectorV2List is a list of SAML connectors.
struct Types_SAMLConnectorV2List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SAMLConnectors is a list of SAML connectors.
  var samlconnectors: [Types_SAMLConnectorV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SAMLConnectorSpecV2 is a SAML connector specification.
struct Types_SAMLConnectorSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Issuer is the identity provider issuer.
  var issuer: String = String()

  /// SSO is the URL of the identity provider's SSO service.
  var sso: String = String()

  /// Cert is the identity provider certificate PEM.
  /// IDP signs <Response> responses using this certificate.
  var cert: String = String()

  /// Display controls how this connector is displayed.
  var display: String = String()

  /// AssertionConsumerService is a URL for assertion consumer service
  /// on the service provider (Teleport's side).
  var assertionConsumerService: String = String()

  /// Audience uniquely identifies our service provider.
  var audience: String = String()

  /// ServiceProviderIssuer is the issuer of the service provider (Teleport).
  var serviceProviderIssuer: String = String()

  /// EntityDescriptor is XML with descriptor. It can be used to supply configuration
  /// parameters in one XML file rather than supplying them in the individual elements.
  var entityDescriptor: String = String()

  /// EntityDescriptorURL is a URL that supplies a configuration XML.
  var entityDescriptorURL: String = String()

  /// AttributesToRoles is a list of mappings of attribute statements to roles.
  var attributesToRoles: [Types_AttributeMapping] = []

  /// SigningKeyPair is an x509 key pair used to sign AuthnRequest.
  var signingKeyPair: Types_AsymmetricKeyPair {
    get {return _signingKeyPair ?? Types_AsymmetricKeyPair()}
    set {_signingKeyPair = newValue}
  }
  /// Returns true if `signingKeyPair` has been explicitly set.
  var hasSigningKeyPair: Bool {return self._signingKeyPair != nil}
  /// Clears the value of `signingKeyPair`. Subsequent reads from it will return its default value.
  mutating func clearSigningKeyPair() {self._signingKeyPair = nil}

  /// Provider is the external identity provider.
  var provider: String = String()

  /// EncryptionKeyPair is a key pair used for decrypting SAML assertions.
  var encryptionKeyPair: Types_AsymmetricKeyPair {
    get {return _encryptionKeyPair ?? Types_AsymmetricKeyPair()}
    set {_encryptionKeyPair = newValue}
  }
  /// Returns true if `encryptionKeyPair` has been explicitly set.
  var hasEncryptionKeyPair: Bool {return self._encryptionKeyPair != nil}
  /// Clears the value of `encryptionKeyPair`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionKeyPair() {self._encryptionKeyPair = nil}

  /// AllowIDPInitiated is a flag that indicates if the connector can be used for IdP-initiated
  /// logins.
  var allowIdpinitiated: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signingKeyPair: Types_AsymmetricKeyPair? = nil
  fileprivate var _encryptionKeyPair: Types_AsymmetricKeyPair? = nil
}

/// SAMLAuthRequest is a request to authenticate with SAML
/// provider, the state about request is managed by auth server.
struct Types_SAMLAuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is a unique request ID.
  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// ConnectorID is ID of OIDC connector this request uses.
  var connectorID: String {
    get {return _storage._connectorID}
    set {_uniqueStorage()._connectorID = newValue}
  }

  /// Type is opaque string that helps callbacks identify the request type.
  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// CheckUser tells validator if it should expect and check user.
  var checkUser: Bool {
    get {return _storage._checkUser}
    set {_uniqueStorage()._checkUser = newValue}
  }

  /// RedirectURL will be used by browser.
  var redirectURL: String {
    get {return _storage._redirectURL}
    set {_uniqueStorage()._redirectURL = newValue}
  }

  /// PublicKey is an optional public key, users want these
  /// keys to be signed by auth servers user CA in case
  /// of successful auth.
  var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  /// CertTTL is the TTL of the certificate user wants to get.
  var certTtl: Int64 {
    get {return _storage._certTtl}
    set {_uniqueStorage()._certTtl = newValue}
  }

  /// CSRFToken is associated with user web session token.
  var csrftoken: String {
    get {return _storage._csrftoken}
    set {_uniqueStorage()._csrftoken = newValue}
  }

  /// CreateWebSession indicates if user wants to generate a web
  /// session after successful authentication.
  var createWebSession: Bool {
    get {return _storage._createWebSession}
    set {_uniqueStorage()._createWebSession = newValue}
  }

  /// ClientRedirectURL is a URL client wants to be redirected
  /// after successful authentication.
  var clientRedirectURL: String {
    get {return _storage._clientRedirectURL}
    set {_uniqueStorage()._clientRedirectURL = newValue}
  }

  /// Compatibility specifies OpenSSH compatibility flags.
  var compatibility: String {
    get {return _storage._compatibility}
    set {_uniqueStorage()._compatibility = newValue}
  }

  /// RouteToCluster is the name of Teleport cluster to issue credentials for.
  var routeToCluster: String {
    get {return _storage._routeToCluster}
    set {_uniqueStorage()._routeToCluster = newValue}
  }

  /// KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
  var kubernetesCluster: String {
    get {return _storage._kubernetesCluster}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }

  /// SSOTestFlow indicates if the request is part of the test flow.
  var ssotestFlow: Bool {
    get {return _storage._ssotestFlow}
    set {_uniqueStorage()._ssotestFlow = newValue}
  }

  /// ConnectorSpec is embedded connector spec for use in test flow.
  var connectorSpec: Types_SAMLConnectorSpecV2 {
    get {return _storage._connectorSpec ?? Types_SAMLConnectorSpecV2()}
    set {_uniqueStorage()._connectorSpec = newValue}
  }
  /// Returns true if `connectorSpec` has been explicitly set.
  var hasConnectorSpec: Bool {return _storage._connectorSpec != nil}
  /// Clears the value of `connectorSpec`. Subsequent reads from it will return its default value.
  mutating func clearConnectorSpec() {_uniqueStorage()._connectorSpec = nil}

  /// attestation_statement is an attestation statement for the given public key.
  var attestationStatement: Teleport_Attestation_V1_AttestationStatement {
    get {return _storage._attestationStatement ?? Teleport_Attestation_V1_AttestationStatement()}
    set {_uniqueStorage()._attestationStatement = newValue}
  }
  /// Returns true if `attestationStatement` has been explicitly set.
  var hasAttestationStatement: Bool {return _storage._attestationStatement != nil}
  /// Clears the value of `attestationStatement`. Subsequent reads from it will return its default value.
  mutating func clearAttestationStatement() {_uniqueStorage()._attestationStatement = nil}

  /// ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
  var clientLoginIp: String {
    get {return _storage._clientLoginIp}
    set {_uniqueStorage()._clientLoginIp = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AttributeMapping maps a SAML attribute statement to teleport roles.
struct Types_AttributeMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is an attribute statement name.
  var name: String = String()

  /// Value is an attribute statement value to match.
  var value: String = String()

  /// Roles is a list of static teleport roles to map to.
  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AsymmetricKeyPair is a combination of a public certificate and
/// private key that can be used for encryption and signing.
struct Types_AsymmetricKeyPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PrivateKey is a PEM encoded x509 private key.
  var privateKey: String = String()

  /// Cert is a PEM-encoded x509 certificate.
  var cert: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GithubConnectorV3 represents a Github connector.
struct Types_GithubConnectorV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is a resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata holds resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is an Github connector specification.
  var spec: Types_GithubConnectorSpecV3 {
    get {return _storage._spec ?? Types_GithubConnectorSpecV3()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GithubConnectorV3List is a list of Github connectors.
struct Types_GithubConnectorV3List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// GithubConnectors is a list of Github connectors.
  var githubConnectors: [Types_GithubConnectorV3] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GithubConnectorSpecV3 is a Github connector specification.
struct Types_GithubConnectorSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID is the Github OAuth app client ID.
  var clientID: String = String()

  /// ClientSecret is the Github OAuth app client secret.
  var clientSecret: String = String()

  /// RedirectURL is the authorization callback URL.
  var redirectURL: String = String()

  /// TeamsToLogins maps Github team memberships onto allowed logins/roles.
  ///
  /// DELETE IN 11.0.0
  /// Deprecated: use GithubTeamsToRoles instead.
  var teamsToLogins: [Types_TeamMapping] = []

  /// Display is the connector display name.
  var display: String = String()

  /// TeamsToRoles maps Github team memberships onto allowed roles.
  var teamsToRoles: [Types_TeamRolesMapping] = []

  /// EndpointURL is the URL of the GitHub instance this connector is for.
  var endpointURL: String = String()

  /// APIEndpointURL is the URL of the API endpoint of the Github instance
  /// this connector is for.
  var apiendpointURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GithubAuthRequest is the request to start Github OAuth2 flow.
struct Types_GithubAuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConnectorID is the name of the connector to use.
  var connectorID: String {
    get {return _storage._connectorID}
    set {_uniqueStorage()._connectorID = newValue}
  }

  /// Type is opaque string that helps callbacks identify the request type.
  var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// StateToken is used to validate the request.
  var stateToken: String {
    get {return _storage._stateToken}
    set {_uniqueStorage()._stateToken = newValue}
  }

  /// CSRFToken is used to protect against CSRF attacks.
  var csrftoken: String {
    get {return _storage._csrftoken}
    set {_uniqueStorage()._csrftoken = newValue}
  }

  /// PublicKey is an optional public key to sign in case of successful auth.
  var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  /// CertTTL is TTL of the cert that's generated in case of successful auth.
  var certTtl: Int64 {
    get {return _storage._certTtl}
    set {_uniqueStorage()._certTtl = newValue}
  }

  /// CreateWebSession indicates that a user wants to generate a web session
  /// after successful authentication.
  var createWebSession: Bool {
    get {return _storage._createWebSession}
    set {_uniqueStorage()._createWebSession = newValue}
  }

  /// RedirectURL will be used by browser.
  var redirectURL: String {
    get {return _storage._redirectURL}
    set {_uniqueStorage()._redirectURL = newValue}
  }

  /// ClientRedirectURL is the URL where client will be redirected after
  /// successful auth.
  var clientRedirectURL: String {
    get {return _storage._clientRedirectURL}
    set {_uniqueStorage()._clientRedirectURL = newValue}
  }

  /// Compatibility specifies OpenSSH compatibility flags.
  var compatibility: String {
    get {return _storage._compatibility}
    set {_uniqueStorage()._compatibility = newValue}
  }

  /// Expires is a global expiry time header can be set on any resource in the system.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  /// RouteToCluster is the name of Teleport cluster to issue credentials for.
  var routeToCluster: String {
    get {return _storage._routeToCluster}
    set {_uniqueStorage()._routeToCluster = newValue}
  }

  /// KubernetesCluster is the name of Kubernetes cluster to issue credentials for.
  var kubernetesCluster: String {
    get {return _storage._kubernetesCluster}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }

  /// SSOTestFlow indicates if the request is part of the test flow.
  var ssotestFlow: Bool {
    get {return _storage._ssotestFlow}
    set {_uniqueStorage()._ssotestFlow = newValue}
  }

  /// ConnectorSpec is embedded connector spec for use in test flow.
  var connectorSpec: Types_GithubConnectorSpecV3 {
    get {return _storage._connectorSpec ?? Types_GithubConnectorSpecV3()}
    set {_uniqueStorage()._connectorSpec = newValue}
  }
  /// Returns true if `connectorSpec` has been explicitly set.
  var hasConnectorSpec: Bool {return _storage._connectorSpec != nil}
  /// Clears the value of `connectorSpec`. Subsequent reads from it will return its default value.
  mutating func clearConnectorSpec() {_uniqueStorage()._connectorSpec = nil}

  /// attestation_statement is an attestation statement for the given public key.
  var attestationStatement: Teleport_Attestation_V1_AttestationStatement {
    get {return _storage._attestationStatement ?? Teleport_Attestation_V1_AttestationStatement()}
    set {_uniqueStorage()._attestationStatement = newValue}
  }
  /// Returns true if `attestationStatement` has been explicitly set.
  var hasAttestationStatement: Bool {return _storage._attestationStatement != nil}
  /// Clears the value of `attestationStatement`. Subsequent reads from it will return its default value.
  mutating func clearAttestationStatement() {_uniqueStorage()._attestationStatement = nil}

  /// ClientLoginIP specifies IP address of the client for login, it will be written to the user's certificates.
  var clientLoginIp: String {
    get {return _storage._clientLoginIp}
    set {_uniqueStorage()._clientLoginIp = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SSOWarnings conveys a user-facing main message along with auxiliary warnings.
struct Types_SSOWarnings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message is main user-facing message to be shown.
  var message: String = String()

  /// Warnings is a set of distinct warnings to be reported.
  var warnings: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CreateUserParams represents the user creation parameters as called during SSO login flow.
struct Types_CreateUserParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConnectorName is the name of the connector used for SSO login flow.
  var connectorName: String = String()

  /// Username is the name of the user to be created.
  var username: String = String()

  /// Logins is a list of available unix logins.
  var logins: [String] = []

  /// KubeGroups is a list of assigned kube groups.
  var kubeGroups: [String] = []

  /// KubeUsers is a list of available kube users.
  var kubeUsers: [String] = []

  /// Roles is a list of assigned roles.
  var roles: [String] = []

  /// Traits is the set of traits the user is assigned.
  var traits: Wrappers_LabelValues {
    get {return _traits ?? Wrappers_LabelValues()}
    set {_traits = newValue}
  }
  /// Returns true if `traits` has been explicitly set.
  var hasTraits: Bool {return self._traits != nil}
  /// Clears the value of `traits`. Subsequent reads from it will return its default value.
  mutating func clearTraits() {self._traits = nil}

  /// SessionTTL determines the TTL.
  var sessionTtl: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _traits: Wrappers_LabelValues? = nil
}

/// SSODiagnosticInfo is a single SSO diagnostic info entry.
struct Types_SSODiagnosticInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TestFlow indicates the SSO flow was a test one.
  var testFlow: Bool {
    get {return _storage._testFlow}
    set {_uniqueStorage()._testFlow = newValue}
  }

  /// Error stores user-friendly error message.
  var error: String {
    get {return _storage._error}
    set {_uniqueStorage()._error = newValue}
  }

  /// Success if present, marks the flow as finished with success.
  var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  /// CreateUserParams represents the user creation parameters as called during SSO login flow.
  var createUserParams: Types_CreateUserParams {
    get {return _storage._createUserParams ?? Types_CreateUserParams()}
    set {_uniqueStorage()._createUserParams = newValue}
  }
  /// Returns true if `createUserParams` has been explicitly set.
  var hasCreateUserParams: Bool {return _storage._createUserParams != nil}
  /// Clears the value of `createUserParams`. Subsequent reads from it will return its default value.
  mutating func clearCreateUserParams() {_uniqueStorage()._createUserParams = nil}

  /// SAMLAttributesToRoles represents mapping from attributes to roles, as used during SAML SSO
  /// login flow.
  var samlattributesToRoles: [Types_AttributeMapping] {
    get {return _storage._samlattributesToRoles}
    set {_uniqueStorage()._samlattributesToRoles = newValue}
  }

  /// SAMLAttributesToRolesWarnings contains warnings produced during the process of mapping the
  /// SAML attributes to roles.
  var samlattributesToRolesWarnings: Types_SSOWarnings {
    get {return _storage._samlattributesToRolesWarnings ?? Types_SSOWarnings()}
    set {_uniqueStorage()._samlattributesToRolesWarnings = newValue}
  }
  /// Returns true if `samlattributesToRolesWarnings` has been explicitly set.
  var hasSamlattributesToRolesWarnings: Bool {return _storage._samlattributesToRolesWarnings != nil}
  /// Clears the value of `samlattributesToRolesWarnings`. Subsequent reads from it will return its default value.
  mutating func clearSamlattributesToRolesWarnings() {_uniqueStorage()._samlattributesToRolesWarnings = nil}

  /// SAMLAttributeStatements represents SAML attribute statements.
  var samlattributeStatements: Wrappers_LabelValues {
    get {return _storage._samlattributeStatements ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._samlattributeStatements = newValue}
  }
  /// Returns true if `samlattributeStatements` has been explicitly set.
  var hasSamlattributeStatements: Bool {return _storage._samlattributeStatements != nil}
  /// Clears the value of `samlattributeStatements`. Subsequent reads from it will return its default value.
  mutating func clearSamlattributeStatements() {_uniqueStorage()._samlattributeStatements = nil}

  /// SAMLAssertionInfo represents raw SAML assertion info as returned by IdP during SAML flow.
  var samlassertionInfo: Wrappers_CustomType {
    get {return _storage._samlassertionInfo ?? Wrappers_CustomType()}
    set {_uniqueStorage()._samlassertionInfo = newValue}
  }
  /// Returns true if `samlassertionInfo` has been explicitly set.
  var hasSamlassertionInfo: Bool {return _storage._samlassertionInfo != nil}
  /// Clears the value of `samlassertionInfo`. Subsequent reads from it will return its default value.
  mutating func clearSamlassertionInfo() {_uniqueStorage()._samlassertionInfo = nil}

  /// SAMLTraitsFromAssertions represents traits translated from SAML assertions.
  var samltraitsFromAssertions: Wrappers_LabelValues {
    get {return _storage._samltraitsFromAssertions ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._samltraitsFromAssertions = newValue}
  }
  /// Returns true if `samltraitsFromAssertions` has been explicitly set.
  var hasSamltraitsFromAssertions: Bool {return _storage._samltraitsFromAssertions != nil}
  /// Clears the value of `samltraitsFromAssertions`. Subsequent reads from it will return its default value.
  mutating func clearSamltraitsFromAssertions() {_uniqueStorage()._samltraitsFromAssertions = nil}

  /// SAMLConnectorTraitMapping represents connector-specific trait mapping.
  var samlconnectorTraitMapping: [Types_TraitMapping] {
    get {return _storage._samlconnectorTraitMapping}
    set {_uniqueStorage()._samlconnectorTraitMapping = newValue}
  }

  /// OIDCClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
  var oidcclaimsToRoles: [Types_ClaimMapping] {
    get {return _storage._oidcclaimsToRoles}
    set {_uniqueStorage()._oidcclaimsToRoles = newValue}
  }

  /// OIDCClaimsToRolesWarnings contains warnings produced during the process of mapping the
  /// OIDC claims to roles.
  var oidcclaimsToRolesWarnings: Types_SSOWarnings {
    get {return _storage._oidcclaimsToRolesWarnings ?? Types_SSOWarnings()}
    set {_uniqueStorage()._oidcclaimsToRolesWarnings = newValue}
  }
  /// Returns true if `oidcclaimsToRolesWarnings` has been explicitly set.
  var hasOidcclaimsToRolesWarnings: Bool {return _storage._oidcclaimsToRolesWarnings != nil}
  /// Clears the value of `oidcclaimsToRolesWarnings`. Subsequent reads from it will return its default value.
  mutating func clearOidcclaimsToRolesWarnings() {_uniqueStorage()._oidcclaimsToRolesWarnings = nil}

  /// OIDCClaims represents OIDC claims.
  var oidcclaims: Wrappers_CustomType {
    get {return _storage._oidcclaims ?? Wrappers_CustomType()}
    set {_uniqueStorage()._oidcclaims = newValue}
  }
  /// Returns true if `oidcclaims` has been explicitly set.
  var hasOidcclaims: Bool {return _storage._oidcclaims != nil}
  /// Clears the value of `oidcclaims`. Subsequent reads from it will return its default value.
  mutating func clearOidcclaims() {_uniqueStorage()._oidcclaims = nil}

  /// OIDCIdentity represents mapped OIDC Identity.
  var oidcidentity: Wrappers_CustomType {
    get {return _storage._oidcidentity ?? Wrappers_CustomType()}
    set {_uniqueStorage()._oidcidentity = newValue}
  }
  /// Returns true if `oidcidentity` has been explicitly set.
  var hasOidcidentity: Bool {return _storage._oidcidentity != nil}
  /// Clears the value of `oidcidentity`. Subsequent reads from it will return its default value.
  mutating func clearOidcidentity() {_uniqueStorage()._oidcidentity = nil}

  /// OIDCTraitsFromClaims represents traits translated from OIDC claims.
  var oidctraitsFromClaims: Wrappers_LabelValues {
    get {return _storage._oidctraitsFromClaims ?? Wrappers_LabelValues()}
    set {_uniqueStorage()._oidctraitsFromClaims = newValue}
  }
  /// Returns true if `oidctraitsFromClaims` has been explicitly set.
  var hasOidctraitsFromClaims: Bool {return _storage._oidctraitsFromClaims != nil}
  /// Clears the value of `oidctraitsFromClaims`. Subsequent reads from it will return its default value.
  mutating func clearOidctraitsFromClaims() {_uniqueStorage()._oidctraitsFromClaims = nil}

  /// OIDCConnectorTraitMapping represents connector-specific trait mapping.
  var oidcconnectorTraitMapping: [Types_TraitMapping] {
    get {return _storage._oidcconnectorTraitMapping}
    set {_uniqueStorage()._oidcconnectorTraitMapping = newValue}
  }

  /// GithubClaims represents Github user information obtained during OAuth2 flow.
  var githubClaims: Types_GithubClaims {
    get {return _storage._githubClaims ?? Types_GithubClaims()}
    set {_uniqueStorage()._githubClaims = newValue}
  }
  /// Returns true if `githubClaims` has been explicitly set.
  var hasGithubClaims: Bool {return _storage._githubClaims != nil}
  /// Clears the value of `githubClaims`. Subsequent reads from it will return its default value.
  mutating func clearGithubClaims() {_uniqueStorage()._githubClaims = nil}

  /// GithubTeamsToLogins is TeamsToLogins mapping from Github connector used in the SSO flow.
  var githubTeamsToLogins: [Types_TeamMapping] {
    get {return _storage._githubTeamsToLogins}
    set {_uniqueStorage()._githubTeamsToLogins = newValue}
  }

  /// GithubTeamsToRoles is TeamRolesMapping mapping from Github connector used in the SSO flow.
  var githubTeamsToRoles: [Types_TeamRolesMapping] {
    get {return _storage._githubTeamsToRoles}
    set {_uniqueStorage()._githubTeamsToRoles = newValue}
  }

  /// GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
  var githubTokenInfo: Types_GithubTokenInfo {
    get {return _storage._githubTokenInfo ?? Types_GithubTokenInfo()}
    set {_uniqueStorage()._githubTokenInfo = newValue}
  }
  /// Returns true if `githubTokenInfo` has been explicitly set.
  var hasGithubTokenInfo: Bool {return _storage._githubTokenInfo != nil}
  /// Clears the value of `githubTokenInfo`. Subsequent reads from it will return its default value.
  mutating func clearGithubTokenInfo() {_uniqueStorage()._githubTokenInfo = nil}

  /// AppliedLoginRules stores the name of each login rule that was applied.
  var appliedLoginRules: [String] {
    get {return _storage._appliedLoginRules}
    set {_uniqueStorage()._appliedLoginRules = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GithubTokenInfo stores diagnostic info about Github OAuth2 token obtained during SSO flow.
/// The token itself is secret and therefore not included.
struct Types_GithubTokenInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenType: String = String()

  var expires: Int64 = 0

  var scope: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GithubClaims represents Github user information obtained during OAuth2 flow
struct Types_GithubClaims {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Username is the user's username
  var username: String = String()

  /// OrganizationToTeams is the user's organization and team membership
  var organizationToTeams: Wrappers_LabelValues {
    get {return _organizationToTeams ?? Wrappers_LabelValues()}
    set {_organizationToTeams = newValue}
  }
  /// Returns true if `organizationToTeams` has been explicitly set.
  var hasOrganizationToTeams: Bool {return self._organizationToTeams != nil}
  /// Clears the value of `organizationToTeams`. Subsequent reads from it will return its default value.
  mutating func clearOrganizationToTeams() {self._organizationToTeams = nil}

  /// Teams is the users team membership
  var teams: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _organizationToTeams: Wrappers_LabelValues? = nil
}

/// TeamMapping represents a single team membership mapping.
///
/// DELETE IN 11.0.0
struct Types_TeamMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Organization is a Github organization a user belongs to.
  var organization: String = String()

  /// Team is a team within the organization a user belongs to.
  var team: String = String()

  /// Logins is a list of allowed logins for this org/team.
  var logins: [String] = []

  /// KubeGroups is a list of allowed kubernetes groups for this org/team.
  var kubeGroups: [String] = []

  /// KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
  var kubeUsers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TeamRolesMapping represents a single team membership mapping.
struct Types_TeamRolesMapping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Organization is a Github organization a user belongs to.
  var organization: String = String()

  /// Team is a team within the organization a user belongs to.
  var team: String = String()

  /// Roles is a list of allowed logins for this org/team.
  var roles: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TrustedClusterV2 represents a Trusted Cluster.
struct Types_TrustedClusterV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is a resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata holds resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is a Trusted Cluster specification.
  var spec: Types_TrustedClusterSpecV2 {
    get {return _storage._spec ?? Types_TrustedClusterSpecV2()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TrustedClusterV2List is a list of trusted cluster.
struct Types_TrustedClusterV2List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TrustedClusters is a list of trusted cluster.
  var trustedClusters: [Types_TrustedClusterV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TrustedClusterSpecV2 is a Trusted Cluster specification.
struct Types_TrustedClusterSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enabled is a bool that indicates if the TrustedCluster is enabled or disabled.
  /// Setting Enabled to false has a side effect of deleting the user and host certificate
  /// authority (CA).
  var enabled: Bool = false

  /// Roles is a list of roles that users will be assuming when connecting to this cluster.
  var roles: [String] = []

  /// Token is the authorization token provided by another cluster needed by this cluster to join.
  var token: String = String()

  /// ProxyAddress is the address of the web proxy server of the cluster to join. If not set,
  /// it is derived from <metadata.name>:<default web proxy server port>.
  var proxyAddress: String = String()

  /// ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If
  /// not set, it is derived from <metadata.name>:<default reverse tunnel port>.
  var reverseTunnelAddress: String = String()

  /// RoleMap specifies role mappings to remote roles.
  var roleMap: [Types_RoleMapping] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LockV2 represents a lock.
/// Locks are used to restrict access to a Teleport environment by disabling
/// interactions involving a user, an RBAC role, a node, etc.
/// See rfd/0009-locking.md for more details.
struct Types_LockV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// SubKind is an optional resource sub kind, used in some resources.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// Version is a resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata holds resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Spec is a Lock specification.
  var spec: Types_LockSpecV2 {
    get {return _storage._spec ?? Types_LockSpecV2()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// LockSpecV2 is a Lock specification.
struct Types_LockSpecV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target describes the set of interactions that the lock applies to.
  var target: Types_LockTarget {
    get {return _target ?? Types_LockTarget()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  mutating func clearTarget() {self._target = nil}

  /// Message is the message displayed to locked-out users.
  var message: String = String()

  /// Expires if set specifies when the lock ceases to be in force.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  /// CreatedAt is the date time that the lock was created.
  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  /// CreatedBy is the username of the author of the lock.
  var createdBy: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _target: Types_LockTarget? = nil
  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// LockTarget lists the attributes of interactions to be disabled.
struct Types_LockTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User specifies the name of a Teleport user.
  var user: String = String()

  /// Role specifies the name of an RBAC role known to the root cluster.
  /// In remote clusters, this constraint is evaluated before translating to local roles.
  var role: String = String()

  /// Login specifies the name of a local UNIX user.
  var login: String = String()

  /// Node specifies the UUID of a Teleport node.
  /// A matching node is also prevented from heartbeating to the auth server.
  /// DEPRECATED: use ServerID instead.
  var node: String = String()

  /// MFADevice specifies the UUID of a user MFA device.
  var mfadevice: String = String()

  /// WindowsDesktop specifies the name of a Windows desktop.
  var windowsDesktop: String = String()

  /// AccessRequest specifies the UUID of an access request.
  var accessRequest: String = String()

  /// Device is the device ID of a trusted device.
  /// Requires Teleport Enterprise.
  var device: String = String()

  /// ServerID is the host id of the Teleport instance.
  var serverID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AddressCondition represents a set of addresses. Presently the addresses are specified
/// exclusively in terms of IPv4/IPv6 ranges.
struct Types_AddressCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CIDR is IPv4 or IPv6 address. Valid value are either CIDR ranges (e.g. "10.0.1.0/24",
  /// "fe::/8") or a single IP address (e.g "10.1.2.3")
  var cidr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_NetworkRestrictionsSpecV4 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allow lists the addresses that should be allowed.
  var allow: [Types_AddressCondition] = []

  /// Deny lists the addresses that should be denied even if they're allowed by Allow condition.
  var deny: [Types_AddressCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// NetworkRestrictions specifies a list of addresses to restrict (block). The deny
/// list is checked first and the allow lists overrides it. Thus an empty allow
/// list does not mean that no addresses will be allowed, that will only be the
/// case if the deny list covers the whole address range.
struct Types_NetworkRestrictionsV4 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the network restrictions resource kind.
  var kind: String = String()

  /// SubKind is an optional resource subkind.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the network restrictions metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec contains the network restrictions data
  var spec: Types_NetworkRestrictionsSpecV4 {
    get {return _spec ?? Types_NetworkRestrictionsSpecV4()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_NetworkRestrictionsSpecV4? = nil
}

/// WindowsDesktopServiceV3 represents a windows desktop access service.
struct Types_WindowsDesktopServiceV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the common resource header.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the windows desktop service spec.
  var spec: Types_WindowsDesktopServiceSpecV3 {
    get {return _spec ?? Types_WindowsDesktopServiceSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_WindowsDesktopServiceSpecV3? = nil
}

/// WindowsDesktopServiceSpecV3 is the windows desktop service spec.
struct Types_WindowsDesktopServiceSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Addr is the address that this service can be reached at.
  var addr: String = String()

  /// TeleportVersion is teleport binary version running this service.
  var teleportVersion: String = String()

  /// Hostname is the desktop service hostname.
  var hostname: String = String()

  /// ProxyIDs is a list of proxy IDs this server is expected to be connected to.
  var proxyIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WindowsDesktopFilter are filters to apply when searching for windows desktops.
struct Types_WindowsDesktopFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HostID is the ID of the host the Windows Desktop Service proxying the desktop.
  var hostID: String = String()

  /// Name is the name of the desktop.
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WindowsDesktopV3 represents a Windows host for desktop access.
struct Types_WindowsDesktopV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the common resource header.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the Windows host spec.
  var spec: Types_WindowsDesktopSpecV3 {
    get {return _spec ?? Types_WindowsDesktopSpecV3()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_WindowsDesktopSpecV3? = nil
}

/// WindowsDesktopSpecV3 is the Windows host spec.
struct Types_WindowsDesktopSpecV3 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Addr is the address that this host can be reached at.
  var addr: String = String()

  /// Domain is the ActiveDirectory domain that this host belongs to.
  var domain: String = String()

  /// HostID is the ID of the host the Windows Desktop Service proxying the desktop.
  var hostID: String = String()

  /// NonAD marks this desktop as a standalone host that is
  /// not joined to an Active Directory domain.
  var nonAd: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RegisterUsingTokenRequest is a request to register with the auth server using
/// an authentication token
struct Types_RegisterUsingTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HostID is a unique host ID, usually a UUID
  var hostID: String = String()

  /// NodeName is a node name
  var nodeName: String = String()

  /// Role is a system role, e.g. Proxy
  var role: String = String()

  /// Token is the name of an authentication token
  var token: String = String()

  /// AdditionalPrincipals is a list of additional principals
  var additionalPrincipals: [String] = []

  /// DNSNames is a list of DNS names to include in the x509 client certificate
  var dnsnames: [String] = []

  /// PublicTLSKey is a PEM encoded public key
  /// used for TLS setup
  var publicTlskey: Data = Data()

  /// PublicSSHKey is a SSH encoded public key,
  /// if present will be signed as a return value
  /// otherwise, new public/private key pair will be generated
  var publicSshkey: Data = Data()

  /// RemoteAddr is the remote address of the host requesting a host certificate.
  /// It is used to replace 0.0.0.0 in the list of additional principals.
  var remoteAddr: String = String()

  /// EC2IdentityDocument is used for the EC2 join method to prove the identity
  /// of a joining EC2 instance.
  var ec2IdentityDocument: Data = Data()

  /// IDToken is a token provided by a workload identity provider as part of
  /// OIDC join types such as GitHub.
  var idtoken: String = String()

  /// Expires is a desired time of the expiry of user certificates returned by
  /// registration. This only applies to bot joining, and will be ignored by
  /// node joining.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// RecoveryCodes holds a user's recovery code information. Recovery codes allows users to regain
/// access to their account by restoring their lost password or second factor. Once a recovery code
/// is successfully verified, the code is mark used (which invalidates it), and lets the user begin
/// the recovery flow. When a user successfully finishes the recovery flow, users will get a new set
/// of codes that will replace all the previous ones.
struct Types_RecoveryCodesV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the resource kind.
  var kind: String = String()

  /// SubKind is an optional resource subkind. Currently unused for this resource.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the resource metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is the resource spec.
  var spec: Types_RecoveryCodesSpecV1 {
    get {return _spec ?? Types_RecoveryCodesSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_RecoveryCodesSpecV1? = nil
}

/// RecoveryCodesSpecV1 is the recovery codes spec.
struct Types_RecoveryCodesSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Codes hold a list of numOfRecoveryCodes.
  var codes: [Types_RecoveryCode] = []

  /// Created is when the set of recovery codes were generated. Updated when a new set of recovery
  /// codes are inserted.
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// RecoveryCode describes a recovery code.
struct Types_RecoveryCode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HashedCode is a bcrypt hash of this recovery code.
  var hashedCode: Data = Data()

  /// IsUsed determines if this recovery code was used.
  var isUsed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_NullableSessionState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Types_SessionState = .pending

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SessionTrackerFilter are filters to apply when searching for session trackers.
struct Types_SessionTrackerFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind describes what kind of session this is.
  var kind: String = String()

  /// State is the current state of this session.
  var state: Types_NullableSessionState {
    get {return _state ?? Types_NullableSessionState()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  /// DesktopName is the windows desktop server this session belongs to.
  var desktopName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: Types_NullableSessionState? = nil
}

/// SessionTrackerV1 represents a live session resource.
struct Types_SessionTrackerV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the common resource header.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is a session specification.
  var spec: Types_SessionTrackerSpecV1 {
    get {return _spec ?? Types_SessionTrackerSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_SessionTrackerSpecV1? = nil
}

/// SessionTrackerSpecV1 is the specification for a live session.
struct Types_SessionTrackerSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SessionID is unique identifier of this session.
  var sessionID: String {
    get {return _storage._sessionID}
    set {_uniqueStorage()._sessionID = newValue}
  }

  /// Kind describes what kind of session this is.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// State is the current state of this session.
  var state: Types_SessionState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Created encodes the time at which the session was registered with the auth
  /// server.
  ///
  /// This should match the timestamp in the corresponding `session.create` event.
  /// It's thus up to the tracker creator to set the correct timestamp.
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {_uniqueStorage()._created = nil}

  /// Expires encodes the time at which this session expires and becomes invalid.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  /// AttachedData is arbitrary attached JSON serialized metadata.
  var attachedData: String {
    get {return _storage._attachedData}
    set {_uniqueStorage()._attachedData = newValue}
  }

  /// Reason is an arbitrary string that may be used to describe the session and/or it's
  /// purpose.
  var reason: String {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  /// Invited is a list of invited users, this field is interpreted by different
  /// clients on a best-effort basis and used for delivering notifications to invited users.
  var invited: [String] {
    get {return _storage._invited}
    set {_uniqueStorage()._invited = newValue}
  }

  /// Hostname identifies the target this session is connected to.
  var hostname: String {
    get {return _storage._hostname}
    set {_uniqueStorage()._hostname = newValue}
  }

  /// Address is the address of the target this session is connected to.
  var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// ClusterName is the name of the Teleport cluster that this session belongs to.
  var clusterName: String {
    get {return _storage._clusterName}
    set {_uniqueStorage()._clusterName = newValue}
  }

  /// Login is the local login/user on the target used by the session.
  var login: String {
    get {return _storage._login}
    set {_uniqueStorage()._login = newValue}
  }

  /// Participants is a list of session participants.
  var participants: [Types_Participant] {
    get {return _storage._participants}
    set {_uniqueStorage()._participants = newValue}
  }

  /// The Kubernetes cluster this session belongs to.
  var kubernetesCluster: String {
    get {return _storage._kubernetesCluster}
    set {_uniqueStorage()._kubernetesCluster = newValue}
  }

  /// HostUser is the user regarded as the owner of this session, RBAC checks are performed
  /// against the require policies of this user.
  ///
  /// This refers to the Teleport user but may not be the same as the sessions initiator.
  var hostUser: String {
    get {return _storage._hostUser}
    set {_uniqueStorage()._hostUser = newValue}
  }

  /// HostPolicies is a list of RBAC policy sets held by the host user at the time of session
  /// creation.
  var hostPolicies: [Types_SessionTrackerPolicySet] {
    get {return _storage._hostPolicies}
    set {_uniqueStorage()._hostPolicies = newValue}
  }

  /// DatabaseName is the database server this session belongs to.
  var databaseName: String {
    get {return _storage._databaseName}
    set {_uniqueStorage()._databaseName = newValue}
  }

  /// AppName is the app server this session belongs to.
  var appName: String {
    get {return _storage._appName}
    set {_uniqueStorage()._appName = newValue}
  }

  /// AppSessionID is the unique ID of the app access certificate used to start this app session.
  var appSessionID: String {
    get {return _storage._appSessionID}
    set {_uniqueStorage()._appSessionID = newValue}
  }

  /// DesktopName is the windows desktop server this session belongs to.
  var desktopName: String {
    get {return _storage._desktopName}
    set {_uniqueStorage()._desktopName = newValue}
  }

  /// HostID is the target host id that created the session tracker.
  /// It's useful for Kubernetes moderated sessions when running in high availabilty
  /// otherwise kube proxy is not able to know which agent runs the session.
  var hostID: String {
    get {return _storage._hostID}
    set {_uniqueStorage()._hostID = newValue}
  }

  /// TargetSubKind is the sub kind of the target server.
  var targetSubKind: String {
    get {return _storage._targetSubKind}
    set {_uniqueStorage()._targetSubKind = newValue}
  }

  /// InitialCommand is the command that was executed to start this session.
  var initialCommand: [String] {
    get {return _storage._initialCommand}
    set {_uniqueStorage()._initialCommand = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SessionTrackerPolicySet is a set of RBAC policies held by the session tracker
/// that contain additional metadata from the originating role.
struct Types_SessionTrackerPolicySet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is name of the role this policy set originates from.
  var name: String = String()

  /// Version is version of the role this policy set originates from.
  var version: String = String()

  /// RequireSessionJoin specifies policies for required users to start a session.
  var requireSessionJoin: [Types_SessionRequirePolicy] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Participant stores information about a participant in the session.
struct Types_Participant {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID is a unique UUID of this participant for a given session.
  var id: String = String()

  /// User is the canonical name of the Teleport user controlling this participant.
  var user: String = String()

  /// Mode is the participant mode.
  var mode: String = String()

  /// LastActive is the last time this party was active in the session.
  var lastActive: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastActive ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastActive = newValue}
  }
  /// Returns true if `lastActive` has been explicitly set.
  var hasLastActive: Bool {return self._lastActive != nil}
  /// Clears the value of `lastActive`. Subsequent reads from it will return its default value.
  mutating func clearLastActive() {self._lastActive = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastActive: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// UIConfigV1 represents the configuration for the web UI served by the proxy service
struct Types_UIConfigV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header for the UI configuration.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the resource spec.
  var spec: Types_UIConfigSpecV1 {
    get {return _spec ?? Types_UIConfigSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_UIConfigSpecV1? = nil
}

/// UIConfigSpecV1 is the specification for a UIConfig
struct Types_UIConfigSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scrollbackLines: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InstallerV1 represents an installer script resource. Used to
/// provide a script to install teleport on discovered nodes.
struct Types_InstallerV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the resource kind.
  var kind: String = String()

  /// SubKind is an optional resource subkind. Currently unused for this resource.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the resource metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is the resource spec.
  var spec: Types_InstallerSpecV1 {
    get {return _spec ?? Types_InstallerSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_InstallerSpecV1? = nil
}

/// InstallerSpecV1 is the specification for an Installer
struct Types_InstallerSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Script represents the contents of a installer shell script
  var script: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InstallerV1List represents a list of installer resources.
struct Types_InstallerV1List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Installers is a list of installer resources.
  var installers: [Types_InstallerV1] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SortBy defines a sort criteria.
struct Types_SortBy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IsDesc is a sort direction flag where if true the direction is descending, else ascending.
  var isDesc: Bool = false

  /// Field is the name of an objects field to sort by.
  var field: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ConnectionDiagnosticV1 is the result of testing a connection.
/// When setting up a new resource in Teleport, it's useful to know if we can connect to it.
/// This can be done using the test connection feature.
/// The user can then receive the result as feedback using the UI
struct Types_ConnectionDiagnosticV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the resource spec.
  var spec: Types_ConnectionDiagnosticSpecV1 {
    get {return _spec ?? Types_ConnectionDiagnosticSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_ConnectionDiagnosticSpecV1? = nil
}

/// ConnectionDiagnosticSpecV1 is the ConnectionDiagnostic Spec.
/// It contains the result of testing a connection.
/// It has the overall result of the connection and then a list of traces.
/// Each trace contains checkpoints of the connection attempt and its result.
struct Types_ConnectionDiagnosticSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Success describes whether the connection was a success or a failure.
  var success: Bool = false

  /// Message may contain some user friendly message to let the user know whether it was
  /// successful or a failure.
  var message: String = String()

  /// Traces contain a list of checkpoints defined by
  var traces: [Types_ConnectionDiagnosticTrace] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ConnectionDiagnosticTrace describes a trace of a connection diagnostic
struct Types_ConnectionDiagnosticTrace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Types_ConnectionDiagnosticTrace.TraceType = .unspecified

  var status: Types_ConnectionDiagnosticTrace.StatusType = .statusUnspecified

  /// Details contains a User friendly message of the check's result.
  var details: String = String()

  /// Error contains the low level error message in case of a failure.
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TraceType is an identification of the checkpoint.
  enum TraceType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0

    /// UNKNOWN_ERROR is used when we don't know the error.
    /// It's not always possible to offer guidance based on the received error.
    /// This trace type should be used when the error is too generic given the context we
    /// have.
    case unknownError // = 1

    /// RBAC_NODE is for RBAC checks for the node.
    case rbacNode // = 2

    /// CONNECTIVITY is for network connectivity checks.
    case connectivity // = 3

    /// RBAC_PRINCIPAL is used when checking if the principal is allowed per RBAC rules.
    case rbacPrincipal // = 4

    /// NODE_PRINCIPAL is used when checking if the Node has the requested principal.
    case nodePrincipal // = 5

    /// RBAC_KUBE is for RBAC checks to kubernetes the cluster.
    case rbacKube // = 6

    /// KUBE_PRINCIPAL is used when checking if the Kube Cluster has at least one user principals.
    case kubePrincipal // = 7

    /// RBAC_DATABASE is for RBAC checks to database access (db_labels).
    case rbacDatabase // = 8

    /// RBAC_DATABASE_LOGIN is for RBAC checks to database login (db_name and db_user).
    case rbacDatabaseLogin // = 9

    /// DATABASE_DB_USER is used when checking whether the Database has the requested Database User.
    case databaseDbUser // = 10

    /// DATABASE_DB_NAME is used when checking whether the Database has the requested Database Name.
    case databaseDbName // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unknownError
      case 2: self = .rbacNode
      case 3: self = .connectivity
      case 4: self = .rbacPrincipal
      case 5: self = .nodePrincipal
      case 6: self = .rbacKube
      case 7: self = .kubePrincipal
      case 8: self = .rbacDatabase
      case 9: self = .rbacDatabaseLogin
      case 10: self = .databaseDbUser
      case 11: self = .databaseDbName
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unknownError: return 1
      case .rbacNode: return 2
      case .connectivity: return 3
      case .rbacPrincipal: return 4
      case .nodePrincipal: return 5
      case .rbacKube: return 6
      case .kubePrincipal: return 7
      case .rbacDatabase: return 8
      case .rbacDatabaseLogin: return 9
      case .databaseDbUser: return 10
      case .databaseDbName: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// StatusType describes whether this was a success or a failure.
  enum StatusType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case statusUnspecified // = 0
    case success // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .statusUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .statusUnspecified
      case 1: self = .success
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .statusUnspecified: return 0
      case .success: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Types_ConnectionDiagnosticTrace.TraceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_ConnectionDiagnosticTrace.TraceType] = [
    .unspecified,
    .unknownError,
    .rbacNode,
    .connectivity,
    .rbacPrincipal,
    .nodePrincipal,
    .rbacKube,
    .kubePrincipal,
    .rbacDatabase,
    .rbacDatabaseLogin,
    .databaseDbUser,
    .databaseDbName,
  ]
}

extension Types_ConnectionDiagnosticTrace.StatusType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_ConnectionDiagnosticTrace.StatusType] = [
    .statusUnspecified,
    .success,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// DatabaseServiceV1 is the representation of a DatabaseService (agent) process.
struct Types_DatabaseServiceV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the resource spec.
  var spec: Types_DatabaseServiceSpecV1 {
    get {return _spec ?? Types_DatabaseServiceSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_DatabaseServiceSpecV1? = nil
}

/// DatabaseServiceSpecV1 is the DatabaseService Spec.
struct Types_DatabaseServiceSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ResourceMatchers is the configured match for Database resources.
  var resourceMatchers: [Types_DatabaseResourceMatcher] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DatabaseResourceMatcher is a set of properties that is used to match on resources.
struct Types_DatabaseResourceMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var labels: Wrappers_LabelValues {
    get {return _labels ?? Wrappers_LabelValues()}
    set {_labels = newValue}
  }
  /// Returns true if `labels` has been explicitly set.
  var hasLabels: Bool {return self._labels != nil}
  /// Clears the value of `labels`. Subsequent reads from it will return its default value.
  mutating func clearLabels() {self._labels = nil}

  var aws: Types_ResourceMatcherAWS {
    get {return _aws ?? Types_ResourceMatcherAWS()}
    set {_aws = newValue}
  }
  /// Returns true if `aws` has been explicitly set.
  var hasAws: Bool {return self._aws != nil}
  /// Clears the value of `aws`. Subsequent reads from it will return its default value.
  mutating func clearAws() {self._aws = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _labels: Wrappers_LabelValues? = nil
  fileprivate var _aws: Types_ResourceMatcherAWS? = nil
}

/// ResourceMatcherAWS contains AWS specific settings for resource matcher.
struct Types_ResourceMatcherAWS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AssumeRoleARN is an optional AWS role ARN to assume when accessing a database.
  var assumeRoleArn: String = String()

  /// ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
  var externalID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClusterAlert is a cluster-level alert message.
struct Types_ClusterAlert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var spec: Types_ClusterAlertSpec {
    get {return _spec ?? Types_ClusterAlertSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_ClusterAlertSpec? = nil
}

/// ClusterAlertSpec is a cluster alert specification.
struct Types_ClusterAlertSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Severity represents how problematic/urgent the alert is.
  var severity: Types_AlertSeverity = .low

  /// Message is the user-facing message associated with the alert.
  var message: String = String()

  /// Created is the time at which the alert was generated.
  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// GetClusterAlertsRequest matches cluster alerts.
struct Types_GetClusterAlertsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Severity is an optional minimum severity.
  var severity: Types_AlertSeverity = .low

  /// AlertID optionally specifies the ID of the alert being requested.
  var alertID: String = String()

  /// Labels is an optional label selector.
  var labels: Dictionary<String,String> = [:]

  /// WithSuperseded includes superseded alerts in the output of the request.
  var withSuperseded: Bool = false

  /// WithAcknowledged includes acknowledged alerts in the output of the request.
  var withAcknowledged: Bool = false

  /// WithUntargeted requests that alerts be included even if they are not specifically
  /// targeted toward the caller. This has no effect unless the caller has `cluster_alert:list`.
  var withUntargeted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AlertAcknowledgement marks a cluster alert as having been "acknowledged".
/// This causes the alert to no longer be displayed in 'tsh login', UI banners,
/// etc. Acknowledgements must have an expiry and a message describing why the
/// alert can be considered acknowledged.
struct Types_AlertAcknowledgement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AlertID is the ID of the alert being acknowledged.
  var alertID: String = String()

  /// Reason describes the reason why the alert can be considered
  /// acknowledged (e.g. 'alice will fix next week').
  var reason: String = String()

  /// Expires is the time after which the acknowledgement expires.
  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Release correspond to a Teleport Enterprise releases
struct Types_Release {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NotesMD is the notes of the release in markdown
  var notesMd: String = String()

  /// Product is the release product, teleport or teleport-ent
  var product: String = String()

  /// ReleaseID is the ID of the product
  var releaseID: String = String()

  /// Status is the status of the release
  var status: String = String()

  /// Version is the version of the release
  var version: String = String()

  /// Assets is a list of assets related to the release
  var assets: [Types_Asset] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Asset represents a release asset
struct Types_Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arch is the architecture of the asset
  var arch: String = String()

  /// Description is the description of the asset
  var description_p: String = String()

  /// Name is the name of the asset
  var name: String = String()

  /// OS is which OS the asset is built for
  var os: String = String()

  /// SHA256 is the sha256 of the asset
  var sha256: String = String()

  /// Size is the size of the release in bytes
  var assetSize: Int64 = 0

  /// DisplaySize is the human-readable size of the asset
  var displaySize: String = String()

  /// ReleaseIDs is a list of releases that have the asset included
  var releaseIds: [String] = []

  /// PublicURL is the public URL used to download the asset
  var publicURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Plugin describes a single instance of a Teleport Plugin
struct Types_PluginV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// kind is the plugin resource kind.
  var kind: String {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// sub_kind is an optional resource subkind.
  var subKind: String {
    get {return _storage._subKind}
    set {_uniqueStorage()._subKind = newValue}
  }

  /// version is the resource version.
  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// metadata is the resource metadata.
  var metadata: Types_Metadata {
    get {return _storage._metadata ?? Types_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var spec: Types_PluginSpecV1 {
    get {return _storage._spec ?? Types_PluginSpecV1()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var status: Types_PluginStatusV1 {
    get {return _storage._status ?? Types_PluginStatusV1()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// credentials are "live" credentials to the 3rd party API.
  /// These are considered secrets.
  var credentials: Types_PluginCredentialsV1 {
    get {return _storage._credentials ?? Types_PluginCredentialsV1()}
    set {_uniqueStorage()._credentials = newValue}
  }
  /// Returns true if `credentials` has been explicitly set.
  var hasCredentials: Bool {return _storage._credentials != nil}
  /// Clears the value of `credentials`. Subsequent reads from it will return its default value.
  mutating func clearCredentials() {_uniqueStorage()._credentials = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Types_PluginSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// settings contain provider-specific plugin options.
  var settings: Types_PluginSpecV1.OneOf_Settings? = nil

  /// Settings for the Slack access plugin
  var slackAccessPlugin: Types_PluginSlackAccessSettings {
    get {
      if case .slackAccessPlugin(let v)? = settings {return v}
      return Types_PluginSlackAccessSettings()
    }
    set {settings = .slackAccessPlugin(newValue)}
  }

  /// Settings for the Opsgenie access plugin
  var opsgenie: Types_PluginOpsgenieAccessSettings {
    get {
      if case .opsgenie(let v)? = settings {return v}
      return Types_PluginOpsgenieAccessSettings()
    }
    set {settings = .opsgenie(newValue)}
  }

  /// Settings for OpenAI plugin
  var openai: Types_PluginOpenAISettings {
    get {
      if case .openai(let v)? = settings {return v}
      return Types_PluginOpenAISettings()
    }
    set {settings = .openai(newValue)}
  }

  /// Settings for the Okta plugin
  var okta: Types_PluginOktaSettings {
    get {
      if case .okta(let v)? = settings {return v}
      return Types_PluginOktaSettings()
    }
    set {settings = .okta(newValue)}
  }

  /// Settings for device trust jamf plugin
  var jamf: Types_PluginJamfSettings {
    get {
      if case .jamf(let v)? = settings {return v}
      return Types_PluginJamfSettings()
    }
    set {settings = .jamf(newValue)}
  }

  /// Settings for the PagerDuty plugin
  var pagerDuty: Types_PluginPagerDutySettings {
    get {
      if case .pagerDuty(let v)? = settings {return v}
      return Types_PluginPagerDutySettings()
    }
    set {settings = .pagerDuty(newValue)}
  }

  /// Settings for the Mattermost plugin
  var mattermost: Types_PluginMattermostSettings {
    get {
      if case .mattermost(let v)? = settings {return v}
      return Types_PluginMattermostSettings()
    }
    set {settings = .mattermost(newValue)}
  }

  /// Settings for the JIRA plugin
  var jira: Types_PluginJiraSettings {
    get {
      if case .jira(let v)? = settings {return v}
      return Types_PluginJiraSettings()
    }
    set {settings = .jira(newValue)}
  }

  /// Settings for the Discord plugin
  var discord: Types_PluginDiscordSettings {
    get {
      if case .discord(let v)? = settings {return v}
      return Types_PluginDiscordSettings()
    }
    set {settings = .discord(newValue)}
  }

  /// Settings for the ServiceNow plugin
  var serviceNow: Types_PluginServiceNowSettings {
    get {
      if case .serviceNow(let v)? = settings {return v}
      return Types_PluginServiceNowSettings()
    }
    set {settings = .serviceNow(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// settings contain provider-specific plugin options.
  enum OneOf_Settings: Equatable {
    /// Settings for the Slack access plugin
    case slackAccessPlugin(Types_PluginSlackAccessSettings)
    /// Settings for the Opsgenie access plugin
    case opsgenie(Types_PluginOpsgenieAccessSettings)
    /// Settings for OpenAI plugin
    case openai(Types_PluginOpenAISettings)
    /// Settings for the Okta plugin
    case okta(Types_PluginOktaSettings)
    /// Settings for device trust jamf plugin
    case jamf(Types_PluginJamfSettings)
    /// Settings for the PagerDuty plugin
    case pagerDuty(Types_PluginPagerDutySettings)
    /// Settings for the Mattermost plugin
    case mattermost(Types_PluginMattermostSettings)
    /// Settings for the JIRA plugin
    case jira(Types_PluginJiraSettings)
    /// Settings for the Discord plugin
    case discord(Types_PluginDiscordSettings)
    /// Settings for the ServiceNow plugin
    case serviceNow(Types_PluginServiceNowSettings)

  #if !swift(>=4.1)
    static func ==(lhs: Types_PluginSpecV1.OneOf_Settings, rhs: Types_PluginSpecV1.OneOf_Settings) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.slackAccessPlugin, .slackAccessPlugin): return {
        guard case .slackAccessPlugin(let l) = lhs, case .slackAccessPlugin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.opsgenie, .opsgenie): return {
        guard case .opsgenie(let l) = lhs, case .opsgenie(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openai, .openai): return {
        guard case .openai(let l) = lhs, case .openai(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.okta, .okta): return {
        guard case .okta(let l) = lhs, case .okta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jamf, .jamf): return {
        guard case .jamf(let l) = lhs, case .jamf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pagerDuty, .pagerDuty): return {
        guard case .pagerDuty(let l) = lhs, case .pagerDuty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mattermost, .mattermost): return {
        guard case .mattermost(let l) = lhs, case .mattermost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jira, .jira): return {
        guard case .jira(let l) = lhs, case .jira(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discord, .discord): return {
        guard case .discord(let l) = lhs, case .discord(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serviceNow, .serviceNow): return {
        guard case .serviceNow(let l) = lhs, case .serviceNow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Types_PluginSlackAccessSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fallbackChannel: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_PluginOpsgenieAccessSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Priority to create Opsgenie alerts with
  var priority: String = String()

  /// List of tags to be added to alerts created in Opsgenie
  var alertTags: [String] = []

  /// Default on-call schedules to check if none are provided in the access request annotations
  var defaultSchedules: [String] = []

  /// APIEndpoint is the address of Opsgenie API.
  var apiEndpoint: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginServiceNowSettings are the settings for the serviceNow plugin
struct Types_PluginServiceNowSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ApiEndpoint is the ServiceNow API endpoint.
  var apiEndpoint: String = String()

  /// Username is the ServiceNow API username.
  var username: String = String()

  /// Password is the ServiceNow API password.
  var password: String = String()

  /// CloseCode is the close code that ServiceNow incidents will use.
  var closeCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_PluginPagerDutySettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UserEmail is the email address of the PagerDuty user that will be
  /// listed as the reporter source of incidents, comments, etc
  /// within PagerDuty. Should usually be the same user the API key
  /// represents.
  var userEmail: String = String()

  /// APIEndpoint is the address of PagerDuty API.
  var apiEndpoint: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_PluginJiraSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ServerURL is the address of the target JIRA Server instance.
  var serverURL: String = String()

  /// ProjectKey is the key of the Jira project that will receive
  /// notifications and issues from the plugin.
  var projectKey: String = String()

  /// IssueType is the type of Jira Issue that the plugin will create
  var issueType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Defines settings for the OpenAI plugin. Currently there are no settings.
struct Types_PluginOpenAISettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Defines settings for the Mattermost plugin.
struct Types_PluginMattermostSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// serverURL is the URL to access Mattermost.
  var serverURL: String = String()

  /// team is the Mattermost workspace.
  var team: String = String()

  /// channel is the Mattermost channel in the workspace
  /// (team) to send notifications to.
  var channel: String = String()

  /// report_to_email is an optional email address of a Mattermost user
  /// to notify via a direct message when the plugin receives an
  /// Access Request event.
  var reportToEmail: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Defines settings for Jamf plugin.
struct Types_PluginJamfSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Jamf service spec
  var jamfSpec: Types_JamfSpecV1 {
    get {return _jamfSpec ?? Types_JamfSpecV1()}
    set {_jamfSpec = newValue}
  }
  /// Returns true if `jamfSpec` has been explicitly set.
  var hasJamfSpec: Bool {return self._jamfSpec != nil}
  /// Clears the value of `jamfSpec`. Subsequent reads from it will return its default value.
  mutating func clearJamfSpec() {self._jamfSpec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _jamfSpec: Types_JamfSpecV1? = nil
}

/// Defines settings for the Okta plugin.
struct Types_PluginOktaSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OrgUrl is the Okta organization URL to use for API communication.
  var orgURL: String = String()

  /// EnableUserSync controls the user sync in the Okta integration service.
  var enableUserSync: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Defines a set of discord channel IDs
struct Types_DiscordChannels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var channelIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Defines settings for the discord plugin
struct Types_PluginDiscordSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RoleToRecipients maps Teleport roles (by name) to the set of Discord
  /// channel IDs that will receive notifications and requests regarding that
  /// that Role.
  var roleToRecipients: Dictionary<String,Types_DiscordChannels> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_PluginBootstrapCredentialsV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credentials: Types_PluginBootstrapCredentialsV1.OneOf_Credentials? = nil

  var oauth2AuthorizationCode: Types_PluginOAuth2AuthorizationCodeCredentials {
    get {
      if case .oauth2AuthorizationCode(let v)? = credentials {return v}
      return Types_PluginOAuth2AuthorizationCodeCredentials()
    }
    set {credentials = .oauth2AuthorizationCode(newValue)}
  }

  var bearerToken: Types_PluginBearerTokenCredentials {
    get {
      if case .bearerToken(let v)? = credentials {return v}
      return Types_PluginBearerTokenCredentials()
    }
    set {credentials = .bearerToken(newValue)}
  }

  var idSecret: Types_PluginIdSecretCredential {
    get {
      if case .idSecret(let v)? = credentials {return v}
      return Types_PluginIdSecretCredential()
    }
    set {credentials = .idSecret(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Credentials: Equatable {
    case oauth2AuthorizationCode(Types_PluginOAuth2AuthorizationCodeCredentials)
    case bearerToken(Types_PluginBearerTokenCredentials)
    case idSecret(Types_PluginIdSecretCredential)

  #if !swift(>=4.1)
    static func ==(lhs: Types_PluginBootstrapCredentialsV1.OneOf_Credentials, rhs: Types_PluginBootstrapCredentialsV1.OneOf_Credentials) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.oauth2AuthorizationCode, .oauth2AuthorizationCode): return {
        guard case .oauth2AuthorizationCode(let l) = lhs, case .oauth2AuthorizationCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bearerToken, .bearerToken): return {
        guard case .bearerToken(let l) = lhs, case .bearerToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.idSecret, .idSecret): return {
        guard case .idSecret(let l) = lhs, case .idSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// PluginIdSecretCredential can be OAuth2-like client_id and client_secret or username and password.
struct Types_PluginIdSecretCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var secret: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Types_PluginOAuth2AuthorizationCodeCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authorizationCode: String = String()

  var redirectUri: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginStatus is the user-facing status for the plugin instance.
struct Types_PluginStatusV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Types_PluginStatusCode = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginCredentialsV1 represents "live" credentials
/// that are used by the plugin to authenticate to the 3rd party API.
struct Types_PluginCredentialsV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credentials: Types_PluginCredentialsV1.OneOf_Credentials? = nil

  var oauth2AccessToken: Types_PluginOAuth2AccessTokenCredentials {
    get {
      if case .oauth2AccessToken(let v)? = credentials {return v}
      return Types_PluginOAuth2AccessTokenCredentials()
    }
    set {credentials = .oauth2AccessToken(newValue)}
  }

  var bearerToken: Types_PluginBearerTokenCredentials {
    get {
      if case .bearerToken(let v)? = credentials {return v}
      return Types_PluginBearerTokenCredentials()
    }
    set {credentials = .bearerToken(newValue)}
  }

  var idSecret: Types_PluginIdSecretCredential {
    get {
      if case .idSecret(let v)? = credentials {return v}
      return Types_PluginIdSecretCredential()
    }
    set {credentials = .idSecret(newValue)}
  }

  var staticCredentialsRef: Types_PluginStaticCredentialsRef {
    get {
      if case .staticCredentialsRef(let v)? = credentials {return v}
      return Types_PluginStaticCredentialsRef()
    }
    set {credentials = .staticCredentialsRef(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Credentials: Equatable {
    case oauth2AccessToken(Types_PluginOAuth2AccessTokenCredentials)
    case bearerToken(Types_PluginBearerTokenCredentials)
    case idSecret(Types_PluginIdSecretCredential)
    case staticCredentialsRef(Types_PluginStaticCredentialsRef)

  #if !swift(>=4.1)
    static func ==(lhs: Types_PluginCredentialsV1.OneOf_Credentials, rhs: Types_PluginCredentialsV1.OneOf_Credentials) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.oauth2AccessToken, .oauth2AccessToken): return {
        guard case .oauth2AccessToken(let l) = lhs, case .oauth2AccessToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bearerToken, .bearerToken): return {
        guard case .bearerToken(let l) = lhs, case .bearerToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.idSecret, .idSecret): return {
        guard case .idSecret(let l) = lhs, case .idSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.staticCredentialsRef, .staticCredentialsRef): return {
        guard case .staticCredentialsRef(let l) = lhs, case .staticCredentialsRef(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Types_PluginOAuth2AccessTokenCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accessToken: String = String()

  var refreshToken: String = String()

  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return self._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {self._expires = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Types_PluginBearerTokenCredentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token is the literal bearer token to be submitted to the 3rd-party API provider.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginStaticCredentialsRef is a reference to plugin static credentials by labels.
struct Types_PluginStaticCredentialsRef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Labels is the set of labels to use to match against a set of static credentials.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginList represents a list of plugin resources
struct Types_PluginListV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Plugins is a list of plugin resources.
  var plugins: [Types_PluginV1] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginStaticCredentialsV1 is a representation of static credentials for plugins.
struct Types_PluginStaticCredentialsV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header for the plugin static credentials object.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec contains the actual credentials for the object.
  var spec: Types_PluginStaticCredentialsSpecV1 {
    get {return _spec ?? Types_PluginStaticCredentialsSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_PluginStaticCredentialsSpecV1? = nil
}

/// PluginStaticCredentialsSpecV1 is the specification for the static credentials object.
struct Types_PluginStaticCredentialsSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credentials: Types_PluginStaticCredentialsSpecV1.OneOf_Credentials? = nil

  var apitoken: String {
    get {
      if case .apitoken(let v)? = credentials {return v}
      return String()
    }
    set {credentials = .apitoken(newValue)}
  }

  var basicAuth: Types_PluginStaticCredentialsBasicAuth {
    get {
      if case .basicAuth(let v)? = credentials {return v}
      return Types_PluginStaticCredentialsBasicAuth()
    }
    set {credentials = .basicAuth(newValue)}
  }

  var oauthClientSecret: Types_PluginStaticCredentialsOAuthClientSecret {
    get {
      if case .oauthClientSecret(let v)? = credentials {return v}
      return Types_PluginStaticCredentialsOAuthClientSecret()
    }
    set {credentials = .oauthClientSecret(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Credentials: Equatable {
    case apitoken(String)
    case basicAuth(Types_PluginStaticCredentialsBasicAuth)
    case oauthClientSecret(Types_PluginStaticCredentialsOAuthClientSecret)

  #if !swift(>=4.1)
    static func ==(lhs: Types_PluginStaticCredentialsSpecV1.OneOf_Credentials, rhs: Types_PluginStaticCredentialsSpecV1.OneOf_Credentials) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.apitoken, .apitoken): return {
        guard case .apitoken(let l) = lhs, case .apitoken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.basicAuth, .basicAuth): return {
        guard case .basicAuth(let l) = lhs, case .basicAuth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oauthClientSecret, .oauthClientSecret): return {
        guard case .oauthClientSecret(let l) = lhs, case .oauthClientSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// PluginStaticCredentialsBasicAuth represents username and password credentials for a plugin.
struct Types_PluginStaticCredentialsBasicAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Username is the username to use for basic auth.
  var username: String = String()

  /// Password is the password to use for basic auth.
  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PluginStaticCredentialsOAuthClientSecret represents an oauth client id and secret.
struct Types_PluginStaticCredentialsOAuthClientSecret {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientId is the client ID to use for OAuth client secret.
  var clientID: String = String()

  /// ClientSecret is the client secret to use.
  var clientSecret: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SAMLIdPServiceProviderV1 is the representation of a SAML IdP service provider.
struct Types_SAMLIdPServiceProviderV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header for the SAML IdP service provider.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the SAML IdP service provider spec.
  var spec: Types_SAMLIdPServiceProviderSpecV1 {
    get {return _spec ?? Types_SAMLIdPServiceProviderSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_SAMLIdPServiceProviderSpecV1? = nil
}

/// SAMLIdPServiceProviderSpecV1 is the SAMLIdPServiceProviderV1 resource spec.
struct Types_SAMLIdPServiceProviderSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// EntityDescriptor is the entity descriptor for the service provider
  var entityDescriptor: String = String()

  /// EntityID is the entity ID for the entity descriptor. This ID is checked that it matches
  /// the entity ID in the entity descriptor at upsert time to avoid having to parse the
  /// XML blob in the entity descriptor every time we need to use this resource.
  var entityID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// IdPOptions specify options related to access Teleport IdPs.
struct Types_IdPOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SAML are options related to the Teleport SAML IdP.
  var saml: Types_IdPSAMLOptions {
    get {return _saml ?? Types_IdPSAMLOptions()}
    set {_saml = newValue}
  }
  /// Returns true if `saml` has been explicitly set.
  var hasSaml: Bool {return self._saml != nil}
  /// Clears the value of `saml`. Subsequent reads from it will return its default value.
  mutating func clearSaml() {self._saml = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _saml: Types_IdPSAMLOptions? = nil
}

/// IdPSAMLOptions specifies options related to accessing the Teleport SAML IdP.
struct Types_IdPSAMLOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enabled is set to true if this option allows access to the Teleport SAML IdP.
  var enabled: Types_BoolValue {
    get {return _enabled ?? Types_BoolValue()}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enabled: Types_BoolValue? = nil
}

/// KubernetesResourceV1 represents a Kubernetes resource.
struct Types_KubernetesResourceV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind
  var kind: String = String()

  /// SubKind is an optional resource sub kind, used in some resources
  var subKind: String = String()

  /// Version is version
  var version: String = String()

  /// Metadata is KubernetesResourceV1 metadata
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec contains the Kubernetes resource data.
  var spec: Types_KubernetesResourceSpecV1 {
    get {return _spec ?? Types_KubernetesResourceSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_KubernetesResourceSpecV1? = nil
}

/// KubernetesResourceSpecV1 is the Kubernetes resource spec.
struct Types_KubernetesResourceSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace is the resource namespace.
  var namespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ClusterMaintenanceConfigV1 is a config singleton used to configure infrequent
/// cluster maintenance operations.
struct Types_ClusterMaintenanceConfigV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var spec: Types_ClusterMaintenanceConfigSpecV1 {
    get {return _spec ?? Types_ClusterMaintenanceConfigSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  /// Nonce is used to protect against concurrent modification of the maintenance
  /// window. Clients should treat nonces as opaque.
  var nonce: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_ClusterMaintenanceConfigSpecV1? = nil
}

/// ClusterMaintenanceConfigSpecV1 encodes the parameters of the upgrade window config object.
struct Types_ClusterMaintenanceConfigSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AgentUpgrades encodes the agent upgrade window.
  var agentUpgrades: Types_AgentUpgradeWindow {
    get {return _agentUpgrades ?? Types_AgentUpgradeWindow()}
    set {_agentUpgrades = newValue}
  }
  /// Returns true if `agentUpgrades` has been explicitly set.
  var hasAgentUpgrades: Bool {return self._agentUpgrades != nil}
  /// Clears the value of `agentUpgrades`. Subsequent reads from it will return its default value.
  mutating func clearAgentUpgrades() {self._agentUpgrades = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _agentUpgrades: Types_AgentUpgradeWindow? = nil
}

/// AgentUpgradeWindow is the config object used to determine upcoming agent
/// upgrade windows.
struct Types_AgentUpgradeWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// UTCStartHour is the start hour of the maintenance window in UTC.
  var utcstartHour: UInt32 = 0

  /// Weekdays is an optional list of weekdays. If not specified, an agent upgrade window
  /// occurs every day.
  var weekdays: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ScheduledAgentUpgradeWindow is a derived value representing a single
/// upgrade window. Upgraders deal with discrete start/end times, so we use the
/// agent upgrade window configuration object to generate a sequence of specific
/// scheduled windows.
struct Types_ScheduledAgentUpgradeWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start is the start time of the upgrade window.
  var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  /// Stop is the stop time of the upgrade window.
  var stop: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _stop ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_stop = newValue}
  }
  /// Returns true if `stop` has been explicitly set.
  var hasStop: Bool {return self._stop != nil}
  /// Clears the value of `stop`. Subsequent reads from it will return its default value.
  mutating func clearStop() {self._stop = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _stop: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// AgentUpgradeSchedule is the canonical representation of upcoming
/// agent upgrade windows as generated by the AgentUpgradeWindow config object.
struct Types_AgentUpgradeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Windows is the list of upcoming windows.
  var windows: [Types_ScheduledAgentUpgradeWindow] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UserGroupV1 is a representation of an externally sourced user group.
struct Types_UserGroupV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header for the user group.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the user group resource spec.
  var spec: Types_UserGroupSpecV1 {
    get {return _spec ?? Types_UserGroupSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_UserGroupSpecV1? = nil
}

/// UserGroupSpecV1 is the specification of a user group.
struct Types_UserGroupSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Applications are a list of application IDs belonging to this user group.
  var applications: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OktaImportRuleSpecV1 is a Okta import rule specification.
struct Types_OktaImportRuleSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Priority represents the priority of the rule application. Lower numbered rules will be applied first.
  var priority: Int32 = 0

  /// Mappings is a list of matches that will map match conditions to labels.
  var mappings: [Types_OktaImportRuleMappingV1] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OktaImportRuleMappingV1 is a list of matches that map match rules to labels.
struct Types_OktaImportRuleMappingV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Match is a set of matching rules for this mapping. If any of these match, then the mapping will be applied.
  var match: [Types_OktaImportRuleMatchV1] = []

  /// AddLabels specifies which labels to add if any of the previous matches match.
  var addLabels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OktaImportRuleV1 is a representation of labeling rules for importing of Okta objects.
struct Types_OktaImportRuleV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header for the SAML IdP service provider.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is the specification for the Okta import rule.
  var spec: Types_OktaImportRuleSpecV1 {
    get {return _spec ?? Types_OktaImportRuleSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_OktaImportRuleSpecV1? = nil
}

/// OktaImportRuleMatchV1 is a match rule for a mapping.
struct Types_OktaImportRuleMatchV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AppIDs is a list of app IDs to match against.
  var appIds: [String] = []

  /// GroupIDs is a list of group IDs to match against.
  var groupIds: [String] = []

  /// AppNameRegexes is a list of regexes to match against app names.
  var appNameRegexes: [String] = []

  /// GroupNameRegexes is a list of regexes to match against group names.
  var groupNameRegexes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OktaAssignmentV1 is a representation of an action or set of actions taken by Teleport to assign Okta users to applications or groups.
struct Types_OktaAssignmentV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header for the Okta assignment.
  var header: Types_ResourceHeader {
    get {return _storage._header ?? Types_ResourceHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// Spec is the specification for the Okta assignment.
  var spec: Types_OktaAssignmentSpecV1 {
    get {return _storage._spec ?? Types_OktaAssignmentSpecV1()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {_uniqueStorage()._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OktaAssignmentSpecV1 is a Okta assignment specification.
struct Types_OktaAssignmentSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User is the user that these actions will be applied to.
  var user: String = String()

  /// Targets is a list of Okta targets to take on a user.
  var targets: [Types_OktaAssignmentTargetV1] = []

  /// CleanupTime is an optional field that notes when the assignment should be cleaned up.
  /// If absent, the assignment will never be cleaned up.
  var cleanupTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _cleanupTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_cleanupTime = newValue}
  }
  /// Returns true if `cleanupTime` has been explicitly set.
  var hasCleanupTime: Bool {return self._cleanupTime != nil}
  /// Clears the value of `cleanupTime`. Subsequent reads from it will return its default value.
  mutating func clearCleanupTime() {self._cleanupTime = nil}

  /// Status is the status of the assignment.
  var status: Types_OktaAssignmentSpecV1.OktaAssignmentStatus = .unknown

  /// LastTransition is an optional field that notes when the last state transition
  /// occurred for this action. If absent, this object has never transitioned.
  var lastTransition: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastTransition ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastTransition = newValue}
  }
  /// Returns true if `lastTransition` has been explicitly set.
  var hasLastTransition: Bool {return self._lastTransition != nil}
  /// Clears the value of `lastTransition`. Subsequent reads from it will return its default value.
  mutating func clearLastTransition() {self._lastTransition = nil}

  /// Finalized is set when the assignment has been properly cleaned up.
  var finalized: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// OktaAssignmentStatus represents the status of an Okta assignment.
  enum OktaAssignmentStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// UNKNOWN indicates the status is not set.
    case unknown // = 0

    /// PENDING indicates the action has not yet been applied.
    case pending // = 1

    /// PROCESSSING indicates that the assignment is being applied.
    case processing // = 2

    /// SUCCESSFUL indicates the action was applied successfully.
    case successful // = 3

    /// FAILED indicates the action was not applied successfully. It will be retried.
    case failed // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .pending
      case 2: self = .processing
      case 3: self = .successful
      case 4: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .pending: return 1
      case .processing: return 2
      case .successful: return 3
      case .failed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _cleanupTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastTransition: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Types_OktaAssignmentSpecV1.OktaAssignmentStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_OktaAssignmentSpecV1.OktaAssignmentStatus] = [
    .unknown,
    .pending,
    .processing,
    .successful,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// OktaAssignmentTargetV1 is a target of an Okta assignment.
struct Types_OktaAssignmentTargetV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type is the type of Okta resource this assignment is targeting.
  var type: Types_OktaAssignmentTargetV1.OktaAssignmentTargetType = .unknown

  /// ID is the ID of the Okta resource that's being targeted.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// OktaAssignmentTargetType is the type of Okta object that an assignment is targeting.
  enum OktaAssignmentTargetType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// UNKNOWN indicates the target is unknown.
    case unknown // = 0

    /// APPLICATION indicates the target is an application.
    case application // = 1

    /// GROUP indicates the target is a group.
    case group // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .application
      case 2: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .application: return 1
      case .group: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Types_OktaAssignmentTargetV1.OktaAssignmentTargetType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Types_OktaAssignmentTargetV1.OktaAssignmentTargetType] = [
    .unknown,
    .application,
    .group,
  ]
}

#endif  // swift(>=4.2)

/// IntegrationV1 represents a connection between Teleport and some other 3rd party system.
/// This connection allows API access to that service from Teleport.
/// Each Integration instance must have a SubKind defined which identifies the external system.
struct Types_IntegrationV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Spec is an Integration specification.
  var spec: Types_IntegrationSpecV1 {
    get {return _spec ?? Types_IntegrationSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _spec: Types_IntegrationSpecV1? = nil
}

/// IntegrationSpecV1 contains properties of all the supported integrations.
struct Types_IntegrationSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subKindSpec: Types_IntegrationSpecV1.OneOf_SubKindSpec? = nil

  /// AWSOIDC contains the specific fields to handle the AWS OIDC Integration subkind
  var awsoidc: Types_AWSOIDCIntegrationSpecV1 {
    get {
      if case .awsoidc(let v)? = subKindSpec {return v}
      return Types_AWSOIDCIntegrationSpecV1()
    }
    set {subKindSpec = .awsoidc(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubKindSpec: Equatable {
    /// AWSOIDC contains the specific fields to handle the AWS OIDC Integration subkind
    case awsoidc(Types_AWSOIDCIntegrationSpecV1)

  #if !swift(>=4.1)
    static func ==(lhs: Types_IntegrationSpecV1.OneOf_SubKindSpec, rhs: Types_IntegrationSpecV1.OneOf_SubKindSpec) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.awsoidc, .awsoidc): return {
        guard case .awsoidc(let l) = lhs, case .awsoidc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

/// AWSOIDCIntegrationSpecV1 contains the spec properties for the AWS OIDC SubKind Integration.
struct Types_AWSOIDCIntegrationSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RoleARN contains the Role ARN used to set up the Integration.
  /// This is the AWS Role that Teleport will use to issue tokens for API Calls.
  var roleArn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// HeadlessAuthentication holds data for an ongoing headless authentication attempt.
struct Types_HeadlessAuthentication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// User is a teleport user name.
  var user: String = String()

  /// PublicKey is an ssh public key to sign in case of successful auth.
  var publicKey: Data = Data()

  /// State is the headless authentication request state.
  var state: Types_HeadlessAuthenticationState = .unspecified

  /// MFADevice is the mfa device used to approve the request in case of successful auth.
  var mfaDevice: Types_MFADevice {
    get {return _mfaDevice ?? Types_MFADevice()}
    set {_mfaDevice = newValue}
  }
  /// Returns true if `mfaDevice` has been explicitly set.
  var hasMfaDevice: Bool {return self._mfaDevice != nil}
  /// Clears the value of `mfaDevice`. Subsequent reads from it will return its default value.
  mutating func clearMfaDevice() {self._mfaDevice = nil}

  /// ClientIPAddress is the IP address of the client being authenticated.
  var clientIpAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
  fileprivate var _mfaDevice: Types_MFADevice? = nil
}

/// WatchKind specifies resource kind to watch
/// When adding fields to this struct, make sure to review/update WatchKind.Contains method.
struct Types_WatchKind {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is a resource kind to watch
  var kind: String = String()

  /// LoadSecrets specifies whether to load secrets
  var loadSecrets: Bool = false

  /// Name is an optional specific resource type to watch,
  /// if specified only the events with a specific resource
  /// name will be sent
  var name: String = String()

  /// Filter is an optional mapping of custom filter parameters.
  /// Valid values vary by resource kind.
  var filter: Dictionary<String,String> = [:]

  /// SubKind is a resource subkind to watch
  var subKind: String = String()

  /// Version optionally specifies the resource version to watch.
  /// Currently this field is ignored.
  var version: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WatchStatusV1 is intended to be attached to OpInit events and contain information about a successful WatchEvents call.
struct Types_WatchStatusV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the resource kind.
  var kind: String = String()

  /// SubKind is an optional resource subkind. Currently unused for this resource.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the resource metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is the resource spec.
  var spec: Types_WatchStatusSpecV1 {
    get {return _spec ?? Types_WatchStatusSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_WatchStatusSpecV1? = nil
}

/// WatchStatusSpecV1 contains resource kinds confirmed by WatchEvents to be included in the event stream.
struct Types_WatchStatusSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kinds: [Types_WatchKind] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ServerInfoV1 contains info that should be applied to joining Nodes.
struct Types_ServerInfoV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Kind is the resource kind.
  var kind: String = String()

  /// SubKind is an optional resource subkind.
  var subKind: String = String()

  /// Version is the resource version.
  var version: String = String()

  /// Metadata is the resource metadata.
  var metadata: Types_Metadata {
    get {return _metadata ?? Types_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Spec is the resource spec.
  var spec: Types_ServerInfoSpecV1 {
    get {return _spec ?? Types_ServerInfoSpecV1()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  mutating func clearSpec() {self._spec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Types_Metadata? = nil
  fileprivate var _spec: Types_ServerInfoSpecV1? = nil
}

/// ServerInfoSpecV1 contains fields used to match Nodes to this ServerInfo.
struct Types_ServerInfoSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NewLabels is the set of labels to add to nodes matching this ServerInfo.
  var newLabels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// JamfSpecV1 is the base configuration for the Jamf MDM service.
struct Types_JamfSpecV1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enabled toggles the service on or off.
  var enabled: Bool = false

  /// Name of the service device source.
  /// See the teleport.devicetrust.v1.DeviceSource proto.
  /// Defaults to "jamf".
  var name: String = String()

  /// Initial sync delay for the service.
  /// Set to negative to perform syncs immediately on startup.
  /// Defaults to a random delay (a few minutes max).
  var syncDelay: Int64 = 0

  /// Jamf Pro API endpoint.
  /// Example: "https://yourtenant.jamfcloud.com/api".
  /// Required.
  var apiEndpoint: String = String()

  /// Jamf API username.
  /// Username and password are used to acquire short-lived Jamf Pro API tokens.
  /// See https://developer.jamf.com/jamf-pro/docs/jamf-pro-api-overview.
  /// Required.
  var username: String = String()

  /// Jamf API password.
  /// Username and password are used to acquire short-lived Jamf Pro API tokens.
  /// See https://developer.jamf.com/jamf-pro/docs/jamf-pro-api-overview.
  /// Required.
  var password: String = String()

  /// Inventory sync entries.
  /// If empty a default sync configuration is used.
  var inventory: [Types_JamfInventoryEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// JamfInventoryEntry is an inventory sync entry for [JamfSpecV1].
struct Types_JamfInventoryEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Jamf Pro API RSQL filter, used when querying endpoints like
  /// "/api/v1/computers-inventory".
  /// See https://developer.jamf.com/jamf-pro/reference/get_v1-computers-inventory.
  var filterRsql: String = String()

  /// Sync period for PARTIAL syncs.
  /// PARTIAL syncs are scheduled in the time window between FULL syncs, so
  /// sync_period_partial must always be smaller than sync_period_full, otherwise
  /// it would never trigger.
  /// Set to zero or negative to disable PARTIAL syncs.
  var syncPeriodPartial: Int64 = 0

  /// Sync period for FULL syncs.
  /// Ideally sync_period_full is a multiple of sync_period_partial, so schedules
  /// line up perfectly.
  /// Set to zero or negative to disable FULL syncs.
  var syncPeriodFull: Int64 = 0

  /// on_missing is the trigger used on devices missing from the MDM view in a
  /// FULL sync.
  /// Only runs on successful FULL syncs.
  /// Corresponds to [teleport.devicetrust.v1.SyncInventoryDeviceAction].
  /// Must be either "NOOP" or "DELETE".
  /// Defaults to "NOOP".
  var onMissing: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MessageWithHeader is a message with a resource header. This is used primarily
/// for parsing of resource headers and isn't expected to be used directly by any
/// resources.
///
/// When using a oneof in a protobuf messages, the existing utils.FastMarshal
/// utility does not work, so using something like protojson or jsonpb is required.
/// However, these do not respect gogoproto's extensions. When using a ResourceHeader,
/// protojson will not recognize that the ResourceHeader is intended to be embedded and
/// the resulting JSON will have the header as a separate field. This means that using
/// utils.FastUnmarshal will not work for extracting a ResourceHeader from the
/// JSON, and we explicitly extract this header to do things like version checking in
/// lib/services.
///
/// This can be avoided by explicitly embedding the members of the ResourceHeader in
/// a message. However, if we would like to avoid this, we can use this MessageWitHheader
/// to extract the resource header and its elements, which can later be used for the
/// aforementioned processing in lib/services.
struct Types_MessageWithHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header is the resource header for a resource.
  var header: Types_ResourceHeader {
    get {return _header ?? Types_ResourceHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Types_ResourceHeader? = nil
}

/// AWSMatcher matches AWS EC2 instances and AWS Databases
struct Types_AWSMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Types are AWS database types to match, "ec2", "rds", "redshift", "elasticache",
  /// or "memorydb".
  var types: [String] = []

  /// Regions are AWS regions to query for databases.
  var regions: [String] = []

  /// AssumeRoleARN is the AWS role to assume for database discovery.
  var assumeRole: Types_AssumeRole {
    get {return _assumeRole ?? Types_AssumeRole()}
    set {_assumeRole = newValue}
  }
  /// Returns true if `assumeRole` has been explicitly set.
  var hasAssumeRole: Bool {return self._assumeRole != nil}
  /// Clears the value of `assumeRole`. Subsequent reads from it will return its default value.
  mutating func clearAssumeRole() {self._assumeRole = nil}

  /// Tags are AWS resource Tags to match.
  var tags: Wrappers_LabelValues {
    get {return _tags ?? Wrappers_LabelValues()}
    set {_tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  var hasTags: Bool {return self._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  mutating func clearTags() {self._tags = nil}

  /// Params sets the join method when installing on discovered EC2 nodes
  var params: Types_InstallerParams {
    get {return _params ?? Types_InstallerParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  /// SSM provides options to use when sending a document command to
  /// an EC2 node
  var ssm: Types_AWSSSM {
    get {return _ssm ?? Types_AWSSSM()}
    set {_ssm = newValue}
  }
  /// Returns true if `ssm` has been explicitly set.
  var hasSsm: Bool {return self._ssm != nil}
  /// Clears the value of `ssm`. Subsequent reads from it will return its default value.
  mutating func clearSsm() {self._ssm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _assumeRole: Types_AssumeRole? = nil
  fileprivate var _tags: Wrappers_LabelValues? = nil
  fileprivate var _params: Types_InstallerParams? = nil
  fileprivate var _ssm: Types_AWSSSM? = nil
}

/// AssumeRole provides a role ARN and ExternalID to assume an AWS role
/// when interacting with AWS resources.
struct Types_AssumeRole {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RoleARN is the fully specified AWS IAM role ARN.
  var roleArn: String = String()

  /// ExternalID is the external ID used to assume a role in another account.
  var externalID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InstallParams sets join method to use on discovered nodes
struct Types_InstallerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// JoinMethod is the method to use when joining the cluster
  var joinMethod: String = String()

  /// JoinToken is the token to use when joining the cluster
  var joinToken: String = String()

  /// ScriptName is the name of the teleport installer script
  /// resource for the cloud instance to execute
  var scriptName: String = String()

  /// InstallTeleport disables agentless discovery
  var installTeleport: Bool = false

  /// SSHDConfig provides the path to write sshd configuration changes
  var sshdconfig: String = String()

  /// PublicProxyAddr is the address of the proxy the discovered node should use
  /// to connect to the cluster.
  var publicProxyAddr: String = String()

  /// Azure is the set of Azure-specific installation parameters.
  var azure: Types_AzureInstallerParams {
    get {return _azure ?? Types_AzureInstallerParams()}
    set {_azure = newValue}
  }
  /// Returns true if `azure` has been explicitly set.
  var hasAzure: Bool {return self._azure != nil}
  /// Clears the value of `azure`. Subsequent reads from it will return its default value.
  mutating func clearAzure() {self._azure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _azure: Types_AzureInstallerParams? = nil
}

/// AWSSSM provides options to use when executing SSM documents
struct Types_AWSSSM {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DocumentName is the name of the document to use when executing an
  /// SSM command
  var documentName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AzureInstallerParams is the set of Azure-specific installation parameters.
struct Types_AzureInstallerParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID is the client ID of the managed identity discovered nodes
  /// should use to join the cluster.
  var clientID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AzureMatcher matches Azure resources.
/// It defines which resource types, filters and some configuration params.
struct Types_AzureMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Subscriptions are Azure subscriptions to query for resources.
  var subscriptions: [String] = []

  /// ResourceGroups are Azure resource groups to query for resources.
  var resourceGroups: [String] = []

  /// Types are Azure types to match: "mysql", "postgres", "aks", "vm"
  var types: [String] = []

  /// Regions are Azure locations to match for databases.
  var regions: [String] = []

  /// ResourceTags are Azure tags on resources to match.
  var resourceTags: Wrappers_LabelValues {
    get {return _resourceTags ?? Wrappers_LabelValues()}
    set {_resourceTags = newValue}
  }
  /// Returns true if `resourceTags` has been explicitly set.
  var hasResourceTags: Bool {return self._resourceTags != nil}
  /// Clears the value of `resourceTags`. Subsequent reads from it will return its default value.
  mutating func clearResourceTags() {self._resourceTags = nil}

  /// Params sets the join method when installing on
  /// discovered Azure nodes.
  var params: Types_InstallerParams {
    get {return _params ?? Types_InstallerParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resourceTags: Wrappers_LabelValues? = nil
  fileprivate var _params: Types_InstallerParams? = nil
}

/// GCPMatcher matches GCP resources.
struct Types_GCPMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Types are GKE resource types to match: "gke", "vm".
  var types: [String] = []

  /// Locations are GKE locations to search resources for.
  var locations: [String] = []

  /// Tags is obsolete and only exists for backwards compatibility. Use Labels instead.
  var tags: Wrappers_LabelValues {
    get {return _tags ?? Wrappers_LabelValues()}
    set {_tags = newValue}
  }
  /// Returns true if `tags` has been explicitly set.
  var hasTags: Bool {return self._tags != nil}
  /// Clears the value of `tags`. Subsequent reads from it will return its default value.
  mutating func clearTags() {self._tags = nil}

  /// ProjectIDs are the GCP project ID where the resources are deployed.
  var projectIds: [String] = []

  /// ServiceAccounts are the emails of service accounts attached to VMs.
  var serviceAccounts: [String] = []

  /// Params sets the join method when installing on
  /// discovered GCP nodes.
  var params: Types_InstallerParams {
    get {return _params ?? Types_InstallerParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  /// Labels are GCP labels to match.
  var labels: Wrappers_LabelValues {
    get {return _labels ?? Wrappers_LabelValues()}
    set {_labels = newValue}
  }
  /// Returns true if `labels` has been explicitly set.
  var hasLabels: Bool {return self._labels != nil}
  /// Clears the value of `labels`. Subsequent reads from it will return its default value.
  mutating func clearLabels() {self._labels = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tags: Wrappers_LabelValues? = nil
  fileprivate var _params: Types_InstallerParams? = nil
  fileprivate var _labels: Wrappers_LabelValues? = nil
}

/// KubernetesMatcher matches Kubernetes services.
struct Types_KubernetesMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Types are Kubernetes services types to match. Currently only 'app' is supported.
  var types: [String] = []

  /// Namespaces are Kubernetes namespaces in which to discover services
  var namespaces: [String] = []

  /// Labels are Kubernetes services labels to match.
  var labels: Wrappers_LabelValues {
    get {return _labels ?? Wrappers_LabelValues()}
    set {_labels = newValue}
  }
  /// Returns true if `labels` has been explicitly set.
  var hasLabels: Bool {return self._labels != nil}
  /// Clears the value of `labels`. Subsequent reads from it will return its default value.
  mutating func clearLabels() {self._labels = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _labels: Wrappers_LabelValues? = nil
}

/// OktaOptions specify options related to the Okta service.
struct Types_OktaOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SyncPeriod is the duration between synchronization calls in nanoseconds.
  var syncPeriod: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Types_IAMPolicyStatus: @unchecked Sendable {}
extension Types_DatabaseTLSMode: @unchecked Sendable {}
extension Types_PrivateKeyType: @unchecked Sendable {}
extension Types_ProxyListenerMode: @unchecked Sendable {}
extension Types_RoutingStrategy: @unchecked Sendable {}
extension Types_UserTokenUsage: @unchecked Sendable {}
extension Types_RequestState: @unchecked Sendable {}
extension Types_CreateHostUserMode: @unchecked Sendable {}
extension Types_CreateDatabaseUserMode: @unchecked Sendable {}
extension Types_CertExtensionMode: @unchecked Sendable {}
extension Types_CertExtensionType: @unchecked Sendable {}
extension Types_SessionState: @unchecked Sendable {}
extension Types_AlertSeverity: @unchecked Sendable {}
extension Types_RequireMFAType: @unchecked Sendable {}
extension Types_PluginStatusCode: @unchecked Sendable {}
extension Types_HeadlessAuthenticationState: @unchecked Sendable {}
extension Types_KeepAlive: @unchecked Sendable {}
extension Types_KeepAlive.KeepAliveType: @unchecked Sendable {}
extension Types_Metadata: @unchecked Sendable {}
extension Types_Rotation: @unchecked Sendable {}
extension Types_RotationSchedule: @unchecked Sendable {}
extension Types_ResourceHeader: @unchecked Sendable {}
extension Types_DatabaseServerV3: @unchecked Sendable {}
extension Types_DatabaseServerSpecV3: @unchecked Sendable {}
extension Types_DatabaseV3List: @unchecked Sendable {}
extension Types_DatabaseV3: @unchecked Sendable {}
extension Types_DatabaseSpecV3: @unchecked Sendable {}
extension Types_DatabaseAdminUser: @unchecked Sendable {}
extension Types_OracleOptions: @unchecked Sendable {}
extension Types_DatabaseStatusV3: @unchecked Sendable {}
extension Types_AWS: @unchecked Sendable {}
extension Types_SecretStore: @unchecked Sendable {}
extension Types_Redshift: @unchecked Sendable {}
extension Types_RDS: @unchecked Sendable {}
extension Types_RDSProxy: @unchecked Sendable {}
extension Types_ElastiCache: @unchecked Sendable {}
extension Types_MemoryDB: @unchecked Sendable {}
extension Types_RedshiftServerless: @unchecked Sendable {}
extension Types_OpenSearch: @unchecked Sendable {}
extension Types_GCPCloudSQL: @unchecked Sendable {}
extension Types_Azure: @unchecked Sendable {}
extension Types_AzureRedis: @unchecked Sendable {}
extension Types_AD: @unchecked Sendable {}
extension Types_DatabaseTLS: @unchecked Sendable {}
extension Types_MySQLOptions: @unchecked Sendable {}
extension Types_MongoAtlas: @unchecked Sendable {}
extension Types_InstanceV1: @unchecked Sendable {}
extension Types_InstanceSpecV1: @unchecked Sendable {}
extension Types_InstanceControlLogEntry: @unchecked Sendable {}
extension Types_InstanceFilter: @unchecked Sendable {}
extension Types_ServerV2: @unchecked Sendable {}
extension Types_ServerSpecV2: @unchecked Sendable {}
extension Types_AWSInfo: @unchecked Sendable {}
extension Types_CloudMetadata: @unchecked Sendable {}
extension Types_AppServerV3: @unchecked Sendable {}
extension Types_AppServerSpecV3: @unchecked Sendable {}
extension Types_AppV3List: @unchecked Sendable {}
extension Types_AppV3: @unchecked Sendable {}
extension Types_AppSpecV3: @unchecked Sendable {}
extension Types_AppServerOrSAMLIdPServiceProviderV1: @unchecked Sendable {}
extension Types_AppServerOrSAMLIdPServiceProviderV1.OneOf_Resource: @unchecked Sendable {}
extension Types_Rewrite: @unchecked Sendable {}
extension Types_Header: @unchecked Sendable {}
extension Types_CommandLabelV2: @unchecked Sendable {}
extension Types_AppAWS: @unchecked Sendable {}
extension Types_SSHKeyPair: @unchecked Sendable {}
extension Types_TLSKeyPair: @unchecked Sendable {}
extension Types_JWTKeyPair: @unchecked Sendable {}
extension Types_CertAuthorityV2: @unchecked Sendable {}
extension Types_CertAuthoritySpecV2: @unchecked Sendable {}
extension Types_CertAuthoritySpecV2.SigningAlgType: @unchecked Sendable {}
extension Types_CAKeySet: @unchecked Sendable {}
extension Types_RoleMapping: @unchecked Sendable {}
extension Types_ProvisionTokenV1: @unchecked Sendable {}
extension Types_ProvisionTokenV2: @unchecked Sendable {}
extension Types_ProvisionTokenV2List: @unchecked Sendable {}
extension Types_TokenRule: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2GitHub: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2GitHub.Rule: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2GitLab: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2GitLab.Rule: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2CircleCI: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2CircleCI.Rule: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2Kubernetes: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2Kubernetes.Rule: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2Azure: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2Azure.Rule: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2GCP: @unchecked Sendable {}
extension Types_ProvisionTokenSpecV2GCP.Rule: @unchecked Sendable {}
extension Types_StaticTokensV2: @unchecked Sendable {}
extension Types_StaticTokensSpecV2: @unchecked Sendable {}
extension Types_ClusterNameV2: @unchecked Sendable {}
extension Types_ClusterNameSpecV2: @unchecked Sendable {}
extension Types_ClusterAuditConfigV2: @unchecked Sendable {}
extension Types_ClusterAuditConfigSpecV2: @unchecked Sendable {}
extension Types_ClusterAuditConfigSpecV2.FIPSEndpointState: @unchecked Sendable {}
extension Types_ClusterNetworkingConfigV2: @unchecked Sendable {}
extension Types_ClusterNetworkingConfigSpecV2: @unchecked Sendable {}
extension Types_TunnelStrategyV1: @unchecked Sendable {}
extension Types_TunnelStrategyV1.OneOf_Strategy: @unchecked Sendable {}
extension Types_AgentMeshTunnelStrategy: @unchecked Sendable {}
extension Types_ProxyPeeringTunnelStrategy: @unchecked Sendable {}
extension Types_SessionRecordingConfigV2: @unchecked Sendable {}
extension Types_SessionRecordingConfigSpecV2: @unchecked Sendable {}
extension Types_AuthPreferenceV2: @unchecked Sendable {}
extension Types_AuthPreferenceSpecV2: @unchecked Sendable {}
extension Types_U2F: @unchecked Sendable {}
extension Types_Webauthn: @unchecked Sendable {}
extension Types_DeviceTrust: @unchecked Sendable {}
extension Types_Namespace: @unchecked Sendable {}
extension Types_NamespaceSpec: @unchecked Sendable {}
extension Types_UserTokenV3: @unchecked Sendable {}
extension Types_UserTokenSpecV3: @unchecked Sendable {}
extension Types_UserTokenSecretsV3: @unchecked Sendable {}
extension Types_UserTokenSecretsSpecV3: @unchecked Sendable {}
extension Types_AccessRequestV3: @unchecked Sendable {}
extension Types_AccessReviewThreshold: @unchecked Sendable {}
extension Types_PromotedAccessList: @unchecked Sendable {}
extension Types_AccessReview: @unchecked Sendable {}
extension Types_AccessReviewSubmission: @unchecked Sendable {}
extension Types_ThresholdIndexSet: @unchecked Sendable {}
extension Types_ThresholdIndexSets: @unchecked Sendable {}
extension Types_AccessRequestSpecV3: @unchecked Sendable {}
extension Types_AccessRequestFilter: @unchecked Sendable {}
extension Types_AccessCapabilities: @unchecked Sendable {}
extension Types_AccessCapabilitiesRequest: @unchecked Sendable {}
extension Types_ResourceID: @unchecked Sendable {}
extension Types_PluginDataV3: @unchecked Sendable {}
extension Types_PluginDataEntry: @unchecked Sendable {}
extension Types_PluginDataSpecV3: @unchecked Sendable {}
extension Types_PluginDataFilter: @unchecked Sendable {}
extension Types_PluginDataUpdateParams: @unchecked Sendable {}
extension Types_RoleV6: @unchecked Sendable {}
extension Types_RoleSpecV6: @unchecked Sendable {}
extension Types_RoleOptions: @unchecked Sendable {}
extension Types_RecordSession: @unchecked Sendable {}
extension Types_CertExtension: @unchecked Sendable {}
extension Types_RoleConditions: @unchecked Sendable {}
extension Types_KubernetesResource: @unchecked Sendable {}
extension Types_SessionRequirePolicy: @unchecked Sendable {}
extension Types_SessionJoinPolicy: @unchecked Sendable {}
extension Types_AccessRequestConditions: @unchecked Sendable {}
extension Types_AccessReviewConditions: @unchecked Sendable {}
extension Types_AccessRequestAllowedPromotion: @unchecked Sendable {}
extension Types_AccessRequestAllowedPromotions: @unchecked Sendable {}
extension Types_ClaimMapping: @unchecked Sendable {}
extension Types_TraitMapping: @unchecked Sendable {}
extension Types_Rule: @unchecked Sendable {}
extension Types_ImpersonateConditions: @unchecked Sendable {}
extension Types_BoolValue: @unchecked Sendable {}
extension Types_UserV2: @unchecked Sendable {}
extension Types_UserSpecV2: @unchecked Sendable {}
extension Types_ExternalIdentity: @unchecked Sendable {}
extension Types_LoginStatus: @unchecked Sendable {}
extension Types_CreatedBy: @unchecked Sendable {}
extension Types_LocalAuthSecrets: @unchecked Sendable {}
extension Types_MFADevice: @unchecked Sendable {}
extension Types_MFADevice.OneOf_Device: @unchecked Sendable {}
extension Types_TOTPDevice: @unchecked Sendable {}
extension Types_U2FDevice: @unchecked Sendable {}
extension Types_WebauthnDevice: @unchecked Sendable {}
extension Types_WebauthnLocalAuth: @unchecked Sendable {}
extension Types_ConnectorRef: @unchecked Sendable {}
extension Types_UserRef: @unchecked Sendable {}
extension Types_ReverseTunnelV2: @unchecked Sendable {}
extension Types_ReverseTunnelSpecV2: @unchecked Sendable {}
extension Types_TunnelConnectionV2: @unchecked Sendable {}
extension Types_TunnelConnectionSpecV2: @unchecked Sendable {}
extension Types_SemaphoreFilter: @unchecked Sendable {}
extension Types_AcquireSemaphoreRequest: @unchecked Sendable {}
extension Types_SemaphoreLease: @unchecked Sendable {}
extension Types_SemaphoreLeaseRef: @unchecked Sendable {}
extension Types_SemaphoreV3: @unchecked Sendable {}
extension Types_SemaphoreSpecV3: @unchecked Sendable {}
extension Types_WebSessionV2: @unchecked Sendable {}
extension Types_WebSessionSpecV2: @unchecked Sendable {}
extension Types_WebSessionFilter: @unchecked Sendable {}
extension Types_SAMLSessionData: @unchecked Sendable {}
extension Types_SAMLAttribute: @unchecked Sendable {}
extension Types_SAMLAttributeValue: @unchecked Sendable {}
extension Types_SAMLNameID: @unchecked Sendable {}
extension Types_RemoteClusterV3: @unchecked Sendable {}
extension Types_RemoteClusterStatusV3: @unchecked Sendable {}
extension Types_KubernetesCluster: @unchecked Sendable {}
extension Types_KubernetesClusterV3: @unchecked Sendable {}
extension Types_KubernetesClusterSpecV3: @unchecked Sendable {}
extension Types_KubeAzure: @unchecked Sendable {}
extension Types_KubeAWS: @unchecked Sendable {}
extension Types_KubeGCP: @unchecked Sendable {}
extension Types_KubernetesClusterV3List: @unchecked Sendable {}
extension Types_KubernetesServerV3: @unchecked Sendable {}
extension Types_KubernetesServerSpecV3: @unchecked Sendable {}
extension Types_WebTokenV3: @unchecked Sendable {}
extension Types_WebTokenSpecV3: @unchecked Sendable {}
extension Types_GetWebSessionRequest: @unchecked Sendable {}
extension Types_DeleteWebSessionRequest: @unchecked Sendable {}
extension Types_GetWebTokenRequest: @unchecked Sendable {}
extension Types_DeleteWebTokenRequest: @unchecked Sendable {}
extension Types_ResourceRequest: @unchecked Sendable {}
extension Types_ResourceWithSecretsRequest: @unchecked Sendable {}
extension Types_ResourcesWithSecretsRequest: @unchecked Sendable {}
extension Types_ResourceInNamespaceRequest: @unchecked Sendable {}
extension Types_ResourcesInNamespaceRequest: @unchecked Sendable {}
extension Types_OIDCConnectorV3: @unchecked Sendable {}
extension Types_OIDCConnectorV3List: @unchecked Sendable {}
extension Types_OIDCConnectorSpecV3: @unchecked Sendable {}
extension Types_MaxAge: @unchecked Sendable {}
extension Types_OIDCAuthRequest: @unchecked Sendable {}
extension Types_SAMLConnectorV2: @unchecked Sendable {}
extension Types_SAMLConnectorV2List: @unchecked Sendable {}
extension Types_SAMLConnectorSpecV2: @unchecked Sendable {}
extension Types_SAMLAuthRequest: @unchecked Sendable {}
extension Types_AttributeMapping: @unchecked Sendable {}
extension Types_AsymmetricKeyPair: @unchecked Sendable {}
extension Types_GithubConnectorV3: @unchecked Sendable {}
extension Types_GithubConnectorV3List: @unchecked Sendable {}
extension Types_GithubConnectorSpecV3: @unchecked Sendable {}
extension Types_GithubAuthRequest: @unchecked Sendable {}
extension Types_SSOWarnings: @unchecked Sendable {}
extension Types_CreateUserParams: @unchecked Sendable {}
extension Types_SSODiagnosticInfo: @unchecked Sendable {}
extension Types_GithubTokenInfo: @unchecked Sendable {}
extension Types_GithubClaims: @unchecked Sendable {}
extension Types_TeamMapping: @unchecked Sendable {}
extension Types_TeamRolesMapping: @unchecked Sendable {}
extension Types_TrustedClusterV2: @unchecked Sendable {}
extension Types_TrustedClusterV2List: @unchecked Sendable {}
extension Types_TrustedClusterSpecV2: @unchecked Sendable {}
extension Types_LockV2: @unchecked Sendable {}
extension Types_LockSpecV2: @unchecked Sendable {}
extension Types_LockTarget: @unchecked Sendable {}
extension Types_AddressCondition: @unchecked Sendable {}
extension Types_NetworkRestrictionsSpecV4: @unchecked Sendable {}
extension Types_NetworkRestrictionsV4: @unchecked Sendable {}
extension Types_WindowsDesktopServiceV3: @unchecked Sendable {}
extension Types_WindowsDesktopServiceSpecV3: @unchecked Sendable {}
extension Types_WindowsDesktopFilter: @unchecked Sendable {}
extension Types_WindowsDesktopV3: @unchecked Sendable {}
extension Types_WindowsDesktopSpecV3: @unchecked Sendable {}
extension Types_RegisterUsingTokenRequest: @unchecked Sendable {}
extension Types_RecoveryCodesV1: @unchecked Sendable {}
extension Types_RecoveryCodesSpecV1: @unchecked Sendable {}
extension Types_RecoveryCode: @unchecked Sendable {}
extension Types_NullableSessionState: @unchecked Sendable {}
extension Types_SessionTrackerFilter: @unchecked Sendable {}
extension Types_SessionTrackerV1: @unchecked Sendable {}
extension Types_SessionTrackerSpecV1: @unchecked Sendable {}
extension Types_SessionTrackerPolicySet: @unchecked Sendable {}
extension Types_Participant: @unchecked Sendable {}
extension Types_UIConfigV1: @unchecked Sendable {}
extension Types_UIConfigSpecV1: @unchecked Sendable {}
extension Types_InstallerV1: @unchecked Sendable {}
extension Types_InstallerSpecV1: @unchecked Sendable {}
extension Types_InstallerV1List: @unchecked Sendable {}
extension Types_SortBy: @unchecked Sendable {}
extension Types_ConnectionDiagnosticV1: @unchecked Sendable {}
extension Types_ConnectionDiagnosticSpecV1: @unchecked Sendable {}
extension Types_ConnectionDiagnosticTrace: @unchecked Sendable {}
extension Types_ConnectionDiagnosticTrace.TraceType: @unchecked Sendable {}
extension Types_ConnectionDiagnosticTrace.StatusType: @unchecked Sendable {}
extension Types_DatabaseServiceV1: @unchecked Sendable {}
extension Types_DatabaseServiceSpecV1: @unchecked Sendable {}
extension Types_DatabaseResourceMatcher: @unchecked Sendable {}
extension Types_ResourceMatcherAWS: @unchecked Sendable {}
extension Types_ClusterAlert: @unchecked Sendable {}
extension Types_ClusterAlertSpec: @unchecked Sendable {}
extension Types_GetClusterAlertsRequest: @unchecked Sendable {}
extension Types_AlertAcknowledgement: @unchecked Sendable {}
extension Types_Release: @unchecked Sendable {}
extension Types_Asset: @unchecked Sendable {}
extension Types_PluginV1: @unchecked Sendable {}
extension Types_PluginSpecV1: @unchecked Sendable {}
extension Types_PluginSpecV1.OneOf_Settings: @unchecked Sendable {}
extension Types_PluginSlackAccessSettings: @unchecked Sendable {}
extension Types_PluginOpsgenieAccessSettings: @unchecked Sendable {}
extension Types_PluginServiceNowSettings: @unchecked Sendable {}
extension Types_PluginPagerDutySettings: @unchecked Sendable {}
extension Types_PluginJiraSettings: @unchecked Sendable {}
extension Types_PluginOpenAISettings: @unchecked Sendable {}
extension Types_PluginMattermostSettings: @unchecked Sendable {}
extension Types_PluginJamfSettings: @unchecked Sendable {}
extension Types_PluginOktaSettings: @unchecked Sendable {}
extension Types_DiscordChannels: @unchecked Sendable {}
extension Types_PluginDiscordSettings: @unchecked Sendable {}
extension Types_PluginBootstrapCredentialsV1: @unchecked Sendable {}
extension Types_PluginBootstrapCredentialsV1.OneOf_Credentials: @unchecked Sendable {}
extension Types_PluginIdSecretCredential: @unchecked Sendable {}
extension Types_PluginOAuth2AuthorizationCodeCredentials: @unchecked Sendable {}
extension Types_PluginStatusV1: @unchecked Sendable {}
extension Types_PluginCredentialsV1: @unchecked Sendable {}
extension Types_PluginCredentialsV1.OneOf_Credentials: @unchecked Sendable {}
extension Types_PluginOAuth2AccessTokenCredentials: @unchecked Sendable {}
extension Types_PluginBearerTokenCredentials: @unchecked Sendable {}
extension Types_PluginStaticCredentialsRef: @unchecked Sendable {}
extension Types_PluginListV1: @unchecked Sendable {}
extension Types_PluginStaticCredentialsV1: @unchecked Sendable {}
extension Types_PluginStaticCredentialsSpecV1: @unchecked Sendable {}
extension Types_PluginStaticCredentialsSpecV1.OneOf_Credentials: @unchecked Sendable {}
extension Types_PluginStaticCredentialsBasicAuth: @unchecked Sendable {}
extension Types_PluginStaticCredentialsOAuthClientSecret: @unchecked Sendable {}
extension Types_SAMLIdPServiceProviderV1: @unchecked Sendable {}
extension Types_SAMLIdPServiceProviderSpecV1: @unchecked Sendable {}
extension Types_IdPOptions: @unchecked Sendable {}
extension Types_IdPSAMLOptions: @unchecked Sendable {}
extension Types_KubernetesResourceV1: @unchecked Sendable {}
extension Types_KubernetesResourceSpecV1: @unchecked Sendable {}
extension Types_ClusterMaintenanceConfigV1: @unchecked Sendable {}
extension Types_ClusterMaintenanceConfigSpecV1: @unchecked Sendable {}
extension Types_AgentUpgradeWindow: @unchecked Sendable {}
extension Types_ScheduledAgentUpgradeWindow: @unchecked Sendable {}
extension Types_AgentUpgradeSchedule: @unchecked Sendable {}
extension Types_UserGroupV1: @unchecked Sendable {}
extension Types_UserGroupSpecV1: @unchecked Sendable {}
extension Types_OktaImportRuleSpecV1: @unchecked Sendable {}
extension Types_OktaImportRuleMappingV1: @unchecked Sendable {}
extension Types_OktaImportRuleV1: @unchecked Sendable {}
extension Types_OktaImportRuleMatchV1: @unchecked Sendable {}
extension Types_OktaAssignmentV1: @unchecked Sendable {}
extension Types_OktaAssignmentSpecV1: @unchecked Sendable {}
extension Types_OktaAssignmentSpecV1.OktaAssignmentStatus: @unchecked Sendable {}
extension Types_OktaAssignmentTargetV1: @unchecked Sendable {}
extension Types_OktaAssignmentTargetV1.OktaAssignmentTargetType: @unchecked Sendable {}
extension Types_IntegrationV1: @unchecked Sendable {}
extension Types_IntegrationSpecV1: @unchecked Sendable {}
extension Types_IntegrationSpecV1.OneOf_SubKindSpec: @unchecked Sendable {}
extension Types_AWSOIDCIntegrationSpecV1: @unchecked Sendable {}
extension Types_HeadlessAuthentication: @unchecked Sendable {}
extension Types_WatchKind: @unchecked Sendable {}
extension Types_WatchStatusV1: @unchecked Sendable {}
extension Types_WatchStatusSpecV1: @unchecked Sendable {}
extension Types_ServerInfoV1: @unchecked Sendable {}
extension Types_ServerInfoSpecV1: @unchecked Sendable {}
extension Types_JamfSpecV1: @unchecked Sendable {}
extension Types_JamfInventoryEntry: @unchecked Sendable {}
extension Types_MessageWithHeader: @unchecked Sendable {}
extension Types_AWSMatcher: @unchecked Sendable {}
extension Types_AssumeRole: @unchecked Sendable {}
extension Types_InstallerParams: @unchecked Sendable {}
extension Types_AWSSSM: @unchecked Sendable {}
extension Types_AzureInstallerParams: @unchecked Sendable {}
extension Types_AzureMatcher: @unchecked Sendable {}
extension Types_GCPMatcher: @unchecked Sendable {}
extension Types_KubernetesMatcher: @unchecked Sendable {}
extension Types_OktaOptions: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "types"

extension Types_IAMPolicyStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IAM_POLICY_STATUS_UNSPECIFIED"),
    1: .same(proto: "IAM_POLICY_STATUS_PENDING"),
    2: .same(proto: "IAM_POLICY_STATUS_FAILED"),
    3: .same(proto: "IAM_POLICY_STATUS_SUCCESS"),
  ]
}

extension Types_DatabaseTLSMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERIFY_FULL"),
    1: .same(proto: "VERIFY_CA"),
    2: .same(proto: "INSECURE"),
  ]
}

extension Types_PrivateKeyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RAW"),
    1: .same(proto: "PKCS11"),
    2: .same(proto: "GCP_KMS"),
  ]
}

extension Types_ProxyListenerMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Separate"),
    1: .same(proto: "Multiplex"),
  ]
}

extension Types_RoutingStrategy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNAMBIGUOUS_MATCH"),
    1: .same(proto: "MOST_RECENT"),
  ]
}

extension Types_UserTokenUsage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_TOKEN_USAGE_UNSPECIFIED"),
    1: .same(proto: "USER_TOKEN_RECOVER_PASSWORD"),
    2: .same(proto: "USER_TOKEN_RECOVER_MFA"),
    3: .same(proto: "USER_TOKEN_RENEWAL_BOT"),
  ]
}

extension Types_RequestState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "APPROVED"),
    3: .same(proto: "DENIED"),
    4: .same(proto: "PROMOTED"),
  ]
}

extension Types_CreateHostUserMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HOST_USER_MODE_UNSPECIFIED"),
    1: .same(proto: "HOST_USER_MODE_OFF"),
    2: .same(proto: "HOST_USER_MODE_DROP"),
    3: .same(proto: "HOST_USER_MODE_KEEP"),
  ]
}

extension Types_CreateDatabaseUserMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DB_USER_MODE_UNSPECIFIED"),
    1: .same(proto: "DB_USER_MODE_OFF"),
    2: .same(proto: "DB_USER_MODE_KEEP"),
    3: .same(proto: "DB_USER_MODE_BEST_EFFORT_DROP"),
  ]
}

extension Types_CertExtensionMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTENSION"),
  ]
}

extension Types_CertExtensionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SSH"),
  ]
}

extension Types_SessionState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SessionStatePending"),
    1: .same(proto: "SessionStateRunning"),
    2: .same(proto: "SessionStateTerminated"),
  ]
}

extension Types_AlertSeverity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOW"),
    5: .same(proto: "MEDIUM"),
    10: .same(proto: "HIGH"),
  ]
}

extension Types_RequireMFAType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OFF"),
    1: .same(proto: "SESSION"),
    2: .same(proto: "SESSION_AND_HARDWARE_KEY"),
    3: .same(proto: "HARDWARE_KEY_TOUCH"),
    4: .same(proto: "HARDWARE_KEY_PIN"),
    5: .same(proto: "HARDWARE_KEY_TOUCH_AND_PIN"),
  ]
}

extension Types_PluginStatusCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "OTHER_ERROR"),
    3: .same(proto: "UNAUTHORIZED"),
    10: .same(proto: "SLACK_NOT_IN_CHANNEL"),
  ]
}

extension Types_HeadlessAuthenticationState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HEADLESS_AUTHENTICATION_STATE_UNSPECIFIED"),
    1: .same(proto: "HEADLESS_AUTHENTICATION_STATE_PENDING"),
    2: .same(proto: "HEADLESS_AUTHENTICATION_STATE_DENIED"),
    3: .same(proto: "HEADLESS_AUTHENTICATION_STATE_APPROVED"),
  ]
}

extension Types_KeepAlive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeepAlive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Namespace"),
    3: .same(proto: "LeaseID"),
    4: .same(proto: "Expires"),
    9: .same(proto: "Type"),
    10: .same(proto: "HostID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.leaseID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    if self.leaseID != 0 {
      try visitor.visitSingularInt64Field(value: self.leaseID, fieldNumber: 3)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 9)
    }
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KeepAlive, rhs: Types_KeepAlive) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.leaseID != rhs.leaseID {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.type != rhs.type {return false}
    if lhs.hostID != rhs.hostID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KeepAlive.KeepAliveType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NODE"),
    2: .same(proto: "APP"),
    3: .same(proto: "DATABASE"),
    4: .same(proto: "WINDOWS_DESKTOP"),
    5: .same(proto: "KUBERNETES"),
    6: .same(proto: "DATABASE_SERVICE"),
  ]
}

extension Types_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Namespace"),
    3: .same(proto: "Description"),
    5: .same(proto: "Labels"),
    6: .same(proto: "Expires"),
    7: .same(proto: "ID"),
    8: .same(proto: "Revision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.revision) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 7)
    }
    if !self.revision.isEmpty {
      try visitor.visitSingularStringField(value: self.revision, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Metadata, rhs: Types_Metadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.id != rhs.id {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Rotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rotation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "State"),
    2: .same(proto: "Phase"),
    3: .same(proto: "Mode"),
    4: .same(proto: "CurrentID"),
    5: .same(proto: "Started"),
    6: .same(proto: "GracePeriod"),
    7: .same(proto: "LastRotated"),
    8: .same(proto: "Schedule"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.phase) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currentID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._started) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.gracePeriod) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastRotated) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 1)
    }
    if !self.phase.isEmpty {
      try visitor.visitSingularStringField(value: self.phase, fieldNumber: 2)
    }
    if !self.mode.isEmpty {
      try visitor.visitSingularStringField(value: self.mode, fieldNumber: 3)
    }
    if !self.currentID.isEmpty {
      try visitor.visitSingularStringField(value: self.currentID, fieldNumber: 4)
    }
    try { if let v = self._started {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.gracePeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.gracePeriod, fieldNumber: 6)
    }
    try { if let v = self._lastRotated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Rotation, rhs: Types_Rotation) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.phase != rhs.phase {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.currentID != rhs.currentID {return false}
    if lhs._started != rhs._started {return false}
    if lhs.gracePeriod != rhs.gracePeriod {return false}
    if lhs._lastRotated != rhs._lastRotated {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RotationSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RotationSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UpdateClients"),
    2: .same(proto: "UpdateServers"),
    3: .same(proto: "Standby"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateClients) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateServers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._standby) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updateClients {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateServers {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._standby {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RotationSchedule, rhs: Types_RotationSchedule) -> Bool {
    if lhs._updateClients != rhs._updateClients {return false}
    if lhs._updateServers != rhs._updateServers {return false}
    if lhs._standby != rhs._standby {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourceHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourceHeader, rhs: Types_ResourceHeader) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseServerV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseServerV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseServerV3, rhs: Types_DatabaseServerV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseServerSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseServerSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "Version"),
    7: .same(proto: "Hostname"),
    8: .same(proto: "HostID"),
    10: .same(proto: "Rotation"),
    12: .same(proto: "Database"),
    13: .same(proto: "ProxyIDs"),
  ]

  fileprivate class _StorageClass {
    var _version: String = String()
    var _hostname: String = String()
    var _hostID: String = String()
    var _rotation: Types_Rotation? = nil
    var _database: Types_DatabaseV3? = nil
    var _proxyIds: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _hostname = source._hostname
      _hostID = source._hostID
      _rotation = source._rotation
      _database = source._database
      _proxyIds = source._proxyIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._hostID) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._rotation) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._database) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._proxyIds) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 6)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 7)
      }
      if !_storage._hostID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostID, fieldNumber: 8)
      }
      try { if let v = _storage._rotation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._database {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._proxyIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._proxyIds, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseServerSpecV3, rhs: Types_DatabaseServerSpecV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._hostID != rhs_storage._hostID {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._database != rhs_storage._database {return false}
        if _storage._proxyIds != rhs_storage._proxyIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseV3List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseV3List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Databases"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.databases) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.databases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.databases, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseV3List, rhs: Types_DatabaseV3List) -> Bool {
    if lhs.databases != rhs.databases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
    6: .same(proto: "Status"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_DatabaseSpecV3? = nil
    var _status: Types_DatabaseStatusV3? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseV3, rhs: Types_DatabaseV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Protocol"),
    2: .same(proto: "URI"),
    3: .same(proto: "CACert"),
    4: .same(proto: "DynamicLabels"),
    5: .same(proto: "AWS"),
    6: .same(proto: "GCP"),
    7: .same(proto: "Azure"),
    8: .same(proto: "TLS"),
    9: .same(proto: "AD"),
    10: .same(proto: "MySQL"),
    11: .same(proto: "AdminUser"),
    12: .same(proto: "MongoAtlas"),
    13: .same(proto: "Oracle"),
  ]

  fileprivate class _StorageClass {
    var _protocol: String = String()
    var _uri: String = String()
    var _cacert: String = String()
    var _dynamicLabels: Dictionary<String,Types_CommandLabelV2> = [:]
    var _aws: Types_AWS? = nil
    var _gcp: Types_GCPCloudSQL? = nil
    var _azure: Types_Azure? = nil
    var _tls: Types_DatabaseTLS? = nil
    var _ad: Types_AD? = nil
    var _mySql: Types_MySQLOptions? = nil
    var _adminUser: Types_DatabaseAdminUser? = nil
    var _mongoAtlas: Types_MongoAtlas? = nil
    var _oracle: Types_OracleOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _protocol = source._protocol
      _uri = source._uri
      _cacert = source._cacert
      _dynamicLabels = source._dynamicLabels
      _aws = source._aws
      _gcp = source._gcp
      _azure = source._azure
      _tls = source._tls
      _ad = source._ad
      _mySql = source._mySql
      _adminUser = source._adminUser
      _mongoAtlas = source._mongoAtlas
      _oracle = source._oracle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._protocol) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._uri) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._cacert) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: &_storage._dynamicLabels) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._aws) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._gcp) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._azure) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._tls) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._ad) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._mySql) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._adminUser) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._mongoAtlas) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._oracle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._protocol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._protocol, fieldNumber: 1)
      }
      if !_storage._uri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uri, fieldNumber: 2)
      }
      if !_storage._cacert.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cacert, fieldNumber: 3)
      }
      if !_storage._dynamicLabels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: _storage._dynamicLabels, fieldNumber: 4)
      }
      try { if let v = _storage._aws {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._gcp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._azure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._tls {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._ad {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._mySql {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._adminUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._mongoAtlas {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._oracle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseSpecV3, rhs: Types_DatabaseSpecV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._uri != rhs_storage._uri {return false}
        if _storage._cacert != rhs_storage._cacert {return false}
        if _storage._dynamicLabels != rhs_storage._dynamicLabels {return false}
        if _storage._aws != rhs_storage._aws {return false}
        if _storage._gcp != rhs_storage._gcp {return false}
        if _storage._azure != rhs_storage._azure {return false}
        if _storage._tls != rhs_storage._tls {return false}
        if _storage._ad != rhs_storage._ad {return false}
        if _storage._mySql != rhs_storage._mySql {return false}
        if _storage._adminUser != rhs_storage._adminUser {return false}
        if _storage._mongoAtlas != rhs_storage._mongoAtlas {return false}
        if _storage._oracle != rhs_storage._oracle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseAdminUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseAdminUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "DefaultDatabase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.defaultDatabase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.defaultDatabase.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultDatabase, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseAdminUser, rhs: Types_DatabaseAdminUser) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.defaultDatabase != rhs.defaultDatabase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OracleOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AuditUser"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.auditUser) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.auditUser.isEmpty {
      try visitor.visitSingularStringField(value: self.auditUser, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OracleOptions, rhs: Types_OracleOptions) -> Bool {
    if lhs.auditUser != rhs.auditUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseStatusV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseStatusV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CACert"),
    2: .same(proto: "AWS"),
    3: .same(proto: "MySQL"),
    4: .same(proto: "ManagedUsers"),
    5: .same(proto: "Azure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cacert) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._aws) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mySql) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.managedUsers) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._azure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cacert.isEmpty {
      try visitor.visitSingularStringField(value: self.cacert, fieldNumber: 1)
    }
    try { if let v = self._aws {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mySql {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.managedUsers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.managedUsers, fieldNumber: 4)
    }
    try { if let v = self._azure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseStatusV3, rhs: Types_DatabaseStatusV3) -> Bool {
    if lhs.cacert != rhs.cacert {return false}
    if lhs._aws != rhs._aws {return false}
    if lhs._mySql != rhs._mySql {return false}
    if lhs.managedUsers != rhs.managedUsers {return false}
    if lhs._azure != rhs._azure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AWS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Region"),
    2: .same(proto: "Redshift"),
    3: .same(proto: "RDS"),
    4: .same(proto: "AccountID"),
    5: .same(proto: "ElastiCache"),
    6: .same(proto: "SecretStore"),
    7: .same(proto: "MemoryDB"),
    8: .same(proto: "RDSProxy"),
    9: .same(proto: "RedshiftServerless"),
    10: .same(proto: "ExternalID"),
    11: .same(proto: "AssumeRoleARN"),
    12: .same(proto: "OpenSearch"),
    14: .same(proto: "IAMPolicyStatus"),
  ]

  fileprivate class _StorageClass {
    var _region: String = String()
    var _redshift: Types_Redshift? = nil
    var _rds: Types_RDS? = nil
    var _accountID: String = String()
    var _elastiCache: Types_ElastiCache? = nil
    var _secretStore: Types_SecretStore? = nil
    var _memoryDb: Types_MemoryDB? = nil
    var _rdsproxy: Types_RDSProxy? = nil
    var _redshiftServerless: Types_RedshiftServerless? = nil
    var _externalID: String = String()
    var _assumeRoleArn: String = String()
    var _openSearch: Types_OpenSearch? = nil
    var _iampolicyStatus: Types_IAMPolicyStatus = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _region = source._region
      _redshift = source._redshift
      _rds = source._rds
      _accountID = source._accountID
      _elastiCache = source._elastiCache
      _secretStore = source._secretStore
      _memoryDb = source._memoryDb
      _rdsproxy = source._rdsproxy
      _redshiftServerless = source._redshiftServerless
      _externalID = source._externalID
      _assumeRoleArn = source._assumeRoleArn
      _openSearch = source._openSearch
      _iampolicyStatus = source._iampolicyStatus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._redshift) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rds) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._accountID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._elastiCache) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._secretStore) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._memoryDb) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._rdsproxy) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._redshiftServerless) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._externalID) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._assumeRoleArn) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._openSearch) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._iampolicyStatus) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 1)
      }
      try { if let v = _storage._redshift {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 4)
      }
      try { if let v = _storage._elastiCache {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._secretStore {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._memoryDb {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._rdsproxy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._redshiftServerless {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._externalID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._externalID, fieldNumber: 10)
      }
      if !_storage._assumeRoleArn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assumeRoleArn, fieldNumber: 11)
      }
      try { if let v = _storage._openSearch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._iampolicyStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._iampolicyStatus, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AWS, rhs: Types_AWS) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._region != rhs_storage._region {return false}
        if _storage._redshift != rhs_storage._redshift {return false}
        if _storage._rds != rhs_storage._rds {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._elastiCache != rhs_storage._elastiCache {return false}
        if _storage._secretStore != rhs_storage._secretStore {return false}
        if _storage._memoryDb != rhs_storage._memoryDb {return false}
        if _storage._rdsproxy != rhs_storage._rdsproxy {return false}
        if _storage._redshiftServerless != rhs_storage._redshiftServerless {return false}
        if _storage._externalID != rhs_storage._externalID {return false}
        if _storage._assumeRoleArn != rhs_storage._assumeRoleArn {return false}
        if _storage._openSearch != rhs_storage._openSearch {return false}
        if _storage._iampolicyStatus != rhs_storage._iampolicyStatus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SecretStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecretStore"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KeyPrefix"),
    2: .same(proto: "KMSKeyID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyPrefix) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kmskeyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.keyPrefix, fieldNumber: 1)
    }
    if !self.kmskeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.kmskeyID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SecretStore, rhs: Types_SecretStore) -> Bool {
    if lhs.keyPrefix != rhs.keyPrefix {return false}
    if lhs.kmskeyID != rhs.kmskeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Redshift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Redshift"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Redshift, rhs: Types_Redshift) -> Bool {
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RDS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RDS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "InstanceID"),
    2: .same(proto: "ClusterID"),
    3: .same(proto: "ResourceID"),
    4: .same(proto: "IAMAuth"),
    5: .same(proto: "Subnets"),
    6: .same(proto: "VPCID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.iamauth) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.subnets) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.vpcid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 1)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 2)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 3)
    }
    if self.iamauth != false {
      try visitor.visitSingularBoolField(value: self.iamauth, fieldNumber: 4)
    }
    if !self.subnets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subnets, fieldNumber: 5)
    }
    if !self.vpcid.isEmpty {
      try visitor.visitSingularStringField(value: self.vpcid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RDS, rhs: Types_RDS) -> Bool {
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.iamauth != rhs.iamauth {return false}
    if lhs.subnets != rhs.subnets {return false}
    if lhs.vpcid != rhs.vpcid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RDSProxy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RDSProxy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "CustomEndpointName"),
    3: .same(proto: "ResourceID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.customEndpointName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.customEndpointName.isEmpty {
      try visitor.visitSingularStringField(value: self.customEndpointName, fieldNumber: 2)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RDSProxy, rhs: Types_RDSProxy) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.customEndpointName != rhs.customEndpointName {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ElastiCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ElastiCache"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ReplicationGroupID"),
    2: .same(proto: "UserGroupIDs"),
    3: .same(proto: "TransitEncryptionEnabled"),
    4: .same(proto: "EndpointType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.replicationGroupID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.userGroupIds) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.transitEncryptionEnabled) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.endpointType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.replicationGroupID.isEmpty {
      try visitor.visitSingularStringField(value: self.replicationGroupID, fieldNumber: 1)
    }
    if !self.userGroupIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userGroupIds, fieldNumber: 2)
    }
    if self.transitEncryptionEnabled != false {
      try visitor.visitSingularBoolField(value: self.transitEncryptionEnabled, fieldNumber: 3)
    }
    if !self.endpointType.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ElastiCache, rhs: Types_ElastiCache) -> Bool {
    if lhs.replicationGroupID != rhs.replicationGroupID {return false}
    if lhs.userGroupIds != rhs.userGroupIds {return false}
    if lhs.transitEncryptionEnabled != rhs.transitEncryptionEnabled {return false}
    if lhs.endpointType != rhs.endpointType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_MemoryDB: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemoryDB"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "ACLName"),
    3: .same(proto: "TLSEnabled"),
    4: .same(proto: "EndpointType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.aclname) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.tlsenabled) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.endpointType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.aclname.isEmpty {
      try visitor.visitSingularStringField(value: self.aclname, fieldNumber: 2)
    }
    if self.tlsenabled != false {
      try visitor.visitSingularBoolField(value: self.tlsenabled, fieldNumber: 3)
    }
    if !self.endpointType.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_MemoryDB, rhs: Types_MemoryDB) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.aclname != rhs.aclname {return false}
    if lhs.tlsenabled != rhs.tlsenabled {return false}
    if lhs.endpointType != rhs.endpointType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RedshiftServerless: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RedshiftServerless"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WorkgroupName"),
    2: .same(proto: "EndpointName"),
    3: .same(proto: "WorkgroupID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workgroupName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpointName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workgroupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workgroupName.isEmpty {
      try visitor.visitSingularStringField(value: self.workgroupName, fieldNumber: 1)
    }
    if !self.endpointName.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointName, fieldNumber: 2)
    }
    if !self.workgroupID.isEmpty {
      try visitor.visitSingularStringField(value: self.workgroupID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RedshiftServerless, rhs: Types_RedshiftServerless) -> Bool {
    if lhs.workgroupName != rhs.workgroupName {return false}
    if lhs.endpointName != rhs.endpointName {return false}
    if lhs.workgroupID != rhs.workgroupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OpenSearch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenSearch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DomainName"),
    2: .same(proto: "DomainID"),
    3: .same(proto: "EndpointType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.domainName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domainID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpointType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domainName.isEmpty {
      try visitor.visitSingularStringField(value: self.domainName, fieldNumber: 1)
    }
    if !self.domainID.isEmpty {
      try visitor.visitSingularStringField(value: self.domainID, fieldNumber: 2)
    }
    if !self.endpointType.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OpenSearch, rhs: Types_OpenSearch) -> Bool {
    if lhs.domainName != rhs.domainName {return false}
    if lhs.domainID != rhs.domainID {return false}
    if lhs.endpointType != rhs.endpointType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GCPCloudSQL: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GCPCloudSQL"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProjectID"),
    2: .same(proto: "InstanceID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GCPCloudSQL, rhs: Types_GCPCloudSQL) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Azure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Azure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "ResourceID"),
    3: .same(proto: "Redis"),
    4: .same(proto: "IsFlexiServer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._redis) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isFlexiServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.resourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceID, fieldNumber: 2)
    }
    try { if let v = self._redis {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.isFlexiServer != false {
      try visitor.visitSingularBoolField(value: self.isFlexiServer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Azure, rhs: Types_Azure) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs._redis != rhs._redis {return false}
    if lhs.isFlexiServer != rhs.isFlexiServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AzureRedis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AzureRedis"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusteringPolicy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusteringPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusteringPolicy.isEmpty {
      try visitor.visitSingularStringField(value: self.clusteringPolicy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AzureRedis, rhs: Types_AzureRedis) -> Bool {
    if lhs.clusteringPolicy != rhs.clusteringPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AD: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AD"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KeytabFile"),
    2: .same(proto: "Krb5File"),
    3: .same(proto: "Domain"),
    4: .same(proto: "SPN"),
    5: .same(proto: "LDAPCert"),
    6: .same(proto: "KDCHostName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keytabFile) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.krb5File) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.spn) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ldapcert) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.kdchostName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keytabFile.isEmpty {
      try visitor.visitSingularStringField(value: self.keytabFile, fieldNumber: 1)
    }
    if !self.krb5File.isEmpty {
      try visitor.visitSingularStringField(value: self.krb5File, fieldNumber: 2)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 3)
    }
    if !self.spn.isEmpty {
      try visitor.visitSingularStringField(value: self.spn, fieldNumber: 4)
    }
    if !self.ldapcert.isEmpty {
      try visitor.visitSingularStringField(value: self.ldapcert, fieldNumber: 5)
    }
    if !self.kdchostName.isEmpty {
      try visitor.visitSingularStringField(value: self.kdchostName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AD, rhs: Types_AD) -> Bool {
    if lhs.keytabFile != rhs.keytabFile {return false}
    if lhs.krb5File != rhs.krb5File {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.spn != rhs.spn {return false}
    if lhs.ldapcert != rhs.ldapcert {return false}
    if lhs.kdchostName != rhs.kdchostName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseTLS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseTLS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Mode"),
    2: .same(proto: "CACert"),
    3: .same(proto: "ServerName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cacert) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .verifyFull {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if !self.cacert.isEmpty {
      try visitor.visitSingularStringField(value: self.cacert, fieldNumber: 2)
    }
    if !self.serverName.isEmpty {
      try visitor.visitSingularStringField(value: self.serverName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseTLS, rhs: Types_DatabaseTLS) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.cacert != rhs.cacert {return false}
    if lhs.serverName != rhs.serverName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_MySQLOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MySQLOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServerVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_MySQLOptions, rhs: Types_MySQLOptions) -> Bool {
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_MongoAtlas: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MongoAtlas"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_MongoAtlas, rhs: Types_MongoAtlas) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstanceV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _header: Types_ResourceHeader? = nil
    var _spec: Types_InstanceSpecV1? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstanceV1, rhs: Types_InstanceV1) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstanceSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Version"),
    2: .same(proto: "Services"),
    3: .same(proto: "Hostname"),
    4: .same(proto: "AuthID"),
    5: .same(proto: "LastSeen"),
    6: .same(proto: "ControlLog"),
    7: .same(proto: "ExternalUpgrader"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.services) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastSeen) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.controlLog) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.externalUpgrader) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedStringField(value: self.services, fieldNumber: 2)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 3)
    }
    if !self.authID.isEmpty {
      try visitor.visitSingularStringField(value: self.authID, fieldNumber: 4)
    }
    try { if let v = self._lastSeen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.controlLog.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.controlLog, fieldNumber: 6)
    }
    if !self.externalUpgrader.isEmpty {
      try visitor.visitSingularStringField(value: self.externalUpgrader, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstanceSpecV1, rhs: Types_InstanceSpecV1) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.services != rhs.services {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.authID != rhs.authID {return false}
    if lhs._lastSeen != rhs._lastSeen {return false}
    if lhs.controlLog != rhs.controlLog {return false}
    if lhs.externalUpgrader != rhs.externalUpgrader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstanceControlLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceControlLogEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "ID"),
    3: .same(proto: "Time"),
    4: .same(proto: "TTL"),
    5: .same(proto: "Labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstanceControlLogEntry, rhs: Types_InstanceControlLogEntry) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs._time != rhs._time {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstanceFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServerID"),
    2: .same(proto: "Version"),
    3: .same(proto: "Services"),
    4: .same(proto: "ExternalUpgrader"),
    5: .same(proto: "NoExtUpgrader"),
    6: .same(proto: "OlderThanVersion"),
    7: .same(proto: "NewerThanVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.services) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.externalUpgrader) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.noExtUpgrader) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.olderThanVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.newerThanVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedStringField(value: self.services, fieldNumber: 3)
    }
    if !self.externalUpgrader.isEmpty {
      try visitor.visitSingularStringField(value: self.externalUpgrader, fieldNumber: 4)
    }
    if self.noExtUpgrader != false {
      try visitor.visitSingularBoolField(value: self.noExtUpgrader, fieldNumber: 5)
    }
    if !self.olderThanVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.olderThanVersion, fieldNumber: 6)
    }
    if !self.newerThanVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.newerThanVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstanceFilter, rhs: Types_InstanceFilter) -> Bool {
    if lhs.serverID != rhs.serverID {return false}
    if lhs.version != rhs.version {return false}
    if lhs.services != rhs.services {return false}
    if lhs.externalUpgrader != rhs.externalUpgrader {return false}
    if lhs.noExtUpgrader != rhs.noExtUpgrader {return false}
    if lhs.olderThanVersion != rhs.olderThanVersion {return false}
    if lhs.newerThanVersion != rhs.newerThanVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ServerV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ServerV2, rhs: Types_ServerV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ServerSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Addr"),
    2: .same(proto: "PublicAddr"),
    3: .same(proto: "Hostname"),
    4: .same(proto: "CmdLabels"),
    5: .same(proto: "Rotation"),
    6: .same(proto: "UseTunnel"),
    7: .same(proto: "Version"),
    11: .same(proto: "PeerAddr"),
    12: .same(proto: "ProxyIDs"),
    13: .standard(proto: "public_addrs"),
    14: .same(proto: "CloudMetadata"),
  ]

  fileprivate class _StorageClass {
    var _addr: String = String()
    var _publicAddr: String = String()
    var _hostname: String = String()
    var _cmdLabels: Dictionary<String,Types_CommandLabelV2> = [:]
    var _rotation: Types_Rotation? = nil
    var _useTunnel: Bool = false
    var _version: String = String()
    var _peerAddr: String = String()
    var _proxyIds: [String] = []
    var _publicAddrs: [String] = []
    var _cloudMetadata: Types_CloudMetadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _addr = source._addr
      _publicAddr = source._publicAddr
      _hostname = source._hostname
      _cmdLabels = source._cmdLabels
      _rotation = source._rotation
      _useTunnel = source._useTunnel
      _version = source._version
      _peerAddr = source._peerAddr
      _proxyIds = source._proxyIds
      _publicAddrs = source._publicAddrs
      _cloudMetadata = source._cloudMetadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._addr) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._publicAddr) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: &_storage._cmdLabels) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._rotation) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._useTunnel) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._peerAddr) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._proxyIds) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._publicAddrs) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._cloudMetadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._addr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addr, fieldNumber: 1)
      }
      if !_storage._publicAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._publicAddr, fieldNumber: 2)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 3)
      }
      if !_storage._cmdLabels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: _storage._cmdLabels, fieldNumber: 4)
      }
      try { if let v = _storage._rotation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._useTunnel != false {
        try visitor.visitSingularBoolField(value: _storage._useTunnel, fieldNumber: 6)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 7)
      }
      if !_storage._peerAddr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._peerAddr, fieldNumber: 11)
      }
      if !_storage._proxyIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._proxyIds, fieldNumber: 12)
      }
      if !_storage._publicAddrs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._publicAddrs, fieldNumber: 13)
      }
      try { if let v = _storage._cloudMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ServerSpecV2, rhs: Types_ServerSpecV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._addr != rhs_storage._addr {return false}
        if _storage._publicAddr != rhs_storage._publicAddr {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._cmdLabels != rhs_storage._cmdLabels {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._useTunnel != rhs_storage._useTunnel {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._peerAddr != rhs_storage._peerAddr {return false}
        if _storage._proxyIds != rhs_storage._proxyIds {return false}
        if _storage._publicAddrs != rhs_storage._publicAddrs {return false}
        if _storage._cloudMetadata != rhs_storage._cloudMetadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AWSInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWSInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AccountID"),
    2: .same(proto: "InstanceID"),
    3: .same(proto: "Region"),
    4: .same(proto: "VPCID"),
    5: .same(proto: "Integration"),
    6: .same(proto: "SubnetID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.vpcid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.integration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.subnetID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 2)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 3)
    }
    if !self.vpcid.isEmpty {
      try visitor.visitSingularStringField(value: self.vpcid, fieldNumber: 4)
    }
    if !self.integration.isEmpty {
      try visitor.visitSingularStringField(value: self.integration, fieldNumber: 5)
    }
    if !self.subnetID.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AWSInfo, rhs: Types_AWSInfo) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.region != rhs.region {return false}
    if lhs.vpcid != rhs.vpcid {return false}
    if lhs.integration != rhs.integration {return false}
    if lhs.subnetID != rhs.subnetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CloudMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloudMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AWS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._aws) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aws {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CloudMetadata, rhs: Types_CloudMetadata) -> Bool {
    if lhs._aws != rhs._aws {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AppServerV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppServerV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AppServerV3, rhs: Types_AppServerV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AppServerSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppServerSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Version"),
    2: .same(proto: "Hostname"),
    3: .same(proto: "HostID"),
    4: .same(proto: "Rotation"),
    5: .same(proto: "App"),
    6: .same(proto: "ProxyIDs"),
  ]

  fileprivate class _StorageClass {
    var _version: String = String()
    var _hostname: String = String()
    var _hostID: String = String()
    var _rotation: Types_Rotation? = nil
    var _app: Types_AppV3? = nil
    var _proxyIds: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _hostname = source._hostname
      _hostID = source._hostID
      _rotation = source._rotation
      _app = source._app
      _proxyIds = source._proxyIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._hostID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._rotation) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._proxyIds) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 1)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 2)
      }
      if !_storage._hostID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostID, fieldNumber: 3)
      }
      try { if let v = _storage._rotation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._proxyIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._proxyIds, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AppServerSpecV3, rhs: Types_AppServerSpecV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._hostID != rhs_storage._hostID {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._proxyIds != rhs_storage._proxyIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AppV3List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppV3List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Apps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AppV3List, rhs: Types_AppV3List) -> Bool {
    if lhs.apps != rhs.apps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AppV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_AppSpecV3? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AppV3, rhs: Types_AppV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AppSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "URI"),
    2: .same(proto: "PublicAddr"),
    3: .same(proto: "DynamicLabels"),
    4: .same(proto: "InsecureSkipVerify"),
    5: .same(proto: "Rewrite"),
    6: .same(proto: "AWS"),
    7: .same(proto: "Cloud"),
    8: .same(proto: "UserGroups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicAddr) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: &self.dynamicLabels) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.insecureSkipVerify) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rewrite) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._aws) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.cloud) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.userGroups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.publicAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.publicAddr, fieldNumber: 2)
    }
    if !self.dynamicLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: self.dynamicLabels, fieldNumber: 3)
    }
    if self.insecureSkipVerify != false {
      try visitor.visitSingularBoolField(value: self.insecureSkipVerify, fieldNumber: 4)
    }
    try { if let v = self._rewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._aws {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.cloud.isEmpty {
      try visitor.visitSingularStringField(value: self.cloud, fieldNumber: 7)
    }
    if !self.userGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userGroups, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AppSpecV3, rhs: Types_AppSpecV3) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.publicAddr != rhs.publicAddr {return false}
    if lhs.dynamicLabels != rhs.dynamicLabels {return false}
    if lhs.insecureSkipVerify != rhs.insecureSkipVerify {return false}
    if lhs._rewrite != rhs._rewrite {return false}
    if lhs._aws != rhs._aws {return false}
    if lhs.cloud != rhs.cloud {return false}
    if lhs.userGroups != rhs.userGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AppServerOrSAMLIdPServiceProviderV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppServerOrSAMLIdPServiceProviderV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "AppServer"),
    3: .same(proto: "SAMLIdPServiceProvider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try {
        var v: Types_AppServerV3?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .appServer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .appServer(v)
        }
      }()
      case 3: try {
        var v: Types_SAMLIdPServiceProviderV1?
        var hadOneofValue = false
        if let current = self.resource {
          hadOneofValue = true
          if case .samlidPserviceProvider(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.resource = .samlidPserviceProvider(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    switch self.resource {
    case .appServer?: try {
      guard case .appServer(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .samlidPserviceProvider?: try {
      guard case .samlidPserviceProvider(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AppServerOrSAMLIdPServiceProviderV1, rhs: Types_AppServerOrSAMLIdPServiceProviderV1) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Rewrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rewrite"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Redirect"),
    2: .same(proto: "Headers"),
    3: .same(proto: "JWTClaims"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.redirect) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.jwtclaims) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.redirect.isEmpty {
      try visitor.visitRepeatedStringField(value: self.redirect, fieldNumber: 1)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 2)
    }
    if !self.jwtclaims.isEmpty {
      try visitor.visitSingularStringField(value: self.jwtclaims, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Rewrite, rhs: Types_Rewrite) -> Bool {
    if lhs.redirect != rhs.redirect {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.jwtclaims != rhs.jwtclaims {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Header"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Header, rhs: Types_Header) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CommandLabelV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandLabelV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Period"),
    2: .same(proto: "Command"),
    3: .same(proto: "Result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.period) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.command) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.period != 0 {
      try visitor.visitSingularInt64Field(value: self.period, fieldNumber: 1)
    }
    if !self.command.isEmpty {
      try visitor.visitRepeatedStringField(value: self.command, fieldNumber: 2)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CommandLabelV2, rhs: Types_CommandLabelV2) -> Bool {
    if lhs.period != rhs.period {return false}
    if lhs.command != rhs.command {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AppAWS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppAWS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ExternalID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.externalID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalID.isEmpty {
      try visitor.visitSingularStringField(value: self.externalID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AppAWS, rhs: Types_AppAWS) -> Bool {
    if lhs.externalID != rhs.externalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SSHKeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SSHKeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PublicKey"),
    2: .same(proto: "PrivateKey"),
    3: .same(proto: "PrivateKeyType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.privateKeyType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 2)
    }
    if self.privateKeyType != .raw {
      try visitor.visitSingularEnumField(value: self.privateKeyType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SSHKeyPair, rhs: Types_SSHKeyPair) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.privateKeyType != rhs.privateKeyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TLSKeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TLSKeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Cert"),
    2: .same(proto: "Key"),
    3: .same(proto: "KeyType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.cert) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.keyType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cert.isEmpty {
      try visitor.visitSingularBytesField(value: self.cert, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    if self.keyType != .raw {
      try visitor.visitSingularEnumField(value: self.keyType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TLSKeyPair, rhs: Types_TLSKeyPair) -> Bool {
    if lhs.cert != rhs.cert {return false}
    if lhs.key != rhs.key {return false}
    if lhs.keyType != rhs.keyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_JWTKeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JWTKeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PublicKey"),
    2: .same(proto: "PrivateKey"),
    3: .same(proto: "PrivateKeyType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.privateKeyType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 2)
    }
    if self.privateKeyType != .raw {
      try visitor.visitSingularEnumField(value: self.privateKeyType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_JWTKeyPair, rhs: Types_JWTKeyPair) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.privateKeyType != rhs.privateKeyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CertAuthorityV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertAuthorityV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CertAuthorityV2, rhs: Types_CertAuthorityV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CertAuthoritySpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertAuthoritySpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "ClusterName"),
    5: .same(proto: "Roles"),
    6: .same(proto: "RoleMap"),
    8: .same(proto: "Rotation"),
    9: .same(proto: "SigningAlg"),
    11: .same(proto: "ActiveKeys"),
    12: .same(proto: "AdditionalTrustedKeys"),
  ]

  fileprivate class _StorageClass {
    var _type: String = String()
    var _clusterName: String = String()
    var _roles: [String] = []
    var _roleMap: [Types_RoleMapping] = []
    var _rotation: Types_Rotation? = nil
    var _signingAlg: Types_CertAuthoritySpecV2.SigningAlgType = .unknown
    var _activeKeys: Types_CAKeySet? = nil
    var _additionalTrustedKeys: Types_CAKeySet? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _clusterName = source._clusterName
      _roles = source._roles
      _roleMap = source._roleMap
      _rotation = source._rotation
      _signingAlg = source._signingAlg
      _activeKeys = source._activeKeys
      _additionalTrustedKeys = source._additionalTrustedKeys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._clusterName) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._roleMap) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._rotation) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._signingAlg) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._activeKeys) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._additionalTrustedKeys) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._clusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterName, fieldNumber: 2)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 5)
      }
      if !_storage._roleMap.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._roleMap, fieldNumber: 6)
      }
      try { if let v = _storage._rotation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._signingAlg != .unknown {
        try visitor.visitSingularEnumField(value: _storage._signingAlg, fieldNumber: 9)
      }
      try { if let v = _storage._activeKeys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._additionalTrustedKeys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CertAuthoritySpecV2, rhs: Types_CertAuthoritySpecV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._clusterName != rhs_storage._clusterName {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._roleMap != rhs_storage._roleMap {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._signingAlg != rhs_storage._signingAlg {return false}
        if _storage._activeKeys != rhs_storage._activeKeys {return false}
        if _storage._additionalTrustedKeys != rhs_storage._additionalTrustedKeys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CertAuthoritySpecV2.SigningAlgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RSA_SHA1"),
    2: .same(proto: "RSA_SHA2_256"),
    3: .same(proto: "RSA_SHA2_512"),
  ]
}

extension Types_CAKeySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CAKeySet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SSH"),
    2: .same(proto: "TLS"),
    3: .same(proto: "JWT"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ssh) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tls) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.jwt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssh.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ssh, fieldNumber: 1)
    }
    if !self.tls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tls, fieldNumber: 2)
    }
    if !self.jwt.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jwt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CAKeySet, rhs: Types_CAKeySet) -> Bool {
    if lhs.ssh != rhs.ssh {return false}
    if lhs.tls != rhs.tls {return false}
    if lhs.jwt != rhs.jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RoleMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Remote"),
    2: .same(proto: "Local"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.remote) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.local) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.remote.isEmpty {
      try visitor.visitSingularStringField(value: self.remote, fieldNumber: 1)
    }
    if !self.local.isEmpty {
      try visitor.visitRepeatedStringField(value: self.local, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RoleMapping, rhs: Types_RoleMapping) -> Bool {
    if lhs.remote != rhs.remote {return false}
    if lhs.local != rhs.local {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Roles"),
    2: .same(proto: "Expires"),
    3: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenV1, rhs: Types_ProvisionTokenV1) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenV2, rhs: Types_ProvisionTokenV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenV2List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenV2List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProvisionTokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.provisionTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provisionTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.provisionTokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenV2List, rhs: Types_ProvisionTokenV2List) -> Bool {
    if lhs.provisionTokens != rhs.provisionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TokenRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenRule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AWSAccount"),
    2: .same(proto: "AWSRegions"),
    3: .same(proto: "AWSRole"),
    4: .same(proto: "AWSARN"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.awsaccount) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.awsregions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.awsrole) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.awsarn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.awsaccount.isEmpty {
      try visitor.visitSingularStringField(value: self.awsaccount, fieldNumber: 1)
    }
    if !self.awsregions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.awsregions, fieldNumber: 2)
    }
    if !self.awsrole.isEmpty {
      try visitor.visitSingularStringField(value: self.awsrole, fieldNumber: 3)
    }
    if !self.awsarn.isEmpty {
      try visitor.visitSingularStringField(value: self.awsarn, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TokenRule, rhs: Types_TokenRule) -> Bool {
    if lhs.awsaccount != rhs.awsaccount {return false}
    if lhs.awsregions != rhs.awsregions {return false}
    if lhs.awsrole != rhs.awsrole {return false}
    if lhs.awsarn != rhs.awsarn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Roles"),
    2: .same(proto: "Allow"),
    3: .same(proto: "AWSIIDTTL"),
    4: .same(proto: "JoinMethod"),
    5: .same(proto: "BotName"),
    6: .same(proto: "SuggestedLabels"),
    7: .same(proto: "GitHub"),
    8: .same(proto: "CircleCI"),
    9: .same(proto: "SuggestedAgentMatcherLabels"),
    10: .same(proto: "Kubernetes"),
    11: .same(proto: "Azure"),
    12: .same(proto: "GitLab"),
    13: .same(proto: "GCP"),
  ]

  fileprivate class _StorageClass {
    var _roles: [String] = []
    var _allow: [Types_TokenRule] = []
    var _awsiidttl: Int64 = 0
    var _joinMethod: String = String()
    var _botName: String = String()
    var _suggestedLabels: Wrappers_LabelValues? = nil
    var _gitHub: Types_ProvisionTokenSpecV2GitHub? = nil
    var _circleCi: Types_ProvisionTokenSpecV2CircleCI? = nil
    var _suggestedAgentMatcherLabels: Wrappers_LabelValues? = nil
    var _kubernetes: Types_ProvisionTokenSpecV2Kubernetes? = nil
    var _azure: Types_ProvisionTokenSpecV2Azure? = nil
    var _gitLab: Types_ProvisionTokenSpecV2GitLab? = nil
    var _gcp: Types_ProvisionTokenSpecV2GCP? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _roles = source._roles
      _allow = source._allow
      _awsiidttl = source._awsiidttl
      _joinMethod = source._joinMethod
      _botName = source._botName
      _suggestedLabels = source._suggestedLabels
      _gitHub = source._gitHub
      _circleCi = source._circleCi
      _suggestedAgentMatcherLabels = source._suggestedAgentMatcherLabels
      _kubernetes = source._kubernetes
      _azure = source._azure
      _gitLab = source._gitLab
      _gcp = source._gcp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._allow) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._awsiidttl) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._joinMethod) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._botName) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._suggestedLabels) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._gitHub) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._circleCi) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._suggestedAgentMatcherLabels) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetes) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._azure) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._gitLab) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._gcp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 1)
      }
      if !_storage._allow.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._allow, fieldNumber: 2)
      }
      if _storage._awsiidttl != 0 {
        try visitor.visitSingularInt64Field(value: _storage._awsiidttl, fieldNumber: 3)
      }
      if !_storage._joinMethod.isEmpty {
        try visitor.visitSingularStringField(value: _storage._joinMethod, fieldNumber: 4)
      }
      if !_storage._botName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._botName, fieldNumber: 5)
      }
      try { if let v = _storage._suggestedLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._gitHub {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._circleCi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._suggestedAgentMatcherLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._kubernetes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._azure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._gitLab {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._gcp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2, rhs: Types_ProvisionTokenSpecV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._allow != rhs_storage._allow {return false}
        if _storage._awsiidttl != rhs_storage._awsiidttl {return false}
        if _storage._joinMethod != rhs_storage._joinMethod {return false}
        if _storage._botName != rhs_storage._botName {return false}
        if _storage._suggestedLabels != rhs_storage._suggestedLabels {return false}
        if _storage._gitHub != rhs_storage._gitHub {return false}
        if _storage._circleCi != rhs_storage._circleCi {return false}
        if _storage._suggestedAgentMatcherLabels != rhs_storage._suggestedAgentMatcherLabels {return false}
        if _storage._kubernetes != rhs_storage._kubernetes {return false}
        if _storage._azure != rhs_storage._azure {return false}
        if _storage._gitLab != rhs_storage._gitLab {return false}
        if _storage._gcp != rhs_storage._gcp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2GitHub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenSpecV2GitHub"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Allow"),
    2: .same(proto: "EnterpriseServerHost"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allow) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.enterpriseServerHost) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allow, fieldNumber: 1)
    }
    if !self.enterpriseServerHost.isEmpty {
      try visitor.visitSingularStringField(value: self.enterpriseServerHost, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2GitHub, rhs: Types_ProvisionTokenSpecV2GitHub) -> Bool {
    if lhs.allow != rhs.allow {return false}
    if lhs.enterpriseServerHost != rhs.enterpriseServerHost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2GitHub.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Types_ProvisionTokenSpecV2GitHub.protoMessageName + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sub"),
    2: .same(proto: "Repository"),
    3: .same(proto: "RepositoryOwner"),
    4: .same(proto: "Workflow"),
    5: .same(proto: "Environment"),
    6: .same(proto: "Actor"),
    7: .same(proto: "Ref"),
    8: .same(proto: "RefType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sub) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.repository) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.repositoryOwner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.workflow) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.environment) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.actor) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.ref) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.refType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sub.isEmpty {
      try visitor.visitSingularStringField(value: self.sub, fieldNumber: 1)
    }
    if !self.repository.isEmpty {
      try visitor.visitSingularStringField(value: self.repository, fieldNumber: 2)
    }
    if !self.repositoryOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.repositoryOwner, fieldNumber: 3)
    }
    if !self.workflow.isEmpty {
      try visitor.visitSingularStringField(value: self.workflow, fieldNumber: 4)
    }
    if !self.environment.isEmpty {
      try visitor.visitSingularStringField(value: self.environment, fieldNumber: 5)
    }
    if !self.actor.isEmpty {
      try visitor.visitSingularStringField(value: self.actor, fieldNumber: 6)
    }
    if !self.ref.isEmpty {
      try visitor.visitSingularStringField(value: self.ref, fieldNumber: 7)
    }
    if !self.refType.isEmpty {
      try visitor.visitSingularStringField(value: self.refType, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2GitHub.Rule, rhs: Types_ProvisionTokenSpecV2GitHub.Rule) -> Bool {
    if lhs.sub != rhs.sub {return false}
    if lhs.repository != rhs.repository {return false}
    if lhs.repositoryOwner != rhs.repositoryOwner {return false}
    if lhs.workflow != rhs.workflow {return false}
    if lhs.environment != rhs.environment {return false}
    if lhs.actor != rhs.actor {return false}
    if lhs.ref != rhs.ref {return false}
    if lhs.refType != rhs.refType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2GitLab: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenSpecV2GitLab"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Allow"),
    2: .same(proto: "Domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allow) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allow, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2GitLab, rhs: Types_ProvisionTokenSpecV2GitLab) -> Bool {
    if lhs.allow != rhs.allow {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2GitLab.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Types_ProvisionTokenSpecV2GitLab.protoMessageName + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sub"),
    2: .same(proto: "Ref"),
    3: .same(proto: "RefType"),
    4: .same(proto: "NamespacePath"),
    5: .same(proto: "ProjectPath"),
    6: .same(proto: "PipelineSource"),
    7: .same(proto: "Environment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sub) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ref) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.refType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespacePath) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.projectPath) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.pipelineSource) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.environment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sub.isEmpty {
      try visitor.visitSingularStringField(value: self.sub, fieldNumber: 1)
    }
    if !self.ref.isEmpty {
      try visitor.visitSingularStringField(value: self.ref, fieldNumber: 2)
    }
    if !self.refType.isEmpty {
      try visitor.visitSingularStringField(value: self.refType, fieldNumber: 3)
    }
    if !self.namespacePath.isEmpty {
      try visitor.visitSingularStringField(value: self.namespacePath, fieldNumber: 4)
    }
    if !self.projectPath.isEmpty {
      try visitor.visitSingularStringField(value: self.projectPath, fieldNumber: 5)
    }
    if !self.pipelineSource.isEmpty {
      try visitor.visitSingularStringField(value: self.pipelineSource, fieldNumber: 6)
    }
    if !self.environment.isEmpty {
      try visitor.visitSingularStringField(value: self.environment, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2GitLab.Rule, rhs: Types_ProvisionTokenSpecV2GitLab.Rule) -> Bool {
    if lhs.sub != rhs.sub {return false}
    if lhs.ref != rhs.ref {return false}
    if lhs.refType != rhs.refType {return false}
    if lhs.namespacePath != rhs.namespacePath {return false}
    if lhs.projectPath != rhs.projectPath {return false}
    if lhs.pipelineSource != rhs.pipelineSource {return false}
    if lhs.environment != rhs.environment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2CircleCI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenSpecV2CircleCI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Allow"),
    2: .same(proto: "OrganizationID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allow) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.organizationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allow, fieldNumber: 1)
    }
    if !self.organizationID.isEmpty {
      try visitor.visitSingularStringField(value: self.organizationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2CircleCI, rhs: Types_ProvisionTokenSpecV2CircleCI) -> Bool {
    if lhs.allow != rhs.allow {return false}
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2CircleCI.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Types_ProvisionTokenSpecV2CircleCI.protoMessageName + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProjectID"),
    2: .same(proto: "ContextID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contextID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.contextID.isEmpty {
      try visitor.visitSingularStringField(value: self.contextID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2CircleCI.Rule, rhs: Types_ProvisionTokenSpecV2CircleCI.Rule) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.contextID != rhs.contextID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2Kubernetes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenSpecV2Kubernetes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Allow"),
    2: .same(proto: "Type"),
    3: .same(proto: "StaticJWKS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allow) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._staticJwks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.allow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allow, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._staticJwks {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2Kubernetes, rhs: Types_ProvisionTokenSpecV2Kubernetes) -> Bool {
    if lhs.allow != rhs.allow {return false}
    if lhs.type != rhs.type {return false}
    if lhs._staticJwks != rhs._staticJwks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Types_ProvisionTokenSpecV2Kubernetes.protoMessageName + ".StaticJWKSConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JWKS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jwks.isEmpty {
      try visitor.visitSingularStringField(value: self.jwks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig, rhs: Types_ProvisionTokenSpecV2Kubernetes.StaticJWKSConfig) -> Bool {
    if lhs.jwks != rhs.jwks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2Kubernetes.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Types_ProvisionTokenSpecV2Kubernetes.protoMessageName + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ServiceAccount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2Kubernetes.Rule, rhs: Types_ProvisionTokenSpecV2Kubernetes.Rule) -> Bool {
    if lhs.serviceAccount != rhs.serviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2Azure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenSpecV2Azure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Allow"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allow, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2Azure, rhs: Types_ProvisionTokenSpecV2Azure) -> Bool {
    if lhs.allow != rhs.allow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2Azure.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Types_ProvisionTokenSpecV2Azure.protoMessageName + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Subscription"),
    2: .same(proto: "ResourceGroups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.resourceGroups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if !self.resourceGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resourceGroups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2Azure.Rule, rhs: Types_ProvisionTokenSpecV2Azure.Rule) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.resourceGroups != rhs.resourceGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2GCP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvisionTokenSpecV2GCP"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Allow"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allow, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2GCP, rhs: Types_ProvisionTokenSpecV2GCP) -> Bool {
    if lhs.allow != rhs.allow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProvisionTokenSpecV2GCP.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Types_ProvisionTokenSpecV2GCP.protoMessageName + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ProjectIDs"),
    2: .same(proto: "Locations"),
    3: .same(proto: "ServiceAccounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.projectIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.locations) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.serviceAccounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.projectIds, fieldNumber: 1)
    }
    if !self.locations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locations, fieldNumber: 2)
    }
    if !self.serviceAccounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serviceAccounts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProvisionTokenSpecV2GCP.Rule, rhs: Types_ProvisionTokenSpecV2GCP.Rule) -> Bool {
    if lhs.projectIds != rhs.projectIds {return false}
    if lhs.locations != rhs.locations {return false}
    if lhs.serviceAccounts != rhs.serviceAccounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_StaticTokensV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StaticTokensV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_StaticTokensV2, rhs: Types_StaticTokensV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_StaticTokensSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StaticTokensSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "StaticTokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.staticTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.staticTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.staticTokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_StaticTokensSpecV2, rhs: Types_StaticTokensSpecV2) -> Bool {
    if lhs.staticTokens != rhs.staticTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterNameV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterNameV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterNameV2, rhs: Types_ClusterNameV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterNameSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterNameSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "ClusterID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterNameSpecV2, rhs: Types_ClusterNameSpecV2) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterAuditConfigV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterAuditConfigV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_ClusterAuditConfigSpecV2? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterAuditConfigV2, rhs: Types_ClusterAuditConfigV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterAuditConfigSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterAuditConfigSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "Region"),
    3: .same(proto: "AuditSessionsURI"),
    4: .same(proto: "AuditEventsURI"),
    6: .same(proto: "EnableContinuousBackups"),
    7: .same(proto: "EnableAutoScaling"),
    8: .same(proto: "ReadMaxCapacity"),
    9: .same(proto: "ReadMinCapacity"),
    10: .same(proto: "ReadTargetValue"),
    11: .same(proto: "WriteMaxCapacity"),
    12: .same(proto: "WriteMinCapacity"),
    13: .same(proto: "WriteTargetValue"),
    14: .same(proto: "RetentionPeriod"),
    15: .same(proto: "UseFIPSEndpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.auditSessionsUri) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._auditEventsUri) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enableContinuousBackups) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.enableAutoScaling) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.readMaxCapacity) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.readMinCapacity) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.readTargetValue) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.writeMaxCapacity) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.writeMinCapacity) }()
      case 13: try { try decoder.decodeSingularDoubleField(value: &self.writeTargetValue) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.retentionPeriod) }()
      case 15: try { try decoder.decodeSingularEnumField(value: &self.useFipsendpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.auditSessionsUri.isEmpty {
      try visitor.visitSingularStringField(value: self.auditSessionsUri, fieldNumber: 3)
    }
    try { if let v = self._auditEventsUri {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.enableContinuousBackups != false {
      try visitor.visitSingularBoolField(value: self.enableContinuousBackups, fieldNumber: 6)
    }
    if self.enableAutoScaling != false {
      try visitor.visitSingularBoolField(value: self.enableAutoScaling, fieldNumber: 7)
    }
    if self.readMaxCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.readMaxCapacity, fieldNumber: 8)
    }
    if self.readMinCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.readMinCapacity, fieldNumber: 9)
    }
    if self.readTargetValue != 0 {
      try visitor.visitSingularDoubleField(value: self.readTargetValue, fieldNumber: 10)
    }
    if self.writeMaxCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.writeMaxCapacity, fieldNumber: 11)
    }
    if self.writeMinCapacity != 0 {
      try visitor.visitSingularInt64Field(value: self.writeMinCapacity, fieldNumber: 12)
    }
    if self.writeTargetValue != 0 {
      try visitor.visitSingularDoubleField(value: self.writeTargetValue, fieldNumber: 13)
    }
    if self.retentionPeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.retentionPeriod, fieldNumber: 14)
    }
    if self.useFipsendpoint != .fipsUnset {
      try visitor.visitSingularEnumField(value: self.useFipsendpoint, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterAuditConfigSpecV2, rhs: Types_ClusterAuditConfigSpecV2) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.region != rhs.region {return false}
    if lhs.auditSessionsUri != rhs.auditSessionsUri {return false}
    if lhs._auditEventsUri != rhs._auditEventsUri {return false}
    if lhs.enableContinuousBackups != rhs.enableContinuousBackups {return false}
    if lhs.enableAutoScaling != rhs.enableAutoScaling {return false}
    if lhs.readMaxCapacity != rhs.readMaxCapacity {return false}
    if lhs.readMinCapacity != rhs.readMinCapacity {return false}
    if lhs.readTargetValue != rhs.readTargetValue {return false}
    if lhs.writeMaxCapacity != rhs.writeMaxCapacity {return false}
    if lhs.writeMinCapacity != rhs.writeMinCapacity {return false}
    if lhs.writeTargetValue != rhs.writeTargetValue {return false}
    if lhs.retentionPeriod != rhs.retentionPeriod {return false}
    if lhs.useFipsendpoint != rhs.useFipsendpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterAuditConfigSpecV2.FIPSEndpointState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIPS_UNSET"),
    1: .same(proto: "FIPS_ENABLED"),
    2: .same(proto: "FIPS_DISABLED"),
  ]
}

extension Types_ClusterNetworkingConfigV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterNetworkingConfigV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_ClusterNetworkingConfigSpecV2? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterNetworkingConfigV2, rhs: Types_ClusterNetworkingConfigV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterNetworkingConfigSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterNetworkingConfigSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClientIdleTimeout"),
    2: .same(proto: "KeepAliveInterval"),
    3: .same(proto: "KeepAliveCountMax"),
    4: .same(proto: "SessionControlTimeout"),
    5: .same(proto: "ClientIdleTimeoutMessage"),
    6: .same(proto: "WebIdleTimeout"),
    7: .same(proto: "ProxyListenerMode"),
    8: .same(proto: "RoutingStrategy"),
    9: .same(proto: "TunnelStrategy"),
    10: .same(proto: "ProxyPingInterval"),
    11: .same(proto: "AssistCommandExecutionWorkers"),
    12: .same(proto: "CaseInsensitiveRouting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clientIdleTimeout) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.keepAliveInterval) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.keepAliveCountMax) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.sessionControlTimeout) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.clientIdleTimeoutMessage) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.webIdleTimeout) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.proxyListenerMode) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.routingStrategy) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._tunnelStrategy) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.proxyPingInterval) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.assistCommandExecutionWorkers) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.caseInsensitiveRouting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.clientIdleTimeout != 0 {
      try visitor.visitSingularInt64Field(value: self.clientIdleTimeout, fieldNumber: 1)
    }
    if self.keepAliveInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.keepAliveInterval, fieldNumber: 2)
    }
    if self.keepAliveCountMax != 0 {
      try visitor.visitSingularInt64Field(value: self.keepAliveCountMax, fieldNumber: 3)
    }
    if self.sessionControlTimeout != 0 {
      try visitor.visitSingularInt64Field(value: self.sessionControlTimeout, fieldNumber: 4)
    }
    if !self.clientIdleTimeoutMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.clientIdleTimeoutMessage, fieldNumber: 5)
    }
    if self.webIdleTimeout != 0 {
      try visitor.visitSingularInt64Field(value: self.webIdleTimeout, fieldNumber: 6)
    }
    if self.proxyListenerMode != .separate {
      try visitor.visitSingularEnumField(value: self.proxyListenerMode, fieldNumber: 7)
    }
    if self.routingStrategy != .unambiguousMatch {
      try visitor.visitSingularEnumField(value: self.routingStrategy, fieldNumber: 8)
    }
    try { if let v = self._tunnelStrategy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.proxyPingInterval != 0 {
      try visitor.visitSingularInt64Field(value: self.proxyPingInterval, fieldNumber: 10)
    }
    if self.assistCommandExecutionWorkers != 0 {
      try visitor.visitSingularInt32Field(value: self.assistCommandExecutionWorkers, fieldNumber: 11)
    }
    if self.caseInsensitiveRouting != false {
      try visitor.visitSingularBoolField(value: self.caseInsensitiveRouting, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterNetworkingConfigSpecV2, rhs: Types_ClusterNetworkingConfigSpecV2) -> Bool {
    if lhs.clientIdleTimeout != rhs.clientIdleTimeout {return false}
    if lhs.keepAliveInterval != rhs.keepAliveInterval {return false}
    if lhs.keepAliveCountMax != rhs.keepAliveCountMax {return false}
    if lhs.sessionControlTimeout != rhs.sessionControlTimeout {return false}
    if lhs.clientIdleTimeoutMessage != rhs.clientIdleTimeoutMessage {return false}
    if lhs.webIdleTimeout != rhs.webIdleTimeout {return false}
    if lhs.proxyListenerMode != rhs.proxyListenerMode {return false}
    if lhs.routingStrategy != rhs.routingStrategy {return false}
    if lhs._tunnelStrategy != rhs._tunnelStrategy {return false}
    if lhs.proxyPingInterval != rhs.proxyPingInterval {return false}
    if lhs.assistCommandExecutionWorkers != rhs.assistCommandExecutionWorkers {return false}
    if lhs.caseInsensitiveRouting != rhs.caseInsensitiveRouting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TunnelStrategyV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelStrategyV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AgentMesh"),
    2: .same(proto: "ProxyPeering"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_AgentMeshTunnelStrategy?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .agentMesh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .agentMesh(v)
        }
      }()
      case 2: try {
        var v: Types_ProxyPeeringTunnelStrategy?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .proxyPeering(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .proxyPeering(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.strategy {
    case .agentMesh?: try {
      guard case .agentMesh(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .proxyPeering?: try {
      guard case .proxyPeering(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TunnelStrategyV1, rhs: Types_TunnelStrategyV1) -> Bool {
    if lhs.strategy != rhs.strategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AgentMeshTunnelStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AgentMeshTunnelStrategy"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AgentMeshTunnelStrategy, rhs: Types_AgentMeshTunnelStrategy) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ProxyPeeringTunnelStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProxyPeeringTunnelStrategy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AgentConnectionCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.agentConnectionCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.agentConnectionCount != 0 {
      try visitor.visitSingularInt64Field(value: self.agentConnectionCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ProxyPeeringTunnelStrategy, rhs: Types_ProxyPeeringTunnelStrategy) -> Bool {
    if lhs.agentConnectionCount != rhs.agentConnectionCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionRecordingConfigV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionRecordingConfigV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionRecordingConfigV2, rhs: Types_SessionRecordingConfigV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionRecordingConfigSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionRecordingConfigSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Mode"),
    2: .same(proto: "ProxyChecksHostKeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._proxyChecksHostKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mode.isEmpty {
      try visitor.visitSingularStringField(value: self.mode, fieldNumber: 1)
    }
    try { if let v = self._proxyChecksHostKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionRecordingConfigSpecV2, rhs: Types_SessionRecordingConfigSpecV2) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs._proxyChecksHostKeys != rhs._proxyChecksHostKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AuthPreferenceV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthPreferenceV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AuthPreferenceV2, rhs: Types_AuthPreferenceV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AuthPreferenceSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthPreferenceSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "SecondFactor"),
    3: .same(proto: "ConnectorName"),
    4: .same(proto: "U2F"),
    6: .same(proto: "DisconnectExpiredCert"),
    7: .same(proto: "AllowLocalAuth"),
    8: .same(proto: "MessageOfTheDay"),
    9: .same(proto: "LockingMode"),
    10: .same(proto: "Webauthn"),
    11: .same(proto: "AllowPasswordless"),
    12: .same(proto: "RequireMFAType"),
    13: .same(proto: "DeviceTrust"),
    14: .same(proto: "IDP"),
    15: .same(proto: "AllowHeadless"),
    16: .same(proto: "DefaultSessionTTL"),
    17: .same(proto: "Okta"),
    18: .same(proto: "PIVSlot"),
  ]

  fileprivate class _StorageClass {
    var _type: String = String()
    var _secondFactor: String = String()
    var _connectorName: String = String()
    var _u2F: Types_U2F? = nil
    var _disconnectExpiredCert: Types_BoolValue? = nil
    var _allowLocalAuth: Types_BoolValue? = nil
    var _messageOfTheDay: String = String()
    var _lockingMode: String = String()
    var _webauthn: Types_Webauthn? = nil
    var _allowPasswordless: Types_BoolValue? = nil
    var _requireMfatype: Types_RequireMFAType = .off
    var _deviceTrust: Types_DeviceTrust? = nil
    var _idp: Types_IdPOptions? = nil
    var _allowHeadless: Types_BoolValue? = nil
    var _defaultSessionTtl: Int64 = 0
    var _okta: Types_OktaOptions? = nil
    var _pivslot: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _secondFactor = source._secondFactor
      _connectorName = source._connectorName
      _u2F = source._u2F
      _disconnectExpiredCert = source._disconnectExpiredCert
      _allowLocalAuth = source._allowLocalAuth
      _messageOfTheDay = source._messageOfTheDay
      _lockingMode = source._lockingMode
      _webauthn = source._webauthn
      _allowPasswordless = source._allowPasswordless
      _requireMfatype = source._requireMfatype
      _deviceTrust = source._deviceTrust
      _idp = source._idp
      _allowHeadless = source._allowHeadless
      _defaultSessionTtl = source._defaultSessionTtl
      _okta = source._okta
      _pivslot = source._pivslot
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._secondFactor) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._connectorName) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._u2F) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._disconnectExpiredCert) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._allowLocalAuth) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._messageOfTheDay) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._lockingMode) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._webauthn) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._allowPasswordless) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._requireMfatype) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._deviceTrust) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._idp) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._allowHeadless) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._defaultSessionTtl) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._okta) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._pivslot) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._secondFactor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._secondFactor, fieldNumber: 2)
      }
      if !_storage._connectorName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectorName, fieldNumber: 3)
      }
      try { if let v = _storage._u2F {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._disconnectExpiredCert {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._allowLocalAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._messageOfTheDay.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageOfTheDay, fieldNumber: 8)
      }
      if !_storage._lockingMode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lockingMode, fieldNumber: 9)
      }
      try { if let v = _storage._webauthn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._allowPasswordless {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._requireMfatype != .off {
        try visitor.visitSingularEnumField(value: _storage._requireMfatype, fieldNumber: 12)
      }
      try { if let v = _storage._deviceTrust {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._idp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._allowHeadless {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._defaultSessionTtl != 0 {
        try visitor.visitSingularInt64Field(value: _storage._defaultSessionTtl, fieldNumber: 16)
      }
      try { if let v = _storage._okta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._pivslot.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pivslot, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AuthPreferenceSpecV2, rhs: Types_AuthPreferenceSpecV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._secondFactor != rhs_storage._secondFactor {return false}
        if _storage._connectorName != rhs_storage._connectorName {return false}
        if _storage._u2F != rhs_storage._u2F {return false}
        if _storage._disconnectExpiredCert != rhs_storage._disconnectExpiredCert {return false}
        if _storage._allowLocalAuth != rhs_storage._allowLocalAuth {return false}
        if _storage._messageOfTheDay != rhs_storage._messageOfTheDay {return false}
        if _storage._lockingMode != rhs_storage._lockingMode {return false}
        if _storage._webauthn != rhs_storage._webauthn {return false}
        if _storage._allowPasswordless != rhs_storage._allowPasswordless {return false}
        if _storage._requireMfatype != rhs_storage._requireMfatype {return false}
        if _storage._deviceTrust != rhs_storage._deviceTrust {return false}
        if _storage._idp != rhs_storage._idp {return false}
        if _storage._allowHeadless != rhs_storage._allowHeadless {return false}
        if _storage._defaultSessionTtl != rhs_storage._defaultSessionTtl {return false}
        if _storage._okta != rhs_storage._okta {return false}
        if _storage._pivslot != rhs_storage._pivslot {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_U2F: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".U2F"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AppID"),
    2: .same(proto: "Facets"),
    3: .same(proto: "DeviceAttestationCAs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.facets) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.deviceAttestationCas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.facets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.facets, fieldNumber: 2)
    }
    if !self.deviceAttestationCas.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deviceAttestationCas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_U2F, rhs: Types_U2F) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.facets != rhs.facets {return false}
    if lhs.deviceAttestationCas != rhs.deviceAttestationCas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Webauthn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Webauthn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RPID"),
    2: .same(proto: "AttestationAllowedCAs"),
    3: .same(proto: "AttestationDeniedCAs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rpid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.attestationAllowedCas) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.attestationDeniedCas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rpid.isEmpty {
      try visitor.visitSingularStringField(value: self.rpid, fieldNumber: 1)
    }
    if !self.attestationAllowedCas.isEmpty {
      try visitor.visitRepeatedStringField(value: self.attestationAllowedCas, fieldNumber: 2)
    }
    if !self.attestationDeniedCas.isEmpty {
      try visitor.visitRepeatedStringField(value: self.attestationDeniedCas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Webauthn, rhs: Types_Webauthn) -> Bool {
    if lhs.rpid != rhs.rpid {return false}
    if lhs.attestationAllowedCas != rhs.attestationAllowedCas {return false}
    if lhs.attestationDeniedCas != rhs.attestationDeniedCas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DeviceTrust: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceTrust"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Mode"),
    2: .same(proto: "AutoEnroll"),
    3: .same(proto: "EKCertAllowedCAs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.autoEnroll) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.ekcertAllowedCas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mode.isEmpty {
      try visitor.visitSingularStringField(value: self.mode, fieldNumber: 1)
    }
    if self.autoEnroll != false {
      try visitor.visitSingularBoolField(value: self.autoEnroll, fieldNumber: 2)
    }
    if !self.ekcertAllowedCas.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ekcertAllowedCas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DeviceTrust, rhs: Types_DeviceTrust) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.autoEnroll != rhs.autoEnroll {return false}
    if lhs.ekcertAllowedCas != rhs.ekcertAllowedCas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Namespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Namespace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Namespace, rhs: Types_Namespace) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_NamespaceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamespaceSpec"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_NamespaceSpec, rhs: Types_NamespaceSpec) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserTokenV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTokenV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserTokenV3, rhs: Types_UserTokenV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserTokenSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTokenSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "URL"),
    3: .same(proto: "Usage"),
    4: .same(proto: "Created"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.usage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if self.usage != .unspecified {
      try visitor.visitSingularEnumField(value: self.usage, fieldNumber: 3)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserTokenSpecV3, rhs: Types_UserTokenSpecV3) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.url != rhs.url {return false}
    if lhs.usage != rhs.usage {return false}
    if lhs._created != rhs._created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserTokenSecretsV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTokenSecretsV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserTokenSecretsV3, rhs: Types_UserTokenSecretsV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserTokenSecretsSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserTokenSecretsSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OTPKey"),
    2: .same(proto: "QRCode"),
    3: .same(proto: "Created"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.otpkey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.qrcode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.otpkey.isEmpty {
      try visitor.visitSingularStringField(value: self.otpkey, fieldNumber: 1)
    }
    if !self.qrcode.isEmpty {
      try visitor.visitSingularStringField(value: self.qrcode, fieldNumber: 2)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserTokenSecretsSpecV3, rhs: Types_UserTokenSecretsSpecV3) -> Bool {
    if lhs.otpkey != rhs.otpkey {return false}
    if lhs.qrcode != rhs.qrcode {return false}
    if lhs._created != rhs._created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessRequestV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessRequestV3, rhs: Types_AccessRequestV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessReviewThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessReviewThreshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Filter"),
    3: .same(proto: "Approve"),
    4: .same(proto: "Deny"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.approve) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.deny) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.approve != 0 {
      try visitor.visitSingularUInt32Field(value: self.approve, fieldNumber: 3)
    }
    if self.deny != 0 {
      try visitor.visitSingularUInt32Field(value: self.deny, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessReviewThreshold, rhs: Types_AccessReviewThreshold) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.approve != rhs.approve {return false}
    if lhs.deny != rhs.deny {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PromotedAccessList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromotedAccessList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PromotedAccessList, rhs: Types_PromotedAccessList) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Author"),
    2: .same(proto: "Roles"),
    3: .same(proto: "ProposedState"),
    4: .same(proto: "Reason"),
    5: .same(proto: "Created"),
    6: .same(proto: "Annotations"),
    7: .same(proto: "ThresholdIndexes"),
    9: .same(proto: "accessList"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.author) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.proposedState) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._annotations) }()
      case 7: try { try decoder.decodeRepeatedUInt32Field(value: &self.thresholdIndexes) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._accessList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    if self.proposedState != .none {
      try visitor.visitSingularEnumField(value: self.proposedState, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._annotations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.thresholdIndexes.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.thresholdIndexes, fieldNumber: 7)
    }
    try { if let v = self._accessList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessReview, rhs: Types_AccessReview) -> Bool {
    if lhs.author != rhs.author {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.proposedState != rhs.proposedState {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._created != rhs._created {return false}
    if lhs._annotations != rhs._annotations {return false}
    if lhs.thresholdIndexes != rhs.thresholdIndexes {return false}
    if lhs._accessList != rhs._accessList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessReviewSubmission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessReviewSubmission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RequestID"),
    2: .same(proto: "Review"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._review) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try { if let v = self._review {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessReviewSubmission, rhs: Types_AccessReviewSubmission) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._review != rhs._review {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ThresholdIndexSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThresholdIndexSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Indexes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.indexes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexes.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.indexes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ThresholdIndexSet, rhs: Types_ThresholdIndexSet) -> Bool {
    if lhs.indexes != rhs.indexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ThresholdIndexSets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThresholdIndexSets"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Sets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ThresholdIndexSets, rhs: Types_ThresholdIndexSets) -> Bool {
    if lhs.sets != rhs.sets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessRequestSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Roles"),
    3: .same(proto: "State"),
    4: .same(proto: "Created"),
    5: .same(proto: "Expires"),
    6: .same(proto: "RequestReason"),
    7: .same(proto: "ResolveReason"),
    8: .same(proto: "ResolveAnnotations"),
    9: .same(proto: "SystemAnnotations"),
    10: .same(proto: "Thresholds"),
    11: .same(proto: "RoleThresholdMapping"),
    12: .same(proto: "Reviews"),
    13: .same(proto: "SuggestedReviewers"),
    14: .same(proto: "RequestedResourceIDs"),
    15: .same(proto: "LoginHint"),
    16: .same(proto: "DryRun"),
    17: .same(proto: "MaxDuration"),
    18: .same(proto: "SessionTTL"),
    20: .same(proto: "accessList"),
  ]

  fileprivate class _StorageClass {
    var _user: String = String()
    var _roles: [String] = []
    var _state: Types_RequestState = .none
    var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _requestReason: String = String()
    var _resolveReason: String = String()
    var _resolveAnnotations: Wrappers_LabelValues? = nil
    var _systemAnnotations: Wrappers_LabelValues? = nil
    var _thresholds: [Types_AccessReviewThreshold] = []
    var _roleThresholdMapping: Dictionary<String,Types_ThresholdIndexSets> = [:]
    var _reviews: [Types_AccessReview] = []
    var _suggestedReviewers: [String] = []
    var _requestedResourceIds: [Types_ResourceID] = []
    var _loginHint: String = String()
    var _dryRun: Bool = false
    var _maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _sessionTtl: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _accessList: Types_PromotedAccessList? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _roles = source._roles
      _state = source._state
      _created = source._created
      _expires = source._expires
      _requestReason = source._requestReason
      _resolveReason = source._resolveReason
      _resolveAnnotations = source._resolveAnnotations
      _systemAnnotations = source._systemAnnotations
      _thresholds = source._thresholds
      _roleThresholdMapping = source._roleThresholdMapping
      _reviews = source._reviews
      _suggestedReviewers = source._suggestedReviewers
      _requestedResourceIds = source._requestedResourceIds
      _loginHint = source._loginHint
      _dryRun = source._dryRun
      _maxDuration = source._maxDuration
      _sessionTtl = source._sessionTtl
      _accessList = source._accessList
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._created) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._expires) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._requestReason) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._resolveReason) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._resolveAnnotations) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._systemAnnotations) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._thresholds) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_ThresholdIndexSets>.self, value: &_storage._roleThresholdMapping) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._reviews) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._suggestedReviewers) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestedResourceIds) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._loginHint) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._dryRun) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._maxDuration) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._sessionTtl) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._accessList) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._user.isEmpty {
        try visitor.visitSingularStringField(value: _storage._user, fieldNumber: 1)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 2)
      }
      if _storage._state != .none {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      try { if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._requestReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestReason, fieldNumber: 6)
      }
      if !_storage._resolveReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resolveReason, fieldNumber: 7)
      }
      try { if let v = _storage._resolveAnnotations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._systemAnnotations {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._thresholds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._thresholds, fieldNumber: 10)
      }
      if !_storage._roleThresholdMapping.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_ThresholdIndexSets>.self, value: _storage._roleThresholdMapping, fieldNumber: 11)
      }
      if !_storage._reviews.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reviews, fieldNumber: 12)
      }
      if !_storage._suggestedReviewers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._suggestedReviewers, fieldNumber: 13)
      }
      if !_storage._requestedResourceIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestedResourceIds, fieldNumber: 14)
      }
      if !_storage._loginHint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._loginHint, fieldNumber: 15)
      }
      if _storage._dryRun != false {
        try visitor.visitSingularBoolField(value: _storage._dryRun, fieldNumber: 16)
      }
      try { if let v = _storage._maxDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._sessionTtl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._accessList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessRequestSpecV3, rhs: Types_AccessRequestSpecV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._requestReason != rhs_storage._requestReason {return false}
        if _storage._resolveReason != rhs_storage._resolveReason {return false}
        if _storage._resolveAnnotations != rhs_storage._resolveAnnotations {return false}
        if _storage._systemAnnotations != rhs_storage._systemAnnotations {return false}
        if _storage._thresholds != rhs_storage._thresholds {return false}
        if _storage._roleThresholdMapping != rhs_storage._roleThresholdMapping {return false}
        if _storage._reviews != rhs_storage._reviews {return false}
        if _storage._suggestedReviewers != rhs_storage._suggestedReviewers {return false}
        if _storage._requestedResourceIds != rhs_storage._requestedResourceIds {return false}
        if _storage._loginHint != rhs_storage._loginHint {return false}
        if _storage._dryRun != rhs_storage._dryRun {return false}
        if _storage._maxDuration != rhs_storage._maxDuration {return false}
        if _storage._sessionTtl != rhs_storage._sessionTtl {return false}
        if _storage._accessList != rhs_storage._accessList {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessRequestFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "User"),
    3: .same(proto: "State"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 2)
    }
    if self.state != .none {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessRequestFilter, rhs: Types_AccessRequestFilter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.user != rhs.user {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessCapabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RequestableRoles"),
    2: .same(proto: "SuggestedReviewers"),
    3: .same(proto: "ApplicableRolesForResources"),
    4: .same(proto: "RequestPrompt"),
    5: .same(proto: "RequireReason"),
    6: .same(proto: "AutoRequest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.requestableRoles) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.suggestedReviewers) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.applicableRolesForResources) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestPrompt) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.requireReason) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.autoRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestableRoles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestableRoles, fieldNumber: 1)
    }
    if !self.suggestedReviewers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.suggestedReviewers, fieldNumber: 2)
    }
    if !self.applicableRolesForResources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.applicableRolesForResources, fieldNumber: 3)
    }
    if !self.requestPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.requestPrompt, fieldNumber: 4)
    }
    if self.requireReason != false {
      try visitor.visitSingularBoolField(value: self.requireReason, fieldNumber: 5)
    }
    if self.autoRequest != false {
      try visitor.visitSingularBoolField(value: self.autoRequest, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessCapabilities, rhs: Types_AccessCapabilities) -> Bool {
    if lhs.requestableRoles != rhs.requestableRoles {return false}
    if lhs.suggestedReviewers != rhs.suggestedReviewers {return false}
    if lhs.applicableRolesForResources != rhs.applicableRolesForResources {return false}
    if lhs.requestPrompt != rhs.requestPrompt {return false}
    if lhs.requireReason != rhs.requireReason {return false}
    if lhs.autoRequest != rhs.autoRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessCapabilitiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessCapabilitiesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "RequestableRoles"),
    3: .same(proto: "SuggestedReviewers"),
    4: .same(proto: "ResourceIDs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.requestableRoles) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.suggestedReviewers) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.resourceIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if self.requestableRoles != false {
      try visitor.visitSingularBoolField(value: self.requestableRoles, fieldNumber: 2)
    }
    if self.suggestedReviewers != false {
      try visitor.visitSingularBoolField(value: self.suggestedReviewers, fieldNumber: 3)
    }
    if !self.resourceIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessCapabilitiesRequest, rhs: Types_AccessCapabilitiesRequest) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.requestableRoles != rhs.requestableRoles {return false}
    if lhs.suggestedReviewers != rhs.suggestedReviewers {return false}
    if lhs.resourceIds != rhs.resourceIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourceID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "Kind"),
    3: .same(proto: "Name"),
    4: .same(proto: "SubResourceName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subResourceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.subResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.subResourceName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourceID, rhs: Types_ResourceID) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.name != rhs.name {return false}
    if lhs.subResourceName != rhs.subResourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginDataV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDataV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginDataV3, rhs: Types_PluginDataV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginDataEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDataEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginDataEntry, rhs: Types_PluginDataEntry) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginDataSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDataSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_PluginDataEntry>.self, value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_PluginDataEntry>.self, value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginDataSpecV3, rhs: Types_PluginDataSpecV3) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginDataFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDataFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "Resource"),
    3: .same(proto: "Plugin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.plugin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 2)
    }
    if !self.plugin.isEmpty {
      try visitor.visitSingularStringField(value: self.plugin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginDataFilter, rhs: Types_PluginDataFilter) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.plugin != rhs.plugin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginDataUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDataUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "Resource"),
    3: .same(proto: "Plugin"),
    4: .same(proto: "Set"),
    5: .same(proto: "Expect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.plugin) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.set) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.expect) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 2)
    }
    if !self.plugin.isEmpty {
      try visitor.visitSingularStringField(value: self.plugin, fieldNumber: 3)
    }
    if !self.set.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.set, fieldNumber: 4)
    }
    if !self.expect.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.expect, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginDataUpdateParams, rhs: Types_PluginDataUpdateParams) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.plugin != rhs.plugin {return false}
    if lhs.set != rhs.set {return false}
    if lhs.expect != rhs.expect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RoleV6: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleV6"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RoleV6, rhs: Types_RoleV6) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RoleSpecV6: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleSpecV6"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Options"),
    2: .same(proto: "Allow"),
    3: .same(proto: "Deny"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._allow) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deny) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._allow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._deny {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RoleSpecV6, rhs: Types_RoleSpecV6) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs._allow != rhs._allow {return false}
    if lhs._deny != rhs._deny {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RoleOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ForwardAgent"),
    2: .same(proto: "MaxSessionTTL"),
    3: .same(proto: "PortForwarding"),
    4: .same(proto: "CertificateFormat"),
    5: .same(proto: "ClientIdleTimeout"),
    6: .same(proto: "DisconnectExpiredCert"),
    7: .same(proto: "BPF"),
    8: .same(proto: "PermitX11Forwarding"),
    9: .same(proto: "MaxConnections"),
    10: .same(proto: "MaxSessions"),
    11: .same(proto: "RequestAccess"),
    12: .same(proto: "RequestPrompt"),
    14: .same(proto: "Lock"),
    15: .same(proto: "RecordSession"),
    16: .same(proto: "DesktopClipboard"),
    17: .same(proto: "CertExtensions"),
    18: .same(proto: "MaxKubernetesConnections"),
    19: .same(proto: "DesktopDirectorySharing"),
    20: .same(proto: "CreateHostUser"),
    21: .same(proto: "PinSourceIP"),
    22: .same(proto: "SSHFileCopy"),
    23: .same(proto: "RequireMFAType"),
    24: .same(proto: "DeviceTrustMode"),
    25: .same(proto: "IDP"),
    26: .same(proto: "CreateDesktopUser"),
    27: .same(proto: "CreateDatabaseUser"),
    28: .same(proto: "CreateHostUserMode"),
    29: .same(proto: "CreateDatabaseUserMode"),
  ]

  fileprivate class _StorageClass {
    var _forwardAgent: Bool = false
    var _maxSessionTtl: Int64 = 0
    var _portForwarding: Types_BoolValue? = nil
    var _certificateFormat: String = String()
    var _clientIdleTimeout: Int64 = 0
    var _disconnectExpiredCert: Bool = false
    var _bpf: [String] = []
    var _permitX11Forwarding: Bool = false
    var _maxConnections: Int64 = 0
    var _maxSessions: Int64 = 0
    var _requestAccess: String = String()
    var _requestPrompt: String = String()
    var _lock: String = String()
    var _recordSession: Types_RecordSession? = nil
    var _desktopClipboard: Types_BoolValue? = nil
    var _certExtensions: [Types_CertExtension] = []
    var _maxKubernetesConnections: Int64 = 0
    var _desktopDirectorySharing: Types_BoolValue? = nil
    var _createHostUser: Types_BoolValue? = nil
    var _pinSourceIp: Bool = false
    var _sshfileCopy: Types_BoolValue? = nil
    var _requireMfatype: Types_RequireMFAType = .off
    var _deviceTrustMode: String = String()
    var _idp: Types_IdPOptions? = nil
    var _createDesktopUser: Types_BoolValue? = nil
    var _createDatabaseUser: Types_BoolValue? = nil
    var _createHostUserMode: Types_CreateHostUserMode = .hostUserModeUnspecified
    var _createDatabaseUserMode: Types_CreateDatabaseUserMode = .dbUserModeUnspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _forwardAgent = source._forwardAgent
      _maxSessionTtl = source._maxSessionTtl
      _portForwarding = source._portForwarding
      _certificateFormat = source._certificateFormat
      _clientIdleTimeout = source._clientIdleTimeout
      _disconnectExpiredCert = source._disconnectExpiredCert
      _bpf = source._bpf
      _permitX11Forwarding = source._permitX11Forwarding
      _maxConnections = source._maxConnections
      _maxSessions = source._maxSessions
      _requestAccess = source._requestAccess
      _requestPrompt = source._requestPrompt
      _lock = source._lock
      _recordSession = source._recordSession
      _desktopClipboard = source._desktopClipboard
      _certExtensions = source._certExtensions
      _maxKubernetesConnections = source._maxKubernetesConnections
      _desktopDirectorySharing = source._desktopDirectorySharing
      _createHostUser = source._createHostUser
      _pinSourceIp = source._pinSourceIp
      _sshfileCopy = source._sshfileCopy
      _requireMfatype = source._requireMfatype
      _deviceTrustMode = source._deviceTrustMode
      _idp = source._idp
      _createDesktopUser = source._createDesktopUser
      _createDatabaseUser = source._createDatabaseUser
      _createHostUserMode = source._createHostUserMode
      _createDatabaseUserMode = source._createDatabaseUserMode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._forwardAgent) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._maxSessionTtl) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._portForwarding) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._certificateFormat) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._clientIdleTimeout) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._disconnectExpiredCert) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._bpf) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._permitX11Forwarding) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._maxConnections) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._maxSessions) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._requestAccess) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._requestPrompt) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._lock) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._recordSession) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._desktopClipboard) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._certExtensions) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._maxKubernetesConnections) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._desktopDirectorySharing) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._createHostUser) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._pinSourceIp) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._sshfileCopy) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._requireMfatype) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._deviceTrustMode) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._idp) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._createDesktopUser) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._createDatabaseUser) }()
        case 28: try { try decoder.decodeSingularEnumField(value: &_storage._createHostUserMode) }()
        case 29: try { try decoder.decodeSingularEnumField(value: &_storage._createDatabaseUserMode) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._forwardAgent != false {
        try visitor.visitSingularBoolField(value: _storage._forwardAgent, fieldNumber: 1)
      }
      if _storage._maxSessionTtl != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxSessionTtl, fieldNumber: 2)
      }
      try { if let v = _storage._portForwarding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._certificateFormat.isEmpty {
        try visitor.visitSingularStringField(value: _storage._certificateFormat, fieldNumber: 4)
      }
      if _storage._clientIdleTimeout != 0 {
        try visitor.visitSingularInt64Field(value: _storage._clientIdleTimeout, fieldNumber: 5)
      }
      if _storage._disconnectExpiredCert != false {
        try visitor.visitSingularBoolField(value: _storage._disconnectExpiredCert, fieldNumber: 6)
      }
      if !_storage._bpf.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._bpf, fieldNumber: 7)
      }
      if _storage._permitX11Forwarding != false {
        try visitor.visitSingularBoolField(value: _storage._permitX11Forwarding, fieldNumber: 8)
      }
      if _storage._maxConnections != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxConnections, fieldNumber: 9)
      }
      if _storage._maxSessions != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxSessions, fieldNumber: 10)
      }
      if !_storage._requestAccess.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestAccess, fieldNumber: 11)
      }
      if !_storage._requestPrompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestPrompt, fieldNumber: 12)
      }
      if !_storage._lock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lock, fieldNumber: 14)
      }
      try { if let v = _storage._recordSession {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._desktopClipboard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._certExtensions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._certExtensions, fieldNumber: 17)
      }
      if _storage._maxKubernetesConnections != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxKubernetesConnections, fieldNumber: 18)
      }
      try { if let v = _storage._desktopDirectorySharing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._createHostUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if _storage._pinSourceIp != false {
        try visitor.visitSingularBoolField(value: _storage._pinSourceIp, fieldNumber: 21)
      }
      try { if let v = _storage._sshfileCopy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if _storage._requireMfatype != .off {
        try visitor.visitSingularEnumField(value: _storage._requireMfatype, fieldNumber: 23)
      }
      if !_storage._deviceTrustMode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deviceTrustMode, fieldNumber: 24)
      }
      try { if let v = _storage._idp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._createDesktopUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._createDatabaseUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      if _storage._createHostUserMode != .hostUserModeUnspecified {
        try visitor.visitSingularEnumField(value: _storage._createHostUserMode, fieldNumber: 28)
      }
      if _storage._createDatabaseUserMode != .dbUserModeUnspecified {
        try visitor.visitSingularEnumField(value: _storage._createDatabaseUserMode, fieldNumber: 29)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RoleOptions, rhs: Types_RoleOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._forwardAgent != rhs_storage._forwardAgent {return false}
        if _storage._maxSessionTtl != rhs_storage._maxSessionTtl {return false}
        if _storage._portForwarding != rhs_storage._portForwarding {return false}
        if _storage._certificateFormat != rhs_storage._certificateFormat {return false}
        if _storage._clientIdleTimeout != rhs_storage._clientIdleTimeout {return false}
        if _storage._disconnectExpiredCert != rhs_storage._disconnectExpiredCert {return false}
        if _storage._bpf != rhs_storage._bpf {return false}
        if _storage._permitX11Forwarding != rhs_storage._permitX11Forwarding {return false}
        if _storage._maxConnections != rhs_storage._maxConnections {return false}
        if _storage._maxSessions != rhs_storage._maxSessions {return false}
        if _storage._requestAccess != rhs_storage._requestAccess {return false}
        if _storage._requestPrompt != rhs_storage._requestPrompt {return false}
        if _storage._lock != rhs_storage._lock {return false}
        if _storage._recordSession != rhs_storage._recordSession {return false}
        if _storage._desktopClipboard != rhs_storage._desktopClipboard {return false}
        if _storage._certExtensions != rhs_storage._certExtensions {return false}
        if _storage._maxKubernetesConnections != rhs_storage._maxKubernetesConnections {return false}
        if _storage._desktopDirectorySharing != rhs_storage._desktopDirectorySharing {return false}
        if _storage._createHostUser != rhs_storage._createHostUser {return false}
        if _storage._pinSourceIp != rhs_storage._pinSourceIp {return false}
        if _storage._sshfileCopy != rhs_storage._sshfileCopy {return false}
        if _storage._requireMfatype != rhs_storage._requireMfatype {return false}
        if _storage._deviceTrustMode != rhs_storage._deviceTrustMode {return false}
        if _storage._idp != rhs_storage._idp {return false}
        if _storage._createDesktopUser != rhs_storage._createDesktopUser {return false}
        if _storage._createDatabaseUser != rhs_storage._createDatabaseUser {return false}
        if _storage._createHostUserMode != rhs_storage._createHostUserMode {return false}
        if _storage._createDatabaseUserMode != rhs_storage._createDatabaseUserMode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RecordSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordSession"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Desktop"),
    2: .same(proto: "Default"),
    3: .same(proto: "SSH"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._desktop) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`default`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ssh) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._desktop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.`default`.isEmpty {
      try visitor.visitSingularStringField(value: self.`default`, fieldNumber: 2)
    }
    if !self.ssh.isEmpty {
      try visitor.visitSingularStringField(value: self.ssh, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RecordSession, rhs: Types_RecordSession) -> Bool {
    if lhs._desktop != rhs._desktop {return false}
    if lhs.`default` != rhs.`default` {return false}
    if lhs.ssh != rhs.ssh {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CertExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertExtension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "Mode"),
    3: .same(proto: "Name"),
    4: .same(proto: "Value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .ssh {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.mode != .extension {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CertExtension, rhs: Types_CertExtension) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RoleConditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleConditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Logins"),
    2: .same(proto: "Namespaces"),
    3: .same(proto: "NodeLabels"),
    4: .same(proto: "Rules"),
    5: .same(proto: "KubeGroups"),
    6: .same(proto: "Request"),
    7: .same(proto: "KubeUsers"),
    8: .same(proto: "AppLabels"),
    9: .same(proto: "ClusterLabels"),
    10: .same(proto: "KubernetesLabels"),
    11: .same(proto: "DatabaseLabels"),
    12: .same(proto: "DatabaseNames"),
    13: .same(proto: "DatabaseUsers"),
    14: .same(proto: "Impersonate"),
    15: .same(proto: "ReviewRequests"),
    16: .same(proto: "AWSRoleARNs"),
    17: .same(proto: "WindowsDesktopLogins"),
    18: .same(proto: "WindowsDesktopLabels"),
    19: .same(proto: "RequireSessionJoin"),
    20: .same(proto: "JoinSessions"),
    21: .same(proto: "HostGroups"),
    22: .same(proto: "HostSudoers"),
    23: .same(proto: "AzureIdentities"),
    24: .same(proto: "KubernetesResources"),
    25: .same(proto: "GCPServiceAccounts"),
    26: .same(proto: "DatabaseServiceLabels"),
    27: .same(proto: "GroupLabels"),
    28: .same(proto: "DesktopGroups"),
    29: .same(proto: "DatabaseRoles"),
    30: .same(proto: "NodeLabelsExpression"),
    31: .same(proto: "AppLabelsExpression"),
    32: .same(proto: "ClusterLabelsExpression"),
    33: .same(proto: "KubernetesLabelsExpression"),
    34: .same(proto: "DatabaseLabelsExpression"),
    35: .same(proto: "DatabaseServiceLabelsExpression"),
    36: .same(proto: "WindowsDesktopLabelsExpression"),
    37: .same(proto: "GroupLabelsExpression"),
  ]

  fileprivate class _StorageClass {
    var _logins: [String] = []
    var _namespaces: [String] = []
    var _nodeLabels: Wrappers_LabelValues? = nil
    var _rules: [Types_Rule] = []
    var _kubeGroups: [String] = []
    var _request: Types_AccessRequestConditions? = nil
    var _kubeUsers: [String] = []
    var _appLabels: Wrappers_LabelValues? = nil
    var _clusterLabels: Wrappers_LabelValues? = nil
    var _kubernetesLabels: Wrappers_LabelValues? = nil
    var _databaseLabels: Wrappers_LabelValues? = nil
    var _databaseNames: [String] = []
    var _databaseUsers: [String] = []
    var _impersonate: Types_ImpersonateConditions? = nil
    var _reviewRequests: Types_AccessReviewConditions? = nil
    var _awsroleArns: [String] = []
    var _windowsDesktopLogins: [String] = []
    var _windowsDesktopLabels: Wrappers_LabelValues? = nil
    var _requireSessionJoin: [Types_SessionRequirePolicy] = []
    var _joinSessions: [Types_SessionJoinPolicy] = []
    var _hostGroups: [String] = []
    var _hostSudoers: [String] = []
    var _azureIdentities: [String] = []
    var _kubernetesResources: [Types_KubernetesResource] = []
    var _gcpserviceAccounts: [String] = []
    var _databaseServiceLabels: Wrappers_LabelValues? = nil
    var _groupLabels: Wrappers_LabelValues? = nil
    var _desktopGroups: [String] = []
    var _databaseRoles: [String] = []
    var _nodeLabelsExpression: String = String()
    var _appLabelsExpression: String = String()
    var _clusterLabelsExpression: String = String()
    var _kubernetesLabelsExpression: String = String()
    var _databaseLabelsExpression: String = String()
    var _databaseServiceLabelsExpression: String = String()
    var _windowsDesktopLabelsExpression: String = String()
    var _groupLabelsExpression: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _logins = source._logins
      _namespaces = source._namespaces
      _nodeLabels = source._nodeLabels
      _rules = source._rules
      _kubeGroups = source._kubeGroups
      _request = source._request
      _kubeUsers = source._kubeUsers
      _appLabels = source._appLabels
      _clusterLabels = source._clusterLabels
      _kubernetesLabels = source._kubernetesLabels
      _databaseLabels = source._databaseLabels
      _databaseNames = source._databaseNames
      _databaseUsers = source._databaseUsers
      _impersonate = source._impersonate
      _reviewRequests = source._reviewRequests
      _awsroleArns = source._awsroleArns
      _windowsDesktopLogins = source._windowsDesktopLogins
      _windowsDesktopLabels = source._windowsDesktopLabels
      _requireSessionJoin = source._requireSessionJoin
      _joinSessions = source._joinSessions
      _hostGroups = source._hostGroups
      _hostSudoers = source._hostSudoers
      _azureIdentities = source._azureIdentities
      _kubernetesResources = source._kubernetesResources
      _gcpserviceAccounts = source._gcpserviceAccounts
      _databaseServiceLabels = source._databaseServiceLabels
      _groupLabels = source._groupLabels
      _desktopGroups = source._desktopGroups
      _databaseRoles = source._databaseRoles
      _nodeLabelsExpression = source._nodeLabelsExpression
      _appLabelsExpression = source._appLabelsExpression
      _clusterLabelsExpression = source._clusterLabelsExpression
      _kubernetesLabelsExpression = source._kubernetesLabelsExpression
      _databaseLabelsExpression = source._databaseLabelsExpression
      _databaseServiceLabelsExpression = source._databaseServiceLabelsExpression
      _windowsDesktopLabelsExpression = source._windowsDesktopLabelsExpression
      _groupLabelsExpression = source._groupLabelsExpression
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedStringField(value: &_storage._logins) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._namespaces) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._nodeLabels) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._rules) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._kubeGroups) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._kubeUsers) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._appLabels) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._clusterLabels) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._kubernetesLabels) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._databaseLabels) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._databaseNames) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._databaseUsers) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._impersonate) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._reviewRequests) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._awsroleArns) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._windowsDesktopLogins) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._windowsDesktopLabels) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._requireSessionJoin) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._joinSessions) }()
        case 21: try { try decoder.decodeRepeatedStringField(value: &_storage._hostGroups) }()
        case 22: try { try decoder.decodeRepeatedStringField(value: &_storage._hostSudoers) }()
        case 23: try { try decoder.decodeRepeatedStringField(value: &_storage._azureIdentities) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._kubernetesResources) }()
        case 25: try { try decoder.decodeRepeatedStringField(value: &_storage._gcpserviceAccounts) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._databaseServiceLabels) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._groupLabels) }()
        case 28: try { try decoder.decodeRepeatedStringField(value: &_storage._desktopGroups) }()
        case 29: try { try decoder.decodeRepeatedStringField(value: &_storage._databaseRoles) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._nodeLabelsExpression) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._appLabelsExpression) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._clusterLabelsExpression) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._kubernetesLabelsExpression) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._databaseLabelsExpression) }()
        case 35: try { try decoder.decodeSingularStringField(value: &_storage._databaseServiceLabelsExpression) }()
        case 36: try { try decoder.decodeSingularStringField(value: &_storage._windowsDesktopLabelsExpression) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._groupLabelsExpression) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._logins.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._logins, fieldNumber: 1)
      }
      if !_storage._namespaces.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._namespaces, fieldNumber: 2)
      }
      try { if let v = _storage._nodeLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._rules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rules, fieldNumber: 4)
      }
      if !_storage._kubeGroups.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._kubeGroups, fieldNumber: 5)
      }
      try { if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._kubeUsers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._kubeUsers, fieldNumber: 7)
      }
      try { if let v = _storage._appLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._clusterLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._kubernetesLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._databaseLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._databaseNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._databaseNames, fieldNumber: 12)
      }
      if !_storage._databaseUsers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._databaseUsers, fieldNumber: 13)
      }
      try { if let v = _storage._impersonate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._reviewRequests {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._awsroleArns.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._awsroleArns, fieldNumber: 16)
      }
      if !_storage._windowsDesktopLogins.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._windowsDesktopLogins, fieldNumber: 17)
      }
      try { if let v = _storage._windowsDesktopLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._requireSessionJoin.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requireSessionJoin, fieldNumber: 19)
      }
      if !_storage._joinSessions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._joinSessions, fieldNumber: 20)
      }
      if !_storage._hostGroups.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._hostGroups, fieldNumber: 21)
      }
      if !_storage._hostSudoers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._hostSudoers, fieldNumber: 22)
      }
      if !_storage._azureIdentities.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._azureIdentities, fieldNumber: 23)
      }
      if !_storage._kubernetesResources.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._kubernetesResources, fieldNumber: 24)
      }
      if !_storage._gcpserviceAccounts.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._gcpserviceAccounts, fieldNumber: 25)
      }
      try { if let v = _storage._databaseServiceLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._groupLabels {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      if !_storage._desktopGroups.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._desktopGroups, fieldNumber: 28)
      }
      if !_storage._databaseRoles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._databaseRoles, fieldNumber: 29)
      }
      if !_storage._nodeLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodeLabelsExpression, fieldNumber: 30)
      }
      if !_storage._appLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appLabelsExpression, fieldNumber: 31)
      }
      if !_storage._clusterLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterLabelsExpression, fieldNumber: 32)
      }
      if !_storage._kubernetesLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kubernetesLabelsExpression, fieldNumber: 33)
      }
      if !_storage._databaseLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._databaseLabelsExpression, fieldNumber: 34)
      }
      if !_storage._databaseServiceLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._databaseServiceLabelsExpression, fieldNumber: 35)
      }
      if !_storage._windowsDesktopLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._windowsDesktopLabelsExpression, fieldNumber: 36)
      }
      if !_storage._groupLabelsExpression.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupLabelsExpression, fieldNumber: 37)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RoleConditions, rhs: Types_RoleConditions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._logins != rhs_storage._logins {return false}
        if _storage._namespaces != rhs_storage._namespaces {return false}
        if _storage._nodeLabels != rhs_storage._nodeLabels {return false}
        if _storage._rules != rhs_storage._rules {return false}
        if _storage._kubeGroups != rhs_storage._kubeGroups {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._kubeUsers != rhs_storage._kubeUsers {return false}
        if _storage._appLabels != rhs_storage._appLabels {return false}
        if _storage._clusterLabels != rhs_storage._clusterLabels {return false}
        if _storage._kubernetesLabels != rhs_storage._kubernetesLabels {return false}
        if _storage._databaseLabels != rhs_storage._databaseLabels {return false}
        if _storage._databaseNames != rhs_storage._databaseNames {return false}
        if _storage._databaseUsers != rhs_storage._databaseUsers {return false}
        if _storage._impersonate != rhs_storage._impersonate {return false}
        if _storage._reviewRequests != rhs_storage._reviewRequests {return false}
        if _storage._awsroleArns != rhs_storage._awsroleArns {return false}
        if _storage._windowsDesktopLogins != rhs_storage._windowsDesktopLogins {return false}
        if _storage._windowsDesktopLabels != rhs_storage._windowsDesktopLabels {return false}
        if _storage._requireSessionJoin != rhs_storage._requireSessionJoin {return false}
        if _storage._joinSessions != rhs_storage._joinSessions {return false}
        if _storage._hostGroups != rhs_storage._hostGroups {return false}
        if _storage._hostSudoers != rhs_storage._hostSudoers {return false}
        if _storage._azureIdentities != rhs_storage._azureIdentities {return false}
        if _storage._kubernetesResources != rhs_storage._kubernetesResources {return false}
        if _storage._gcpserviceAccounts != rhs_storage._gcpserviceAccounts {return false}
        if _storage._databaseServiceLabels != rhs_storage._databaseServiceLabels {return false}
        if _storage._groupLabels != rhs_storage._groupLabels {return false}
        if _storage._desktopGroups != rhs_storage._desktopGroups {return false}
        if _storage._databaseRoles != rhs_storage._databaseRoles {return false}
        if _storage._nodeLabelsExpression != rhs_storage._nodeLabelsExpression {return false}
        if _storage._appLabelsExpression != rhs_storage._appLabelsExpression {return false}
        if _storage._clusterLabelsExpression != rhs_storage._clusterLabelsExpression {return false}
        if _storage._kubernetesLabelsExpression != rhs_storage._kubernetesLabelsExpression {return false}
        if _storage._databaseLabelsExpression != rhs_storage._databaseLabelsExpression {return false}
        if _storage._databaseServiceLabelsExpression != rhs_storage._databaseServiceLabelsExpression {return false}
        if _storage._windowsDesktopLabelsExpression != rhs_storage._windowsDesktopLabelsExpression {return false}
        if _storage._groupLabelsExpression != rhs_storage._groupLabelsExpression {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "Namespace"),
    3: .same(proto: "Name"),
    4: .same(proto: "Verbs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.verbs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.verbs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.verbs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesResource, rhs: Types_KubernetesResource) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.name != rhs.name {return false}
    if lhs.verbs != rhs.verbs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionRequirePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionRequirePolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Filter"),
    3: .same(proto: "Kinds"),
    4: .same(proto: "Count"),
    5: .same(proto: "Modes"),
    6: .same(proto: "OnLeave"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.kinds) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.modes) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.onLeave) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kinds, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 4)
    }
    if !self.modes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modes, fieldNumber: 5)
    }
    if !self.onLeave.isEmpty {
      try visitor.visitSingularStringField(value: self.onLeave, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionRequirePolicy, rhs: Types_SessionRequirePolicy) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.count != rhs.count {return false}
    if lhs.modes != rhs.modes {return false}
    if lhs.onLeave != rhs.onLeave {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionJoinPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionJoinPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Roles"),
    3: .same(proto: "Kinds"),
    4: .same(proto: "Modes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.kinds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.modes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kinds, fieldNumber: 3)
    }
    if !self.modes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.modes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionJoinPolicy, rhs: Types_SessionJoinPolicy) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.modes != rhs.modes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessRequestConditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestConditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Roles"),
    2: .same(proto: "ClaimsToRoles"),
    3: .same(proto: "Annotations"),
    4: .same(proto: "Thresholds"),
    5: .same(proto: "SuggestedReviewers"),
    6: .same(proto: "SearchAsRoles"),
    7: .same(proto: "MaxDuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.claimsToRoles) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._annotations) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.thresholds) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.suggestedReviewers) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.searchAsRoles) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.maxDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.claimsToRoles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.claimsToRoles, fieldNumber: 2)
    }
    try { if let v = self._annotations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.thresholds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.thresholds, fieldNumber: 4)
    }
    if !self.suggestedReviewers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.suggestedReviewers, fieldNumber: 5)
    }
    if !self.searchAsRoles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searchAsRoles, fieldNumber: 6)
    }
    if self.maxDuration != 0 {
      try visitor.visitSingularInt64Field(value: self.maxDuration, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessRequestConditions, rhs: Types_AccessRequestConditions) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.claimsToRoles != rhs.claimsToRoles {return false}
    if lhs._annotations != rhs._annotations {return false}
    if lhs.thresholds != rhs.thresholds {return false}
    if lhs.suggestedReviewers != rhs.suggestedReviewers {return false}
    if lhs.searchAsRoles != rhs.searchAsRoles {return false}
    if lhs.maxDuration != rhs.maxDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessReviewConditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessReviewConditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Roles"),
    2: .same(proto: "ClaimsToRoles"),
    3: .same(proto: "Where"),
    4: .same(proto: "PreviewAsRoles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.claimsToRoles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.`where`) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.previewAsRoles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.claimsToRoles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.claimsToRoles, fieldNumber: 2)
    }
    if !self.`where`.isEmpty {
      try visitor.visitSingularStringField(value: self.`where`, fieldNumber: 3)
    }
    if !self.previewAsRoles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.previewAsRoles, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessReviewConditions, rhs: Types_AccessReviewConditions) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.claimsToRoles != rhs.claimsToRoles {return false}
    if lhs.`where` != rhs.`where` {return false}
    if lhs.previewAsRoles != rhs.previewAsRoles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessRequestAllowedPromotion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestAllowedPromotion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accessListName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessListName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessListName.isEmpty {
      try visitor.visitSingularStringField(value: self.accessListName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessRequestAllowedPromotion, rhs: Types_AccessRequestAllowedPromotion) -> Bool {
    if lhs.accessListName != rhs.accessListName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AccessRequestAllowedPromotions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestAllowedPromotions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "promotions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.promotions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.promotions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.promotions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AccessRequestAllowedPromotions, rhs: Types_AccessRequestAllowedPromotions) -> Bool {
    if lhs.promotions != rhs.promotions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClaimMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClaimMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Claim"),
    2: .same(proto: "Value"),
    3: .same(proto: "Roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.claim) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.claim.isEmpty {
      try visitor.visitSingularStringField(value: self.claim, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClaimMapping, rhs: Types_ClaimMapping) -> Bool {
    if lhs.claim != rhs.claim {return false}
    if lhs.value != rhs.value {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TraitMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TraitMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Trait"),
    2: .same(proto: "Value"),
    3: .same(proto: "Roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trait) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trait.isEmpty {
      try visitor.visitSingularStringField(value: self.trait, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TraitMapping, rhs: Types_TraitMapping) -> Bool {
    if lhs.trait != rhs.trait {return false}
    if lhs.value != rhs.value {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Resources"),
    2: .same(proto: "Verbs"),
    3: .same(proto: "Where"),
    4: .same(proto: "Actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.resources) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.verbs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.`where`) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.actions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resources, fieldNumber: 1)
    }
    if !self.verbs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.verbs, fieldNumber: 2)
    }
    if !self.`where`.isEmpty {
      try visitor.visitSingularStringField(value: self.`where`, fieldNumber: 3)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.actions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Rule, rhs: Types_Rule) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.verbs != rhs.verbs {return false}
    if lhs.`where` != rhs.`where` {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ImpersonateConditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ImpersonateConditions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Users"),
    2: .same(proto: "Roles"),
    3: .same(proto: "Where"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.users) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.`where`) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedStringField(value: self.users, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    if !self.`where`.isEmpty {
      try visitor.visitSingularStringField(value: self.`where`, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ImpersonateConditions, rhs: Types_ImpersonateConditions) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.`where` != rhs.`where` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_BoolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoolValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_BoolValue, rhs: Types_BoolValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserV2, rhs: Types_UserV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OIDCIdentities"),
    2: .same(proto: "SAMLIdentities"),
    3: .same(proto: "GithubIdentities"),
    4: .same(proto: "Roles"),
    5: .same(proto: "Traits"),
    6: .same(proto: "Status"),
    7: .same(proto: "Expires"),
    8: .same(proto: "CreatedBy"),
    9: .same(proto: "LocalAuth"),
    10: .same(proto: "TrustedDeviceIDs"),
  ]

  fileprivate class _StorageClass {
    var _oidcidentities: [Types_ExternalIdentity] = []
    var _samlidentities: [Types_ExternalIdentity] = []
    var _githubIdentities: [Types_ExternalIdentity] = []
    var _roles: [String] = []
    var _traits: Wrappers_LabelValues? = nil
    var _status: Types_LoginStatus? = nil
    var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _createdBy: Types_CreatedBy? = nil
    var _localAuth: Types_LocalAuthSecrets? = nil
    var _trustedDeviceIds: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _oidcidentities = source._oidcidentities
      _samlidentities = source._samlidentities
      _githubIdentities = source._githubIdentities
      _roles = source._roles
      _traits = source._traits
      _status = source._status
      _expires = source._expires
      _createdBy = source._createdBy
      _localAuth = source._localAuth
      _trustedDeviceIds = source._trustedDeviceIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._oidcidentities) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._samlidentities) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._githubIdentities) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._traits) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._expires) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._createdBy) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._localAuth) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._trustedDeviceIds) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._oidcidentities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oidcidentities, fieldNumber: 1)
      }
      if !_storage._samlidentities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._samlidentities, fieldNumber: 2)
      }
      if !_storage._githubIdentities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._githubIdentities, fieldNumber: 3)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 4)
      }
      try { if let v = _storage._traits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._createdBy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._localAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._trustedDeviceIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._trustedDeviceIds, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserSpecV2, rhs: Types_UserSpecV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._oidcidentities != rhs_storage._oidcidentities {return false}
        if _storage._samlidentities != rhs_storage._samlidentities {return false}
        if _storage._githubIdentities != rhs_storage._githubIdentities {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._traits != rhs_storage._traits {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._createdBy != rhs_storage._createdBy {return false}
        if _storage._localAuth != rhs_storage._localAuth {return false}
        if _storage._trustedDeviceIds != rhs_storage._trustedDeviceIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ExternalIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExternalIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ConnectorID"),
    2: .same(proto: "Username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectorID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorID, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ExternalIdentity, rhs: Types_ExternalIdentity) -> Bool {
    if lhs.connectorID != rhs.connectorID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_LoginStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "IsLocked"),
    2: .same(proto: "LockedMessage"),
    3: .same(proto: "LockedTime"),
    4: .same(proto: "LockExpires"),
    5: .same(proto: "RecoveryAttemptLockExpires"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isLocked) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lockedMessage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lockedTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lockExpires) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._recoveryAttemptLockExpires) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isLocked != false {
      try visitor.visitSingularBoolField(value: self.isLocked, fieldNumber: 1)
    }
    if !self.lockedMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.lockedMessage, fieldNumber: 2)
    }
    try { if let v = self._lockedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lockExpires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._recoveryAttemptLockExpires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_LoginStatus, rhs: Types_LoginStatus) -> Bool {
    if lhs.isLocked != rhs.isLocked {return false}
    if lhs.lockedMessage != rhs.lockedMessage {return false}
    if lhs._lockedTime != rhs._lockedTime {return false}
    if lhs._lockExpires != rhs._lockExpires {return false}
    if lhs._recoveryAttemptLockExpires != rhs._recoveryAttemptLockExpires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CreatedBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreatedBy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connector"),
    2: .same(proto: "Time"),
    3: .same(proto: "User"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connector) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CreatedBy, rhs: Types_CreatedBy) -> Bool {
    if lhs._connector != rhs._connector {return false}
    if lhs._time != rhs._time {return false}
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_LocalAuthSecrets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocalAuthSecrets"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PasswordHash"),
    2: .same(proto: "TOTPKey"),
    5: .same(proto: "MFA"),
    6: .same(proto: "Webauthn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.passwordHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.totpkey) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.mfa) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._webauthn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.passwordHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.passwordHash, fieldNumber: 1)
    }
    if !self.totpkey.isEmpty {
      try visitor.visitSingularStringField(value: self.totpkey, fieldNumber: 2)
    }
    if !self.mfa.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mfa, fieldNumber: 5)
    }
    try { if let v = self._webauthn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_LocalAuthSecrets, rhs: Types_LocalAuthSecrets) -> Bool {
    if lhs.passwordHash != rhs.passwordHash {return false}
    if lhs.totpkey != rhs.totpkey {return false}
    if lhs.mfa != rhs.mfa {return false}
    if lhs._webauthn != rhs._webauthn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_MFADevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MFADevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .standard(proto: "sub_kind"),
    3: .same(proto: "version"),
    4: .same(proto: "metadata"),
    5: .same(proto: "id"),
    6: .standard(proto: "added_at"),
    7: .standard(proto: "last_used"),
    8: .same(proto: "totp"),
    9: .same(proto: "u2f"),
    10: .same(proto: "webauthn"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _id: String = String()
    var _addedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastUsed: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _device: Types_MFADevice.OneOf_Device?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _id = source._id
      _addedAt = source._addedAt
      _lastUsed = source._lastUsed
      _device = source._device
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._addedAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lastUsed) }()
        case 8: try {
          var v: Types_TOTPDevice?
          var hadOneofValue = false
          if let current = _storage._device {
            hadOneofValue = true
            if case .totp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._device = .totp(v)
          }
        }()
        case 9: try {
          var v: Types_U2FDevice?
          var hadOneofValue = false
          if let current = _storage._device {
            hadOneofValue = true
            if case .u2F(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._device = .u2F(v)
          }
        }()
        case 10: try {
          var v: Types_WebauthnDevice?
          var hadOneofValue = false
          if let current = _storage._device {
            hadOneofValue = true
            if case .webauthn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._device = .webauthn(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 5)
      }
      try { if let v = _storage._addedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._lastUsed {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      switch _storage._device {
      case .totp?: try {
        guard case .totp(let v)? = _storage._device else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .u2F?: try {
        guard case .u2F(let v)? = _storage._device else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .webauthn?: try {
        guard case .webauthn(let v)? = _storage._device else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_MFADevice, rhs: Types_MFADevice) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._addedAt != rhs_storage._addedAt {return false}
        if _storage._lastUsed != rhs_storage._lastUsed {return false}
        if _storage._device != rhs_storage._device {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TOTPDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TOTPDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TOTPDevice, rhs: Types_TOTPDevice) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_U2FDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".U2FDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_handle"),
    2: .standard(proto: "pub_key"),
    3: .same(proto: "counter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.keyHandle) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pubKey) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyHandle.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyHandle, fieldNumber: 1)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 2)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_U2FDevice, rhs: Types_U2FDevice) -> Bool {
    if lhs.keyHandle != rhs.keyHandle {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WebauthnDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebauthnDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "credential_id"),
    2: .standard(proto: "public_key_cbor"),
    3: .standard(proto: "attestation_type"),
    4: .same(proto: "aaguid"),
    5: .standard(proto: "signature_counter"),
    6: .standard(proto: "attestation_object"),
    7: .standard(proto: "resident_key"),
    8: .standard(proto: "credential_rp_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.credentialID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKeyCbor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.attestationType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.aaguid) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.signatureCounter) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.attestationObject) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.residentKey) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.credentialRpID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.credentialID.isEmpty {
      try visitor.visitSingularBytesField(value: self.credentialID, fieldNumber: 1)
    }
    if !self.publicKeyCbor.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeyCbor, fieldNumber: 2)
    }
    if !self.attestationType.isEmpty {
      try visitor.visitSingularStringField(value: self.attestationType, fieldNumber: 3)
    }
    if !self.aaguid.isEmpty {
      try visitor.visitSingularBytesField(value: self.aaguid, fieldNumber: 4)
    }
    if self.signatureCounter != 0 {
      try visitor.visitSingularUInt32Field(value: self.signatureCounter, fieldNumber: 5)
    }
    if !self.attestationObject.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationObject, fieldNumber: 6)
    }
    if self.residentKey != false {
      try visitor.visitSingularBoolField(value: self.residentKey, fieldNumber: 7)
    }
    if !self.credentialRpID.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialRpID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WebauthnDevice, rhs: Types_WebauthnDevice) -> Bool {
    if lhs.credentialID != rhs.credentialID {return false}
    if lhs.publicKeyCbor != rhs.publicKeyCbor {return false}
    if lhs.attestationType != rhs.attestationType {return false}
    if lhs.aaguid != rhs.aaguid {return false}
    if lhs.signatureCounter != rhs.signatureCounter {return false}
    if lhs.attestationObject != rhs.attestationObject {return false}
    if lhs.residentKey != rhs.residentKey {return false}
    if lhs.credentialRpID != rhs.credentialRpID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WebauthnLocalAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebauthnLocalAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UserID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WebauthnLocalAuth, rhs: Types_WebauthnLocalAuth) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ConnectorRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectorRef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "ID"),
    3: .same(proto: "Identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ConnectorRef, rhs: Types_ConnectorRef) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserRef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserRef, rhs: Types_UserRef) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ReverseTunnelV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReverseTunnelV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ReverseTunnelV2, rhs: Types_ReverseTunnelV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ReverseTunnelSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReverseTunnelSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "DialAddrs"),
    3: .same(proto: "Type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.dialAddrs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.dialAddrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dialAddrs, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ReverseTunnelSpecV2, rhs: Types_ReverseTunnelSpecV2) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.dialAddrs != rhs.dialAddrs {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TunnelConnectionV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelConnectionV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TunnelConnectionV2, rhs: Types_TunnelConnectionV2) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TunnelConnectionSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelConnectionSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClusterName"),
    2: .same(proto: "ProxyName"),
    3: .same(proto: "LastHeartbeat"),
    4: .same(proto: "Type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.proxyName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeat) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.proxyName.isEmpty {
      try visitor.visitSingularStringField(value: self.proxyName, fieldNumber: 2)
    }
    try { if let v = self._lastHeartbeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TunnelConnectionSpecV2, rhs: Types_TunnelConnectionSpecV2) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.proxyName != rhs.proxyName {return false}
    if lhs._lastHeartbeat != rhs._lastHeartbeat {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SemaphoreFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SemaphoreFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SemaphoreKind"),
    2: .same(proto: "SemaphoreName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.semaphoreKind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.semaphoreName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.semaphoreKind.isEmpty {
      try visitor.visitSingularStringField(value: self.semaphoreKind, fieldNumber: 1)
    }
    if !self.semaphoreName.isEmpty {
      try visitor.visitSingularStringField(value: self.semaphoreName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SemaphoreFilter, rhs: Types_SemaphoreFilter) -> Bool {
    if lhs.semaphoreKind != rhs.semaphoreKind {return false}
    if lhs.semaphoreName != rhs.semaphoreName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AcquireSemaphoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcquireSemaphoreRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SemaphoreKind"),
    2: .same(proto: "SemaphoreName"),
    3: .same(proto: "MaxLeases"),
    4: .same(proto: "Expires"),
    5: .same(proto: "Holder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.semaphoreKind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.semaphoreName) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maxLeases) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.holder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.semaphoreKind.isEmpty {
      try visitor.visitSingularStringField(value: self.semaphoreKind, fieldNumber: 1)
    }
    if !self.semaphoreName.isEmpty {
      try visitor.visitSingularStringField(value: self.semaphoreName, fieldNumber: 2)
    }
    if self.maxLeases != 0 {
      try visitor.visitSingularInt64Field(value: self.maxLeases, fieldNumber: 3)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.holder.isEmpty {
      try visitor.visitSingularStringField(value: self.holder, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AcquireSemaphoreRequest, rhs: Types_AcquireSemaphoreRequest) -> Bool {
    if lhs.semaphoreKind != rhs.semaphoreKind {return false}
    if lhs.semaphoreName != rhs.semaphoreName {return false}
    if lhs.maxLeases != rhs.maxLeases {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.holder != rhs.holder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SemaphoreLease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SemaphoreLease"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SemaphoreKind"),
    2: .same(proto: "SemaphoreName"),
    3: .same(proto: "LeaseID"),
    5: .same(proto: "Expires"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.semaphoreKind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.semaphoreName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.leaseID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.semaphoreKind.isEmpty {
      try visitor.visitSingularStringField(value: self.semaphoreKind, fieldNumber: 1)
    }
    if !self.semaphoreName.isEmpty {
      try visitor.visitSingularStringField(value: self.semaphoreName, fieldNumber: 2)
    }
    if !self.leaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaseID, fieldNumber: 3)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SemaphoreLease, rhs: Types_SemaphoreLease) -> Bool {
    if lhs.semaphoreKind != rhs.semaphoreKind {return false}
    if lhs.semaphoreName != rhs.semaphoreName {return false}
    if lhs.leaseID != rhs.leaseID {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SemaphoreLeaseRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SemaphoreLeaseRef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LeaseID"),
    2: .same(proto: "Expires"),
    3: .same(proto: "Holder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.leaseID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.holder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.leaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.leaseID, fieldNumber: 1)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.holder.isEmpty {
      try visitor.visitSingularStringField(value: self.holder, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SemaphoreLeaseRef, rhs: Types_SemaphoreLeaseRef) -> Bool {
    if lhs.leaseID != rhs.leaseID {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.holder != rhs.holder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SemaphoreV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SemaphoreV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SemaphoreV3, rhs: Types_SemaphoreV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SemaphoreSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SemaphoreSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Leases"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.leases) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.leases, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SemaphoreSpecV3, rhs: Types_SemaphoreSpecV3) -> Bool {
    if lhs.leases != rhs.leases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WebSessionV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebSessionV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_WebSessionSpecV2? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WebSessionV2, rhs: Types_WebSessionV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WebSessionSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebSessionSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Pub"),
    3: .same(proto: "Priv"),
    4: .same(proto: "TLSCert"),
    5: .same(proto: "BearerToken"),
    6: .same(proto: "BearerTokenExpires"),
    7: .same(proto: "Expires"),
    8: .same(proto: "LoginTime"),
    9: .same(proto: "IdleTimeout"),
    10: .same(proto: "ConsumedAccessRequestID"),
    11: .same(proto: "SAMLSession"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pub) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.priv) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tlscert) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bearerToken) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._bearerTokenExpires) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._loginTime) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.idleTimeout) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.consumedAccessRequestID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._samlsession) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.pub.isEmpty {
      try visitor.visitSingularBytesField(value: self.pub, fieldNumber: 2)
    }
    if !self.priv.isEmpty {
      try visitor.visitSingularBytesField(value: self.priv, fieldNumber: 3)
    }
    if !self.tlscert.isEmpty {
      try visitor.visitSingularBytesField(value: self.tlscert, fieldNumber: 4)
    }
    if !self.bearerToken.isEmpty {
      try visitor.visitSingularStringField(value: self.bearerToken, fieldNumber: 5)
    }
    try { if let v = self._bearerTokenExpires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._loginTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.idleTimeout != 0 {
      try visitor.visitSingularInt64Field(value: self.idleTimeout, fieldNumber: 9)
    }
    if !self.consumedAccessRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.consumedAccessRequestID, fieldNumber: 10)
    }
    try { if let v = self._samlsession {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WebSessionSpecV2, rhs: Types_WebSessionSpecV2) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.pub != rhs.pub {return false}
    if lhs.priv != rhs.priv {return false}
    if lhs.tlscert != rhs.tlscert {return false}
    if lhs.bearerToken != rhs.bearerToken {return false}
    if lhs._bearerTokenExpires != rhs._bearerTokenExpires {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs._loginTime != rhs._loginTime {return false}
    if lhs.idleTimeout != rhs.idleTimeout {return false}
    if lhs.consumedAccessRequestID != rhs.consumedAccessRequestID {return false}
    if lhs._samlsession != rhs._samlsession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WebSessionFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebSessionFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WebSessionFilter, rhs: Types_WebSessionFilter) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLSessionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLSessionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "CreateTime"),
    3: .same(proto: "ExpireTime"),
    4: .same(proto: "Index"),
    5: .same(proto: "NameID"),
    6: .same(proto: "NameIDFormat"),
    7: .same(proto: "SubjectID"),
    8: .same(proto: "Groups"),
    9: .same(proto: "UserName"),
    10: .same(proto: "UserEmail"),
    11: .same(proto: "UserCommonName"),
    12: .same(proto: "UserSurname"),
    13: .same(proto: "UserGivenName"),
    14: .same(proto: "UserScopedAffiliation"),
    15: .same(proto: "CustomAttributes"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _index: String = String()
    var _nameID: String = String()
    var _nameIdformat: String = String()
    var _subjectID: String = String()
    var _groups: [String] = []
    var _userName: String = String()
    var _userEmail: String = String()
    var _userCommonName: String = String()
    var _userSurname: String = String()
    var _userGivenName: String = String()
    var _userScopedAffiliation: String = String()
    var _customAttributes: [Types_SAMLAttribute] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _createTime = source._createTime
      _expireTime = source._expireTime
      _index = source._index
      _nameID = source._nameID
      _nameIdformat = source._nameIdformat
      _subjectID = source._subjectID
      _groups = source._groups
      _userName = source._userName
      _userEmail = source._userEmail
      _userCommonName = source._userCommonName
      _userSurname = source._userSurname
      _userGivenName = source._userGivenName
      _userScopedAffiliation = source._userScopedAffiliation
      _customAttributes = source._customAttributes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._expireTime) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._index) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._nameID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._nameIdformat) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._subjectID) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._groups) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._userName) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._userEmail) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._userCommonName) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._userSurname) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._userGivenName) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._userScopedAffiliation) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._customAttributes) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._expireTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._index.isEmpty {
        try visitor.visitSingularStringField(value: _storage._index, fieldNumber: 4)
      }
      if !_storage._nameID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nameID, fieldNumber: 5)
      }
      if !_storage._nameIdformat.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nameIdformat, fieldNumber: 6)
      }
      if !_storage._subjectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subjectID, fieldNumber: 7)
      }
      if !_storage._groups.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._groups, fieldNumber: 8)
      }
      if !_storage._userName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userName, fieldNumber: 9)
      }
      if !_storage._userEmail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userEmail, fieldNumber: 10)
      }
      if !_storage._userCommonName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userCommonName, fieldNumber: 11)
      }
      if !_storage._userSurname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userSurname, fieldNumber: 12)
      }
      if !_storage._userGivenName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userGivenName, fieldNumber: 13)
      }
      if !_storage._userScopedAffiliation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userScopedAffiliation, fieldNumber: 14)
      }
      if !_storage._customAttributes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customAttributes, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLSessionData, rhs: Types_SAMLSessionData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._expireTime != rhs_storage._expireTime {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._nameID != rhs_storage._nameID {return false}
        if _storage._nameIdformat != rhs_storage._nameIdformat {return false}
        if _storage._subjectID != rhs_storage._subjectID {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._userName != rhs_storage._userName {return false}
        if _storage._userEmail != rhs_storage._userEmail {return false}
        if _storage._userCommonName != rhs_storage._userCommonName {return false}
        if _storage._userSurname != rhs_storage._userSurname {return false}
        if _storage._userGivenName != rhs_storage._userGivenName {return false}
        if _storage._userScopedAffiliation != rhs_storage._userScopedAffiliation {return false}
        if _storage._customAttributes != rhs_storage._customAttributes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FriendlyName"),
    2: .same(proto: "Name"),
    3: .same(proto: "NameFormat"),
    4: .same(proto: "Values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.friendlyName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nameFormat) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.friendlyName.isEmpty {
      try visitor.visitSingularStringField(value: self.friendlyName, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.nameFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.nameFormat, fieldNumber: 3)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLAttribute, rhs: Types_SAMLAttribute) -> Bool {
    if lhs.friendlyName != rhs.friendlyName {return false}
    if lhs.name != rhs.name {return false}
    if lhs.nameFormat != rhs.nameFormat {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLAttributeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLAttributeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "Value"),
    3: .same(proto: "NameID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._nameID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try { if let v = self._nameID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLAttributeValue, rhs: Types_SAMLAttributeValue) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs._nameID != rhs._nameID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLNameID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLNameID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NameQualifier"),
    2: .same(proto: "SPNameQualifier"),
    3: .same(proto: "Format"),
    4: .same(proto: "SPProvidedID"),
    5: .same(proto: "Value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nameQualifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.spnameQualifier) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.spprovidedID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nameQualifier.isEmpty {
      try visitor.visitSingularStringField(value: self.nameQualifier, fieldNumber: 1)
    }
    if !self.spnameQualifier.isEmpty {
      try visitor.visitSingularStringField(value: self.spnameQualifier, fieldNumber: 2)
    }
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 3)
    }
    if !self.spprovidedID.isEmpty {
      try visitor.visitSingularStringField(value: self.spprovidedID, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLNameID, rhs: Types_SAMLNameID) -> Bool {
    if lhs.nameQualifier != rhs.nameQualifier {return false}
    if lhs.spnameQualifier != rhs.spnameQualifier {return false}
    if lhs.format != rhs.format {return false}
    if lhs.spprovidedID != rhs.spprovidedID {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RemoteClusterV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteClusterV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RemoteClusterV3, rhs: Types_RemoteClusterV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RemoteClusterStatusV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoteClusterStatusV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Connection"),
    2: .same(proto: "LastHeartbeat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connection) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.connection.isEmpty {
      try visitor.visitSingularStringField(value: self.connection, fieldNumber: 1)
    }
    try { if let v = self._lastHeartbeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RemoteClusterStatusV3, rhs: Types_RemoteClusterStatusV3) -> Bool {
    if lhs.connection != rhs.connection {return false}
    if lhs._lastHeartbeat != rhs._lastHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesCluster"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "StaticLabels"),
    3: .same(proto: "DynamicLabels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.staticLabels) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: &self.dynamicLabels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.staticLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.staticLabels, fieldNumber: 2)
    }
    if !self.dynamicLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: self.dynamicLabels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesCluster, rhs: Types_KubernetesCluster) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.staticLabels != rhs.staticLabels {return false}
    if lhs.dynamicLabels != rhs.dynamicLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesClusterV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesClusterV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_KubernetesClusterSpecV3? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesClusterV3, rhs: Types_KubernetesClusterV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesClusterSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesClusterSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DynamicLabels"),
    2: .same(proto: "Kubeconfig"),
    3: .same(proto: "Azure"),
    4: .same(proto: "AWS"),
    5: .same(proto: "GCP"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: &self.dynamicLabels) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.kubeconfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._azure) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._aws) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._gcp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dynamicLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_CommandLabelV2>.self, value: self.dynamicLabels, fieldNumber: 1)
    }
    if !self.kubeconfig.isEmpty {
      try visitor.visitSingularBytesField(value: self.kubeconfig, fieldNumber: 2)
    }
    try { if let v = self._azure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._aws {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gcp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesClusterSpecV3, rhs: Types_KubernetesClusterSpecV3) -> Bool {
    if lhs.dynamicLabels != rhs.dynamicLabels {return false}
    if lhs.kubeconfig != rhs.kubeconfig {return false}
    if lhs._azure != rhs._azure {return false}
    if lhs._aws != rhs._aws {return false}
    if lhs._gcp != rhs._gcp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubeAzure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubeAzure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ResourceName"),
    2: .same(proto: "ResourceGroup"),
    3: .same(proto: "TenantID"),
    4: .same(proto: "SubscriptionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceGroup) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tenantID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceName, fieldNumber: 1)
    }
    if !self.resourceGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceGroup, fieldNumber: 2)
    }
    if !self.tenantID.isEmpty {
      try visitor.visitSingularStringField(value: self.tenantID, fieldNumber: 3)
    }
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubeAzure, rhs: Types_KubeAzure) -> Bool {
    if lhs.resourceName != rhs.resourceName {return false}
    if lhs.resourceGroup != rhs.resourceGroup {return false}
    if lhs.tenantID != rhs.tenantID {return false}
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubeAWS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubeAWS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Region"),
    2: .same(proto: "AccountID"),
    3: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubeAWS, rhs: Types_KubeAWS) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubeGCP: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubeGCP"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Location"),
    2: .same(proto: "ProjectID"),
    3: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubeGCP, rhs: Types_KubeGCP) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesClusterV3List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesClusterV3List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "KubernetesClusters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.kubernetesClusters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kubernetesClusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kubernetesClusters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesClusterV3List, rhs: Types_KubernetesClusterV3List) -> Bool {
    if lhs.kubernetesClusters != rhs.kubernetesClusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesServerV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesServerV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesServerV3, rhs: Types_KubernetesServerV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesServerSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesServerSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Version"),
    2: .same(proto: "Hostname"),
    3: .same(proto: "HostID"),
    4: .same(proto: "Rotation"),
    5: .same(proto: "Cluster"),
    6: .same(proto: "ProxyIDs"),
  ]

  fileprivate class _StorageClass {
    var _version: String = String()
    var _hostname: String = String()
    var _hostID: String = String()
    var _rotation: Types_Rotation? = nil
    var _cluster: Types_KubernetesClusterV3? = nil
    var _proxyIds: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _hostname = source._hostname
      _hostID = source._hostID
      _rotation = source._rotation
      _cluster = source._cluster
      _proxyIds = source._proxyIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._hostID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._rotation) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._cluster) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._proxyIds) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 1)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 2)
      }
      if !_storage._hostID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostID, fieldNumber: 3)
      }
      try { if let v = _storage._rotation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._cluster {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._proxyIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._proxyIds, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesServerSpecV3, rhs: Types_KubernetesServerSpecV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._hostID != rhs_storage._hostID {return false}
        if _storage._rotation != rhs_storage._rotation {return false}
        if _storage._cluster != rhs_storage._cluster {return false}
        if _storage._proxyIds != rhs_storage._proxyIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WebTokenV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebTokenV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WebTokenV3, rhs: Types_WebTokenV3) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WebTokenSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WebTokenSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WebTokenSpecV3, rhs: Types_WebTokenSpecV3) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GetWebSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWebSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GetWebSessionRequest, rhs: Types_GetWebSessionRequest) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DeleteWebSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteWebSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "SessionID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DeleteWebSessionRequest, rhs: Types_DeleteWebSessionRequest) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GetWebTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWebTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GetWebTokenRequest, rhs: Types_GetWebTokenRequest) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DeleteWebTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteWebTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DeleteWebTokenRequest, rhs: Types_DeleteWebTokenRequest) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourceRequest, rhs: Types_ResourceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourceWithSecretsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceWithSecretsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "WithSecrets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.withSecrets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.withSecrets != false {
      try visitor.visitSingularBoolField(value: self.withSecrets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourceWithSecretsRequest, rhs: Types_ResourceWithSecretsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.withSecrets != rhs.withSecrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourcesWithSecretsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourcesWithSecretsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WithSecrets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.withSecrets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.withSecrets != false {
      try visitor.visitSingularBoolField(value: self.withSecrets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourcesWithSecretsRequest, rhs: Types_ResourcesWithSecretsRequest) -> Bool {
    if lhs.withSecrets != rhs.withSecrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourceInNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceInNamespaceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Namespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourceInNamespaceRequest, rhs: Types_ResourceInNamespaceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourcesInNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourcesInNamespaceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Namespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourcesInNamespaceRequest, rhs: Types_ResourcesInNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OIDCConnectorV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OIDCConnectorV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_OIDCConnectorSpecV3? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OIDCConnectorV3, rhs: Types_OIDCConnectorV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OIDCConnectorV3List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OIDCConnectorV3List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OIDCConnectors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.oidcconnectors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oidcconnectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oidcconnectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OIDCConnectorV3List, rhs: Types_OIDCConnectorV3List) -> Bool {
    if lhs.oidcconnectors != rhs.oidcconnectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OIDCConnectorSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OIDCConnectorSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "IssuerURL"),
    2: .same(proto: "ClientID"),
    3: .same(proto: "ClientSecret"),
    5: .same(proto: "ACR"),
    6: .same(proto: "Provider"),
    7: .same(proto: "Display"),
    8: .same(proto: "Scope"),
    9: .same(proto: "Prompt"),
    10: .same(proto: "ClaimsToRoles"),
    11: .same(proto: "GoogleServiceAccountURI"),
    12: .same(proto: "GoogleServiceAccount"),
    13: .same(proto: "GoogleAdminEmail"),
    14: .same(proto: "RedirectURLs"),
    15: .same(proto: "AllowUnverifiedEmail"),
    16: .same(proto: "UsernameClaim"),
    17: .same(proto: "MaxAge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuerURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientSecret) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.acr) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.scope) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.claimsToRoles) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.googleServiceAccountUri) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.googleServiceAccount) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.googleAdminEmail) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._redirectUrls) }()
      case 15: try { try decoder.decodeSingularBoolField(value: &self.allowUnverifiedEmail) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.usernameClaim) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._maxAge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.issuerURL.isEmpty {
      try visitor.visitSingularStringField(value: self.issuerURL, fieldNumber: 1)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 2)
    }
    if !self.clientSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSecret, fieldNumber: 3)
    }
    if !self.acr.isEmpty {
      try visitor.visitSingularStringField(value: self.acr, fieldNumber: 5)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 6)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 7)
    }
    if !self.scope.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scope, fieldNumber: 8)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 9)
    }
    if !self.claimsToRoles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.claimsToRoles, fieldNumber: 10)
    }
    if !self.googleServiceAccountUri.isEmpty {
      try visitor.visitSingularStringField(value: self.googleServiceAccountUri, fieldNumber: 11)
    }
    if !self.googleServiceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.googleServiceAccount, fieldNumber: 12)
    }
    if !self.googleAdminEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.googleAdminEmail, fieldNumber: 13)
    }
    try { if let v = self._redirectUrls {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    if self.allowUnverifiedEmail != false {
      try visitor.visitSingularBoolField(value: self.allowUnverifiedEmail, fieldNumber: 15)
    }
    if !self.usernameClaim.isEmpty {
      try visitor.visitSingularStringField(value: self.usernameClaim, fieldNumber: 16)
    }
    try { if let v = self._maxAge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OIDCConnectorSpecV3, rhs: Types_OIDCConnectorSpecV3) -> Bool {
    if lhs.issuerURL != rhs.issuerURL {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.clientSecret != rhs.clientSecret {return false}
    if lhs.acr != rhs.acr {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.display != rhs.display {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.claimsToRoles != rhs.claimsToRoles {return false}
    if lhs.googleServiceAccountUri != rhs.googleServiceAccountUri {return false}
    if lhs.googleServiceAccount != rhs.googleServiceAccount {return false}
    if lhs.googleAdminEmail != rhs.googleAdminEmail {return false}
    if lhs._redirectUrls != rhs._redirectUrls {return false}
    if lhs.allowUnverifiedEmail != rhs.allowUnverifiedEmail {return false}
    if lhs.usernameClaim != rhs.usernameClaim {return false}
    if lhs._maxAge != rhs._maxAge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_MaxAge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MaxAge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_MaxAge, rhs: Types_MaxAge) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OIDCAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OIDCAuthRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ConnectorID"),
    2: .same(proto: "Type"),
    3: .same(proto: "CheckUser"),
    4: .same(proto: "StateToken"),
    5: .same(proto: "CSRFToken"),
    6: .same(proto: "RedirectURL"),
    7: .same(proto: "PublicKey"),
    8: .same(proto: "CertTTL"),
    9: .same(proto: "CreateWebSession"),
    10: .same(proto: "ClientRedirectURL"),
    11: .same(proto: "Compatibility"),
    12: .same(proto: "RouteToCluster"),
    13: .same(proto: "KubernetesCluster"),
    14: .same(proto: "SSOTestFlow"),
    15: .same(proto: "ConnectorSpec"),
    16: .same(proto: "ProxyAddress"),
    17: .standard(proto: "attestation_statement"),
    18: .same(proto: "ClientLoginIP"),
  ]

  fileprivate class _StorageClass {
    var _connectorID: String = String()
    var _type: String = String()
    var _checkUser: Bool = false
    var _stateToken: String = String()
    var _csrftoken: String = String()
    var _redirectURL: String = String()
    var _publicKey: Data = Data()
    var _certTtl: Int64 = 0
    var _createWebSession: Bool = false
    var _clientRedirectURL: String = String()
    var _compatibility: String = String()
    var _routeToCluster: String = String()
    var _kubernetesCluster: String = String()
    var _ssotestFlow: Bool = false
    var _connectorSpec: Types_OIDCConnectorSpecV3? = nil
    var _proxyAddress: String = String()
    var _attestationStatement: Teleport_Attestation_V1_AttestationStatement? = nil
    var _clientLoginIp: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connectorID = source._connectorID
      _type = source._type
      _checkUser = source._checkUser
      _stateToken = source._stateToken
      _csrftoken = source._csrftoken
      _redirectURL = source._redirectURL
      _publicKey = source._publicKey
      _certTtl = source._certTtl
      _createWebSession = source._createWebSession
      _clientRedirectURL = source._clientRedirectURL
      _compatibility = source._compatibility
      _routeToCluster = source._routeToCluster
      _kubernetesCluster = source._kubernetesCluster
      _ssotestFlow = source._ssotestFlow
      _connectorSpec = source._connectorSpec
      _proxyAddress = source._proxyAddress
      _attestationStatement = source._attestationStatement
      _clientLoginIp = source._clientLoginIp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._connectorID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._checkUser) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateToken) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._csrftoken) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._redirectURL) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._certTtl) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._createWebSession) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._clientRedirectURL) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._compatibility) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._routeToCluster) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._kubernetesCluster) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._ssotestFlow) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._connectorSpec) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._proxyAddress) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._attestationStatement) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._clientLoginIp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._connectorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectorID, fieldNumber: 1)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._checkUser != false {
        try visitor.visitSingularBoolField(value: _storage._checkUser, fieldNumber: 3)
      }
      if !_storage._stateToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateToken, fieldNumber: 4)
      }
      if !_storage._csrftoken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._csrftoken, fieldNumber: 5)
      }
      if !_storage._redirectURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redirectURL, fieldNumber: 6)
      }
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 7)
      }
      if _storage._certTtl != 0 {
        try visitor.visitSingularInt64Field(value: _storage._certTtl, fieldNumber: 8)
      }
      if _storage._createWebSession != false {
        try visitor.visitSingularBoolField(value: _storage._createWebSession, fieldNumber: 9)
      }
      if !_storage._clientRedirectURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientRedirectURL, fieldNumber: 10)
      }
      if !_storage._compatibility.isEmpty {
        try visitor.visitSingularStringField(value: _storage._compatibility, fieldNumber: 11)
      }
      if !_storage._routeToCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._routeToCluster, fieldNumber: 12)
      }
      if !_storage._kubernetesCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kubernetesCluster, fieldNumber: 13)
      }
      if _storage._ssotestFlow != false {
        try visitor.visitSingularBoolField(value: _storage._ssotestFlow, fieldNumber: 14)
      }
      try { if let v = _storage._connectorSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._proxyAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._proxyAddress, fieldNumber: 16)
      }
      try { if let v = _storage._attestationStatement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._clientLoginIp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientLoginIp, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OIDCAuthRequest, rhs: Types_OIDCAuthRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connectorID != rhs_storage._connectorID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._checkUser != rhs_storage._checkUser {return false}
        if _storage._stateToken != rhs_storage._stateToken {return false}
        if _storage._csrftoken != rhs_storage._csrftoken {return false}
        if _storage._redirectURL != rhs_storage._redirectURL {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._certTtl != rhs_storage._certTtl {return false}
        if _storage._createWebSession != rhs_storage._createWebSession {return false}
        if _storage._clientRedirectURL != rhs_storage._clientRedirectURL {return false}
        if _storage._compatibility != rhs_storage._compatibility {return false}
        if _storage._routeToCluster != rhs_storage._routeToCluster {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._ssotestFlow != rhs_storage._ssotestFlow {return false}
        if _storage._connectorSpec != rhs_storage._connectorSpec {return false}
        if _storage._proxyAddress != rhs_storage._proxyAddress {return false}
        if _storage._attestationStatement != rhs_storage._attestationStatement {return false}
        if _storage._clientLoginIp != rhs_storage._clientLoginIp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLConnectorV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLConnectorV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_SAMLConnectorSpecV2? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLConnectorV2, rhs: Types_SAMLConnectorV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLConnectorV2List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLConnectorV2List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SAMLConnectors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.samlconnectors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.samlconnectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.samlconnectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLConnectorV2List, rhs: Types_SAMLConnectorV2List) -> Bool {
    if lhs.samlconnectors != rhs.samlconnectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLConnectorSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLConnectorSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Issuer"),
    2: .same(proto: "SSO"),
    3: .same(proto: "Cert"),
    4: .same(proto: "Display"),
    5: .same(proto: "AssertionConsumerService"),
    6: .same(proto: "Audience"),
    7: .same(proto: "ServiceProviderIssuer"),
    8: .same(proto: "EntityDescriptor"),
    9: .same(proto: "EntityDescriptorURL"),
    10: .same(proto: "AttributesToRoles"),
    11: .same(proto: "SigningKeyPair"),
    12: .same(proto: "Provider"),
    13: .same(proto: "EncryptionKeyPair"),
    14: .same(proto: "AllowIDPInitiated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sso) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cert) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.assertionConsumerService) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.audience) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.serviceProviderIssuer) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.entityDescriptor) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.entityDescriptorURL) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.attributesToRoles) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._signingKeyPair) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._encryptionKeyPair) }()
      case 14: try { try decoder.decodeSingularBoolField(value: &self.allowIdpinitiated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 1)
    }
    if !self.sso.isEmpty {
      try visitor.visitSingularStringField(value: self.sso, fieldNumber: 2)
    }
    if !self.cert.isEmpty {
      try visitor.visitSingularStringField(value: self.cert, fieldNumber: 3)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 4)
    }
    if !self.assertionConsumerService.isEmpty {
      try visitor.visitSingularStringField(value: self.assertionConsumerService, fieldNumber: 5)
    }
    if !self.audience.isEmpty {
      try visitor.visitSingularStringField(value: self.audience, fieldNumber: 6)
    }
    if !self.serviceProviderIssuer.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceProviderIssuer, fieldNumber: 7)
    }
    if !self.entityDescriptor.isEmpty {
      try visitor.visitSingularStringField(value: self.entityDescriptor, fieldNumber: 8)
    }
    if !self.entityDescriptorURL.isEmpty {
      try visitor.visitSingularStringField(value: self.entityDescriptorURL, fieldNumber: 9)
    }
    if !self.attributesToRoles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributesToRoles, fieldNumber: 10)
    }
    try { if let v = self._signingKeyPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 12)
    }
    try { if let v = self._encryptionKeyPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    if self.allowIdpinitiated != false {
      try visitor.visitSingularBoolField(value: self.allowIdpinitiated, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLConnectorSpecV2, rhs: Types_SAMLConnectorSpecV2) -> Bool {
    if lhs.issuer != rhs.issuer {return false}
    if lhs.sso != rhs.sso {return false}
    if lhs.cert != rhs.cert {return false}
    if lhs.display != rhs.display {return false}
    if lhs.assertionConsumerService != rhs.assertionConsumerService {return false}
    if lhs.audience != rhs.audience {return false}
    if lhs.serviceProviderIssuer != rhs.serviceProviderIssuer {return false}
    if lhs.entityDescriptor != rhs.entityDescriptor {return false}
    if lhs.entityDescriptorURL != rhs.entityDescriptorURL {return false}
    if lhs.attributesToRoles != rhs.attributesToRoles {return false}
    if lhs._signingKeyPair != rhs._signingKeyPair {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs._encryptionKeyPair != rhs._encryptionKeyPair {return false}
    if lhs.allowIdpinitiated != rhs.allowIdpinitiated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLAuthRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "ConnectorID"),
    3: .same(proto: "Type"),
    4: .same(proto: "CheckUser"),
    5: .same(proto: "RedirectURL"),
    6: .same(proto: "PublicKey"),
    7: .same(proto: "CertTTL"),
    8: .same(proto: "CSRFToken"),
    9: .same(proto: "CreateWebSession"),
    10: .same(proto: "ClientRedirectURL"),
    11: .same(proto: "Compatibility"),
    12: .same(proto: "RouteToCluster"),
    13: .same(proto: "KubernetesCluster"),
    14: .same(proto: "SSOTestFlow"),
    15: .same(proto: "ConnectorSpec"),
    16: .standard(proto: "attestation_statement"),
    17: .same(proto: "ClientLoginIP"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _connectorID: String = String()
    var _type: String = String()
    var _checkUser: Bool = false
    var _redirectURL: String = String()
    var _publicKey: Data = Data()
    var _certTtl: Int64 = 0
    var _csrftoken: String = String()
    var _createWebSession: Bool = false
    var _clientRedirectURL: String = String()
    var _compatibility: String = String()
    var _routeToCluster: String = String()
    var _kubernetesCluster: String = String()
    var _ssotestFlow: Bool = false
    var _connectorSpec: Types_SAMLConnectorSpecV2? = nil
    var _attestationStatement: Teleport_Attestation_V1_AttestationStatement? = nil
    var _clientLoginIp: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _connectorID = source._connectorID
      _type = source._type
      _checkUser = source._checkUser
      _redirectURL = source._redirectURL
      _publicKey = source._publicKey
      _certTtl = source._certTtl
      _csrftoken = source._csrftoken
      _createWebSession = source._createWebSession
      _clientRedirectURL = source._clientRedirectURL
      _compatibility = source._compatibility
      _routeToCluster = source._routeToCluster
      _kubernetesCluster = source._kubernetesCluster
      _ssotestFlow = source._ssotestFlow
      _connectorSpec = source._connectorSpec
      _attestationStatement = source._attestationStatement
      _clientLoginIp = source._clientLoginIp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._connectorID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._checkUser) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._redirectURL) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._certTtl) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._csrftoken) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._createWebSession) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._clientRedirectURL) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._compatibility) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._routeToCluster) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._kubernetesCluster) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._ssotestFlow) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._connectorSpec) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._attestationStatement) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._clientLoginIp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._connectorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectorID, fieldNumber: 2)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 3)
      }
      if _storage._checkUser != false {
        try visitor.visitSingularBoolField(value: _storage._checkUser, fieldNumber: 4)
      }
      if !_storage._redirectURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redirectURL, fieldNumber: 5)
      }
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 6)
      }
      if _storage._certTtl != 0 {
        try visitor.visitSingularInt64Field(value: _storage._certTtl, fieldNumber: 7)
      }
      if !_storage._csrftoken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._csrftoken, fieldNumber: 8)
      }
      if _storage._createWebSession != false {
        try visitor.visitSingularBoolField(value: _storage._createWebSession, fieldNumber: 9)
      }
      if !_storage._clientRedirectURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientRedirectURL, fieldNumber: 10)
      }
      if !_storage._compatibility.isEmpty {
        try visitor.visitSingularStringField(value: _storage._compatibility, fieldNumber: 11)
      }
      if !_storage._routeToCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._routeToCluster, fieldNumber: 12)
      }
      if !_storage._kubernetesCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kubernetesCluster, fieldNumber: 13)
      }
      if _storage._ssotestFlow != false {
        try visitor.visitSingularBoolField(value: _storage._ssotestFlow, fieldNumber: 14)
      }
      try { if let v = _storage._connectorSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._attestationStatement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._clientLoginIp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientLoginIp, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLAuthRequest, rhs: Types_SAMLAuthRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._connectorID != rhs_storage._connectorID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._checkUser != rhs_storage._checkUser {return false}
        if _storage._redirectURL != rhs_storage._redirectURL {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._certTtl != rhs_storage._certTtl {return false}
        if _storage._csrftoken != rhs_storage._csrftoken {return false}
        if _storage._createWebSession != rhs_storage._createWebSession {return false}
        if _storage._clientRedirectURL != rhs_storage._clientRedirectURL {return false}
        if _storage._compatibility != rhs_storage._compatibility {return false}
        if _storage._routeToCluster != rhs_storage._routeToCluster {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._ssotestFlow != rhs_storage._ssotestFlow {return false}
        if _storage._connectorSpec != rhs_storage._connectorSpec {return false}
        if _storage._attestationStatement != rhs_storage._attestationStatement {return false}
        if _storage._clientLoginIp != rhs_storage._clientLoginIp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AttributeMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttributeMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Value"),
    3: .same(proto: "Roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AttributeMapping, rhs: Types_AttributeMapping) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AsymmetricKeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AsymmetricKeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PrivateKey"),
    2: .same(proto: "Cert"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.privateKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cert) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.privateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKey, fieldNumber: 1)
    }
    if !self.cert.isEmpty {
      try visitor.visitSingularStringField(value: self.cert, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AsymmetricKeyPair, rhs: Types_AsymmetricKeyPair) -> Bool {
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.cert != rhs.cert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GithubConnectorV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubConnectorV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_GithubConnectorSpecV3? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GithubConnectorV3, rhs: Types_GithubConnectorV3) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GithubConnectorV3List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubConnectorV3List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GithubConnectors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.githubConnectors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.githubConnectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.githubConnectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GithubConnectorV3List, rhs: Types_GithubConnectorV3List) -> Bool {
    if lhs.githubConnectors != rhs.githubConnectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GithubConnectorSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubConnectorSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClientID"),
    2: .same(proto: "ClientSecret"),
    3: .same(proto: "RedirectURL"),
    4: .same(proto: "TeamsToLogins"),
    5: .same(proto: "Display"),
    6: .same(proto: "TeamsToRoles"),
    7: .same(proto: "EndpointURL"),
    8: .same(proto: "APIEndpointURL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientSecret) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.redirectURL) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.teamsToLogins) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.display) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.teamsToRoles) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.endpointURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.apiendpointURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.clientSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSecret, fieldNumber: 2)
    }
    if !self.redirectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.redirectURL, fieldNumber: 3)
    }
    if !self.teamsToLogins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.teamsToLogins, fieldNumber: 4)
    }
    if !self.display.isEmpty {
      try visitor.visitSingularStringField(value: self.display, fieldNumber: 5)
    }
    if !self.teamsToRoles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.teamsToRoles, fieldNumber: 6)
    }
    if !self.endpointURL.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointURL, fieldNumber: 7)
    }
    if !self.apiendpointURL.isEmpty {
      try visitor.visitSingularStringField(value: self.apiendpointURL, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GithubConnectorSpecV3, rhs: Types_GithubConnectorSpecV3) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.clientSecret != rhs.clientSecret {return false}
    if lhs.redirectURL != rhs.redirectURL {return false}
    if lhs.teamsToLogins != rhs.teamsToLogins {return false}
    if lhs.display != rhs.display {return false}
    if lhs.teamsToRoles != rhs.teamsToRoles {return false}
    if lhs.endpointURL != rhs.endpointURL {return false}
    if lhs.apiendpointURL != rhs.apiendpointURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GithubAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubAuthRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ConnectorID"),
    2: .same(proto: "Type"),
    3: .same(proto: "StateToken"),
    4: .same(proto: "CSRFToken"),
    5: .same(proto: "PublicKey"),
    6: .same(proto: "CertTTL"),
    7: .same(proto: "CreateWebSession"),
    8: .same(proto: "RedirectURL"),
    9: .same(proto: "ClientRedirectURL"),
    10: .same(proto: "Compatibility"),
    11: .same(proto: "Expires"),
    12: .same(proto: "RouteToCluster"),
    13: .same(proto: "KubernetesCluster"),
    14: .same(proto: "SSOTestFlow"),
    15: .same(proto: "ConnectorSpec"),
    16: .standard(proto: "attestation_statement"),
    17: .same(proto: "ClientLoginIP"),
  ]

  fileprivate class _StorageClass {
    var _connectorID: String = String()
    var _type: String = String()
    var _stateToken: String = String()
    var _csrftoken: String = String()
    var _publicKey: Data = Data()
    var _certTtl: Int64 = 0
    var _createWebSession: Bool = false
    var _redirectURL: String = String()
    var _clientRedirectURL: String = String()
    var _compatibility: String = String()
    var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _routeToCluster: String = String()
    var _kubernetesCluster: String = String()
    var _ssotestFlow: Bool = false
    var _connectorSpec: Types_GithubConnectorSpecV3? = nil
    var _attestationStatement: Teleport_Attestation_V1_AttestationStatement? = nil
    var _clientLoginIp: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connectorID = source._connectorID
      _type = source._type
      _stateToken = source._stateToken
      _csrftoken = source._csrftoken
      _publicKey = source._publicKey
      _certTtl = source._certTtl
      _createWebSession = source._createWebSession
      _redirectURL = source._redirectURL
      _clientRedirectURL = source._clientRedirectURL
      _compatibility = source._compatibility
      _expires = source._expires
      _routeToCluster = source._routeToCluster
      _kubernetesCluster = source._kubernetesCluster
      _ssotestFlow = source._ssotestFlow
      _connectorSpec = source._connectorSpec
      _attestationStatement = source._attestationStatement
      _clientLoginIp = source._clientLoginIp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._connectorID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._stateToken) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._csrftoken) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._certTtl) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._createWebSession) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._redirectURL) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._clientRedirectURL) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._compatibility) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._expires) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._routeToCluster) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._kubernetesCluster) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._ssotestFlow) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._connectorSpec) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._attestationStatement) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._clientLoginIp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._connectorID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectorID, fieldNumber: 1)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._stateToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateToken, fieldNumber: 3)
      }
      if !_storage._csrftoken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._csrftoken, fieldNumber: 4)
      }
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 5)
      }
      if _storage._certTtl != 0 {
        try visitor.visitSingularInt64Field(value: _storage._certTtl, fieldNumber: 6)
      }
      if _storage._createWebSession != false {
        try visitor.visitSingularBoolField(value: _storage._createWebSession, fieldNumber: 7)
      }
      if !_storage._redirectURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redirectURL, fieldNumber: 8)
      }
      if !_storage._clientRedirectURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientRedirectURL, fieldNumber: 9)
      }
      if !_storage._compatibility.isEmpty {
        try visitor.visitSingularStringField(value: _storage._compatibility, fieldNumber: 10)
      }
      try { if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._routeToCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._routeToCluster, fieldNumber: 12)
      }
      if !_storage._kubernetesCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kubernetesCluster, fieldNumber: 13)
      }
      if _storage._ssotestFlow != false {
        try visitor.visitSingularBoolField(value: _storage._ssotestFlow, fieldNumber: 14)
      }
      try { if let v = _storage._connectorSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._attestationStatement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._clientLoginIp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientLoginIp, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GithubAuthRequest, rhs: Types_GithubAuthRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connectorID != rhs_storage._connectorID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._stateToken != rhs_storage._stateToken {return false}
        if _storage._csrftoken != rhs_storage._csrftoken {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._certTtl != rhs_storage._certTtl {return false}
        if _storage._createWebSession != rhs_storage._createWebSession {return false}
        if _storage._redirectURL != rhs_storage._redirectURL {return false}
        if _storage._clientRedirectURL != rhs_storage._clientRedirectURL {return false}
        if _storage._compatibility != rhs_storage._compatibility {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._routeToCluster != rhs_storage._routeToCluster {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._ssotestFlow != rhs_storage._ssotestFlow {return false}
        if _storage._connectorSpec != rhs_storage._connectorSpec {return false}
        if _storage._attestationStatement != rhs_storage._attestationStatement {return false}
        if _storage._clientLoginIp != rhs_storage._clientLoginIp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SSOWarnings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SSOWarnings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Message"),
    2: .same(proto: "Warnings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.warnings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warnings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SSOWarnings, rhs: Types_SSOWarnings) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_CreateUserParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateUserParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ConnectorName"),
    2: .same(proto: "Username"),
    3: .same(proto: "Logins"),
    4: .same(proto: "KubeGroups"),
    5: .same(proto: "KubeUsers"),
    6: .same(proto: "Roles"),
    7: .same(proto: "Traits"),
    8: .same(proto: "SessionTTL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectorName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.logins) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.kubeGroups) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.kubeUsers) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._traits) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.sessionTtl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.connectorName.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorName, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.logins.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logins, fieldNumber: 3)
    }
    if !self.kubeGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kubeGroups, fieldNumber: 4)
    }
    if !self.kubeUsers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kubeUsers, fieldNumber: 5)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 6)
    }
    try { if let v = self._traits {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.sessionTtl != 0 {
      try visitor.visitSingularInt64Field(value: self.sessionTtl, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_CreateUserParams, rhs: Types_CreateUserParams) -> Bool {
    if lhs.connectorName != rhs.connectorName {return false}
    if lhs.username != rhs.username {return false}
    if lhs.logins != rhs.logins {return false}
    if lhs.kubeGroups != rhs.kubeGroups {return false}
    if lhs.kubeUsers != rhs.kubeUsers {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs._traits != rhs._traits {return false}
    if lhs.sessionTtl != rhs.sessionTtl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SSODiagnosticInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SSODiagnosticInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TestFlow"),
    2: .same(proto: "Error"),
    3: .same(proto: "Success"),
    4: .same(proto: "CreateUserParams"),
    10: .same(proto: "SAMLAttributesToRoles"),
    11: .same(proto: "SAMLAttributesToRolesWarnings"),
    12: .same(proto: "SAMLAttributeStatements"),
    13: .same(proto: "SAMLAssertionInfo"),
    14: .same(proto: "SAMLTraitsFromAssertions"),
    15: .same(proto: "SAMLConnectorTraitMapping"),
    20: .same(proto: "OIDCClaimsToRoles"),
    21: .same(proto: "OIDCClaimsToRolesWarnings"),
    22: .same(proto: "OIDCClaims"),
    23: .same(proto: "OIDCIdentity"),
    24: .same(proto: "OIDCTraitsFromClaims"),
    25: .same(proto: "OIDCConnectorTraitMapping"),
    30: .same(proto: "GithubClaims"),
    31: .same(proto: "GithubTeamsToLogins"),
    32: .same(proto: "GithubTeamsToRoles"),
    33: .same(proto: "GithubTokenInfo"),
    34: .same(proto: "AppliedLoginRules"),
  ]

  fileprivate class _StorageClass {
    var _testFlow: Bool = false
    var _error: String = String()
    var _success: Bool = false
    var _createUserParams: Types_CreateUserParams? = nil
    var _samlattributesToRoles: [Types_AttributeMapping] = []
    var _samlattributesToRolesWarnings: Types_SSOWarnings? = nil
    var _samlattributeStatements: Wrappers_LabelValues? = nil
    var _samlassertionInfo: Wrappers_CustomType? = nil
    var _samltraitsFromAssertions: Wrappers_LabelValues? = nil
    var _samlconnectorTraitMapping: [Types_TraitMapping] = []
    var _oidcclaimsToRoles: [Types_ClaimMapping] = []
    var _oidcclaimsToRolesWarnings: Types_SSOWarnings? = nil
    var _oidcclaims: Wrappers_CustomType? = nil
    var _oidcidentity: Wrappers_CustomType? = nil
    var _oidctraitsFromClaims: Wrappers_LabelValues? = nil
    var _oidcconnectorTraitMapping: [Types_TraitMapping] = []
    var _githubClaims: Types_GithubClaims? = nil
    var _githubTeamsToLogins: [Types_TeamMapping] = []
    var _githubTeamsToRoles: [Types_TeamRolesMapping] = []
    var _githubTokenInfo: Types_GithubTokenInfo? = nil
    var _appliedLoginRules: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _testFlow = source._testFlow
      _error = source._error
      _success = source._success
      _createUserParams = source._createUserParams
      _samlattributesToRoles = source._samlattributesToRoles
      _samlattributesToRolesWarnings = source._samlattributesToRolesWarnings
      _samlattributeStatements = source._samlattributeStatements
      _samlassertionInfo = source._samlassertionInfo
      _samltraitsFromAssertions = source._samltraitsFromAssertions
      _samlconnectorTraitMapping = source._samlconnectorTraitMapping
      _oidcclaimsToRoles = source._oidcclaimsToRoles
      _oidcclaimsToRolesWarnings = source._oidcclaimsToRolesWarnings
      _oidcclaims = source._oidcclaims
      _oidcidentity = source._oidcidentity
      _oidctraitsFromClaims = source._oidctraitsFromClaims
      _oidcconnectorTraitMapping = source._oidcconnectorTraitMapping
      _githubClaims = source._githubClaims
      _githubTeamsToLogins = source._githubTeamsToLogins
      _githubTeamsToRoles = source._githubTeamsToRoles
      _githubTokenInfo = source._githubTokenInfo
      _appliedLoginRules = source._appliedLoginRules
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._testFlow) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._error) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._success) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createUserParams) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._samlattributesToRoles) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._samlattributesToRolesWarnings) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._samlattributeStatements) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._samlassertionInfo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._samltraitsFromAssertions) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._samlconnectorTraitMapping) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._oidcclaimsToRoles) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._oidcclaimsToRolesWarnings) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._oidcclaims) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._oidcidentity) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._oidctraitsFromClaims) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._oidcconnectorTraitMapping) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._githubClaims) }()
        case 31: try { try decoder.decodeRepeatedMessageField(value: &_storage._githubTeamsToLogins) }()
        case 32: try { try decoder.decodeRepeatedMessageField(value: &_storage._githubTeamsToRoles) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._githubTokenInfo) }()
        case 34: try { try decoder.decodeRepeatedStringField(value: &_storage._appliedLoginRules) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._testFlow != false {
        try visitor.visitSingularBoolField(value: _storage._testFlow, fieldNumber: 1)
      }
      if !_storage._error.isEmpty {
        try visitor.visitSingularStringField(value: _storage._error, fieldNumber: 2)
      }
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 3)
      }
      try { if let v = _storage._createUserParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._samlattributesToRoles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._samlattributesToRoles, fieldNumber: 10)
      }
      try { if let v = _storage._samlattributesToRolesWarnings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._samlattributeStatements {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._samlassertionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._samltraitsFromAssertions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._samlconnectorTraitMapping.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._samlconnectorTraitMapping, fieldNumber: 15)
      }
      if !_storage._oidcclaimsToRoles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oidcclaimsToRoles, fieldNumber: 20)
      }
      try { if let v = _storage._oidcclaimsToRolesWarnings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._oidcclaims {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._oidcidentity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._oidctraitsFromClaims {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if !_storage._oidcconnectorTraitMapping.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._oidcconnectorTraitMapping, fieldNumber: 25)
      }
      try { if let v = _storage._githubClaims {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      if !_storage._githubTeamsToLogins.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._githubTeamsToLogins, fieldNumber: 31)
      }
      if !_storage._githubTeamsToRoles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._githubTeamsToRoles, fieldNumber: 32)
      }
      try { if let v = _storage._githubTokenInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      if !_storage._appliedLoginRules.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._appliedLoginRules, fieldNumber: 34)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SSODiagnosticInfo, rhs: Types_SSODiagnosticInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._testFlow != rhs_storage._testFlow {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._success != rhs_storage._success {return false}
        if _storage._createUserParams != rhs_storage._createUserParams {return false}
        if _storage._samlattributesToRoles != rhs_storage._samlattributesToRoles {return false}
        if _storage._samlattributesToRolesWarnings != rhs_storage._samlattributesToRolesWarnings {return false}
        if _storage._samlattributeStatements != rhs_storage._samlattributeStatements {return false}
        if _storage._samlassertionInfo != rhs_storage._samlassertionInfo {return false}
        if _storage._samltraitsFromAssertions != rhs_storage._samltraitsFromAssertions {return false}
        if _storage._samlconnectorTraitMapping != rhs_storage._samlconnectorTraitMapping {return false}
        if _storage._oidcclaimsToRoles != rhs_storage._oidcclaimsToRoles {return false}
        if _storage._oidcclaimsToRolesWarnings != rhs_storage._oidcclaimsToRolesWarnings {return false}
        if _storage._oidcclaims != rhs_storage._oidcclaims {return false}
        if _storage._oidcidentity != rhs_storage._oidcidentity {return false}
        if _storage._oidctraitsFromClaims != rhs_storage._oidctraitsFromClaims {return false}
        if _storage._oidcconnectorTraitMapping != rhs_storage._oidcconnectorTraitMapping {return false}
        if _storage._githubClaims != rhs_storage._githubClaims {return false}
        if _storage._githubTeamsToLogins != rhs_storage._githubTeamsToLogins {return false}
        if _storage._githubTeamsToRoles != rhs_storage._githubTeamsToRoles {return false}
        if _storage._githubTokenInfo != rhs_storage._githubTokenInfo {return false}
        if _storage._appliedLoginRules != rhs_storage._appliedLoginRules {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GithubTokenInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubTokenInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TokenType"),
    2: .same(proto: "Expires"),
    3: .same(proto: "Scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expires) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenType.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenType, fieldNumber: 1)
    }
    if self.expires != 0 {
      try visitor.visitSingularInt64Field(value: self.expires, fieldNumber: 2)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GithubTokenInfo, rhs: Types_GithubTokenInfo) -> Bool {
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.expires != rhs.expires {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GithubClaims: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GithubClaims"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
    2: .same(proto: "OrganizationToTeams"),
    3: .same(proto: "Teams"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._organizationToTeams) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.teams) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try { if let v = self._organizationToTeams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.teams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.teams, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GithubClaims, rhs: Types_GithubClaims) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs._organizationToTeams != rhs._organizationToTeams {return false}
    if lhs.teams != rhs.teams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TeamMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeamMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Organization"),
    2: .same(proto: "Team"),
    3: .same(proto: "Logins"),
    4: .same(proto: "KubeGroups"),
    5: .same(proto: "KubeUsers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.organization) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.team) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.logins) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.kubeGroups) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.kubeUsers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.organization.isEmpty {
      try visitor.visitSingularStringField(value: self.organization, fieldNumber: 1)
    }
    if !self.team.isEmpty {
      try visitor.visitSingularStringField(value: self.team, fieldNumber: 2)
    }
    if !self.logins.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logins, fieldNumber: 3)
    }
    if !self.kubeGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kubeGroups, fieldNumber: 4)
    }
    if !self.kubeUsers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kubeUsers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TeamMapping, rhs: Types_TeamMapping) -> Bool {
    if lhs.organization != rhs.organization {return false}
    if lhs.team != rhs.team {return false}
    if lhs.logins != rhs.logins {return false}
    if lhs.kubeGroups != rhs.kubeGroups {return false}
    if lhs.kubeUsers != rhs.kubeUsers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TeamRolesMapping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TeamRolesMapping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Organization"),
    2: .same(proto: "Team"),
    3: .same(proto: "Roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.organization) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.team) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.organization.isEmpty {
      try visitor.visitSingularStringField(value: self.organization, fieldNumber: 1)
    }
    if !self.team.isEmpty {
      try visitor.visitSingularStringField(value: self.team, fieldNumber: 2)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TeamRolesMapping, rhs: Types_TeamRolesMapping) -> Bool {
    if lhs.organization != rhs.organization {return false}
    if lhs.team != rhs.team {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TrustedClusterV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrustedClusterV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_TrustedClusterSpecV2? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TrustedClusterV2, rhs: Types_TrustedClusterV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TrustedClusterV2List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrustedClusterV2List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TrustedClusters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trustedClusters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trustedClusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trustedClusters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TrustedClusterV2List, rhs: Types_TrustedClusterV2List) -> Bool {
    if lhs.trustedClusters != rhs.trustedClusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_TrustedClusterSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrustedClusterSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Enabled"),
    2: .same(proto: "Roles"),
    3: .same(proto: "Token"),
    4: .same(proto: "ProxyAddress"),
    5: .same(proto: "ReverseTunnelAddress"),
    6: .same(proto: "RoleMap"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.proxyAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reverseTunnelAddress) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.roleMap) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 3)
    }
    if !self.proxyAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.proxyAddress, fieldNumber: 4)
    }
    if !self.reverseTunnelAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.reverseTunnelAddress, fieldNumber: 5)
    }
    if !self.roleMap.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roleMap, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_TrustedClusterSpecV2, rhs: Types_TrustedClusterSpecV2) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.token != rhs.token {return false}
    if lhs.proxyAddress != rhs.proxyAddress {return false}
    if lhs.reverseTunnelAddress != rhs.reverseTunnelAddress {return false}
    if lhs.roleMap != rhs.roleMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_LockV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LockV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_LockSpecV2? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_LockV2, rhs: Types_LockV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_LockSpecV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LockSpecV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Target"),
    2: .same(proto: "Message"),
    3: .same(proto: "Expires"),
    4: .same(proto: "CreatedAt"),
    5: .same(proto: "CreatedBy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.createdBy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.createdBy.isEmpty {
      try visitor.visitSingularStringField(value: self.createdBy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_LockSpecV2, rhs: Types_LockSpecV2) -> Bool {
    if lhs._target != rhs._target {return false}
    if lhs.message != rhs.message {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.createdBy != rhs.createdBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_LockTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LockTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Role"),
    3: .same(proto: "Login"),
    4: .same(proto: "Node"),
    5: .same(proto: "MFADevice"),
    6: .same(proto: "WindowsDesktop"),
    7: .same(proto: "AccessRequest"),
    8: .same(proto: "Device"),
    9: .same(proto: "ServerID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.login) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.node) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.mfadevice) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.windowsDesktop) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.accessRequest) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if !self.login.isEmpty {
      try visitor.visitSingularStringField(value: self.login, fieldNumber: 3)
    }
    if !self.node.isEmpty {
      try visitor.visitSingularStringField(value: self.node, fieldNumber: 4)
    }
    if !self.mfadevice.isEmpty {
      try visitor.visitSingularStringField(value: self.mfadevice, fieldNumber: 5)
    }
    if !self.windowsDesktop.isEmpty {
      try visitor.visitSingularStringField(value: self.windowsDesktop, fieldNumber: 6)
    }
    if !self.accessRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.accessRequest, fieldNumber: 7)
    }
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 8)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_LockTarget, rhs: Types_LockTarget) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.role != rhs.role {return false}
    if lhs.login != rhs.login {return false}
    if lhs.node != rhs.node {return false}
    if lhs.mfadevice != rhs.mfadevice {return false}
    if lhs.windowsDesktop != rhs.windowsDesktop {return false}
    if lhs.accessRequest != rhs.accessRequest {return false}
    if lhs.device != rhs.device {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AddressCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddressCondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CIDR"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cidr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cidr.isEmpty {
      try visitor.visitSingularStringField(value: self.cidr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AddressCondition, rhs: Types_AddressCondition) -> Bool {
    if lhs.cidr != rhs.cidr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_NetworkRestrictionsSpecV4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkRestrictionsSpecV4"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Allow"),
    2: .same(proto: "Deny"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allow) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deny) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allow.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allow, fieldNumber: 1)
    }
    if !self.deny.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deny, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_NetworkRestrictionsSpecV4, rhs: Types_NetworkRestrictionsSpecV4) -> Bool {
    if lhs.allow != rhs.allow {return false}
    if lhs.deny != rhs.deny {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_NetworkRestrictionsV4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkRestrictionsV4"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_NetworkRestrictionsV4, rhs: Types_NetworkRestrictionsV4) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WindowsDesktopServiceV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopServiceV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WindowsDesktopServiceV3, rhs: Types_WindowsDesktopServiceV3) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WindowsDesktopServiceSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopServiceSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Addr"),
    2: .same(proto: "TeleportVersion"),
    3: .same(proto: "Hostname"),
    4: .same(proto: "ProxyIDs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.teleportVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.proxyIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    if !self.teleportVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.teleportVersion, fieldNumber: 2)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 3)
    }
    if !self.proxyIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.proxyIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WindowsDesktopServiceSpecV3, rhs: Types_WindowsDesktopServiceSpecV3) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.teleportVersion != rhs.teleportVersion {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.proxyIds != rhs.proxyIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WindowsDesktopFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HostID"),
    2: .same(proto: "Name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WindowsDesktopFilter, rhs: Types_WindowsDesktopFilter) -> Bool {
    if lhs.hostID != rhs.hostID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WindowsDesktopV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WindowsDesktopV3, rhs: Types_WindowsDesktopV3) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WindowsDesktopSpecV3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowsDesktopSpecV3"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Addr"),
    2: .same(proto: "Domain"),
    3: .same(proto: "HostID"),
    4: .same(proto: "NonAD"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.nonAd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 3)
    }
    if self.nonAd != false {
      try visitor.visitSingularBoolField(value: self.nonAd, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WindowsDesktopSpecV3, rhs: Types_WindowsDesktopSpecV3) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.hostID != rhs.hostID {return false}
    if lhs.nonAd != rhs.nonAd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RegisterUsingTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterUsingTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HostID"),
    2: .same(proto: "NodeName"),
    3: .same(proto: "Role"),
    4: .same(proto: "Token"),
    5: .same(proto: "AdditionalPrincipals"),
    6: .same(proto: "DNSNames"),
    7: .same(proto: "PublicTLSKey"),
    8: .same(proto: "PublicSSHKey"),
    9: .same(proto: "RemoteAddr"),
    10: .same(proto: "EC2IdentityDocument"),
    11: .same(proto: "IDToken"),
    12: .same(proto: "Expires"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodeName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.additionalPrincipals) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.dnsnames) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.publicTlskey) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.publicSshkey) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.remoteAddr) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.ec2IdentityDocument) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.idtoken) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hostID.isEmpty {
      try visitor.visitSingularStringField(value: self.hostID, fieldNumber: 1)
    }
    if !self.nodeName.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeName, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 3)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 4)
    }
    if !self.additionalPrincipals.isEmpty {
      try visitor.visitRepeatedStringField(value: self.additionalPrincipals, fieldNumber: 5)
    }
    if !self.dnsnames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dnsnames, fieldNumber: 6)
    }
    if !self.publicTlskey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicTlskey, fieldNumber: 7)
    }
    if !self.publicSshkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicSshkey, fieldNumber: 8)
    }
    if !self.remoteAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteAddr, fieldNumber: 9)
    }
    if !self.ec2IdentityDocument.isEmpty {
      try visitor.visitSingularBytesField(value: self.ec2IdentityDocument, fieldNumber: 10)
    }
    if !self.idtoken.isEmpty {
      try visitor.visitSingularStringField(value: self.idtoken, fieldNumber: 11)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RegisterUsingTokenRequest, rhs: Types_RegisterUsingTokenRequest) -> Bool {
    if lhs.hostID != rhs.hostID {return false}
    if lhs.nodeName != rhs.nodeName {return false}
    if lhs.role != rhs.role {return false}
    if lhs.token != rhs.token {return false}
    if lhs.additionalPrincipals != rhs.additionalPrincipals {return false}
    if lhs.dnsnames != rhs.dnsnames {return false}
    if lhs.publicTlskey != rhs.publicTlskey {return false}
    if lhs.publicSshkey != rhs.publicSshkey {return false}
    if lhs.remoteAddr != rhs.remoteAddr {return false}
    if lhs.ec2IdentityDocument != rhs.ec2IdentityDocument {return false}
    if lhs.idtoken != rhs.idtoken {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RecoveryCodesV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoveryCodesV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RecoveryCodesV1, rhs: Types_RecoveryCodesV1) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RecoveryCodesSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoveryCodesSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Codes"),
    2: .same(proto: "Created"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.codes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.codes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.codes, fieldNumber: 1)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RecoveryCodesSpecV1, rhs: Types_RecoveryCodesSpecV1) -> Bool {
    if lhs.codes != rhs.codes {return false}
    if lhs._created != rhs._created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_RecoveryCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecoveryCode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HashedCode"),
    2: .same(proto: "IsUsed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hashedCode) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isUsed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashedCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.hashedCode, fieldNumber: 1)
    }
    if self.isUsed != false {
      try visitor.visitSingularBoolField(value: self.isUsed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_RecoveryCode, rhs: Types_RecoveryCode) -> Bool {
    if lhs.hashedCode != rhs.hashedCode {return false}
    if lhs.isUsed != rhs.isUsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_NullableSessionState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NullableSessionState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "State"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .pending {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_NullableSessionState, rhs: Types_NullableSessionState) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionTrackerFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "State"),
    3: .same(proto: "DesktopName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.desktopName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.desktopName.isEmpty {
      try visitor.visitSingularStringField(value: self.desktopName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionTrackerFilter, rhs: Types_SessionTrackerFilter) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs._state != rhs._state {return false}
    if lhs.desktopName != rhs.desktopName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionTrackerV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionTrackerV1, rhs: Types_SessionTrackerV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionTrackerSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SessionID"),
    2: .same(proto: "Kind"),
    3: .same(proto: "State"),
    4: .same(proto: "Created"),
    5: .same(proto: "Expires"),
    6: .same(proto: "AttachedData"),
    7: .same(proto: "Reason"),
    8: .same(proto: "Invited"),
    9: .same(proto: "Hostname"),
    10: .same(proto: "Address"),
    11: .same(proto: "ClusterName"),
    12: .same(proto: "Login"),
    13: .same(proto: "Participants"),
    14: .same(proto: "KubernetesCluster"),
    15: .same(proto: "HostUser"),
    16: .same(proto: "HostPolicies"),
    17: .same(proto: "DatabaseName"),
    18: .same(proto: "AppName"),
    19: .same(proto: "AppSessionID"),
    20: .same(proto: "DesktopName"),
    21: .same(proto: "HostID"),
    22: .same(proto: "TargetSubKind"),
    23: .same(proto: "InitialCommand"),
  ]

  fileprivate class _StorageClass {
    var _sessionID: String = String()
    var _kind: String = String()
    var _state: Types_SessionState = .pending
    var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attachedData: String = String()
    var _reason: String = String()
    var _invited: [String] = []
    var _hostname: String = String()
    var _address: String = String()
    var _clusterName: String = String()
    var _login: String = String()
    var _participants: [Types_Participant] = []
    var _kubernetesCluster: String = String()
    var _hostUser: String = String()
    var _hostPolicies: [Types_SessionTrackerPolicySet] = []
    var _databaseName: String = String()
    var _appName: String = String()
    var _appSessionID: String = String()
    var _desktopName: String = String()
    var _hostID: String = String()
    var _targetSubKind: String = String()
    var _initialCommand: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sessionID = source._sessionID
      _kind = source._kind
      _state = source._state
      _created = source._created
      _expires = source._expires
      _attachedData = source._attachedData
      _reason = source._reason
      _invited = source._invited
      _hostname = source._hostname
      _address = source._address
      _clusterName = source._clusterName
      _login = source._login
      _participants = source._participants
      _kubernetesCluster = source._kubernetesCluster
      _hostUser = source._hostUser
      _hostPolicies = source._hostPolicies
      _databaseName = source._databaseName
      _appName = source._appName
      _appSessionID = source._appSessionID
      _desktopName = source._desktopName
      _hostID = source._hostID
      _targetSubKind = source._targetSubKind
      _initialCommand = source._initialCommand
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._created) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._expires) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._attachedData) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._invited) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._address) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._clusterName) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._login) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._participants) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._kubernetesCluster) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._hostUser) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._hostPolicies) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._databaseName) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._appName) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._appSessionID) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._desktopName) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._hostID) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._targetSubKind) }()
        case 23: try { try decoder.decodeRepeatedStringField(value: &_storage._initialCommand) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionID, fieldNumber: 1)
      }
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 2)
      }
      if _storage._state != .pending {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      try { if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._attachedData.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attachedData, fieldNumber: 6)
      }
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 7)
      }
      if !_storage._invited.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._invited, fieldNumber: 8)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 9)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 10)
      }
      if !_storage._clusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterName, fieldNumber: 11)
      }
      if !_storage._login.isEmpty {
        try visitor.visitSingularStringField(value: _storage._login, fieldNumber: 12)
      }
      if !_storage._participants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._participants, fieldNumber: 13)
      }
      if !_storage._kubernetesCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kubernetesCluster, fieldNumber: 14)
      }
      if !_storage._hostUser.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostUser, fieldNumber: 15)
      }
      if !_storage._hostPolicies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hostPolicies, fieldNumber: 16)
      }
      if !_storage._databaseName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._databaseName, fieldNumber: 17)
      }
      if !_storage._appName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appName, fieldNumber: 18)
      }
      if !_storage._appSessionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appSessionID, fieldNumber: 19)
      }
      if !_storage._desktopName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desktopName, fieldNumber: 20)
      }
      if !_storage._hostID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostID, fieldNumber: 21)
      }
      if !_storage._targetSubKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetSubKind, fieldNumber: 22)
      }
      if !_storage._initialCommand.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._initialCommand, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionTrackerSpecV1, rhs: Types_SessionTrackerSpecV1) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._attachedData != rhs_storage._attachedData {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._invited != rhs_storage._invited {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._clusterName != rhs_storage._clusterName {return false}
        if _storage._login != rhs_storage._login {return false}
        if _storage._participants != rhs_storage._participants {return false}
        if _storage._kubernetesCluster != rhs_storage._kubernetesCluster {return false}
        if _storage._hostUser != rhs_storage._hostUser {return false}
        if _storage._hostPolicies != rhs_storage._hostPolicies {return false}
        if _storage._databaseName != rhs_storage._databaseName {return false}
        if _storage._appName != rhs_storage._appName {return false}
        if _storage._appSessionID != rhs_storage._appSessionID {return false}
        if _storage._desktopName != rhs_storage._desktopName {return false}
        if _storage._hostID != rhs_storage._hostID {return false}
        if _storage._targetSubKind != rhs_storage._targetSubKind {return false}
        if _storage._initialCommand != rhs_storage._initialCommand {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SessionTrackerPolicySet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionTrackerPolicySet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Version"),
    3: .same(proto: "RequireSessionJoin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.requireSessionJoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.requireSessionJoin.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requireSessionJoin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SessionTrackerPolicySet, rhs: Types_SessionTrackerPolicySet) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.requireSessionJoin != rhs.requireSessionJoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Participant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "User"),
    3: .same(proto: "Mode"),
    4: .same(proto: "LastActive"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 2)
    }
    if !self.mode.isEmpty {
      try visitor.visitSingularStringField(value: self.mode, fieldNumber: 3)
    }
    try { if let v = self._lastActive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Participant, rhs: Types_Participant) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.user != rhs.user {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs._lastActive != rhs._lastActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UIConfigV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIConfigV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UIConfigV1, rhs: Types_UIConfigV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UIConfigSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIConfigSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ScrollbackLines"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.scrollbackLines) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scrollbackLines != 0 {
      try visitor.visitSingularInt32Field(value: self.scrollbackLines, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UIConfigSpecV1, rhs: Types_UIConfigSpecV1) -> Bool {
    if lhs.scrollbackLines != rhs.scrollbackLines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstallerV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstallerV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstallerV1, rhs: Types_InstallerV1) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstallerSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstallerSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Script"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.script) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.script.isEmpty {
      try visitor.visitSingularStringField(value: self.script, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstallerSpecV1, rhs: Types_InstallerSpecV1) -> Bool {
    if lhs.script != rhs.script {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstallerV1List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstallerV1List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "installers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.installers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.installers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.installers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstallerV1List, rhs: Types_InstallerV1List) -> Bool {
    if lhs.installers != rhs.installers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SortBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SortBy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "IsDesc"),
    2: .same(proto: "Field"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isDesc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.field) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isDesc != false {
      try visitor.visitSingularBoolField(value: self.isDesc, fieldNumber: 1)
    }
    if !self.field.isEmpty {
      try visitor.visitSingularStringField(value: self.field, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SortBy, rhs: Types_SortBy) -> Bool {
    if lhs.isDesc != rhs.isDesc {return false}
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ConnectionDiagnosticV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionDiagnosticV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ConnectionDiagnosticV1, rhs: Types_ConnectionDiagnosticV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ConnectionDiagnosticSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionDiagnosticSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Success"),
    2: .same(proto: "Message"),
    3: .same(proto: "Traces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.traces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.traces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traces, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ConnectionDiagnosticSpecV1, rhs: Types_ConnectionDiagnosticSpecV1) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.message != rhs.message {return false}
    if lhs.traces != rhs.traces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ConnectionDiagnosticTrace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionDiagnosticTrace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Type"),
    2: .same(proto: "Status"),
    3: .same(proto: "Details"),
    4: .same(proto: "Error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.details) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.status != .statusUnspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 3)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ConnectionDiagnosticTrace, rhs: Types_ConnectionDiagnosticTrace) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.status != rhs.status {return false}
    if lhs.details != rhs.details {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ConnectionDiagnosticTrace.TraceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRACE_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN_ERROR"),
    2: .same(proto: "RBAC_NODE"),
    3: .same(proto: "CONNECTIVITY"),
    4: .same(proto: "RBAC_PRINCIPAL"),
    5: .same(proto: "NODE_PRINCIPAL"),
    6: .same(proto: "RBAC_KUBE"),
    7: .same(proto: "KUBE_PRINCIPAL"),
    8: .same(proto: "RBAC_DATABASE"),
    9: .same(proto: "RBAC_DATABASE_LOGIN"),
    10: .same(proto: "DATABASE_DB_USER"),
    11: .same(proto: "DATABASE_DB_NAME"),
  ]
}

extension Types_ConnectionDiagnosticTrace.StatusType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILED"),
  ]
}

extension Types_DatabaseServiceV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseServiceV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseServiceV1, rhs: Types_DatabaseServiceV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseServiceSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseServiceSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ResourceMatchers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resourceMatchers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceMatchers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceMatchers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseServiceSpecV1, rhs: Types_DatabaseServiceSpecV1) -> Bool {
    if lhs.resourceMatchers != rhs.resourceMatchers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DatabaseResourceMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DatabaseResourceMatcher"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Labels"),
    2: .same(proto: "AWS"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._aws) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._aws {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DatabaseResourceMatcher, rhs: Types_DatabaseResourceMatcher) -> Bool {
    if lhs._labels != rhs._labels {return false}
    if lhs._aws != rhs._aws {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ResourceMatcherAWS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceMatcherAWS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AssumeRoleARN"),
    2: .same(proto: "ExternalID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.assumeRoleArn) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.externalID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assumeRoleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.assumeRoleArn, fieldNumber: 1)
    }
    if !self.externalID.isEmpty {
      try visitor.visitSingularStringField(value: self.externalID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ResourceMatcherAWS, rhs: Types_ResourceMatcherAWS) -> Bool {
    if lhs.assumeRoleArn != rhs.assumeRoleArn {return false}
    if lhs.externalID != rhs.externalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterAlert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterAlert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterAlert, rhs: Types_ClusterAlert) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterAlertSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterAlertSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Severity"),
    2: .same(proto: "Message"),
    3: .same(proto: "Created"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.severity != .low {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterAlertSpec, rhs: Types_ClusterAlertSpec) -> Bool {
    if lhs.severity != rhs.severity {return false}
    if lhs.message != rhs.message {return false}
    if lhs._created != rhs._created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GetClusterAlertsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetClusterAlertsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Severity"),
    2: .same(proto: "AlertID"),
    3: .same(proto: "Labels"),
    4: .same(proto: "WithSuperseded"),
    5: .same(proto: "WithAcknowledged"),
    6: .same(proto: "WithUntargeted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.alertID) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.withSuperseded) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.withAcknowledged) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.withUntargeted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.severity != .low {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 1)
    }
    if !self.alertID.isEmpty {
      try visitor.visitSingularStringField(value: self.alertID, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    if self.withSuperseded != false {
      try visitor.visitSingularBoolField(value: self.withSuperseded, fieldNumber: 4)
    }
    if self.withAcknowledged != false {
      try visitor.visitSingularBoolField(value: self.withAcknowledged, fieldNumber: 5)
    }
    if self.withUntargeted != false {
      try visitor.visitSingularBoolField(value: self.withUntargeted, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GetClusterAlertsRequest, rhs: Types_GetClusterAlertsRequest) -> Bool {
    if lhs.severity != rhs.severity {return false}
    if lhs.alertID != rhs.alertID {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.withSuperseded != rhs.withSuperseded {return false}
    if lhs.withAcknowledged != rhs.withAcknowledged {return false}
    if lhs.withUntargeted != rhs.withUntargeted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AlertAcknowledgement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertAcknowledgement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AlertID"),
    2: .same(proto: "Reason"),
    4: .same(proto: "Expires"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.alertID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.alertID.isEmpty {
      try visitor.visitSingularStringField(value: self.alertID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AlertAcknowledgement, rhs: Types_AlertAcknowledgement) -> Bool {
    if lhs.alertID != rhs.alertID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Release: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Release"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NotesMD"),
    2: .same(proto: "Product"),
    3: .same(proto: "ReleaseID"),
    4: .same(proto: "Status"),
    5: .same(proto: "Version"),
    6: .same(proto: "Assets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.notesMd) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.product) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.releaseID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notesMd.isEmpty {
      try visitor.visitSingularStringField(value: self.notesMd, fieldNumber: 1)
    }
    if !self.product.isEmpty {
      try visitor.visitSingularStringField(value: self.product, fieldNumber: 2)
    }
    if !self.releaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseID, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 5)
    }
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Release, rhs: Types_Release) -> Bool {
    if lhs.notesMd != rhs.notesMd {return false}
    if lhs.product != rhs.product {return false}
    if lhs.releaseID != rhs.releaseID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.version != rhs.version {return false}
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Asset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Arch"),
    2: .same(proto: "Description"),
    3: .same(proto: "Name"),
    4: .same(proto: "OS"),
    5: .same(proto: "SHA256"),
    6: .same(proto: "AssetSize"),
    7: .same(proto: "DisplaySize"),
    8: .same(proto: "ReleaseIDs"),
    9: .same(proto: "PublicURL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.arch) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sha256) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.assetSize) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.displaySize) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.releaseIds) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.publicURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.arch.isEmpty {
      try visitor.visitSingularStringField(value: self.arch, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 4)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularStringField(value: self.sha256, fieldNumber: 5)
    }
    if self.assetSize != 0 {
      try visitor.visitSingularInt64Field(value: self.assetSize, fieldNumber: 6)
    }
    if !self.displaySize.isEmpty {
      try visitor.visitSingularStringField(value: self.displaySize, fieldNumber: 7)
    }
    if !self.releaseIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.releaseIds, fieldNumber: 8)
    }
    if !self.publicURL.isEmpty {
      try visitor.visitSingularStringField(value: self.publicURL, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_Asset, rhs: Types_Asset) -> Bool {
    if lhs.arch != rhs.arch {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.name != rhs.name {return false}
    if lhs.os != rhs.os {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.assetSize != rhs.assetSize {return false}
    if lhs.displaySize != rhs.displaySize {return false}
    if lhs.releaseIds != rhs.releaseIds {return false}
    if lhs.publicURL != rhs.publicURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .standard(proto: "sub_kind"),
    3: .same(proto: "version"),
    4: .same(proto: "metadata"),
    5: .same(proto: "spec"),
    6: .same(proto: "status"),
    7: .same(proto: "credentials"),
  ]

  fileprivate class _StorageClass {
    var _kind: String = String()
    var _subKind: String = String()
    var _version: String = String()
    var _metadata: Types_Metadata? = nil
    var _spec: Types_PluginSpecV1? = nil
    var _status: Types_PluginStatusV1? = nil
    var _credentials: Types_PluginCredentialsV1? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
      _subKind = source._subKind
      _version = source._version
      _metadata = source._metadata
      _spec = source._spec
      _status = source._status
      _credentials = source._credentials
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._kind) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._subKind) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._credentials) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._kind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._kind, fieldNumber: 1)
      }
      if !_storage._subKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subKind, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._credentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginV1, rhs: Types_PluginV1) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._subKind != rhs_storage._subKind {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._credentials != rhs_storage._credentials {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slack_access_plugin"),
    2: .same(proto: "opsgenie"),
    3: .same(proto: "openai"),
    4: .same(proto: "okta"),
    5: .same(proto: "jamf"),
    6: .standard(proto: "pager_duty"),
    7: .same(proto: "mattermost"),
    8: .same(proto: "jira"),
    9: .same(proto: "discord"),
    10: .same(proto: "serviceNow"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_PluginSlackAccessSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .slackAccessPlugin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .slackAccessPlugin(v)
        }
      }()
      case 2: try {
        var v: Types_PluginOpsgenieAccessSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .opsgenie(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .opsgenie(v)
        }
      }()
      case 3: try {
        var v: Types_PluginOpenAISettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .openai(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .openai(v)
        }
      }()
      case 4: try {
        var v: Types_PluginOktaSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .okta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .okta(v)
        }
      }()
      case 5: try {
        var v: Types_PluginJamfSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .jamf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .jamf(v)
        }
      }()
      case 6: try {
        var v: Types_PluginPagerDutySettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .pagerDuty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .pagerDuty(v)
        }
      }()
      case 7: try {
        var v: Types_PluginMattermostSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .mattermost(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .mattermost(v)
        }
      }()
      case 8: try {
        var v: Types_PluginJiraSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .jira(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .jira(v)
        }
      }()
      case 9: try {
        var v: Types_PluginDiscordSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .discord(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .discord(v)
        }
      }()
      case 10: try {
        var v: Types_PluginServiceNowSettings?
        var hadOneofValue = false
        if let current = self.settings {
          hadOneofValue = true
          if case .serviceNow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.settings = .serviceNow(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.settings {
    case .slackAccessPlugin?: try {
      guard case .slackAccessPlugin(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .opsgenie?: try {
      guard case .opsgenie(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .openai?: try {
      guard case .openai(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .okta?: try {
      guard case .okta(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .jamf?: try {
      guard case .jamf(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .pagerDuty?: try {
      guard case .pagerDuty(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .mattermost?: try {
      guard case .mattermost(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .jira?: try {
      guard case .jira(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .discord?: try {
      guard case .discord(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .serviceNow?: try {
      guard case .serviceNow(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginSpecV1, rhs: Types_PluginSpecV1) -> Bool {
    if lhs.settings != rhs.settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginSlackAccessSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginSlackAccessSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fallback_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fallbackChannel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fallbackChannel.isEmpty {
      try visitor.visitSingularStringField(value: self.fallbackChannel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginSlackAccessSettings, rhs: Types_PluginSlackAccessSettings) -> Bool {
    if lhs.fallbackChannel != rhs.fallbackChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginOpsgenieAccessSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginOpsgenieAccessSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "priority"),
    3: .standard(proto: "alert_tags"),
    4: .standard(proto: "default_schedules"),
    5: .standard(proto: "api_endpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.priority) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.alertTags) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.defaultSchedules) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.apiEndpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.priority.isEmpty {
      try visitor.visitSingularStringField(value: self.priority, fieldNumber: 2)
    }
    if !self.alertTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.alertTags, fieldNumber: 3)
    }
    if !self.defaultSchedules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.defaultSchedules, fieldNumber: 4)
    }
    if !self.apiEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.apiEndpoint, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginOpsgenieAccessSettings, rhs: Types_PluginOpsgenieAccessSettings) -> Bool {
    if lhs.priority != rhs.priority {return false}
    if lhs.alertTags != rhs.alertTags {return false}
    if lhs.defaultSchedules != rhs.defaultSchedules {return false}
    if lhs.apiEndpoint != rhs.apiEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginServiceNowSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginServiceNowSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_endpoint"),
    2: .same(proto: "username"),
    3: .same(proto: "password"),
    4: .standard(proto: "close_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apiEndpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.closeCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.apiEndpoint, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 3)
    }
    if !self.closeCode.isEmpty {
      try visitor.visitSingularStringField(value: self.closeCode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginServiceNowSettings, rhs: Types_PluginServiceNowSettings) -> Bool {
    if lhs.apiEndpoint != rhs.apiEndpoint {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.closeCode != rhs.closeCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginPagerDutySettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginPagerDutySettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_email"),
    2: .standard(proto: "api_endpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userEmail) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.apiEndpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmail, fieldNumber: 1)
    }
    if !self.apiEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.apiEndpoint, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginPagerDutySettings, rhs: Types_PluginPagerDutySettings) -> Bool {
    if lhs.userEmail != rhs.userEmail {return false}
    if lhs.apiEndpoint != rhs.apiEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginJiraSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginJiraSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_url"),
    2: .standard(proto: "project_key"),
    3: .standard(proto: "issue_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.issueType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.serverURL, fieldNumber: 1)
    }
    if !self.projectKey.isEmpty {
      try visitor.visitSingularStringField(value: self.projectKey, fieldNumber: 2)
    }
    if !self.issueType.isEmpty {
      try visitor.visitSingularStringField(value: self.issueType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginJiraSettings, rhs: Types_PluginJiraSettings) -> Bool {
    if lhs.serverURL != rhs.serverURL {return false}
    if lhs.projectKey != rhs.projectKey {return false}
    if lhs.issueType != rhs.issueType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginOpenAISettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginOpenAISettings"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginOpenAISettings, rhs: Types_PluginOpenAISettings) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginMattermostSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginMattermostSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_url"),
    2: .same(proto: "team"),
    3: .same(proto: "channel"),
    4: .standard(proto: "report_to_email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.team) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reportToEmail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.serverURL, fieldNumber: 1)
    }
    if !self.team.isEmpty {
      try visitor.visitSingularStringField(value: self.team, fieldNumber: 2)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 3)
    }
    if !self.reportToEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.reportToEmail, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginMattermostSettings, rhs: Types_PluginMattermostSettings) -> Bool {
    if lhs.serverURL != rhs.serverURL {return false}
    if lhs.team != rhs.team {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.reportToEmail != rhs.reportToEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginJamfSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginJamfSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "jamf_spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._jamfSpec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._jamfSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginJamfSettings, rhs: Types_PluginJamfSettings) -> Bool {
    if lhs._jamfSpec != rhs._jamfSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginOktaSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginOktaSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "org_url"),
    2: .standard(proto: "enable_user_sync"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orgURL) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableUserSync) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.orgURL, fieldNumber: 1)
    }
    if self.enableUserSync != false {
      try visitor.visitSingularBoolField(value: self.enableUserSync, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginOktaSettings, rhs: Types_PluginOktaSettings) -> Bool {
    if lhs.orgURL != rhs.orgURL {return false}
    if lhs.enableUserSync != rhs.enableUserSync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_DiscordChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiscordChannels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.channelIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.channelIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_DiscordChannels, rhs: Types_DiscordChannels) -> Bool {
    if lhs.channelIds != rhs.channelIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginDiscordSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDiscordSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_to_recipients"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_DiscordChannels>.self, value: &self.roleToRecipients) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roleToRecipients.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Types_DiscordChannels>.self, value: self.roleToRecipients, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginDiscordSettings, rhs: Types_PluginDiscordSettings) -> Bool {
    if lhs.roleToRecipients != rhs.roleToRecipients {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginBootstrapCredentialsV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginBootstrapCredentialsV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oauth2_authorization_code"),
    2: .standard(proto: "bearer_token"),
    3: .standard(proto: "id_secret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_PluginOAuth2AuthorizationCodeCredentials?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .oauth2AuthorizationCode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .oauth2AuthorizationCode(v)
        }
      }()
      case 2: try {
        var v: Types_PluginBearerTokenCredentials?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .bearerToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .bearerToken(v)
        }
      }()
      case 3: try {
        var v: Types_PluginIdSecretCredential?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .idSecret(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .idSecret(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.credentials {
    case .oauth2AuthorizationCode?: try {
      guard case .oauth2AuthorizationCode(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .bearerToken?: try {
      guard case .bearerToken(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .idSecret?: try {
      guard case .idSecret(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginBootstrapCredentialsV1, rhs: Types_PluginBootstrapCredentialsV1) -> Bool {
    if lhs.credentials != rhs.credentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginIdSecretCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginIdSecretCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "secret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginIdSecretCredential, rhs: Types_PluginIdSecretCredential) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginOAuth2AuthorizationCodeCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginOAuth2AuthorizationCodeCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "authorization_code"),
    2: .standard(proto: "redirect_uri"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authorizationCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.redirectUri) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authorizationCode.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationCode, fieldNumber: 1)
    }
    if !self.redirectUri.isEmpty {
      try visitor.visitSingularStringField(value: self.redirectUri, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginOAuth2AuthorizationCodeCredentials, rhs: Types_PluginOAuth2AuthorizationCodeCredentials) -> Bool {
    if lhs.authorizationCode != rhs.authorizationCode {return false}
    if lhs.redirectUri != rhs.redirectUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginStatusV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginStatusV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginStatusV1, rhs: Types_PluginStatusV1) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginCredentialsV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginCredentialsV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oauth2_access_token"),
    2: .standard(proto: "bearer_token"),
    3: .standard(proto: "id_secret"),
    4: .standard(proto: "static_credentials_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_PluginOAuth2AccessTokenCredentials?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .oauth2AccessToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .oauth2AccessToken(v)
        }
      }()
      case 2: try {
        var v: Types_PluginBearerTokenCredentials?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .bearerToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .bearerToken(v)
        }
      }()
      case 3: try {
        var v: Types_PluginIdSecretCredential?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .idSecret(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .idSecret(v)
        }
      }()
      case 4: try {
        var v: Types_PluginStaticCredentialsRef?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .staticCredentialsRef(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .staticCredentialsRef(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.credentials {
    case .oauth2AccessToken?: try {
      guard case .oauth2AccessToken(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .bearerToken?: try {
      guard case .bearerToken(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .idSecret?: try {
      guard case .idSecret(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .staticCredentialsRef?: try {
      guard case .staticCredentialsRef(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginCredentialsV1, rhs: Types_PluginCredentialsV1) -> Bool {
    if lhs.credentials != rhs.credentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginOAuth2AccessTokenCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginOAuth2AccessTokenCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .standard(proto: "refresh_token"),
    3: .same(proto: "expires"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expires) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 1)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 2)
    }
    try { if let v = self._expires {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginOAuth2AccessTokenCredentials, rhs: Types_PluginOAuth2AccessTokenCredentials) -> Bool {
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs._expires != rhs._expires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginBearerTokenCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginBearerTokenCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginBearerTokenCredentials, rhs: Types_PluginBearerTokenCredentials) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginStaticCredentialsRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginStaticCredentialsRef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginStaticCredentialsRef, rhs: Types_PluginStaticCredentialsRef) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginListV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginListV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plugins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.plugins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plugins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.plugins, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginListV1, rhs: Types_PluginListV1) -> Bool {
    if lhs.plugins != rhs.plugins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginStaticCredentialsV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginStaticCredentialsV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginStaticCredentialsV1, rhs: Types_PluginStaticCredentialsV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginStaticCredentialsSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginStaticCredentialsSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "APIToken"),
    2: .same(proto: "BasicAuth"),
    3: .same(proto: "OAuthClientSecret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.credentials != nil {try decoder.handleConflictingOneOf()}
          self.credentials = .apitoken(v)
        }
      }()
      case 2: try {
        var v: Types_PluginStaticCredentialsBasicAuth?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .basicAuth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .basicAuth(v)
        }
      }()
      case 3: try {
        var v: Types_PluginStaticCredentialsOAuthClientSecret?
        var hadOneofValue = false
        if let current = self.credentials {
          hadOneofValue = true
          if case .oauthClientSecret(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentials = .oauthClientSecret(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.credentials {
    case .apitoken?: try {
      guard case .apitoken(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .basicAuth?: try {
      guard case .basicAuth(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .oauthClientSecret?: try {
      guard case .oauthClientSecret(let v)? = self.credentials else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginStaticCredentialsSpecV1, rhs: Types_PluginStaticCredentialsSpecV1) -> Bool {
    if lhs.credentials != rhs.credentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginStaticCredentialsBasicAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginStaticCredentialsBasicAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Username"),
    2: .same(proto: "Password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginStaticCredentialsBasicAuth, rhs: Types_PluginStaticCredentialsBasicAuth) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_PluginStaticCredentialsOAuthClientSecret: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginStaticCredentialsOAuthClientSecret"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClientId"),
    2: .same(proto: "ClientSecret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientSecret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if !self.clientSecret.isEmpty {
      try visitor.visitSingularStringField(value: self.clientSecret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_PluginStaticCredentialsOAuthClientSecret, rhs: Types_PluginStaticCredentialsOAuthClientSecret) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.clientSecret != rhs.clientSecret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLIdPServiceProviderV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPServiceProviderV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLIdPServiceProviderV1, rhs: Types_SAMLIdPServiceProviderV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_SAMLIdPServiceProviderSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SAMLIdPServiceProviderSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "EntityDescriptor"),
    2: .same(proto: "EntityID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityDescriptor) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityDescriptor.isEmpty {
      try visitor.visitSingularStringField(value: self.entityDescriptor, fieldNumber: 1)
    }
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_SAMLIdPServiceProviderSpecV1, rhs: Types_SAMLIdPServiceProviderSpecV1) -> Bool {
    if lhs.entityDescriptor != rhs.entityDescriptor {return false}
    if lhs.entityID != rhs.entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_IdPOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdPOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SAML"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._saml) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._saml {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_IdPOptions, rhs: Types_IdPOptions) -> Bool {
    if lhs._saml != rhs._saml {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_IdPSAMLOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdPSAMLOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_IdPSAMLOptions, rhs: Types_IdPSAMLOptions) -> Bool {
    if lhs._enabled != rhs._enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesResourceV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesResourceV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesResourceV1, rhs: Types_KubernetesResourceV1) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesResourceSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesResourceSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Namespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesResourceSpecV1, rhs: Types_KubernetesResourceSpecV1) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterMaintenanceConfigV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterMaintenanceConfigV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
    3: .same(proto: "Nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterMaintenanceConfigV1, rhs: Types_ClusterMaintenanceConfigV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ClusterMaintenanceConfigSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClusterMaintenanceConfigSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AgentUpgrades"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._agentUpgrades) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._agentUpgrades {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ClusterMaintenanceConfigSpecV1, rhs: Types_ClusterMaintenanceConfigSpecV1) -> Bool {
    if lhs._agentUpgrades != rhs._agentUpgrades {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AgentUpgradeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AgentUpgradeWindow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UTCStartHour"),
    2: .same(proto: "Weekdays"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.utcstartHour) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.weekdays) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.utcstartHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.utcstartHour, fieldNumber: 1)
    }
    if !self.weekdays.isEmpty {
      try visitor.visitRepeatedStringField(value: self.weekdays, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AgentUpgradeWindow, rhs: Types_AgentUpgradeWindow) -> Bool {
    if lhs.utcstartHour != rhs.utcstartHour {return false}
    if lhs.weekdays != rhs.weekdays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ScheduledAgentUpgradeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScheduledAgentUpgradeWindow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Start"),
    2: .same(proto: "Stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stop {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ScheduledAgentUpgradeWindow, rhs: Types_ScheduledAgentUpgradeWindow) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._stop != rhs._stop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AgentUpgradeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AgentUpgradeSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Windows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.windows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.windows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.windows, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AgentUpgradeSchedule, rhs: Types_AgentUpgradeSchedule) -> Bool {
    if lhs.windows != rhs.windows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserGroupV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserGroupV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserGroupV1, rhs: Types_UserGroupV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_UserGroupSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserGroupSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Applications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.applications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.applications.isEmpty {
      try visitor.visitRepeatedStringField(value: self.applications, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_UserGroupSpecV1, rhs: Types_UserGroupSpecV1) -> Bool {
    if lhs.applications != rhs.applications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaImportRuleSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaImportRuleSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Priority"),
    2: .same(proto: "Mappings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.priority) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mappings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.priority != 0 {
      try visitor.visitSingularInt32Field(value: self.priority, fieldNumber: 1)
    }
    if !self.mappings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mappings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaImportRuleSpecV1, rhs: Types_OktaImportRuleSpecV1) -> Bool {
    if lhs.priority != rhs.priority {return false}
    if lhs.mappings != rhs.mappings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaImportRuleMappingV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaImportRuleMappingV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Match"),
    2: .same(proto: "AddLabels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.match) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.addLabels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.match.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.match, fieldNumber: 1)
    }
    if !self.addLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.addLabels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaImportRuleMappingV1, rhs: Types_OktaImportRuleMappingV1) -> Bool {
    if lhs.match != rhs.match {return false}
    if lhs.addLabels != rhs.addLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaImportRuleV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaImportRuleV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaImportRuleV1, rhs: Types_OktaImportRuleV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaImportRuleMatchV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaImportRuleMatchV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AppIDs"),
    2: .same(proto: "GroupIDs"),
    3: .same(proto: "AppNameRegexes"),
    4: .same(proto: "GroupNameRegexes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.appIds) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.groupIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.appNameRegexes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.groupNameRegexes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.appIds, fieldNumber: 1)
    }
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groupIds, fieldNumber: 2)
    }
    if !self.appNameRegexes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.appNameRegexes, fieldNumber: 3)
    }
    if !self.groupNameRegexes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groupNameRegexes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaImportRuleMatchV1, rhs: Types_OktaImportRuleMatchV1) -> Bool {
    if lhs.appIds != rhs.appIds {return false}
    if lhs.groupIds != rhs.groupIds {return false}
    if lhs.appNameRegexes != rhs.appNameRegexes {return false}
    if lhs.groupNameRegexes != rhs.groupNameRegexes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaAssignmentV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaAssignmentV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  fileprivate class _StorageClass {
    var _header: Types_ResourceHeader? = nil
    var _spec: Types_OktaAssignmentSpecV1? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _spec = source._spec
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaAssignmentV1, rhs: Types_OktaAssignmentV1) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._spec != rhs_storage._spec {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaAssignmentSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaAssignmentSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "User"),
    2: .same(proto: "Targets"),
    3: .same(proto: "CleanupTime"),
    4: .same(proto: "status"),
    5: .same(proto: "LastTransition"),
    6: .same(proto: "Finalized"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cleanupTime) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastTransition) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.finalized) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 1)
    }
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 2)
    }
    try { if let v = self._cleanupTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try { if let v = self._lastTransition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.finalized != false {
      try visitor.visitSingularBoolField(value: self.finalized, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaAssignmentSpecV1, rhs: Types_OktaAssignmentSpecV1) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.targets != rhs.targets {return false}
    if lhs._cleanupTime != rhs._cleanupTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs._lastTransition != rhs._lastTransition {return false}
    if lhs.finalized != rhs.finalized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaAssignmentSpecV1.OktaAssignmentStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "PROCESSING"),
    3: .same(proto: "SUCCESSFUL"),
    4: .same(proto: "FAILED"),
  ]
}

extension Types_OktaAssignmentTargetV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaAssignmentTargetV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaAssignmentTargetV1, rhs: Types_OktaAssignmentTargetV1) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaAssignmentTargetV1.OktaAssignmentTargetType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "APPLICATION"),
    2: .same(proto: "GROUP"),
  ]
}

extension Types_IntegrationV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IntegrationV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
    2: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_IntegrationV1, rhs: Types_IntegrationV1) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_IntegrationSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IntegrationSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "AWSOIDC"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Types_AWSOIDCIntegrationSpecV1?
        var hadOneofValue = false
        if let current = self.subKindSpec {
          hadOneofValue = true
          if case .awsoidc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subKindSpec = .awsoidc(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .awsoidc(let v)? = self.subKindSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_IntegrationSpecV1, rhs: Types_IntegrationSpecV1) -> Bool {
    if lhs.subKindSpec != rhs.subKindSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AWSOIDCIntegrationSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWSOIDCIntegrationSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RoleARN"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roleArn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.roleArn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AWSOIDCIntegrationSpecV1, rhs: Types_AWSOIDCIntegrationSpecV1) -> Bool {
    if lhs.roleArn != rhs.roleArn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_HeadlessAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HeadlessAuthentication"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "user"),
    3: .standard(proto: "public_key"),
    4: .same(proto: "state"),
    5: .standard(proto: "mfa_device"),
    6: .standard(proto: "client_ip_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.user) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mfaDevice) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.clientIpAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.user.isEmpty {
      try visitor.visitSingularStringField(value: self.user, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 3)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    try { if let v = self._mfaDevice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.clientIpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.clientIpAddress, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_HeadlessAuthentication, rhs: Types_HeadlessAuthentication) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.user != rhs.user {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.state != rhs.state {return false}
    if lhs._mfaDevice != rhs._mfaDevice {return false}
    if lhs.clientIpAddress != rhs.clientIpAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WatchKind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchKind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "LoadSecrets"),
    3: .same(proto: "Name"),
    4: .same(proto: "Filter"),
    5: .same(proto: "SubKind"),
    6: .same(proto: "Version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.loadSecrets) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.filter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if self.loadSecrets != false {
      try visitor.visitSingularBoolField(value: self.loadSecrets, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.filter, fieldNumber: 4)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 5)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WatchKind, rhs: Types_WatchKind) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.loadSecrets != rhs.loadSecrets {return false}
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WatchStatusV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchStatusV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WatchStatusV1, rhs: Types_WatchStatusV1) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_WatchStatusSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WatchStatusSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kinds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.kinds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kinds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_WatchStatusSpecV1, rhs: Types_WatchStatusSpecV1) -> Bool {
    if lhs.kinds != rhs.kinds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ServerInfoV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerInfoV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Kind"),
    2: .same(proto: "SubKind"),
    3: .same(proto: "Version"),
    4: .same(proto: "Metadata"),
    5: .same(proto: "Spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subKind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.subKind.isEmpty {
      try visitor.visitSingularStringField(value: self.subKind, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ServerInfoV1, rhs: Types_ServerInfoV1) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.subKind != rhs.subKind {return false}
    if lhs.version != rhs.version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_ServerInfoSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerInfoSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "NewLabels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.newLabels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.newLabels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_ServerInfoSpecV1, rhs: Types_ServerInfoSpecV1) -> Bool {
    if lhs.newLabels != rhs.newLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_JamfSpecV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JamfSpecV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "name"),
    3: .standard(proto: "sync_delay"),
    4: .standard(proto: "api_endpoint"),
    5: .same(proto: "username"),
    6: .same(proto: "password"),
    7: .same(proto: "inventory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.syncDelay) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.apiEndpoint) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.inventory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.syncDelay != 0 {
      try visitor.visitSingularInt64Field(value: self.syncDelay, fieldNumber: 3)
    }
    if !self.apiEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.apiEndpoint, fieldNumber: 4)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 5)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 6)
    }
    if !self.inventory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inventory, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_JamfSpecV1, rhs: Types_JamfSpecV1) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.name != rhs.name {return false}
    if lhs.syncDelay != rhs.syncDelay {return false}
    if lhs.apiEndpoint != rhs.apiEndpoint {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.inventory != rhs.inventory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_JamfInventoryEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JamfInventoryEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filter_rsql"),
    2: .standard(proto: "sync_period_partial"),
    3: .standard(proto: "sync_period_full"),
    4: .standard(proto: "on_missing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filterRsql) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.syncPeriodPartial) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.syncPeriodFull) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.onMissing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filterRsql.isEmpty {
      try visitor.visitSingularStringField(value: self.filterRsql, fieldNumber: 1)
    }
    if self.syncPeriodPartial != 0 {
      try visitor.visitSingularInt64Field(value: self.syncPeriodPartial, fieldNumber: 2)
    }
    if self.syncPeriodFull != 0 {
      try visitor.visitSingularInt64Field(value: self.syncPeriodFull, fieldNumber: 3)
    }
    if !self.onMissing.isEmpty {
      try visitor.visitSingularStringField(value: self.onMissing, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_JamfInventoryEntry, rhs: Types_JamfInventoryEntry) -> Bool {
    if lhs.filterRsql != rhs.filterRsql {return false}
    if lhs.syncPeriodPartial != rhs.syncPeriodPartial {return false}
    if lhs.syncPeriodFull != rhs.syncPeriodFull {return false}
    if lhs.onMissing != rhs.onMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_MessageWithHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageWithHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Header"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_MessageWithHeader, rhs: Types_MessageWithHeader) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AWSMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWSMatcher"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Types"),
    2: .same(proto: "Regions"),
    3: .same(proto: "AssumeRole"),
    4: .same(proto: "Tags"),
    5: .same(proto: "Params"),
    6: .same(proto: "SSM"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.regions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._assumeRole) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tags) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._ssm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 1)
    }
    if !self.regions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.regions, fieldNumber: 2)
    }
    try { if let v = self._assumeRole {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ssm {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AWSMatcher, rhs: Types_AWSMatcher) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.regions != rhs.regions {return false}
    if lhs._assumeRole != rhs._assumeRole {return false}
    if lhs._tags != rhs._tags {return false}
    if lhs._params != rhs._params {return false}
    if lhs._ssm != rhs._ssm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AssumeRole: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssumeRole"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RoleARN"),
    2: .same(proto: "ExternalID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roleArn) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.externalID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roleArn.isEmpty {
      try visitor.visitSingularStringField(value: self.roleArn, fieldNumber: 1)
    }
    if !self.externalID.isEmpty {
      try visitor.visitSingularStringField(value: self.externalID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AssumeRole, rhs: Types_AssumeRole) -> Bool {
    if lhs.roleArn != rhs.roleArn {return false}
    if lhs.externalID != rhs.externalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_InstallerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstallerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "JoinMethod"),
    2: .same(proto: "JoinToken"),
    3: .same(proto: "ScriptName"),
    4: .same(proto: "InstallTeleport"),
    5: .same(proto: "SSHDConfig"),
    6: .same(proto: "PublicProxyAddr"),
    7: .same(proto: "Azure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.joinMethod) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.joinToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scriptName) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.installTeleport) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sshdconfig) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.publicProxyAddr) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._azure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.joinMethod.isEmpty {
      try visitor.visitSingularStringField(value: self.joinMethod, fieldNumber: 1)
    }
    if !self.joinToken.isEmpty {
      try visitor.visitSingularStringField(value: self.joinToken, fieldNumber: 2)
    }
    if !self.scriptName.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptName, fieldNumber: 3)
    }
    if self.installTeleport != false {
      try visitor.visitSingularBoolField(value: self.installTeleport, fieldNumber: 4)
    }
    if !self.sshdconfig.isEmpty {
      try visitor.visitSingularStringField(value: self.sshdconfig, fieldNumber: 5)
    }
    if !self.publicProxyAddr.isEmpty {
      try visitor.visitSingularStringField(value: self.publicProxyAddr, fieldNumber: 6)
    }
    try { if let v = self._azure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_InstallerParams, rhs: Types_InstallerParams) -> Bool {
    if lhs.joinMethod != rhs.joinMethod {return false}
    if lhs.joinToken != rhs.joinToken {return false}
    if lhs.scriptName != rhs.scriptName {return false}
    if lhs.installTeleport != rhs.installTeleport {return false}
    if lhs.sshdconfig != rhs.sshdconfig {return false}
    if lhs.publicProxyAddr != rhs.publicProxyAddr {return false}
    if lhs._azure != rhs._azure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AWSSSM: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AWSSSM"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DocumentName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.documentName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documentName.isEmpty {
      try visitor.visitSingularStringField(value: self.documentName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AWSSSM, rhs: Types_AWSSSM) -> Bool {
    if lhs.documentName != rhs.documentName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AzureInstallerParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AzureInstallerParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClientID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AzureInstallerParams, rhs: Types_AzureInstallerParams) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_AzureMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AzureMatcher"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Subscriptions"),
    2: .same(proto: "ResourceGroups"),
    3: .same(proto: "Types"),
    4: .same(proto: "Regions"),
    5: .same(proto: "ResourceTags"),
    6: .same(proto: "Params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.subscriptions) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.resourceGroups) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.regions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._resourceTags) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subscriptions, fieldNumber: 1)
    }
    if !self.resourceGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.resourceGroups, fieldNumber: 2)
    }
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 3)
    }
    if !self.regions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.regions, fieldNumber: 4)
    }
    try { if let v = self._resourceTags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_AzureMatcher, rhs: Types_AzureMatcher) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.resourceGroups != rhs.resourceGroups {return false}
    if lhs.types != rhs.types {return false}
    if lhs.regions != rhs.regions {return false}
    if lhs._resourceTags != rhs._resourceTags {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_GCPMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GCPMatcher"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Types"),
    2: .same(proto: "Locations"),
    3: .same(proto: "Tags"),
    4: .same(proto: "ProjectIDs"),
    5: .same(proto: "ServiceAccounts"),
    6: .same(proto: "Params"),
    7: .same(proto: "Labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.locations) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tags) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.projectIds) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.serviceAccounts) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 1)
    }
    if !self.locations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locations, fieldNumber: 2)
    }
    try { if let v = self._tags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.projectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.projectIds, fieldNumber: 4)
    }
    if !self.serviceAccounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serviceAccounts, fieldNumber: 5)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_GCPMatcher, rhs: Types_GCPMatcher) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.locations != rhs.locations {return false}
    if lhs._tags != rhs._tags {return false}
    if lhs.projectIds != rhs.projectIds {return false}
    if lhs.serviceAccounts != rhs.serviceAccounts {return false}
    if lhs._params != rhs._params {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_KubernetesMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KubernetesMatcher"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Types"),
    2: .same(proto: "Namespaces"),
    3: .same(proto: "Labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.namespaces) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 1)
    }
    if !self.namespaces.isEmpty {
      try visitor.visitRepeatedStringField(value: self.namespaces, fieldNumber: 2)
    }
    try { if let v = self._labels {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_KubernetesMatcher, rhs: Types_KubernetesMatcher) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.namespaces != rhs.namespaces {return false}
    if lhs._labels != rhs._labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Types_OktaOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OktaOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SyncPeriod"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.syncPeriod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.syncPeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.syncPeriod, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Types_OktaOptions, rhs: Types_OktaOptions) -> Bool {
    if lhs.syncPeriod != rhs.syncPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
