// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/usageevents/v1/usageevents.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Gravitational, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// DiscoverResource represents a resource type.
enum Teleport_Usageevents_V1_DiscoverResource: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case server // = 1
  case kubernetes // = 2
  case databasePostgresSelfHosted // = 3
  case databaseMysqlSelfHosted // = 4
  case databaseMongodbSelfHosted // = 5
  case databasePostgresRds // = 6
  case databaseMysqlRds // = 7
  case applicationHTTP // = 8
  case applicationTcp // = 9
  case windowsDesktop // = 10
  case databaseSqlserverRds // = 11
  case databasePostgresRedshift // = 12
  case databaseSqlserverSelfHosted // = 13
  case databaseRedisSelfHosted // = 14
  case databasePostgresGcp // = 15
  case databaseMysqlGcp // = 16
  case databaseSqlserverGcp // = 17
  case databasePostgresRedshiftServerless // = 18
  case databasePostgresAzure // = 19
  case databaseDynamodb // = 20
  case databaseCassandraKeyspaces // = 21

  /// Cassandra & ScyllaDb
  case databaseCassandraSelfHosted // = 22
  case databaseElasticsearchSelfHosted // = 23

  /// Elasticache & MemoryDb
  case databaseRedisElasticache // = 24
  case databaseRedisMemorydb // = 25
  case databaseRedisAzureCache // = 26
  case databaseRedisClusterSelfHosted // = 27
  case databaseMysqlAzure // = 28
  case databaseSqlserverAzure // = 29
  case databaseSqlserverMicrosoft // = 30
  case databaseCockroachdbSelfHosted // = 31
  case databaseMongodbAtlas // = 32
  case databaseSnowflake // = 33
  case docDatabaseRdsProxy // = 34
  case docDatabaseHighAvailability // = 35
  case docDatabaseDynamicRegistration // = 36
  case samlApplication // = 37
  case ec2Instance // = 38
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .server
    case 2: self = .kubernetes
    case 3: self = .databasePostgresSelfHosted
    case 4: self = .databaseMysqlSelfHosted
    case 5: self = .databaseMongodbSelfHosted
    case 6: self = .databasePostgresRds
    case 7: self = .databaseMysqlRds
    case 8: self = .applicationHTTP
    case 9: self = .applicationTcp
    case 10: self = .windowsDesktop
    case 11: self = .databaseSqlserverRds
    case 12: self = .databasePostgresRedshift
    case 13: self = .databaseSqlserverSelfHosted
    case 14: self = .databaseRedisSelfHosted
    case 15: self = .databasePostgresGcp
    case 16: self = .databaseMysqlGcp
    case 17: self = .databaseSqlserverGcp
    case 18: self = .databasePostgresRedshiftServerless
    case 19: self = .databasePostgresAzure
    case 20: self = .databaseDynamodb
    case 21: self = .databaseCassandraKeyspaces
    case 22: self = .databaseCassandraSelfHosted
    case 23: self = .databaseElasticsearchSelfHosted
    case 24: self = .databaseRedisElasticache
    case 25: self = .databaseRedisMemorydb
    case 26: self = .databaseRedisAzureCache
    case 27: self = .databaseRedisClusterSelfHosted
    case 28: self = .databaseMysqlAzure
    case 29: self = .databaseSqlserverAzure
    case 30: self = .databaseSqlserverMicrosoft
    case 31: self = .databaseCockroachdbSelfHosted
    case 32: self = .databaseMongodbAtlas
    case 33: self = .databaseSnowflake
    case 34: self = .docDatabaseRdsProxy
    case 35: self = .docDatabaseHighAvailability
    case 36: self = .docDatabaseDynamicRegistration
    case 37: self = .samlApplication
    case 38: self = .ec2Instance
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .server: return 1
    case .kubernetes: return 2
    case .databasePostgresSelfHosted: return 3
    case .databaseMysqlSelfHosted: return 4
    case .databaseMongodbSelfHosted: return 5
    case .databasePostgresRds: return 6
    case .databaseMysqlRds: return 7
    case .applicationHTTP: return 8
    case .applicationTcp: return 9
    case .windowsDesktop: return 10
    case .databaseSqlserverRds: return 11
    case .databasePostgresRedshift: return 12
    case .databaseSqlserverSelfHosted: return 13
    case .databaseRedisSelfHosted: return 14
    case .databasePostgresGcp: return 15
    case .databaseMysqlGcp: return 16
    case .databaseSqlserverGcp: return 17
    case .databasePostgresRedshiftServerless: return 18
    case .databasePostgresAzure: return 19
    case .databaseDynamodb: return 20
    case .databaseCassandraKeyspaces: return 21
    case .databaseCassandraSelfHosted: return 22
    case .databaseElasticsearchSelfHosted: return 23
    case .databaseRedisElasticache: return 24
    case .databaseRedisMemorydb: return 25
    case .databaseRedisAzureCache: return 26
    case .databaseRedisClusterSelfHosted: return 27
    case .databaseMysqlAzure: return 28
    case .databaseSqlserverAzure: return 29
    case .databaseSqlserverMicrosoft: return 30
    case .databaseCockroachdbSelfHosted: return 31
    case .databaseMongodbAtlas: return 32
    case .databaseSnowflake: return 33
    case .docDatabaseRdsProxy: return 34
    case .docDatabaseHighAvailability: return 35
    case .docDatabaseDynamicRegistration: return 36
    case .samlApplication: return 37
    case .ec2Instance: return 38
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Usageevents_V1_DiscoverResource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_DiscoverResource] = [
    .unspecified,
    .server,
    .kubernetes,
    .databasePostgresSelfHosted,
    .databaseMysqlSelfHosted,
    .databaseMongodbSelfHosted,
    .databasePostgresRds,
    .databaseMysqlRds,
    .applicationHTTP,
    .applicationTcp,
    .windowsDesktop,
    .databaseSqlserverRds,
    .databasePostgresRedshift,
    .databaseSqlserverSelfHosted,
    .databaseRedisSelfHosted,
    .databasePostgresGcp,
    .databaseMysqlGcp,
    .databaseSqlserverGcp,
    .databasePostgresRedshiftServerless,
    .databasePostgresAzure,
    .databaseDynamodb,
    .databaseCassandraKeyspaces,
    .databaseCassandraSelfHosted,
    .databaseElasticsearchSelfHosted,
    .databaseRedisElasticache,
    .databaseRedisMemorydb,
    .databaseRedisAzureCache,
    .databaseRedisClusterSelfHosted,
    .databaseMysqlAzure,
    .databaseSqlserverAzure,
    .databaseSqlserverMicrosoft,
    .databaseCockroachdbSelfHosted,
    .databaseMongodbAtlas,
    .databaseSnowflake,
    .docDatabaseRdsProxy,
    .docDatabaseHighAvailability,
    .docDatabaseDynamicRegistration,
    .samlApplication,
    .ec2Instance,
  ]
}

#endif  // swift(>=4.2)

/// DiscoverStatus represents a Discover Step outcome.
enum Teleport_Usageevents_V1_DiscoverStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// The user tried to complete the action and it succeeded.
  case success // = 1

  /// The system skipped the step.
  /// For example:
  /// When setting up a Database and there's already a Database Service proxying the DB.
  /// In this case the Database Agent installation is skipped.
  case skipped // = 2

  /// The user tried to complete the action and it failed.
  case error // = 3

  /// The user did not complete the action and left the wizard.
  case aborted // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .success
    case 2: self = .skipped
    case 3: self = .error
    case 4: self = .aborted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .success: return 1
    case .skipped: return 2
    case .error: return 3
    case .aborted: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Usageevents_V1_DiscoverStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_DiscoverStatus] = [
    .unspecified,
    .success,
    .skipped,
    .error,
    .aborted,
  ]
}

#endif  // swift(>=4.2)

/// CTA represents teleport web UI's call to action buttons.
/// We can't use prehog.v1alpha.CTA here because AuthService (and thus this file)
/// is generated with gogofast, so we just copy the enum definition here instead.
/// Make sure you update both.
enum Teleport_Usageevents_V1_CTA: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case authConnector // = 1
  case activeSessions // = 2
  case accessRequests // = 3
  case premiumSupport // = 4
  case trustedDevices // = 5
  case upgradeBanner // = 6
  case billingSummary // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .authConnector
    case 2: self = .activeSessions
    case 3: self = .accessRequests
    case 4: self = .premiumSupport
    case 5: self = .trustedDevices
    case 6: self = .upgradeBanner
    case 7: self = .billingSummary
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .authConnector: return 1
    case .activeSessions: return 2
    case .accessRequests: return 3
    case .premiumSupport: return 4
    case .trustedDevices: return 5
    case .upgradeBanner: return 6
    case .billingSummary: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Usageevents_V1_CTA: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_CTA] = [
    .unspecified,
    .authConnector,
    .activeSessions,
    .accessRequests,
    .premiumSupport,
    .trustedDevices,
    .upgradeBanner,
    .billingSummary,
  ]
}

#endif  // swift(>=4.2)

/// IntegrationEnrollKind represents the types of integration that
/// can be enrolled.
enum Teleport_Usageevents_V1_IntegrationEnrollKind: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case slack // = 1
  case awsOidc // = 2
  case pagerduty // = 3
  case email // = 4
  case jira // = 5
  case discord // = 6
  case mattermost // = 7
  case msTeams // = 8
  case opsgenie // = 9
  case okta // = 10
  case jamf // = 11
  case machineID // = 12
  case machineIDGithubActions // = 13
  case machineIDCircleci // = 14
  case machineIDGitlab // = 15
  case machineIDJenkins // = 16
  case machineIDAnsible // = 17
  case servicenow // = 18
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .slack
    case 2: self = .awsOidc
    case 3: self = .pagerduty
    case 4: self = .email
    case 5: self = .jira
    case 6: self = .discord
    case 7: self = .mattermost
    case 8: self = .msTeams
    case 9: self = .opsgenie
    case 10: self = .okta
    case 11: self = .jamf
    case 12: self = .machineID
    case 13: self = .machineIDGithubActions
    case 14: self = .machineIDCircleci
    case 15: self = .machineIDGitlab
    case 16: self = .machineIDJenkins
    case 17: self = .machineIDAnsible
    case 18: self = .servicenow
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .slack: return 1
    case .awsOidc: return 2
    case .pagerduty: return 3
    case .email: return 4
    case .jira: return 5
    case .discord: return 6
    case .mattermost: return 7
    case .msTeams: return 8
    case .opsgenie: return 9
    case .okta: return 10
    case .jamf: return 11
    case .machineID: return 12
    case .machineIDGithubActions: return 13
    case .machineIDCircleci: return 14
    case .machineIDGitlab: return 15
    case .machineIDJenkins: return 16
    case .machineIDAnsible: return 17
    case .servicenow: return 18
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Usageevents_V1_IntegrationEnrollKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_IntegrationEnrollKind] = [
    .unspecified,
    .slack,
    .awsOidc,
    .pagerduty,
    .email,
    .jira,
    .discord,
    .mattermost,
    .msTeams,
    .opsgenie,
    .okta,
    .jamf,
    .machineID,
    .machineIDGithubActions,
    .machineIDCircleci,
    .machineIDGitlab,
    .machineIDJenkins,
    .machineIDAnsible,
    .servicenow,
  ]
}

#endif  // swift(>=4.2)

/// Feature is name of Teleport feature
enum Teleport_Usageevents_V1_Feature: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case trustedDevices // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .trustedDevices
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .trustedDevices: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Usageevents_V1_Feature: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_Feature] = [
    .unspecified,
    .trustedDevices,
  ]
}

#endif  // swift(>=4.2)

/// FeatureRecommendationStatus is feature recommendation status.
enum Teleport_Usageevents_V1_FeatureRecommendationStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// FEATURE_RECOMMENDATION_STATUS_NOTIFIED is emitted when a feature is recommended (notified in UI) to user.
  case notified // = 1

  /// FEATURE_RECOMMENDATION_STATUS_DONE is emitted when user completes the desired CTA.
  case done // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notified
    case 2: self = .done
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notified: return 1
    case .done: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Teleport_Usageevents_V1_FeatureRecommendationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_FeatureRecommendationStatus] = [
    .unspecified,
    .notified,
    .done,
  ]
}

#endif  // swift(>=4.2)

/// UIBannerClickEvent is a usage event sent by the UI when the upgrade
/// banner is clicked.
struct Teleport_Usageevents_V1_UIBannerClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cluster alert name.
  var alert: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIOnboardCompleteGoToDashboardClickEvent is a UI event sent when initial
/// registration is complete.
struct Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event username. Not extracted from identity as this is pre-registration.
  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIOnboardAddFirstResourceClickEvent is a UI event sent when a user clicks the
/// "add first resource" button.
struct Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIOnboardAddFirstResourceLaterClickEvent is a UI event sent when a user
/// clicks the "add first resource later" button.
struct Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIOnboardSetCredentialSubmitEvent is a UI event sent during registration when
/// users configure their credentials.
struct Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event username. Not extracted from identity as this is pre-registration.
  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIOnboardQuestionnaireSubmitEvent is a UI event sent during registration when
/// the user submits their onboarding questionnaire.
struct Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event username. Not extracted from identity as this is pre-registration.
  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIOnboardRegisterChallengeSubmitEvent is a UI event sent during registration
/// when the MFA challenge is completed.
struct Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event username. Not extracted from identity as this is pre-registration.
  var username: String = String()

  /// The type of MFA used.
  var mfaType: String = String()

  /// The type of login used.
  var loginFlow: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIRecoveryCodesContinueClickEvent is a UI event sent during
/// registration when the user configures cluster recovery codes.
struct Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event username. Not extracted from identity as this is pre-registration.
  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIRecoveryCodesCopyClickEvent is a UI event sent during
/// registration when the user copies recovery codes.
struct Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event username. Not extracted from identity as this is pre-registration.
  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIRecoveryCodesPrintClickEvent is a UI event sent during
/// registration when the user prints recovery codes.
struct Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event username. Not extracted from identity as this is pre-registration.
  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DiscoverMetadata contains common metadata for Discover related events.
struct Teleport_Usageevents_V1_DiscoverMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Uniquely identifies Discover wizard "session". Will allow to correlate
  /// events within the same Discover wizard run.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DiscoverResourceMetadata contains common metadata identifying resource type being added.
struct Teleport_Usageevents_V1_DiscoverResourceMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource type that is being added.
  var resource: Teleport_Usageevents_V1_DiscoverResource = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DiscoverStepStatus contains fields that track a particular step outcome,
/// for example connection test failed or succeeded, or user aborted the step.
struct Teleport_Usageevents_V1_DiscoverStepStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates the step outcome.
  var status: Teleport_Usageevents_V1_DiscoverStatus = .unspecified

  /// Contains error details in case of Error Status.
  /// We have to be careful to not include any identifyable infomation like server addresses here.
  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIDiscoverStartedEvent is emitted when the wizard opens.
struct Teleport_Usageevents_V1_UIDiscoverStartedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverResourceSelectionEvent is emitted when user selected resource type to add
/// and proceeded to the next step.
struct Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverIntegrationAWSOIDCConnectEvent is emitted when a user is finished with the step
/// that asks user to setup aws integration or select from a list of existing
/// aws integrations.
struct Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverDatabaseRDSEnrollEvent is emitted when a user is finished with
/// the step that asks user to select from a list of RDS databases.
struct Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var selectedResourcesCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UICallToActionClickEvent is emmited when a user clicks a Teleport Web UI's CTA.
struct Teleport_Usageevents_V1_UICallToActionClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cta: Teleport_Usageevents_V1_CTA = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIDiscoverDeployServiceEvent is emitted after the user installs a Teleport Agent.
/// For SSH this is the Teleport 'install-node' script.
///
/// For Kubernetes this is the teleport-agent helm chart installation.
///
/// For Database Access this step is the installation of the teleport 'install-db' script.
/// It can be skipped if the cluster already has a Database Service capable of proxying the database.
struct Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var deployMethod: Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployMethod = .unspecified

  var deployType: Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployType = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// DeployMethod describes the method used to deploy a service.
  enum DeployMethod: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// DEPLOY_METHOD_UNSPECIFIED means there was an existing service
    /// so deploying step got skipped.
    case unspecified // = 0

    /// DEPLOY_METHOD_AUTO means Teleport deployed a service for the user.
    case auto // = 1

    /// DEPLOY_METHOD_MANUAL means a user deployed a service by themselves.
    case manual // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .auto
      case 2: self = .manual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .auto: return 1
      case .manual: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// DeployType describes the type of deployment.
  enum DeployType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// DEPLOY_METHOD_UNSPECIFIED means there was an existing service
    /// so deploying step got skipped.
    case unspecified // = 0

    /// DEPLOY_TYPE_INSTALL_SCRIPT means service was deployed using an
    /// install script.
    case installScript // = 1

    /// DEPLOY_TYPE_AMAZON_ECS means service was deployed using amazon's
    /// elastic container service.
    case amazonEcs // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .installScript
      case 2: self = .amazonEcs
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .installScript: return 1
      case .amazonEcs: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

#if swift(>=4.2)

extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployMethod] = [
    .unspecified,
    .auto,
    .manual,
  ]
}

extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployType] = [
    .unspecified,
    .installScript,
    .amazonEcs,
  ]
}

#endif  // swift(>=4.2)

/// UIDiscoverDatabaseRegisterEvent is emitted when a user is finished with the step that registers a database resource.
struct Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverDatabaseConfigureMTLSEvent is emitted when a user is finished with the step that configures mutual TLS for a self-hosted database.
struct Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverDesktopActiveDirectoryToolsInstallEvent is emitted when the user is finished with the step that asks user to run the install Active Directory tools script for the Desktop flow.
struct Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverDesktopActiveDirectoryConfigureEvent is emitted when the user is finished with the step that asks user to run the Configure Active Directory script for the Desktop flow.
struct Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverAutoDiscoveredResourcesEvent is emitted when the user is finished with the step that auto discovers resources (waiting until resources show up).
/// resources_count field must reflect the latest amount of discovered resources (get the number after user is finished with this step).
struct Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var resourcesCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverEC2InstanceSelectionEvent is emitted when the user is finished with the step that asks the user to select an EC2 Instance to enroll.
struct Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverDeployEICEEvent is emitted when the user deploys an EC2 Instance Connect Endpoint.
struct Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverCreateNodeEvent is emitted when the node is created in Teleport.
struct Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverDatabaseConfigureIAMPolicyEvent is emitted when a user is finished with the step that configures IAM policy for an RDS database.
struct Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverPrincipalsConfigureEvent is emitted when a user is finished with the step that allows user to update their principals (setting up access).
struct Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverTestConnectionEvent emitted on the "Test Connection" screen
/// when the user clicked tested connection to their resource.
struct Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UIDiscoverCompletedEvent is emitted when user completes the Discover wizard.
struct Teleport_Usageevents_V1_UIDiscoverCompletedEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_DiscoverMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_DiscoverMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resource: Teleport_Usageevents_V1_DiscoverResourceMetadata {
    get {return _resource ?? Teleport_Usageevents_V1_DiscoverResourceMetadata()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  mutating func clearResource() {self._resource = nil}

  var status: Teleport_Usageevents_V1_DiscoverStepStatus {
    get {return _status ?? Teleport_Usageevents_V1_DiscoverStepStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_DiscoverMetadata? = nil
  fileprivate var _resource: Teleport_Usageevents_V1_DiscoverResourceMetadata? = nil
  fileprivate var _status: Teleport_Usageevents_V1_DiscoverStepStatus? = nil
}

/// UICreateNewRoleClickEvent is an event that can be triggered during custom role creation
struct Teleport_Usageevents_V1_UICreateNewRoleClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UICreateNewRoleSaveClickEvent is an event that can be triggered during custom role creation
struct Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UICreateNewRoleCancelClickEvent is an event that can be triggered during custom role creation
struct Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UICreateNewRoleViewDocumentationClickEvent is an event that can be triggered during custom role creation
struct Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AssistCompletionEvent is an event that is emitted when a completion occurs in the Assistant
struct Teleport_Usageevents_V1_AssistCompletionEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConversationId is the UUID that identifies a single Assist conversation
  var conversationID: String = String()

  /// TotalTokens is the total amount of token used to satisfy this request
  var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt
  var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the completion response consists of
  var completionTokens: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AssistExecutionEvent is an event that is emitted when an Assist command
/// execution is triggered by the user.
struct Teleport_Usageevents_V1_AssistExecutionEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConversationId is the UUID that identifies a single Assist conversation
  var conversationID: String = String()

  /// NodeCount is the number of nodes the command was executed on
  var nodeCount: Int64 = 0

  /// TotalTokens is the total amount of token used to satisfy this request
  var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt
  var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the completion response consists of
  var completionTokens: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AssistNewConversationEvent is an event that is emitted for each new Assist
/// conversation and contains the conversation category.
struct Teleport_Usageevents_V1_AssistNewConversationEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Category is the conversation category. This represents what kind of request
  /// the user is asking Assist.
  var category: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AssistAccessRequest is an event that is emitted when a user requests access
/// to a resource via Assist.
struct Teleport_Usageevents_V1_AssistAccessRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ResourceType describes the type of resource the user is requesting access to, e.g. "node", "db", "k8s" or "role".
  var resourceType: String = String()

  /// TotalTokens is the total amount of token used to generate the command summary
  var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt to generate the command summary
  var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the summary completion response consists of
  var completionTokens: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AssistAction is an event that is emitted when a user triggers an action (SSH command generation, output explain, etc.)
/// via Assist.
struct Teleport_Usageevents_V1_AssistAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Action is the action that was triggered, e.g. "ssh-explain", "ssh-command-generate", etc.
  var action: String = String()

  /// TotalTokens is the total amount of token used to generate the command summary
  var totalTokens: Int64 = 0

  /// PromptTokens is the amount of estimated tokens used by the prompt to generate the command summary
  var promptTokens: Int64 = 0

  /// CompletionTokens is the amount of tokens that the summary completion response consists of
  var completionTokens: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListMetadata contains common metadata for Access List related events.
struct Teleport_Usageevents_V1_AccessListMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Uniquely identifies an Access List. Will allow correlation of events within an access list.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AccessListCreate is an event that is emitted when an access list is created.
struct Teleport_Usageevents_V1_AccessListCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_AccessListMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_AccessListMetadata? = nil
}

/// AccessListUpdate is an event that is emitted when an access list is updated.
struct Teleport_Usageevents_V1_AccessListUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_AccessListMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_AccessListMetadata? = nil
}

/// AccessListDelete is an event that is emitted when an access list is deleted.
struct Teleport_Usageevents_V1_AccessListDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_AccessListMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_AccessListMetadata? = nil
}

/// AccessListMemberCreate is an event that is emitted when a member is added to an access list.
struct Teleport_Usageevents_V1_AccessListMemberCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_AccessListMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_AccessListMetadata? = nil
}

/// AccessListMemberCreate is an event that is emitted when a member is updated in an access list.
struct Teleport_Usageevents_V1_AccessListMemberUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_AccessListMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_AccessListMetadata? = nil
}

/// AccessListMemberDelete is an event that is emitted when a member is removed from an access list.
struct Teleport_Usageevents_V1_AccessListMemberDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_AccessListMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_AccessListMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_AccessListMetadata? = nil
}

/// AccessListGrantsToUser is an event that is emitted when access list permissions are granted to a user
/// on login.
struct Teleport_Usageevents_V1_AccessListGrantsToUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// count_roles_granted is the number of roles granted to a user.
  var countRolesGranted: Int32 = 0

  /// count_traits_granted is the number of traits granted to a user.
  var countTraitsGranted: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// IntegrationEnrollMetadata contains common metadata
/// for Integration Enroll related events.
struct Teleport_Usageevents_V1_IntegrationEnrollMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is used as a unique identifier to correlate events within the
  /// same enroll wizard run.
  var id: String = String()

  /// kind identifies what type of integration the user clicked on to enroll.
  var kind: Teleport_Usageevents_V1_IntegrationEnrollKind = .unspecified

  /// user_name is anonymized.
  var userName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UIIntegrationEnrollEvent is an event that is emitted when a user
/// clicks on a integration to enroll.
struct Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_IntegrationEnrollMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_IntegrationEnrollMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_IntegrationEnrollMetadata? = nil
}

/// UIIntegrationEnrollEvent is an event that is emitted when a user
/// completed enrolling an integration.
struct Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Teleport_Usageevents_V1_IntegrationEnrollMetadata {
    get {return _metadata ?? Teleport_Usageevents_V1_IntegrationEnrollMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Teleport_Usageevents_V1_IntegrationEnrollMetadata? = nil
}

/// ResourceCreateEvent is emitted when a resource is created.
struct Teleport_Usageevents_V1_ResourceCreateEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// resource_type is the type of resource ("node", "node.openssh", "db", "k8s", "app").
  var resourceType: String = String()

  /// resource_origin is the origin of the resource ("cloud", "kubernetes").
  var resourceOrigin: String = String()

  /// cloud_provider is the cloud provider the resource came from ("AWS", "Azure", "GCP")
  /// if resource_origin == "cloud".
  var cloudProvider: String = String()

  /// database contains additional database information if resource_type == "db".
  var database: Teleport_Usageevents_V1_DiscoveredDatabaseMetadata {
    get {return _database ?? Teleport_Usageevents_V1_DiscoveredDatabaseMetadata()}
    set {_database = newValue}
  }
  /// Returns true if `database` has been explicitly set.
  var hasDatabase: Bool {return self._database != nil}
  /// Clears the value of `database`. Subsequent reads from it will return its default value.
  mutating func clearDatabase() {self._database = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _database: Teleport_Usageevents_V1_DiscoveredDatabaseMetadata? = nil
}

/// DiscoveredDatabaseMetadata contains additional database information.
struct Teleport_Usageevents_V1_DiscoveredDatabaseMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// database type.
  var dbType: String = String()

  /// database protocol.
  var dbProtocol: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// FeatureRecommendationEvent captures event emitted when a feature is recommended to user or
/// when user completes the desired CTA for the feature.
///
/// PostHost event: tp.ui.feature.recommendation
struct Teleport_Usageevents_V1_FeatureRecommendationEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// anonymized Teleport username, 32 bytes (HMAC-SHA-256) encoded in base64;
  ///
  /// PostHog property: tp.user_name
  var userName: String = String()

  /// feature is name of the Teleport feature.
  ///
  /// PostHost property: tp.feature
  var feature: Teleport_Usageevents_V1_Feature = .unspecified

  /// feature_recommendation_status records recommendation state, which can be 'NOTIFIED' (feature is recommended)
  /// OR 'DONE' (user completes desired CTA)
  ///
  /// PostHost property: tp.feature_recommendation_status
  var featureRecommendationStatus: Teleport_Usageevents_V1_FeatureRecommendationStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// UsageEventOneOf is a message that can accept a oneof of any supported
/// external usage event.
struct Teleport_Usageevents_V1_UsageEventOneOf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Teleport_Usageevents_V1_UsageEventOneOf.OneOf_Event? = nil

  var uiBannerClick: Teleport_Usageevents_V1_UIBannerClickEvent {
    get {
      if case .uiBannerClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIBannerClickEvent()
    }
    set {event = .uiBannerClick(newValue)}
  }

  var uiOnboardCompleteGoToDashboardClick: Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent {
    get {
      if case .uiOnboardCompleteGoToDashboardClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent()
    }
    set {event = .uiOnboardCompleteGoToDashboardClick(newValue)}
  }

  var uiOnboardAddFirstResourceClick: Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent {
    get {
      if case .uiOnboardAddFirstResourceClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent()
    }
    set {event = .uiOnboardAddFirstResourceClick(newValue)}
  }

  var uiOnboardAddFirstResourceLaterClick: Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent {
    get {
      if case .uiOnboardAddFirstResourceLaterClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent()
    }
    set {event = .uiOnboardAddFirstResourceLaterClick(newValue)}
  }

  var uiOnboardSetCredentialSubmit: Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent {
    get {
      if case .uiOnboardSetCredentialSubmit(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent()
    }
    set {event = .uiOnboardSetCredentialSubmit(newValue)}
  }

  var uiOnboardRegisterChallengeSubmit: Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent {
    get {
      if case .uiOnboardRegisterChallengeSubmit(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent()
    }
    set {event = .uiOnboardRegisterChallengeSubmit(newValue)}
  }

  var uiRecoveryCodesContinueClick: Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent {
    get {
      if case .uiRecoveryCodesContinueClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent()
    }
    set {event = .uiRecoveryCodesContinueClick(newValue)}
  }

  var uiRecoveryCodesCopyClick: Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent {
    get {
      if case .uiRecoveryCodesCopyClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent()
    }
    set {event = .uiRecoveryCodesCopyClick(newValue)}
  }

  var uiRecoveryCodesPrintClick: Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent {
    get {
      if case .uiRecoveryCodesPrintClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent()
    }
    set {event = .uiRecoveryCodesPrintClick(newValue)}
  }

  var uiDiscoverStartedEvent: Teleport_Usageevents_V1_UIDiscoverStartedEvent {
    get {
      if case .uiDiscoverStartedEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverStartedEvent()
    }
    set {event = .uiDiscoverStartedEvent(newValue)}
  }

  var uiDiscoverResourceSelectionEvent: Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent {
    get {
      if case .uiDiscoverResourceSelectionEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent()
    }
    set {event = .uiDiscoverResourceSelectionEvent(newValue)}
  }

  var uiDiscoverDeployServiceEvent: Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent {
    get {
      if case .uiDiscoverDeployServiceEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent()
    }
    set {event = .uiDiscoverDeployServiceEvent(newValue)}
  }

  var uiDiscoverDatabaseRegisterEvent: Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent {
    get {
      if case .uiDiscoverDatabaseRegisterEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent()
    }
    set {event = .uiDiscoverDatabaseRegisterEvent(newValue)}
  }

  var uiDiscoverDatabaseConfigureMtlsEvent: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent {
    get {
      if case .uiDiscoverDatabaseConfigureMtlsEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent()
    }
    set {event = .uiDiscoverDatabaseConfigureMtlsEvent(newValue)}
  }

  var uiDiscoverDesktopActiveDirectoryToolsInstallEvent: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent {
    get {
      if case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent()
    }
    set {event = .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(newValue)}
  }

  var uiDiscoverDesktopActiveDirectoryConfigureEvent: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent {
    get {
      if case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent()
    }
    set {event = .uiDiscoverDesktopActiveDirectoryConfigureEvent(newValue)}
  }

  var uiDiscoverAutoDiscoveredResourcesEvent: Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent {
    get {
      if case .uiDiscoverAutoDiscoveredResourcesEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent()
    }
    set {event = .uiDiscoverAutoDiscoveredResourcesEvent(newValue)}
  }

  var uiDiscoverDatabaseConfigureIamPolicyEvent: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent {
    get {
      if case .uiDiscoverDatabaseConfigureIamPolicyEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent()
    }
    set {event = .uiDiscoverDatabaseConfigureIamPolicyEvent(newValue)}
  }

  var uiDiscoverPrincipalsConfigureEvent: Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent {
    get {
      if case .uiDiscoverPrincipalsConfigureEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent()
    }
    set {event = .uiDiscoverPrincipalsConfigureEvent(newValue)}
  }

  var uiDiscoverTestConnectionEvent: Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent {
    get {
      if case .uiDiscoverTestConnectionEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent()
    }
    set {event = .uiDiscoverTestConnectionEvent(newValue)}
  }

  var uiDiscoverCompletedEvent: Teleport_Usageevents_V1_UIDiscoverCompletedEvent {
    get {
      if case .uiDiscoverCompletedEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverCompletedEvent()
    }
    set {event = .uiDiscoverCompletedEvent(newValue)}
  }

  var uiCreateNewRoleClick: Teleport_Usageevents_V1_UICreateNewRoleClickEvent {
    get {
      if case .uiCreateNewRoleClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UICreateNewRoleClickEvent()
    }
    set {event = .uiCreateNewRoleClick(newValue)}
  }

  var uiCreateNewRoleSaveClick: Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent {
    get {
      if case .uiCreateNewRoleSaveClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent()
    }
    set {event = .uiCreateNewRoleSaveClick(newValue)}
  }

  var uiCreateNewRoleCancelClick: Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent {
    get {
      if case .uiCreateNewRoleCancelClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent()
    }
    set {event = .uiCreateNewRoleCancelClick(newValue)}
  }

  var uiCreateNewRoleViewDocumentationClick: Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent {
    get {
      if case .uiCreateNewRoleViewDocumentationClick(let v)? = event {return v}
      return Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent()
    }
    set {event = .uiCreateNewRoleViewDocumentationClick(newValue)}
  }

  var uiDiscoverIntegrationAwsOidcConnectEvent: Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent {
    get {
      if case .uiDiscoverIntegrationAwsOidcConnectEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent()
    }
    set {event = .uiDiscoverIntegrationAwsOidcConnectEvent(newValue)}
  }

  var uiDiscoverDatabaseRdsEnrollEvent: Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent {
    get {
      if case .uiDiscoverDatabaseRdsEnrollEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent()
    }
    set {event = .uiDiscoverDatabaseRdsEnrollEvent(newValue)}
  }

  var uiCallToActionClickEvent: Teleport_Usageevents_V1_UICallToActionClickEvent {
    get {
      if case .uiCallToActionClickEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UICallToActionClickEvent()
    }
    set {event = .uiCallToActionClickEvent(newValue)}
  }

  var assistCompletion: Teleport_Usageevents_V1_AssistCompletionEvent {
    get {
      if case .assistCompletion(let v)? = event {return v}
      return Teleport_Usageevents_V1_AssistCompletionEvent()
    }
    set {event = .assistCompletion(newValue)}
  }

  var uiIntegrationEnrollStartEvent: Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent {
    get {
      if case .uiIntegrationEnrollStartEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent()
    }
    set {event = .uiIntegrationEnrollStartEvent(newValue)}
  }

  var uiIntegrationEnrollCompleteEvent: Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent {
    get {
      if case .uiIntegrationEnrollCompleteEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent()
    }
    set {event = .uiIntegrationEnrollCompleteEvent(newValue)}
  }

  var uiOnboardQuestionnaireSubmit: Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent {
    get {
      if case .uiOnboardQuestionnaireSubmit(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent()
    }
    set {event = .uiOnboardQuestionnaireSubmit(newValue)}
  }

  var assistExecution: Teleport_Usageevents_V1_AssistExecutionEvent {
    get {
      if case .assistExecution(let v)? = event {return v}
      return Teleport_Usageevents_V1_AssistExecutionEvent()
    }
    set {event = .assistExecution(newValue)}
  }

  var assistNewConversation: Teleport_Usageevents_V1_AssistNewConversationEvent {
    get {
      if case .assistNewConversation(let v)? = event {return v}
      return Teleport_Usageevents_V1_AssistNewConversationEvent()
    }
    set {event = .assistNewConversation(newValue)}
  }

  var resourceCreateEvent: Teleport_Usageevents_V1_ResourceCreateEvent {
    get {
      if case .resourceCreateEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_ResourceCreateEvent()
    }
    set {event = .resourceCreateEvent(newValue)}
  }

  var featureRecommendationEvent: Teleport_Usageevents_V1_FeatureRecommendationEvent {
    get {
      if case .featureRecommendationEvent(let v)? = event {return v}
      return Teleport_Usageevents_V1_FeatureRecommendationEvent()
    }
    set {event = .featureRecommendationEvent(newValue)}
  }

  var assistAccessRequest: Teleport_Usageevents_V1_AssistAccessRequest {
    get {
      if case .assistAccessRequest(let v)? = event {return v}
      return Teleport_Usageevents_V1_AssistAccessRequest()
    }
    set {event = .assistAccessRequest(newValue)}
  }

  var assistAction: Teleport_Usageevents_V1_AssistAction {
    get {
      if case .assistAction(let v)? = event {return v}
      return Teleport_Usageevents_V1_AssistAction()
    }
    set {event = .assistAction(newValue)}
  }

  var accessListCreate: Teleport_Usageevents_V1_AccessListCreate {
    get {
      if case .accessListCreate(let v)? = event {return v}
      return Teleport_Usageevents_V1_AccessListCreate()
    }
    set {event = .accessListCreate(newValue)}
  }

  var accessListUpdate: Teleport_Usageevents_V1_AccessListUpdate {
    get {
      if case .accessListUpdate(let v)? = event {return v}
      return Teleport_Usageevents_V1_AccessListUpdate()
    }
    set {event = .accessListUpdate(newValue)}
  }

  var accessListDelete: Teleport_Usageevents_V1_AccessListDelete {
    get {
      if case .accessListDelete(let v)? = event {return v}
      return Teleport_Usageevents_V1_AccessListDelete()
    }
    set {event = .accessListDelete(newValue)}
  }

  var accessListMemberCreate: Teleport_Usageevents_V1_AccessListMemberCreate {
    get {
      if case .accessListMemberCreate(let v)? = event {return v}
      return Teleport_Usageevents_V1_AccessListMemberCreate()
    }
    set {event = .accessListMemberCreate(newValue)}
  }

  var accessListMemberUpdate: Teleport_Usageevents_V1_AccessListMemberUpdate {
    get {
      if case .accessListMemberUpdate(let v)? = event {return v}
      return Teleport_Usageevents_V1_AccessListMemberUpdate()
    }
    set {event = .accessListMemberUpdate(newValue)}
  }

  var accessListMemberDelete: Teleport_Usageevents_V1_AccessListMemberDelete {
    get {
      if case .accessListMemberDelete(let v)? = event {return v}
      return Teleport_Usageevents_V1_AccessListMemberDelete()
    }
    set {event = .accessListMemberDelete(newValue)}
  }

  var accessListGrantsToUser: Teleport_Usageevents_V1_AccessListGrantsToUser {
    get {
      if case .accessListGrantsToUser(let v)? = event {return v}
      return Teleport_Usageevents_V1_AccessListGrantsToUser()
    }
    set {event = .accessListGrantsToUser(newValue)}
  }

  var uiDiscoverEc2InstanceSelection: Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent {
    get {
      if case .uiDiscoverEc2InstanceSelection(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent()
    }
    set {event = .uiDiscoverEc2InstanceSelection(newValue)}
  }

  var uiDiscoverDeployEice: Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent {
    get {
      if case .uiDiscoverDeployEice(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent()
    }
    set {event = .uiDiscoverDeployEice(newValue)}
  }

  var uiDiscoverCreateNode: Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent {
    get {
      if case .uiDiscoverCreateNode(let v)? = event {return v}
      return Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent()
    }
    set {event = .uiDiscoverCreateNode(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable {
    case uiBannerClick(Teleport_Usageevents_V1_UIBannerClickEvent)
    case uiOnboardCompleteGoToDashboardClick(Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent)
    case uiOnboardAddFirstResourceClick(Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent)
    case uiOnboardAddFirstResourceLaterClick(Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent)
    case uiOnboardSetCredentialSubmit(Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent)
    case uiOnboardRegisterChallengeSubmit(Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent)
    case uiRecoveryCodesContinueClick(Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent)
    case uiRecoveryCodesCopyClick(Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent)
    case uiRecoveryCodesPrintClick(Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent)
    case uiDiscoverStartedEvent(Teleport_Usageevents_V1_UIDiscoverStartedEvent)
    case uiDiscoverResourceSelectionEvent(Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent)
    case uiDiscoverDeployServiceEvent(Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent)
    case uiDiscoverDatabaseRegisterEvent(Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent)
    case uiDiscoverDatabaseConfigureMtlsEvent(Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent)
    case uiDiscoverDesktopActiveDirectoryToolsInstallEvent(Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent)
    case uiDiscoverDesktopActiveDirectoryConfigureEvent(Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent)
    case uiDiscoverAutoDiscoveredResourcesEvent(Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent)
    case uiDiscoverDatabaseConfigureIamPolicyEvent(Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent)
    case uiDiscoverPrincipalsConfigureEvent(Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent)
    case uiDiscoverTestConnectionEvent(Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent)
    case uiDiscoverCompletedEvent(Teleport_Usageevents_V1_UIDiscoverCompletedEvent)
    case uiCreateNewRoleClick(Teleport_Usageevents_V1_UICreateNewRoleClickEvent)
    case uiCreateNewRoleSaveClick(Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent)
    case uiCreateNewRoleCancelClick(Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent)
    case uiCreateNewRoleViewDocumentationClick(Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent)
    case uiDiscoverIntegrationAwsOidcConnectEvent(Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent)
    case uiDiscoverDatabaseRdsEnrollEvent(Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent)
    case uiCallToActionClickEvent(Teleport_Usageevents_V1_UICallToActionClickEvent)
    case assistCompletion(Teleport_Usageevents_V1_AssistCompletionEvent)
    case uiIntegrationEnrollStartEvent(Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent)
    case uiIntegrationEnrollCompleteEvent(Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent)
    case uiOnboardQuestionnaireSubmit(Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent)
    case assistExecution(Teleport_Usageevents_V1_AssistExecutionEvent)
    case assistNewConversation(Teleport_Usageevents_V1_AssistNewConversationEvent)
    case resourceCreateEvent(Teleport_Usageevents_V1_ResourceCreateEvent)
    case featureRecommendationEvent(Teleport_Usageevents_V1_FeatureRecommendationEvent)
    case assistAccessRequest(Teleport_Usageevents_V1_AssistAccessRequest)
    case assistAction(Teleport_Usageevents_V1_AssistAction)
    case accessListCreate(Teleport_Usageevents_V1_AccessListCreate)
    case accessListUpdate(Teleport_Usageevents_V1_AccessListUpdate)
    case accessListDelete(Teleport_Usageevents_V1_AccessListDelete)
    case accessListMemberCreate(Teleport_Usageevents_V1_AccessListMemberCreate)
    case accessListMemberUpdate(Teleport_Usageevents_V1_AccessListMemberUpdate)
    case accessListMemberDelete(Teleport_Usageevents_V1_AccessListMemberDelete)
    case accessListGrantsToUser(Teleport_Usageevents_V1_AccessListGrantsToUser)
    case uiDiscoverEc2InstanceSelection(Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent)
    case uiDiscoverDeployEice(Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent)
    case uiDiscoverCreateNode(Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent)

  #if !swift(>=4.1)
    static func ==(lhs: Teleport_Usageevents_V1_UsageEventOneOf.OneOf_Event, rhs: Teleport_Usageevents_V1_UsageEventOneOf.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uiBannerClick, .uiBannerClick): return {
        guard case .uiBannerClick(let l) = lhs, case .uiBannerClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiOnboardCompleteGoToDashboardClick, .uiOnboardCompleteGoToDashboardClick): return {
        guard case .uiOnboardCompleteGoToDashboardClick(let l) = lhs, case .uiOnboardCompleteGoToDashboardClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiOnboardAddFirstResourceClick, .uiOnboardAddFirstResourceClick): return {
        guard case .uiOnboardAddFirstResourceClick(let l) = lhs, case .uiOnboardAddFirstResourceClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiOnboardAddFirstResourceLaterClick, .uiOnboardAddFirstResourceLaterClick): return {
        guard case .uiOnboardAddFirstResourceLaterClick(let l) = lhs, case .uiOnboardAddFirstResourceLaterClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiOnboardSetCredentialSubmit, .uiOnboardSetCredentialSubmit): return {
        guard case .uiOnboardSetCredentialSubmit(let l) = lhs, case .uiOnboardSetCredentialSubmit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiOnboardRegisterChallengeSubmit, .uiOnboardRegisterChallengeSubmit): return {
        guard case .uiOnboardRegisterChallengeSubmit(let l) = lhs, case .uiOnboardRegisterChallengeSubmit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiRecoveryCodesContinueClick, .uiRecoveryCodesContinueClick): return {
        guard case .uiRecoveryCodesContinueClick(let l) = lhs, case .uiRecoveryCodesContinueClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiRecoveryCodesCopyClick, .uiRecoveryCodesCopyClick): return {
        guard case .uiRecoveryCodesCopyClick(let l) = lhs, case .uiRecoveryCodesCopyClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiRecoveryCodesPrintClick, .uiRecoveryCodesPrintClick): return {
        guard case .uiRecoveryCodesPrintClick(let l) = lhs, case .uiRecoveryCodesPrintClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverStartedEvent, .uiDiscoverStartedEvent): return {
        guard case .uiDiscoverStartedEvent(let l) = lhs, case .uiDiscoverStartedEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverResourceSelectionEvent, .uiDiscoverResourceSelectionEvent): return {
        guard case .uiDiscoverResourceSelectionEvent(let l) = lhs, case .uiDiscoverResourceSelectionEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDeployServiceEvent, .uiDiscoverDeployServiceEvent): return {
        guard case .uiDiscoverDeployServiceEvent(let l) = lhs, case .uiDiscoverDeployServiceEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDatabaseRegisterEvent, .uiDiscoverDatabaseRegisterEvent): return {
        guard case .uiDiscoverDatabaseRegisterEvent(let l) = lhs, case .uiDiscoverDatabaseRegisterEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDatabaseConfigureMtlsEvent, .uiDiscoverDatabaseConfigureMtlsEvent): return {
        guard case .uiDiscoverDatabaseConfigureMtlsEvent(let l) = lhs, case .uiDiscoverDatabaseConfigureMtlsEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDesktopActiveDirectoryToolsInstallEvent, .uiDiscoverDesktopActiveDirectoryToolsInstallEvent): return {
        guard case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let l) = lhs, case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDesktopActiveDirectoryConfigureEvent, .uiDiscoverDesktopActiveDirectoryConfigureEvent): return {
        guard case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let l) = lhs, case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverAutoDiscoveredResourcesEvent, .uiDiscoverAutoDiscoveredResourcesEvent): return {
        guard case .uiDiscoverAutoDiscoveredResourcesEvent(let l) = lhs, case .uiDiscoverAutoDiscoveredResourcesEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDatabaseConfigureIamPolicyEvent, .uiDiscoverDatabaseConfigureIamPolicyEvent): return {
        guard case .uiDiscoverDatabaseConfigureIamPolicyEvent(let l) = lhs, case .uiDiscoverDatabaseConfigureIamPolicyEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverPrincipalsConfigureEvent, .uiDiscoverPrincipalsConfigureEvent): return {
        guard case .uiDiscoverPrincipalsConfigureEvent(let l) = lhs, case .uiDiscoverPrincipalsConfigureEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverTestConnectionEvent, .uiDiscoverTestConnectionEvent): return {
        guard case .uiDiscoverTestConnectionEvent(let l) = lhs, case .uiDiscoverTestConnectionEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverCompletedEvent, .uiDiscoverCompletedEvent): return {
        guard case .uiDiscoverCompletedEvent(let l) = lhs, case .uiDiscoverCompletedEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiCreateNewRoleClick, .uiCreateNewRoleClick): return {
        guard case .uiCreateNewRoleClick(let l) = lhs, case .uiCreateNewRoleClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiCreateNewRoleSaveClick, .uiCreateNewRoleSaveClick): return {
        guard case .uiCreateNewRoleSaveClick(let l) = lhs, case .uiCreateNewRoleSaveClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiCreateNewRoleCancelClick, .uiCreateNewRoleCancelClick): return {
        guard case .uiCreateNewRoleCancelClick(let l) = lhs, case .uiCreateNewRoleCancelClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiCreateNewRoleViewDocumentationClick, .uiCreateNewRoleViewDocumentationClick): return {
        guard case .uiCreateNewRoleViewDocumentationClick(let l) = lhs, case .uiCreateNewRoleViewDocumentationClick(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverIntegrationAwsOidcConnectEvent, .uiDiscoverIntegrationAwsOidcConnectEvent): return {
        guard case .uiDiscoverIntegrationAwsOidcConnectEvent(let l) = lhs, case .uiDiscoverIntegrationAwsOidcConnectEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDatabaseRdsEnrollEvent, .uiDiscoverDatabaseRdsEnrollEvent): return {
        guard case .uiDiscoverDatabaseRdsEnrollEvent(let l) = lhs, case .uiDiscoverDatabaseRdsEnrollEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiCallToActionClickEvent, .uiCallToActionClickEvent): return {
        guard case .uiCallToActionClickEvent(let l) = lhs, case .uiCallToActionClickEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assistCompletion, .assistCompletion): return {
        guard case .assistCompletion(let l) = lhs, case .assistCompletion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiIntegrationEnrollStartEvent, .uiIntegrationEnrollStartEvent): return {
        guard case .uiIntegrationEnrollStartEvent(let l) = lhs, case .uiIntegrationEnrollStartEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiIntegrationEnrollCompleteEvent, .uiIntegrationEnrollCompleteEvent): return {
        guard case .uiIntegrationEnrollCompleteEvent(let l) = lhs, case .uiIntegrationEnrollCompleteEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiOnboardQuestionnaireSubmit, .uiOnboardQuestionnaireSubmit): return {
        guard case .uiOnboardQuestionnaireSubmit(let l) = lhs, case .uiOnboardQuestionnaireSubmit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assistExecution, .assistExecution): return {
        guard case .assistExecution(let l) = lhs, case .assistExecution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assistNewConversation, .assistNewConversation): return {
        guard case .assistNewConversation(let l) = lhs, case .assistNewConversation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resourceCreateEvent, .resourceCreateEvent): return {
        guard case .resourceCreateEvent(let l) = lhs, case .resourceCreateEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.featureRecommendationEvent, .featureRecommendationEvent): return {
        guard case .featureRecommendationEvent(let l) = lhs, case .featureRecommendationEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assistAccessRequest, .assistAccessRequest): return {
        guard case .assistAccessRequest(let l) = lhs, case .assistAccessRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assistAction, .assistAction): return {
        guard case .assistAction(let l) = lhs, case .assistAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListCreate, .accessListCreate): return {
        guard case .accessListCreate(let l) = lhs, case .accessListCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListUpdate, .accessListUpdate): return {
        guard case .accessListUpdate(let l) = lhs, case .accessListUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListDelete, .accessListDelete): return {
        guard case .accessListDelete(let l) = lhs, case .accessListDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMemberCreate, .accessListMemberCreate): return {
        guard case .accessListMemberCreate(let l) = lhs, case .accessListMemberCreate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMemberUpdate, .accessListMemberUpdate): return {
        guard case .accessListMemberUpdate(let l) = lhs, case .accessListMemberUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListMemberDelete, .accessListMemberDelete): return {
        guard case .accessListMemberDelete(let l) = lhs, case .accessListMemberDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessListGrantsToUser, .accessListGrantsToUser): return {
        guard case .accessListGrantsToUser(let l) = lhs, case .accessListGrantsToUser(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverEc2InstanceSelection, .uiDiscoverEc2InstanceSelection): return {
        guard case .uiDiscoverEc2InstanceSelection(let l) = lhs, case .uiDiscoverEc2InstanceSelection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverDeployEice, .uiDiscoverDeployEice): return {
        guard case .uiDiscoverDeployEice(let l) = lhs, case .uiDiscoverDeployEice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uiDiscoverCreateNode, .uiDiscoverCreateNode): return {
        guard case .uiDiscoverCreateNode(let l) = lhs, case .uiDiscoverCreateNode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Teleport_Usageevents_V1_DiscoverResource: @unchecked Sendable {}
extension Teleport_Usageevents_V1_DiscoverStatus: @unchecked Sendable {}
extension Teleport_Usageevents_V1_CTA: @unchecked Sendable {}
extension Teleport_Usageevents_V1_IntegrationEnrollKind: @unchecked Sendable {}
extension Teleport_Usageevents_V1_Feature: @unchecked Sendable {}
extension Teleport_Usageevents_V1_FeatureRecommendationStatus: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIBannerClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_DiscoverMetadata: @unchecked Sendable {}
extension Teleport_Usageevents_V1_DiscoverResourceMetadata: @unchecked Sendable {}
extension Teleport_Usageevents_V1_DiscoverStepStatus: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverStartedEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UICallToActionClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployMethod: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployType: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIDiscoverCompletedEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UICreateNewRoleClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AssistCompletionEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AssistExecutionEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AssistNewConversationEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AssistAccessRequest: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AssistAction: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListMetadata: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListCreate: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListUpdate: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListDelete: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListMemberCreate: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListMemberUpdate: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListMemberDelete: @unchecked Sendable {}
extension Teleport_Usageevents_V1_AccessListGrantsToUser: @unchecked Sendable {}
extension Teleport_Usageevents_V1_IntegrationEnrollMetadata: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_ResourceCreateEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_DiscoveredDatabaseMetadata: @unchecked Sendable {}
extension Teleport_Usageevents_V1_FeatureRecommendationEvent: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UsageEventOneOf: @unchecked Sendable {}
extension Teleport_Usageevents_V1_UsageEventOneOf.OneOf_Event: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.usageevents.v1"

extension Teleport_Usageevents_V1_DiscoverResource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISCOVER_RESOURCE_UNSPECIFIED"),
    1: .same(proto: "DISCOVER_RESOURCE_SERVER"),
    2: .same(proto: "DISCOVER_RESOURCE_KUBERNETES"),
    3: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_SELF_HOSTED"),
    4: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_SELF_HOSTED"),
    5: .same(proto: "DISCOVER_RESOURCE_DATABASE_MONGODB_SELF_HOSTED"),
    6: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_RDS"),
    7: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_RDS"),
    8: .same(proto: "DISCOVER_RESOURCE_APPLICATION_HTTP"),
    9: .same(proto: "DISCOVER_RESOURCE_APPLICATION_TCP"),
    10: .same(proto: "DISCOVER_RESOURCE_WINDOWS_DESKTOP"),
    11: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_RDS"),
    12: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_REDSHIFT"),
    13: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_SELF_HOSTED"),
    14: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_SELF_HOSTED"),
    15: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_GCP"),
    16: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_GCP"),
    17: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_GCP"),
    18: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_REDSHIFT_SERVERLESS"),
    19: .same(proto: "DISCOVER_RESOURCE_DATABASE_POSTGRES_AZURE"),
    20: .same(proto: "DISCOVER_RESOURCE_DATABASE_DYNAMODB"),
    21: .same(proto: "DISCOVER_RESOURCE_DATABASE_CASSANDRA_KEYSPACES"),
    22: .same(proto: "DISCOVER_RESOURCE_DATABASE_CASSANDRA_SELF_HOSTED"),
    23: .same(proto: "DISCOVER_RESOURCE_DATABASE_ELASTICSEARCH_SELF_HOSTED"),
    24: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_ELASTICACHE"),
    25: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_MEMORYDB"),
    26: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_AZURE_CACHE"),
    27: .same(proto: "DISCOVER_RESOURCE_DATABASE_REDIS_CLUSTER_SELF_HOSTED"),
    28: .same(proto: "DISCOVER_RESOURCE_DATABASE_MYSQL_AZURE"),
    29: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_AZURE"),
    30: .same(proto: "DISCOVER_RESOURCE_DATABASE_SQLSERVER_MICROSOFT"),
    31: .same(proto: "DISCOVER_RESOURCE_DATABASE_COCKROACHDB_SELF_HOSTED"),
    32: .same(proto: "DISCOVER_RESOURCE_DATABASE_MONGODB_ATLAS"),
    33: .same(proto: "DISCOVER_RESOURCE_DATABASE_SNOWFLAKE"),
    34: .same(proto: "DISCOVER_RESOURCE_DOC_DATABASE_RDS_PROXY"),
    35: .same(proto: "DISCOVER_RESOURCE_DOC_DATABASE_HIGH_AVAILABILITY"),
    36: .same(proto: "DISCOVER_RESOURCE_DOC_DATABASE_DYNAMIC_REGISTRATION"),
    37: .same(proto: "DISCOVER_RESOURCE_SAML_APPLICATION"),
    38: .same(proto: "DISCOVER_RESOURCE_EC2_INSTANCE"),
  ]
}

extension Teleport_Usageevents_V1_DiscoverStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISCOVER_STATUS_UNSPECIFIED"),
    1: .same(proto: "DISCOVER_STATUS_SUCCESS"),
    2: .same(proto: "DISCOVER_STATUS_SKIPPED"),
    3: .same(proto: "DISCOVER_STATUS_ERROR"),
    4: .same(proto: "DISCOVER_STATUS_ABORTED"),
  ]
}

extension Teleport_Usageevents_V1_CTA: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CTA_UNSPECIFIED"),
    1: .same(proto: "CTA_AUTH_CONNECTOR"),
    2: .same(proto: "CTA_ACTIVE_SESSIONS"),
    3: .same(proto: "CTA_ACCESS_REQUESTS"),
    4: .same(proto: "CTA_PREMIUM_SUPPORT"),
    5: .same(proto: "CTA_TRUSTED_DEVICES"),
    6: .same(proto: "CTA_UPGRADE_BANNER"),
    7: .same(proto: "CTA_BILLING_SUMMARY"),
  ]
}

extension Teleport_Usageevents_V1_IntegrationEnrollKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTEGRATION_ENROLL_KIND_UNSPECIFIED"),
    1: .same(proto: "INTEGRATION_ENROLL_KIND_SLACK"),
    2: .same(proto: "INTEGRATION_ENROLL_KIND_AWS_OIDC"),
    3: .same(proto: "INTEGRATION_ENROLL_KIND_PAGERDUTY"),
    4: .same(proto: "INTEGRATION_ENROLL_KIND_EMAIL"),
    5: .same(proto: "INTEGRATION_ENROLL_KIND_JIRA"),
    6: .same(proto: "INTEGRATION_ENROLL_KIND_DISCORD"),
    7: .same(proto: "INTEGRATION_ENROLL_KIND_MATTERMOST"),
    8: .same(proto: "INTEGRATION_ENROLL_KIND_MS_TEAMS"),
    9: .same(proto: "INTEGRATION_ENROLL_KIND_OPSGENIE"),
    10: .same(proto: "INTEGRATION_ENROLL_KIND_OKTA"),
    11: .same(proto: "INTEGRATION_ENROLL_KIND_JAMF"),
    12: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID"),
    13: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_GITHUB_ACTIONS"),
    14: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_CIRCLECI"),
    15: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_GITLAB"),
    16: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_JENKINS"),
    17: .same(proto: "INTEGRATION_ENROLL_KIND_MACHINE_ID_ANSIBLE"),
    18: .same(proto: "INTEGRATION_ENROLL_KIND_SERVICENOW"),
  ]
}

extension Teleport_Usageevents_V1_Feature: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_UNSPECIFIED"),
    1: .same(proto: "FEATURE_TRUSTED_DEVICES"),
  ]
}

extension Teleport_Usageevents_V1_FeatureRecommendationStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_RECOMMENDATION_STATUS_UNSPECIFIED"),
    1: .same(proto: "FEATURE_RECOMMENDATION_STATUS_NOTIFIED"),
    2: .same(proto: "FEATURE_RECOMMENDATION_STATUS_DONE"),
  ]
}

extension Teleport_Usageevents_V1_UIBannerClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIBannerClickEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alert"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.alert) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alert.isEmpty {
      try visitor.visitSingularStringField(value: self.alert, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIBannerClickEvent, rhs: Teleport_Usageevents_V1_UIBannerClickEvent) -> Bool {
    if lhs.alert != rhs.alert {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIOnboardCompleteGoToDashboardClickEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent, rhs: Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIOnboardAddFirstResourceClickEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent, rhs: Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIOnboardAddFirstResourceLaterClickEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent, rhs: Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIOnboardSetCredentialSubmitEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent, rhs: Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIOnboardQuestionnaireSubmitEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent, rhs: Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIOnboardRegisterChallengeSubmitEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .standard(proto: "mfa_type"),
    3: .standard(proto: "login_flow"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mfaType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.loginFlow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.mfaType.isEmpty {
      try visitor.visitSingularStringField(value: self.mfaType, fieldNumber: 2)
    }
    if !self.loginFlow.isEmpty {
      try visitor.visitSingularStringField(value: self.loginFlow, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent, rhs: Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.mfaType != rhs.mfaType {return false}
    if lhs.loginFlow != rhs.loginFlow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIRecoveryCodesContinueClickEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent, rhs: Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIRecoveryCodesCopyClickEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent, rhs: Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIRecoveryCodesPrintClickEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent, rhs: Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_DiscoverMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiscoverMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_DiscoverMetadata, rhs: Teleport_Usageevents_V1_DiscoverMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_DiscoverResourceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiscoverResourceMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.resource) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.resource != .unspecified {
      try visitor.visitSingularEnumField(value: self.resource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_DiscoverResourceMetadata, rhs: Teleport_Usageevents_V1_DiscoverResourceMetadata) -> Bool {
    if lhs.resource != rhs.resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_DiscoverStepStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiscoverStepStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_DiscoverStepStatus, rhs: Teleport_Usageevents_V1_DiscoverStepStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverStartedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverStartedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverStartedEvent, rhs: Teleport_Usageevents_V1_UIDiscoverStartedEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverResourceSelectionEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent, rhs: Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverIntegrationAWSOIDCConnectEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent, rhs: Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseRDSEnrollEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
    4: .standard(proto: "selected_resources_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.selectedResourcesCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.selectedResourcesCount != 0 {
      try visitor.visitSingularInt64Field(value: self.selectedResourcesCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.selectedResourcesCount != rhs.selectedResourcesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UICallToActionClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UICallToActionClickEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.cta) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cta != .unspecified {
      try visitor.visitSingularEnumField(value: self.cta, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UICallToActionClickEvent, rhs: Teleport_Usageevents_V1_UICallToActionClickEvent) -> Bool {
    if lhs.cta != rhs.cta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDeployServiceEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
    4: .standard(proto: "deploy_method"),
    5: .standard(proto: "deploy_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.deployMethod) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.deployType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.deployMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.deployMethod, fieldNumber: 4)
    }
    if self.deployType != .unspecified {
      try visitor.visitSingularEnumField(value: self.deployType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.deployMethod != rhs.deployMethod {return false}
    if lhs.deployType != rhs.deployType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPLOY_METHOD_UNSPECIFIED"),
    1: .same(proto: "DEPLOY_METHOD_AUTO"),
    2: .same(proto: "DEPLOY_METHOD_MANUAL"),
  ]
}

extension Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent.DeployType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPLOY_TYPE_UNSPECIFIED"),
    1: .same(proto: "DEPLOY_TYPE_INSTALL_SCRIPT"),
    2: .same(proto: "DEPLOY_TYPE_AMAZON_ECS"),
  ]
}

extension Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseRegisterEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseConfigureMTLSEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDesktopActiveDirectoryToolsInstallEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDesktopActiveDirectoryConfigureEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverAutoDiscoveredResourcesEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
    4: .standard(proto: "resources_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.resourcesCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.resourcesCount != 0 {
      try visitor.visitSingularInt64Field(value: self.resourcesCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent, rhs: Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.resourcesCount != rhs.resourcesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverEC2InstanceSelectionEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent, rhs: Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDeployEICEEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverCreateNodeEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent, rhs: Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverDatabaseConfigureIAMPolicyEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent, rhs: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverPrincipalsConfigureEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent, rhs: Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverTestConnectionEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent, rhs: Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIDiscoverCompletedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIDiscoverCompletedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "resource"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIDiscoverCompletedEvent, rhs: Teleport_Usageevents_V1_UIDiscoverCompletedEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UICreateNewRoleClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleClickEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UICreateNewRoleClickEvent, rhs: Teleport_Usageevents_V1_UICreateNewRoleClickEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleSaveClickEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent, rhs: Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleCancelClickEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent, rhs: Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UICreateNewRoleViewDocumentationClickEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent, rhs: Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AssistCompletionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssistCompletionEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "total_tokens"),
    3: .standard(proto: "prompt_tokens"),
    4: .standard(proto: "completion_tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 2)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 3)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AssistCompletionEvent, rhs: Teleport_Usageevents_V1_AssistCompletionEvent) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AssistExecutionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssistExecutionEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conversation_id"),
    2: .standard(proto: "node_count"),
    3: .standard(proto: "total_tokens"),
    4: .standard(proto: "prompt_tokens"),
    5: .standard(proto: "completion_tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.nodeCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if self.nodeCount != 0 {
      try visitor.visitSingularInt64Field(value: self.nodeCount, fieldNumber: 2)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 3)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 4)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AssistExecutionEvent, rhs: Teleport_Usageevents_V1_AssistExecutionEvent) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.nodeCount != rhs.nodeCount {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AssistNewConversationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssistNewConversationEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.category) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AssistNewConversationEvent, rhs: Teleport_Usageevents_V1_AssistNewConversationEvent) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AssistAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssistAccessRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_type"),
    2: .standard(proto: "total_tokens"),
    3: .standard(proto: "prompt_tokens"),
    4: .standard(proto: "completion_tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 1)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 2)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 3)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AssistAccessRequest, rhs: Teleport_Usageevents_V1_AssistAccessRequest) -> Bool {
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AssistAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssistAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "total_tokens"),
    3: .standard(proto: "prompt_tokens"),
    4: .standard(proto: "completion_tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalTokens) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.promptTokens) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.completionTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 1)
    }
    if self.totalTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.totalTokens, fieldNumber: 2)
    }
    if self.promptTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.promptTokens, fieldNumber: 3)
    }
    if self.completionTokens != 0 {
      try visitor.visitSingularInt64Field(value: self.completionTokens, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AssistAction, rhs: Teleport_Usageevents_V1_AssistAction) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.totalTokens != rhs.totalTokens {return false}
    if lhs.promptTokens != rhs.promptTokens {return false}
    if lhs.completionTokens != rhs.completionTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListMetadata, rhs: Teleport_Usageevents_V1_AccessListMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListCreate, rhs: Teleport_Usageevents_V1_AccessListCreate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListUpdate, rhs: Teleport_Usageevents_V1_AccessListUpdate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListDelete, rhs: Teleport_Usageevents_V1_AccessListDelete) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListMemberCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListMemberCreate, rhs: Teleport_Usageevents_V1_AccessListMemberCreate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListMemberUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListMemberUpdate, rhs: Teleport_Usageevents_V1_AccessListMemberUpdate) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListMemberDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListMemberDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListMemberDelete, rhs: Teleport_Usageevents_V1_AccessListMemberDelete) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_AccessListGrantsToUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessListGrantsToUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "count_roles_granted"),
    2: .standard(proto: "count_traits_granted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.countRolesGranted) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.countTraitsGranted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.countRolesGranted != 0 {
      try visitor.visitSingularInt32Field(value: self.countRolesGranted, fieldNumber: 1)
    }
    if self.countTraitsGranted != 0 {
      try visitor.visitSingularInt32Field(value: self.countTraitsGranted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_AccessListGrantsToUser, rhs: Teleport_Usageevents_V1_AccessListGrantsToUser) -> Bool {
    if lhs.countRolesGranted != rhs.countRolesGranted {return false}
    if lhs.countTraitsGranted != rhs.countTraitsGranted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_IntegrationEnrollMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IntegrationEnrollMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "kind"),
    3: .standard(proto: "user_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_IntegrationEnrollMetadata, rhs: Teleport_Usageevents_V1_IntegrationEnrollMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIIntegrationEnrollStartEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent, rhs: Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UIIntegrationEnrollCompleteEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent, rhs: Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_ResourceCreateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceCreateEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_type"),
    2: .standard(proto: "resource_origin"),
    3: .standard(proto: "cloud_provider"),
    4: .same(proto: "database"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceOrigin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cloudProvider) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._database) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 1)
    }
    if !self.resourceOrigin.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceOrigin, fieldNumber: 2)
    }
    if !self.cloudProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudProvider, fieldNumber: 3)
    }
    try { if let v = self._database {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_ResourceCreateEvent, rhs: Teleport_Usageevents_V1_ResourceCreateEvent) -> Bool {
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.resourceOrigin != rhs.resourceOrigin {return false}
    if lhs.cloudProvider != rhs.cloudProvider {return false}
    if lhs._database != rhs._database {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_DiscoveredDatabaseMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiscoveredDatabaseMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "db_type"),
    2: .standard(proto: "db_protocol"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dbType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dbProtocol) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dbType.isEmpty {
      try visitor.visitSingularStringField(value: self.dbType, fieldNumber: 1)
    }
    if !self.dbProtocol.isEmpty {
      try visitor.visitSingularStringField(value: self.dbProtocol, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_DiscoveredDatabaseMetadata, rhs: Teleport_Usageevents_V1_DiscoveredDatabaseMetadata) -> Bool {
    if lhs.dbType != rhs.dbType {return false}
    if lhs.dbProtocol != rhs.dbProtocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_FeatureRecommendationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureRecommendationEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_name"),
    2: .same(proto: "feature"),
    3: .standard(proto: "feature_recommendation_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.feature) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.featureRecommendationStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 1)
    }
    if self.feature != .unspecified {
      try visitor.visitSingularEnumField(value: self.feature, fieldNumber: 2)
    }
    if self.featureRecommendationStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.featureRecommendationStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_FeatureRecommendationEvent, rhs: Teleport_Usageevents_V1_FeatureRecommendationEvent) -> Bool {
    if lhs.userName != rhs.userName {return false}
    if lhs.feature != rhs.feature {return false}
    if lhs.featureRecommendationStatus != rhs.featureRecommendationStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Usageevents_V1_UsageEventOneOf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UsageEventOneOf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ui_banner_click"),
    3: .standard(proto: "ui_onboard_complete_go_to_dashboard_click"),
    4: .standard(proto: "ui_onboard_add_first_resource_click"),
    5: .standard(proto: "ui_onboard_add_first_resource_later_click"),
    6: .standard(proto: "ui_onboard_set_credential_submit"),
    7: .standard(proto: "ui_onboard_register_challenge_submit"),
    8: .standard(proto: "ui_recovery_codes_continue_click"),
    9: .standard(proto: "ui_recovery_codes_copy_click"),
    10: .standard(proto: "ui_recovery_codes_print_click"),
    11: .standard(proto: "ui_discover_started_event"),
    12: .standard(proto: "ui_discover_resource_selection_event"),
    13: .standard(proto: "ui_discover_deploy_service_event"),
    14: .standard(proto: "ui_discover_database_register_event"),
    15: .standard(proto: "ui_discover_database_configure_mtls_event"),
    16: .standard(proto: "ui_discover_desktop_active_directory_tools_install_event"),
    17: .standard(proto: "ui_discover_desktop_active_directory_configure_event"),
    18: .standard(proto: "ui_discover_auto_discovered_resources_event"),
    19: .standard(proto: "ui_discover_database_configure_iam_policy_event"),
    20: .standard(proto: "ui_discover_principals_configure_event"),
    21: .standard(proto: "ui_discover_test_connection_event"),
    22: .standard(proto: "ui_discover_completed_event"),
    23: .standard(proto: "ui_create_new_role_click"),
    24: .standard(proto: "ui_create_new_role_save_click"),
    25: .standard(proto: "ui_create_new_role_cancel_click"),
    26: .standard(proto: "ui_create_new_role_view_documentation_click"),
    27: .standard(proto: "ui_discover_integration_aws_oidc_connect_event"),
    28: .standard(proto: "ui_discover_database_rds_enroll_event"),
    29: .standard(proto: "ui_call_to_action_click_event"),
    30: .standard(proto: "assist_completion"),
    31: .standard(proto: "ui_integration_enroll_start_event"),
    32: .standard(proto: "ui_integration_enroll_complete_event"),
    33: .standard(proto: "ui_onboard_questionnaire_submit"),
    34: .standard(proto: "assist_execution"),
    35: .standard(proto: "assist_new_conversation"),
    36: .standard(proto: "resource_create_event"),
    37: .standard(proto: "feature_recommendation_event"),
    38: .standard(proto: "assist_access_request"),
    39: .standard(proto: "assist_action"),
    40: .standard(proto: "access_list_create"),
    41: .standard(proto: "access_list_update"),
    42: .standard(proto: "access_list_delete"),
    43: .standard(proto: "access_list_member_create"),
    44: .standard(proto: "access_list_member_update"),
    45: .standard(proto: "access_list_member_delete"),
    46: .standard(proto: "access_list_grants_to_user"),
    47: .standard(proto: "ui_discover_ec2_instance_selection"),
    48: .standard(proto: "ui_discover_deploy_eice"),
    49: .standard(proto: "ui_discover_create_node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Teleport_Usageevents_V1_UIBannerClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiBannerClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiBannerClick(v)
        }
      }()
      case 3: try {
        var v: Teleport_Usageevents_V1_UIOnboardCompleteGoToDashboardClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiOnboardCompleteGoToDashboardClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiOnboardCompleteGoToDashboardClick(v)
        }
      }()
      case 4: try {
        var v: Teleport_Usageevents_V1_UIOnboardAddFirstResourceClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiOnboardAddFirstResourceClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiOnboardAddFirstResourceClick(v)
        }
      }()
      case 5: try {
        var v: Teleport_Usageevents_V1_UIOnboardAddFirstResourceLaterClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiOnboardAddFirstResourceLaterClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiOnboardAddFirstResourceLaterClick(v)
        }
      }()
      case 6: try {
        var v: Teleport_Usageevents_V1_UIOnboardSetCredentialSubmitEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiOnboardSetCredentialSubmit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiOnboardSetCredentialSubmit(v)
        }
      }()
      case 7: try {
        var v: Teleport_Usageevents_V1_UIOnboardRegisterChallengeSubmitEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiOnboardRegisterChallengeSubmit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiOnboardRegisterChallengeSubmit(v)
        }
      }()
      case 8: try {
        var v: Teleport_Usageevents_V1_UIRecoveryCodesContinueClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiRecoveryCodesContinueClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiRecoveryCodesContinueClick(v)
        }
      }()
      case 9: try {
        var v: Teleport_Usageevents_V1_UIRecoveryCodesCopyClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiRecoveryCodesCopyClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiRecoveryCodesCopyClick(v)
        }
      }()
      case 10: try {
        var v: Teleport_Usageevents_V1_UIRecoveryCodesPrintClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiRecoveryCodesPrintClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiRecoveryCodesPrintClick(v)
        }
      }()
      case 11: try {
        var v: Teleport_Usageevents_V1_UIDiscoverStartedEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverStartedEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverStartedEvent(v)
        }
      }()
      case 12: try {
        var v: Teleport_Usageevents_V1_UIDiscoverResourceSelectionEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverResourceSelectionEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverResourceSelectionEvent(v)
        }
      }()
      case 13: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDeployServiceEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDeployServiceEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDeployServiceEvent(v)
        }
      }()
      case 14: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDatabaseRegisterEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDatabaseRegisterEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDatabaseRegisterEvent(v)
        }
      }()
      case 15: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureMTLSEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDatabaseConfigureMtlsEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDatabaseConfigureMtlsEvent(v)
        }
      }()
      case 16: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryToolsInstallEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(v)
        }
      }()
      case 17: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDesktopActiveDirectoryConfigureEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDesktopActiveDirectoryConfigureEvent(v)
        }
      }()
      case 18: try {
        var v: Teleport_Usageevents_V1_UIDiscoverAutoDiscoveredResourcesEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverAutoDiscoveredResourcesEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverAutoDiscoveredResourcesEvent(v)
        }
      }()
      case 19: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDatabaseConfigureIAMPolicyEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDatabaseConfigureIamPolicyEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDatabaseConfigureIamPolicyEvent(v)
        }
      }()
      case 20: try {
        var v: Teleport_Usageevents_V1_UIDiscoverPrincipalsConfigureEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverPrincipalsConfigureEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverPrincipalsConfigureEvent(v)
        }
      }()
      case 21: try {
        var v: Teleport_Usageevents_V1_UIDiscoverTestConnectionEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverTestConnectionEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverTestConnectionEvent(v)
        }
      }()
      case 22: try {
        var v: Teleport_Usageevents_V1_UIDiscoverCompletedEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverCompletedEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverCompletedEvent(v)
        }
      }()
      case 23: try {
        var v: Teleport_Usageevents_V1_UICreateNewRoleClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiCreateNewRoleClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiCreateNewRoleClick(v)
        }
      }()
      case 24: try {
        var v: Teleport_Usageevents_V1_UICreateNewRoleSaveClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiCreateNewRoleSaveClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiCreateNewRoleSaveClick(v)
        }
      }()
      case 25: try {
        var v: Teleport_Usageevents_V1_UICreateNewRoleCancelClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiCreateNewRoleCancelClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiCreateNewRoleCancelClick(v)
        }
      }()
      case 26: try {
        var v: Teleport_Usageevents_V1_UICreateNewRoleViewDocumentationClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiCreateNewRoleViewDocumentationClick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiCreateNewRoleViewDocumentationClick(v)
        }
      }()
      case 27: try {
        var v: Teleport_Usageevents_V1_UIDiscoverIntegrationAWSOIDCConnectEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverIntegrationAwsOidcConnectEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverIntegrationAwsOidcConnectEvent(v)
        }
      }()
      case 28: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDatabaseRDSEnrollEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDatabaseRdsEnrollEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDatabaseRdsEnrollEvent(v)
        }
      }()
      case 29: try {
        var v: Teleport_Usageevents_V1_UICallToActionClickEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiCallToActionClickEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiCallToActionClickEvent(v)
        }
      }()
      case 30: try {
        var v: Teleport_Usageevents_V1_AssistCompletionEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .assistCompletion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .assistCompletion(v)
        }
      }()
      case 31: try {
        var v: Teleport_Usageevents_V1_UIIntegrationEnrollStartEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiIntegrationEnrollStartEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiIntegrationEnrollStartEvent(v)
        }
      }()
      case 32: try {
        var v: Teleport_Usageevents_V1_UIIntegrationEnrollCompleteEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiIntegrationEnrollCompleteEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiIntegrationEnrollCompleteEvent(v)
        }
      }()
      case 33: try {
        var v: Teleport_Usageevents_V1_UIOnboardQuestionnaireSubmitEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiOnboardQuestionnaireSubmit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiOnboardQuestionnaireSubmit(v)
        }
      }()
      case 34: try {
        var v: Teleport_Usageevents_V1_AssistExecutionEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .assistExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .assistExecution(v)
        }
      }()
      case 35: try {
        var v: Teleport_Usageevents_V1_AssistNewConversationEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .assistNewConversation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .assistNewConversation(v)
        }
      }()
      case 36: try {
        var v: Teleport_Usageevents_V1_ResourceCreateEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .resourceCreateEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .resourceCreateEvent(v)
        }
      }()
      case 37: try {
        var v: Teleport_Usageevents_V1_FeatureRecommendationEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .featureRecommendationEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .featureRecommendationEvent(v)
        }
      }()
      case 38: try {
        var v: Teleport_Usageevents_V1_AssistAccessRequest?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .assistAccessRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .assistAccessRequest(v)
        }
      }()
      case 39: try {
        var v: Teleport_Usageevents_V1_AssistAction?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .assistAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .assistAction(v)
        }
      }()
      case 40: try {
        var v: Teleport_Usageevents_V1_AccessListCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListCreate(v)
        }
      }()
      case 41: try {
        var v: Teleport_Usageevents_V1_AccessListUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListUpdate(v)
        }
      }()
      case 42: try {
        var v: Teleport_Usageevents_V1_AccessListDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListDelete(v)
        }
      }()
      case 43: try {
        var v: Teleport_Usageevents_V1_AccessListMemberCreate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListMemberCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListMemberCreate(v)
        }
      }()
      case 44: try {
        var v: Teleport_Usageevents_V1_AccessListMemberUpdate?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListMemberUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListMemberUpdate(v)
        }
      }()
      case 45: try {
        var v: Teleport_Usageevents_V1_AccessListMemberDelete?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListMemberDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListMemberDelete(v)
        }
      }()
      case 46: try {
        var v: Teleport_Usageevents_V1_AccessListGrantsToUser?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accessListGrantsToUser(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accessListGrantsToUser(v)
        }
      }()
      case 47: try {
        var v: Teleport_Usageevents_V1_UIDiscoverEC2InstanceSelectionEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverEc2InstanceSelection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverEc2InstanceSelection(v)
        }
      }()
      case 48: try {
        var v: Teleport_Usageevents_V1_UIDiscoverDeployEICEEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverDeployEice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverDeployEice(v)
        }
      }()
      case 49: try {
        var v: Teleport_Usageevents_V1_UIDiscoverCreateNodeEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .uiDiscoverCreateNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .uiDiscoverCreateNode(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .uiBannerClick?: try {
      guard case .uiBannerClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .uiOnboardCompleteGoToDashboardClick?: try {
      guard case .uiOnboardCompleteGoToDashboardClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .uiOnboardAddFirstResourceClick?: try {
      guard case .uiOnboardAddFirstResourceClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .uiOnboardAddFirstResourceLaterClick?: try {
      guard case .uiOnboardAddFirstResourceLaterClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .uiOnboardSetCredentialSubmit?: try {
      guard case .uiOnboardSetCredentialSubmit(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .uiOnboardRegisterChallengeSubmit?: try {
      guard case .uiOnboardRegisterChallengeSubmit(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .uiRecoveryCodesContinueClick?: try {
      guard case .uiRecoveryCodesContinueClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .uiRecoveryCodesCopyClick?: try {
      guard case .uiRecoveryCodesCopyClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .uiRecoveryCodesPrintClick?: try {
      guard case .uiRecoveryCodesPrintClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .uiDiscoverStartedEvent?: try {
      guard case .uiDiscoverStartedEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .uiDiscoverResourceSelectionEvent?: try {
      guard case .uiDiscoverResourceSelectionEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .uiDiscoverDeployServiceEvent?: try {
      guard case .uiDiscoverDeployServiceEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .uiDiscoverDatabaseRegisterEvent?: try {
      guard case .uiDiscoverDatabaseRegisterEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .uiDiscoverDatabaseConfigureMtlsEvent?: try {
      guard case .uiDiscoverDatabaseConfigureMtlsEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent?: try {
      guard case .uiDiscoverDesktopActiveDirectoryToolsInstallEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .uiDiscoverDesktopActiveDirectoryConfigureEvent?: try {
      guard case .uiDiscoverDesktopActiveDirectoryConfigureEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .uiDiscoverAutoDiscoveredResourcesEvent?: try {
      guard case .uiDiscoverAutoDiscoveredResourcesEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .uiDiscoverDatabaseConfigureIamPolicyEvent?: try {
      guard case .uiDiscoverDatabaseConfigureIamPolicyEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .uiDiscoverPrincipalsConfigureEvent?: try {
      guard case .uiDiscoverPrincipalsConfigureEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .uiDiscoverTestConnectionEvent?: try {
      guard case .uiDiscoverTestConnectionEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .uiDiscoverCompletedEvent?: try {
      guard case .uiDiscoverCompletedEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .uiCreateNewRoleClick?: try {
      guard case .uiCreateNewRoleClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .uiCreateNewRoleSaveClick?: try {
      guard case .uiCreateNewRoleSaveClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .uiCreateNewRoleCancelClick?: try {
      guard case .uiCreateNewRoleCancelClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .uiCreateNewRoleViewDocumentationClick?: try {
      guard case .uiCreateNewRoleViewDocumentationClick(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .uiDiscoverIntegrationAwsOidcConnectEvent?: try {
      guard case .uiDiscoverIntegrationAwsOidcConnectEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .uiDiscoverDatabaseRdsEnrollEvent?: try {
      guard case .uiDiscoverDatabaseRdsEnrollEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .uiCallToActionClickEvent?: try {
      guard case .uiCallToActionClickEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .assistCompletion?: try {
      guard case .assistCompletion(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .uiIntegrationEnrollStartEvent?: try {
      guard case .uiIntegrationEnrollStartEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .uiIntegrationEnrollCompleteEvent?: try {
      guard case .uiIntegrationEnrollCompleteEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .uiOnboardQuestionnaireSubmit?: try {
      guard case .uiOnboardQuestionnaireSubmit(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .assistExecution?: try {
      guard case .assistExecution(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .assistNewConversation?: try {
      guard case .assistNewConversation(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .resourceCreateEvent?: try {
      guard case .resourceCreateEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .featureRecommendationEvent?: try {
      guard case .featureRecommendationEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .assistAccessRequest?: try {
      guard case .assistAccessRequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .assistAction?: try {
      guard case .assistAction(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .accessListCreate?: try {
      guard case .accessListCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .accessListUpdate?: try {
      guard case .accessListUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .accessListDelete?: try {
      guard case .accessListDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .accessListMemberCreate?: try {
      guard case .accessListMemberCreate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .accessListMemberUpdate?: try {
      guard case .accessListMemberUpdate(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .accessListMemberDelete?: try {
      guard case .accessListMemberDelete(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .accessListGrantsToUser?: try {
      guard case .accessListGrantsToUser(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .uiDiscoverEc2InstanceSelection?: try {
      guard case .uiDiscoverEc2InstanceSelection(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .uiDiscoverDeployEice?: try {
      guard case .uiDiscoverDeployEice(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .uiDiscoverCreateNode?: try {
      guard case .uiDiscoverCreateNode(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Usageevents_V1_UsageEventOneOf, rhs: Teleport_Usageevents_V1_UsageEventOneOf) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
