// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: teleport/lib/teleterm/v1/access_request.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Teleport
// Copyright (C) 2023  Gravitational, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Teleport_Lib_Teleterm_V1_AccessRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// the request state of Access Request. option of PENDING, APPROVED, DENIED, PROMOTED, NONE
  var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var resolveReason: String {
    get {return _storage._resolveReason}
    set {_uniqueStorage()._resolveReason = newValue}
  }

  var requestReason: String {
    get {return _storage._requestReason}
    set {_uniqueStorage()._requestReason = newValue}
  }

  /// user is the user who submitted the Access Request
  var user: String {
    get {return _storage._user}
    set {_uniqueStorage()._user = newValue}
  }

  /// a list of roles requested
  var roles: [String] {
    get {return _storage._roles}
    set {_uniqueStorage()._roles = newValue}
  }

  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {_uniqueStorage()._created = nil}

  var expires: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expires ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expires = newValue}
  }
  /// Returns true if `expires` has been explicitly set.
  var hasExpires: Bool {return _storage._expires != nil}
  /// Clears the value of `expires`. Subsequent reads from it will return its default value.
  mutating func clearExpires() {_uniqueStorage()._expires = nil}

  var reviews: [Teleport_Lib_Teleterm_V1_AccessRequestReview] {
    get {return _storage._reviews}
    set {_uniqueStorage()._reviews = newValue}
  }

  var suggestedReviewers: [String] {
    get {return _storage._suggestedReviewers}
    set {_uniqueStorage()._suggestedReviewers = newValue}
  }

  /// thresholds specifies minimum amount of approvers or deniers. Defaults to 'default'
  var thresholdNames: [String] {
    get {return _storage._thresholdNames}
    set {_uniqueStorage()._thresholdNames = newValue}
  }

  /// TODO(avatus) remove the resource_ids field once the changes to rely on resources instead is merged
  /// a list of resourceIDs requested in the AccessRequest
  var resourceIds: [Teleport_Lib_Teleterm_V1_ResourceID] {
    get {return _storage._resourceIds}
    set {_uniqueStorage()._resourceIds = newValue}
  }

  var resources: [Teleport_Lib_Teleterm_V1_Resource] {
    get {return _storage._resources}
    set {_uniqueStorage()._resources = newValue}
  }

  /// promoted_access_list_title is the title of the access
  /// list that this access request was promoted to.
  var promotedAccessListTitle: String {
    get {return _storage._promotedAccessListTitle}
    set {_uniqueStorage()._promotedAccessListTitle = newValue}
  }

  /// assume_start_time is the time after which the requested access can be assumed.
  var assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._assumeStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._assumeStartTime = newValue}
  }
  /// Returns true if `assumeStartTime` has been explicitly set.
  var hasAssumeStartTime: Bool {return _storage._assumeStartTime != nil}
  /// Clears the value of `assumeStartTime`. Subsequent reads from it will return its default value.
  mutating func clearAssumeStartTime() {_uniqueStorage()._assumeStartTime = nil}

  /// max_duration is the maximum duration for which the request is valid.
  var maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._maxDuration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._maxDuration = newValue}
  }
  /// Returns true if `maxDuration` has been explicitly set.
  var hasMaxDuration: Bool {return _storage._maxDuration != nil}
  /// Clears the value of `maxDuration`. Subsequent reads from it will return its default value.
  mutating func clearMaxDuration() {_uniqueStorage()._maxDuration = nil}

  /// request_ttl is the expiration time of the request (how long it will await
  /// approval).
  var requestTtl: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._requestTtl ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._requestTtl = newValue}
  }
  /// Returns true if `requestTtl` has been explicitly set.
  var hasRequestTtl: Bool {return _storage._requestTtl != nil}
  /// Clears the value of `requestTtl`. Subsequent reads from it will return its default value.
  mutating func clearRequestTtl() {_uniqueStorage()._requestTtl = nil}

  /// session_ttl indicates how long a certificate for a session should be valid for.
  var sessionTtl: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._sessionTtl ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._sessionTtl = newValue}
  }
  /// Returns true if `sessionTtl` has been explicitly set.
  var hasSessionTtl: Bool {return _storage._sessionTtl != nil}
  /// Clears the value of `sessionTtl`. Subsequent reads from it will return its default value.
  mutating func clearSessionTtl() {_uniqueStorage()._sessionTtl = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Teleport_Lib_Teleterm_V1_AccessRequestReview: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// author is the creator of the AccessRequestReview.
  var author: String = String()

  /// list of roles approved
  var roles: [String] = []

  /// the state of the review, either APPROVED or DENIED
  var state: String = String()

  /// reason is why the request was approved or denied
  var reason: String = String()

  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  /// promoted_access_list_title is the title of the access
  /// list that the access request was promoted to.
  var promotedAccessListTitle: String = String()

  /// if not a nil value, this reviewer overwrote
  /// the requested start time.
  var assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _assumeStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_assumeStartTime = newValue}
  }
  /// Returns true if `assumeStartTime` has been explicitly set.
  var hasAssumeStartTime: Bool {return self._assumeStartTime != nil}
  /// Clears the value of `assumeStartTime`. Subsequent reads from it will return its default value.
  mutating func clearAssumeStartTime() {self._assumeStartTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Teleport_Lib_Teleterm_V1_ResourceID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: String = String()

  var name: String = String()

  var clusterName: String = String()

  var subResourceName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Teleport_Lib_Teleterm_V1_ResourceDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hostname: String = String()

  var friendlyName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Teleport_Lib_Teleterm_V1_Resource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Teleport_Lib_Teleterm_V1_ResourceID {
    get {return _id ?? Teleport_Lib_Teleterm_V1_ResourceID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var details: Teleport_Lib_Teleterm_V1_ResourceDetails {
    get {return _details ?? Teleport_Lib_Teleterm_V1_ResourceDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {self._details = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Teleport_Lib_Teleterm_V1_ResourceID? = nil
  fileprivate var _details: Teleport_Lib_Teleterm_V1_ResourceDetails? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "teleport.lib.teleterm.v1"

extension Teleport_Lib_Teleterm_V1_AccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "state"),
    3: .standard(proto: "resolve_reason"),
    4: .standard(proto: "request_reason"),
    5: .same(proto: "user"),
    6: .same(proto: "roles"),
    7: .same(proto: "created"),
    8: .same(proto: "expires"),
    9: .same(proto: "reviews"),
    10: .standard(proto: "suggested_reviewers"),
    11: .standard(proto: "threshold_names"),
    12: .standard(proto: "resource_ids"),
    13: .same(proto: "resources"),
    14: .standard(proto: "promoted_access_list_title"),
    15: .standard(proto: "assume_start_time"),
    16: .standard(proto: "max_duration"),
    17: .standard(proto: "request_ttl"),
    18: .standard(proto: "session_ttl"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _state: String = String()
    var _resolveReason: String = String()
    var _requestReason: String = String()
    var _user: String = String()
    var _roles: [String] = []
    var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expires: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _reviews: [Teleport_Lib_Teleterm_V1_AccessRequestReview] = []
    var _suggestedReviewers: [String] = []
    var _thresholdNames: [String] = []
    var _resourceIds: [Teleport_Lib_Teleterm_V1_ResourceID] = []
    var _resources: [Teleport_Lib_Teleterm_V1_Resource] = []
    var _promotedAccessListTitle: String = String()
    var _assumeStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _maxDuration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _requestTtl: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _sessionTtl: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _state = source._state
      _resolveReason = source._resolveReason
      _requestReason = source._requestReason
      _user = source._user
      _roles = source._roles
      _created = source._created
      _expires = source._expires
      _reviews = source._reviews
      _suggestedReviewers = source._suggestedReviewers
      _thresholdNames = source._thresholdNames
      _resourceIds = source._resourceIds
      _resources = source._resources
      _promotedAccessListTitle = source._promotedAccessListTitle
      _assumeStartTime = source._assumeStartTime
      _maxDuration = source._maxDuration
      _requestTtl = source._requestTtl
      _sessionTtl = source._sessionTtl
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._resolveReason) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._requestReason) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._user) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._roles) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._created) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._expires) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._reviews) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._suggestedReviewers) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._thresholdNames) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._resourceIds) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._resources) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._promotedAccessListTitle) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._assumeStartTime) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._maxDuration) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._requestTtl) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._sessionTtl) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 2)
      }
      if !_storage._resolveReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resolveReason, fieldNumber: 3)
      }
      if !_storage._requestReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestReason, fieldNumber: 4)
      }
      if !_storage._user.isEmpty {
        try visitor.visitSingularStringField(value: _storage._user, fieldNumber: 5)
      }
      if !_storage._roles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._roles, fieldNumber: 6)
      }
      try { if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._expires {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._reviews.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reviews, fieldNumber: 9)
      }
      if !_storage._suggestedReviewers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._suggestedReviewers, fieldNumber: 10)
      }
      if !_storage._thresholdNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._thresholdNames, fieldNumber: 11)
      }
      if !_storage._resourceIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._resourceIds, fieldNumber: 12)
      }
      if !_storage._resources.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._resources, fieldNumber: 13)
      }
      if !_storage._promotedAccessListTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._promotedAccessListTitle, fieldNumber: 14)
      }
      try { if let v = _storage._assumeStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._maxDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._requestTtl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._sessionTtl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_AccessRequest, rhs: Teleport_Lib_Teleterm_V1_AccessRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._resolveReason != rhs_storage._resolveReason {return false}
        if _storage._requestReason != rhs_storage._requestReason {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._roles != rhs_storage._roles {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._expires != rhs_storage._expires {return false}
        if _storage._reviews != rhs_storage._reviews {return false}
        if _storage._suggestedReviewers != rhs_storage._suggestedReviewers {return false}
        if _storage._thresholdNames != rhs_storage._thresholdNames {return false}
        if _storage._resourceIds != rhs_storage._resourceIds {return false}
        if _storage._resources != rhs_storage._resources {return false}
        if _storage._promotedAccessListTitle != rhs_storage._promotedAccessListTitle {return false}
        if _storage._assumeStartTime != rhs_storage._assumeStartTime {return false}
        if _storage._maxDuration != rhs_storage._maxDuration {return false}
        if _storage._requestTtl != rhs_storage._requestTtl {return false}
        if _storage._sessionTtl != rhs_storage._sessionTtl {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_AccessRequestReview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessRequestReview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "author"),
    2: .same(proto: "roles"),
    3: .same(proto: "state"),
    4: .same(proto: "reason"),
    5: .same(proto: "created"),
    6: .standard(proto: "promoted_access_list_title"),
    7: .standard(proto: "assume_start_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.author) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.promotedAccessListTitle) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._assumeStartTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.author.isEmpty {
      try visitor.visitSingularStringField(value: self.author, fieldNumber: 1)
    }
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 2)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.promotedAccessListTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.promotedAccessListTitle, fieldNumber: 6)
    }
    try { if let v = self._assumeStartTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_AccessRequestReview, rhs: Teleport_Lib_Teleterm_V1_AccessRequestReview) -> Bool {
    if lhs.author != rhs.author {return false}
    if lhs.roles != rhs.roles {return false}
    if lhs.state != rhs.state {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._created != rhs._created {return false}
    if lhs.promotedAccessListTitle != rhs.promotedAccessListTitle {return false}
    if lhs._assumeStartTime != rhs._assumeStartTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ResourceID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "name"),
    3: .standard(proto: "cluster_name"),
    4: .standard(proto: "sub_resource_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subResourceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kind.isEmpty {
      try visitor.visitSingularStringField(value: self.kind, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 3)
    }
    if !self.subResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.subResourceName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_ResourceID, rhs: Teleport_Lib_Teleterm_V1_ResourceID) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.name != rhs.name {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.subResourceName != rhs.subResourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_ResourceDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostname"),
    2: .standard(proto: "friendly_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.friendlyName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 1)
    }
    if !self.friendlyName.isEmpty {
      try visitor.visitSingularStringField(value: self.friendlyName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_ResourceDetails, rhs: Teleport_Lib_Teleterm_V1_ResourceDetails) -> Bool {
    if lhs.hostname != rhs.hostname {return false}
    if lhs.friendlyName != rhs.friendlyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Teleport_Lib_Teleterm_V1_Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Resource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Teleport_Lib_Teleterm_V1_Resource, rhs: Teleport_Lib_Teleterm_V1_Resource) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
